model checking java programs using structural heuristics describe work troducing heuristic search java pathfinder model checker targets java bytecode rather focusing heuristics aimed particular kind error deadlocks describe heuristics based modification traditional branch coverage metrics structure measures thread interdependency present experimental results showing utility heuristics argue usefulness structural heuristics class b introduction recent interest model checking software written real programming languages 3 10 15 24 25 33 using heuristics direct exploration explicitstate model checkers 12 35 heuristicguided search clearly directed nding errors rather verifying complete correctness software connections model checking testing made particularly clear ideas combined paper present one fruitful product intersection elds show apply nding errors programs primary challenge software model checking model checking state space explosion problem exploring behaviors system say least dicult number behaviors exponential possible inputs contents data structures number threads program vast array techniques applied problem 8 rst hardware verication increasingly software verication 3 10 21 many techniques require considerable nonautomatic work present basic heuristic framework discuss creation user dened heuristics tool paper elsewhere 18 italy experts apply well software hardware techniques aimed reducing size total state space must explored representing symbolically reduce memory time needed exploration alternative approach concentrate verifying correctness programs dealing state space explosion attempting nd errors rather reducing overall size state space attempt nd counterexample state explosion exhausts memory heuristic model checking usually aims generating counterexamples searching bugcontaining part state space rst obviously know general part programs state space going contain error even error present however using measurements exploration programs structure particular branching structure thread interdependency structure believe model checker often improve ability nd errors programs although one strongest advantages model checking generation counterexamples verication fails traditional depthrst search algorithms tend return long counterexamples heuristic search succeeds almost always produces much succinct counterexamples paper explore heuristic model checking software written java programming language use heuristics based coverage measurements derived world software testing introduce notion structural heuristics classication heuristics used model checking present describe motivations de veloping successful novel heuristics class paper organized follows section 2 describes heuristic model checking examines related work introduces various search algorithms using section 3 brie presents java pathfinder model checker implementation heuristic search new heuristics dened described detail section 4 also includes experimental results present conclusions consider future work nal section 2 heuristic model checking heuristic directed model checking state space explored order dependent evaluation function states function heuristic usually intended guide model checker quickly error state priority queue q empty q best f remove q successor state 0 0 already visited goal terminate store figure 1 algorithm bestrst search resulting counterexamples often shorter ones produced depthrst search based algorithms traditionally used explicitstate model checkers growing body literature model checking using heuristics largely concentrates heuristics tailored nd certain kind error 12 16 22 26 35 common heuristics include measuring lengths queues giving preference blocking operations 12 26 using hamming distance goal state 14 35 godefroid khurshid apply genetic algorithm techniques rather basic heuristic searches using heuristics measuring outgoing transitions state similar mostblocked heuristic see table 1 rewarding evaluations assertions measuring messages exchanged security protocol 16 heuristics also used symbolic model checking reduce bottlenecks image computation without necessarily attempting zero errors bloem ravi thus draw distinction propertydependent systemdependent heuristics 5 note propertydependent heuristics applied explicit state model checking sense exploring state space dierent order remove bottlenecks event entire space must explored however suggest classication propertydependent heuristics propertyspecic heuristics rely features particular property queue sizes blocking statements deadlock distance control data ow false valuations assertions structural heuristics attempt explore structure program way conducive nding general errors heuristic used flavers would example latter 9 concentrate primarily structural heuristics rene notion examined heuristics heuristics also used generating test cases 29 furthermore model checker used test case generation 1 2 approach applicable test case generation applies coverage metrics used testing usual model checking goal nding errors program 21 search algorithms number dierent search algorithms combined heuristics simplest bestrst search uses heuristic function h compute tness f greedy fashion figure 1 algorithm 19 similar except like dijkstras shortest paths algorithm adds length path 0 f heuristic function h admissible hs 0 guaranteed less equal queue q empty q empty priority queue remove q successor state 0 0 already visited goal terminate store remove k best elements q 0 figure 2 algorithm beam search length shortest path 0 goal state guaranteed nd optimal solution purposes shortest counterexample compromise guaranteed optimality breadthrst search eciency returning solution bestrst search beamsearch proceeds even like breadthrst search uses heuristic function discard k best candidate states depth figure 2 queuelimiting technique used beamsearch may also applied bestrst search removing worst state q without expanding children whenever inserting 0 results q containing k states course introduces incompleteness model checking run termination without reported errors indicate errors exist state space however given advantage heuristic search ability quickly discover fairly short counterexamples practice queuelimiting eective bugnding tactic experimental results section 4 show varying utility dierent search strategies none heuristics examined admissible lacks theoretical optimality generally less ecient bestrst search heuristic value sometimes much larger path length case behaves much like bestrst search far aware combining bestrst search limitations size queue storing states pending discussed given name literature heuristic search bestrst search queue limiting nd deep solutions might dicult beamsearch reach unless queue limit k small specically introduction queuelimiting heuristic search model checking appears genuinely novel raises possibility using incomplete methods focus model checking discovery errors rather verication example partial order reduction techniques usually require cycle check may expensive overconservative context heuristic search 13 however queuelimiting considered natural experiment applying partial order reduction without cycle check general approach remains one model checking rather testing storing states already visited crucial obtaining good results experience one notable exception see discussion sections 411 421 3 java pathfinder java pathfinder jpf explicit state onthe model checker takes compiled java programs ie bytecode classles analyzes paths program deadlock assertion violations linear time temporal logic ltl properties 33 jpf unique built custommade java virtual machine jvm therefore require translation existing model checkers input notation dspin model checker 25 extends spin 23 handle dynamic memory allocation functions closely related system jpf model checker java support nondeterminism model checking context often important analyze behavior program aggressive environment possible actions order must considered reason added methods special class called verify allow nondeterminism expressed example verifyrandom2 nondeterministically return value range 02 inclusive model checker trap execution evaluate possible values important feature model checker exibility choosing granularity transition states analysis bytecode since model checker executes bytecode instructions negrained analysis supported level individual bytecodes un fortunately large programs bytecodelevel analysis scale well therefore default mode analyze code linebyline basis jpf also supports atomic constructs denoted verifybeginatomic verifyendatomic calls model checker trap allow larger code fragments grouped single transition model checker consists two basic components state generator includes jvm information scheduling state storage facilities required keep track executed states visited default exploration jpf depthrst generation state space option limit search maximum depth changing scheduling information one change way state space generated default stack used record states expanded next hence default dfs search analysis algorithms includes algorithms checking deadlocks assertion violations violation ltl properties algorithms work instructing state generation component generate new states backtrack old states check state jvm api calls eg check deadlock reached heuristics jpf implemented state generator component since many heuristics require information jvm natural way implementation adapt scheduling state explore next eg trivial case breathrst search one changes stack queue bestrst also used beamsearch straightforward implementations algorithms listed section 21 using priority queues within scheduler heuristic search capabilities currently limited deadlock assertion violation checks none heuristic search algorithms particularly suited cycle detection important part checking ltl properties addition limited experimental data improving cycles counterexamples liveness properties encouraging 14 heuristic search jpf also provides number additional features including users introduce heuristics interfacing jvm welldened api access program variables etc sum two heuristics used order analysis states heuristic value altered number elements priority queue limited search depth limited 4 structural heuristics consider following heuristics structural heuris tics intended nd errors targeted specically particular assertion statements variants deadlocks rather explore structural aspect program branching structure thread interdependence 41 code coverage heuristics code coverage achieved testing measure adequacy testing words quality set test cases although directly address correctness code test achieved high code coverage testing without discovering errors inspire condence code correct case point avionics industry software certied ight 100 structural coverage specically modied conditiondecision coverage mcdc achieved testing 30 testing literature vast number structural code coverage criteria simply covering statements program covering possible execution paths focus branch coverage requires every branching point program possible branches taken least many industries 100 branch coverage considered minimum requirement test adequacy 4 face one might wonder coverage model checking worth since model checkers typically cover state space system analysis hence denition covering structure code however model checking java programs programs often innitestate large nite state space model checker cannot cover due 1 states covering previously untaken branch receive best heuristic value 2 states reached taking branch receive next best heuristic value 3 states cover branch already taken ranked according many times branch taken worse scores assigned frequently taken branches figure 3 basic branchcoverage heuristic resource limitations typically memory calculating coverage therefore serves purpose testing shows adequacy partial model checking run test coverage tools calculating branch coverage model checking requires us keep track whether structural branching point options taken since jpf executes bytecode statements means simple extensions need introduced whenever related ifstatement code tableswitch related casestatements executed keep track choices made however unlike simple branch coverage also keep track many times branch taken rather whether taken consider coverage separately thread created execution program rst benet feature model checker produce detailed coverage information exhausts memory without nding counterexample searching entire state space additionally coverage metrics useful measurement set test cases seems plausible using coverage heuristic prioritize exploration state space might useful one approach using coverage metrics heuristic would simply use percentage branches covered perthread global basis heuristic value refer coverage heuristic however approach work well practice see section 411 instead slightly complex heuristic proves successful figure 3 motivation behind heuristic make use branching structure program avoiding pitfalls direct heuristic coverage heuristic likely fall local minima exploring paths cover large number branches future increase coverage heuristic behaves essentially breadthrst manner unless path actually increasing coverage default system explores states heuristic value fifo manner resulting breadthrst exploration program branch choices however frontier much deeper along paths previously increased coverage still advance exploration structurally interesting paths heuristic delays exploration repetitive portions state space take branches repeatedly nondeterminisic choice determines many times execute loop instance heuristic delay exploring multiple iterations loop along certain paths searched along paths skip loop execute thus achieve deeper coverage structure examine possible behaviors termination loop paths beyond loop continue free branches involve previously uncovered branches exploration continue however one paths leads loop return explore iterations rst loop executing latter loop number options modify basic strategy counts may taken globally entire state space explored path particular state reached allows us examine either combinations choices along path try maximize branch choices entire search ordering along paths less relevant prin ciple pathbased approach useful taking certain branches particular combination execution responsible errors global counts useful simply exercising branches better way nd error instance latter would program one large nondeterministic choice beginning results different classes shallow executions one leads error state branch count may allowed persist state reached without covering branches last branch count path state reached may used instead giving state second best heuristic value see figure 3 allows us increase tendency explore paths improved coverage without quite prone falling local minima coverage heuristic counts path summed reduce searchs sensitivity individual branch choices various methods also applied counts taken executions individual bytecode struction rather branches equivalent idea statement coverage traditional testing practical eect class heuristic increase exploration portions state space nondeterministic choices thread interleavings resulted possibility previously unexplored lessexplored branches taken 411 experimental results refer number heuristics experimental results table 1 addition basic heuristics indicate whether heuristic measured paths states appending path global op tion results beam search also noted denition branch basic branchcoverage heuristic coverage measures percentage branches covered states higher coverage receive better values bfs breadthrst search dfs depthrst search depth n indicates stack depth limited n mostblocked measures number blocked threads blocked threads result better values interleaving measures amount interleaving threads see section 42 random uses randomly assigned heuristic value table 1 heuristics search strategies deos realtime operating system developed honeywell enables integrated modular avionics ima currently used within certain small business aircraft schedule timecritical software tasks development routine code inspection led uncovering subtle error timepartitioning could allow tasks starved cpu time sequence unanticipated api calls made near timeperiod boundaries would trigger error inter estingly although avionics software needs tested high degree 100 mcdc coverage certied ight error uncovered testing model checking used rediscover error using translation promela input language spin model checker 28 later java translation original c code used detect error versions use abstraction nd error see discussion section 43 results table 2 version java code abstract away innitestate counter straightforward translation original c code java coverage heuristic indeed appear easily become trapped local minima admissible using search necessarily help comparison results using heuristics also give results breadthrst search bfs depthrst search dfs depthrst searches limited certain maximum depth essentially innite state systems version deos limiting depth practical way use dfs seen nding proper depth dicult large depths may result extremely long counterexamples using purely random heuristic fact nd counterexample deos however counterexample considerably longer takes time memory produce coverage heuristics also applied successful heuristics deos system storing visited states turned ing testing simulation rather model checking essen tially without state storage heuristics failed nd counterexample exhausting memory 42 thread interleaving heuristics dierent kind structural heuristic based maximizing thread interleavings testing generally scheduler cannot controlled directly often misses subtle race conditions deadlocks rely unlikely thread scheduling one way expose concurrency errors step execution append thread executed thread history pass history making heuristic value returned worse time thread executed appears history value proportional 1 far back history execution 2 current number live threads figure 4 basic interleaving heuristic reward demonic scheduling assigning better heuristic values states reached paths involving switching threads case structure attempt explore dependency threads precise ordering nonlocked variable accessed thread instance another thread also access variable leading race condition result deadlock assertion violation path preferred one accessing thread continues onwards perhaps escaping effects race condition reading justaltered value calculate heuristic keeping possibly limited history threads scheduled path figure 4 421 experimental results may 1999 deepspace 1 spacecraft ran set experiments whereby spacecraft control aibased system called remote agent unfortu nately one experiments software went deadlock state restarted earth cause error time unknown study likely components caused error identied error found applying model checking java version code error due missing critical section causing race violation occur certain thread interleavings introducing deadlock 20 results table use version code faithful original system also includes parts system involved deadlock experiments examples presented interest space indicate beamsearch certainly perform well times generally perform well bestrst search heuristics admissible optimality advantages come play general appear require judicious choice queuelimits necessary bestrst search finally dining philosophers table 4 show interleaving heuristic scale quite large numbers threads dfs fails uncover counterexamples even small problem sizes interleaving heuristic produce short counterexamples 64 threads mostblocked heuristic designed detect deadlocks generally returns larger counterexamples case size 8 queue limit 5 larger factor thousand longer time interleaving heuristic even importantly scale well larger numbers explored length max depth branch path branch branch global branch coverage path fails 20215 334 coverage coverage global fails 20213 334 random 162 240 8057 334 360 dfs depth 500 6782 383 392479 455 500 dfs depth 1000 2222 196 146949 987 1000 dfs depth 4000 171 270 8481 3997 4000 results state storage turned branchglobal table 2 experimental results deos system results obtained 14 ghz athlon jpf limited 512mb times seconds memory megabytes fails indicates failure due running memory length column reports length counterexample one found max depth column reports length longest path explored maximum stack depth depthrst case explored length max depth branch path queue 40 fails 1765009 12092 branch path queue 160 fails 1506725 5885 branch path queue 1000 132 290 845263 136 136 branch global queue 40 fails 1758416 12077 branch global queue 160 fails 1483827 1409 branch global queue 1000 fails 1509810 327 random fails 55940 472 dfs depth 500 43 54 116071 500 500 dfs depth 1000 44 64 117235 1000 1000 interleaving fails 378068 81 interleaving queue 5 15 17 38449 913 913 interleaving queue 40 116 184 431752 869 869 interleaving queue 160 908 501 1287984 869 870 interleaving queue 1000 fails 745788 177 interleaving interleaving queue 5 interleaving queue 40 interleaving queue 160 interleaving queue 1000 interleaving queue 5 beam 14 interleaving queue 40 beam 91 113 238945 924 924 interleaving queue 160 beam 386 418 1025595 898 898 interleaving queue 1000 beam fails 1604940 365 mostblocked 7 33 7537 158 169 mostblocked queue 5 fails 922433 27628 mostblocked queue 40 fails 913946 4923 mostblocked queue 160 fails 918575 1177 mostblocked queue mostblocked mostblocked queue 5 mostblocked queue 40 mostblocked queue 160 mostblocked queue 1000 table 3 experimental results remote agent system explored length max depth branch path 8 fails 374152 41 random 8 fails 218500 86 mostblocked 8 fails 310317 285 mostblocked queue 5 8 17259 378 891177 78353 78353 mostblocked queue mostblocked queue mostblocked queue 1000 8 46 59 123640 254 278 interleaving 8 fails 487942 interleaving queue interleaving queue interleaving queue interleaving queue 1000 8 mostblocked queue 5 mostblocked queue 40 mostblocked queue 160 mostblocked queue 1000 interleaving queue 5 interleaving queue 40 interleaving queue 160 interleaving queue 1000 mostblocked queue 40 interleaving queue 5 interleaving queue 40 interleaving queue 160 interleaving queue 5 64 59 206 101196 514 514 table 4 experimental results dining philosophers threads reported number philosopher threads results searches successful next smaller version problem results shown indicate fact failed searches tend succeed larger sizes key dierence approach using property specic heuristic structural heuristic seen dining philosophers example search wellknown deadlock scenario increasing number philosophers high enough example 16 becomes impossible explicitstate model checker try possible combinations actions get deadlock heuristics luck required propertyspecic heuristic applicable try maximize number blocked threads mostblocked heuristic table 1 since threads blocked deadlock java pro gram whereas structural heuristic may observe dealing highly concurrent program hence may argued error may well related unexpected interleaving hence use heuristic favor increased interleaving search interleaving heuristic table 1 although results means conclusive still worth noting specic example structural heuristic performs much better propertyspecic heuristic dining philosophers remote agent example also performed experiment turning storage interleaving heuristic results essentially unchanged minor variations length counterexamples number states searched believe return previously visited state case requires action sequence given good heuristic value interleaving heuristic example dining philosophers alternating picking dropping forks threads mostblocked heuristic however successful searches become unsuccessful removal state storage introduces possibility nontermination search example mostblocked heuristic without state storage may even terminate cases godefroid khurshid apply genetic algorithm techniques similar implementation dining philosophers written c rather java 16 seed genetic search randomly version 17 running threads reporting 50 success rate average search time 177 seconds slower machine used results suggest dierences may much result heuristics used something like mostblocked vs interleaving heuristic genetic search application heuristics dierent search frameworks interesting avenue future study 43 choosefree heuristic abstraction based overapproximations system behavior popular technique reducing size state space system allow ecient model checking 7 11 17 34 jpf supports two forms approximation predicate abstraction 34 typebased abstractions via bandera tool 11 however overapproximation well suited errordetection since additional behaviors introduced abstraction lead spurious errors present origi nal eliminating spurious errors active area research within model checking community 3 6 21 27 31 jpf uses novel technique elimination spurious errors called choosefree search 27 technique based fact overapproximations introduce nondeterministic choices abstract program present original therefore choosefree search rst searches part state space doesnt contain nondeterministic choices due abstraction error found socalled choosefree portion state space also error original program although technique may seem almost naive shown work remarkably well practice 11 27 rst implementation technique searching choosefree state space current implementation uses heuristic gives best heuristic values states fewest nondeterministic choice statements enabled ie allowing choosefree state space searched rst continuing rest state space otherwise also allows choosefree combined heuristics deos example abstracted using predicate abstraction 34 typebased abstraction 11 predicate abstraction deos precise abstraction ie introduce new behaviors present original hence focus typebased abstraction specically use range abstraction allowing values 1 concrete values 2 represented one abstract value appropriate variable 11 using choosefree heuristic discovered range abstraction heuristic search reports choosefree error length 26 20 seconds heuristics nding feasible counterexamples abstraction seen onthe underapproximation overapproximation abstraction system behavior heuristic aware falls similar category one reducing infeasible execution sequences flavers tool 9 5 conclusions future work heuristic search techniques traditionally used solve problems goal known welldened measure exists close one goal aim heuristic search guide search using mea sure achieve goal quickly fewest steps possible also traditional use heuristic search model checking heuristics dened regards property checked advocate complementary approach focus heuristic search structure state space searched case java program state space generated believe structural heuristics replace propertyspecic heuristics rather propose used complementary approach furthermore since testing domain long used notion structural code coverage seems appropriate investigate similar ideas context structural heuristics model checking shown realistic example deos heuristic based branch coverage relatively structural coverage measure gives encouraging results worth noting much stronger coverage measure mcdc help uncovering error testing ie 100 coverage achieved bug found conjecture use code coverage heuristic model checking lead classes errors found coverage measures testing uncover example branch coverage typically little use uncovering concurrency errors using heuristic model checking allow model checker evaluate interleavings might lead error branch coverage found deadlock remote agent example whereas traditional testing failed 2 number possible avenues future work experimental results make clear rather daunting array parameters available using heuristic search least heuristic search algorithm queue size must selected hope explore practicalities selecting options gathering experimental data determine instance appears proper queue size limits essential checking programs large number threads possibility would attempt apply algorithmic learning techniques nding good parameters heuristic model checking development structural heuristics renement presented also open problem instance analogous structures explored data structures program control structures explored branchcoverage heuristics imagine heuristics might relate particular kinds errors interleaving heuristic relates concurrency errors 6 r using model checking generate tests specications test generation recognition formal methods automatically validating temporal safety properties interfaces software testing techniques symbolic guided search ctl model checking model checking abstraction model checking right algorithm right time comparing data flow analysis algorithms finite state veri directed explicit model checking hsfspin partial order reduction directed model checking verisoft tool automatic analysis concurrent reactive software exploring large state spaces using genetic algorithms construction abstract state graphs pvs heuristic model checking java programs formal basis heuristic determination minimum path cost formal analysis remote agent flight lazy abstraction algorithms automated protocol veri state spin automating software feature veri dynamic extension spin protocol veri classical search strategies test case generation constraint logic programming rtca special committee 167 modular incremental analysis concurrent software systems automated framework structural testdata generation model checking programs using predicate abstraction reduce objectoriented programs model checking validation guided search state space tr software testing techniques 2nd ed model checking abstraction validation guided search state space model checking bandera symbolic guided search ctl model checking verification time partitioning deos scheduler kernel using predicate abstraction reduce objectoriented programs model checking directed explicit model checking hsfspin automatically validating temporal safety properties interfaces right algorithm right time toolsupported program abstraction finitestate verification lazy abstraction dspin heuristic model checking java programs partial order reduction directed model checking finding feasible counterexamples model checking abstracted java programs exploring large state spaces using genetic algorithms construction abstract state graphs pvs counterexampleguided abstraction refinement state spin automated framework structural testdata generation modular incremental analysis concurrent software systems model checking programs using model checking generate tests specifications ctr neha rungta eric g mercer contextsensitive structural heuristic guided search model checking proceedings 20th ieeeacm international conference automated software engineering november 0711 2005 long beach ca usa kevin seppi michael jones peter lamborn guided model checking bayesian metaheuristic fundamenta informaticae v70 n12 p111126 april 2006 madanlal musuvathi shaz qadeer iterative context bounding systematic testing multithreaded programs acm sigplan notices v42 n6 june 2007 guillaume brat doron drusinsky dimitra giannakopoulou allen goldberg klaus havelund mike lowry corina pasareanu arnaud venet willem visser rich washington experimental evaluation verification validation tools martian rover software formal methods system design v25 n23 p167198 septembernovember 2004 jianbin tan george avrunin lori clarke shlomo zilberstein stefan leue heuristicguided counterexample search flavers acm sigsoft software engineering notes v29 n6 november 2004 jianbin tan george avrunin lori clarke heuristicbased model refinement flavers proceedings 26th international conference software engineering p635644 may 2328 2004 oksana tkachuk sreeranga p rajan application automated environment generation commercial software proceedings 2006 international symposium software testing analysis july 1720 2006 portland maine usa dimitra giannakopoulou corina pasareanu jamieson cobleigh assumeguarantee verification source code designlevel assumptions proceedings 26th international conference software engineering p211220 may 2328 2004 robby matthew b dwyer john hatcliff bogor extensible highlymodular software model checking framework acm sigsoft software engineering notes v28 n5 september alexander pretschner heiko ltzbeyer jan philipps model based testing incremental system development journal systems software v70 n3 p315329 march 2004 cyrille artho howard barringer allen goldberg klaus havelund sarfraz khurshid mike lowry corina pasareanu grigore rosu koushik sen willem visser rich washington combining test case generation runtime verification theoretical computer science v336 n23 p209234 26 may 2005 john penix willem visser seungjoon park corina pasareanu eric engstrom aaron larson nicholas weininger verifying time partitioning deos scheduling kernel formal methods system design v26 n2 p103135 march 2005
ordered semantic hyperlinking ordered semantic hyperlinking strategy complete firstorder logic accepts userspecified natural semantics guides search proof semantics meanings function predicate symbols computable ground terms may used instancebased strategy efficient nearpropositional problems goal sensitive extension equality term rewriting however sometimes difficulty generating large terms compare strategy others use semantic information present proof soundness completeness also give theoretical results search efficiency strategy examples illustrate performance strategy b introduction least two basic approaches study automated deduction one approach concentrates solving hard problems especially interest human mathematicians notable successes area even proofs hitherto unproven conjectures served give field automated deduction respectability among mathematicians general public proofs may done without human interaction approach secondary interest whether prover solves hard problems weak easy problems another approach automated deduction concentrates building provers perform well broad range problems minimum human interaction approach make sense try hard problems ones prover still difficulty easy problems philosophy develop far possible theorem provers general problem solving ability advantage approach one likely obtain provers wellrounded long run possibly powerful disadvantage results may appear less spectacular especially early stages concentrated latter approach endeavor developed number provers recent years including modified problem reduction format pla88 extensions clause linking method lp92 clause linking semantics cp94a among others emphasized firstorder logic without equality provers become increasingly powerful able solve considerable range problems reach pre decessor little human guidance addition provers compete respectably wellknown powerful theorem provers certain types problems emphasized prolog implementation way rapidly implement test wide variety ideas little manpower means provers disadvantage respect provers carefully implemented c lisp since underlying language less efficient despite performance impressive would like carry investigation step incorporate kind ordering methods hyperlinking cp94a developed retain propositional advantages hyperlinking lp92 adding natural semantics goalsensitivity pla94a discuss issues propositional efficiency goalsensitivity pla94a pla94b thereby highlighting feel inefficiencies many common theorem proving strategies even hyperlinking without semantics performs much better resolution similar strategies hard problems particularly nonhorn problems show cp94a hyperlinking semantics sometimes much better still however still problem semantic hyperlinking would like solve cooperation semantic hyperlinking rough resolution seem clean could rough resolution cp93b version ordered resolution developed eliminate large literals proofs helpful semantic hyperlinking difficulties generating large literals therefore cooperation two methods seems attractive indeed show cp93b cooperation improves effectiveness semantic hyperlinking number problems however definition rough resolution seems arbitrary logical way eliminate large literals use ordered resolution described bg90 hr91 also manner semantic tree constructed searched seems arbitrary element also makes part method harder describe formally addition semantic hyperlinking rough resolution ur unit resulting resolution component prover described cp94a motivation rough resolution eliminates large literals proofs ur resolution eliminates horn parts proofs remains nonhorn proof small literals clause linking performs well problems however horn property really irrelevant since clause linking performs well problems small literals whether horn problems therefore seems logical eliminate ur resolution also choice rough resolutions urresolutions performed seems arbitrary extent prefer small clauses small proofs essentially motivation development ordered semantic hyperlinking simplify semantic hyperlinking much possible way hopefully extend peaks strength wider class problems also allow small easily understood implementation addition interested removing propositional inefficiencies termrewriting based theorem proving strategies strategies essentially reduce aordering sla67 firstorder logic without equality however pla94b show simple sets clauses aordering produces exponential search space regardless ordering chosen hand termrewriting methods often efficient extend naturally specialized theories bg94 furthermore certain sets clauses easily decided strategies based ordering fltz93 ordering based strategies decision procedure always terminating indicating whether set input clauses satisfiable however sublanguages firstorder logic decidable way clause linking therefore would like present semantic clause linking format facilitates transition termrewriting based theorem proving strategies thereby also providing way remove notable inefficiencies preserving advantages idea semantic hyperlinking show set clauses unsatisfiable failure systematic search model ordered semantic hyperlinking similar organizes search little differently basic principle behind ordered semantic hyperlinking following suppose set independent choices make process examining set possibilities thus potentially 2 n combinations choices altogether assume ordering choices make simplest choice first suppose p 1 simplest choices first consider alternatives p 1 notp 1 alternative recursively attempt solve problem reasoning may solve problem complex choices even seen thereby saving effort seems natural strategy standpoint human problem solving application theorem proving set choices infinite order made implications idea still furthermore problem semantic hyperlinking sometimes enumeration ground terms necessary would like method based unification instead enumeration ground terms proposed method incorporates unification natural way certain kinds semantics show enumeration phase done polynomial time additional reason believe new version better performance work required semantic hyperlinking strongly influenced number eligible literals generated proposed method reduce number thereby making method efficient permitting proofs require rounds search also consider complexity issues discussed part gou94 approach nonclausal analysis applies clausal framework shows fundamental problem associated mating and81 connection bib87 approach sigma p 2 complete approaches first choose number copies input clauses seek find single substitution makes given set copies clauses propositionally unsatisfiable general set clauses arbitrary number copies may needed goubaults result consequence effort prove theorem worst exponential size minimal proof using suitable implementation approaches proof size measured number instances input clauses appear proof precisely set input clauses clause appears n times proof effort exponential n times size written character string actually bad bound many methods considerably worse least relative measure proof size example clause linking double even triple exponential measure proof complexity reason proof containing n copies input clauses may involve number unifications proportional n unification increase size terms constant factor thus terms exponentially large generated number terms within exponential size bound double exponential time handle double exponential set ground clauses triple exponential altering measure term size repeated subterms counted reduced double exponential consider behavior ordered clause linking argue although worstcase bound double exponential reason believe many cases performance single exponential even better course may proofs many copies clauses needed term sizes small clauses clause linking would probably faster mating approach interesting proposed theorem prover incorporates number wellknown ai techniques including case analysis explanationbased generaliza tion procedural semantics describe semantics set clauses back tracking ordering criteria course unification firstorder logic therefore prover may independent interest standpoint artificial intelligence 2 orderings interpretations clauses idea ordered clause linking semantics place total ordering set atoms based define lexicographic total ordering set interpretations atoms semantic hyperlinking seen systematic search model set clauses search fails know unsatisfiable search semantic tree essentially constructed ordered semantic hyperlinking works similar way fact strategies somewhat similar model elimination respect lov69 similarity may apparent ordered semantic hyperlinking semantic hyperlinking however instead semantic tree transfinite semantic tree hr91 also ordered semantic hyperlinking specify precisely tree constructed interpretations examined sequence consistent total ordering first interpretation 0 considered one least ordering interpretation find clause c 0 satisfied 0 clause minimal contradicting clause specified ordering clauses next interpretation 1 considered smallest interpretation obviously contradicted clauses found far case c 0 search continues manner sequence interpretations examined completely determined way choice clauses c found also largely determined minimality unsatisfiable eventually set fc unsatisfiable detected prover search stop define orderings atoms interpretations precisely assume firstorder language specified terms finite set f function constant symbols finite set p predicate symbols list x variables interested satisfiability problem sets firstorder clauses language let set terms formed function symbols f variables x let f set ground terms terms without variables formed f let set atoms expressions form p orderings define x equivalent x partial ordering said wellfounded infinite sequences x assume total wellfounded ordering ordering orderisomorphic enumerated 1 possible ordering corresponds higher ordinal ordering may based size number symbol occurrences atoms may one orderings used show termination termrewriting systems dj90 pla93 course also possibilities specify ordering interpretations literal atom atom preceded negation sign literal without negation sign called positive one called negative literals l l called complementary write l complement l thus l positive l l l l 2 call literals interpretation purposes subset equivalently mapping ftrue falseg maps true write j say satisfies otherwise 6j say contradicts say j l iff 6j l say two interpretations j agree literal l assign l true assign l false j two distinct interpretations let di j least atom respect j agree least atom must exist ordering atoms well founded let 0 special interpretation called initial interpretation typically supplied user order interpretations respect 0 follows let j two different interpretations let di j agrees 0 say thus smallest literals greatest influence ordering interpretations agree 0 smaller ordering interpretations disagree 0 things equal note 0 minimal interpretation ordering ordering interpretations wellfounded infinite still turns certain sets interpretations interest us minimal elements mainly interested interpretations differ 0 finitely many places develop properties definition 21 given interpretation literals l let il defined follows lng b l 62 fl lng thus like except finite list l ceptions earlier use notation see cp94a theorem 22 suppose interpretation proof j j unequal thus must literal di j agrees 0 atom di j j 2 result classifies interpretations smaller n distinct groups depending l equal di j specify ordering literals clauses order literals b atoms b b literals b b b however literals ordered respect one another clause finite set literals regarded disjunction clause tautology contains literal negation clause ground clause contains variables similarly literals atoms terms define partial ordering nontautologous clauses multiset extension ordering literals c empty clause contains literals c every nonempty clause also c clauses let maximum respective literals exist c non tautologous fmg l complementary c ordered note multiset ordering clauses wellfounded underlying ordering literals use ordering clauses present mainly make point clear interpretation satisfies ground clause c satisfies least one literal c case write otherwise say c contradicts write 6j c substitution mapping variables terms theta substitution c clause c theta represents clause obtained replacing variables c terms specified theta clause c theta called instance c similar terminology applies terms atoms literals apply substitutions example purposes say interpretation satisfies nonground clause satisfies ground instances interpretation satisfies set clauses satisfies every clause c interpretation model ground clause c model set ground clauses j c c 2 least models single ground clauses finite sets ground clauses exist show theorem 23 suppose lng ground clause suppose least model c 0 ln proof note 0 l n model c show smaller interpretation j model c suppose j 0 l n theorem 22 di implies j agrees 0 ln c contradicts j 2 theorem 24 let g finite set ground clauses g satisfiable g least model proof let atoms appear positively negatively clauses g finitely many interpretations atoms least one say model since g satisfiable let min least model ordering interpretations must exist since finitely many finite interpretations extend min interpretation l either min j model g since min least model min small possible among interpretations interpretations literals chosen small possible smaller interpretation would differ j literal l theorem 22 possible way min chosen 2 definition 25 g set ground clauses let lmg least model smallest interpretation ordering interpretations satisfies elements g ordered clause linking semantics accumulate set g process keep track least model lmg however store g original form apply certain simplifications features relevant current minimal model retained make use least models also least contradicting clauses interpretations however necessitates introduction another ordering clauses would liked define ordered semantic hyperlinking entirely terms ordering clauses turns incomplete ordering order type greater therefore introduce another ordering cl clauses use choose contradicting instances means purposes completeness ordered semantic hyperlinking may need use two different orderings seems somewhat remarkable purpose assume cl partial ordering ground clauses c finitely many ground clauses satisfy cl example ordering order clauses size total number occurrences symbols two clauses unordered number symbols since finitely many nonvariable symbols appear clause ordering satisfies finiteness property given note cl wellfounded say clause c minimal set clauses clause set cl c note set clauses one finitely many minimal elements show minimal contradicting clauses always exist model set nonground clauses minimal ground instance clause c contradicts theorem 26 suppose set possibly nonground clauses interpretation model ground instance clause c ground instances 0 clauses 6j 0 either cl 0 0 unrelated cl proof set ground clauses 0 6j 0 nonempty since 6j since ordering cl ground clauses wellfounded set ground clauses minimal element claimed note may one minimal finitely many way cl defined result holds even infinite way 2 definition 27 let mis clause ground instance clause 6j ground instance c clause c cl 6j c one instance assume mis one chosen arbitrary manner call clause minimal contradicting instance later discuss algorithmic aspects computing mis 3 search procedure task devise procedure search set interpretations manner consistent ordering finding clauses contradict interpretation maintain finite list c relevant ground clauses record progress made search far list contains instances clauses well instances clauses derived aordering resolu tion goal search continually increase least model lmc c make lmc larger larger ordering interpretations least model called current interpretation beginning c empty lmc 0 elements added c sometimes removed least model becomes larger larger ordering interpretations unsatisfiable eventually c contradict interpretations least model point empty clause c search stop invariant c possesses captured following definitions definition 31 c nontautologous clause let maxc maximal literal c ordering exists clauses finite definition 32 list c clauses ascending form c contradicts least model c 1 literals called eligible literals harmony use term cp94a theorem 33 prefixes also furthermore latter interpretation disagrees 0 literals maxc j proof part prefixes immediate let 0 maxc 1 maxcn rest use induction show 0 6j induction lmfc since literal maxc larger literal maxc 1 agrees 0 maxc definition ascending lmfc show 0 disagree literals maxc shown 0 6j maxc way constructed show lmc show model c smaller interpretation j model c model c since satisfies literals j must differ eligible literal theorem 22 suppose di j maxc j differ maxc remains show j satisfy literals c know lmfc definition ascending induction know lmfc satisfy c therefore j satisfy c since j agrees 0 maxc 1 literals smaller maxc thus literals c satisfied j either 2 search procedure begins set c empty set successively modified adding clause instance contradicting least model whenever done necessary processing c preserve ascending property processing involves performing certain resolutions well deleting certain elements c manner described letting simpc denote result processing following overall algorithm ordered semantic hyperlinking fg 62 c lmc else mis lmc return unsatisfiable 31 processing list c relevant clauses two kinds operations take place processing c involved call simp first kind perform ordered resolutions last clause c possible define rescd follows definition 34 suppose c ground clauses suppose literal l rescd aordering resolution involving maximal literals c note aordering resolution complete theorem proving method propositional logic natural extensions firstorder logic second kind operation takes place simp eliminate elements c made irrelevant aordering resolutions elements c eliminated without affecting lmc following procedure simp procedure maxcn maxd complementary return else maxcn maxd return else return c show correctness define interpretation c c ascending list clauses clause contradicting lmc interpretation property lmc c c 6j c therefore c satisfiable c lmc thus definition gives lower bound least model exists show processing step simp decrease c beginning c larger lmc therefore end obtain ascending set clauses whose least model larger beginning c maximal terpretation interpretation disagrees 0 everywhere property preserved eventually derive empty clause fg c maximal interpretation c unsatisfiable definition 35 suppose c ascending list clauses let cn last clause list c suppose ground clause contradicting lmc define c follows c 1 l maxd 0 6j l 2 l maxd lmc note since c imitates lmc literals less equal maxd maxd contradicts lmc therefore c satisfy also literals larger maxd c chosen large possible ordering interpretations smaller literals c agrees lmc therefore c lmc cannot equality c differs 0 infinitely many literals assuming infinite also j interpretation j c j satisfy c j lmc immediate contradicts j j lmc dj lmc maxd since c lmc agree literals larger maxd therefore contradicts j case thus lmc c least model c least say interpretations j less equal c fail satisfy c show correctness need show every processing step simp preserves property contradicts lmc decrease c let cn last element c maxd maxcn list c added end ascending contradicts lmc maxd cn enter definition c deleting cn affect c also still contradicts lmfc since cannot distinguished lmc literals smaller maxcn maxd maxcn complementary remaining case aordering resolution replaces resolvent containing literals cn except two maximal ones resolvent still contradict least model since cn definition ascending literals except maxd also contradicted least model since contradicted lmc also fc maximal literal rescn smaller maximal literal consider case c unsatisfiable stage processing c becomes maximal interpretation ascending list produced since ascending lists clauses satisfiable means empty clause fg derived search terminates 32 example suppose set atoms contains following clauses suppose 0 interprets p true 0 following sequence current interpretations corresponding clauses mis 0 clause p 5 p 8 chosen resolvent two clauses generated resolvent p 6 generated p 10 p 6 resolvent p 5 generated p 6 p 5 resolvent fg generated p 5 p 5 show five ascending lists clauses generated simp called 33 completeness argue completeness method manner similar completeness proof pacl92 however fact partial orderings may order type greater complicates argument little also fact clauses chosen one point may discarded later complicates proof general idea show unsatisfiable finite number ground instances ever chosen minimal contradicting instances therefore finite number atoms ever appear c essentially reduces problem one involving finite interpretations since finitely many finite interpretations ordering interpretations one cannot seen eventually method must stop unsatisfiable way method stop generate empty clause show finite number clauses chosen theorem 36 suppose unsatisfiable set clauses set fmis interpretation ag finite proof let finite unsatisfiable set ground instances clauses set exists socalled herbrands theorem every interpretation clause 6j note mis minimal cl among clauses contradicting thus cannot mis however finitely many ground clauses c finite 2 definition 37 suppose arbitrarily choose finite unsatisfiable set ground instances say ground instance c small set d2t fd large otherwise say atom small appears positively negatively small clause large otherwise also literal small small otherwise large theorem 38 ordered semantic hyperlinking complete set clauses unsatisfiable eventually empty clause fg derived proof observe clauses mis small current interpretation finitely many clauses follows current interpretations constructed form 0 l l subset small literals finite set interpretations current interpretation constructed larger predecessor ordering interpretations thus interpretation cannot seen twice search must eventually stop way happen empty clause generated unsatisfiable 2 34 efficiency briefly note one advantage approach semantic hyperlinking described cp94a growth number eligible literals better controlled number eligible literals strong effect work required find minimal clause contradicting current interpretation procedure simp automatically perform aordering resolutions maximal literal contradicting clause complement existing eligible literal resolution effect removing eligible literal c semantic hyperlinking without ordering rare eligible literals removed typically set eligible literals grows rapidly making search procedure timeconsuming rounds search making difficult find proofs require rounds search however parts semantic hyperlinking powerful enough many proofs found within three four rounds search addition way literals ordered semantic hyperlinking makes propositional satisfiability test fast still think would advantage able handle many rounds search efficiently finding minimal contradicting instances preceding discussion dealt practical aspects minimal contradicting instance mis found dealt extent cp94a problem given interpretation form 0 l set possibly nonground clauses test whether 0 l find minimal ground instance clause c contradicts clause exists purpose shall see helpful choose 0 decidable given nonground clause c decide whether 0 number kinds interpretations 0 decidable among syntactic interpretations interpretations finite domain interpretations reals functions predicates expressed terms linear arithmetic inequality say interpretation syntactic two atoms b predicate symbol depending signs predicate symbols literals fairly limited expressiveness sometimes useful anyway show cp94a example interpretation terms linear arithmetic inequality might interpret p x 2x might interpret fx x x else 0 6j c need find ground instance c theta c 0 6j c theta problem even 0 6j c ground instance may exist reason elements domain 0 may values finite ground terms question given clause c exist substitution theta c theta ground clause 0 6j c theta seems harder deciding 0 say interpretation 0 herbrand decidable question theta decidable note syntactic interpretations interpretations finite domain herbrand decidable dont know whether interpretations reals functions predicates expressed using linear arithmetic inequality herbrand decidable 0 herbrand decid able may current interpretation satisfies without able detect may spend infinite amount time fruitlessly searching ground instance c theta contradicts however affect completeness ordered semantic hyperlinking c theta exists eventually found 0 herbrand decidable question whether decidable show first specify detail instance c theta found exists moreover instance minimal assuming 0 decidable approach construct set z literals following property set ground instances literals z exactly set ground literals l 0 6j l neither l complement l appear list l eligible literals one show contradicts 0 l literal either complement eligible literal instance literal z literals complements l false 0 l since 0 l also literals instances elements z false 0 l agrees 0 literals obtain instances take clause c apply substitution theta literals l c theta instances literal z complements eligible literal find general theta l c theta exists literal z set complements eligible literals l identical note finding theta reminiscent hyperlinking method lp92 literals z ground literals done matching procedure literals c matched one one literals z nonground may need successive unifications resulting instance nonground necessary instantiate variables ground terms manner since interested minimal ground instances replace variable ground term minimal clause ordering assuming clause ordering cl monotone purposes say clause ordering monotone extended partial ordering terms terms cl implies cs cl ct clause cs containing occurrence furthermore require term finitely many terms cl note implies finitely many minimal terms condition given however order find minimal instance may necessary replace variable minimal terms possible ways expensive purpose write st mean tt write cd similarly clauses c choose ordering cl st implies csct example ordering terms size satisfies condition ordering obtain minimal instance c replacing variables arbitrarily chosen minimal terms problem generate z without knowing 0 much said test 0 j l decidable ground l one enumerate ground literals l discard eligible literals complements test whether 0 l way generate least enumerate z fact z infinite need problem one needs enumerate z ascending order ordering cl order find minimal contradicting instance soon one instance found literals l cl l need examined eliminates finitely many literals need assume l 2 c l 6 c l cl c cp94b indicate specialized decision procedures used aid generation sets z literals cases course enumerative method cannot detect current interpretation satisfies c choose different approach permits relatively small set z 0 generated independent 0 delays consideration 0 later stage approach also permits us detect current interpretation satisfies 0 herbrand decidable make comments complexity measures used defined terms sizes various structures considered character strings alternatively size clause set clauses etc number occurrences symbols say something computed time polynomial set clauses mean running time bounded polynomial length written character string usual complexity measure 41 disunification let z 0 set literals ground literal l instance literal exactly neither l complement appear set eligible literals thus kind disunification problem turns finite set z 0 always exists since eligible literals ground finitely many using fact finitely many function predicate symbols also z 0 computed time polynomial list eligible literals see let z 0 e desired z 0 literals desired e set literals either eligible literals complements first note positive negative literals handled separately let l pos set positive literals let l neg set negative literals let pos positive literals e let e neg negative literals e extend consider sets positive negative literals specified predicate symbols solving z 0 subclass n predicate symbols obtain total 2n subproblems solve whose solutions combined obtain desired z 0 predicate symbol specified sign appear e subproblem simple solution p z 0 e suitable p since none instances e otherwise consider sets literals various function constant symbols chosen position division reduces problem number subproblems equal number function constant symbols partitions set e disjoint subsets eventually obtain trivial problems whose solutions combined 42 generating eligible instances suppose set z 0 literals generated specified generate instances input clauses follows clause c partition c two disjoint sets literals c ff c fi done possible ways partition unify literals c ff complements eligible literals c fi literals z 0 also must done possible ways way obtain instance c expressed ff fi literals ff complements eligible literals literals fi instances literals z 0 unify eligible literals complements call instance eligible instance note finitely many eligible instances found simple enumeration procedure order ensure contradicts 0 l necessary find substitution fl 0 6j fi fl also want instance minimal clause ordering cl fl specified 0 l reasoning literals ff satisfied current interpretation complements eligible literals literals fi fl satisfied current interpretation 0 l satisfied 0 0 herbrand decidable test whether fl exists decidable way test current interpretation satisfies fl exists want find one dfl minimal ordering cl search depends course 0 cl clause ordering based directed acyclic graph size terms size number distinct subterms appear independent often appear computation seems rather complicated despite favorable theoretical properties size measure however certain types interpretations literal orderings search fl producing small clause done quickly show next section also dealt extent paper cp94b likely also search always done fast 0 interpretation small finite domain clause ordering cl monotone however say something case 0 syntactic 0 syntactic 0 6j fi fl iff 0 6j fi latter condition checked examining signs predicate symbols literals permits clauses rapidly eliminated processing 43 complexity analysis generation eligible instances requires amount work depends number sizes eligible literals number literals clauses however suppose constant bound number literals clause generation eligible instances done time polynomial set eligible literals since one look combinations obtained unifying literal c complement eligible literals element z 0 set eligible literals unioned z 0 n elements clause c k literals n k possibilities still polynomial fixed k possibility work polynomial even linear using efficient unification algorithms note n polynomial number elements z 0 polynomial disunification arguments given assumption k bounded reasonable possible convert clauses many literals clauses three literals satisfiability preserving manner introducing new predicate symbols shown number literals clauses bounded eligible instances generated polynomial time regardless 0 however order generate minimal contradicting instance necessary instantiate eligible instances substitution fl specified 0 syntactic clause ordering cl monotone properties concerning specified section 4 fl obtained simply checking signs predicate symbols replacing variables minimal term entire process generating minimal contradicting instance done time polynomial set eligible literals polynomial lengths written character strings 0 finite domain find domain element minimal ground term whose interpretation 0 terms found simple iteration procedure find minimal instance dfl 0 6j fi fl necessary consider fl replacing variables terms form various domain finite number possibilities exponential number variables fi use ordering based directed acyclic graphs counting number distinct subterms appear counting often appear generation minimal contradicting instance complicated directed acyclic graphbased orderings monotone since contribution subterm clause depends subterms appear elsewhere clause however favorable complexity properties directed acyclic graphbased orderings may worthwhile use anyway general makes sense look eligible instances order size possible small contradicting instance may found early instantiation larger eligible instances may avoided 5 additional ordered resolutions since basic search procedure performs aordering resolution seems reasonable additional resolutions might effect part work advance thereby speed search might add input clause set set 0 clauses generated aordering resolution consider clauses 0 additional input clauses one would expect additional clauses might lead finding certain contradictions earlier also effect eliminating large literals proofs mentioned cp94a since basic search procedure difficulty generating large literals combination reasonable found practice combination rough resolution instead aordering resolution eliminate large literals often works well balance work ordered semantic hyperlinking ordering resolution way done parallel one method use divide total time spent equally question remains ordering use aordering resolutions aordering resolutions ordering choose literal ordering lit compatible ordering ground literals say lit nonground literals l ground substitution theta ltheta theta note really need use ordering cl compare ltheta theta restrict literals resolved literals maximal ordering lit aordering resolutions perform observed section 43 strong dependence efficiency ordered semantic hyperlinking number literals clauses reasonable keep number literals small however want perform aordering search complete manner reasonably large portion search space explored necessary consider number literals clause size number symbol occurrences clause preferring clauses small size done completenessspreserving manner also tend keep number literals small question remains exactly done one way keep list pairs clauses yet resolved together always resolve pair clauses whose sum sizes small possible produces clauses small size number symbol occurrences tend literals requires quadratic amount space store possible resolutions another method otter mcc89 approach small clause repeatedly chosen resolved clauses avoids expensive bookkeeping problem small clause also resolve large clauses possibly producing large clauses early propose compromise list clauses constructed follows clauses entered list l smallest first whenever clause entered list resolves using aordering resolution clauses already list way resolutions eventually done guarantee two clauses resolved small also amount bookkeeping kept minimum done resolving c c j j find smallest clause produced earlier resolution already list l enter smallest clause list c i1 resolve c j 1 j continuing process certain problems important produce large aordering resolvents early directly derived negation theorem case example bledsoes five limit problems ble90 therefore would like make aordering resolution procedure sensitive support criteria well size purpose say clause c semantically supported contradicts usergiven interpretation 0 input clauses clauses generated resolution semantically supported modify aordering search strategy alternate choices semantically supported clause chosen thus alternate choosing smallest clause yet l smallest semantically supported clause yet l added list resolved clauses already l tend favor resolutions involving supported clauses even clauses large done systematically 0 decidable better herbrand decidable 51 explanationbased generalization idea explanationbased generalization ebg extract general principles specific argument enabling argument applied wider range situations principle applied ordered resolution phase ordered semantic hyperlinking note procedure simp section 31 aordering resolutions performed ground clauses cn cn instances clauses clauses produced prior aordering resolutions suppose c 0 n 0 general possibly nonground clauses cn respectively instances general properties res olution follows aordering resolvent c cn resc n instance c therefore seems reasonable store general clauses c 0 along respective instances cn resc n way produce lemmas added set input clauses lemmas likely relevant proof may generated search adding may avoid sections search resolutions performed makes sense generate lemmas addition performing aordering resolutions previous section since lemmas may generated listbased search method described fact uniform ordering used search may make lemma mechanism effective search method used semantic hyperlinking without ordering vary literal ordering different interpretations making less likely lemma found earlier useful later 6 replacement rules found use replacement rules considerably enhanced performance semantic hyperlinking reasonable include ordered semantic hyperlinking however necessary adapt current context suppose current set c relevant clauses construct set el explicit literals literals satisfied lmc actually appear clauses c thus set el defined set literals l either l l member c lmc show els unsatisfiable already contradicted current interpretation lmc need search minimal contradicting instance show el unsatisfiable know clause logical consequence used minimal contradicting instance fact typically find small subset clause consequence may useful search see whether els unsatisfiable use incomplete often effective methods general ai context may viewed obvious inferences associations readily made one method use natural replacement rules implications form l variables literal l appear elsewhere implication clause member replacement rules may used unifying l elements el corresponding instance l ground literal since variables l also appear elsewhere ground literal logical consequence el temporarily added el operation may repeated number times complementary literals appear el know el unsatisfiable derivation clause subset fl l 2 elg may extracted logical consequence used place minimal contradicting instance another kind replacement rules definitional replace rules slight simplification minimal replace rules cp93a idea definitional replace rules capture clauses represent definitions effect applying expand definitions particularly useful set theory modal logic definitional replace rule form l variables l 1 appear l clause fl l member one definition form l j l literal formula involving quantifiers one verify clauses generated definition converted clause form sometimes formulae generated even contains quantifiers replacement rules used inverse way natural replacement rules l instance ltheta el implication ltheta added el also l instance ltheta appearing righthand side implication previously added el instance added el way el augmented set ground instances clauses instances instances one would consider expanding definitions test el together ground instances unsatisfiable using something like davis putnams method dp60 clause subset fl l 2 elg may extracted logical consequence thus know el unsatisfiable order control application replace rules seems reasonable use time bound based time used search minimal contradicting instance seems reasonable first search contradiction using natural replace rules fails definitional replace rules applied controlled time bound fails generated set g ground clauses processed little set g contains el considered unit clauses together ground instances generated definitional replacement since g consists ground clauses finitely many models examine models j g one one model j apply natural replacement j see contradicted note since g finite models j essentially finite model j considered set u unit clauses set literals l j j l l complement appears g perform natural replacement set u may find contradictions nearly quite found definitional replacement contradictions demonstrations u unsatisfiable need found models j g order demonstrate 7 complexity analysis consider complexity required ordered clause linking terms complexity shortest proof consider worstcase bounds give plausibility arguments better performance introduction noticed clause linking triple exponential bound complexity proof reduced double exponential suitable ordering literals used arguments apply ordered clause linking however reason believe performance better know unsatisfiable unsatisfiable set ground instances suppose measure complexity proof complexity ct length written character string equivalently purposes measure complexity proof complexity largest clause note complexity measure economize repeated occurrences subterm suppose clause ordering based simply length clause written character string sum sizes literals clause clause appearing proof complexity ct find proof clauses complexity ct less generated earlier number clauses exponential ct time required test satisfiability may double exponential ct note measure independent many clauses appear largest clause complexity measure used give method better comparison methods gou94 need count number elements another favorable factor method satisfiability set ground clauses tested expected polynomial time many probability distributions practice methods similar davis putnams method often decide satisfiability sets propositional clauses fast also found case clause linking theorem prover since search procedure similar davis putnams procedure systematic search model would expect similar time bound apply thus may expect practice time required method single exponential note based assumption clauses complexity ct less generated method selective clauses generated reasonable assume small subset clauses complexity ct less generated example show method generate logically minimal ground instances ground instances logical consequences smaller respect cl ground instances equivalently ground instance c logically minimal interpretation c minimal instance contradicting question whether clause logical consequence simpler clauses also relevant methods bg90 bg94 turns one would expect number logically minimal ground instances given size much smaller total number fact even generate logically minimal clauses fact aordering resolutions done simp procedure means many interpretations even examined generate clauses logically minimal aordering resolvents also considered eliminate clauses logically minimal worst case bound method exponential number logically minimal ground instances always finite unsatisfiable one might ask whether would efficient generate ground instances clauses consider order size thus would list c ground instances smallest ones occurring earlier list could test c logical consequence c j delete c list produces smaller sublist c 0 ground instances finite prefixes tested satisfiability method efficient nonlogically minimal instances never even generated furthermore even logically minimal instances avoided explained 71 estimating size tree give additional evidence work required ordered semantic hyperlinking often small note small atoms influence search defined definition 37 let us consider smallest n atoms probability clause c atoms contradict arbitrary interpretation suppose 3literal ground clauses c chance random interpretation satisfy specific clause c 18 since 3 literals must mapped false therefore chance interpretation satisfy clause c 78 chance satisfy 3literal clauses 78 clauses chosen independently expected number models independently chosen clauses considering first n literals 2 n 78 since 2 n interpretations altogether n atoms note expected number models less one means probability small search past first n atoms find contradicting instance evidence many clauses size tree small average given nonground clauses general instead ground instances determining quantity analysis number ground instances various sizes depend one another r theorem proving via general mating restrictions ordered paramodulation simplification ordered chaining total derings automated theorem proving challenge problems elementary calculus model finding semantically guided instancebased theorem proving rough resolution refinement resolution remove large literals semantically guided firstorder theorem proving using hyperlinking use presburger formulas semantically guided theorem proving rewrite systems computing procedure quantification theory resolution methods decision problem complexity resourcebounded firstorder classical logic proving refutational completeness theoremproving strategies transfinite semantic tree method simplified format model elimination procedure eliminating duplication hyperlinking strategy otter 10 users guide conditional term rewriting firstorder theorem proving equational reasoning term rewriting systems search efficiency theorem proving strategies search efficiency theorem proving strategies analytical comparison automatic theorem proving renameable semantic resolution tr ctr kahlil hodgson john slaney tptp casc development semantically guided theorem prover ai communications v15 n23 p135146 august 2002 kahlil hodgson john slaney tptp casc development semantically guided theorem prover ai communications v15 n2 p135146 september 2002 r janvier lakhnech prin certifying cryptographic protocols abstract modelchecking proof concretization acm sigbed review v3 n4 p3757 october 2006 david plaisted adnan yahya relevance restriction strategy automated deduction artificial intelligence v144 n12 p5993 march adnan yahya david plaisted ordered semantic hyper tableaux journal automated reasoning v29 n1 p1757 2002 carsten sinz visualizing sat instances runs dpll algorithm journal automated reasoning v39 n2 p219243 august 2007 peter baumgartner firstorder logic davisputnamlogemannloveland procedure exploring artificial intelligence new millennium morgan kaufmann publishers inc san francisco ca
improving code density using compression techniques propose method compressing programs embedded processors instruction memory size dominates cost postcompilation analyzer examines program replaces common sequences instructions single instruction codeword microprocessor executes compressed instruction sequences fetching code words instruction memory expanding back original sequence instructions decode stage issuing execution stages apply technique powerpc arm i386 instruction sets achieve average size reduction 39 34 26 respectively spec cint95 programs b introduction according recent prediction instat inc merchant processor market set exceed 60 billion 1999 nearly half embedded processors however unit count embedded processors exceed number general purpose microprocessors factor 20 compared general purpose microprocessors processors embedded applications much less studied figures suggest deserve attention embedded processors highly constrained cost power size general purpose microprocessors control oriented embedded applications common type significant portion final circuitry used instruction memory since cost integrated circuit strongly related die size memory size proportional die size developers want program fit smallest memory possible additional pressure program memory relatively recent adoption highlevel languages embedded systems need control development costs typical code sizes grown costs ballooned rates comparable seen desktop world thus ability compress instruction code important even cost execution speed high performance systems also impacted program size due delays incurred instruction cache misses study digital perl96 showed sql server dec 21064 alpha bandwidth limited factor two instruction cache misses alone problem increase gap processor performance memory performance grows reducing program size one way reduce instruction cache misses achieve higher performance chen97b paper focuses compression embedded applications execution speed traded compression borrow concepts field text compression apply compression instruction sequences propose modifications microarchitecture level support compressed programs postcompilation analyzer examines program replaces common sequences instructions single instruction codeword microprocessor executes compressed instruction sequences fetching codewords instruction memory expanding back original sequence instructions decode stage issuing execution stages demonstrate technique applying powerpc instruction set 11 code generation compilers generate code using syntax directed translation scheme sdts aho86 syntactic source code patterns mapped onto templates instructions implement appropriate semantics consider simple schema translate subset integer arithmetic patterns show syntactic fragments right hand side two productions replaced reduced simpler syntactic structure two expressions added multiplied together result single new expression register numbers holding operand expressions 1 3 encoded add multiplication operation emitted generated object code result register 1 passed parse tree use parent operation two patterns reused arithmetic operations throughout program compilation complex actions translation control structures generate instructions albeit still driven template structure sdts general difference instruction sequences given source code fragments different points object module register numbers arithmetic instructions operand offsets load store instructions consequence object modules generated many common subsequences instructions high degree redundancy encoding instructions program programs examined small number instructions bit pattern encodings repeated elsewhere program indeed found small number instruction encodings highly reused programs illustrate redundancy instruction encodings profiled spec cint95 benchmarks spec95 benchmarks compiled powerpc gcc 272 using o2 opti mization figure 1 shows compiled programs consist many instructions identical encodings average less 20 instructions benchmarks bit pattern encodings used exactly program go benchmark example 1 frequent instruction words account 30 program size 10 frequent instruction words account 66 program size clear redundancy instruction encodings provides great opportunity reducing program size compression techniques 12 overview compression method compression method finds sequences instruction bytes frequently repeated throughout single program replaces entire sequence single codeword rewritten encoded sequences instructions kept dictionary turn used program execution time expand singleton codewords instruction stream back original sequence instructions codewords assigned compression algorithm merely indices instruction dictionary final compressed program consists codewords interspersed uncompressed instructions figure 2 illustrates relationship uncompressed code compressed code dictionary complete description compression method presented section 3 compress gcc go ijpeg li benchmarks 0 10 20 30 40 program instructions distinct instruction encodings used program distinct instruction encodings used multiple times program figure 1 distinct instruction encodings percentage entire program uncompressed code clrlwi r11r924 addi r0r111 cmplwi cr1r08 ble cr1000401c8 cmplwi cr1r117 bgt cr100041d34 stb r180r28 clrlwi r11r924 addi r0r111 cmplwi cr1r08 bgt cr100041c98 compressed code codeword 1 ble cr1000401c8 cmplwi cr1r117 bgt cr100041d34 codeword 2 codeword 1 bgt cr100041c98 dictionary clrlwi r11r924 addi r0r111 cmplwi cr1r08 stb r180r28 figure 2 example compression background related work section discuss strategies text compression methods currently employed microprocessor manufacturers reduce impact risc instruction sets program size 21 text compression text compression methods fall two general categories statistical dictionary statistical compression uses frequency singleton characters choose size codewords replace frequent characters encoded using shorter codewords overall length compressed text minimized huffman encoding text wellknown example dictionary compression selects entire phrases common characters replaces single codeword codeword used index dictionary entry contains original characters compression achieved codewords use fewer bits characters replace several criteria used select using dictionary statistical compression techniques two important factors decode efficiency overall compression ratio decode efficiency measure work required reexpand compressed text compression ratio defined formula eq dictionary decompression uses codeword index dictionary table inserts dictionary entry decompressed text stream codewords aligned machine words dictionary lookup constant time operation statistical compression hand uses codewords different bit sizes align machine word bound aries since codewords aligned statistical decompression stage must first establish range bits comprising codeword text expansion proceed shown every dictionary method equivalent statistical method achieves equal compression improved upon give better compression bell90 thus statistical methods always achieve better compression dictionary methods albeit expense additional computation requirements decompression noted ever dictionary compression yields good results systems memory time constraints one entry expands several characters general dictionary compression provides faster simpler decoding statistical compression yields better compression ratio 22 compression risc instruction sets although risc instruction set easy decode fixedlength instruction formats wasteful program memory thumb arm95mpr95 mips16 kissell97 two compression ratio compressed size original size recently proposed instruction set modifications define reduced instruction word sizes effort reduce overall size compiled programs thumb subset arm architecture consisting 36 arm 32bit wide instructions reencoded require 16 bits instructions included thumb either require full 32bits frequently used important compiler generating small object code programs compiled thumb achieve 30 smaller code comparison standard arm instruction set arm95 mips16 defines 16bit fixedlength instruction set architecture isa subset mipsiii instructions used mips16 chosen statistically analyzing wide range application programs instructions frequently generated compilers code written 32bit mipsiii typically reduced 40 size compiled mips16 kissell97 thumb mips16 act preprocessors underlying architectures case 16bit instruction fetched instruction memory expanded 32bit wide instruc tion passed base processor core execution thumb mips16 shrink instruction widths expense reducing number bits used represent register designators immediate value fields confines thumb mips16 programs 8 registers base architecture significantly reduces range immediate values subsets base architectures thumb mips16 neither capable generating complete programs operating underlying machine thumb relies 32bit instructions memory management exception handling mips16 relies 32bit instructions floatingpoint operations moreover thumb cannot exploit conditional execution zero latency shifts rotates underlying arm architecture thumb mips16 require special branch instructions toggle 32bit 16bit modes fixed set instructions comprise thumb mips16 chosen assessment instructions used range applications neither architecture access regis ters instructions modes underlying 32bit core architecture contrast derive codewords dictionary specific characteristics program execution compressed program access resources available machine yet still exploit compressibility individual program 23 ccrp compressed code risc processor ccrp described wolfe92wolfe94 instruction cache modified run compressed programs compiletime cache line bytes huffman encoded runtime cache lines fetched main memory uncom pressed put instruction cache instructions fetched cache addresses uncompressed program therefore core processor need modification support compression however cache misses problematic missed instructions cache reside address main memory ccrp uses line address table lat map missed instruction cache addresses main memory addresses compressed code located lat limits compressed programs execute processors line size compiled one shortcoming ccrp compresses granularity bytes rather full instructions means ccrp requires overhead encode instruction scheme encodes groups instructions moreover scheme requires less effort decode program since single codeword encode entire group instructions addition compression method need lat mechanism since patch branches use new instruction addresses compressed program 24 liao et al purely software method supporting compressed code proposed liao96 author finds minisubroutines common sequences instructions program instance minisubroutine removed program replaced call instruction minisubroutine placed text program ends return instruction minisubroutines constrained basic blocks may contain branch instructions restricted conditions prime advantage compression method requires hardware support however subroutine call overhead slow program execution liao96 suggests hardware modification support code compression consisting primarily calldictionary instruction instruction takes two arguments location length common instruction sequences program saved dictionary sequence replaced program calldictionary instruction execution processor jumps point dictionary indicated location executes length instructions implicitly returning liao96 limits dictionary use sequences instructions within basic blocks liao96 explore tradeoff field widths location length arguments calldictionary instruction codewords 1 2 instruction words size considered requires dictionary contain sequences least 2 3 instructions respectively since shorter sequences would bigger calldictionary instruction compression would result since single instructions frequently occurring patterns important use scheme compress paper vary parameters dictionary size number entries dictionary dictionary entry length number instructions dictionary entry thus allowing us examine efficacy compressing instruction sequences length 3 compression method 31 algorithm compression method based technique introduced bird96chen97a dictionary compression algorithm applied compiler generated program take advantage sdts find common sequences instructions place dictionary algorithm divided 3 steps 1 build dictionary 2 replace instruction sequences codewords 3 encode codewords 311 dictionary content arbitrary text choosing entries dictionary achieve maximum compression npcomplete size text storer77 dictionary methods use greedy algorithm quickly determine dictionary entries 1 every iteration algorithm examine potential dictionary entry find one results largest immediate savings algorithm continues pick dictionary entries termination criteria reached usually exhaustion codeword space maximum number dictionary entries determined choice encoding scheme codewords obviously codewords bits index larger range dictionary entries limit dictionary entries sequences instructions within basic block allow branch instructions branch codewords may branch within encoded sequences also compress branches offset fields restrictions simplify code generation 312 replacement instructions codewords greedy algorithm combines step building dictionary step replacing instruction sequences dictionary entry defined instances program replaced token token replaced efficient encoding encoding step 313 encoding encoding refers representation codewords compressed program discussed section 21 variablelength codewords used huffman encoding expensive decode fixedlength codeword hand used directly index dictionary making decoding simple table lookup operation baseline compression method uses fixedlength codeword enable fast decoding also investigate variablelength scheme however restrict variablelength codewords multiple basic unit example present compression scheme codewords 4 bits 8 bits 12 bits 16 bits instructions compressed uncompressed aligned size smallest codeword shortest codewords encode frequent dictionary entries maximize savings achieves better compression fixedlength encoding complicates decoding 32 related issues 321 branch instructions one side effect compression scheme alters locations instructions program presents special problem branch instructions since branch targets change result program compression 1 greedy algorithms often nearoptimal practice study compress relative branch instructions ie containing offset field used compute branch target makes easy us patch offset fields branch instruction compression allowed compression relative branches might need rewrite codewords representing relative branches compression pass would affect relative branch targets thus requiring rewrite codewords etc result npcomplete problem szymanski78 indirect branches compressed study since branches take target register branch instruction need patched compression cannot create codeword rewriting problem outlined however jump tables containing program addresses need patched reflect address changes due compression gcc puts jump table data text section immediately following branch instruction assume table could relocated data section patched postcompression branch target addresses 322 branch targets fixedlength instruction sets fixedlength instruction sets typically restrict branches use targets aligned instruction word boundaries since primary concern code size tradeoff performance advantages aligned fixedlength instructions exchange compact code use codewords smaller instruction word boundaries align size smallest codeword 4 bits study therefore need specify method address branch targets fall instruction word boundaries one solution pad compressed program branch targets aligned defined original isa obvious disadvantage solution decrease compression ratio complex solution one adopted experiments modify control unit processor treat branch offsets aligned size smallest codeword example size codeword 8 bits 32bit aligned instruction set would branch offset range reduced factor 4 table 1 shows branches benchmarks use entire range offset fields postcompilation compressor modifies branch offsets use alignment codewords branches requiring larger ranges modified load targets jump tables course result slight increase code size branch sequences 33 compressed program processor general design compressed program processor given figure 3 assume levels memory hierarchy contain compressed instructions conserve memory since compressed program may contain compressed uncompressed instructions two paths program memory processor core uncompressed instructions proceed directly normal instruction decoder compressed instructions must first translated using dictionary decoded executed usual manner dictionary could loaded variety ways dictionary small one possibility place permanent onchip memory alternatively dictionary larger might kept data segment compressed program dictionary entry could loaded needed 4 experiments section integrate compression technique powerpc instruction set compiled spec cint95 benchmarks gcc 272 using o2 optimization optimizations include common subexpression elimination include function inlining loop unrolling since optimizations tend increase code size linking done statically table 1 usage bits branch offset field bench number relative branches branch offsets wide enough provide 2byte resolution branch targets branch offsets wide enough provide 1byte resolution branch targets branch offsets wide enough provide 4bit resolution branch targets number percent number percent number percent compress li 4806 0 000 perl 14578 15 010 74 051 191 131 vortex cpu core figure 3 overview compressed program processor uncompressed instruction stream dictionary compressed program memory usually rom libraries included results compressed program sizes include overhead dictionary recall interested dictionary size number codewords dictionary entry length number instructions dictionary entry 41 baseline compression method baseline compression method use codewords 2bytes first byte escape byte illegal powerpc opcode value allows us distinguish normal instructions compressed instructions second byte selects one 256 dictionary entries dictionary entries limited length 16 bytes 4 powerpc instructions powerpc 8 illegal 6bit opcodes using 8 illegal opcodes possible patterns remaining 2 bits byte 32 different escape bytes combining second byte codeword specify 8192 different codewords since compressed instructions use illegal opcodes processor designed execute programs compressed baseline method able execute original programs well first experiments vary parameters baseline method figure 4 shows effect varying dictionary entry length interestingly dictionary entries allowed contain 8 instructions overall compression begins decline attributed greedy selection algorithm generating dictionary selecting large dictionary entries removes opportunities formation smaller entries large entries chosen result immediate reduction program size however guarantee best entries use achieving good compression large sequence replaced destroys small sequences partially overlapped may savings using multiple smaller sequences would greater savings single large sequence however greedy algorithm detect case potential savings lost general dictionary entry sizes 4 instructions improve compression noticeably figure 5 illustrates happens number codewords entries dictionary increases compression ratio program continues improve maximum amount codewords reached unique single use encodings remain uncompressed table 2 lists maximum number codewords program baseline compression method representing upper bound size dictionary compress gcc go ijpeg li benchmarks 0 10 20 30 40 50 70 80 90 100 compression ratio 1357maximum number instructions dictionary entry figure 4 effect dictionary entry size compression ratio benchmarks contain numerous instructions occur times dictionary becomes large codewords available replace numerous instruction encodings occur infrequently savings compressing individual instruction tiny multiplied length program compression noticeable achieve good compression important increase number codewords dictionary rather increase length dictionary entries thousand codewords enough spec cint95 programs 411 usage dictionary since usage dictionary similar across benchmarks show results using ijpeg representative benchmark extend baseline compression method use dictionary entries 8 instructions figure 6 shows composition dictionary number instructions dictionary entries contain number dictionary entries single instruction ranges 48 80 surprisingly larger dictionary higher proportion short dictionary entries figure 7 shows dictionary entries contribute compression dictionary entries 1 instruction achieve 48 60 compression savings short entries contribute larger portion savings size dictionary increases compression method liao96 cannot take advantage table 2 maximum number codewords used baseline compression max dictionary entry bench maximum number codewords used compress 647 go 3123 ijpeg 2107 li 1104 perl 2970 vortex 3545 compress gcc go ijpeg li benchmarks 0 10 20 30 40 50 70 80 90 100 compression number codewords figure 5 effect number codewords compression ratio since codewords size single instructions single instructions compressed 412 compression using small dictionaries implementations compressed code processor may constrained use small dic tionaries investigated compression dictionaries ranging 128 bytes 512 bytes size present one compression scheme demonstrate compression beneficial even small dictionaries compression scheme small dictionaries uses 1byte codewords dictionary entries 4 instructions size figure 8 shows results dictionaries 8 16 entries average dictionary size 512 bytes sufficient get code reduction 15 413 variablelength codewords baseline method used 2byte codewords improve compression ratio using smaller encodings codewords figure 9 shows baseline compression uses 8192 codewords 40 compressed program bytes codewords since baseline compression uses 2byte codewords means 20 final compressed program size due escape bytes investigated several compression schemes using variablelength codewords size dictionary number entries 0 20 40 80 100 percentage dictionary figure composition dictionary ijpeg max dictionary length dictionary entry number instructions size dictionary number entries 100 200 300 400 program bytes removed2468 length dictionary entry due compression figure 7 bytes saved compression ijpeg according instruction length dictionary entry number instructions aligned 4bits nibbles although higher decode penalty using variablelength codewords able achieve better compression restricting codewords integer multiples 4bits given decoding process regularity 1bit aligned huffman encoding wolfe94 lacks choice encoding based spec cint95 benchmarks present best encoding choice discovered use codewords 4bits 8bits 12bits 16bits length programs may benefit different encodings example many codewords necessary good compression 4bit 8bit code words could used reduce codeword overhead diagram nibble aligned encoding shown figure 10 scheme predicated observation unlimited number codewords used final compressed program size dominated codeword bytes therefore use escape code indicate less uncompressed instructions rather codewords first 4bits codeword determine length codeword scheme provide 128 8bit codewords thousand 12bit 16bit codewords offers flexibility many short codewords thus minimizing impact frequently used instructions allowing large overall number codewords one nibble reserved escape code uncompressed instruc compress gcc go ijpeg li benchmarks 0 10 20 30 40 50 70 80 90 100 compression number codewords number codewords figure 8 compression ratio 1byte codewords 4 instructionsentry figure 9 composition compressed program 8192 2byte codewords 4 instructionsentry compress gcc go ijpeg li benchmarks 100 200 300 400 500 700 800 900 1000 compressed program size dictionary codewords escape bytes codewords index bytes uncompressed instructions tions reduce codeword overhead encoding frequent sequences instructions shortest codewords using encoding technique effectively redefines entire instruction set encoding method compression used existing instruction sets available escape bytes unfortunately also means original programs longer execute unmodified processors execute compressed programs without mode switching results 4bit aligned compression presented figure 11 obtain code reduction 30 50 depending benchmark comparison extracted instruction bytes benchmarks compressed unix compress compress uses adaptive dictionary technique based zivlempel coding modify dictionary response changes characteristics text addition also uses huffman encoding codewords thus able achieve better compression method figure 11 shows compress indeed better compression ratio still within 5 benchmarks figure 10 nibble aligned encoding instruction 128 8bit codewords 1536 12bit codewords 4096 16bit codewords 36bit uncompressed instruction figure 11 comparison nibble aligned compression unix compress compress gcc go ijpeg li benchmarks 100 200 300 400 500 700 800 900 1000 compression compression nibble aligned codewords unix compress 5 conclusions future work proposed method compressing programs embedded microprocessors program size limited approach combines elements two previous proposals first use dictionary compression method liao96 allows codewords expand several instructions second allow codewords smaller single instruction wolfe94 find size dictionary single important parameter attaining better compression ratio second important factor reducing codeword size size single instruction find much savings comes compressing patterns single instructions aggressive compression spec cint95 achieves 30 50 code reduction compression ratio similar achieved thumb mips16 thumb mips16 designed completely new instruction set compiler instruction decoder achieved results processing compiled object code slightly modifying instruction fetch mechanism several ways compression method improved first compiler could attempt produce instructions similar byte sequences could easily compressed one way accomplish allocating registers common sequences instructions use registers another way generate generalized stds code sequences would less efficient would semantically correct larger variety circumstances example optimizing compilers function prologue sequence might save registers modified within body function prologue sequence standardized always save registers instructions sequence could compressed single codeword space saving optimization would decrease code size expense execution time table 3 shows prologue epilogue combined typically account 12 program size type compression would provide significant size reduction also plan explore performance aspects compression examine tradeoffs partitioning onchip memory dictionary program table 3 prologue epilogue code benchmarks bench static prologue instructions percentage entire program static epilogue instructions percentage entire program compress 53 62 gcc 42 49 go 62 68 ijpeg 69 94 li 81 99 perl 37 43 vortex 63 71 6 r compiler principles advanced risc machines ltd instruction stream compression technique impact instruction compression icache performance enhancing instruction fetching mechanism using data com pression highdensity mips embedded market code generation optimization embedded digital signal processors thumb squeezes arm code size studies windows nt performance using dynamic execution traces npcompleteness results concerning data compression assembling code machines spandependent instructions executing compressed programs embedded risc architecture compression embedded system programs tr text compression executing compressed programs embedded risc architecture studies windows nt performance using dynamic execution traces assembling code machines spandependent instructions compression embedded system programs code generation optimization embedded digital signal processors enhancing instruction fetching mechanism using data compression ctr seokwon seong prabhat mishra bitmaskbased code compression technique embedded systems proceedings 2006 ieeeacm international conference computeraided design november 0509 2006 san jose california heidi pan krste asanovi heads tails variablelength instruction format supporting parallel fetch decode proceedings 2001 international conference compilers architecture synthesis embedded systems november 1617 2001 atlanta georgia usa chang hong lin yuan xie wayne wolf lzwbased code compression vliw embedded systems proceedings conference design automation test europe p30076 february 1620 2004 chang hong lin yuan xie wayne wolf code compression vliw embedded systems using selfgenerating table ieee transactions large scale integration vlsi systems v15 n10 p11601171 october 2007 haris lekatsas jrg henkel wayne wolf design simulation pipelined decompression architecture embedded systems proceedings 14th international symposium systems synthesis september 30october 03 2001 montral pq canada seokwon seong prabhat mishra efficient code compression technique using applicationaware bitmask dictionary selection methods proceedings conference design automation test europe april 1620 2007 nice france haris lekatsas jrg henkel wayne wolf code compression low power embedded system design proceedings 37th conference design automation p294299 june 0509 2000 los angeles california united states x h xu c clarke r jones high performance code compression architecture embedded armthumb processor proceedings 1st conference computing frontiers april 1416 2004 ischia italy jari heikkinen jarmo takala effects program compression journal systems architecture euromicro journal v53 n10 p679688 october 2007 paulo centoducatte guido araujo ricardo pannain compressed code execution dsp architectures proceedings 12th international symposium system synthesis p56 november 0104 1999 timothy sherwood brad calder patchable instruction rom architecture proceedings 2001 international conference compilers architecture synthesis embedded systems november 1617 2001 atlanta georgia usa talal bonny joerg henkel efficient code density lookup table compression proceedings conference design automation test europe april 1620 2007 nice france youtao zhang jun yang rajiv gupta frequent value locality valuecentric data cache design acm sigops operating systems review v34 n5 p150159 dec 2000 youtao zhang jun yang rajiv gupta frequent value locality valuecentric data cache design acm sigplan notices v35 n11 p150159 nov 2000 haris lekatsas jrg henkel wayne wolf code compression variable hardwaresoftware codesign proceedings eighth international workshop hardwaresoftware codesign p120124 may 2000 san diego california united states shlomo weiss roman tsikel approximate prefix coding systemonachip programs journal systems architecture euromicro journal v48 n1315 p367375 may darko kirovski johnson kin william h mangionesmith procedure based program compression international journal parallel programming v27 n6 p457475 1999 e wanderley netto r azevedo p centoducatte g araujo multiprofile based code compression proceedings 41st annual conference design automation june 0711 2004 san diego ca usa guido araujo paulo centoducatte mario cartes ricardo pannain code compression based operand factorization proceedings 31st annual acmieee international symposium microarchitecture p194201 november 1998 dallas texas united states jack liu fred chow timothy kong rupan roy variable instruction set architecture compiler support ieee transactions computers v52 n7 p881895 july jun yang youtao zhang rajiv gupta frequent value compression data caches proceedings 33rd annual acmieee international symposium microarchitecture p258265 december 2000 monterey california united states israel waldman shlomit pinter profiledriven compression scheme embedded systems proceedings 3rd conference computing frontiers may 0305 2006 ischia italy montserrat ros peter sutton postcompilation register reassignment technique improving hamming distance code compression proceedings 2005 international conference compilers architectures synthesis embedded systems september 2427 2005 san francisco california usa brad calder chandra krintz urs hlzle reducing transfer delay using java class file splitting prefetching acm sigplan notices v34 n10 p276291 oct 1999 alberto macii enrico macii fabrizio crudo roberto zafalon new algorithm energydriven data compression vliw embedded processors proceedings conference design automation test europe p10024 march 0307 andreas dandalis viktor k prasanna configuration compression fpgabased embedded systems proceedings 2001 acmsigda ninth international symposium field programmable gate arrays p173182 february 2001 monterey california united states montserrat ros peter sutton hamming distance based vliwepic code compression technique proceedings 2004 international conference compilers architecture synthesis embedded systems september 2225 2004 washington dc usa kelvin lin chungping chung jean jyhjiun shann compressing mips code multiple operand dependencies acm transactions embedded computing systems tecs v2 n4 p482508 november montserrat ros peter sutton compiler optimization ordering effects vliw code compression proceedings international conference compilers architecture synthesis embedded systems october 30november 01 2003 san jose california usa shaoyang wang rongguey chang code size reduction compressing repeated instruction sequences journal supercomputing v40 n3 p319331 june 2007 mats brorsson mikael collin adaptive flexible dictionary code compression embedded applications proceedings 2006 international conference compilers architecture synthesis embedded systems october 2225 2006 seoul korea talal bonny joerg henkel using linkernighan algorithm lookup table compression improve code density proceedings 16th acm great lakes symposium vlsi april 30may 01 2006 philadelphia pa usa arvind krishnaswamy rajiv gupta dynamic coalescing 16bit instructions acm transactions embedded computing systems tecs v4 n1 p337 february 2005 kelvin lin jean jyhjiun shann chungping chung code compression register operand dependency journal systems software v72 n3 p295304 august 2004 keith cooper nathaniel mcintosh enhanced code compression embedded risc processors acm sigplan notices v34 n5 p139149 may 1999 john gilbert david abrahamson adaptive object code compression proceedings 2006 international conference compilers architecture synthesis embedded systems october 2225 2006 seoul korea greive gunnar braun andreas andreas rainer leupers oliver schliebusch heinrich meyr instruction encoding synthesis architecture exploration using hierarchical processor models proceedings 40th conference design automation june 0206 2003 anaheim ca usa ahmad zmily christos kozyrakis simultaneously improving code size performance energy embedded processors proceedings conference design automation test europe proceedings march 0610 2006 munich germany stephen hines david whalley gary tyson adapting compilation techniques enhance packing instructions registers proceedings 2006 international conference compilers architecture synthesis embedded systems october 2225 2006 seoul korea marc l corliss e christopher lewis amir roth dise implementation dynamic code decompression acm sigplan notices v38 n7 july charles lefurgy eva piccininni trevor mudge evaluation high performance code compression method proceedings 32nd annual acmieee international symposium microarchitecture p93102 november 1618 1999 haifa israel lars rder clausen ulrik pagh schultz charles consel gilles muller java bytecode compression lowend embedded systems acm transactions programming languages systems toplas v22 n3 p471489 may 2000 stephen hines joshua green gary tyson david whalley improving program efficiency packing instructions registers acm sigarch computer architecture news v33 n2 p260271 may 2005 stephen hines gary tyson david whalley reducing instruction fetch cost packing instructions registerwindows proceedings 38th annual ieeeacm international symposium microarchitecture p1929 november 1216 2005 barcelona spain subash chandar mahesh mehendale r govindarajan area power reduction embedded dsp systems using instruction compression reconfigurable encoding journal vlsi signal processing systems v44 n3 p245267 september 2006 chandra krintz brad calder han bok lee benjamin g zorn overlapping execution transfer using nonstrict execution mobile programs acm sigops operating systems review v32 n5 p159169 dec 1998 yuan xie wayne wolf haris lekatsas code decompression architecture vliw processors proceedings 34th annual acmieee international symposium microarchitecture december 0105 2001 austin texas jeremy lau stefan schoenmackers timothy sherwood brad calder reducing code size echo instructions proceedings international conference compilers architecture synthesis embedded systems october 30november 01 2003 san jose california usa marc l corliss e christopher lewis amir roth dise programmable macro engine customizing applications acm sigarch computer architecture news v31 n2 may marc l corliss e christopher lewis amir roth implementation evaluation dynamic code decompression using dise acm transactions embedded computing systems tecs v4 n1 p3872 february 2005 luca benini francesco menichelli mauro olivieri class code compression schemes reducing power consumption embedded microprocessor systems ieee transactions computers v53 n4 p467482 april 2004 larin thomas conte compilerdriven cached code compression schemes embedded ilp processors proceedings 32nd annual acmieee international symposium microarchitecture p8292 november 1618 1999 haifa israel stephen roderick hines gary tyson david whalley addressing instruction fetch bottlenecks using instruction register file acm sigplan notices v42 n7 july 2007 oliver rthing jens knoop bernhard steffen sparse code motion proceedings 27th acm sigplansigact symposium principles programming languages p170183 january 1921 2000 boston usa christopher w fraser instruction direct interpretation lz77compressed programs softwarepractice experience v36 n4 p397411 april 2006 rpd beszdes rudolf ferenc tibor gyimthy andr dolenc konsta karsisto survey codesize reduction methods acm computing surveys csur v35 n3 p223267 september
fast accurate algorithms projective multiimage structure motion abstractwe describe algorithms computing projective structure motion multiimage sequence tracked points algorithms essentially linear work motion moderate size give accuracies similar maximumlikelihood estimate give better results sturmtriggs factorization approach equally fast much faster bundle adjustment experiments show iterated sturmtriggs approach often fails linear camera motions addition study experimentally common situation calibration fixed approximately known comparing projective versions algorithms mixed projectiveeuclidean strategies clarify nature dominantplane compensation showing considered smalltranslation approximation rather approximation scene planar show projective algorithms accurately recover projected inverse depths homographies despite possibility transforming structure motion projective transformation b introduction paper extends previous multiimage structurefrommotion sfm algorithms 182616 24 euclidean projective context previously assumed camera calibration known fixed new versions algorithms handle sequences varying unknown calibrations also adapt algorithms common situation calibration measured moderate errors known fixed previous work aim approach fast accurate sequences small signal ie small translational image displacements small signal makes reconstruction problem difficult effective algorithm must exploit information sequence require intrinsically multiimage approach 19 1 hand small displacements simplify problem finding correspondence limit effects correspondence outliers reconstruction since correspondence errors cannot large motivated factors 182616 disregard correspondence problem present algorithm reconstructs pretracked point features large number images see 2120 extensions approach direct method 58 reconstructs directly image intensities well pretracked point line data small displacements scene points visible images makes possible use fast factorization methods 1826163130 also means one use multiple images eliminate correspondences outliers found good way get reliable feature tracks compute correspondences first image pairs restrict features tracked consistently images eliminating features lowers signal intrinsically multiimage approach effectively exploits consistent feature tracks entire sequence becomes even crucial past work focus scenes large range depths camera large perspective effects factorization approaches previous work could handle shallowdepth scenes one use algorithms 31 complement approach assumptions large depth range small image displacements imply camera motions small designed approaches exploit present two classes algorithms one works motions truly general ie camera positions lie single plane expect effective motions approach 16 describe one determine selfconsistently whether 1 intrinsically multiframe approach either batch recursive mean one reconstructs directly many images rather first reconstructing subsets images combining results motion general enough approach work second approach works moderatesized motions effective camera moves roughly along line propose mainly type motion however experiments show also works well camera moves plane makes unrestricted 3d motions unlike projective factorization approach sturm triggs 30 approach needs initial guess projective depths succeeds situations sturmtriggs algorithm 30 fails usually gives better results factorizes smaller matrix used sturm triggs thus faster large problems discussion illustrates number interesting theoretical points demonstrate close analogy recovering rotations euclidean context recovering 2d projective transforms homogra phies projective one show compensating dominant plane 92711 understood smalltranslation approximation rather approximation scene planar show algorithms recover projected inverse depths homographies even projective sfm experiments focus common situation camera calibration remains fixed sequence approximately known experiments general motion show algorithm gives fast computation projective structure approaches accuracy maximumlikelihood leastsquares estimate mixed euclideanprojective strategy somewhat better completely projective one experiments linear motions find euclidean approach slightly wrong calibration better projective one intermediate translation directions worse translations close image plane viewing direction results compare well projective maximumlikelihood estimate finally show approach also gives better results sturmtriggs approach camera moves plane 11 summary next section describes notation preliminary results need derive algorithms section 21 shows one accurately recover projected inverse depths despite freedom alter structure projective transform section 22 characterizes image displacements caused cameras motion calibration changes section 23 characterizes flows due infinitesimal 2d projective transforms ie infinitesimal homographies section 3 describes generalmotion algorithm fully projective mixed euclideanprojective versions results algorithm presented section 34 section 4 describes algorithm specialized lineartranslation case section 43 gives results experiments section 44 explains extend handle translational motion preliminaries notation definitions use matlab notation semicolon separates entries column vector comma space separates entries row vector colon indicates range indices denote average value quantity x hxi matrix size singular values much bigger rest refer large singular values leading singular values corresponding singular vectors leading singular vectors given vector v define v 2 length2 vector consisting first two components v v 3d point define ideal image point corresponding v v j v 2 v z note take ideal image focal length 1 define 3d point v 1 corresponding 2d point v 1 v 1 j theta 3 theta 3 matrix v 1 2d image point let v 1 denote image point obtained v 1 multiplying use notation v 1 theta v 2 mean v 3d vector identity theta z theta z 1 mv z note general assume n quantities indexed define fig denote lengthn column vector whose ath element also use notation upsilon indicate column vector typically long vector length greater 3 similarly quantities ab indexed b let denote matrix whose bth entry ab let n p points tracked n images label images 1g take zeroth image reference image define pm j mth 3d point coordinate system zeroth image let p denote mth image point ith image let let k denote calibration matrix ith image define respect ideal image eg neglecting noise take calibration matrices standard upperdiagonal form 22 k i0 let r represent translation rotation reference image 0 ith image define motion 3d point p r p z refer 0i 3d epipoles since epipoles reference image given e 21 projective inverse depths experiments report results projected inverse depths show one recover accurately projective sfm projective context one recover structure projective transform pi pi 4 theta4 matrix structure changes pi delta scalars dividing z 0 zm rewrite pm noisefree ideal image coordinates since adopt coordinate system zeroth image need consider pi leave image points fixed image generic scenes first three rows pi must form theta 1 3 3 theta 3 identity matrix 0 3 length3 column zeros implies small effects noise one accurately recover inverse depths additive plane multiplicative scale define n p theta n p projection matrix ql annihilating three vectors f1g fxg fyg 2 implies one accurately recover projection ql scale small effects noise experiments compare accuracy various algorithms recovering projection 22 image displacements due varying calibration consider two images eg images 0 neglect noise note theta one eliminate k denominator right since theta 1 let represent image point one would get pure translation without changing original calibration write image displacements sum pure translational piece remaining piece contains rotational effects recall z theta z one rewrite rm tm tm thus rm represent displacements due pure 2d projective transform k r form 3 leads naturally algorithms described 23 infinitesimal 2d projective transforms algorithm requires characterizing form infinitesimal 2d projective transform homography suppose set image points p 0 given small 2d projective transform image points pm write 3 theta 3 matrix f 3 theta 3 identity matrix small f 2 theta 2 matrix j 2 theta 1 vectors 2d image displacements 8 parameters f j define length2 vector h b giving corresponding firstorder displacement due infinitesimal homography thus xm ym xm ym 2 define 8 theta 2 matrix hm bth column h equals h b 24 additional definitions algorithms homography flow vectors psi b assuming n p image points define eight length2n p homog raphy flow vectors psi b corresponding h b defined fxyg phi define 2n p theta 8 matrix psi bth column equals psi b translational flow vectors phi b define three length2n p translationalflow vectors phi z corresponding translational displacements 3 phi f0g phi let image displacement matrix organize observed image displacements n gamma 1 theta 2n p matrix putting x coordinates given image single row bias compensation matrix c define use f note one compute products c gamma12 c n computation modified translation vectors ca 2 fx g lengthn gamma 1 vector whose elements 0i define 3 generalmotion algorithm assumptions approach 16 algorithm requires translational motion large eg jt 0 j z 13 camera positions lie plane one automatically detect camera moving plane line use approach algorithm ii 26 31 algorithm proj step p1 homography compensation assuming translations zero recover homographies separately reference image subsequent image compensate homographies defining compensated image p let image displacements displacement matrix refer compensated image points p cm step p2a homography elimination using householder matrices 254 compute 2n annihilates subspace generated 8 vectors projection ie rows h orthogonal step p2b singular value decomposition define modified displacement matrix compute singularvalue decomposition svd let 123 three leading right singular vectors dch let j theta 2 3 step p3a depth recovery recover depths solving linear system theta gammaphi phi gammaphi phi z gammaphi z gamma1 3 theta 3 matrix u step p3b translation recovery using recovered values phi solve linear system cx cy cz phi phi z ca ft 0 g given ft 0 ca step p4 improved homography recovery let 0i represent current estimates 0i solve linear system theta theta theta pma j pm 10 f j estimate residual homography reference image image step p5 iteration optional iteratively repeat convergence following 1 compensate residual homographies newly computed step p4 2 repeat steps p2bp4 32 discussion step p1 homography compensation preprocessing step sometimes unnecessary purpose make effective motion smaller one could also apply step sturmtriggs approach 30 since approach like works best small motions errors recovering scale size translational image displacements fi fi correction term denote average sizes image noise inverse depths translations moderatetranslation assumption fi fi small compensating equivalent compensating dominant plane 2 9 2711 formulation makes clear one understand compensation smalltranslation approximation rather approximation scene planar 2 though initial step method 9 subsequent algorithm differs two important respects linear corrects firstorder errors compensation dominant plane steps p2a b homography elimination svd one compute h products n p computation 16 current implementation computes products h 2 labs overhead makes n p implementation quite slow homography compensation step p1 z theta z neglect denominator 11 since causes second order correction multiplying h eliminates firstorder corrections due ffim second order get bilinear expression cx cy cz z step 2b based approximating dch bilinear structure motion use h annihilate residual homographies derives opticalflow technique jepson heeger 10 generalized 25 apply arbitrary rather regular imagepoint configurations sideways translations denominator 11 exactly equals 1 succeed making residual homography ffim small example means iteration step p5 dch becomes exactly bilinear sideways translations matter big thus algorithm capable giving good results large sideways translations 3 experiments 14 euclidean version approach show iterating typically make residual rotations small even large translations rotations euclidean equivalent homographies implies iterating also make ffim small approach succeed large sideways translations confirmed test sequences see however approach intended mainly small moderate translations discussed 16 multiplying c gamma12 reduces bias due singling reference image special treatment algorithm requires dch 3 singular values much larger rest precise form impose generalmotion assumption dch 3 large singular values given sequence one use algorithm ii rather approach section 3 presented algorithm specialized sideways motions 26 step p3a depth recovery 8 reflects fact recovered right singular vectors b must generate approximately subspace three translational flow vectors phi xyz discussed section 21 one recover z gamma1 additive plane multiplicative scale one see explicitly fact h annihilates contributions phi xyz components lengthn p vectors one solve 8 n p computation discussed 16 current implementation use simple 3 step p4 improved homography recovery 11 get theta theta theta denotes size error estimating 0i denotes average size 0i fi fi j denote average sizes inverse depths noise define f j 4 13 5 give linear system 10 linear system 10 determine residual homographies ffim unambiguously reflects projective covariance equations one free change projective basis changes values ffim z gamma1 0i discussed section 21 one characterize projective transforms leave reference image fixed effects z gamma1 remove ambiguity recovering ffim setting zero part ffim would add plane inverse depths remark one could also estimate improved values image points step 4 algorithm 16 implemented 33 variations algorithm presented fully projective handle arbitrary changes linear calibrations images sequences taken single camera calibration remains essentially constant sequence possible exception focal length considered simple modifications step p1 exploit one variation fixed algorithm recovers homographies reference subsequent images leastsquares optimization assumption calibration k fixed like original step p1 assumes translations zero variations exploit fact calibration error typically small one neglect homographies k rk gamma1 approximate pure rotations r projnocomp variation algorithm compensate homographies simply eliminating step p1 version projunrot approximates k pure rotation instead step p1 computes compensates best rotations transforming reference image subsequent images 16 finally compared projective algorithms euclidean version algorithm described 16 34 generalmotion experiments following synthetic experiments motion structure image noise varied randomly trial sequences consisted 15 images points field view fov 3d depths varied 20 z 100 experiments 14 randomly chose translation component respect zeroth camera position gammat max xyz tmax added random rotations maximum 20 ffi experiment 5 motion consists scene rotation corresponds large camera translations cameracentered coordinates poses serious challenge approach since targeted moderate translations algorithms eg twoimage tomasikanade approach appropriate situation 1931 noise onepixel gaussian assuming 512 theta 512 image specified fov simulated calibration error multiplying images derived matrix k corresponds calibration error focal length 510 table 1 shows results several versions algorithm comparison maximumlikelihood estimates entries give mean error degrees trials recovered groundtruth values ql section 21 proj refers algorithm section 31 pu refers projunrot described mle gives results maximumlikelihood leastsquares estimate computed standard levenbergmarquardt steepestdescent approach starting ground truth expt seqs proj pu euc mle tmax table 1 experiments 15 general motion average errors degrees projected inverse depths 1g euc euclidean algorithm 16 projunrot gives best tabulated results fixed results shown comparable good enough justify extra computational cost small translations algorithm accurate projunrot 11 worse mle euc also well results 12 worse projunrot one reasons good performance projunrot euc calibration error ie difference k identity matrix moderate expected algorithm relatively less well mle experiment 5 however large baselines experiment resulting translational image displacements constrain reconstruction strongly algorithms still give good results ie projunrot averages better 7 error also computed results shown another variation algorithm instead step p1 computed homographies reference subsequent images single optimization one way use 2d version sturmtriggs approach 3015 since step p1 computes transform image 0 image separately overweights reference image noise computing transforms simultaneously avoid however found singleoptimization approach improve results realimage sequence tested algorithm castle real image sequence available cmu figure 1 shows first image sequence generated images experiment multiplying correctly calibrated images unit focal length 122 shifting 0403 0093 center images scale unity thus assumed focal length incorrect factor 122 pure projective approach proj gave error projected inverse depths 40 ffi compared 04 ffi mle euc gave error 282 ffi largeness euclidean error due large error assumed focal length since scene sequence shallow depth affine approach tomasikanade figure 1 castle image algorithm 31 appropriate 16 comparison sturmtriggs approach sturmtriggs algorithm 30 factorization method like deals well small motions large perspective effects compared approach algorithm using implementation created previously purposes optimized code sturmtriggs algorithm extent sturmtriggs implementation followed advice 32 applying algorithm first centered scaled image unit box normalized homogenous image point unit norm initialized algorithm setting unknown projective depths equal one 3217 appropriate small motions since aim true multiimage technique works low signaltonoise compute projective depths two three images original algorithm 30 proven 15 iterative version sturmtriggs algorithm converges also tested approach iterated version implementation steps p2 p3 algorithm requires 80 lines matlab code steps p4 p5 require additional 30 iterative version sturmtriggs approach requires 80 lines created synthetic sequences using groundtruth structure two realimage sequences umassmartinmarietta rocketfield sequence 3 umass puma sequence 12 points rocketfield sequence range 17 67 depth cover effective fov 37 ffi puma points range 13 32 depth cover effective fov 33 ffi table 2 gives parameters experiments table 3 shows errors recovering projected inverse depths epipoles zeroth image homographies table 2 indicates experiments image different randomly chosen calibration define r random number chosen uniformly interval gammaa n images selected calibration matrix via theta theta theta theta theta theta chose r separately entry matrix table 2 gives size added noise pixels define size pixel taking maximum magnitude image point coordinates correspond 256 pixels note applying calibration matrix k since shift camera center due theta 123 displaces image region origin noise usually larger would image region centered origin define epipole error sequence average images true true calc e true calculated true epipoles reference image one show section 21 projective transforms leave reference image fixed also leave epipoles fixed obtain homography error sequence averaging homography error images 1 homography error mean error recovering k projective transform leaves reference image fixed one show changes matrix true noise v length3 vectors g 3 theta 3 homography matrix ith image define corresponding invariant homography matrix invar use backslash notation matlab ie e true matrix division e true g definition invar invariant noise projective transforms leave reference image fixed denote recovered homographies define homography error image angle degrees length9 vectors v true v calc contain entries respectively invar invar expt struct uncalib oe oe rot noise st proj deg pix itermax itermax table 2 parameters experiments comparing proj sturmtriggs approach st struct column indicates structure used generate sequences 1 uncalib column indicates introduced different calibrations image see text choose x z independently gaussian variables columns labelled oe tabulate standard deviations xyz oe rot characterizes typical size rotations noise column indicates standard deviation gaussian noise added remaining two columns indicate maximum number iterations allowed respectively sturmtriggs approach step p5 proj algorithm results show algorithm proj usually gives better results structure motion sturmtriggs approach one iteration proj takes slightly longer one iteration sturmtriggs approach recall current implementation slower necessary however preprocessing step p1 initial homography recovery accounts computation time table 3 shows factorization part algorithm steps p2p3 four times faster sturmtriggs approach also computation times experiment 7 suggest approach converges quickly sturmtriggs method see also section 44 also checked performance algorithm sequence large sideways translations puma structure oe refer table 2 definition r algorithm gave errors projected depths 16 sequence largest translation size 134 comparable 139 distance closest 3d point cameras reference position 4 algorithm ii algorithm presented assumes translational motion sufficiently general ie camera locations lie close line plane section present version algorithm deals common case camera moving along line one extend deal expt time sec z gamma1 epis epis homog homog cycles 9 0042 019 015 86 84 81 27 69 18 54 1 9med 004 019 015 68 67 71 11 28 11 49 1 43 32 14 1 11med 004 019 015 91 11 11 14 28 23 52 1 19med table 3 results experiments parameters given previous table nocomp nc refer steps p2 p3 proj algorithm without computation initial compensation homographies columns labelled st give results sturmtriggs approach present errors projected inverse depths z gamma1 epipoles epis homographies homog see text explanation error measures used cycles column indicates number cycles used proj step p5 quantities shown represent mean results 100 random trials except rows labelled med quantities represent median 100 random trials general motions camera moving plane 3d describe briefly definitions let unit vector 0 denote direction 0i let j let theta denote n gamma 1 theta n p matrix whose mth element equals pm gammat 0 theta n p theta n p projection matrix annihilates subspace generated eight vectors ae theta h b oe one show subspace fivedimensional 41 algorithm description step l0 rescaling transform images center origin scale choose scale reference image end algorithm transform recovered unknowns back coordinate system original reference image step l1 homography compensation assuming translations zero recover homographies separately reference image subsequent image define compensated image p let image displacements displacement matrix refer compensated image points p cm step l2a using householder matrices 254 compute n annihilates subspace generated six lengthn p vectors f1g projection step l2b linear translation recovery solve linear system 0 step l3 iterative improvement recovered translation starting previous estimate minimize error trace theta theta respect 0 take step l4 improved homography recovery step p4 generalmotion approach step l5 iteration optional step p5 generalmotion approach 42 discussion step l0 6 1813 step reduces bias linear algorithm step l2 step l2 step projective algorithm exactly euclidean algorithm 18 difference projective algorithm computes estimate kt rather however projective case linear algorithm exploits available information gives better approximation result minimizing full error since hl annihilates one degree freedom q 5 projective linear algorithm uses one available constraints euclidean linear algorithm forgoes three available constraints one show additional lengthn p vector annihilated hl z z linear motion 3 becomes z assume compensated homographies step l1 groundtruth value noise independent denominator 16 thus residual homographies ffim small algorithm works size direction translation 18 also holds step l3 step l1 suffice make ffim small iteration step l5 may thus expect algorithm work even large translations euclidean version approach shown 14 step l3 e 0 near fov instead steps l2 l3 one could use recent method srinivasan 2928 find true global minimum 15 directly important since 142 showed leastsquares error typically several local minima e near image region yet implemented srinivasans approach remark one could also recover z gamma1 1823 improve homography computation step p4 generalmotion algorithm since straightforward transcriptions previous methods discuss 43 lineartranslation experiments generated sequences experiments 14 except camera translated constant steps 02 along line random rotations created 400 sequences choosing random directions imageplane projections systematically varying 01 4 steps 01 figure 2 shows mean angular errors recovering 0 three versions algorithms pure euclidean approach 1823 projective approach algorithm ii algorithm ii step l1 replaced initial compensation rotations derived curve labeled mle first using levenbergmarquardt compute maximumlikelihood leastsquares projective reconstruction computing calibration motions leastsquares minimization euclidean estimate worse projective ones parallel image plane z comparable 4 intermediate overall median results slightly better 4 verified euclidean approach gives bad results z simply calibration error calibration error perform well parallel image plane degrees figure 2 angular errors recovering 0 x axis shows lower limit bin size 025 data point average 25 trials indicated bin cyan circles mle blue squares euclidean x linear projective algorithm initial compensation rotations homographies respectively projective algorithms also ran algorithm ii initial projective compensation 55 choices image pairs castle sequence figure 1 algorithm recovered 0 average error 11 ffi compared 071 ffi mle median errors two approaches respectively 80 ffi 40 ffi maximum errors 66 ffi 44 ffi though assumed focal length incorrect factor 122 section 34 approach nearly well mle large error focal length variation initially compensating rotation instead homography yielded relatively large errors 10 ffi rotation euclidean algorithm usually recovered 0 accurately apart 13 outliers possibly due local minima euclidean algorithm recovered 0 average error 51 ffi comparison sturmtriggs approach compare algorithm ii sturmtriggs ap proach created synthetic sequences 16 images 32 points using structure puma sequence let true denote true translation direction z viewing direction reference image systematically varied angle true ji 0 ffi 86 ffi increments 29 ffi selected true created sequences chose projection true xy plane randomly sequence image randomly chose rotation r oe standard deviation 5 ffi rotation around axis randomly uniformly chose translation magnitudes maximum 1 recall puma depths range 1332 introduced varying angular error recovered epipole deg figure 3 angular errors recovering 3d epipole 0 sturmtriggs approach algorithm ii plotted versus true trials triangles show result one sturmtriggs iteration diamonds show sturmtriggs result convergence cut 300 iterations algorithm converge number shows linear estimate algorithm ii step l2 shows result nonlinear minimization step l3 algorithm ii calibrations experiments 619 added gaussian noise 005 pixels assuming maximum magnitude image point coordinates corresponded 256 pixels figure 3 compares results algorithm ii sturmtriggs approach 3d epipoles data point represents mean 30 trials indicated value true approach plot results error calc true true value 3d epipole calc value recovered since sturmtriggs approach recovers different 3d epipole 0i st image plot average error ii approach show errors initial linear estimate step l2 one iteration nonlinear estimate step l3 comparison show sturmtriggs estimates one iteration algorithm either converges reaches 300 iterations one iteration sturmtriggs approach much worse linear estimate converged sturmtriggs result also much worse linear estimate almost good nonlinear estimate nonlinear algorithm averaged 2 seconds computation linear algorithm took fractions second iterated sturmtriggs approach averaged 9 seconds also applied iteration step l5 allowed algorithm ii converge average figure 4 first image rocketfield sequence sequences number cycles till convergence 4 average time till convergence 8 seconds less 9 seconds sturmtriggs approach sturmtriggs approach averaged 177 iterations however used much stricter convergence criterion sturmtriggs approach give chance converge accurate result proven 15 sturmtriggs approach minimizes particular error function defined algorithm converged error changed less iterations defined algorithm ii converged residual homography recovered step l4 satisfied additional comparison ran step l5 iteration algorithm ii 100 sequences similar defining convergence average step l5 converged 75 cycles always less 15 figure 5 shows similar results homography recovery homography error defined section 34 also tested algorithm ii sturmtriggs approach rocketfield realimage sequence 3 see figure 4 sequence large translations ranging 75 magnitude recall depths vary 17 67 camera moves approximately along line deviating average direction 15 ffi steps l2 l3 approach recovered 0 errors 58 ffi 64 ffi respectively steps l1 l4 recovered homographies average errors 28 ffi 20 ffi initial sturmtriggs estimate average errors 147 ffi 155 ffi 0 homographies respectively 100 iterations sturmtriggs approach gave errors 33 ffi 71 found sturmtriggs approach gives poor results linear motion motion forward backward created sequences 16 images 32 points randomly chosen structures depths varied 40 60 translation direction 01 01 1 randomly 1 rotations oe zero noise allowed sturmtriggs approach 3000 iterations converge defined converged error changed less iterations proved 15 sturmtriggs algorithm eventually converge local minimum error 9 trials algorithm large errors recovering epipoles average error 44 ffi trials maximum error linear estimate step l2 015 ffi similar set sequences rotations 15 ffi sturmtriggs approach gave large errors 25 approach gave nearly perfect results also found sturmtriggs approach often failed converge correctly used structure puma sequence generate sequences failures produced bad initial choice projective depths causes sturmtriggs approach converge incorrect local minima error small forward backward motions way get good initial estimates projective depthsone cannot compute accurately small number images 30 proposed also projective error surface flat epipoles away forwardmotion direction 17 tends local minima near image points 14217 initial choice projective depths corresponds epipole far image region factors could cause local minimum intercept algorithm prevent converging true global minimum 44 extension general motion describe extend algorithm ii motion 26 step l0 rescaling step l1 homography compensation step l2 define h hl compute svd dch let ns 3 number large singular values dch let right left singular vectors corresponding singular values let oe denote leading singular values dch define 2n oe 1 step l0 step l0 steps l1l2 steps p1 p2 generalmotion algorithm homography errors figure 5 errors recovering homographies sturmtriggs approach algorithm ii plotted versus true images sequence triangles show result one sturmtriggs iteration diamonds show sturmtriggs result convergence cut 300 iterations algorithm converge number shows initial estimate algorithm ii step l1 shows result step l5 algorithm ii converged step l3a 1 ns define npm define h hn x step l3b linear estimates effective translation directions let unit vector 0s translation direction corresponding solve ni theta leastsquares sense 0s step l3c refinement effective translation directions refine estimate 0s minimizing respect 0s step l4a isolate translational flow recall hm 8 theta 2 matrix bth column hm equals h b compute length8 vector w solving pm gammat 0s hmw compute delta h step l4b depth recovery solve linear system z oe z gamma1 4ns constants step l4c full translation recovery recover translations via theta phi x z step l5 improved homography recovery steps l4 p4 algorithms described step l6 iteration optional steps p5 l5 algorithms described 441 discussion algorithm projective version euclidean algorithm 26 step l3 translationdirection recovery leading singular vector corresponds effective translation direction 0s recover 0s exactly algorithm ii step l4ab isolate translational flow depth recovery leading singular vector hmw effective infinitesimal homography one cannot determine uniquely due projective covariance specify setting zero components w would add plane z gamma1 constants necessary since step l4a recovers homographies ambiguity 0 6 z gamma1 corresponding recovered may differ additive plane z gamma1 need scales fix scale z gamma1 different singular vectors introduce singular value oe 18 emphasize singular vectors larger singular values since less noise sensitivity 442 experiments created 100 sequences general motion experiments 619 using puma structure varying calibration oe refer table 2 ran extended version algorithm ii without iterative refinement translations step l3c without iteration step l6 without steps l3c l6 extended algorithm purely linear iteration apart svd linear equation solving compared results sturmtriggs st algorithm allowed 300 iterations converge average st required 135 iterations converge noniterative version algorithm averaged 021 seconds computation compared 70 seconds iterated sturmtriggs ist approach gave average error projected z gamma1 139 ffi compared 163 ffi ist average error computing epipolar directions 88 53 ffi average homography error 016 ffi ist 052 ffi single iteration st gave average error 297 ffi epipoles 32 ffi homographies created second set 100 sequences planar motion parameters first achieved planar motions creating setting third singular value matrix translations zero average errors projected z gamma1 162 average errors epipolar directions 44 ist average errors homographies 011 average ist took 140 iterations converge first iteration st gave average error 33 ffi epipolar directions 37 ffi homographies also ran ist 11 iterations check speed convergence took average 061 seconds gave average errors 51 ffi 229 ffi 24 ffi projected inverse depths epipolar directions homographies respectively 443 approximately linear planar motions happens apply algorithm ii extension restrictive motion modelfor example assuming planar motion camera centers lie exactly plane extent neglect denominator 3and causes small second order effects translations smallthis causes additional error structure recovery applying algorithm restrictive motion model means using ns leading singular vectors dimensionality translational motion greater ns ie neglect smaller components translational motion prevent us recovering good approximation translations projected ns dimensional subspace since singular vector gives separate estimate z gamma1 effect structure recovery restricting subset singular vectors lose information could used improve estimates ran extended algorithm ii sequences created test algorithm 100 generalmotion sequences ran algorithm without iterative refinement translations step l3c without iteration step l6 obtained average error projected inverse depths 137 ffi less result ist error projected true 3d epipoles plane epipolar directions recovered algorithm average error recovering 3d epipoles plane 64 ffi average error step l5 recovering homographies 020 ffi results suggest advantageous ignore smaller leading singular values vectors good deal noise contamination sequences x z components translational motion similar magnitudes smallness fov causes signal ie image displacements ztranslations much smaller directions one detect smallness third leading singular value dch sequences often much bigger noise effects one recovered structure accurately using subset leading singular vectors one return calculate translational components corresponding neglected leading singular vectors conclusions presented fast projective structurefrommotion algorithms comparable accuracy mle appear superior sturmtriggs approach 30 algorithms work motion long camera displacements big jtj z 13 16 showed experimentally sturmtriggs approach often fails linear camera motions especially forward backward motions speculated recent characterizations projective leastsquares error surface 17214 may offer part explanation studied advantages pure projective approach versus mixed euclideanprojective strategy common situation calibration fixed partly known showed algorithms recover projected inverse depths homographies even projective sfm clarified nature dominantplane compensation showing considered smalltranslation approximation rather planarscene approximation r recursive structure motion image sequences using shape depth spaces optimal structure motion local ambiguities global esti mates data set quantitative motion analysis matrix computations direct multiresolution estimation egomotion structure motion defense eightpoint algorithm projective structure motion image sequences using subspace methods direct methods recovering motion unified approach moving object detection 2d 3d scenes linear subspace methods recovering translational direction direct recovery shape multiple views parallax based approach sensitivity pose refinement problem accurate estimation camera parameters removal translation bias using subspace methods three algorithms 2image 2image structure motion fast accurate selfcalibration multiframe structure motion algorithm perspective projection new structure motion ambiguity recovering heading structure constantdirection motion critique structure motion algorithms direct multiframe structure motion handheld cameras structure motion using points lines intensities fast algorithms projective multiframe structure motion computing camera heading multiple frames multiframe structure motion perspective linear solution multiframe structure motion structure linear planar motions simplifying motion structure analysis using planar parallax image warping extracting structure optical flow using fast error search technique fast partial search solution 3d sfm problem factorization based algorithm multiimage projective structure motion shape motion image streams orthography factorization method factorization methods projective structure motion tr ctr lionel moisan brenger stival probabilistic criterion detect rigid point matches two images estimate fundamental matrix international journal computer vision v57 n3 p201218 mayjune 2004 john oliensis exact twoimage structure motion ieee transactions pattern analysis machine intelligence v24 n12 p16181633 december 2002 p anandan michal irani factorization uncertainty international journal computer vision v49 n23 p101116 septemberoctober 2002 john oliensis leastsquares error structure infinitesimal motion international journal computer vision v61 n3 p259299 februarymarch 2005 amit k roy chowdhury r chellappa stochastic approximation ratedistortion analysis robust structure motion estimation international journal computer vision v55 n1 p2753 october
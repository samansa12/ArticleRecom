clock synchronization faults recoveries extended abstract present convergencefunction based clock synchronization algorithm simple efficient faulttolerant algorithm tolerant failures allows recoveries long less third processors faulty time arbitrary byzantine faults tolerated without requiring awareness failure recovery contrast previous clock synchronization algorithms limited total number faults throughout execution realistic assumed fault detection use algorithm ensures secure reliable time services requirement many distributed systems algorithms particular secure time fundamental assumption proactive secure mechanisms also designed allow recovery arbitrary faults therefore work crucial realize mechanisms securely b introduction accurate synchronized clocks extremely useful coordinate activities cooperating processors therefore essential many distributed algorithms sys tems although computers usually contain hardwarebased clock imprecise substantial drift highly precise clocks expensive cumbersome furthermore even hardwarebased clocks prone faults andor malicious resetting hence clock synchronization algorithm needed lets processors adjust clocks overcome effects drifts failures algorithm maintains processor logical clock based local physical clock messages exchanged processors algorithm must deal communication delay uncertainties clock imprecision drift well link processor faults many systems main need clock synchronization deal faults rather drift drift rates quite small works eg 11 12 actually ignore drifts noted however clock synchronization ongoing task never terminates realistic limit total number faults systems lifetime contribution work ability tolerate unbounded number faults execution long many processors faulty done allowing processors longer faulty synchronize clocks operational processors protocol withstands arbitrary byzantine faults affected processors may deviate specified algorithm arbitrary manner potentially cooperating maliciously disrupt goal algorithm system obviously critical tolerate faults system secure attackers ie design secure systems indeed many secure systems assume use synchronized clocks usually effect drifts ignored assumption may become weak spot exploited attacker maliciously changes clocks therefore solutions frequently try rely synchronized clocks eg use instead freshness authentication protocols eg kerberos 22 however always achievable often synchronized clocks essential efficiency functionality fact security tasks require securely synchronized clocks definition example timestamping 14 ecommerce applications payments bids expiration dates therefore secure time services integral part secure systems dce 25 ongoing work standardize secure version internets network time protocol ietf 28 note existing secure time protocols simply authenticate clock synchronization messages easy see may withstand malicious attack even authentication secure original motivation work came need implement secure clock synchronization proactive security toolkit 1 proactive security allows arbitrary faults processor long f processors faulty fixed length period namely proactive security makes use processors faulty later recovered important notice settings may possible malicious attacker avoid detection solution needed works even indication processor failed recovered achieve algorithms proactive security periodically perform correctivemaintenance action example may replace secret keys may exposed attacker clearly security reliability periodical protocols depend securely synchronized clocks ensure maintenance protocols indeed performed periodically substantial amount research proactive security including basic services agreement 24 secret sharing 23 17 signatures eg 16 pseudorandomness 4 5 see survey 3 however results far assumed clocks synchronized work therefore provides missing foundation future proactive security works 11 relations prior work large body research clock synchroniza tion much focusing faulttolerance focus relevant works number works focus handling processor faults ignore drifts dolev welch 11 12 analyzed clock synchronization hybrid faults model recovery arbitrary initial state processors self stabilization well napping stop failures number processors 11 byzantine faults third processors 12 works assume synchronous model synchronize logical clocks goal clocks number pulse results directly comparable since clear algorithm self stabilizing analysis assume system initialized correctly hand allow byzantine faults third processors period work asynchronous setting allow drift synchronize real time model timeadaptive self stabilization suggested kutten pattshamir 18 closer goal recover arbitrary faults f processors time function f notice weaker model sense assumes periods faults timeadaptive selfstabilizing clock synchronization protocol asynchronous model presented herman 15 protocol comparable allow drifts synchronize real time among works dealing processor faults drifts assume processor failed never covers bound f number failed processors throughout lifetime system many works based local convergence functions early overview approach found schneiders report 26 partial list results along line includes 13 7 8 9 21 2 20 network time protocol designed mills 21 allows recoveries without analysis proof furthermore authenticated versions 21 pro posed far attempt recovery malicious faults algorithm uses convergence function similar fetzer cristian 9 turn refinement welch lynch 20 however seems one design goals solution 9 incompatible processor recoveries specifically 9 try minimize change made clocks synchronization oper ation using small correction may delay recovery processor clock far correct one 9 recovery may never complete problem accounts difference convergence function one 9 choice small maximum correction value fast recovery time chose latter another aspect 9 optimal maximum logical drift see definition 3 section 23 lution logical drift equals hardware drift whereas solution additive factor o2 gammak k number synchronization operations performed every time period roughly assume less third processors faulty time period require several synchronization operations take place period model approaches 9 ie length time period approaches infinity added factor logical drift approaches zero conjecture optimal logical drift achieved mobile faults model another difference algorithm several traditional convergence function based clock synchronization algorithms many solutions proceed rounds correct processes approximately agree time round starts end round processor reads clocks adjusts clock accordingly contrast protocol also ntp 21 proceed rounds believe implementing round synchronization across large network internet could difficult previous work address faults recoveries clock synchronization due dolev halpern simons strong 10 work assumed faults detected practice faults often undetected especially malicious faults attacker makes every effort avoid detection attack handling undetected faults recoveries critical proactive security trivial recovering processor may clock set value bit outside permitted range solution 10 rely signatures rather authenticated links therefore also limit power attacker assuming cannot collect many bad signatures assumption a4 10 algorithm dolev et al 10 based broadcast require processors sign forward messages processors several practical disadvantages compared local convergence function based algorithms present paper dis advantages mostly result global nature discussed fetzer cristian 13 additional practical disadvantages broadcastbased algorithms include sensitivity transient delays inability take advantage realistic knowledge regarding delays overhead delay resulting depending broadcasts reaching network eg internet hand broadcast based algorithm dolev et al 10 require majority processors correct need two thirds also 10 requires subnet non faulty processors connected rather demanding direct link two processors implementing broadcast used 10 substantial overhead requires twothird processors correct connected 12 informal statement requirements clock synchronization algorithm handles faults recoveries satisfy synchronization guarantee times clock values nonfaulty processors close 1 accuracy guarantee clock rates nonfaulty processors close realtime clock one reason requirement practice set processors island sometimes need communicate coordinate processors outside world recovery guarantee processor longer faulty processor recovers correct clock value rejoins good processors within fixed amount time present formalization model goals simple algorithm satisfies requirements analyze algorithm model attacker temporarily corrupt processors communication links may possible refine analysis show algorithm used even attacker corrupt processors links long many either corrupted time 2 formal model 21 network clocks network model fully connected communication graph n processors processor local clock denote processor names assume 1 note trivial solution setting local clocks constant value achieves synchronization goal accuracy requirement prevents happening processor knows name names neigh bors addition processors network model also contains adversary may occasionally corrupt processors network limited time throughout discussion assume bound ae clock drift good processors bound time takes send message two good processors refer ae drift bound message delivery bound envision network environment real time convenient way thinking real time another clock also ticks less rate processors clocks purpose analysis convenient view local clock processor p consisting two components one unresettable hardware clock hp adjustment variable adj p reset processor clock value p real time denoted cp sum hardware clock adjustment factor time cp notations 26 2 stress hp adj p merely mathematical convenience processors adversary really access values formally operations processor p perform hp adj p reading value hp adding arbitrary factor adj p changes value hp changes continuously value adj p remains fixed clocks hardware clock processor p smooth monotonically increasing function denoted hp adjustment factor p discrete function changes p adds value adjustment variable local clock p defined assume upper bound ae drift rate processors hardware clocks real time namely 1 2 every processor p network holds 2 note practice ae usually fairly small 22 adversary model said network model comes adver sary occasionally break processor resetting local clock arbitrary value adversary may choose leave processor would like processor recover clock value envision adversary see modify communication network also break processors leave wish breaking general adj p discrete variable could also depend dont use generality paper though processor p adversary learns current internal state processor furthermore point leaves p adversary may send messages p may also modify internal state p including adjustment variable adj p adversary leaves processor p access ps internal state say p faulty controlled adversary adversary broke leave yet assume reliable authenticated communication processors p q faulty pre cisely let denote message delivery bound processors p q faulty p sends message q time q receives exactly message p furthermore nonfaulty processor q receives message processor p time either p sent exactly message q else faulty time interval 3 power adversary model measured number processors control within time interval certain length limitation reasonable otherwise even adversary control one processor time corrupt clocks system moving fast enough processor processor limited adversary let 0 ng fixed adversary flimited respect time interval controls f processors refer time period f number faulty processors notice definition 2 implies particular f limited adversary controls f processors wants break another one must leave one current processors least time units break new one rest paper assume n 3f 1 23 clock synchronization protocols intuitively purpose clock synchronization algorithm ensure processors local clocks remain close close real time faulty processors become synchronized quickly adversary leave clear however protocol achieve instantaneous recovery must allow processors time recover typically want recovery time time adversary breaks new processors ones left already recovered definition 3 clock synchronization consider clock synchronization protocol executed network drift rate ae message delivery bound presence flimited adversary respect time period 3 formulation good links completely rule replay old messages pause problem application however say ensures synchronization maximal deviation ffi time two processors faulty gamma holds ii say ensures accuracy maximal drift ae maximal discontinuity whenever p faulty interval holds 3 aclocksynchronizationproto col practical clock synchronization protocols basic operation protocol estimation processor peers clocks therefore begin subsection 31 discussing requirements clock estimation procedure describing simple known procedure subsection 32 describe clock synchronization protocol description abstract clock estimation procedure view black box provides properties discussed finally subsection 33 elaborate aspects protocol compare similar synchronization protocols models 31 clock estimation protocols basic building block subroutine processor p estimates clock value another processor q natural requirements procedures accuracy value returned procedure far actual clock value processor q bounded error along estimated clock value also gets upper bound error estimation technical reasons also convenient procedure return distance local clocks p q rather clock value q hence define clock estimation procedure twoparty protocol processor p invokes protocol trying estimate clock value another processor q protocol returns two values dq aq distance accuracy values interpreted since procedure voked point difference cq gamma cp dq error aq formally definition 4 say clock estimation routine reading error timeout maxwait whenever processor p nonfaulty time interval maxwait calls routine time estimate clock q routine returns time 0 maxwait values moreover q also nonfaulty interval 0 values satisfy following ffl ffl time 00 2 0 cq 00 gammac p 00 describe simple clock estimation algorithm requestor p sends message q returns reply containing time according clock q sending reply p receive reply within message delivery bound aborts estimation sets wise p sends ping message q local time receives answer c local time r sets rgammasintuitively p estimates local time rs qs time c network totally symmetric time message arrive identical way p q way back q p ps clock progressed r constant rate estimation would totally accurate case q returned answer c time p local time p local time r q value c estimation offset cant miss rgammas simple procedure optimized several ways common method used practice decrease error estimating peers clock expense worse timeliness repeatedly ping processor choose estimation given ping least round trip time used example ntp protocol 21 also reduce network load may possible piggyback clock querying messages messages perform different thread spread across time interval course implement latter idea mobile adversary setting clock synchronization protocol periodically check thread exists restart otherwise protect adversary killing thread note implemented way cannot guarantee conditions definition 4 anymore since separate thread may return old cached value measured call clock estimation procedure hence analysis paper cannot applied right box case time estimation done separate thread 32 protocol sync clock synchronization protocol uses clock estimation procedure one described section 31 denote estimateoffset timeout bound denoted maxwait maximal error parameters protocol local time syncint two executions synchronization protocol parameter wayoff used processor gauge distance clock clocks proces sors parameters approximately computed network model parameters ae constraints parameters satisfy syncint 2maxwait 4 maximum deviation want achieve settings discussed analysis sec tion 42 section 33 sync protocol described figure 1 basic idea processor p uses estimateoffset get estimate clocks peers p eliminates f smallest f largest values use remaining values adjust clock roughly p computes low value c f 1st smallest estimate high value c f 1st largest estimate ps clock cp wayoff away interval c knows clock far clocks good processors ignores clock resets c c 2 otherwise ps clock far processors would like limit change case instead completely ignoring old clock value resets clock minc ps clock c c move halfway towards values details sync protocol slightly different though specifically way low value high value chosen processor p first uses error bounds generate overestimates underestimates clock values computes low value c f 1st smallest overestimate high value f largest underestimate analysis also assume clock estimations done parallel time takes make local computations negligible run sync takes maxwait time local clock really crucial saves introduction extra parameter analysis 33 discussion sync protocol follows general framework conver gence function synchronization algorithms see 26 next clock value processor p computed estimates clock values processors using fixed simple convergence function 4 rounds mentioned section 11 one notable differences protocol protocols proposed literature many convergence function protocols example 8 9 proceed rounds processor keeps different logical clock round round time two consecutive synchronization protocols protocols processor asked roundi clock processor already 1st round would return value clock didnt last synchronization protocol contrast sync protocol processor p always responds current clock value makes analysis protocol little complicated greatly simplifies implementation especially mobile adversary setting since variables current round 4 current algorithm analysis processor needs estimate clocks processors expect improved processor need estimate clocks local neighbors parameters syncint time synchronizations wayoff bound clocks far rest 1 every syncint time units call sync 3 function sync f 4 q 2 ng 5 7 8 f 1st smallest dq 9 f 1st largest q 11 adj p adj 12 else adj p adj 13 g last rounds clock time begin next round recovered break known values another practical advantage protocol require know values parameters message delivery bound hardware drift ae maximum deviation ffi may hard measure practice fact may even change course execution use values analysis protocol practice algorithm parameters depend value like maxwait syncint wayoff may overestimate multiplicative factor without much harm ie without introducing factor maximum deviation logical drift recovery time actually achieved perform sync protocol processor executes sync protocol every syncint time units local time make assumptions relative times sync executions different processors common way implement set alarm end execution start new execution alarm goes mobile adversary setting one must make sure alarm recovered breakin note analysis depend processors executing sync exactly every syncint time units rather need time interval 1 aesyncint maxwait real time processor completes least one two syncs 4 analysis let denote value every nonfaulty processor completes least one two full syncs interval length specifically setting appropriate purpose syncint time specified protocol maxwait bound execution time single sync ae drift rate 41 main theorem following main theorem characterizes performance achieved protocol theorem 5 let defined let k assume k 5 sync protocol fulfills synchronization requirement maximum deviation ii sync protocol fulfills accuracy requirement logical drift discontinuity note theorem shows tradeoff rate sync protocol performed function optimal performance choose small compared instance small get almost perfect accuracy ae ae significant term maximum deviation bound 16 42 clock bias purpose analysis convenient consider bias clocks rather clock values bias processor p time difference logical clock real time denoted bp namely realtime implied context often omit notation write bp instead bp analysis view protocol sync affecting biases processors rather clock values particular execution sync processor p view dq estimate bp gamma bq rather estimate view modification adj p last step modification bp therefore rewrite figure 2 algorithm sync processor p bias formulation parameters syncint time sunchronizations wayoff bound clocks far rest 1 every syncint time units call sync 3 function sync f 4 q 2 ng 5 7 8 b 1st smallest b q 9 b 1st largest b q 10 11 bp 12 else bp 13 g protocol terms biases rather clock values figure 2 note referencing bp protocol mean bp real time reference takes place stress protocol cannot implemented described figure 2 since processor p know bias bp rather description alternative view real protocol described figure 1 43 proof overview main theorem provide informal overview proof details including useful piece syntax statements technical lemmas found appendix complete proof included full version paper simplicity overview look case drifts clockreading errors namely note case always steps 67 protocol get analysis looks consecutive time intervals i0 length proceeds induction inter vals interval prove spirit following claims bias values good processors get closer together distance ffi beginning distance 7ffi8 end ii bias values recovering processors gets much closer good processors recovering processor distance range good processors beginning would distance 2 range end therefore follows intervals bias recovering processor ffi away good processors prove claims main technical lemma considers given interval assumes set g least n gamma f processors nonfaulty throughout bias values small range beginning wlog range gammad prove following three properties first show biases processors g remain range gammad throughout interval every execution sync processor gets biases range processors g since g contains 2f processors b range ps bias remains range also completes sync protocol also follows argument always processor p never ignores current bias step 11 protocol next consider processors whose initial bias values low say median g executes two syncs time interval sync takes average current bias another bias bias p remains bounded strictly specifically one show resulting bias values cannot larger z z initial median value similarly processors q 2 g high initial bias values bias values remain bounded strictly gammad specifically least z gamma 3d4 property 3 last use result previous steps show end interval bias every processor g z gamma 7d8 z 7d8 hence case errors drifts size interval includes processors g shrunk 2d 7d4 see recall result previous step whenever processor p 2 g executes sync gets bias values bounded z3d4 processors low initial biases low estimate b must also smaller z similarly gets bias values bounded 3d4 processors high initial biases high estimate b p must larger bias p sync protocol computed minb bp2 since bp range gammad result first step result step follows moreover similar argument applied even processor outside g whose initial bias range gammad specifically show beginning interval nonfaulty processor p high bias say 0 end interval bias p z 7d8 hence distance p good range shrinks 2 formal analysis including effects drifts reading errors included full version paper 5 future directions results require third processors faulty period previous clock synchronization protocols assuming authenticated channels able require majority nonfaulty processors 19 27 interesting close gap 10 another weaker requirement subnetwork containing nonfaulty processors remain connected 10 also assumes signatures may possible prove variant protocol particular would interesting show sufficient nonfaulty processors form sufficiently connected subgraph holds also justify limiting clock synchronization links limited number neighbors processor one practical advantages convergence based clock synchronization noted 3f1connectivity sufficient protocol one construct graph 6f 2 nodes 3f 1connected yet protocol work graph consists two cliques 3f1 nodes addition ith node one clique connected ith node graph clearly 3f connected protocol cannot guarantee clocks one cliques drift apart additional work required explore practical potential protocol particular practical protocols network time protocol 21 involve many mechanisms may provide better results typical cases feedback estimate compensate clock drift improvements may needed protocol making sure retain security well refinements protocol analysis provide better bounds results typical scenarios synchronization accuracy requirements defined talk behavior protocol adversary suitably limited may also interesting ask happens stronger adversaries specifically happens adversary powerful back flimited alternative way asking question happens adversary limited initial clock values processors ar bitrary along lines 11 12 desirable improve protocol andor analysis also guarantee self stabiliza tion means network eventually converges state nonfaulty processors synchronized 6 r implicit rejection average function faulttolerant physical clock synchronization maintaining security presence transient faults proactive pseudorandom generator maintaining authenticated communication presence breakins probabilistic clock synchronization probabilistic internal clock synchronization optimal internal clock synchronization algorithm dynamic faulttolerant clock synchronization lower bounds convergence function based clock synchronization phase clocks transient fault repair proactive public key signature systems sharing cope perpetual leakage synchronizing clocks presence faults new faulttolerant algorithm clock synchronization network time protocol kerberos authentication service computer networks withstand mobile virus attacks new solution byzantine generals problem chapter 7 dce time service synchronizing network time understanding protocols byzantine clock synchronization technical report tr87859 tr synchronizing clocks presence faults new solution byzantine generals problem optimal clock synchronization new faulttolerant algorithm clock synchronization withstand mobile virus attacks extended abstract understanding dce waitfree clock synchronization dynamic faulttolerant clock synchronization lower bounds convergence function based clock synchronization maintaining authenticated communication presence breakins timeadaptive self stabilization proactive public key signature systems proactive security toolkit applications maintaining security presence transient faults proactive secret sharing understanding protocols byzantine clock synchronization ctr michael backes christian cachin reto strobl proactive secure message transmission asynchronous networks proceedings twentysecond annual symposium principles distributed computing p223232 july 1316 2003 boston massachusetts kun sun peng ning cliff wang faulttolerant clusterwise clock synchronization wireless sensor networks ieee transactions dependable secure computing v2 n3 p177189 july 2005 hermann kopetz astrit ademaj alexander hanzlik combination clockstate clockrate correction faulttolerant distributed systems realtime systems v33 n13 p139173 july 2006 kun sun peng ning cliff wang tinysersync secure resilient time synchronization wireless sensor networks proceedings 13th acm conference computer communications security october 30november 03 2006 alexandria virginia usa
optimal duplication elementary recursive 1998 asperti mairson proved cost reducing term using optimal reducer la lvy cannot bound elementary function number sharedbeta steps prove paper analogous result holds lampings abstract algorithm elementary function number shared beta steps bounding number duplication steps optimal reducer theorem vindicates oracle lampings algorithm culprit negative result asperti mairson result obtained using technical tool elementary affine logic b introduction last ten years steady interest optimal reduction terms generally functional programs story started fact twenty years ago jeanjacques levys thesis lev78 problem attacked nd execution strategy terms minimizing number reductions already known strategy exists reduces one redex ie single function call time levys insight discover parallel optimal strategy exists one reducing single step redexes belonging family crucial notion introduced however levy lacked programming technology implement strategy showed eective one knew time kind data structure could used dynamically maintain families way redexes given family could somehow shared fore reduced single step solution came 1989 independently kathail kat90 lamping lam90 gave abstract calculus machines reduced terms prescribed levys optimality theory lampings graph rewriting approach one received interest breakthrough variants optimal reducers proposed especially gonthier abadi levy gnal92a asperti asp95 refer optimal sharing graph approach variants share common core abstract algorithm terminology am98 dier way implement bookkeeping work needed maintain families algorithms described elegant graph rewriting systems rule rewrites pair facing nodes easily implemented constant time operation abstract algorithm responsible performing shared rule incremental duplication subterms job bookkeeping part also called oracle maintain graph enough distributed information make abstract algorithm correct respect standard reduction see section 2 ag98 complete account since reduction rules implemented constant time operations may take number rewriting steps reach normal form term cost reduction algorithm levys theory given term prescribes number shared reductions needed reach normal form optimal sharing graph algorithms perform exactly number rewritings global number reductions greater since algorithms also perform duplication abstract algorithm bookkeeping possible bound total work xed function number shared reductions question behind several contributions asperti lawall mairson asp96 lm96 lm97 culminated am98 dene kalmar elementary functions shows terms normalized n shared reductions total work needed reach normal form algorithm hence optimal sharing graph algorithm exceeds k n xed 0 theorem shows optimal reduction cannot realized unit cost operation however mean optimal reduction whole unfeasible classical theorem statman sta79 calculus machine take non elementary time size term reach normal form case optimal reduction non elementary bound function number shared reductions consequence fact sharing technique number redex families surprisingly low essentially linear size term hence part work done case statmans theorem devolved duplication bookkeeping still case lampings algo rithm remained problem understand cost essentially due duplication pretty com bookkeeping technique paper prove already mere cost duplication elementary words lampings bookkeeping technique unfeasible already plain work duplication particularly interesting since good evidence number duplications performed lampings algorithm lower bound complexity suboptimal 1 reduction technique lm97 al97 working tool use paper elementary ane partially supported ec grant erb 4061 pl 970244 linear murst cofin 1998 1 theoretically could superoptimal implementations one dynamically looks common subexpressions levys theory optimality cover cases neglected l b b b figure 1 lampings abstract algorithm nodes logic asp98 eal variant elementary linear logic introduced gir98 particular show simply typed terms used am98 code certain decision problem given type also eal crucial feature terms typeable eal reduction need bookkeeping part sharing graph algo rithm therefore rene rst corollary main theorem am98 following manner exists set terms en bool normalize n parallel steps number bookkeeping duplication interactions required normalize en using lampings graph reduction algorithm grows xed integer 0 reader may confused outward paradox typing non elementary terms elementary logic paradox indeed since complexity reducing terms inside eal elementary depth term xed case depth involved terms grows polynomially size input paper organized follows section 2 introduce lampings graph reduction technology section 3 presents elementary ane logic analyzing complexity cutelimination discussing problem type ference section 4 recalls asperti mairsons result sketches type terms eal obtaining main result optimal reduction assume reader familiarity simply typed calculus recall set types dened inductively grammar oj xed base type untyped terms generated grammar xjm mjxm assume enumerable set variables ranged x types assigned terms usual way reduction dened rule xm details lampings approach optimal reduction complex technical see book ag98 concepts needed understand result paper easy grasp rst step lampings abstract algorithm represent term labelled graph built nodes given figure 1 arrow exiting node principal port node graph obtained syntax tree term representing variable arc wire ii adding explicit node triangular node called fan sharing variable occurrence iii connecting single wire representing variable form syntactical coincidence ax cut figure 3 intuitionistic linear logic sharing node binds variable reduction term represented graph rewriting typed rules abstract algorithm displayed figure 2 note two nodes rewritten interact principal ports face rst rule shared rule others clear shape perform incremental controlled get opti mality duplication graph duplication rst two fanfan rules annihilate fans intuitively two fans originate node starting graph otherwise last rule one fan duplicates observe however presentation algorithm non deterministic since two fanfan rules lefthand side make algorithm deterministic one may think label fans original graph throughout reduction apply rst fanfan rule two fans label apply otherwise one crucial lampings observations simple technique work simply typed fortiori type free terms much complex bookkeeping oracle machinery adopted adding nodes brackets croissants graphs decorating node index full al gorithm therefore consists abstract algorithm sketched bookkeeping part omit introduce next section formal system type terms simple labelling fans enough get correctness 3 elementary ane logic 31 logical system linear logic gir87 provides logical interpretation lampings algorithm cutelimination process suitable notation proofs proofnets rst hinted gnal92a developed gnal92b give intuitive introduction subject motivate use eal tool towards result see eg chapters 4 8 ag98 full account subject figure 3 presents somewhat non standard way intuitionistic fragment linear logic ill modal system modality used mark formulas contraction weakening may applied standard implicational fragment b b b l l b b b b b b b c b b l figure 2 rules abstract algorithm l l figure 5 n translation figure 4 bracket croissant intuitionist logic may embedded ill via interpretation curryhoward isomorphism typed term may give corresponding ill proof proofs may expressed graphs proofnets essentially corresponding syntax tree terms presence expressed socalled boxes boxes given standard ill proofnets global entities certain subgraphs specied nodes interfaces also described local way introducing new nodes node indexes besides ones corresponding connectives logic new nodes corresponding rules nodes needed oracle lampings algorithmbrackets croissants see figure 4 typed term translated optimal sharing graph according inductive rules figure 5 also corresponding ill derivations given rightmost case corresponds abstraction variable appearing body node called eraser thought fan zero premises observe application case rule translated box level translation increases n n i1 rationale translation following since contraction fan may perfomed formulas translation variable puts variable getting ready possible contraction translation application put box around argument n rule since one type free variables n apply rule bracket nally contracting common variables view technique allows translation typed term also untyped terms provided see type restrict logical system removing rules cannot longer prepare contract variable translation figure 5 contractible variables ones get type means rule cannot longer decrease number type variable since rule longer reward however brackets croissants translation term moved complete lampings algorithm abstract one remains seen application two fan fan rules may discriminated dicult see framework level node never changes reduction therefore may apply rst two fan fan rules annihilate two fans level apply second one otherwise restricted system levels behave like labels labels sucient ensure correctness reduction term typed inside restricted system obtained omitting rules optimal reduction performed without need bookkeeping terms given type restricted system therefore natural choice want bound duplication work called sofar restricted system fragment elementary linear logic ell sketched girard gir98 part work directed logical characterization polynomial elementary functions completely describes elementary functions one side elementary function coded proof ell normalization ell proofs elementary time procedure boxnesting depth proof xed exible syntax also polynomial logic lal introduced one authors asp98 allowing full weakening resulting system elementary ane logic eal presented figure 6 also terms added rules say term type context derivable system figure 6 remark terms intended notation proofs eal terms purpose easily obtained lal asp98 use eal typing system pure terms following subject reduction fact although may non obvious rst simply typed terms eal type derived example given end section 33 like ell also eal characterizes elementary func tions elementary function represented eal normalization procedure elementary time finally crucial issue need fol lowing stress gets eal type reduced abstract algorithm simple labelling fan nodes 32 complexity reducing eal proofs lack space cannot enter details normalization procedure paper let us say using technique rounds introduced girard gir98 rening bit argument obtain complexity reduction bounded following size term n nesting level boxes important fact get tower exponentials whose height depends nesting depth term hence normalization elementary size input depth given 33 decorating terms clear rules eal derivation type eal ealtype term consists skeleton given derivation type simple type discipline together box decoration introducing suitable number rules modalities needed since typed variables contracted observe moreover given simply typed skeleton innite number possible decorations instances single general one cut contr figure elementary ane logic z z x x x z z x x x figure 7 type inference eal z z x x x c z z x x x figure 8 type inference eal ii therefore skeleton trivially obtained nding right decoration hard part since introduction box portion proof forces boxes introduced somewhere else conjecture type inference eal decidable complete proof yet typing relevant terms section 4 therefore obtained using heuristics describe section may single three main steps process type inference looking contractions boxing argu ments opening boxes discuss steps going easy example let simply typed term typed eal start syntax tree term labelled types simple discipline changing figure 7 def look contractions variables occur used linearly done case example since x occurs twice contraction eal admitted formulas type need introduce abstraction x using usual sequent calculus notation simple type derivation figure 7 corresponds following derivation eal contraction rule wrong obtain correct eal derivation add rule contraction corresponding typing represented figure 7 b type x inside box ii outside new type however needs propagated left branch tree full term n otherwise topmost application would wrong type consequence variable n figure 7 b gets type io io observe leftmost innermost application wrong need box argument zz must type io shown figure 8 c finally order apply n zz type type need open box figure 8 mentioned types inside boxes lose one particular allowing us perform application observe single contraction inside term forced us introduce boxes tree nal decoration figure 8 represents following derivation eal io oo l cut e derivation given subterm already mentioned decorations n possi ble first may give n type n adding n rules end derivation general may give n type abstraction derivation possibilities may choose introduce close boxes figure 8 abstraction obtaining n type nm io finally remark type inference eal always possible example simply typed term eal decoration see simple way write term sharing graph reduce abstract algorithm matching fans labels sharing graph normal form cycle sharing graph correspond term least say normal form given term means oracle needed reduction term hence cannot type eal coding type theory eal proofs 41 asperti mairsons result result asperti mairson am98 obtained three building blocks rst novel contribution simply typed term precompiled certain way order drastically limit number shared reductions consider size types structural size size terms counting 1 abstraction application counting size type variable nally consider size sharing graphs number nodes let x variable type expansion x x dened inductively follows given simply typed lambdaterm following procedure am98 construct equivalent variant orm optimal root replacing every subterm process introduce certain number clearly linearly bounded size new preliminary redexes sharing graph obtained orm reducing new preliminary redexes propagating sharing nodes base type theorem 1 simplytyped term total number shared reductions graph normalization limited size second ingredient obtained mairsons proof mai92 theorems statman meyer sta79 mey74 decision problem propositional calculus naturally generalized higherorder types allowing variables quantiers range values dk k 1 let variables ranging dk dene prime formulas true false true finally let formula built prime formulas propositional connectives quantiers 8 9 statman showed reduce truth higherorder formula reduction given normal form suitable typed term mairson mai92 showed simplify proof statman dierent encoding based basic idea quantier elimination procedure much simpler easy understand use list iteration quantier elimination procedure theorem 2 higherorder formula true typed calculus interpretation equivalent true bool moreover quanties universes order k finally last step show elementary timebounded turing machine encoded higherorder logic rening proof mai92 theorem 3 let xed turing machine accepts rejects input x k jxj steps exists formula x higherorder logic accepts x x true moreover x quanties universes 6 length ojxj log jxj theorems 1 2 3 main result am98 obtained easily paper show theorems 1 2 hold ealtyped terms combining results theorem 3 observation made end section 31 derive main result theorem 4 exists set terms normalize n shared reductions number non interactions required normalize en using lampings abstract algorithm grows xed integer 0 42 coding higherorder logic eal show section higherorder logic coded ealtyped terms typefree terms use minor variants am98 2 main technical contribution typeinference inside eal dene type booleans b usual terms true false giving church encoding boolean values given eal types n b 8n 0 usual connectives typed respectively type write l eal type generic lists elements 2 modications encoding following use dierent terms encoding equality ii variable x1 prime formula consequence ii one adopt also slightly dierent encoding turing machine proof theorem 3 particular dene x 1 believe work also mairsons original encoding turing machine would get type eal following am98 k domain dk encoded term dk representing dk list values dene powerset double lemma 1 ealtype 0 double type 3i l powerset type l proof see figures 9 10 bold dashed lines stand boxes observe piling already present stage encoding type powerset two consecutive since eal possible derive number consecutive keep creasing intuitively n applications powerset produce 2n consecutive nal type given type schema prove following 8nk 2k 1 dk type k following mai92 quantiers encoded using iteration lists given n 0 eal type suppose coded terms set elements type suppose moreover term encoding generic formula z true term encoding prime formulas encoded following terms observe memberk dened k 2 encoding understood calculus translation following inductive denitions quantied formulas 9z k 1 2 k denition 2k 8z k 1 2 dk 1 denition k encoded list iteration described memberk ealtype maxf4k 9 2k 1g putting together ingredients encoding obtain main technical result establishes theorem 2 ealtyped terms theorem 5 dene term encoding arbitrary formula quantiers eal moreover size x k 1 ojj2kmax kmax greatest k memberk appears proof main case universally quantied formula described figure 11 1 outer bold box stands 2k 1 boxes 3 inner bold box stands p 1 boxes figure 12 complete coding example following bound number type lambda term encoding arbitrary formula provides limitation also boxnesting depth 3 notice dk remember need open boxes apply l l l l l l x l c c x e c c le l l c c figure 9 eal type double double la l l l l c c c figure 10 eal type powerset c lc c x c e l l c n le c l l c l l l l la c lc c x c e l l c n le c l l c l l l l la lc true c false c lx3 true c lc c x c e l l c n le c l l c l l l l la lc true c false c ly3 c lc c x c e l l c n le c l l c l l l l la lc true c false c true member3 x3 false true member2 figure true figure type arbitrary formula corollary 1 let term encoding arbitrary mula type eal kmax greatest k memberk appears n number quantiers proof previous theorem type theorem 6 let term encoding arbitrary mula depth greatest k memberk appears n number quantiers moreover also order obtain desired result complexity du plication remains shown precompilation terms given etaexpansion performed inside eal theorem 7 eal type orm proof sucient prove expansions always typeable eal described figure 13 needed obtain theorem 1 eal typed terms hence theorem 4 conclusions paper shown complexity result parallel betareduction obtained am98 obtained respect optimal duplication one could expected complex machinery required management redexfamilies casts new dierent light asperti mairsons work particular helps understand convey negative result optimal reduction technique normalization lambdaterms reduction lambda term x figure potentially non elementary work duplication done even optimal reduction tech nique parsimonious could cannot magic lot interesting issues still investigated starting theoretical comparison performance lampings technique versus traditional implemen tations comparison hindered far bookkeeping work whose formal investigation complex current state art huge set lambda terms ie terms eal reduced without need bookkeeping providing main promising arena theoretical investigation performance issues r optimal implementation functional programming languages dynamics sharing graphs parallel beta reduction elementary recursive linear logic complexity beta reduction light ane logic linear logic light linear logic optimal interpreters lambdacalculus based functional programming languages algorithm optimal lambda calculus reduction optimality ineciency isnt cost model lambda calculus acm sigplan notices global dynamics optimal graph reduction simple proof theorem statman inherent computational complexity theories ordered sets typed tr linear logic algorithm optimal lambda calculus reduction simple proof theorem statman geometry optimal lambda reduction optimality inefficiency complexity betareduction global dynamics optimal graph reduction parallel beta reduction elementary recursive light linear logic optimal implementation functional programming languages intuitionistic light affine logic dynamics sharing graphs light affine logic
concurrent threads optimal parallel minimum spanning trees algorithm paper resolves longstanding open problem whether concurrent write capability parallel random access machine pram essential solving fundamental graph problems like connected components minimum spanning trees ologn time specifically present new algorithm solve problems ologn time using linear number processors exclusiveread exclusivewrite pram logarithmic time bound actually optimal since well known even computing nbit requires ohgrlog n time exclusivewrite pram efficiency achieved new algorithm based new schedule exploit high degree parallelism b introduction given weighted undirected graph g n vertices edges minimum spanning tree mst problem nd spanning tree spanning forest g smallest possible sum edge weights problem rich history preliminary version paper appeared proceedings tenth annual acmsiam symposium discrete algorithms baltimore maryland acm new york siam philadel phia pp 225234 work supported part hong kong rgc grant hku28995e address ka wong chong takwah lam department computer science information systems university hong kong hong kong email fkwchongtwlamgcsishkuhk yijie han computer science telecommunications program university missouri kansas city 5100 rockhill road kansas mo 64110 usa email hancstpumkcedu permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed prot direct commercial advantage copies show notice rst page initial screen display along full citation copyrights components work owned others acm must honored abstracting credit permitted copy otherwise republish post servers redistribute lists use component work works requires prior specic permission andor fee permissions may requested publications dept acm inc 1515 broadway new york ny 10036 usa fax 1 212 8690481 permissionsacmorg han tw lam sequential mst algorithms running om log n time known decades ago see tarjan 1983 survey subsequently number ecient mst algorithms published particular fredman tarjan 1987 gave algorithm running ommn time n minfi j log n mng time complexity improved om log n gabow galil spencer tarjan 1986 chazelle 1997 presented even faster mst algorithm time complexity ommn log n n inverse ackerman function recently chazelle 1999 improved algorithm run ommn time later pettie 1999 independently devised similar algorithm time complexity recently pettie ramachandran 2000 obtained algorithm running optimal time simple randomized algorithm running linear expected time also found karger et al 1995 parallel context mst problem closely related connected component cc problem nd connected components undirected graph cc problem actually admits faster algorithm sequential con text yet two problems solved similar techniques various models parallel random access machines see surveys jaja 1992 karp ramachandran 1990 respect model concurrent write capability ie processors write shared memory location simultaneously problems solved olog n time using nm processors awerbuch shiloach 1987 cole vishkin 1986 using randomization gazits algorithm 1986 solve cc problem olog n expected time using n processors work algorithm dened timeprocessor product thus optimal later cole et al 1996 obtained result mst problem exclusive write models including concurrentread exclusivewrite exclusiveread exclusivewrite prams olog 2 n time algorithms cc mst problems developed two decades ago chin et al 1982 hirschberg et al 1979 believed exclusive write models could overcome olog 2 n time bound rst breakthrough due johnson metaxas 1991 1992 devised olog 15 n time algorithms cc problem mst problem results improved chong lam 1993 chong 1996 olog n loglog n time randomization allowed time work improved particular karger et al 1995 showed cc problem solved olog n expected time later halperin zwick 1996 improved work linear mst problem karger 1995 obtained randomized algorithm using olog n expected time superlinear work poon ramachandran 1997 gave randomized algorithm using linear expected work olog n log log n 2 log n expected time another approach stems fact deterministic space bounds stconnectivity problem immediately imply identical time bounds erew algorithms cc problem nisan et al 1992 shown stconnectivity problem solved deterministically using olog 15 n space armoni et al 1997 improved bound olog 43 n results imply erew algorithm solving cc problem olog 15 n time olog 43 n time respectively optimal parallel mst algorithm 3 prior work open whether cc mst problems could solved deterministically olog n time exclusive write models notice log n optimal since graphs problems least hard computing n bits cook et al 1986 proven latter requires qui n time crew erew pram matter many processors used existing mst algorithms cc algorithms dicult improve locking among processors processors work dierent parts graph dierent densities progress processors uniform yet processors coordinate closely order take advantage results computed result many processors often wait rather useful computation paper presents new parallel paradigm solving mst problem requires minimal coordination among processors fully utilize parallelism based new insight structure minimum spanning trees show paradigm implemented erew solving mst problem olog n time using n processors algorithm deterministic nature require special operations edge weights comparison finding connected components minimum spanning trees often key step parallel algorithms graph problems see eg miller ramachandran 1986 maon et al 1986 tarjan vishkin 1985 vishkin 1985 new mst algorithm parallel algorithms immediately improved run optimal ie olog n time without using concurrent write eg biconnectivity tarjan vishkin 1985 ear decomposition miller ramachandran 1986 theoretical point view result illustrates concurrent write capability essential solving number fundamental graph problems ef ciently notice erew algorithms actually practical sense adapted realistic parallel models like queuing shared memory qsm gibbons et al 1997 bulk synchronous parallel bsp model valaint 1990 latter distributed memory model parallel computation gibbon et al 1997 showed erew pram algorithm simulated qsm model slow factor g g bandwidth parameter qsm model simulation however known crcw pram thus result implies mst problem solved eciently qsm model og log n time using linear number processors furthermore gibbon et al 1997 derived randomized workpreserving simulation qsm algorithm logarithmic slow bsp model rest paper organized follows section 2 reviews several basic concepts introduces notion called concurrent threads nding minimum spanning trees parallel section 3 describes schedule used threads illustrating limited form pipelining avor similar pipelined mergesort algorithm cole 1988 section 4 lays detailed requirement thread section 5 shows details algorithm simplify discussion rst focus crew pram showing solve mst problem olog n time using n log n processors section 6 adapt algorithm run erew pram reduce processor bound linear 4 kw chong han tw lam remark recently pettie ramachandran 1999 made use result paper improve existing randomized mst algorithms precisely algorithm rst one run high probability olog n time linear work erew pram 2 basics parallel mst algorithms past present section review classical approach nding mst based approach easily contrast new mst algorithm existing ones assume input graph g given form adjacency lists consider edge g note e appears adjacency lists u v call copy e mate need distinguish use notations hu vi hv ui signify edge originates respectively weight e real number denoted wu v without loss generality assume edge weights distinct thus g unique minimum spanning tree denoted g throughout paper also assume g connected otherwise algorithm nds minimum spanning forest g let b subset edges g contains cycle b induces set trees natural sensetwo vertices g tree connected edges b b contains edge incident vertex v v forms tree denition consider edge g tree 2 f u v belong e called internal edge one u v belongs e called external edge note edge also internal edge converse may true denition b said forest tree 2 f least vertices example b empty set b 1forest g spanning tree g nforest consider set b edges chosen g assume b forest augment b give 2forest using greedy arbitrary subset f f 0 includes trees 2 f fewer vertices may contain trees 2 vertices every tree f 0 pick minimum external edge denote b 0 set edges lemma 1 jaja 1992 lemma 54 b 0 consists edges g lemma 2 2forest proof every tree f f 0 already contains least 2 vertices consider tree f 0 let hu vi minimum external edge v belongs another tree 0 2 f respect vertices 0 connected together among trees induced one including 0 contains least 2 vertices therefore 2forest g based lemmas 1 2 nd g blog nc stages follows notation let bp q denote q empty set otherwise optimal parallel mst algorithm 5 procedure 1 blog nc stage let f set trees induced b1 1 g let f 0 arbitrary subset f f 0 includes trees 2 f fewer 2 vertices e minimum external edge 2 f 0 g 2 return b1 blog nc stage dierent strategies choosing set f 0 step 1a may lead dierent b nevertheless b1 always subset g induces 2 forest particular b1 blog nc induces 2 blog nc forest tree denition contains least 2 blog nc n2 vertices words b1 blog nc induces exactly one tree equal g using standard parallel algorithmic techniques stage implemented olog n time erew pram using linear number processors see eg jaja 1992 therefore g found olog 2 n time fact parallel algorithms nding mst including crcw pram algorithms based similar approach see eg awerbuch shiloach 1987 chin et al 1982 citencv86 johnson metaxas 1991 1992 chong lam 1993 chong 1996 karger et al 1995 parallel algorithms sequential sense computation b starts b 1 available see figure 1a innovative idea exploited mst algorithm use concurrent threads compute b threads groups processors working dierent tasks computation threads independent algorithm blog nc concurrent threads nding particular b threads characterized fact thread computing b starts long thread computing b 1 completed actually outputs b o1 time figure 1b result g found olog n time algorithm takes advantage interesting property sets property actually holds respect deterministic algorithms nding mst though mentioned explicitly literature lemma 3 let one trees induced b1 k 0 k blog nc e minimum external edge subtree ie connected sub minimum external edge either e edge proof see appendix 3 overview schedule algorithm consists blog nc threads running concurrently 1 blog nc thread aims nd set b one possible sets computed stage procedure iterativemst precise let f set trees induced arbitrary subset f including trees fewer contains minimum external edges trees f 0 thread 6 kw chong han tw lam phase 2 phase 1 phase 1 phase 1 phase 2 phase 1 phase 2 phase 1 b thread phase blog ic phase blogi 1c fig 1 iterative approach b concurrentthread approach receives output threads 1 1 ie incrementally never looks computation o1 time 31 examples showing detailed schedule thread give two examples illustrating thread speed computation b examples 1 2 thread computes b time ci 1 respectively thread c xed constant simplify discussion examples assume adjacency lists set vertices merged single list time end section explain infeasible implementation highlight novel observations techniques evade problem thread starts set q 0 adjacency lists list contains smallest edges incident vertex g edges kept q 0 already sucient computing b reason follows consider tree induced assume minimum external edge e incident vertex v contains fewer 2 vertices 2 2 edges incident v internal edges thus 2 1 smallest edges incident v must include e example 1 straightforward implementation lemma 2 thread starts available let f set trees induced b1 1 suppose merge adjacency lists vertices tree forming single combined adjacency list notice hat tree f fewer vertices combined adjacency list contain 2 edges optimal parallel mst algorithm 7 combined list 2 edges determine minimum external edge time ci c suitable constant collection minimum external edges reported b observe combined adjacency list edges represents tree containing least 2 vertices denition b necessary report minimum external edge tree example 2 example slightly complex illustrating thread works incremental manner thread starts soon b i2 computed point available thread ready compute b nevertheless performs preprocessing called phase b become available computation b speeded run time 1 2 ci phase ii phase let f 0 set trees induced b1 i2 suppose merge adjacency lists q 0 every tree f 0 forming another set q 0 adjacency lists denition b1 i2 tree f 0 contains least 2 i2 vertices tree f 0 fewer 2 vertices combined adjacency list contains 2 1 2 edges extract list 2 i2 1 smallest edges connects distinct tree f 0 edges sucient nding b argument extension argument example 1 computation takes time ci phase ii b available compute b based q 0 follows edges bi2 connect trees f 0 forming set f bigger trees suppose merge lists q 0 every tree f notice tree f contains fewer 2 vertices composed 2 i2 1 trees f 0 combined adjacency list contains 2 i2 1 2 edges case nd minimum external edge 1 time b set minimum external edges found conclusion computed b found time 1 remark set b found examples 1 2 may dierent yet either case subset g 2 forest 32 schedule mst algorithm based generalization ideas computation thread divided blog ic phases thread 1 computed enter last phase takes o1 report b see figure 1b globally speaking mst algorithm runs blog nc supersteps lasts o1 time particular thread delivers b end ith superstep let us rst consider power two phase 1 thread starts available computation takes i4 supersteps ending i2 starts i2 available uses i8 supersteps subsequent phase uses half many supersteps preceding phase last phase phase log starts ends within ith superstep see figure 2 general thread runs blog ic phases mark starting time 8 kw chong han tw lam1 2 1 ii iphase log phase 1 phase 2 thread fig 2 schedule thread power 2 phase dene sequence phase j thread 1 j blog ic starts 1th superstep uses j1 supersteps phase j handle edge sets b j 1 made available threads execution phase j 1 33 merging examples assume every tree f merge adjacency lists vertices subtrees phase ii example 2 single list eciently time depend total length done via technique introduced tarjan vishkin 1985 let us look example suppose tree contains edge e two vertices u v assume adjacency lists u v contain e mate respectively two lists combined e mate exchange successors see figure 3 every edge mate exchange successors adjacency lists get combined adjacency list o1 time however merging fails edge mate included corresponding adjacency lists algorithm keep track edges vertex subtree eciency example adjacency list q 0 involves edges incident vertex respect tree edges mates may present corresponding adjacency lists therefore applying o1time merging technique may able megre adjacency lists one single list representing failing form single combined adjacency list also complicates extraction essential edges particular minimum external edges computing set b particular cannot easily determine vertices belonging identify redundant edges ie internal extra multiple external edges adjacency list e e e e fig 3 merging pair adjacency lists lu lv respect common edge e optimal parallel mst algorithm 9 actually mst algorithm insist merging adjacency lists single list key idea algorithm maintain essential edges included one particular combined adjacency list based structural properties minimum spanning trees lter redundant adjacency lists obtain unique adjacency list see lemmas 5 9 section 5 adjacency list representing internal edges removed using technique based threshold chong 1996 intriguing part concerns extra multiple external edges nd necessary remove specically show extra multiple external edges cannot removed easily must bigger weight presence aect correctness computation next section elaborate ideas formulate requirements phase achieve schedule 4 requirements phase section specify formally thread expected achieve phase initially phase 0 thread constructs set q 0 adjacency lists vertex v g q 0 contains circular linked list l including 2 1 smallest edges incident v addition l assigned threshold denoted hl l contains edges v smallest edge truncated l blog ic phases adjacency lists merged based newly arrived edge sets truncated according length requirement combined adjacency list new threshold computed intuitively threshold records smallest edge truncated far consider phase j 1 j blog ic inherits set q j 1 adjacency lists phase j 1 receives edge sets ba recall denote set trees induced b1 j phase j aims producing set q j adjacency lists capturing external edges trees f j essential computation b basically try merge adjacency lists q j 1 respect ba mentioned merging process may produce one combined adjacency list tree nevertheless strive ensure one combined list retained rest ltered view time constraint imposed schedule thread also need tight bound length remaining adjacency list let l list q j r1 uniquely corresponds tree 2 f j storing external edges case said represented l q j trees f j may represented lists q fewer 2 vertices represented r2 length l contains 2 bi2 j c 1 edges dene edges tree 2 f j essential must included l consider external edge e connects another tree 0 2 f j han tw lam say e primary among edges connecting 0 e smallest weight otherwise e said secondary note minimum spanning tree g contains edge external edge 0 must primary one ideally primary external edges retained list yet infeasible since thread starts truncated adjacency lists cannot identify remove secondary external edges phase removing internal edges though nontrivial feasible important observation necessary remove secondary external edges based structural classication light heavy edges dened nd light secondary external edges removed easily af terwards list contains light primary external edges possibly heavy secondary external edges set light primary external edges may cover primary external edges size much smaller 2 bi2 j c 1 yet show set light primary external edges suces computing presence heavy secondary external edges aect correctness give denition light heavy edges based notion base denition let tree f j let real number tree 0 2 f j said accessible another tree 00 2 f j 00 accessible connected 0 edge weight smaller let e external internal edge dene set weaccessible tg size basef total number vertices trees involved let e external internal edge say e light kbasef follows denition light edge tree smaller weight heavy edge also heavy edge remain heavy edge subsequent phases specically phase k k j subtree tree x 2 f k external internal edge e therefore e heavy respect also heavy respect x following lemma gives upper bound number light primary external edges tree f j complies length requirement lists q j lemma 4 tree 2 f j 2 bi2 j c 1 light primary external edges proof let x number light primary external edges among light primary external edges let e one biggest weight set includes least x 1 trees adjacent b1 j 2 j forest every tree f j contains least 2 j vertices denition light edge thus x 2 j 2 x 2 optimal parallel mst algorithm 11 following requirement species essential edges kept list characterizes secondary external edges list r3 base let tree f j represented list l 2 q j light primary external edges included l secondary external edges included l must heavy retaining light primary external edges list q j already sufcient computation b particular let us consider scenario end phase blog ic tree 2 f blog ic fewer 2 vertices minimum external edge e ts must reported b note basef blog ic contains ts light primary external edge previous phases k f k contains subtree denoted w e ts external edge note e ts also light primary external edge w heavy edge remains heavy edge subsequently hand end phase blog ic tree x 2 f blog ic contains 2 vertices external edges heavy r3 cannot enforce minimum external edge e tx x kept list x fortunately necessary thread report minimum external edge tree following requirements threshold help us detect whether minimum external edge x removed report anything x essentially require e tx primary external edge e x removed list l x represents x threshold kept l x bigger respectively smallest edge l x e tx weight fewer threshold let tree f j represented list l 2 q j threshold l satises following properties r4 lower bound threshold hl 6 1 hl equal weight heavy internal external edge r5 upper bound threshold let e external edge included l e primary hl algorithm actually satises stronger requirement hl e primary e secondary mate e still included another list l 0 q j summary r1 r5 guarantee end phase blog ic tree fewer 2 vertices minimum external edge e edge kept unique adjacency list representing otherwise may may represented list represented list e already removed threshold kept every external edge currently kept list must weight greater equal threshold thus simply ignore list easy check q 0 satises requirements phase 0 next section give algorithm satisfy requirements every phase consequently thread report b based edges lists 12 kw chong han tw lam 5 algorithm section present algorithmic details thread showing merge extract adjacency lists phase discussion inductive naturefor j 1 assume phase j 1 produced set adjacency lists satisfying requirements r1r5 show phase j computes new set adjacency lists satisfying requirements oi2 j using linear number processors phase j inherits set adjacency lists q j 1 phase j 1 receives edges ba ease discussion refer ba input notice list q represents one trees f j 1 recall denote set trees induced b1 phase j merges adjacency lists q according trees f j 1 connected edges input consider edge input denote w 1 w 2 trees f j 1 containing u v respectively ideally e mate appear adjacency lists w 1 w 2 respectively adjacency lists w 1 w 2 merged easily o1 time however w 1 w 2 might already large representation q j 1 even represented length requirement adjacency lists may allow e included result e may appear two separate lists q one even none call e full half lost edge respectively accordingly partition input three sets namely fullinput halfinput lostinput phase j starts merging lists q respect edges fullinput let tree f j let w 1 trees f j 1 together edges input constitute note w may represented list q j 1 since merging done respect fullinput adjacency lists w 1 present may merged several lists instead single one let merged lists l represents bigger subtree z called cluster see figure 4 cluster may contain one w distinguish one cluster called core cluster minimum external edge e external edge cluster note minimum external edge core cluster may may e noncore cluster z minimum external edge e z z must tree edge lemma 3 thus e z input moreover e z full edge otherwise merging operated e z becomes internal edge bigger cluster merged lists obviously need satisfy requirements q j following sections present additional processing used fulll require ments summary processing given section 54 discussion processing merged lists divided according sizes trees sketched follows tree 2 f j contains fewer 2 vertices simple way ensure exactly one merged list retained q j edges list optimal parallel mst algorithm 13 fig 4 wx represents tree f j 1 dotted solid lines represent half full edges input respectively tree formed connecting trees f j 1 edges input zy called cluster subtree formed connecting wx full edges adjacency lists wx within zy merged single list easily ltered contain light primary external edges secondary external edges included must heavy tree 0 2 f j contains least 2 vertices processing may retain one merged lists put extra step ensure except possibly one merged lists 0 removed threshold remaining list updated retaining 2 bi2 j c 1 smallest edges show requirements threshold satised matter whether tree concern contains fewer 2 vertices 51 trees f j fewer 2 vertices section focus tree 2 f j contains fewer 2 vertices denote merged lists representing clusters observe lists contains 2 bi2 edges derive ecient way nd unique adjacency list representing contains light primary external edges first realize every light primary external edge also light primary external edge tree w f j 1 must present adjacency list represents w q j 1 r3 thus light primary external edges including minimum external edge present merged lists unique representation let l cc list fl l cc contains minimum external edge e l cc represents core cluster z 0 concern remove lists fl represented uniquely l cc eciently distinguish l cc lists make use properties 14 kw chong han tw lam stated following lemma let l nc list fl g let z denote cluster represented l nc lemma 5 l cc contain edge halfinput ii l nc contains least one edge halfinput particular minimum external edge z halfinput proof lemma 5i assume contrary l cc includes edge halfinput precisely ha bi l cc hb ai included list trees f j 1 connected e 2 w edge e primary external edge w well w 0 w w 0 subtrees w also subtree z 0 show contains least 2 vertices latter contradicts assumption thus lemma 5i follows w 0 subtree contains less 2 vertices r1 q contains list lw 0 representing w 0 r3 lw 0 contains light primary external edges w 0 edge hb ai included lw 0 must heavy therefore next want show trees basef subtrees dene b subtrees constructed removing e see figure 5 assume contains vertex b vertex b w well z 0 fig 5 partitioned two subtrees ta b connected e subtree w 0 subtree b lemma 3 minimum external edge b either e e former case impossible e included l cc must external edge z 0 thus e minimum external edge b denition base basef cannot include trees f j 1 outside b words b includes subtrees basef must least 2 vertices must contradiction occurs proof lemma 5ii let e z minimum external edge z e z tree edge input full edge case show e z actually half edge included l nc thus completing proof let w tree f j 1 w component z e z external edge w note e z primary external edge w let lw denote adjacency list q representing w since e z minimum external edge optimal parallel mst algorithm 15 include trees f j 1 outside z thus size less 2 r3 light primary external edges w including e z present lw therefore e z halfinput l nc must inherited e z lw using lemma 5 easily retain l cc remove merged lists l nc one might worry l nc might indeed contain light primary external edge removing l nc incorrect actually impossible view following fact lemma 6 external edge e included l nc proof let e z minimum external edge z external edge e included l nc e also external edge z z let w w 0 trees f j 1 connected e z w 0 component z shown previous lemma e z halfinput moreover e z tree edge present adjacency list w w 0 component adjacency list w 0 q contain e z note e z primary external edge w 0 r1 r3 conclude e z heavy external edge w 0 hence kbasef therefore lemma 6 l nc contain light primary external edge words light primary external edges must l cc list retained excluding light internal secondary external edges l cc contains light primary external edges also edges length requirement ie r2 retain 2 bi2 j c 1 edges l cc note light primary external edges may smallest edges l cc based following two lemmas remove light edges l cc include light internal secondary external edges light primary external edges smallest edges left list retaining 2 bi2 j c 1 smallest edges always include light primary external edges lemma 7 suppose l cc contains light internal edge hu vi mate hv ui also appears l cc proof recall l cc formed merging adjacency lists trees f j 1 r1 lists contain internal edge tree represents l cc contains light internal edge hu vi edge u v must two trees w w 0 f j 1 components z 0 assume light external edges w w 0 respectively let lw lw 0 adjacency lists q j 1 hu vi appears appears lw r3 light edges found lw including hu vi must primary external edges w symmetry hv ui primary external edge w 0 r3 hv ui appears lw 0 since l cc inherits edges lw lw 0 conclude hu vi hv ui appear l cc han tw lam lemma 8 suppose l cc contains light secondary external edge e let e 0 corresponding primary external edge e e 0 appear l cc mates also appear another merged list l 0 cc l 0 cc represents core cluster another tree 0 2 f j proof suppose l cc contains light secondary external edge e assume e connects another tree 0 2 f j e 0 primary external edge 0 0 e fig 6 e light secondary external edge e 0 corresponding primary external edge thus e also light primary external edge must included l cc hand since e secondary equal basef thus contains less 2 vertices merging lists q obtain merged list l 0 cc includes light primary external edges 0 show l 0 cc contains mates e 0 e observe kbasef e 0 e light external edges 0 e 0 also primary external edge 0 e 0 precisely mate must included l 0 cc let w w 0 two trees f j 1 connected e w subtree w 0 0 e light external edge 0 also light external edge w w 0 note l cc inherits e adjacency list represents w r3 lw include light secondary external edge w e primary external edge w symmetry e also primary external edge w 0 thus r3 e adjacency list lw represents w 0 note l 0 cc must include edges lw 0 well lists q j 1 contain light external edges see lemma 6 l 0 cc contains e lemma 7 remove light internal edges simply removing edges whose mates list lemma 8 implies l cc contains light secondary external edge corresponding primary external edge also appears optimal parallel mst algorithm 17 l cc mates exist another list l 0 cc suggests simple way identify remove light secondary external edges follows without loss generality assume every edge l cc determine identity l cc distinct label given l cc edge e 2 l cc mate another list say cc e announce identity l cc mate vice versa sorting edges l cc respect identities received mates multiple light external edges connected tree come together easily remove light secondary external edges know l cc contains light primary external edges edges contains must heavy let us summarize steps required build unique adjacency list representing procedure mc mc means merge clean 1 edges input full respect q j 1 activated merge lists q j 1 let q set merged adjacency lists 2 merged adjacency list l 2 q l contains edge halfinput remove l q b detect remove internal secondary external edges l according lemmas 7 8 52 trees least 2 vertices consider tree 0 2 f j containing 2 vertices let l 1 l merged lists representing cluster 0 lists may contain 2 edges unlike case section 51 minimum external edge e 0 0 heavy cannot guarantee merged list containing e 0 representing core clusters 0 nevertheless thread ignore tree 0 may remove merged lists lemma 9 show lists fl 1 l g represent noncore clusters 0 removed easily indeed merged list l cc representing core cluster thread may remove l cc since 0 contains least 2 vertices light primary external edge nothing enforce l cc regarding light primary external edges concern l cc requirements threshold handled section 53 0 contains least 2 vertices merged list l nc represents noncore cluster 0 may satisfy properties stated lemma 5ii need ways detect l nc first detect length l nc l nc contains 2 edges remove l nc immediately next l nc contains less 2 edges make use following lemma identify denote hl threshold associated list l 2 merged l nc g lemma 9 list l represents noncore cluster 0 satises least one following conditions 1 l nc contains edge halfinput 2 every edge hu vi l nc either hv ui also l nc wu v han tw lam proof assume l nc contain edge halfinput l nc contains edge hu vi contain hv ui show wu v tmphl nc edge u v internal external edge z case 1 u v internal edge z l nc inherits hu vi list l 2 tree represented l r1 hu vi external edge w thus z includes another tree w 0 2 f j 1 hv ui external edge l nc also inherits edges list lw represents w 0 note hv ui appear lw 0 r5 hlw 0 case 2 u v external edge z obvious wu v z e z minimum external edge z show z tmphl tree z e z external edge let lw 2 adjacency list representing w mentioned e z input full edge e z lost edge l nc contain e z e z half edge l nc contain e z l nc contain edge halfinput conclusion e z appear l nc hence cannot appear lw since e z primary external edge w know r5 hlw z denition using lemma 9 extend procedure mc remove every merged list l nc represents noncore cluster tree f j see procedure ext mc precisely fewer 2 vertices l nc removed step 2a otherwise l nc removed step 1b steps 2ac procedure ext mc 1 edges input full respect q j 1 activated merge lists q j 1 let q set merged adjacency lists b list l 2 q l contains 2 remove l q 2 merged adjacency list l 2 q l contains edge halfinput remove l q b detect remove internal secondary external edges l c edges hu vi l wu v tmphl remove l q procedure ext mc executed remaining merged lists representing core clusters trees f j moreover tree 2 f j fewer 2 vertices procedure ext mc like procedure mc always retains merged list l cc represents core cluster l cc removed step 1b l cc cannot contain 2 edges addition l cc contains light primary external edges lemma 10 show tmphl cc weight heavy internal external edge thus l cc contains edges weight less tmphl cc cannot removed step 2c lemma 10 tmphl cc equal weight heavy internal external edge proof among lists q j 1 merged l cc let l one optimal parallel mst algorithm 19 smallest threshold tmphl cc denote tree f j 1 represented l r4 hl equal weight heavy internal external edge e w thus e also heavy internal external edge 53 updating threshold retaining external edges procedure ext mc executed every remaining merged list representing corecluster tree f j let l cc list representing tree 2 f j contains less 2 vertices light primary external edges appear among smallest edges l cc edges l cc heavy edges least 2 vertices external internal edges light edges l cc must heavy denition ext mc number edges l cc 2 bi2 may exceed length requirement phase j ie 1 ensure l cc satises r3 retain 2 bi2 j c 1 smallest edges l cc threshold l cc denoted hl cc updated minimum tmphl cc weight smallest edge truncated contains fewer 2 vertices every edge truncated l cc heavy together lemma 10 conclude hl cc equal weight heavy internal external edge satisfying r4 next give observation l cc lemma 12 show r5 satised denote z 0 corecluster represented l cc lemma 11 let e external edge z 0 e tree edge e included l cc hl cc proof suppose e included l cc note e cannot full edge respect q full edge mate removed step 2b procedure ext mc e halfinput procedure ext mc removed l cc step 2a contradicts l cc one remaining lists procedure ext mc executed therefore e included l cc next show hl cc let w subtree z 0 e external edge w since e tree edge e primary external edge w e included l cc l cc inherits adjacency list lw 2 representing w e also included lw r5 hlw recall lemma 12 let e external edge currently found l cc e primary ii e secondary mate e still included list l 0 q j hl cc proof let vi external edge currently found l cc satisfying conditions stated lemma 12 let w tree f j 1 w subtree e external edge w respect w either e primary e secondary mate e included another list q consider whether w included core cluster z 0 case 1 w subtree z 0 denition z 0 w must represented list end phase j 1 e may may appear lw e 20 kw chong han tw lam z fig 7 z 0 z connected path p p contains edge b external edge z 0 w 0 appear lw r5 hlw hl cc suppose e lw e passed l cc procedure ext mc starts yet e currently l cc e removed l cc within procedure ext mc take place step 2b e either internal edge secondary external edge removed together mate contradicts assumption e thus e removed procedure ext mc ie due truncation case way hl cc updated guarantees case 2 w subtree noncore cluster z show z 0 external observe contains path connecting z 0 z path must involve external edge ha bi z 0 lemma 11 hl cc wa b next show wa b let w 0 tree f j 1 w 0 subtree z 0 ha bi external edge w 0 see figure 7 suppose remove edge b partitioned two subtrees b containing vertices b respectively note b contains w e external edge b hand z 0 included e external edge b lemma 3 minimum external edge b hb ai therefore wa b result hl cc wa b lemma follows removing remaining internal edges note l cc may still contain internal edges procedure ext mc remove internal edges whose mates also appear l cc following lemma shows every remaining internal edges l cc weight greater hl cc thus discarding edges l cc weight greater hl cc ensure external edges retained course light primary external edge removed step lemma 13 internal edge e currently included l cc proof consider whether internal external edge z 0 optimal parallel mst algorithm 21 fig 8 pair vertices u v e connected path p every edge p weight smaller case 1 e internal edge z 0 suppose l cc inherits e list represents tree w 2 f j 1 w subtree z 0 r1 hu vi external edge w z 0 includes another tree w 0 2 f j 1 contains vertex v denote lw 0 list q j 1 represents w 0 edge hv ui external edge w 0 hv ui appear lw 0 otherwise would also inherited hv ui lw 0 procedure ext mc removed hu vi hv ui l cc step 2b r5 hlw 0 wu v case 2 e external edge z 0 lemma 11 e tree edge let p path connecting u v see figure 8 since subtree g every edge p weight smaller wu v p nd external edge ha bi z 0 lemma 11 hl cc wa b hence hl cc wu v 54 complete algorithm discussion thread previous three sections summarized following procedure time processor requirement analyzed next section thread input g b k 1 k 1 available end kth superstep construct q 0 g 0 0 3 blog ic phase j denote input ba 1 edges input full respect q lists set merged adjacency lists b list l 2 q l contains 2 bi2 part lg otherwise remove l q 2 list l 2 q remove unwanted edges lists 22 kw chong han tw lam l contains edge halfinput remove l q b detect remove internal secondary external edges l c edges hu vi l wu v tmphl remove l q 3 truncate list necessary remove remaining internal edges list l 2 q l contains 2 bi2 j c 1 edges retain smallest ones update hl minimum tmphl smallest edge removed l b edge hu vi 2 l wu v hl remove hu vi l appears list l q blog ic wu v hl g 6 time processor complexity first show new mst algorithm runs olog n time using nm log n crew pram processors illustrate modify algorithm run erew pram reduce processor bound linear threads start run concurrently need initialization step first adjacency list g sorted ascending order respect edge weights set sorted adjacency lists replicated blog nc times copy moved local memory thread part global shared memory dedicated processors performing local computation thread replication takes olog n time using linear number processors thread constructs q 0 o1 time afterwards threads run concurrently mentioned section 3 computation thread scheduled run number phases phase starts ends predetermined supersteps need show computation phase completed within allocated time interval particular phase j thread scheduled start j 1th superstep end j1 th superstep using supersteps following lemma shows phase j thread implemented ci2 j 1 time c constant setting length superstep constant c 0 ci2 j 1 c 0 1 phase j complete computation 1 supersteps verify lemma 14 phase j thread implemented oi2 using processors proof consider computation phase j thread merging adjacency list starts thread reads ba may also read many threads local memory thread merging adjacency lists step 2a takes o1 time step 2b testing length list 2 bi2 done performing pointer jumping time adjacency lists left length 2 bi2 subsequent steps make use standard parallel algorithmic techniques including list ranking sorting pointer jumping optimal parallel mst algorithm 23 process remaining list time used techniques logarithmic order length list see eg jaja 1992 therefore steps phase j implemented ci2 using linear number processors corollary 1 minimum spanning tree weighted undirected graph found olog n time using n log n crew pram processors proof lemma 14 computation phase j thread satises predetermined schedule therefore b found end ith superstep b1 blog nc ready end blog ncth superstep means whole algorithm runs olog n time thread uses nm processors n log n processors suce whole algorithm 61 adaptation erew pram illustrate modify algorithm run erew pram model consider phase j thread discussed proof lemma 1 concurrent read used accessing edges ba may also read many threads time ba already resided local memory thread steps implemented erew pram avoid using concurrent read require thread copy output subsequent thread modifying schedule thread perform copying process sequential manner details follows shown proof lemma 1 phase j thread implemented ci2 c constant length superstep set c 0 phase j thread completed within supersteps length superstep doubled ie superstep takes 2c 0 time instead c 0 computation phase j deferred last half supersteps ie last 1 supersteps rst half supersteps phase j ie 1th j1 th supersteps computation performed thread waiting threads store outputs b j 1 local memory complete schedule need show thread k k perform copying time recall thread k completes computation kth superstep k four threads namely thread replication takes using linear number processors lemma 15 consider thread end th super step copy ba residing local memory thread proof k thread receives b k k phase j thread b j last set edges received arrives th superstep start second half phase j han tw lam 62 linear processors section adapt mst algorithm run linear number processors rst show reduce processor requirement n log n dense graph least n log n edges processor requirement dominated finally give simple extra step handle sparse graphs reduce processor requirement log n would like introduce preprocessing thread thread work n instead edges compute required output using n processors yet preprocessing thread still needs handle edges requires processors sidestep diculty attempt share preprocessing among threads precisely computation divided dlog log ne stages stage k 1 ne perform one single preprocessing allows 2 k 1 threads compute concurrently edge sets using processors preprocessing runs o2 k supersteps using processors thus stage makes use total number supersteps stages still olog n lemma 16 minimum spanning tree weighted undirected graph found olog n time using n log n processors erew pram proof linearprocessor algorithm runs dloglog ne1 stages stage 0 found thread 1 1 k dloglog ne stage k given compute b2 specically let thread 2x preprocessing threads 1 2 x actual computation parts require ox supersteps preprocessing prepare initial adjacency lists thread let f set trees induced b1 x denition 2 x forest g invoke thread 2x execute phase 1 computing set q 1 adjacency lists denition list q 1 length 2 2x2 representing tree f containing primary external edges base less 2 2x contains sucient edges nding b 2x also f contains n2 x trees q 1 contains total n edges list q 1 sorted respect edge weight using ox supersteps n processors q 1 copied local memory threads 1 x one one x supersteps using n processors 1 x thread replaces initial set adjacency lists q 0 new set q 0 constructed truncating list q 1 include smallest 2 1 edges threads 1 x ready run concurrently computing b respectively 1 x thread uses q 0 initial set adjacency lists follows original phasebyphase schedule execute algorithm stated section 54 note algorithm thread versatile stated every thread starts q 0 input thread compute edge set b xi instead found threads 1 x x supersteps note q 0 n edges processors requirement thread n short stage k takes ox supersteps using mx n mn log n processors optimal parallel mst algorithm 25 recall dlog log ne stages altogether run olog n time using processors input graph sparse ie n log n rst construct contracted graph g c g follows execute threads 1 loglog n concurrently nd log n induces log nforest b g contracting tree forest obtain contracted graph g c n log n vertices contraction takes olog n time using processors lemma 16 minimum spanning tree g c denoted gc computed olog n time using n log n log processors note gc b include exactly edges g conclude following theorem theorem 1 minimum spanning tree undirected graph found olog n time using linear number processors erew pram r new connectivity msf algorithms shu faster deterministic algorithm minimum spanning trees minimum spanning tree algorithm inverseackermann type complexity finding minimum spanning trees erew pram finding connected components olog n loglog n time erew pram parallel merge sort finding minimum spanning forests logarithmic time linear work using random sampling approximate exact parallel scheduling applications list upper lower time bounds parallel random access machines without simultaneous writes fibonacci heaps used improved network optimization algorithms optimal randomized parallel algorithm finding connected components graph sharedmemory model serve bridging model parallel computation proceedingsin proceedings 9th acm symposium parallel algorithms architecturesproceedings fast ecient parallel connected component algorithm computing connected components parallel computers connected components olg 3 parallel algorithm computing minimum spanning trees random sampling graph optimization problems randomized lineartime algorithm nd minimum spanning trees fast connected components algorithms erew pram parallel algorithms sharedmemory chines parallel ear decomposition search undirected connectivity olog 15 n space finding minimum spanning trees randomized timework optimal parallel algorithm finding minimum spanning forest optimal minimum spanning tree algo rithm randomized linear work erew pram algorithm find minimum spanning forest structures network algorithms bridging model parallel computation tr data structures network algorithms upper lower time bounds parallel random access machines without simultaneous writes efficient algorithms finding minimum spanning trees undirected directed graphs fibonacci heaps uses improved network optimization algorithms new connectivity msf algorithms shuffleexchange network pram parallel ear decomposition search eds italicstnumbering graphs parallel merge sort bridging model parallel computation parallel algorithms sharedmemory machines connected components italicoitaliclgsupscrpt32supscrptitalicvitalic parallel time crew pram extended abstract introduction parallel algorithms parallel algorithm computing minimum spanning trees fast connected components algorithms erew pram randomized lineartime algorithm find minimum spanning trees efficient fast parallelconnected component algorithm random sampling graph optimization problems finding minimum spanning forests logarithmic time linear work using random sampling sharedmemory model serve bridging model parallel computation isli myampersandsubeilisup43sup finding connected components italicoitaliclog italicnitalic loglog italicnitalic time erew pram optimal randomized erew pram algorithms finding spanning forests basic graph connectivity problems minimum spanning tree algorithm inverseackermann type complexity efficient parallel algorithms graph problems computing connected components parallel computers optimal minimum spanning tree algorithm randomized linear work erew pram algorithm find minimum spanning forest randomized timework optimal parallel algorithm finding minimum spanning forest faster deterministic algorithm minimum spanning trees finding minimum spanning trees om alphamn time ctr tsansheng hsu simpler faster biconnectivity augmentation journal algorithms v45 n1 p5571 october 2002 stavros nikolopoulos leonidas palios parallel algorithms p toshihiro fujito takashi doi 2approximation nc algorithm connected vertex cover tree cover information processing letters v90 n2 p5963 vladimir trifonov olog n log log n space algorithm undirected stconnectivity proceedings thirtyseventh annual acm symposium theory computing may 2224 2005 baltimore md usa david bader guojing cong fast sharedmemory algorithms computing minimum spanning forest sparse graphs journal parallel distributed computing v66 n11 p13661378 november 2006 aaron windsor nc algorithm finding maximal acyclic set graph proceedings sixteenth annual acm symposium parallelism algorithms architectures june 2730 2004 barcelona spain seth pettie vijaya ramachandran optimal minimum spanning tree algorithm journal acm jacm v49 n1 p1634 january 2002
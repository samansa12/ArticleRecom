detecting unsafe error recovery schedules mechanism modeling timing precedence dataconsistency constraints concurrently executing processes presented model allows durations intervals events specified algorithm provided detect schedules may unsafe respect constraints work motivated design validation autonomous errorrecovery strategies galileo spacecraft appears applicable variety asynchronous realtime systems b introduction paper presents technique detecting unsafe schedules involving asynchronous software processes responsible error recovery onboard spacecraft autonomous processes constrained event level timing precedence dataconsistency rules schedule ordering events violates constraints jeopardize spacecraft labeled unsafe safety involves correctness properties required static portions specifications 3 motivation work comes difficulty analyzing potential process interactions spacecraft error recovery single failure spacecraft may times trigger several different processes whose actions must compatible one failure may also occur time causing several errorrecovery processes invoked addition time unique sequence uplinked commands instructions subsystems executing spacecraft commands must also compatible actions errorrecovery software system development possibility interaction sequence commands errorrecovery software carefully scrutinized often limited software tools currently available tedious difficult task tool ieee transactions software engineering188 aug 1992 work supported part nasa grant ngt50269 authors mailing address department computer science iowa state university ames ia 50011 one described provides graphical representation relevant command constraints algorithm aid detecting unsafe interleavings software processes help analysis need tools able detect unsafe interleavings processes increase future spacecraft missions 14 18 25 spacecraft become complicated hardware advances distributed architectures allow science autonomy opportunity unplanned interactions grow concurrency increases additional computer capability embedded future science instruments bring risk complicated interfaces subsystems however spacecraft become complex employ concurrent processors software simulation becomes costly timeconsuming develop hardware testbeds usually depend scarce spare components slow test many paths result opportunity spacecraft concurrency increases ability detect unsafe schedules involving concurrent processes increasing commensurately complexity spacecraft requires capability model analyze precedence timing dataconsistency constraints order detect unsafe errorrecovery schedules traditionally realtime constraints defined terms periodic actions deadline requirements definition inadequate model timing constraints spacecraft commands work described extends definition timing constraints represent allowable intervals commands execution times activities initiated commands extensions recent research results allow accurate modeling required timing relationships among commands model represents timing precedence dataconsistency constraints spacecraft commands means labeled graph nodes represent commands edges represent constraints commands algorithm described accepts input constraints graph number potentially concurrent software processes userprovided intervals processes execute algorithm tests edge graph determine whether schedule comprised interleaved commands processes fail satisfy constraint work performed context galileo spacecraft interplanetary probe currently journeying jupiter preliminary results reported 22 ongoing research indicates results equally applicable spacecraft well asynchronous systems precedence critical timing constraints remainder paper organized follows section ii describes problem detail spacecraft setting section iii discusses current research area section iv describes modeling timing precedence dataconsistency constraints means constraints graph section v presents constraints checker algorithm time complexity also provides example illustrate constraints checker applied detect unsafe error recovery schedules section vi describes work remains done application domains appropriate constraints checker final section offers concluding remarks ii errorrecovery schedules galileo spacecraft enroute 1995 encounter planet jupiter complex system many interactions among computers science instruments hardware components spacecraft hard realtime system failure satisfy timing constraints jeopardizes correctness systems behavior well spacecraft 36 spacecraft controlled 28 processors six form sharedmemory central command data subsystem subsystem interfaces spacecraft subsystems two buses hardline connections central subsystems architecture based five virtual machines hide details system scheduling algorithms interrupt handling multilevel message queues virtual machines operate 23second granularity producing relatively coarsegrained timing constraints spacecraft instructions instructions called commands various subsystems direct spacecraft take specific actions specific times individual commands assembled groups timetagged commands called command sequences periodically sent spacecraft ground command sequences stored temporarily spacecrafts memory time comes command execute command sequences critical success failure spacecrafts mission labeled critical sequences command sequences used launch direct galileos science engineering activities jupiter examples critical sequences process sequence commands executed sequentially single processor may initiated ground command response error condition detected onboard command sequences straightline errorrecovery processes may include branches spacecraft however amount branching minimal detection unsafe schedules aided fact unlike situation many asynchronous systems one process wait another time command issued depends starting time process internal structure process actions processes systemlevel software onboard spacecraft monitors responds failures standard definitions used failure event behavior system deviates specification error incorrect state system must remedied 31 errorrecovery processes include respond loss uplink downlink communication thermal power pressure anomalies indicators regarding health computers failure occur noncritical sequence computer may cancel activity critical sequence however must continue execute even system recovery requirement concurrent execution critical sequence error recovery drove much work presented constraints imposed commands effort preclude conflicting interactions among possibly concurrent processes commands interfere effect commands executed closely far apart time certain commands must precede follow commands accomplish desired action commands change values parameters used commands commands relating power propellant usage temperature attitude control spacecraft data modes endanger collection scientific data subsystem spacecraft intervening commands issued another process leave spacecraft unexpected state restrict interactions allowed constraints placed interleavings commands flight rules well documented systemperformance operational specifications forbid certain interactions unsafe constraints also describe ordering precedence timing relationships commands must maintained even processes containing commands execute concurrently work addresses task trying detect conflicting interactionsthose interleavings commands asynchronous processes may unsafe unsafe schedule one defies intercommand constraints detecting undesirable interactions involving errorrecovery processes especially important since errorrecovery software usually executes failure already detected onboard spacecraft critical sequence executing software must quickly thus autonomously reconfigure spacecraft state precondition next activity sequence addition errorrecovery software responsive asynchronous 7 may begin execution time fact spacecraft often taxed critical science activity errorrecovery software likely execute spacecraft active errorrecovery capabilities increase number interactions among concurrently executing processes also tend executed busiest terms process interactions times also case hardware failures due physical damage tend clustered time 29 following assumptions hold 1 process correct initial state runs completion produces correct results executed alone assumptions exclude consideration cases execution single process isolation unsafe cases properly detected methods prior use constraints checker presented assumptions also exclude cases command constraint satisfied one command never issued due process abortion 2 simplifying assumptions galileo architecture made respect existence backup hardware components possibility rollbacks critical sequences iii background problem addressed check concurrent execution asynchronous processes cooperate error recovery satisfy precedence constraints maintain data consistency readwrite constraints satisfy timing constraints problem differs four significant ways focus research area 1 effort validate possible errorrecovery schedules allowed spacecraft system safe research scheduling concentrates developing schedulers capable choosing single safe schedule 2 issue manage concurrency maximize work addresses question whether spacecraft already allows much concurrency guarantee constraints always met spacecrafts scheduling software assumed already place research concurrency instead addresses question concurrency maximized future system within given constraints 3 solutions error recovery usually involve notion atomic actions spacecraft command cannot adequately modeled atomic action 20 37 command defined action issuance command defined event instantiation action specific point time issuance command assumed occur instantaneously point time following convention stated command c occurs issued time however activity operation initiated command c usually instantaneous duration activity constraints often refer example c command slew scan platform particular position mechanical activity moving platform may take minutes complete stated command c takes minutes execute model described allows commands duration length time required execute activity initiated command attached command thus constraint form command c j occurs activity initiated occurrence commmand c must first completed represented type constraint common spacecraft realtime systems duration commanded activity variable limited worstcase time represented model 4 solution must take account precedence constraints timing constraints precedence timing fundamentally different precedence require notion duration 30 methods currently exist model precedence constraints incorporate timing requirements inadequate modeling timing constraints spacecraft 15 24 28 hand many techniques currently available model timing constraints tend ignore precedence constraints techniques consider timing precedence constraints definition timing constraints terms periodic events eg sampling rates fixed execution times events deadline timeliness requirements provides limited model aperiodic interval timing constraints spacecraft commands 8 35 36 40 work described brings together study realtime constraints study precedence dataconsistency constraints wide variety powerful formalisms exists model specifications behavior realtime concurrent systems many formalisms address degree problem checking timing constraints however none available methods readily translates domain validating error recovery spacecraft petri net extensions model periodic events deadlines 10 21 automatabased methods model processes machine try prove predicate may involve upper lower time bounds events true reachable states machine 5 13 23 al ternatively processes repesented timed buchi automata upper time bounds events languages timed traces accept investigated 2 real time logic models timing aspects system specification establish timing properties periodic events deadlines 19 various extensions temporal logic temporal logic model checking developed formally describe timing requirements verify automatically system satisfies 1 9 12 17 30 methods provide good basis specifying timing requirements either ambitious model states less expressive model subset timing constraints needed spacecraft work decribed discusses many timing issues addressed recent work interval temporal logic 11 32 34 38 however emphasis specifying verifying system requirements spacecraft must emphasis verifying operational constraints spacecraft allowed example system requirement often stated terms lower time bound event may occur upper time bound event must occurred contrast operational constraint often stated terms interval event permitted occur perhaps wont outside interval event must never occur distinction hard time constraint interval within action taken soft time constraint interval within action may occur 5 often absent formal models autonomous error recovery onboard spacecraft requires spacecraft capabilities permitted exercise subject certain constraints paper offers partial solution problem modeling quantitative timing constraints within context spacecraft error recovery iv model constraints exist command level asynchronous execution spacecraft error recovery modeled via constraints graph constraints graph directed graph gve node c c j 2 v labeled command edge e labeled constraint edge example timing constraint scan command shall sent within 10 seconds slew command modeled labeled edge node labeled slew node labeled scan fig 1 figure 1 edge constraints graph command command precedence subgraph g 0 subgraph composed precedence edges required acyclic since cycle precedence constraints cannot satisfied simultaneously node representing command associated command mnemonic identifies command nominal predicted execution time command worstcase execution time command longest time designers must plan example taperewind command galileo worstcase time field seven minutes edge associated edge type described two optional time fields indicating constraint documented variable edge represents dataconsistency constraint intercommand constraints rules govern ordering timing relationships commands two main classes intercommand constraints precedence constraints timing constraints dataconsistency constraints typically represented precedence constraints classification timing precedence constraints corresponds loosely standard formal division program correctness safety properties liveness properties safety properties stated informally nothing bad ever happens liveness properties something good eventually happens 39 timing constraints intercommand timing constraints safety properties impose quantitative temporal relationship commands c c j distinct commands 1 2 time parameters following five types timing constraints occur examples paraphased galileo documentation 1 minimuminterval constraint c occurs c j cannot occur within time 1 example scan command shall sent within 10 seconds slew command 2 outsideinterval constraint c occurs c j occur outside range 1 2 example time separation powering sband transmitter powering xband transmitter shall either less onehalf minute greater 6 minutes minimuminterval constraint special case outsideinterval constraint called separately clarity presentation 3 forbidden combination constraint c occurs c j cannot occur special case outsideinterval constraint example one two optics heaters commanded optics heater cannot commanded constraint discussed 4 maximuminterval constraint c occurs c j occur within time 1 example maximum 6 minutes delay spectrometer power replacementheater power tolerated 5 insideinterval constraint c occurs c j occur within range 1 2 example lowgain antenna motor power command follows command sooner 9 seconds later constraint special case insideinterval constraint outsideinterval constraint constraint form c occurs c j occur expressed either outsideinterval edge insideinterval edge cases nominaltoworstcase execution time may documented command c pair values indicates expected time takes command c complete well longest completion time developers must plan worstcase execution time c additional constraint time command c j occur case minimuminterval constraint time parameter worstcase execution time added 1 graph however case maximuminterval timing constraint adding worstcase execution time initial timing constraint mask violation constraint lessening time interval commands c c j instead nominal execution time added timing constraint cases insideinterval outsideinterval edge types follow accordingly b precedence constraints intercommand timing constraints clearly safety properties intercommand precedence constraints contain aspects safety liveness properties 23 precedence constraints enforce ordering commands involve functional correctness concern safety properties precedence constraints also involve liveness properties since assert one command occurs another command must precede c j occurs c must precede example spin detector b powered detector turned thus whereas timing constraints assert every c occur timing relationship c j precedence constraints assert every c j must exist c precedes timing constraint exists commands c c j either command legally occur alone however precedence constraint exists commands c c j eg c j occurs c must precede c j cannot occur isolation c many constraints form state precondition issuing command c j state commanded adequately though imperfectly modeled precedence constraints example rule 10newton thruster firings must performed scan platform safe position context spacecraft suffices ensure command place scan platform safe position precedes command thruster firing representing state scan platform safe position command place scan platform safe position constraint modeled graph required state cannot commanded eg lowradiation environment cannot modeled graph similar abstraction occurs forbiddencombination constraints example constraints graph approximates constraint forbidding issuance command turn optics heater b optics heater means edge forbids issuance command turn optics heater b following issuance command turn optics heater places restriction schedules considered legal example command turn heater occurs two commands schedule flagged illegal method tool used mechanical verification analysis aid development occasional false positives tolerated easily resolvable subsequent inspection code c dataconsistency constraints dataconsistency constraints involve restrictions placed order commands two processes access variable least one process changes value variable 4 cases concurrent execution processes lead result different sequential execution processes forestall data inconsistency could result dataconsistency constraint used specify order commands readwrite variable must occur dataconsistency constraint expressed precedence constraint example galileo commandedmaneuverstatus variable updated command sequence thruster burn places galileo orbit around jupiter failure occurs adjacent time burn variable read errorrecovery process determine appropriate response documented constraint requires update precede read writeread constraint modeled graph adding precedence edge node representing update node representing read constraints checker model state spacecraft instead accepts input several sequences commands processes set rules constraints looks schedulings concurrent execution processes violates constraint consequently process input constraints checker issues command constraints checker see effect command v constraints checker algorithm section iv described edge represents constraint must hold commands edges endpoints constraint translated constraints graph edge type precedence minimum interval etc constraints graph set processes timetagged lists commands input constraints checker constraints checker algorithm fixes one process timeline determines range start times fixed timeline constraint represented edge impose processes start times edge type associated algebraic predicate relates time issuance commands edges endpoints constraint represented edge constraints checker tests whether appropriate predicate holds edge constraints graph edge fails satisfy required predicate flagged case scheduling processes cause constraint represented edge violated since constraints graph sparse adjacency list representation used store graph 27 inputting process constraints checker consists adding twoway pointer command process node constraints graph represents command command associated time tag command represented node may occur processes processes may multiple occurrences command commands various possible paths process interleaved possible interactions distinct processes analyzed furthermore tree possible paths small since command sequences straightline processes errorrecovery processes display little branching practice control structure spacecraft processes simple enough allow complete unraveling process constructs fix timeline one process start time thus timeline fixed processes timelines moved relative fixed process one processes command sequence natural choice fixed timeline since sequences absolute start times otherwise process lowest processor identification pid chosen edge process p issuing command c process p j issuing command c j edge violation occurs result interleaving several processes edge violation still occurs result interleaving two processes issue edges nodes interleaving two processes occur via concurrent execution two processes occur concurrent execution two processes thus suffices check edge every ordered pair c 0 instance c c 0 j instance c j c 0 issued distinct processes see appendix detailed example fixed process issuing c starttime known command sequences earliest possible start time process issuing c l latest possible start time process issuing c e l provided user define maximum range start times analyzed process define interval starttime p c issued fixed process let gc earliest time instance c assumed occurred used precedence edges defined variables j defined p j analogously v refer actual earliest latest start times respectively p v process whose timeline variable sake clarity description algorithm fig 2 assumes values user user provided values constraints checker cannot detect violations edges issue warning flags user however useful information regarding range allowable start times processes still accumulated output described algorithm constraints checker fig 2 distinguishes precedence edges timeconstrained edges precedence edge requires every c j preceded c algorithm effect examines instances c instance c j capture existential quantifier predicate precedence edge exists c precedes c j constraints checker refers information user user decides processes considered always execute current scenario command c process may may execute cannot certainty satisfy precedence edge variable gc earliest time process guaranteed execute guarantee c occur p sequence gc timetag earliest instance command c sequence example analyzing precedence constraint galileo c 22 must precede c 24 gc c 22 fixed time command sequence issues c 22 namely value 20038 see appendix p sequence gc optional userprovided value practice often equal user make guarantee regarding instance c occur gc set arbitrarily large integer constraints checker uses gc detect possible violation precedence edge requiring c j occur gc given j actual start time process issuing c j delta j time interval j command c j issued e j earliest time process p j start command c j occurs fixed however start time process issuing c fixed value j fixed algorithm considers earliest time c j occurnamely earliest time c occur precedes equals gc edge flagged means constraint edge represents always satisfied process interactions noted section iv dataconsistency constraints modeled precedence edges constraints checker algorithm thus validates dataconsistency constraints testing edges timeconstrained edge requires command c occurs command c j occur within time interval whereas precedence edge requires c every c j timeconstrained edge presence one command require presence predicates timeconstrained edges form every c j follows c must satisfy certain timing constraint timing constraint define time interval range possible times process whose timeline variable may start according user define safe set safe times process may start set times satisfy predicate edge type timeconstrained edge satisfied set possible times process whose timeline variable contained within set safe times process poss safe fig 2 fig 2 constraints checker algorithm begin input poss fusersupplied intervalg edge constraints graph begin instance c 0 c j begin according rules p j fixed output warning flag p fixed output warning flag else ftimeconstrained edgeg pair c 0 instances begin according rules p fixed fsee fig 3 predicate theta g safe ft jtheta else safe ft jtheta poss 6 safe output warning flag edge type edge checked edge type 0 edge type precedence 1 edge type minimuminterval ie command c j cannot occur within time 1 command c 2 edge type outsideinterval command c j cannot follow command c time 1 less time 2 3 edge type forbiddencombination command c j cannot occur command c 4 edge type maximuminterval command c j cannot occur time 1 command c 5 edge type insideinterval command c j cannot occur time 2 c thus 2 f012345g simplicity exposition time parameters 1 2 given algorithm although edge types use parameters five timeconstrained edge types 6 0 associated predicate theta used determine set safe fig 3 fig 3 predicates determining safe times theta theta 3 j false b output constraints checker makes assertion allowable start times process whose timeline fixed makes assertion based edge type currently surveyed constraint represented edge offset processes start times issuances c c j fixed start time one process constraint checkers assertion concerning processes start inconsistent userprovided range start times edge flagged order user able reconstruct concurrent execution caused edge flagged ie intercommand constraint edge represents violated constraints checker outputs identity flagged edge nodes well identity two processes whose concurrent execution caused constraint violation edge flagged due erroneous information one edge node labels user readily correct input data run constraints checker verify adequacy correction edge flagged due problem existing errorrecovery schedule data output flagged edge helps user identify problem user responds shifting processes timelines curtailing concurrency allowed intercommand constraint violated goal adjust limit concurrent execution processes edge flagged subsequent run edge flagged either calculated start time within userprovided time range user provide range possible start times predicate stored pair processes forms nodes edge yields predicate relating fixed start time one process variable start time process edges considered onebyone constraints checker constraints edges impose scheduling processes accumulate edges surveyed constraints checker computes every distinct pair processes range safe start times one process relative within time interval intercommand constraints satisfied notion precedence constraints presented restricted two ways first precedence constraints looked backward time command c j occurs exists instance command c precedes secondly precedence constraints contained timing information events order constraints modeled make appropriate restrictions relaxed minor adjustments algorithm allow precedence constraints look forward time every instance c followed instance c j new variable gc l defined used place gc algorithm variable gc l defined latest time c might occur addition e p j fixed adding timing information precedence constraints eg c j occurs c must precede least time blurs useful distinction ordering requirements timing requirements however distinction existential constraints exists c precedes c j universal constraints every c j occur specific time interval relative c preserved algorithm thus readily extended check additional types precedence constraints application domain requires similarly timing details specific system architecture incorporated predicates user wishes example galileo spacecraft commands issued systemfaultprotection processes subsystems given process cycle transferred output queues following cycle long command spends queue depends upon queue type command number commands issued proximate time process issued command operating mode among factors worstcase time command output queue calculated delay included algorithm galileo granularity time units involved command sequencing 23 seconds large enough architectural details included constraints checker c time complexity optimizations time complexity constraintschecker algorithm set edges n number processes k defined follows processes consideration edge set precedence edges set timing forbidden edges number instances fixed c process p x average number instances command per process maximum commands average number instances command per process outer forconstruct constraints checker executes times subsequently algorithm branches depending whether edge precedence timing edge either case testing predicate outputting warning flag takes constant time algorithm thus requires time since constraints graph sparse galileo 1200 commands 284 flight small since usually instances command per process k also small galileo spacecraft k slightly greater 1 although analysis time complexity assumes every command issued every process actuality edges nodes issued input processes checked user reduce running time pruning constraints graph include nodes commands present processes consideration edges rules interest disadvantage pruning graph edges checked may accidentally deleted number processes n usually quite small since constraints checker functions primarily visualization validation tool interactions cannot easily grasped using current techniques typical run consists critical command sequence errorrecovery programs galileo example 26 systemlevel errorrecovery programs many cannot execute concurrently example following example galileo spacecraft illustrates constraints graph algorithm function scenario analyzed addresses complicated timing issues involved probe relayjupiter orbital insertion relayjoi critical sequence resident command data subsystem cds computer issues commands aacs attitude articulation control subsystem hardware presuppose aacs certain configuration aacs computer experiences poweron reset failure jupiter orbital insertion errorrecovery responses cds jointly called must quickly reconfigure aacs configuration required sequence accomplished dividing critical sequence number segments consisting distinct aacs configuration activity eg 400newton burn needed completion sequence 16 33 segment sequence aacs init errorrecovery response tailored designed bring aacs back state required sequence point synchronization segments sequence aacs init errorrecovery responses accomplished via shared flag updated sequence determines aacs init response invoked among timing issues must taken account fact possible commands issued aacs init errorrecovery response time earlier would occurred sequence aacs init response occurred ten synchronized errorrecovery responses aacs init example examines six responses aacs init3 aacs init8 oneandahalfhour portion relayjoi sequence closely brackets joi entire sequence issues commands tenday period portion sequence analyzed contains 70 commands several issued redundantly six errorrecovery responses together contain 237 lines code almost commands many commands issued one response assumption made process satisfied intercommand constraints executed isolation commands process well different processes checked constraints constraints graph input constraints checker fig 4 consists 40 nodes 40 edges 6 26 edges 20 precedence edges 20 timing edges commands represented nodes address four different spacecraft subsystems intercommand constraints involving commands found seven processes discussed example shown figure entire constraints graph galileo would contain order 1200 nodes 1000 edges command represented spacecraft code mnemonic eg 7bigz command initiate 400newton engine burn labeled example positive integer ease explanation 7bigz example labeled c 24 fig 4 shows several precedence constraints unlabeled several timing constraints labeled involving command 7bigz edge node c 37 c 24 example represents precedence constraint 7bigz command occurs 7acclon command accelerometers must preceded results follows seven 40 edges constraints graph flagged constraints checker see appendix details four flagged edges convention violations timing edges labeled precedence edges unlabeled figure 2 example constraint checker precedence edges three timing edges one precedence edge flagged global variable could schedules used updated two edges flagged certain command required precede another occur one violations later traced outdated documentation another flagged edge fact violated appeared since required tailnode command appeared six hours associated headnode command two three timing edges flagged involved timing discrepancy requirements code third timing edge flagged resulted unforeseen consequence data field taking value possible forbidden operations another eight errors involving incorrect inconsistent documentation identified construction constraints graph seven eight errors significant enough caused inaccuracies constraints graph results constraints checker surprising constraints checker accurate constraints provided unexpected number errors discovered modeling process intercommand constraint violations flagged constraints checker boldface graph involved either discrepancies constraints code unforeseen consequences unlikely possible errorrecovery scenarios constraints checker appears useful enhancing developers ability visualize abnormal scenarios flagging timing precedence constraint violations occur subset possible schedules code analyzed baseline version rather current flight version choice made order provide code well thought yet thoroughly tested intermediate stage development process intercommand constraints initially documented details design timing still evolving constraints checker may effective vi future work applications version constraints checker currently development use comet rendezvousasteriod flyby craf spacecraft cassini spacecraft initial use software development tool analyzing testing errorrecovery processes schedules involving concurrent execution later command sequences developed constraints checker incorporate errorrecovery scenarios checks experience galileo indicates early detection significant inconsistencies design constraints constraint checkers major benefit evaluate systems ability satisfy precisely expressed timing precedence properties early design software constraints checker currently limits kinds intercommand constraints modeled original focus solving spacecraft problem existing core suffices check intercommand constraints spacecraft however extension applications requires expansion constraints definition specifically plans include extending include follows well precedes attaching times precedence constraints including boolean operators constraints providing flexibility similar commands distinct parameters grouped currently since interactions among processes execute correctly isolation analyzed edge never flagged due nodes issued different paths single process drop assumption isolated processes execute correctly naming mechanism incorporated constraints checker associate path name command edge flagged test nodes issued path process finally steps need taken towards automating creation constraints graph issues remain investigated modeling initial state form history earlier events representation ordinal iteration command second instance c j addition variable times time parameter constant current research especially interval temporal logic continues identify additional constraint types challenge incorporate features constraints checker without eroding focus usefulness accurately detecting unsafe schedules existing developing systems techniques outlined suitable addressing related problems domains spacecraft design systemlevel errorrecovery eventdriven systems often involves analysis temporal constraints affected concurrent execution processes unpredictable start times issues readily investigated constraints checker critical software applications many processcontrol flightcontrol commandand control avionics systems involve aperiodic tasks timeinterval specifications fre quently however periodic deadline specifications modeled tested tools currently use methods described offer capability quickly accurately model check even aperiodic interval constraints among events always hold system reasons interest expressed use constraints checker embeddable module simulation executablespecification tools constraints checker also suited operational situations space craft portion control software regularly replaced spacecraft sequences commands examples temporary software space station example procedures sequence activities outside astronauts responsibilities need sent ground operational difficulties quickly checking new temporary software conflict prior permanent software eased availability constraintsgraph model constraints checker vii conclusions paper shown construct constraints graph model precedence tim ing dataconsistency constraints historically difficult design constraints graph provides means visualizing command constraints must satisfied every concurrent execution processes paper also presented algorithm given constraints graph set processes detects possibly unsafe schedulings processes errorrecovery scenarios chosen test algorithm involved failures execution critical command sequence controls galileos arrival jupiter activities processes must cooperate error recovery highly constrained due complexity time criticality engineering science planetary encounter thus many opportunities unsafe errorrecovery schedules constraints checker offers way discover process interactions early software development process constraints checker algorithm designed specifically help answer question whether existing systemlevel error recovery adequate offers flexible embeddable relatively simple alternative simulation errorrecovery scenarios context spacecraft algorithm identifies unexpected effects resulting interleaving errorrecovery processes missioncritical sequences commands broader con text research presented part ongoing effort investigate behavior concurrently executing processes subject precedence timing constraints acknowledgments first author thanks chris p jones jet propulsion laboratory many helpful insights authors thank referees comments suggestions work first author started iowa state university supported grant ngt50269 national aeronautics space administration completed jet propulsion laboratory california institute technology contract national aeronautics space administration appendix provides details example described section vd sequence attached absolute time tag command six processes attached offset command measured minor frames 23 second process start edge graph node c called tail node c j called head edge due fact jupiter orbital insertion joi sequence provides time tags relative probe entry rather start command sequence time tag attached command sequence equals command tail node equals command head node command issued sequence gc command sequences time tag command user provided algorithm earliest latest start times aacs init responses fig 5 earliest latest times aacs power onreset occurred point synchronization flag would cause invocation response instance command every process linked node constraints graph node existed commands involved intercommand constraints appear graph checked algorithm 20 precedence edges graph nine discarded constraints checker occurrence commands represented edges heads processes input checker instance head eleven precedence edges checked constraints checker algorithm total 46 instances precedence edge c 22 c 24 one algorithm flagged satisfied four instances c one sequence 20042 hrsminsec one sequence 20044 one aacs init6 abbreviated p 6 one aacs init7 abbreviated p 7 one instance c 22 namely sequence fig 5 value gc time c 22 issued sequence code c seconds p 7 sequence value command issued cases sequence issued c 24 predicate required trivially satisfied case p 6 issued c 24 predicate required since constraints checker flagged edge information p 6 issued c 24 could issue sequence issued c 22 thus violating precedence constraint finally p 7 issued c 24 precedence preserved ten precedence edges similarly analyzed constraints checker three precedence edges flagged case one instances command represented head node occurred instance command represented tail node preceded required one cases analysis showed tail occur part sequence provided example another case documented constraint incorrect case global variable could used updated contrary constraint 20 timing edges graph fifteen dismissed constraints checker since occurrence head tail nodes processes algorithm computed whether timing predicates ever violated remaining five timing edges nodes appeared code edges algorithm tested every pair instances commands represented nodes total 83 pairs insideinterval timing edge c 24 c 32 one constraints checker flagged satisfied four instances c 24 three instances c 32 processes yielding twelve pairs instances c 24 c 32 check since edge type inside interval constraint values predicate held graph 000227 since constraint referred c 24 completed maximum burn time rather issued execution time 04554 constraints graph added 1 2 one twelve pairs checked involved case p 6 issued c 24 sequence issued c 32 24642 safe process start times satisfy predicate process start times satisfy thus however poss interval possible times process issued c 24 could start e edge flagged possible violate another pair checked involved case sequence issued c 24 time 20042 p 8 issued c 32 000016 interval possible times p 8 could start process start times satisfy predicate 20042 246427 poss 6 safe edge flagged additional information cases could violate constraint added output analysis ten pairs followed similarly 129 instances edges checked algorithm another 24 edges discarded head tail nodes found processes calculations seven edges described flagged representing intercommand constraints always satisfied fig 5 earliest latest start times processes aacs init segment 3 117506 132352 4 132353 158219 5 15822 200132 6 200133 237492 7 237493 246359 8 24636 259046 r modelchecking realtime systems automata modeling realtime systems principles concurrent programming analysis programs parallel processing management sensorimotor activity mobile robots galileo space flight operations plan error recovery asynchronous systems dynamic scheduling groups tasks precedence constraints distributed hard realtime systems automatic verification finitestate concurrent systems using temporal logic specifications timed petri net methodology specifying realtime system timing requirements interval logic based actions events temporal modal logic transformational method verifying safety properties realtime systems parallel discrete event simulation using semantic knowledge transaction processing distributed database galileo space flight operations plan temporal proof methodologies realtime systems hypercubes critical spacecraft command ver ification safety analysis timing properties realtime systems survey techniques synchronization recovery decentralized computer systems safety analysis using petri nets validating systemlevel error recovery space craft using mappings prove timing properties operating systems functional emulation engineering subsystem interactions within galileo spacecraft galileo spacecraft flight rules constraints data structures algorithms 2 graph algorithms np completeness approach reliable distributed computing mechanisms reliable distributed realtime operating systems applications temporal logic specifications real time systems reliability issues computing system design realtime interval logic reasoning executions realtime programs relayjoi sequence intervalbased temporal logic concurrency control distributed realtime databases tutorial hard realtime systems big atomic action paradigm realtime specification based interval logic scheduling processes release times deadlines prece dence exclusion relations tr graph algorithms npcompleteness nested transactions approach reliable distributed computing automatic verification finitestate concurrent systems using temporal logic specifications recovery asynchronous systems safety analysis timing properties realtime systems operation systems advanced concepts mechanisms reliable distributed realtime operating systems alpha kernel safety analysis using petri nets concurrency control distributed realtime databases realtime interval logic reasoning executions realtime programs principles concurrent distributed programming scheduling processes release times deadlines precedence exclusion relations parallel discrete event simulation automata modeling realtime systems temporal proof methodologies realtime systems specifiers introduction formal methods temporal modal logic using semantic knowledge transaction processing distributed database reliability issues computing system design survey techniques synchronization recovery decentralized computer systems hard realtime systems timed petri net methodolgoy specifying realtime system timing requirements applications temporal logic specification realtime systems intervalbased temporal logic ctr martin feather rapid application lightweight formal methods consistency analyses ieee transactions software engineering v24 n11 p949959 november 1998 robyn r lutz targeting safetyrelated errors software requirements analysis acm sigsoft software engineering notes v18 n5 p99106 dec 1993 robyn r lutz software engineering safety roadmap proceedings conference future software engineering p213226 june 0411 2000 limerick ireland
byzantine quorum systems quorum systems wellknown tools ensuring consistency availability replicated data despite benign failure data repositories paper consider arbitrary byzantine failure data repositories present first study quorum system requirements constructions ensure data availability consistency despite failures also consider load associated quorum systems ie minimal access probability busiest server services subject arbitrary failures demonstrate quorum systems ini servers load ioi1ini thus meeting lower bound load benignly faulttolerant quorum systems explore several variations quorum systems extend constructions cope arbitrary client failures b introduction well known way enhance availability performance replicated service using quorums quorum system universe servers collection subsets servers pair intersect intuitively quorum operate behalf system thus increasing availability performance intersection property guarantees operations done distinct quorums preserve consistency paper consider arbitrary byzantine failure clients servers initiate study quorum systems model intuitively quorum system tolerant byzantine failures collection subsets servers pair intersect set containing sufficiently many correct servers guarantee consistency replicated data seen clients provide following contributions 1 define class masking quorum systems data consistently replicated way resilient arbitrary failure data repositories present several example constructions systems show necessary sufficient conditions existence masking quorum systems different failure assumptions 2 explore two variations masking quorum systems first called dissemination quorum systems suited services receive distribute selfverifying information correct clients eg digitally signed values faulty servers fail redistribute cannot undetectably alter second variation called opaque masking quorum systems similar regular masking quorums makes assumption selfverifying data differs clients need know failure scenarios service designed somewhat simplifies client protocol case failures maliciously induced reveals less information clients could guide adversary attempting compromise system 3 explore load type quorum system load quorum system minimal access probability busiest server minimizing strategies picking quorums present masking quorum system property load total n servers 1 thereby meeting lower bound load benignlyfaulttolerant quorum systems added contribution also provide proof lower bound benignlyfaulttolerant quorum systemsand fortiori byzantine quorum systemsthat much simpler previous proofs opaque masking quorum systems prove lower bound 1 2 load present construction meets lower bound proves tight 4 services use masking quorums opaque show deal faulty clients addition faulty servers primary challenge raised client failures guarantee clients update quorums according specified protocol thus faulty client could leave service inconsistent irrecoverable state develop two update protocols clients access replicated service prevent clients leaving service inconsistent state protocols desirable property involve quorum access attempted providing systemwide consistency properties treatment express assumptions possible failures system form failprone system servers b contains faulty servers formulation includes typical failure assumptions threshold f servers fail eg sets could sets f servers also generalizes allow less uniform failure scenarios motivation exploring generalization stems experience constructing secure distributed services rei96 mr96 ie distributed services tolerate malicious corruption typically threshold number component servers attacker criticism assuming simple threshold corrupted servers server penetrations may independent example servers physical proximity administrative domain may exhibit correlated probabilities captured servers identical hardware software platforms may correlated probabilities electronic penetration exploiting correlations ie knowledge collection b design quorum systems effectively mask faulty servers quorum systems used conjunction appropriate protocols synchronization mechanisms used implement wide range data semantics paper however choose demonstrate variable supporting read write operations relatively weak semantics order maintain focus quorum constructions semantics imply safe variable lam86 case single reader single writer set correct clients use build abstractions eg atomic multiwriter multireader registers lam86 is92 ltv96 concurrent timestamp systems ds89 il93 lexclusion dgs88 adgm90 atomic snapshot scan adgm93 and93 quorum constructions also directly exploited algorithms employ uniform quorums fault tolerance either explicitly implicitly involving threshold processes order tolerate nonuniform failure scenarios examples include algorithms shared memory emulation abd95 randomized byzantine agreement tou84 reliable byzantine multicast bt85 rei94 mr96 secure replicated data ht88 rest paper structured follows begin section 2 description related work section 3 present system model definitions present quorum systems replication arbitrary data subject arbitrary server failures section 4 section 5 present two variations systems detail access protocols replicated services tolerate faulty clients addition faulty servers section 6 conclude section 7 related work work influenced substantial body literature quorum systems benign failures applications make use eg gif79 tho79 mae85 gb85 her86 et89 caa90 ae91 nw94 pw95 particular grid construction section 51 influenced gridlike constructions benign failures eg caa90 borrow definitions domination load gb85 nw94 respectively quorum systems previously employed implementation security mechanisms naor wool nw96 described methods construct accesscontrol service using quorums constructions use cryptographic techniques ensure outofdate correct servers cannot grant access unauthorized users agrawal el abbadi ae90 mukkamala muk94 considered confidentiality replicated data despite disclosure contents threshold otherwise correct repositories constructions used quorums increased intersec tion combined rabins dispersal scheme rab89 enhance confidentiality availability data despite servers crashing contents observed work differs considering arbitrarily faulty servers accommodating failure scenarios beyond simple threshold servers herlihy tygar ht88 applied quorums increased intersection problem protecting confidentiality integrity replicated data threshold arbitrarily faulty servers constructions replicated data stored encrypted key shared among servers using threshold secretsharing scheme sha79 client accesses threshold number servers reconstruct key prior performing encrypted reads writes construction exhibits one approach make replicated data selfverifying via encryption consequently quorum system develop special case dissemination quorum systems ie threshold faulty servers techniques proposed constructing distributed services tolerate arbitrary failure component servers eg see sch90 mar90 rb94 techniques aware typically require servers receive process client accesses thus exhibit high load many cases techniques could used efficiently mask arbitrary failures 3 preliminaries 31 system model assume universe u servers ju arbitrary number clients distinct servers quorum system q 2 u set subsets u pair intersect called quorum servers clients obey specifications correct faulty server however may deviate specification arbitrarily failprone system b 2 u set subsets u none contained another contains faulty servers failprone system represents assumption characterizing failure scenarios occur could express typical assumptions threshold servers fail well less uniform assumptions remainder section throughout sections 4 5 assume clients behave correctly section 6 relax assumption explicit assume two correct processes clients servers communicate au thenticated reliable channel correct process receives message another correct process correct process sent however assume known bounds message transmission times ie communication asynchronous 32 access protocol consider problem clients perform read write operations variable x replicated server universe u purposes paper define correctness variable follows formal treatment concepts found lam86 say read write operation op 1 precedes operation op 2 op 1 terminates real time client initiated op 2 starts real time client initiating op 1 precede op 2 op 2 precede op 1 called concurrent given set operations serialization operations total ordering extends precedence ordering among correctness condition requires read concurrent writes returns last value written serialization preceding writes case singlereader singlewriter variable immediately imply safe semantics lam86 copies variable x stored server along timestamp value timestamps assigned client replica variable client writes replica protocols require different clients choose different timestamps thus client c chooses timestamps set c intersect c 0 client c 0 timestamps c formed eg integers appended name c loworder bits read write operations implemented follows write client c write value v queries server quorum q obtain set valuetimestamp pairs chooses timestamp 2 c greater highest timestamp value greater timestamp chosen past updates x associated timestamp server q v respectively read client read x queries server quorum q obtain set client applies deterministic function result obtain result resulta read operation case write operation server updates local variable timestamp received values v greater timestamp currently associated variable two points description deserve discussion first nature quorum sets q function result intentionally left unspecified clarification point paper second description intended require client obtain set containing valuetimestamp pairs every server quorum q client unable gather complete set quorum eg server quorum appears unresponsive client must try perform operation different quorum requirement stems lack synchrony assumptions network general way client know accessed every correct server quorum apparently successfully access every server quorum framework guarantees availability quorum moment thus attempting operation multiple quorums client eventually make progress cases client achieve progress incrementally accessing servers obtains responses quorum 33 load measure inherent performance quorum system load naor wool nw94 define load quorum system probability accessing busiest server best case precisely given quorum system q access strategy w probability distribution elements q ie 1 wq probability quorum q chosen service accessed load defined follows definition 31 let strategy w given quorum system universe u element u 2 u load induced w u l w load induced strategy w quorum system q system load quorum system q minimum taken strategies 2 reiterate load best case definition load quorum system achieved optimal access strategy used case failures occur strength definition load property quorum system protocol using comparison definition load seemingly plausible definitions given nw94 also explore related notion capacity quorum system rate system handles quorum accesses prove capacity inverse load 34 size domination another natural measure performance quorum system size quorums intu itively size quorum represents cost incurred client accessing thus general smaller quorums desirable special interest quorum systems cannot reduced size ie quorum system reduced size quorum systems called nondominated precisely let coterie quorum system q property q q q 0 two coteries q every q exists q 2 q dominated exists coterie q dominates nondominated coterie exists paper consider coteries although constructions dominated masking quorum systems section introduce masking quorum systems used mask arbitrarily faulty behavior data repositories motivate definition suppose replicated variable x written quorum q 1 subsequently x read using quorum q 2 b set arbitrarily faulty servers q 1 q 2 nb set correct servers possess latest value x order client obtain value client must able locate valuetimestamp pair returned set servers could faulty addition availability require set faulty servers disable quorums definition 41 quorum system q masking quorum system failprone system b following properties satisfied difficult verify masking quorum system enables client obtain correct answer service write operation implemented described section 3 read operation becomes read client read variable x queries server quorum q obtain set valuetimestamp pairs client computes set client chooses pair v 0 highest timestamp chooses v result read operation 0 empty client returns null value lemma 41 read operation concurrent write operations returns value written last preceding write operation serialization preceding write operations proof let w denote set write operations preceding read read operation return value written write operation w highest timestamp since construction masking quorum systems valuetimestamp pair appear 0 highest timestamp 0 pair higher timestamp returned servers b suffices argue serialization writes w operation appears last words write operation precedes write operation w immediate however precede another write operation w write operation would higher timestamp 2 lemma implies protocol implements singlewriter singlereader safe variable lam86 multiwriter multireader atomic variables built using wellknown constructions lam86 is92 ltv96 necessary sufficient condition existence masking quorum system construction one exists given failprone system b given following theorem theorem 41 let b failprone system universe u exists masking quorum system b iff bg masking quorum system b proof obviously q masking quorum system b one exists show converse assume q masking quorum since m2 holds q construction exist b construction q know masking quorum system b must contain quorums q 0 however q 0 case also since q 0 2 violating m1 therefore exist masking quorum system b assumption q masking quorum system b 2 corollary 41 let b failprone system universe u exists masking quorum system b iff particular suppose fg exists masking quorum system b iff n 4f proof theorem 41 masking quorum b iff bg masking quorum b construction q masking quorum iff m1 holds q ie iff proved nw94 benignfailure quorum systems holds masking quorums well result m1 let cq denote size smallest quorum q theorem 42 q quorum system universe n elements lq maxf 1 cq g proof theorem nw94 employs rather complex methods present simpler proof theorem proof let w strategy quorum system q fix summing loads induced w elements q 1 obtain l w therefore exists element q 1 suffers load least 1 cq similarly summing total load induced w elements universe get u2u l w u2u inequality results minimality cq therefore exists element u suffers load least cq since masking quorum system quorum system fortiori corollary 42 q masking quorum system universe n elements lq cq n g thus lq 1 n give several examples masking quorum systems describe properties refer system nondominated mean within class masking quorum systems given failprone system b example 41 threshold suppose note corresponds usual threshold assumption f servers may fail quorum system masking quorum system b m1 satisfied q intersect least 2f 1 elements m2 holds n2f1e system nondominated strategy assigns equal probability quorum induces load 1 2 e system corollary 42 load fact load system 2 following example interesting since load decreases function n since demonstrates method ensuring systemwide consistency face byzantine failures requiring involvement fewer majority correct servers example 42 grid quorums suppose universe servers size integer k n arrange universe n theta grid shown figure 1 denote rows columns grid r c respectively n quorum system i2i masking quorum system b m1 holds since every pair quorums intersect least 2f 1 elements column one quorum intersects 2f rows m2 holds since choice f faulty elements grid 2f full rows column remain available strategy assigns equal probability quorum induces load 2f2 n corollary 42 load system 2 note choosing example resulting construction load 1 asymptotically meets bounds given corollary 42 grid construction dominated eg column elements top row quorum removed quorum system remains dominated grid construction would work nonsquare grids well eg triangular grids lov73 cwlog grids pw95 contain 2 rows length 2 square grid already possesses load within constant factor optimal pursue constructions figure 1 grid construction k theta example 43 partition suppose 4 partition u b choice b could arise example wide area network composed multiple local clusters containing b expresses assumption time one cluster faulty collection nonempty sets thought superelements universe threshold assumption therefore following masking quorum system b i2i m1 satisfied intersection two quorums contains elements least three sets b m2 holds since intersects quorums q nondominated iff strategy assigns equal probability quorum induces load 1 2 e system regardless size corollary 42 implies load system efficient construction achieved forming grid construction example 42 super elements f achieving load 4 5 variations 51 dissemination quorum systems special case services may employ quorums byzantine environment consider applications service repository selfverifying information ie information clients create clients detect attempted modification faulty server natural example database public key certificates found many public key distribution systems eg ccit88 ta91 labw92 ken93 public key certificate structure containing name user public key represents assertion indicated public key used authenticate messages indicated user structure digitally signed eg rsa78 certification authority anyone public key authority verify assertion providing trusts authority use indicated public key authenticate indicated user due signature possible faulty server undetectably modify certificate stores however faulty server undetectably suppress change propagating clients simply ignoring update certification authority could effect eg suppressing revocation key compromised expected use digital signatures verify data improves cost accessing replicated data support service employ dissemination quorum system weaker requirements masking quorums nevertheless ensures applications like selfverifying writes propagated subsequent read operations despite arbitrary failure servers achieve suffices intersection every two quorums contained set potentially faulty servers written value propagate read supposing operations required continue face failures quorums faulty set cannot disable definition 51 quorum system q dissemination quorum system failprone system b following properties satisfied dissemination quorum system suffice propagating selfverifying information application described write operation implemented described section 3 read operation becomes read client read variable x queries server quorum q obtain set valuetimestamp pairs client discards pairs verifiable eg using appropriate digital signature verification algorithm chooses remaining pairs pair v largest timestamp v result read operation important note timestamps must included part selfverifying infor mation cannot undetectably altered faulty servers case application described existing standards public key certificates eg ccit88 already require realtime timestamp certificate following two lemmata prove correctness protocol using dissemination quorum systems lemma 51 read operation concurrent write operations returns value written last preceding write operation serialization preceding write operations proof let w denote set write operations preceding read read operation return value written write operation w highest timestamp since quorum write completed intersects quorum read occurs least one correct server suffices argue serialization writes w write operation appears last words write operation precedes write operation w immediate however precede another write operation w write operation would higher timestamp 2 case also prove following property lemma 52 read operation concurrent one write operations returns either value written last preceding write operation serialization preceding write operations values written concurrent write operations proof due assumption selfverifying data read operation must return value written preceding concurrent write operation read operation return value written concurrent write operation must return value written last preceding write operation serialization preceding write operations argument similar lemma 41 2 lemmata imply protocol implements singlewriter singlereader regular variable lam86 theorems analogous ones given masking quorum systems easily derived dissemination quorums list results without proof theorem 51 let b failprone system universe u exists dissemination quorum system b iff bg dissemination quorum system b corollary 51 let b failprone system universe u exists dissemination quorum system b iff particular suppose fg exists dissemination quorum system b iff n 3f corollary 52 q dissemination quorum system universe n elements lq cq n g thus also n provide several example constructions dissemination quorum systems example 51 threshold suppose note corresponds usual threshold assumption f servers may fail quorum system dissemination quorum system b d1 satisfied q intersect least f 1 elements d2 holds nf1e system nondominated strategy assigns equal probability quorum induces load 1 2 e system corollary 52 load fact load system 2 example 52 grid let universe arranged grid example 42 let n quorum system i2i dissemination quorum system b d1 holds since every pair quorums intersect least holds since choice f faulty elements grid f column remain available strategy assigns equal probability quorum induces load f2 n corollary 52 load system 2 example 53 partition suppose partition u example 43 collection nonempty sets following dissemination quorum system b i2i d1 satisfied intersection two quorums contains elements least two sets b d2 holds since intersects quorums q nondominated iff j strategy assigns equal probability quorum induces load 2k system regardless size 52 implies load system improved dissemination quorum system achieved forming grid construction example 52 superelements f achieving load 3 2k 2 52 opaque masking quorum systems masking quorums impose requirement clients know failprone system b may reasons clients required know first somewhat complicates clients read protocol second revealing failure scenarios system designed system also reveals failure scenarios vulnerable could exploited attacker guide active attack system revealing failprone system clients indeed giving client small fraction possible quorums system somewhat obscure though perhaps secure formal sense failure scenarios vulnerable especially absence client collusion section describe one way modify masking quorum definition section 4 opaque ie eliminate need clients know b absence client knowing b method aware client reduce set replies servers single reply service via voting ie choosing reply occurs often order reply correct one however must strengthen requirements quorum systems specifically suppose variable x written quorum q 1 subsequently x read quorum q 2 b set arbitrarily faulty servers set correct servers possess latest value x see figure 2 order client obtain value vote set must larger set faulty servers allowed respond ie since faulty servers team outofdate correct servers effort suppress write operation number correct uptodate servers reply must less number faulty outofdate servers reply ie definition 52 quorum system q opaque masking quorum system failprone system b following properties satisfied o2 figure 2 o1 o2 note o1 admits possibility equality size q 1 q 2 nb q 2 bq 2 nq 1 equality sufficient since case faulty servers team correct ofdate servers q 2 value returned q 1 higher timestamp returned q therefore case tie reader choose value higher timestamp interesting note strong inequality o1 would permit correct implementation singlereader singerwriter safe variable use timestamps taking majority value read operation difficult verify opaque masking quorum system enables client obtain correct answer service write operation implemented described section 1 read operation becomes read client read variable x queries server quorum q obtain set valuetimestamp pairs client chooses pair v appears often multiple values one highest timestamp value v result read operation opaque masking quorum systems combined access protocol described previously provide semantics regular masking quorum systems proof almost identical regular masking quorums lemma 53 read operation concurrent write operations returns value written last preceding write operation serialization preceding write operations give several examples opaque masking quorum systems opaque quorum systems describe properties refer system nondominated mean within class opaque quorum systems given failprone system b example 54 threshold suppose quorum system opaque quorum system b o1 satisfied q l n4fm l ngamma2fm similarly o2 satisfied o3 holds since 2n2fe q nondominated strategy assigns equal probability quorum induces load 1 2n2fe system corollary 42 implies load fact load system 2 next theorem proves resilience bound opaque quorum systems theorem 52 suppose fg exists opaque quorum system proof n 5f sufficient already proved example 51 suppose q opaque quorum system b fix q exists o3 note exists o3 therefore b 2 o1 1 2 therefore n 5f 2 example 55 partition suppose partition u b 1 3k choose collection sets fixed constant c 0 i2i opaque quorum system b o1 satisfied since q similarly o2 satisfied since finally o3 satisfied since quorums q nondominated iff strategy assigns equal probability quorum induces load 2k1 system regardless value c corollary 42 considering single element universe size 3k implies load system 2 unlike case regular masking quorum systems open problem find technique testing whether given failprone system b exists opaque quorum system b exhaustive search subsets 2 u constructions examples 53 54 55 resulting quorum systems exhibited loads best constant function n case masking quorum systems able exhibit quorum systems whose load decreased function n namely grid quorums natural question whether exists opaque quorum system failprone system b load decreases function n section answer question negative show lower bound 1of load opaque quorum system construction regardless failprone system theorem 53 load opaque quorum system least 1 proof o1 implies q let w strategy quorum system q fix q 1 2 q total load induced w elements q 1 l w must server q 1 suffers load least 1 present generic construction opaque quorum system increasingly large universe sizes n load tends 1 2 n grows 1 give construction primarily show lower bound 1is tight due requirement construction practical use coping byzantine failures example 56 suppose universe servers fg consider n theta n hadamard matrix h constructed recursively h property hh n theta n identity matrix using wellknown inductive arguments hal86 ch 14 shown first row column consist entirely gamma1s ii ith row ith column 2 1s n positions similarly gamma1s iii two rows two columns npositions ie 1s ncommon positions gamma1s ncommon positions treat rows h indicators subsets u let set defined ith row 1 n note q u 1 included q claim system opaque quorum system b using properties jq nfor 2 u exactly 2 sets q 4 o1 o2 requirements quickly verified load nngamma1 achieved eg strategy assigns equal probability quorum 2 6 faulty clients far concerned providing consistent service set correct clients section extend treatment address faulty clients addition faulty servers would required servers allowed act behalf clients since updates may generated faulty clients make assumption selfverifying data thus use masking construction slightly improves similar idea suggested us andrew odlyzko 2 common form hadamard matrices gamma1 times form use however relevant characteristics hadamard matrices invariant multiplication gamma1 quorum systems section 4 read write protocols focus ensuring consistency data stored replicated service seen correct clients since faulty client may complete write operation quorum servers may even write different values different servers section modify write protocol include update protocol implemented servers prevents clients leaving service inconsistent state update protocol could implemented using wellknown agreement protocols eg lsp82 bt85 given failprone system b property b 2 b size less ju j3 involving servers system describe two protocols correct failprone system b masking quorum exists involve quorum correct servers complete update operation explicitly treat load section latter property essential load measure defined useful write protocol section describes protocol clients write variable x replicated server replace write operation section 3 following procedure write client c write value v queries server quorum q obtain set valuetimestamp pairs chooses timestamp 2 c greater highest timestamp value greater timestamp chosen past performs initiateupdateq v note writing pair v quorum q performed executing operation initiateupdateq v servers execute corresponding events deliverupdatec v c client correct server executes deliverupdatec v 2 c greater timestamp currently stored variable server updates value variable timestamp v respectively regardless whether updates variable sends acknowledgment message c correctness protocol depends following relationships among initiateupdate executions clients deliverupdate events servers implement initiateupdate deliverupdate primitives satisfy relationships topic section c correct correct server executes deliverupdatec v c executed agreement correct server executes deliverupdatec v correct server executes propagation correct server executes deliverupdatec v eventually exists quorum every correct server q executes deliverupdatec v validity correct client c executes initiateupdateq v servers q correct eventually correct server executes deliverupdatec v note validity correct client executes initiateupdateq v q contains faulty server guarantee deliverupdatec v occur correct server ie write operation may effect correct server acknowledges deliverupdatec v execution described inform c deliverupdatec v indeed executed client receives acknowledgments set b servers 8b certain write applied correct servers quorum q propagation client receives acknowledgements set b servers must attempt operation different quorum m2 quorum correct servers exists moment thus repeatedly trying client eventually make progress cases client achieve progress incrementally accessing servers obtains acknowledgements quorum order argue correctness protocol adapt definition operation precedence allow behavior faulty client reason unclear define operation faulty client starts case read terminates client behave outside specification protocol simply say write operation writes v timestamp 2 c terminates correct servers quorum executed write operation op 2 operation read write executed correct client say op 1 precedes op 2 op 1 terminates starts real time correct client otherwise op 2 precede op 1 op 1 eventually terminates op 1 concurrent op 2 note definition operations precede operation involving faulty client every operation faulty client either precedes concurrent every operation given change definition proof similar lemma 41 suffices prove following lemma 61 correct process read operation concurrent write operations returns value written last preceding write operation serialization preceding write operations update operation without signatures remaining protocol describe update protocol masking quorum systems satisfies integrity agreement propagation validity first present update protocol use digital signatures protocol shown figure 3 lemma 62integrity c correct correct server executes deliverupdatec v c executed initiateupdateq v q proof first ready q c v message correct server sent receives echo q c v member q moreover correct member sends echo q c v receives update q v q c authenticated channel ie c executed initiateupdateq v 2 lemma 63agreement correct server executes deliverupdatec v correct server executes proof argued previous lemma correct server execute deliverupdatec v must sent servers q similarly echo q must sent servers q 0 since every two quorums intersect least one correct member since correct server sends echo c v one value v v must identical lemma 64 q masking quorum system universe u respect failprone system b 8q 2 q 1 client executes initiateupdateq v sends update q v member q 2 server receives update q v client c server previously received c message update q server sends echo q c v member q 3 server receives identical echo messages echo q c v every server q sends ready q c v member q 4 server receives identical ready messages ready q c v set b servers b sends ready q c v every member q done already 5 server receives identical ready messages ready q c v set q gamma servers b 2 b figure 3 update protocol use signatures proof assume otherwise contradiction ie m2 exists q thus contradicting m1 2 lemma 65propagation correct server executes deliverupdatec v eventually exists quorum q 2 q every correct server q executes deliverupdatec v proof according protocol correct server executed deliverupdatec v received message ready q c v server members correct every correct member q receives members lemma 64 ready messages b cause correct member q send ready message consequently deliverupdatec v executed correct members q 2 lemma 66validity correct client c executes initiateupdateq v servers q correct eventually correct server executes deliverupdatec v proof since client members q correct update q v received echoed every member q consequently servers q send ready q c v messages members q eventually execute deliverupdatec v 2 update operation signatures update protocol describe section requires server able digitally sign message party reliably authenticate message originated server even message received via untrusted intermediary digital signature algorithms wellknown eg rsa78 remainder section use u denote message signed server u use digital signatures results update protocol exchanges significantly less messages protocol figure 3 protocol shown figure 4 1 client executes initiateupdateq v sends update q v member q 2 server u receives update q v client c u previously received c message update q echo q c v u c 3 client c receives echo q c v u every member q sends fecho q c v u g u2q member q 4 server u 2 q receives fecho q c v u g u2q executes deliverupdatec v sends fecho q c v u g u2q member q already done figure 4 update protocol uses signatures lemma 67integrity c correct correct server executes deliverupdatec v c executed initiateupdateq v q proof correct server execute deliverupdatec v must receive fecho q c v u g u2q quorum q correct server u 2 q sends echo q c v u receiving update q v c authenticated channel ie c executed initiateupdateq v tlemma 68agreement correct server executes deliverupdatec v correct server executes proof argued previous lemma correct server execute deliverupdatec v must sent u 2 q similarly echo q must sent u 2 q 0 since every two quorums intersect least one correct member since correct server u sends echo c v u one value v v must identical v 0 2 lemma 69propagation correct server executes deliverupdatec v eventually exists quorum q 2 q every correct server q executes deliverupdatec v proof correct server executed deliverupdatec v received fecho q c v u g u2q quorum q forwarding servers q step 4 protocol cause correct servers q execute deliverupdatec v 2 lemma 610validity correct client c executes initiateupdateq v servers q correct eventually correct server executes deliverupdatec v proof since client members q correct update q v received echoed every member q client forward echos members q hence member q execute deliverupdatec v 2 conclusions literature contains abundance protocols use quorums accessing replicated data approach appealing constructing replicated services allows increasing availability efficiency service maintaining consistency work extends successful approach environments servers clients service may deviate prescribed behavior arbitrary ways introduced new class quorum systems namely masking quorum systems devised protocols use quorums enhance availability systems prone byzantine failures also explored two variations quorum systems namely dissemination opaque masking quorums classes quorums provided various constructions analyzed load impose system work leaves number intriguing open challenges directions future work one characterize average performance quorum constructions load lessthanideal scenarios eg failures occur generally work described quorum systems uniform sense quorum possible read write operations practice may beneficial employ quorum systems distinguished read quorums write quorums consistency requirements imposed pairs consisting least one write quorum although seem improve lower bounds overall load achieved may allow greater flexibility trading availability reads writes acknowledgments grateful andrew odlyzko suggesting use hadamard matrices construct opaque masking quorum systems asymptotic load 1 also thank yehuda afek michael merritt helpful discussions rebecca wright many helpful comments earlier versions paper insightful comment rida bazzi led substantial improvement previous version paper r atomic snapshots shared memory bounded firstin firstenabledsolution lexclusion problem integrating security faulttolerant distributed databases efficient faulttolerant solution distributed mutual exclusion composite registers sharing memory robustly messagepassing systems concurrency control recovery database systems asynchronous consensus broadcast protocols grid protocol high performance scheme maintaining replicated data toward nonatomic era lexclusion test case bounded concurrent timestamp systems constructible maintaining availability partitioned replicated databases assign votes distributed system weighted voting replicated data quorumconsensus replication method abstract data types make replicated data secure bounded timestamps internet privacy enhanced mail hierarchical quorum consensus new algorithm managing replicated data optimal multiwrite multireader atomic register byzantine generals problem authentication distributed systems theory practice interprocess communication part ii algorithms coverings colorings hypergraphs share concurrent waitfree variables p n algorithm mutual exclusion decentralized systems tolerating failures continuousvalued sensors storage efficient secure replicated distributed databases load access control signatures via quorum secret sharing crumbling walls class high availability quorum systems efficient dispersal information security secure agreement protocols reliable atomic group multicast rampart distributing trust rampart toolkit securely replicate services method obtaining digital signatures publickey cryp tosystems share secret implementing faulttolerant services using state machine approach tutorial spx global authentication using public key certificates majority consensus approach concurrency control multiple copy databases randomized byzantine agreement tr assign votes distributed system quorumconsensus replication method abstract data types efficient dispersal information security load balancing fault tolerance toward nonatomic era lexclusion test case maintaining availability partitioned replicated databases bounded concurrrent timestamp systems constructible integrating security faulttolerant distributed databases efficient faulttolerant solution distributed mutual exclusion bound firstin firstenabled solution 1exclusion problem optimal multiwriter multireader atomic register authentication distributed systems atomic snapshots shared memory inlineequation f radrcdnrcdradf inlineequation algorithm mutual exclusion decentralized systems share concurrent waitfree variables access control signatures via quorum secret sharing byzantine quorum systems load availability byzantine quorum systems synchronous byzantine quorum systems probabilistic quorum systems probabilistic byzantine quorum systems load capacity availability quorum systems combinatorial theory 2nd ed majority consensus approach concurrency control multiple copy databases share secret method obtaining digital signatures publickey cryptosystems storage efficient secure replicated distributed databases grid protocol make replicated data secure weighted voting replicated data survivable consensus objects secure scalable replication phalanx ctr evelyn pierce lorenzo alvisi framework semantic reasoning byzantine quorum systems proceedings twentieth annual acm symposium principles distributed computing p317319 august 2001 newport rhode island united states rodrigo rodrigues barbara liskov brief announcement reconfigurable byzantinefaulttolerant atomic memory proceedings twentythird annual acm symposium principles distributed computing july 2528 2004 st johns newfoundland canada tatsuhiro tsuchiya tohru kikuno byzantine quorum systems maximum availabililty information processing letters v83 n2 p7177 31 july 2002 yuanbo guo jianfeng practical secret sharing scheme realizing generalized adversary structure journal computer science technology v19 n4 p564569 july 2004 ittai abraham gregory chockler idit keidar dahlia malkhi waitfree regular storage byzantine components information processing letters v101 n2 p6065 january 2007 rida bazzi access cost asynchronous byzantine quorum systems distributed computing v14 n1 p4148 january 2001 dahlia malkhi michael merritt ohad rodeh secure reliable multicast protocols wan distributed computing v13 n1 p1928 january 2000 rida bazzi synchronous byzantine quorum systems distributed computing v13 n1 p4552 january 2000 thomas moscibroda stefan schmid roger wattenhofer selfish meets evil byzantine players virus inoculation game proceedings twentyfifth annual acm symposium principles distributed computing july 2326 2006 denver colorado usa fred b schneider lidong zhou implementing trustworthy services using replicated state machines ieee security privacy v3 n5 p3443 september 2005 alysson neves bessani joni da silva fraga lau cheuk lung bts byzantine faulttolerant tuple space proceedings 2006 acm symposium applied computing april 2327 2006 dijon france lorenzo alvisi dahlia malkhi evelyn pierce michael k reiter fault detection byzantine quorum systems ieee transactions parallel distributed systems v12 n9 p9961007 september 2001 rachid guerraoui marko vukoli fast robust read proceedings twentyfifth annual acm symposium principles distributed computing july 2326 2006 denver colorado usa dahlia malkhi yishay mansour michael k reiter diffusion without false rumors propagating updates byzantine environment theoretical computer science v299 n13 p289306 bryan parno mema roussopoulos defending p2p digital preservation system ieee transactions dependable secure computing v1 n4 p209222 october 2004 hyunyoung lee jennifer l welch randomized registers iterative algorithms distributed computing v17 n3 p209221 march 2005 petros maniatis david h rosenthal mema roussopoulos mary baker tj giuli yanto muliadi preserving peer replicas ratelimited sampled voting proceedings nineteenth acm symposium operating systems principles october 1922 2003 bolton landing ny usa lidong zhou fred b schneider robbert van renesse apss proactive secret sharing asynchronous systems acm transactions information system security tissec v8 n3 p259286 august 2005 michael abdelmalek gregory r ganger garth r goodson michael k reiter jay j wylie faultscalable byzantine faulttolerant services acm sigops operating systems review v39 n5 december 2005 dahlia malkhi michael k reiter architecture survivable coordination large distributed systems ieee transactions knowledge data engineering v12 n2 p187202 march 2000 ittai abraham dahlia malkhi probabilistic quorums dynamic systems distributed computing v18 n2 p113124 december 2005 petros maniatis mema roussopoulos j giuli david h rosenthal mary baker lockss peertopeer digital preservation system acm transactions computer systems tocs v23 n1 p250 february 2005 michael marsh fred b schneider codex robust secure secret distribution system ieee transactions dependable secure computing v1 n1 p3447 january 2004 j giuli petros maniatis mary baker david h rosenthal mema roussopoulos attrition defenses peertopeer digital preservation system proceedings usenix annual technical conference 2005 usenix annual technical conference p1212 april 1015 2005 anaheim ca miguel correia nuno ferreira neves lau cheuk lung paulo verssimo wormit wormholebased intrusiontolerant group communication system journal systems software v80 n2 p178197 february 2007 dahlia malkhi michael k reiter avishai wool rebecca n wright probabilistic quorum systems information computation v170 n2 p184206 november 1 2001 meng yu peng liu wanyu zang specifying using intrusion masking models process distributed operations journal computer security v13 n4 p623658 july 2005 jian yin jeanphilippe martin arun venkataramani lorenzo alvisi mike dahlin separating agreement execution byzantine fault tolerant services proceedings nineteenth acm symposium operating systems principles october 1922 2003 bolton landing ny usa amitanand aiyer lorenzo alvisi allen clement mike dahlin jeanphilippe martin carl porth bar fault tolerance cooperative services acm sigops operating systems review v39 n5 december 2005 miguel castro barbara liskov practical byzantine fault tolerance proactive recovery acm transactions computer systems tocs v20 n4 p398461 november 2002 lidong zhou fred b schneider robbert van renesse coca secure distributed online certification authority acm transactions computer systems tocs v20 n4 p329368 november 2002
enforceable security policies precise characterization given class security policies enforceable mechanisms work monitoring system execution automata introduced specifying exactly class security policies techniques enforce security policies specified automata also discussed b introduction security policy defines execution one reason another deemed unacceptable example security policy might concern access control restrict operations principals perform objects ffl information flow restrict things principals infer objects observing aspects system behavior ffl availability prohibit principal denied use resource result execution principals supported part arparadc grant f306029610317 afosr grant f496209410198 views conclusions contained herein author interpreted necessarily representing official policies endorsements either expressed implied organizations us government date generalpurpose security policies like attracted attention applicationdependent specialpurpose security policies increasingly important system support mobile code like java 5 might prevent information leakage enforcing security policy bars messages sent files read support electronic commerce security policy might prohibit executions customer pays service seller provide service finally electronic storage retrieval intellectual property governed complicated rightsmanagement schemes restrict use stored materials also use derivatives 17 practicality security policy depends whether policy enforceable cost paper address questions class enforcement mechanisms call em work monitoring target system terminating execution violate security policy enforced class em includes security kernels reference monitors operating system hardwarebased enforcement mechanisms appeared literature thus understanding cannot accomplished using mechanisms em value excluded em mechanisms use information available monitoring execution target system therefore compilers theoremprovers analyze static representation target system deduce information possible executions excluded em availability information possible target system executions gives power enforcement mechanismjust much power open question also excluded em mechanisms modify target system executing presumably modified target system would equivalent original except satisfies security policy interest definition equivalent needed order analyze class mechanisms proceed follows x2 precise characterization given security policies enforced using mechanisms em automatabased formalism specifying security policies subject x3 mechanisms em enforcing security policies specified automata described x4 next x5 discusses pragmatic issues related specifying enforcing security policies well application enforcement mechanisms safetycritical systems 2 characteristics em enforcement mechanisms formally represent executions finite infinite sequences psi set possible sequences 1 thus target system defines subset sigma psi security policy predicate sets executions target system satisfies security policy p p sigma equals true notice sets sigma pi executions require sigma satisfies p pi ae sigma holds pi satisfies p imposing requirement security policies would disqualify many useful candidates instance requirement would preclude information flow defined informally x1 considered security policyset psi executions satisfies information flow subset pi containing executions value variable x execution correlated value say particular execution known pi value variable x reveals information value definition enforcement mechanisms em work monitoring execution target system thus security policy p enforced using mechanism em must equivalent predicate form p predicate executions b p formalizes criteria used enforcement mechanism deciding terminate execution would otherwise violate policy enforced 1 set executions defined checking execution individually called property using terminology conclude 1 security policy must characterize sets properties order policy enforcement mechanism em every security policy characterizes sets properties predicates sets executions cannot put form 1 cannot defined terms criteria individual executions must satisfy isolation example information flow policy discussed characterizes sets properties proved 11 whether information flows x given execution depends part values takes possible executions whether values correlated value x predicate characterize sets executions cannot constructed using predicates defined single executions 1 manner executions represented irrelevant finite infinite sequences atomic actions higherlevel system steps program states stateaction pairs plausible alternatives enforcement mechanisms em cannot base decisions possible future execution since information definition available mechanisms em restricts security policies enforced mechanisms em particular consider security policy p 1 suppose prefix execution 0 b enforcement mechanism p must prohibit even though extension 0 satisfies b otherwise execution target system might terminate extended 0 enforcement mechanism would failed enforce p formalize requirement follows oe finite infinite execution steps finite execution let oei denote prefix oe involving first steps oe denote execution followed execution oe define pi gamma set finite prefixes elements set pi requirement concerning execution prefixes violating b policy p defined 1 p oe 2 finally note execution rejected enforcement mechanism must rejected finite period formalized policies satisfying 2 3 satisfied sets safety properties 7 class properties stipulate bad thing happens execution formally property defined 8 safety property finite infinite execution oe oe holds means safety property characterized set finite executions excluded therefore prefix execution clearly security policy p satisfying 2 3 set finite prefixesthe set prefixes 2 psi gamma b holdsso p satisfied sets safety properties according 4 analysis enforcement mechanisms em established unenforceable security policy sets executions characterized security policy p safety properties enforcement mechanism em exist p obviously contrapositive holds well em enforcement mechanisms enforce safety properties discussed x4 conversethat safety properties em enforcement mechanismsdoes hold revisiting three applicationindependent security policies described x1 find ffl access control defines safety properties set proscribed partial executions contains partial executions ending unacceptable operation invoked ffl information flow define sets properties argued define sets safety properties safety properties enforcement mechanisms em exactly policy 2 ffl availability defines sets properties safety properties particular partial execution extended way allows principal access resource availability lacks defining set proscribed partial executions every safety property must thus enforcement mechanisms em availabilityat least policy defined x1 3 3 security automata enforcement mechanisms em work terminating targetsystem execution seeing finite prefix oe b poe holds predicate b defined policy enforced established x2 set executions satisfying b also must safety property constraints b p conclude recognizers sets 2 mechanisms em purporting prevent information flow enforcing security policy implies equivalent absence information flow given security policies p q p q holds mechanism enforces suffice enforcing q exist security policies imply restrictions information flow define sets safety properties however policy p implies q might rule executions violate q using stronger policy without adverse consequences 3 alternative formulations availability characterize sets safety properties example one principal cannot denied use resource steps result execution principals defining set partial executions contains intervals exceed steps principal denied use resource fileread fileread send figure 1 send f ileread executions safety properties serve basis enforcement mechanisms em class automata recognizing safety properties defined named 2 shall refer recognizers security automata similar ordinary nondeterministic finitestate automata 6 formally security automaton defined finite set q automaton states set q 0 q initial automaton states countable set input symbols transition function dictated security policy enforced symbols might correspond system states atomic actions higherlevel actions sys tem stateaction pairs addition symbols might also encode information pastfor safety properties transition function require information process sequence 1 input symbols automaton starts current state set equal q 0 reads sequence one symbol time symbol read automaton changes current state set q 0 set q 00 automaton states ever q 00 empty input rejected otherwise input accepted notice acceptance criterion means security automaton accept sequences infinite length well finite length aprin obj oper figure 2 access control figure 1 depicts security automaton security policy prohibits execution send operations f ileread executed automatons states represented two nodes labeled q nfr file read q fr file read initial states automaton represented figure unlabeled incoming edges automaton state initial automaton state figure transition function specified terms edges labeled transition predicates booleanvalued effectively computable total functions domain let ij denote predicate labels edge node q node q j security automaton upon reading input symbol q 0 current state set changes current state set figure transition predicate fileread assumed satisfied system execution steps file read operations transition predicate send assumed satisfied system execution steps messagesend operations since transition defined q fr input symbols corresponding messagesend execution steps security automaton figure 1 rejects inputs message sent file read another example security automaton given figure 2 different instantiations transition predicate aprin obj oper allow automaton specify either discretionary access control 9 mandatory access control 3 discretionary access control policy prohibits operations according access control matrix specifically given access control matrix principal p rin permitted policy execute operation oper involving object obj oper 2 p rin obj holds specify policy using automaton figure 2 transition predicate aprin obj oper would instantiated mandatory access control policy prohibits execution operations according partially ordered set security labels associated system objects information objects assigned higher labels permitted read stored objects assigned lower labels example systems objects might assigned labels set ftopsecret secret sensitive unclassifiedg ordered according topsecret secret sensitive unclassified suppose two system operations supportedread write mandatory access control policy might restrict execution operations according principal p label p permitted execute readf reads file f label f p f holds ii principal p label p permitted execute writef writes file f label f f p holds specify policy using automaton figure 2 transition predicate aprin obj oper instantiated final illustration security automata turn electronic com merce might example desire serviceprovider prevented engaging actions delivering service customer paid requirement security policy formalized terms following predicates executions represented sequences operations payc figure 3 security automaton fair transaction customer c requests pays service customer c rendered service security policy interest proscribes executions serviceprovider executes operation satisfy servec engaged operation satisfies payc security automaton policy given figure 3 notice security automaton figure 3 stipulate payment guarantees service security policy specifies limits serviceprovider customer made payment partic ular security policy specified allows serviceprovider stop executing ie stop producing input symbols rather rendering paid service impose stronger security policy service guaranteed payment safety propertythere defining set proscribed partial executionsand therefore according x2 enforceable using mechanism em 4 using security automata enforcement security automaton serve basis enforcement mechanism class em follows step target system next take represented input symbol sent implementation security automaton automaton make transition input symbol target system allowed perform step automaton state changed according transition predicates ii automaton cannot make transition input symbol target system terminated fact security policy enforceable using mechanism em enforced using securityautomaton implementation safety properties specifications security automata unenforceable security policy x2 implies em enforcement mechanisms enforce safety properties consequently understanding limitations securityautomata enforcement mechanisms gain insight limitations enforcement mechanisms class em implicit ii assumption target system terminated enforcement mechanism specifically assume enforcement mechanism sufficient control target system stop automaton input symbols produced control requirement subtle makes certain security policieseven though characterize sets safety propertiesunenforceable using mechanisms em example consider following variation availability x1 realtime availability one principal cannot denied use resource seconds sets satisfying realtime availability safety propertiesthe bad thing interval execution spanning seconds principal denied resource input symbols security automaton realtime availability must therefore encode time however passage time cannot stopped target system realtime clocks cannot prevented continuing produce input symbols realtime availability simply cannot enforced using one automatabased enforcement mechanisms target systems lack necessary controls since mechanisms em powerful conclude realtime availability cannot enforced using mechanism em two mechanisms involved securityautomaton implementation enforcement mechanism automaton input read mechanism determine input symbol produced target system forward symbol security automaton automaton transition mechanism determine whether security automaton make transition given input perform transition aggregate cost quite high example automatons input symbols set program states transition predicates arbitrary state predicates new input symbol produced machinelanguage instruction target system executes enforcement mechanism must invoked every targetsystem instruction however security policies target systems production input symbols coincides occurrences hardware traps automatabased enforcement mechanism supported quite cheaply incorporating traphandler one example implementing enforcement mechanism access control policies systemsupported objects like files target systems production input symbols coincides invocations system operations hence production input symbols coincides occurrences systemcall traps second example exploiting hardware traps arises implementing memory protection memory protection implements discretionary access control operations read write execute access control matrix tells processes access region memory security automaton figure 2 specifies security policy notice security automaton expects input symbol memory reference input symbols cause change security automatons state input symbols cause automaton state transitions need forwarded automaton justifies following optimization automaton input read automaton input read optimization input symbols forwarded security automaton state automaton transition would transition given optimization production automaton input symbols memory protection made coincide occurrences traps target systems memoryprotection hardwarebasebounds registers page segment tablesis initialized trap occurs input symbol forwarded memory protection automaton memory references cause traps never cause state transition undefined transition automaton inexpensive implementation automatabased enforcement mechanisms also possible programs executed softwareimplemented virtual machine sometimes known reference monitor virtual machine instructionprocessing cycle augmented produces input symbols makes automaton transitions according either internal externally specified security automaton example java virtual machine10 could easily augmented implement automaton input read automaton transition mechanisms input symbols correspond method invocations beyond class em enforcement mechanisms overhead enforcement sometimes reduced merging enforcement mechanism target system one scheme recently attracted attention softwarebased fault isolation sfi also known sandboxing 19 16 sfi implements memory protection specified onestate automaton like figure 2 without hardware assistance instead program edited executed edited programs run target system usually object code edited edits insert instructions check andor modify values operands illegal memory references never attempted sfi class em sfi involves modifying target sys tem modifications permitted enforcement mechanisms em viewed framework inserted instructions sfi seen implement automaton input read copying code automaton transition inline target system instruction produces input symbol notice nothing prevents sfi approach used multistate automata thereby enforcing security policy specified security automaton moreover program optimizer able simplify inserted code eliminate useless portions 4 although introduces second type program analysis sfi requires putting trust automated program analysis tools finally need runtime enforcement mechanism target system analyzed proved violate security policy interest approach employed security policy like sfi originally intended addressa policy specified onestate security automatain proof carrying code pcc 13 pcc proof supplied along program proof comes form checked mechanically running program security policy violated program executed accompanying proof checked found correct original formulation pcc required proofs constructed hand restriction relaxed ulfar erlingsson cornell implemented system exactly java virtual machine intel x86 machine language certain security policies specified onestate security automata compiler automatically produce pcc programs written highlevel typesafe programming languages12 14 extend pcc security policies specified arbitrary security automata method needed extract proof obligations establishing program satisfies property given automaton method existit described 2 utility formalism partly depends ease objects formalism read written users formalism must able translate informal requirements objects formalism security automata establishing correspondence transition predicates informal requirements system behavior crucial require detailed understanding target system automaton figure 1 example captures informal requirement messages sent file read impossible send message unless transition predicate send true impossible read file unless transition predicate f ileread true might many ways send messagessome obvious others buried deep within bowels target system must identified included definition send similar obligation accompanies transition predicate f ileread general problem establishing correspondence informal requirements purported formalization requirements new software engineers usual solution analyze formalization alert inconsistencies results analysis informal requirements might use formal logic derive consequences formalization might use partial evaluation analyze formalization implies one another scenario form testing might manually automatically transform formalization prototype observe behavior various scenarios success proving testing prototyping way gain confidence formalization depends upon two things first decide aspects formalization check largely independent formalism second means checks depends formalism largely determines usability formalism proving require logic whose language includes formalism testing require means evaluating formalization one another scenario prototyping must way transform formalization computational form happens rich set analytical tools exist security au tomata security automata class buchi automata 4 buchi automata widely used computeraided program verification tools existing formal methods based either model checking theorem proving employed analyze security policy specified security automaton testing prototyping security policy specified security automaton matter running automaton guidelines structuring security automata real system security policies best given collections simpler policies single large monolithic policy difficult comprehend systems security policy result composing simpler policies collection taking conjunction employ separation concerns security policies specified security automata must able compose security automata analogous fashion given collection security automata must able construct single conjunction security automaton conjunction security policies specified automata collection construction difficult execution rejected conjunction security automaton rejected automaton collection beyond comprehensibility advantages specifying system security policies collections security automata first collection allows different enforcement mechanisms used different automata hence different security policies collection second security policies specified distinct automata enforced distinct system components something attractive security automatons input symbols correspond events single system compo nent benefits accrue source automatons input symbols single component include ffl enforcement components security policy involves trusting component ffl overhead enforcement mechanism lower communication components reduced example security policy distributed system might specified giving separate security automaton system host host would implement automaton input read automaton transitions mechanisms security automata concerning host designer security automaton often must choose encoding securityrelevant information target systems state automaton state larger automata usually complicated hence difficult understand often lead expensive enforcement mechanisms example generalization sfi involves modifying target system inserting code employing program optimizer simplify result inserted code simulates security automaton code smaller security automaton smaller cheaper execute easier optimize similarly generalization pcc proof obligations derived according 2 fewer simpler security automata smaller however conjecture cost executing reference monitor implements automaton transition probably insensitive whether securityrelevant state information stored target system automaton states predicates must evaluated two implementations differ whether state component associated security automaton target system cost reading state information evaluating predicates similar application safetycritical systems idea security kernels might application safetycritical systems eloquently justified 15 continues interest researchers 18 safetycritical systems concerned enforcing properties safety properties sense 8 natural expect enforcement mechanism safety properties application class systems see impediments using security automata securityautomata based enforcement mechanisms enforcing safety properties safetycritical systems justification given 15 using security kernels safetycritical systems involves characterization types properties enforced security kernel paper 15 concludes safety properties liveness properties enforceable however arguments given 15 informal coupled semantics kernelsupported operations essential attributes enforceability isolate formalize equations 1 2 3 neither identified shown imply safety properties enforced addition 15 concerns kernelized systems notion property restricted sequences kernelprovided functions allowing security automata arbitrary sets input symbols results seen generalizing 15 generalization useful one applies enforcement mechanisms part kernel thus extend central thesis 15 kernelized systems application beyond implementing security policies justify use enforcement mechanisms em building safetycritical systems acknowledgments grateful robbert van renesse greg morrisett ulfar erlingsson yaron minsky lidong zhou helpful feedback use implementation security automata comments previous drafts paper helpful comments earlier draft paper also provided earl boebert li gong robert grimm keith marzullo john rushby john mclean served valuable sounding board ideas developed feedback martin abadi helped sharpen formalism university tromso hospitable setting compelling excuse performing work reported herein r defining liveness recognizing safety liveness secure computer systems mathematical foundations java security present near future formal languages relation automata proving correctness multiprocess programs logical foundation java virtual machine specification general theory composition trace sets closed selective interleaving functions ml typed assembly language kernels safety tool constructing safe extensible c letting loose light igniting commerce electronic publication enforcement software safety policies efficient softwarebased fault isolation tr note denialofservice operating systems distributed systems methods tools specification advanced course verifying temporal properties without temporal logic diamond security policy objectoriented databases partial evaluation automatic program generation efficient softwarebased fault isolation proofcarrying code system f typed assembly language design implementation certifying compiler historybased access control mobile code sasi enforcement security policies guarded commands nondeterminacy formal derivation programs providing policyneutral transparent access control extensible systems automata languages machines java virtual machine specification java security authorization distributed systems general theory composition trace sets closed selective interleaving functions logical language expressing authorizations ctr james ezick resolving applying constraint queries contextsensitive analyses proceedings acmsigplansigsoft workshop program analysis software tools engineering june 0708 2004 washington dc usa scott ch huang kia makki niki pissinou optimizing compatible security policies wireless networks eurasip journal wireless communications networking v2006 n2 p7171 april 2006 alan shieh dan williams emin gn sirer fred b schneider nexus new operating system trustworthy computing proceedings twentieth acm symposium operating systems principles october 2326 2005 brighton united kingdom gary mcgraw greg morrisett attacking malicious code report infosec research council ieee software v17 n5 p3341 september 2000 krzysztof brzezinski norbert malinski reference specification issues online verification passive testing proceedings 24th iasted international conference parallel distributed computing networks p186191 february 1416 2006 innsbruck austria jacob zimmermann george mohay distributed intrusion detection clusters based noninterference proceedings 2006 australasian workshops grid computing eresearch p8995 january 1619 2006 hobart tasmania australia vir v phoha amit u nadgar asok ray shashi phoha supervisory control software systems ieee transactions computers v53 n9 p11871199 september 2004 dries vanoverberghe frank piessens supporting security monitoraware development proceedings third international workshop software engineering secure systems p2 may 2026 2007 massimo bartoletti pierpaolo degano gian luigi ferrari policy framings access control proceedings 2005 workshop issues theory security p511 january 1011 2005 long beach california r sekar c r ramakrishnan v ramakrishnan smolka modelcarrying code mcc new paradigm mobilecode security proceedings 2001 workshop new security paradigms september 1013 2001 cloudcroft new mexico prasad naldurg roy h campbell dynamic access control preserving safety trust network defense operations proceedings eighth acm symposium access control models technologies june 0203 2003 como italy j j whitmore method designing secure solutions ibm systems journal v40 n3 p747768 march 2001 zaid dwaikat francesco parisipresicce risky trust riskbased analysis software systems acm sigsoft software engineering notes v30 n4 july 2005 fabio martinell ilaria matteucci modeling synthesis security automata electronic notes theoretical computer science entcs 179 p3146 july 2007 arie orlovsky danny raz decentralized enforcement security policies distributed computational systems proceedings 2007 acm symposium applied computing march 1115 2007 seoul korea shin nakajima tetsuo tamai formal specification analysis jaas framework proceedings 2006 international workshop software engineering secure systems may 2021 2006 shanghai china dachuan yu ajay chander nayeem islam igor serikov javascript instrumentation browser security acm sigplan notices v42 n1 january 2007 lujo bauer jay ligatti david walker composing security policies polymer acm sigplan notices v40 n6 june 2005 vijay v raghavan toward integrative model applicationsoftware security practicing software engineering 21st century idea group publishing hershey pa mark reith jianwei niu william h winsborough engineering trust management software models proceedings international workshop modeling software engineering p9 may 2026 2007 franois siewe antonio cau hussein zedan compositional framework access control policies enforcement proceedings acm workshop formal methods security engineering p3242 october 30 2003 washington dc claudio bettini sushil jajodia x sean wang duminda wijesekera provisions obligations policy management security applications proceedings 28th international conference large data bases p502513 august 2023 2002 hong kong china galen c hunt james r larus david tarditi ted wobber broad new os research challenges opportunities proceedings 10th conference hot topics operating systems p1515 june 1215 2005 santa fe nm douglas r smith requirement enforcement transformation automata proceedings 6th workshop foundations aspectoriented languages p514 march 1313 2007 vancouver british columbia canada frdric besson thomas de grenier de latour thomas jensen secure calling contexts stack inspection proceedings 4th acm sigplan international conference principles practice declarative programming p7687 october 0608 2002 pittsburgh pa usa panagiotis manolios richard trefler latticetheoretic characterization safety liveness proceedings twentysecond annual symposium principles distributed computing p325333 july 1316 2003 boston massachusetts joel coburn srivaths ravi anand raghunathan srimat chakradhar seca securityenhanced communication architecture proceedings 2005 international conference compilers architectures synthesis embedded systems september 2427 2005 san francisco california usa david wagner paolo soto mimicry attacks hostbased intrusion detection systems proceedings 9th acm conference computer communications security november 1822 2002 washington dc usa stephen mccamant michael ernst simulationbased proof technique dynamic information flow proceedings 2007 workshop programming languages analysis security june 1414 2007 san diego california usa fabio martinelli ilaria matteucci approach specification verification synthesis secure systems electronic notes theoretical computer science entcs 168 p2943 february 2007 k altisen f maraninchi stauch aspectoriented programming reactive systems larissa proposal synchronous framework science computer programming v63 n3 p297320 15 december 2006 anderson santana de oliveira rewritingbased access control policies electronic notes theoretical computer science entcs v171 n4 p5972 july 2007 michael mcdougall rajeev alur carl gunter modelbased approach integrating security policies embedded devices proceedings 4th acm international conference embedded software september 2729 2004 pisa italy martin sulzmann rzvan voicu languagebased program verification via expressive types electronic notes theoretical computer science entcs v174 n7 p129147 june 2007 anish arora marvin theimer modeling tolerating incorrect software journal high speed networks v14 n2 p109134 april 2005 christian skalka trace effects object orientation proceedings 7th acm sigplan international conference principles practice declarative programming p139150 july 1113 2005 lisbon portugal arnab ray security check formal yet practical framework secure software architecture proceedings workshop new security paradigms august 1821 2003 ascona switzerland patrick cousot radhia cousot systematic design program transformation frameworks abstract interpretation acm sigplan notices v37 n1 p178190 jan 2002 karl krukow mogens nielsen vladimiro sassone framework concrete reputationsystems applications historybased access control proceedings 12th acm conference computer communications security november 0711 2005 alexandria va usa kevin w hamlen greg morrisett fred b schneider computability classes enforcement mechanisms acm transactions programming languages systems toplas v28 n1 p175205 january 2006 ian welch robert j stroud using reflection mechanism enforcing security policies compiled code journal computer security v10 n4 p399432 december 2002 tom chothia dominic duggan capability passing processes science computer programming v66 n3 p184204 may 2007 james rose nikhil swamy michael hicks dynamic inference polymorphic lock types science computer programming v58 n3 p366383 december 2005 kevin w hamlen greg morrisett fred b schneider certified inlined reference monitoring net proceedings 2006 workshop programming languages analysis security june 1010 2006 ottawa ontario canada thomas ball sriram k rajamani ilaria matteucci automated synthesis enforcing mechanisms security properties timed setting electronic notes theoretical computer science entcs 186 p101120 july 2007 trent jaeger reiner sailer yogesh sreenivasan managing risk covert information flows virtual machine systems proceedings 12th acm symposium access control models technologies june 2022 2007 sophia antipolis france david brumley dawn song privtrans automatically partitioning programs privilege separation proceedings 13th conference usenix security symposium p55 august 0913 2004 san diego ca therrezinha fernandes jules desharnais describing data flow analysis techniques kleene algebra science computer programming v65 n2 p173194 march 2007 f huang c b jay b skillicorn adaptiveness welltyped java bytecode verification proceedings 2006 conference center advanced studies collaborative research october 1619 2006 toronto ontario canada franois pottier christian skalka scott smith systematic approach static access control acm transactions programming languages systems toplas v27 n2 p344382 march 2005 shihchien chou providing flexible access control information flow control model journal systems software v73 n3 p425439 novemberdecember 2004 r sekar vn venkatakrishnan samik basu sandeep bhatkar daniel c duvarney modelcarrying code practical approach safe execution untrusted applications proceedings nineteenth acm symposium operating systems principles october 1922 2003 bolton landing ny usa shihchien chou chinyi chang information flow control model c applications based access control lists journal systems software v78 n1 p84100 october 2005 ran shaham eran yahav elliot k kolodner mooly sagiv establishing local temporal heap safety properties applications compiletime memory management science computer programming v58 n12 p264289 october 2005 david basin ernstruediger olderog paul e sevinc specifying analyzing security automata using cspoz proceedings 2nd acm symposium information computer communications security march 2022 2007 singapore charles e phillips jr tc ting steven demurjian information sharing security dynamic coalitions proceedings seventh acm symposium access control models technologies june 0304 2002 monterey california usa frdric besson thomas de grenier delatour thomas jensen interfaces stack inspection journal functional programming v15 n2 p179217 march 2005 shihchien chou embedding rolebased access control model objectoriented systems protect privacy journal systems software v71 n12 p143161 april 2004 gianluigi ferrari eugenio moggi rosario pugliese metaklaim type safe multistage language global computing mathematical structures computer science v14 n3 p367395 june 2004 steve zdancewic lantian zheng nathaniel nystrom andrew c myers untrusted hosts confidentiality secure program partitioning acm sigops operating systems review v35 n5 dec 2001 philip w l fong reasoning safety properties jvmlike environment science computer programming v67 n23 p278300 july 2007 thomas ball ella bounimova byron cook vladimir levin jakob lichtenberg con mcgarvey bohus ondrusek sriram k rajamani abdullah ustuner thorough static analysis device drivers acm sigops operating systems review v40 n4 october 2006 susan j chinburg ramesh sharda mark weiser establishing business value network security using analytical hierarchy process creating business value information technology challenges solutions idea group publishing hershey pa david walker karl crary greg morrisett typed memory management via static capabilities acm transactions programming languages systems toplas v22 n4 p701771 july 2000 peter thiemann program specialization execution monitoring journal functional programming v13 n3 p573600 may robert grimm brian n bershad separating access control policy enforcement functionality extensible systems acm transactions computer systems tocs v19 n1 p3670 feb 2001 yaowen huang fang yu christian hang chunghung tsai dertsai lee syyen kuo securing web application code static analysis runtime protection proceedings 13th international conference world wide web may 1720 2004 new york ny usa
umlbased integration testing increasing numbers software developers using unified modeling language uml associated visual modeling tools basis design implementation distributed componentbased applications time necessary test components especially unit integration testingat siemens corporate research addressed issue testing components integrating test generation test execution technology commercial uml modeling tools rational rose goal designbased testing environment order generate test cases automatically developers first define dynamic behavior components via uml statecharts specify interactions amongst finally annotate test requirements test cases derived annotated statecharts using test generation engine executed help test execution tool latter tool developed specifically interfacing components based comdcom corba middlewarein paper present approach modeling components interactions describe test cases derived component models executed verify conformant behavior outline implementation strategy tnt environment use evaluate approach means simple example b figure 1 alternating bit protocol example example figure 1 represents alternating bit communication protocol2 four separate components timer transmitter comch communication channel receiver several internal well external interfaces stimuli protocol unidirectional reliable communication protocol user invokes transmitter component send data messages communication channel receiver component passes another user communication channel lose data messages well acknowledgements reliable data connection implemented observing possible timeout conditions repeatedly sending messages necessary ensuring correct order messages 21 uml statecharts unified modeling language uml generalpurpose visual modeling language used specify visualize construct document artifacts software system paper focus dynamic views uml particular statechart diagrams statechart used describe dynamic behavior component say object time modeling lifecycle key elements described statechart states transitions events actions states transitions define possible states changes state object achieve lifetime state changes occur reactions events received objects interfaces actions correspond internal external method callsthe nomenclature paper refers uml revision 13 2 name alternating bit protocol stems message sequence numbering technique used recognize missing redundant messages keep correct order figure 2 illustrates statechart transmitter object shown figure 1 comprises six states start end state transitions labeled call event descriptions corresponding external stimuli received tuser interface internal stimuli sent timer component via timing interface received comch component via txport interface internalexternal interfaces components shown figure 1 moreover nomenclature used labeling transitions described next section relates way component interactions modeled tusermsg txportack timing canceltuserack txportdata0timingstart timingtimeout txportdata1timingstart txportack timingcanceltuserack tusermsg figure 2 statechart diagram transmitter object 22 communicating statecharts following section describe developer would need model communication multiple statecharts using commercial umlbased modeling tool present uml provide adequate mechanism describing communication two components adopted concepts csp communicating sequential processes 6 enhance existing notation 221 communication semantics approach wanted select communication semantics closely relate way comdcom corba components interact current systems components allow synchronous asynchronous communications focus synchronous mechanism purposes paper addition two types synchronous communication mechanisms first shared global event model may broadcast single event multiple components waiting receive act upon unison second model pointtopoint blocking communication mechanism send single event one component two components synchronized originator event halts execution blocks receiver obtains event pointtopoint model adopted closely resembles communication semantics comdcom corba 222 transition labeling order show explicit component connections associate operations interfaces events within respective statecharts defined transition labeling convention based notation used csp communication operations3 unique name must assigned developer connection two communicating statecharts4 name used prefix trigger incoming send outgoing events transition label statechart would defined follows timingtimeout txportdata0 transition label interpreted receiving trigger event timeout connection timing followed send event data0 sent connection txport trigger also known receive events identified separating question mark whereas send events identified leading caret existing uml notation separating exclamation mark figure 3 two dark arrows indicate timing interface two components used send receive events connections considered bidirectional although possible use different connection names direction direction needs emphasized transitions contain multiple send receive events multiple receive events within transition label specified separating plus sign multiple send events different event names specified separating colon 223 example figure 3 shows two communicating statecharts transmitter timer components labels transitions statechart refer events occurring via internal timing interface interface txport comch component two external interfaces timer tuser figure 3 communicating transmitter timer components transmitter component starts execution state idle0 waits user input message arrives connection tuser state changes preparesend0 message sent communication channel time timer component receives start event component 3 csp operations written channel1event1 means event1 sent via channel1 machine input operation written channel2event1 channel2 receives event1 4 currently limitation tool implementation state messagesent0 waits either timer component sends timeout event comch component sends message acknowledgement ack case timeout message sent timer also started ack received event sent timer component cancel timer user gets acknowledgement successful delivery message steps may repeated different message sequence number expressed event data1 instead data0 addition modeling respective statecharts defining interactions developers specify test requirements directives test generation influence size complexity resulting test suite however aspect shown example 3 establishing global behavioral model following section describe steps taken constructing global behavioral model internal tool multiple statecharts defined developer using commercial umlbased modeling tool global behavioral model significant properties behavior individual state machines preserved 31 definition subsystems prime concern respect construction global model scalability apart utilizing efficient algorithms compute global model defined mechanism whereby developers group components subsystems thus help reduce size given model benefit subsystem definition also reflects commonly used integration testing strategy described section 4 approach allows developers specify subsystem components tested interfaces tested subsystem definition specified developer modeled components interfaces considered part global model 32 composing statecharts 321 finite state machines consider statecharts mealy finite state machines react upon input form receive events produce output form send events state machines define directed graph nodes representing states edges representing transitions one initial state possibly several final states state transitions described function communicating finite state machine used component specification defined s0 f set states unique state machine states marked intermediate states alphabet valid transition annotations consisting transition type connection name event name transition function describing transitions states s0 initial state f set final states initial final states regular states initial state gives starting point behavior description final states express possible end points execution component transition annotations contain transition type well connection name event name transition types internal send receive communication transitions type send receive external events sent received external interface components state machine send receive transitions define external behavior component relevant external behavior observed internal transition equivalent transition empty transition finite state machine 7 triggered external event observable behavior represents arbitrary internal action communication transitions special types internal transitions representing interaction two state machines behavior externally observable composing state machines matching pairs send receive transitions equal connection event names merged form communication transitions example transitions highlighted dark arrows figure 3 would candidates definition state machine allows transitions contain single actions every action expressed transition annotation interpreted atomic action component interaction occur action several actions grouped together without possibility interruption states transitions marked intermediate states intermediate states introduced logically group substructures states transitions semantics intermediate states provide behavioral description mechanism similar microsteps atomic actions separated multiple consecutive steps microsteps always executed one run microsteps outgoing transitions intermediate states technique used approach part process converting uml statecharts internal representation result set normalized state machines idle tusermsg timing preparesendcancel timingstart gotack timingtimeout txportdata0 txportack messagesent figure 4 normalized transmitter component figure 4 shows state machine simplified version transmitter object two additional intermediate states timeron gotack inserted separate multiple events txportdata0timingstart txportacktimingcancel preparesend messagesent idle states shown figure 2 322 composed state machines composed state machine considered product multiple state machines state machine dynamic behavior constituents would react generate output result stimulated events specified respective state machines based definition finite state machine structure composed state machine defined follows 2 s02 sf2 two state machines s1 composed state machine c ab following formal definition connections b matching events t1 t2 generated 1 2 state machine composition schema example global state ab defined twotuple s1 s2 s1 state s2 state b two states referred part states initial state final states ab element subset product possible transition annotations composed union t1 t2 new communication transitions result matching transitions excluded transitions describe possible matches either communication transitions created omitted communication possible 323 composition method basic approach composing two state machines generate product state machine applying generative multiplication rules states transitions leads large overhead many unreachable states produced removed later steps resulting product uses resources necessary well computation time generation minimization instead approach incorporates incremental composition reduction algorithm uses reachability computations global behavioral model created stepwise beginning global initial state reachable states transitions computed every state composed state machine evaluated due reachability algorithm intermediate data structures time larger result one composition step states transitions within composed state machines redundant terms external observation removed applying reduction algorithm using heuristic rules possible detect redundancies reduce size composed state machine next composition step defined subsystems processed independently sequentially subsystem composition algorithm applied inputs composition algorithm data structures representing normalized communicating state machines specified components within current subsystem connection structure components part data structures order composition steps determines size complexity result next step therefore effectiveness whole algorithm worst case intermediate composition products composition two components interaction maximum possible number states transitions created case resembles product two state machines therefore important select suitable component next composition step minimal requirement selected component common interface component means least one connection exists existing previously calculated composed state machine better strategy respect minimizing size intermediate results select state machine highest relative number communication relationships interaction points suitable selection norm ratio possible communication transitions transitions state machine component highest ratio exposes extensive interface existing state machine selected table computing successor states transitions incremental composition reduction method also specifies composition schema every combination outgoing transitions part states decision table shown table 1 used compute new transitions composed state machine new transition leads global state part existing structure composed state machine added unmarked list transition added global model exceptions exist part states marked intermediate every reachable global state processed every possible new global transition inserted composed state machine algorithm terminates unmarked states remain means every reachable global state inserted model later processed schema used based composition schema developed sabnani et al 16 enhanced include extensions connections communication transitions intermediate states assuming throughout composition process individual well composed state machines deterministic behavior also ensure execution order component actions sequential important wish use global model create test cases dependent certain flow events actions want generate linear sequential test cases given subsystem 324 complexity analysis composing product two state machines worst case complexity would on2 assuming n number states state machine however approach often much better due application heuristic reduction rules help minimize overall size global model composition maintain observational equivalence 11 typically reduction algorithm used linear complexity respect number states 16 example reported algorithm applied complex communication protocol isdn q931 shown instead generating 60000 intermediate states composition reduction algorithm kept size model approximately 1000 intermediate states similar results reported use algorithm systems algorithm typically resulted reduction number intermediate states one two orders magnitude 325 example taking normalized state machine transmitter component figure 4 timer component figure 3 composition algorithm needs perform one iteration generate global behavioral model figure 5 global initial state idlestopped created using initial states two state machines state added list unmarked states composition schema applied every state within list generate new global states transitions list empty reachability algorithm creates global state machine comprising six states seven transitions three communication transitions generated identified hash mark transition label showing communication connection event example shows application decision table first global state idlestopped part state idle outgoing receive transition preparesend using external connection part state stopped also outgoing receive transition running connection component according decision rule 4 table transition external connection inserted composed state machine transition ignored new global receive transition leads global state preparesendstop next step part states include transitions use internal connections communicate via connection timing event matching transitions according decision rule 1 table communication transition included composed state machine leads global state timeronrunning rules applied repeatedly global states covered tusermsg timingcancel timingstart timeronrunning timingtimeout messagesentrunning txportack timerexttimeout gotackrunning messagesenttimeout figure 5 global behavioral model transmittertimer subsystem 4 test generation execution preceding sections discussed approach modeling individual collections components using uml statecharts establishing global behavioral model composed statecharts section show model used basis automatic test generation execution unit integration testing 41 unit integration testing designing coding software component developers perform unit testing ensure component correctly implements design ready integrated system components type testing performed isolation components relies heavily design implementation test drivers test stubs new test drivers stubs developed validate components system unit testing concluded individual components collated integrated system validated using yet another set test drivers level testing new set custom test drivers required stimulate components component may behaved correctly unit testing may interacting components therefore objective integration testing ensure components interact interface correctly interface mismatches commonly referred bottomup integration testing approach aims minimizing testing costs time effort associated initially developing customized test drivers test stubs test cases well repeatedly adapting rerunning regression testing purposes level integration 42 test generation proceeding description test generation execution steps would like emphasize following approach generates set conformance tests test cases ensure compliance design specification resulting implementation assumed implementation behaves deterministic externally controllable way otherwise generated test cases may produce incorrect results 421 categorypartition method test generation use test development environment tde product developed siemens corporate research 1 tde processes test design written test specification language tsl language based categorypartition method identifies behavioral equivalence classes within structure system test category partition defined specifying possible data choices represent choices either data values references categories partitions combination data values may string literals representing fragments test scripts code case definitions later form contents test case tsl test design created global behavioral model mapping states transitions tsl categories partitions choices states equivalence classes therefore represented partitions transition state represented choice categorypartition partitions used equivalence class definitions paths state machine limited certain outgoing transitions state would case using category transition defines choice current state combining test data string send receive event annotations reference next state final state defines choice empty test data string 422 generation procedure recursive directed graph built tde root categorypartition contains different paths choices plain data choices graph may contain cycles depending choice definitions equivalent graph global state machine test frame test case one instance initial data category partition one possible path root leaf potentially infinite reachability tree graph instantiation category partition random selection choice possible set choices defined categorypartition case category choice selected every instantiation test frame restricts branching possibilities graph partition however new choice selected random every new instantiation allows full branching within graph significantly influences test data generation contents test case consist data values associated edges along path graph 423 coverage requirements tsl language provides two types coverage requirements generative requirements control test cases instantiated generative test requirements defined test frames created example coverage statements defined categories partitions choices constraining requirements cause tde omit certain generated test cases example maximum coverage definitions rulebased constraints categorypartition instantiation combinations instantiation preconditions instantiation depth limitations test requirements defined globally within tsl test design attached individual categories partitions choices tde creates test cases order satisfy specified coverage requirements input sequences subsystem equivalent paths within global behavioral model represents subsystem starting initial states receive transitions events external connections stimulate subsystem send transitions events external connections define resulting output observed test execution tool communication performed events unit test purposes default coverage criterion transitions within statechart must traversed least integration testing transitions involve component interactions exercised subsystem components defined part modeling process coverage requirements formulated ensure interfaces transitions tested 424 example figure 6 presents test case derived global behavioral model shown figure 5 one test case sufficient exercise interfaces txport tuser timer defined components line generic test case format represents either input event expected output event chose test case format stimulating events expected responses use strings send receive respectively followed connection event names currently events parameters remedied future work figure test case transmittertimer subsystem sequence diagrams execution test case shown figure 7 note external connection timer possible event exttimeout event allows timeout triggered without real hardware timer available receive user msg start data0 msg ackack data0 ackcancel successful transmission receive user msg start data0 msg ack ack exttimeout data0 timeout data0 cancelack b timed transmission figure 7 sequence diagrams example 43 test execution section show generated test cases mapped comcorba programming model describe executable test driver including stubs generated test cases seen earlier test case consists sequence send receive events following intent send event stimulate object test connection tuser mapped object reference stored variable tuser defined test case5 event msg mapped method call object referenced tuser receive event represents response object test received appropriate sink object connection txport mapped object reference stored variable txport event data0 mapped callback object test fires event calling back sink object identified variable txport sink object thus acts stub object would implement txport interface next higher layer software 5 current implementation tnt initialization code instantiates transmitter object stores object reference variable tuser written manually typically reactive software components expose interface allows interested parties subscribe event notification6 layer x1 test driver sink 1 msg txport txport layer x tuser tuser 2 data0 transmitter figure 8 interaction object test interactions test execution environment transmitter object shown figure 8 testdriver calls method msg transmitter object referenced variable tuser transmitter object notifies sink object via outgoing txport interface test case execution involving receive events requires comparison outparameters return values expected values also evaluation event patterns event patterns specify events expected response particular stimuli expected respond accomplish sink objects associated test cases need monitored see required sink methods invoked 5 implementation tnt tnt environment developed siemens corporate research order realize work described designbased testing environment consists two tools existing test generation tool tde extensions uml tdeuml tecs test execution tool thus name tnt new environment interfaces directly uml modeling tools rose2000 rose realtime 60 rational software figure 9 shows test case generation initiated within rational rose section briefly describe implementation strategy 51 tdeuml figure depicts class diagram tdeuml tdeuml accesses rose applications microsoft com interfaces fact application implements com server com component waiting events implemented tdeuml java using microsofts visual j generate java classes given com interface class interface rose object model thus represented java class data types converted consistent rose applications export administrative objects well model objects represent underlying rose repository rose also provides extensibility interface rei integrate external tools known addins new tool tdeuml installed within rose application addin invoked via rose tool menu upon invocation current rose object model imported including necessaryin current implementation tnt initialization code instantiating sink object registering transmitter component written manually statecharts processed using techniques described previous sections files needed test generation test execution generated figure 9 generating tests within rational rose figure 10 class diagram tdeuml 52 tecs test environment distributed componentbased software tecs specifically addresses test execution test generation method described section 42 support components communicating synchronously tecs already supports synchronous asynchronous communication7 test environment specifically designed testing com corba components unit integration testing current version tecs supports testing com components used part tnt environment standalone tool includes following featureswith asynchronous communication component test send response events sink object time thread test harness library c framework provides basic infrastructure creating executable test drivers test case compiler used generate test cases c test case definition one illustrated figure 6 generated test cases closely cooperate test harness library regular c compiler used create executable test driver generated code test harness library generated test drivers com components exposing interfaces defined tecs environment used generate c sink classes idl interface definition file generated sink classes also closely cooperate test harness library test provides user means running test cases interactively graphical user interface batch mode information generated test execution written xmlbased tracefile test control center provides different views data trace view error list execution summary views easily defined writing additional xsl style sheets 6 evaluating example section describe evaluation approach using alternating bit protocol example discussed section 2 example comprises four components statechart connected using interfaces depicted figure 1 currently applying approach set products within different siemens business units results experimentation yet available aiming examine issues fault detection capabilities approach 611 component statistics table 2 shows number states transitions four statecharts imported tdeuml converted normalized global model composition steps described section 32 realize size components moderate use highlight number issues example normalized state machine component never twice size associated uml statechart table component statistics 612 defining integration test important decision developer choice appropriate integration test strategy assuming bottomup integration test strategy used developer may wish integrate transmitter timer components first followed receiver comch components afterwards two subsystems would grouped together form complete system case interface two subsystems txport would need tested show subsystem definitions chosen integration test strategy subsystem transmittertimer components transmitter subsystem comchreceiver components comch receiver subsystem abprotocol components transmitter timer comch interface txport 613 applying composition reduction step time taken import four statecharts well execution time composition algorithm negligible table 3 shows number statestransitions created composition step well values reduction step applied typically reduction algorithm applied composition step values italic show combinations components common interface numbers combinations high would expected combinations generally used intermediate steps values bold indicate number statestransitions used integration test strategy values show number statestransitions substantially reduced case four components evaluated together complete system table 3 size intermediate results example composing model without intermediate reduction steps instead reducing last composition step number states transitions reached difference however lies size intermediate results associated higher execution times case benefit applying reduction algorithm negligible due size example theoretically could lead significant difference execution time 614 generating executing test cases time taken generate test cases three subsystems example took less five seconds tdeuml generated total 7 test cases three subsystems one test case subsystem transmittertimer three test cases subsystem comchreceiver three test cases abprotocol contrast integration approach four components tested corresponding interfaces resulted total 4 tests case incremental integration test strategy resulted test cases generated bigbang approach smaller integration steps usually result stable system higher percentage detected errors examination generated test cases shows free redundancy multiple coverage communication transitions come relatively close optimum 7 related work years numerous papers dedicated subject test data generation 13813171921 moreover number tools developed use within academia commercial market approaches tools based different functional testing concepts different input languages graphical textual nature however received widespread acceptance software development community large number reasons first many methods tools required steep learning curve mathematical background second modeling larger systems beyond single components could supported theoretically practically third design notation would used basis test design often used particular application domain example sdl used predominantly telecommunications embedded systems domain however widespread acceptance use uml throughout software development community well availability suitable tools situation may change apart approach know one effort area offutt et al 12 present approach similar generate test cases uml statecharts however approach different focus examine different coverage requirements able generate tests single component furthermore automate test execution step order developers automatically generate execute tests addition specifically address problems issues associated modeling distributed componentbased systems 8 conclusion future work paper described approach aims minimizing testing costs time effort associated developing customized test drivers test cases validating distributed componentbased systems end describe realize test generation test execution technology integrate umlbased visual modeling tool show approach supports unit integration testing phases component development lifecycle applied com corbabased systems briefly outline implementation strategy evaluate approach using given example following paragraphs focus issues resulting work software systems especially embedded ones use asynchronous communication mechanisms message queuing shared global messages instead synchronous communication mechanism adopted approach asynchronous communication complex model requires modeling queued messages events furthermore communication buffers must included modeling composing dependent implementation size event queue limited mechanisms implemented detect overflow queues generating test cases asynchronously communicating systems complexity may quickly lead scalability problems would need examined addressed future work methods asynchronously communicating systems presented 59 20 component interaction modeled approach using event message exchange containing parameters values future work result modeling parameterized communication achieve model specification must enhanced annotations possible data values types well test requirements values tde allows test case generation using data variations samples possible range parameter values pre postconditions constrain valid data values constraints checked test execution extends error detecting possibilities uml allows users model statecharts hierarchical state machines concurrent states global behavioral model presented paper model components nested states hierarchical state machines internal data conditions state machines meaning global state machine variables influencing transition behavior supported concurrent states also supported yet future work hope support developer optimal integration test strategy examining type extent interactions components environment could provide suggestions developer order components need integrated could include analyses intermediate composition steps well initial graphical depiction systems interfaces approach could significantly influence effectiveness efficiency quality test design modeling realtime systems timing aspects constraints become essential future work hope analyze realtime modeling testing requirements instance test cases could annotated realtime constraints assertions postconditions within model could also contain information could checked test execution 9 acknowledgements would like thank tom murphy head software engineering department siemens corporate research well professor manfred broy heiko ltzbeyer technical university munich 10 r automatic generation test scripts formal test specifications reinhold testing refinements refining tests distributed component systems new computing model one test case generation asynchronously communicating state machines prentice hall introduction automata theory automatic generation test data kang enterprise java beans specification communication concurrency generating test cases uml specifications automatic test case data generator unified modeling language reference manual lapone aleta trace analysis component software case study statistical testing reuseable concurrent objects sahay p tr communicating sequential processes software testing techniques 2nd ed objectoriented modeling design communication concurrency predicatebased test generation computer programs component software unified modeling language reference manual computer system generating test data using domain strategy introduction automata theory languages computation case study statistical testing reusable concurrent objects testing refinements refining tests ctr kansomkeat wanchai rivepiboon automatedgenerating test case using uml statechart diagrams proceedings annual research conference south african institute computer scientists information technologists enablement technology p296300 september 1719 marlon vieira johanne leduc bill hasling rajesh subramanyan juergen kazmeier automation gui testing using modeldriven approach proceedings 2006 international workshop automation software test may 2323 2006 shanghai china mass soldal lund ketil stlen deriving tests uml 20 sequence diagrams neg assert proceedings 2006 international workshop automation software test may 2323 2006 shanghai china j jenny li david weiss howell yee codecoverage guided prioritized test generation information software technology v48 n12 p11871198 december 2006 mauro pezz michal young testing object oriented software proceedings 26th international conference software engineering p739740 may 2328 2004 andr l l de figueiredo wilkerson l andrade patrcia l machado generating interaction test cases mobile phone systems use case specifications acm sigsoft software engineering notes v31 n6 november 2006 dianxiang xu xudong generation test requirements aspectual use cases proceedings 3rd workshop testing aspectoriented programs p1722 march 1213 2007 vancouver british columbia canada hartman k nagin agedis tools model based testing acm sigsoft software engineering notes v29 n4 july 2004 p vr murthy p c anitha mahesh rajesh subramanyan test ready uml statechart models proceedings 2006 international workshop scenarios state machines models algorithms tools may 2727 2006 shanghai china g friedman hartman k nagin shiran projected state machine coverage software testing acm sigsoft software engineering notes v27 n4 july 2002 philip samuel rajib mall pratyush kanth automatic test case generation uml communication diagrams information software technology v49 n2 p158171 february 2007
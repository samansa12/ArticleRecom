dynamic verification c generic algorithms abstractdynamic verification new approach formal verification applicable generic algorithms found standard template library stl part draft ansiiso c standard library using behavioral abstraction symbolic execution techniques verifications carried abstract level results used variety instances generic algorithms without repeating proofs achieved substituting type parameters generic algorithms special data types model generic concepts accepting symbolic inputs deducing outputs using inference methods symbolic execution technique supports testing programs symbolic values abstract level formal verification also need generate multiple program execution paths use assertions handle loops example show achieved via directives conventional debugger program analysis database assertions must still supplied packaged separately evaluated needed appropriate transfers control orchestrated via debugger unlike previous verification methods dynamic verification method thus works without transform source code process special interpreters include example formal verification stl generic algorithm b introduction present new approach formal verification programs called dynamic verification application c templatebased generic algorithms whereas previous verification methods transform source code process special interpreters verification condition generator dynamic verification method able work directly original source code compiled conventional compiler method depends two key insights first rather viewing type parameters generic algorithms complication turn advantage substituting special data types called runtime analysis oracles raos 28 work symbolic inputs compute outputs using inference methods technique form symbolic execution supports testing symbolic values thereby covering large infinite sets inputs individual test set data types covered rao also infinite include data types nonisomorphic one type operator commutative another type operator noncommutative something needed however formal verificationthe ability control program execution paths use assertions function pre postconditions loop invariants brings us second key insight behind dynamic verification achieve necessary control via directives conventional debugging system assertions must still supplied packaged separately symbolically executed needed appropriate transfers control achieved setting breakpoints similarly use debugger commands help analysis database cause program execute multiple execution paths needed case analysis inductive proof methods briefly describe metalevel program analysis system melas supports dynamic verification method c templatebased generic algorithms melas extends conventional debugging system additional commands formal verification symbolic testing rapidprototyping using executable specifications since melas extension debugging tools many programmers already familiar applied selectively small program segments help achieve widespread use symbolic execution formal verification technology melas still development preliminary version sufficient capabilities formally verify simple generic algorithms taken directly ansiiso c standard template library stl 26 28 29 give one example paper relate experience examples many aspects dynamic verification method based part previous work execution formal specification abstract data types generic concepts axiomatic treatments imperative programming languages case adapt previous methods make possible use without transforming source code organize part symbolic execution method deals types library raos rao two distinct levels call interface level inference level structure similar larch specifications 6 31 major difference larch specifications executable requirement dynamic verification logical foundation way dynamic verification deals imperative program constructs eg assignment conditional loop statements based axioms inference rules similar spirit hoares axiomatic approach 7 different important details use hoare triples forwardassignment axiom justify way symbolic execution proceeds program statements normal forward order opposed backward order necessary usual assignment axiom hoares system 1 also treat loops differently hoares approach instead using loop invariant assertions use prepost conditions inference rule akin subgoal induction method 16 details formal foundation found 18 28 algorithms generic algorithms called generic expressed terms type function parameters instantiated many different ways produce different versions algorithms simple exampleone take detail laterconsider algorithm algorithm copies sequence values data structure locations another data structure range locations copied indicated stl objects called iterators generalization c pointers discuss actual stl algorithm later moment let us simplify matters somewhat considering version uses pointers source sequence indicated using two pointers first last pointing first location one beyond last location copied destination indicated single pointer result pointing first location values copied copy operation might coded template function c template class class u 1 although use symbolic execution software verification goes back earliest program verification systems 11 12 13 forward assignment axioms sometimes mentioned literature eg see 5 p 120 aware axiomatic system approach basis u copyt first last u r f last return result instances algorithm created using types u assignments operator defined right hand sides type left hand sides type u example int a100 double b100 code initialize array call 1 copy array array b call 2 shift a1a99 left one position copya1 call 3 shift b10b19 left ten positions call 4 copy a0a9 a10a19 based calls three different instances copy algorithm created c compiler type signatures double copyint int double int copyint int int double copydouble double double first instances used call 1 second calls 2 4 third call 3 instances legal c defines assignment int double viceversa following call might legal declaration class named x array 100 objects type x would allowed assignment type int values type x variables defined definition copy works parameters many different types actual definition copy used hewlettpackard implementation stl 27 even general template class inputiterator class outputiterator outputiterator copyinputiterator first inputiterator last outputiterator result first last return result instead pointer types u algorithm written terms types called inputiterator outputiterator version work must able obtain inputiterator operators first version namely disequality predicate incrementing dereferencing similarly outputiterator must able obtain operators u namely incrementing dereferencing moreover operators must certain semantic properties similar pointer types order algorithm work correctly pointer types required properties example calls previously given still work version many possible ways define types satisfy iterator type requirements example stl defines list iterators follow links linkedlist representation incremented copy list array example thus second version copy much generic first next section show formally capture represent semantic properties common data types used replace type parameters inputiterator outputiterator generic algorithm 3 overview tecton concept specifications tecton 8 9 10 specification language describing using abstract concepts formal software development hardware design one main goals tecton reduce need proof tecton achieves goal supporting behavioral abstraction data abstraction well using behavioral abstraction software hardware component purposely partially specified omitting irrelevant properties thus single tecton specification cover broad category components sharing set properties one proof abstract level tecton specification used variety instances without repeating proof basic unit tecton specification tecton concept description tecton concept description determines concept defined set manysorted algebras manysorted algebra pair hs fi ffl indexed family sets mapping collection sort names collection sets ffl f indexed family functions f mapping collection function descriptions collection functions constraint pair ffi f f ffi domain sorts 1 range sort r f function domain ss 1 tecton concept described series statements definition abbreviation extension realization lemma statement introduces refers concept name called subject concept definition concept description conceptname refinesclause usesclause refinesclause lists previouslydefined concepts definition extends new sorts operators properties usesclause lists previouslydefined concepts used definition without intent extend introducesclause list sorts andor functions introduced definition generatesclause limits set corresponding sort contain elements generated functions listed clause obeysclause list properties must satisfied algebras concept five clauses optional least one must present examples tecton concept definitions introduces bool true bool false bool generates bool freely using true false uses boolean introduces domain domain domain bool introduces domain domain domain obeys x z domain x refines uses clauses empty definition called simple concept definition algebra hs fi belongs concept denoted simple concept definition 1 sorts introduced belong domain 2 function descriptions introduced belong domain f 3 property obeys list true statement sets functions f 4 generates clause satisfied concept description inherits sorts functions properties concept descriptions listed refines uses clauses formally let c 1 concepts listed refines uses clauses concept description algebra fi belongs ds concept c x member intersection c 1 requirements regarded simple concept definition explanation kinds tecton statements see 8 abstract implementations unless contains generatesclause tecton concept definition necessarily define single abstract data type even set isomorphic abstract data types example concept definition associativebinaryop operation fully defined algebras operation defined obeying associative property included concept include algebra integers usual operation algebra character strings defined concatenation strings algebras isomorphic since first operation commutative second thus impossible implement tecton concept description programming language using conventional abstract data type definition mechanisms normal c classes without losing generality allow generic algorithm dynamically verified need construct special data types possess following properties ffl used compilation like normal data types replace type parameters generic algorithms ffl compiled program executed conventional program execution environ ment ffl values type represented symbolically relations computed inference mechanisms provide data types developed new implementation method called abstract implementation abstract implementation tecton concept description consists two layers interface data type written programming language sets rules representing tecton concepts call former runtime analysis oracle rao latter inference engine ie current implementation rao represented c class ie implemented prolog program set rules derived concept descriptions raos ies loosely connected messagepassing mechanism 41 inference engines inference engine ie computational system derives result inputs using logical reasoning maintains semantics symbolic values based constructive executable specifications consisting set axioms inference rules ies used paper derived way similar described 4 set tecton concept specifications necessarily constructive ie usually consists several parts interface set functions receive queries commands clients send results back clients commands usually translated database access functions access fact database fact database stores manages knowledge symbolic values form set constraints b b symbolic values knowledge fact database dynamically enhanced changed clients updating commands fact database also accessed inference rules derive new facts old inference rules separated clients interface may complex would obtained straightforward translation properties tecton specifications example consider following tecton definition specifies properties equality operator equality refines set obeys x z domain unlimited use last property transitivity result infinite loops break cycles corresponding prolog rules expressed using auxiliary list symbols already seen auxiliary function member checking membership list memberx x memberx memberx equality inference rules expressed prolog follows note operator means logical means representing true equaldx equaldy x equaldx equaldy x membery enough information representing unknown 2 possible outcomes rules shown allow derivation outcome possible additional rules disequalities 42 runtime analysis oracles inference engine cannot used directly data type instantiate c generic algorithm formal rules ies used c generic algorithms developed mechanism called runtime analysis oracles raos bind ies c generic algorithm verified rao c class interfaces data represented symbolic values functions operate symbolic values rely formal rulebased ies stateindependent symbolic computation make representation general easy manipulate represent data strings instance data rao total order concept implemented following class totalorder string v public totalorderconst string semantics symbolic values defined inference rules constraints values facts stored fact database ie rao functions usually partial defined basis formal rules ies rao translates function call queries ies combines answers back result function call example following definition operator total order rao comparison two objects rao translated ie answer queries ie total order concept bool operatorconst totalorder x const totalorder return ieanswerx ls mls ie answer also translates result ie back bool return value operator since data raos symbolic values semantics interpreted facts inference rules see section 41 meaning data easily changed altering set facts ies symbolic values weaker constraints cover larger state space programs thus posing weak initial constraints symbolic inputs algorithm analysis wide range execution paths covered however also means branching point execution path tree ies find enough facts fact database answer query handle situation rao must able determine ie enough facts answer query must obtain new facts process query facts obtained must added database later use two sources rao get additional facts first rao dynamically ask user decide answer second answers query separately generated case analysis approach keeping track possibilities missing facts analysis database 5 specification technique dynamic verification section describe specification technique developed dynamic verification allows specifications defined set highlevel formal rules yet also directly evaluated execution environment program verified dynamic verification system program segment specified describing precondition state postcondition state like larch specifications 6 31 specifications dynamic verification twotiered interface specifications consist assertions program states make one tier abstract concept specifications define semantics symbolic values primitive concepts assertions depend constitute tier major difference specification method dynamic verification larch goals larch mainly used system development static program analysis use specifications support dynamic program analysis thus specifications system executable larch make specifications executable interface specifications use constructs target language c whole specification template function packaged template class called specification class contains list variables called save list three functions precondition function postcondition function updating function many cases postcondition must refer state execution specified statements state afterwards save list specification class holds variables prior state postcondition refers precondition function two things called first saves current symbolic values variables save list second evaluates precondition specification postcondition function evaluates postcondition updating function key technique inductive verification also used fastprototyping specifications updates state executing specification instead original program segment note specification class written c one part entire specification template function primitive concepts relating symbolic values state assertions rely defined formal inference rules ies linked specification class raos example consider interface specification stl generic copy algorithm discussed introductory section call copyfirst last result copies sequence values range locations determined iterators first points first element last points one position past last element range begins location result points let rangefirst last denote sequence iterators first first 1 last 1 extend cc dereferencing operator rangefirst last means first first 1 last 1 rangeiterator rao whose symbolic values ranges iterators dereference values type similarly rangevaliterator rao corresponding type sequences values iterator values refer iterator parameters instantiated raos distance functions used specification defined axioms ies conventions write specification class copy follows include rangesh include rangevalh template class inputiterator class outputiterator class class copyspec rangevalt ssv inputiterator firstsv lastsv outputiterator resultsv public bool precondinputiterator first inputiterator last outputiterator result tmp1 tmp2 return true else return false outputiterator postupdateinputiterator first inputiterator last outputiterator result outputiterator resultitrplusdistancefirst last return result bool postcondinputiterator first inputiterator last outputiterator result outputiterator resultsvitrplusdistancefirstsv lastsv return isequalresult tmp rangeresultsv tmp ssv 6 melas system melas metalevel integrated analysis system developed analysis c templatebased generic algorithms allows users verify test fast prototype c generic programs metalevel directly different analysis methods even integrated used analysis session one part program analyzed one method another part analyzed another method melas consists control infrastructure coordinating analysis activities implemented top gnu cc debugging system gdb database managing analysis data controlling coverage analysis paths communication infrastructure linking ies raos verification testing generic algorithms carried fully automatically manually automatic analysis generic algorithm controlled gdb command script determines process analysis check specifications dynamically verify generic algorithm melas need embed main function compiled conventional compiler executable run debugging system main function generic algorithm called objects suitable raos example verify stl copy algorithm create following main function include prologagencyh include dbagenth include inputitrh rao input iterator properties include outputitrh rao output iterator properties include equalityh rao equalitydisequality properties include copyspech specification stl generic copy algorithm itype rao input iterators outputitrequality otype otype rao output iterators copyspecitype otype equality b instantiate copyspec create b use proof dbagent db database agent giving access analysis database include stlalgobaseh definition stl generic copy algorithm int main itype ff otype rr rptr program f l r rao objects symbolic values f f r respectively b objects copy spec specification class copy algorithm discuss usage section 62 object db allows melas access analysis database note template algorithm analysis copy need processed transformed included main function directly library prepost condition functions defined copy spec inserted called copy source code compiled linked environment main function called verification system via debugger 61 verification carry actual verification generic algorithm melas carry following process first start execution program melas weak constraints inputs initial constraints choose limited set execution paths next melas stops execution first line algorithm calls precondition function save values later use postcondition check condition true false verification attempt terminates true melas resumes execution stops last line algorithm melas calls postcondition function see postcondition true particular path taken algorithm verified otherwise one execution path within algorithm melas go every path user chooses analyze algorithm verified paths verified analyze multiple paths database system used organize assumptions along path assertion query sent inference engine ie returns unknown current path split two one branch takes assertion new assumption another takes negation assertion new assumption time user force program execute particular point along path flushing existing assumptions loading assumptions made along path point rerunning program description general details depend concrete language constructs used program segment example consider verification process loops constructs generally easier deal melas loop verified inductively inductive rule splits verification basis case inductive case cases verified loop verified details follows 1 start melas load analysis database generic algorithm verifica tion check database see paths waiting verified exit melas 2 execute program initial assumptions loaded fact database stop first line statement 3 call aprecond 2 save prestate whole loop evaluate precondition false verification attempt fails true continue execution unknown answer raos yesno questions make assumptions make precondition true usually one specification object enough saving states variables inductive verifications two objects specification class needed b 4 evaluation whileloop condition raos may ask user case analysis controller inputs complete evaluation different inputs may lead different paths 5 case false whileloop condition exit loop 6 check apostcond false loop verified true pass control case analysis controller check database another path waiting verification 7 paths verified run program go back beginning loop 8 evaluation whileloop condition step 3 true execute body loop stop first line loop check bprecond 3 save prestate values updating function specification 9 call bpost update using values saved update state program corresponds applying induction hypothesis 10 check apostcond false loop verified true loop verified 62 verification copy algorithm following transcript fully automatic verification stl generic copy algorithm given end section 2 recall algorithm taken directly hewlettpackard implementation stl four kinds prompts used melas msg iterator rao gdb text melas msg contains information hints analysis system following iterator rao yesno question asked rao direction melas prompt gdb users input gdb command start verification call gdb initialization file copygdbinit command script sets breakpoints copy copy spec source code avscsrpiedu gdb aout x copygdbinit q welcome melasgdb object b used avoid overwriting prestate saved breakpoint 1 file copyc line 24 breakpoint 2 file fs5grads6wangcstlalgobaseh line 146 breakpoint 3 file fs5grads6wangcstlalgobaseh line 148 breakpoint 4 file fs5grads6wangcstlalgobaseh line 146 breakpoint 5 file fs5grads6wangcstlalgobaseh line 147 gdb run starting program fs5grads6wangccopyaout breakpoint 1 main copyc24 melas always stops execution first line program allowing user set analysis methods breakpoint please specify name database usually main part source file name current analysis mode verification testing debugging set automanual mode finally type start continue default gdb start automatic verification chosen command start loads analysis database reading file studentsgrads6wangcrosedbdirectoryrose reading standard30 format done reading file studentsgrads6wangcrosedbdirectoryrose writing design directory file studentsgrads6wangcrosedbdirectoryrose reading file studentsgrads6wangcrosedbassumptionsrose reading standard30 format done reading file studentsgrads6wangcrosedbassumptionsrose database successfully loaded gdb command cont resumes execution program gdb cont continuing melas msg stop first line body copy melas msg check precondition copy calling melas msg set p0aprecondfirst last result melas msg precondition true melas checks precondition melas msg continue next state input iterator rao assumed f0 f0d melas resumes execution makes assumptions symbolic values automatically case assumes f0 f0d f0 f0d f0 symbolic iterator value symbolic integer value means source range copy algorithm empty thus basis case melas msg checking postcondition basis case melas msg set psapostcondfirst last result melas msg postcondition true melas checks postcondition basis case inductive verification begins verification next path melas msg begin analyze next path melas msg stop first line body copy melas msg check precondition copy calling melas msg set p0aprecondfirst last result melas msg precondition true melas msg continue next state input iterator rao assumed f0 f0d melas msg checking precondition inductive step inner melas msg set p0bprecondfirst last result melas msg precondition inductive step true melas checks precondition inductive step saves state specification object b melas msg apply lemma inductive step calling melas msg call bpostupdatefirst last result melas calls post update function state saved b melas msg check postcondition inductive step calling melas msg set ps2apostcondfirst last result melas msg postcondition true unanalyzed paths melas checks postcondition checks analysis database analysis path left thus inductive verification algorithm complete 7 conclusion presented new approach formal verification called dynamic verification application c templatebased generic algorithms method employs hoarestyle prepostcondition specifications symbolic execution based forward assignment axioms rather usual backward substitution whileloop inference rule based subgoal induction symbolic execution mechanism includes multiple runtime analysis oracles consists provides c interface one rulebased inference engines briefly described melas system supports dynamic verification method melas extends conventional debugging system additional commands formal veri fication normal symbolic testing rapidprototyping using executable specifications since melas extension debugging tools many programmers already familiar applied selectively small program segments assist achieving widespread use symbolic execution formal verification technology melas still development preliminary version sufficient capabilities formally verify simple generic algorithms taken directly ansiiso c standard template library one example generic copy algorithm discussed paper another stl generic adjacentfind algorithm searching sequence first pair adjacent equal elements interesting point adjacentfind correct originally specified 26 original specification said adjacentfind could used input iterators input iterators properties necessary correctness algorithm needs forward iterators input iterators additional properties error noticed corrected later versions 26 attempting use melas verify original version fails revised specification able complete proof third complex example 28 verified melas stl merge algorithm contains loop ifthenelse statement also makes two calls copy algorithm one nested argument list practice using one generic algorithm programming another typical stl leads reduced overall effort verifying algorithms example proof merge call copy dealt using postupdating function copy spec makes proof simpler copying written line loop would require specifications inductive proofs loop r selecta formal system testing debugging programs symbolic execution lclint tool using specifications check code using assertions declarative operational models automated debugging specifications preferably executable science programming et al larch languages tools formal spec ification axiomatic basis computer programming tecton framework specifying verifying generic system components tecton language manipulating generic objects overview tecton proof system new approach program testing application symbolic mathematical system program verification twodimensional pinpointing debugging formal specifications constructing automated testing oracle effort produce reliable software program verification subgoal induction ada generic library linear list processing packages basis formal specification verification generic algorithms c program verification based denotational semantics taos testing analysis oracle support practical approach programming assertions pvs specification language pvs proof checker reference manual draft specifying testing software components using adl standard template library integrating tools methods rigorous analysis c dynamic verification c generic compo nents practical method support system tr ctr douglas gregor sibylle schupp stllint lifting static checking languages libraries softwarepractice experience v36 n3 p225254 march 2006 stephen h edwards murali sitaraman bruce w weide joseph hollingsworth contractchecking wrappers c classes ieee transactions software engineering v30 n11 p794810 november 2004 antoy dick hamlet automatically checking implementation formal specification ieee transactions software engineering v26 n1 p5569 january 2000
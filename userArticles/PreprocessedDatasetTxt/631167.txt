guaranteeing realtime requirements resourcebased calibration periodic processes paper presents comprehensive design methodology guaranteeing endtoend requirements realtime systems applications structured set process components connected asynchronous channels endpoints systems external inputs outputs timing constraints postulated inputs outputs express properties endtoend propagation delay temporal inputsampling correlation allowable separation times updated output values automated design method works follows first new tasks created correlate related inputs optimization algorithm whose objective minimize cpu utilization transforms endtoend requirements set intermediate rate constraints tasks algorithm fails restructuring tool attempts eliminate bottlenecks transforming application resubmitted assignment algorithm final result schedulable set fully periodic tasks collaboratively maintain endtoend constraints b introduction realtime systems possess small handful inherent timing constraints make break correctness called endtoend constraints established systems external inputs outputs two examples 1 temperature updates rely pressure temperature readings correlated within 10ms 2 navigation coordinates updated minimum rate 40ms maximum rate 80ms endtoend timing parameters may indeed number maintaining functionally correct endtoend values may involve large set interacting components thus ensure endtoend constraints satisfied components turn subject intermediate timing constraints manner small handful endtoend constraints may even modest system yield great many intermediate constraints task imposing timing parameters functional components complex one mandates careful engineering consider example 2 avionics system naviga tion update may require inputs current heading airspeed pitch roll etc sampled within varying degrees accuracy moreover attributes used subsystems imposes tolerance delay possesses output rate navigation unit may outputs may delivered rates faster 40ms perhaps slower 80ms top subsystems may share limited computer resources good engineer balances factors performs extensive tradeoff analysis simulations sensitivity analysis proceeds assign constraints intermediate constraints inevitably conservative side moreover conveyed programmers terms constant values thus scenario like following often played design engineers mandate functional units b c execute periods 65ms 22ms 27ms respectively programmers code system find c grossly overutilizes cpu discover cs outputs read subsystems go back engineers negotiate new periods example 60ms 10ms 32ms process may continue many iterations system finally gets fabricated scenario due simple fact endtoend requirements allow many possibilities intermediate constraints engineers make consider rational selection however basis selection include rough notions software structuring scheduling policies many times hardware even fabricated point approach paper present alternative strategy maintains timing constraints endtoend form long possible design method iteratively instantiates intermediate constraints taking advantage leeway inherent endtoend constraints assignment algorithm fails produce full set intermediate constraints potential bottlenecks identified point application analysis tool takes determines potential solutions bottleneck possible restructures application avoid result resubmitted assignment algorithm domain applicability due complexity general problem paper place following restrictions applications handle restriction 1 assume applications possess three classes timing constraints call freshness correlation separation ffl freshness constraint sometimes called propagation delay bounds time takes data flow system example assume external output function system input x freshness relationship x might delivered time xvalue used compute sampled earlier gamma 10ms use following notation denote constraint f ffl correlation constraint limits maximum timeskew several inputs used produce output example x 1 x 2 used produce correlation relationship may delivered time x 1 x 2 values used compute sampled within 2ms denote constraint cy jx ffl separation constraint constrains jitter consecutive values single output say example delivered minimum rate 3ms maximum rate 13ms denoted ly constraint classification complete sufficiently powerful represent many timing properties one finds requirements document initial examples 1 2 correlation separation constraints respectively note single output 1 may either directly indirectly subject several interdependent constraints example 1 might require tightly correlated inputs may abide relatively lax freshness constraints however perhaps 1 also requires data intermediate subsystem turn shared highrate output 2 restriction 2 subsystems execute single cpu approach extended use distributed systems topic revisit section 7 sake presenting intermediate constraintassignment technique paper limit uniprocessor systems restriction 3 entityrelationships within subsystem already specified example highrate video stream passes monolithic computeintensive filter task situation may easily cause bottleneck algorithm fails find proper intermediate timing constraint filter restructuring tool attempt optimize much possible end however cannot redesign system finally stress offering completely automatic solution even fully periodic task model assigning periods intermediate components complex nonlinear optimization problem worst become combinatorially expensive software restructuring specific tactics used remove bottlenecks often require user interaction problem solution strategy duly note restrictions tackle intermediate constraintassignment problem rendered following ingredients ffl set external inputs fx g endtoend constraints ffl set intermediate component tasks f g ffl task graph denoting communication paths inputs tasks outputs solving problem requires setting timing constraints intermediate components endtoend constraints met moreover interval time utilization may never exceed 100 solution employs following ingredients 1 periodic preemptive tasking model algorithms duty assign rates 2 buffered asynchronous communication scheme allowing us keep ipc times 3 periodassignment optimization algorithm forms heart approach 4 softwarerestructuring tool takes periodassignment fails related work research large part inspired realtime transaction model proposed burns et al 3 model formulated express database applications easily incorporate variants freshness correlation constraints analogue freshness persistent object absolute consistency within corresponds realworld samples taken within maximum drift analogue correlation set data objects possesses relative consistency within sets elements sampled within interval time believe outputdriven applications variety address separation constraints also necessary without postulating minimum rate requirement freshness correlation constraints vacuously satisfied never outputting values thus separation constraints enforce systems progress time burns et al also propose method deriving intermediate constraints data model approach departure point highlevel requirements rewritten set constraints task periods deadlines transformed constraints hopefully solved big drawback however correlation freshness constraints inordinately tighten deadlines eg tasks inputs must correlated within tight degree accuracy say several nanoseconds tasks deadline tightened accordingly similar problems accrue freshness constraints net result may overconstrained system potentially unschedulable one approach different respect tightly correlated samples put emphasis simply getting data system passing due time however since turn causes many different samples flowing system varying rates perform traffic control via novel use virtual sequence numbering results significantly looser periods constrained mainly freshness separation requirements also present period assignment problem optimal though quite expensive worst case work also influenced jeffays realtime producerconsumer model 10 possesses taskgraph structure similar model rates chosen messages produced eventually consumed semantics leads tight coupling execution consumer producers thus seems difficult accommodate relative constraints based freshness klein et al surveys current engineering practice used developing industrial realtime systems 11 stressed intermediate constraints primarily function endtoend constraints possible take account sound realtime scheduling tech niques point however stateoftheart practice trial error guided engineering experience exactly problem address paper remainder paper organized follows section 2 introduce application model formally define problem section 3 show method transforming endtoend constraints intermediate constraints tasks section 4 describe constraintsolver detail push small example section 5 describe application transformer section 6 show executable application finally built problem description overview solution restate problem follows ffl given task graph endtoend timing constraints inputs outputs ffl derive periods offsets deadlines every task ffl endtoend requirements met section define terms present overview solution strategy 21 asynchronous task graph application rendered asynchronous task graph atg format given graph ie set tasks g set asynchronous buffered channels note external outputs inputs simply typed nodes theta p set directed edges e channel singlewritermultireader restriction following attributes period offset 0 denoting earliest starttime startofperiod deadline denoting latest finishtime relative startofperiod maximum execution time e interval constrains window w execution w note initially open variables get instantiated constraintsolver semantics atg follows whenever task executes reads data incoming channels j corresponding edges j writes channels l corresponding edges l actual ordering imposed reads writes inferred task reads writes channels asynchronous nonblocking writer always inserts value onto end channel reader many times read data location example perhaps writer runs period 20ms two readers running 120ms 40ms respectively first reader may use every sixth value neglect others whereas second reader may use every value scheme raises chicken egg issue one many faced work one objectives support software reuse functional components may deployed different systems timing parameters automatically calibrated physical limitations objective would hindered designer employ following tedious method 1 first run constraintsolver would find based results 2 handpatch modules specialized ipc code ensuring intermediate tasks correctly correlate input samples luckily atg semantics enables us automatically support process consider atg figure 1a whose node 4 blown figure 1b far programmer concerned task 4 yettobedetermined period 4 set asynchronous channels accessible via generic operations read write moreover channels treated unbounded nonblocking constraintassignment algorithm determines task rates postprocessing phase determines actual space required channel automatically implemented circular slotted buffers accomplished running awk script module instantiates read write operation select correct input value type scheme allows us minimize overhead incurred blocking communication used concentrate exclusively assignment problem fact show sequel communication completely unconditional even require short locking consistency however pay price avoiding overhead namely period assignments must ensure writer overtake reader currently accessing slot moreover note timing constraints define system driven time output quirements contrast reactive paradigms esterel 4 inputdriven analogous conceptually infinite buffering assumptions rate assignment algorithm assumes external inputs always fresh available derived inputsampling rates determine true requirements inputavailability since input x connected another atgs output requirements would imposed timing constraints d1 d2 6 f writey1 res figure 1 task graph b code 4 22 small example simple illustration consider system whose atg shown figure 1a system composed six interacting tasks three external inputs two external outputs applications characteristics follows freshness f 1 correlation separation max execution e times e system small serves illustrate several facets problem 1 may many possible choices rates task 2 correlation constraints may tight compared allowable endtoend delay 3 data streams may shared several outputs case originating x 2 4 outputs tightest separation constraints may incur highest executiontime costs case 1 exclusively requires 1 23 problem components guaranteeing endtoend constraints actually poses three subproblems define follows correctness let c set derived intermediate constraints e set endtoend constraints system behaviors satisfy c also satisfy e feasibility task executions inferred c never demand interval time utilization exceeds 100 schedulability scheduling algorithm efficiently maintain intermediate constraints c preserve feasibility problem address three issues cannot decoupled correctness example often treated verification problem using logic rtl 9 certainly given atg could formulate e rtl query whether constraint set satisfiable however yes answer would give us little insight finding good choice c must simple enough schedule case methods like modelchecking 1 etc could determine whether ce invariant respect system would posteriori solution assume already possess c hand system feasible may still schedulable known algorithm ie one efficiently managed realistic kernel paper put emphasis first two issues however also imposed task model greatest number efficient scheduling algorithms known simple periodic dispatching offsets deadlines essence restricting cs free variables ensure feasible solutions c easily checked schedulability problem scheduling set periodic realtime tasks single cpu studied many years task set dispatched calendarbased nonpreemptive schedule eg 16 17 18 preemptive staticpriority scheme eg 5 12 13 15 part results independent particular scheduling strategy used concert either nonpreemptive preemptive dispatching however sequel frequently assume underlying staticpriority architecture two reasons first straightforward priority assignment often capture atgs precedence relationships obviates need superfluous offset deadline variables thus space feasible solutions simplified turn reduces constraintsolvers work second prioritybased scheduling recently shown support atgs inherent timing requirements preperiod deadlines 2 precedence constrained subtasks 8 offsets 14 good overview static priority scheduling may found 5 24 overview solution solution carried fourstep process shown figure 2 step 1 intermediate constraints c derived postulates periods deadlines offsets free variables challenge balance several factors correctness feasibility simplicity failure constraint derivation asynchronous task graph constraints restructuring tool constraint satisfaction feasible task set buffer allocation final task set application structure endtoend constraints task libraries figure 2 overview approach require solution c enforce endtoend constraints e solution must also feasible time want keep c simple possible ensure finding solution relatively straightforward venture particularly important since feasibility criterion defined cpu utilization introduces nonlinearities constraint set balancing goals impose additional structure application eg creating new sampler tasks get tightly correlated inputs system step 2 constraintsolver finds solution c done several steps first c solved period variables resulting system solved offsets deadlines throughout process use several heuristics exploit atgs structure solution c cannot found problem often lies original design example perhaps single stateless server handles inputs multiple clients run wildly different rates step 3s restructuring tool helps programmer eliminate bottlenecks automatically replicating strategic parts atg step 4 derived rates used reserve memory channels instantiate read write operations example consider 4 figure 1b reads assume constraintsolver assigns 4 2 periods 30ms 10ms respectively 4 read operation 2 would replaced macro would read every third data item buffer would skip two harmonicity scheme works producer always ensure overtaking consumers consumers always determine data item correct one read example 4 job managing 2 easy since read every third item channel 4 another input channel 1 moreover temporally correlated samples two channels used produce result would happen solver assigned 1 period 30ms gave 2 period 7ms tasks scheduled ratemonotonic order 2 filled five times 4 first frame four times second frame etc fact since 7 relatively prime 4 selection logic correlate inputs would rather complicated one solution would timestamp input x 1 x 2 pass stamps along intermediate results would assume access precise hardware timer moreover timestamps multiple inputs would composed manner worst small data value eg integer would carry large amount reference information obvious solution one adopt ensure every chain possesses common base clockrate exactly rate task head chain words impose harmonicity constraint producer consumer pairs ie pairs edges p c definition 21 harmonicity task 2 harmonic respect task 1 2 exactly divisible 1 represented 2 jt 1 consider figure 1a three chains imposing harmonic relationships tightly coupled system 4 deriving constraints section show derivation process intermediate constraints conser vatively guarantee endtoend requirements start process synthesizing intermediate correlation constraints proceed treat freshness separation 31 synthesizing correlation constraints recall example task graph figure 3a three inputs sampled three separate tasks wish guarantee 1 sampling x 1 correctly correlated 2 sampling x 2 must pick short periods 1 2 indeed many practical realtime systems correlation requirements may well tight way proportion freshness constraints typically results periods get tightened exclusively accommodate correlation easily lead gross overutilization engineers often call problem oversampling somewhat misnomer since sampling rates may tuned expressly coordinating inputs instead problem arises poor coupling sampling computational activities thus approach decouple components much possible create specialized samplers related inputs given atg sampler derivation performed following manner integer d1 d2 6 dx1 dx2 dx3 d1 d2 6 figure 3 original task graph b transformed task graph foreach correlation constraint c l k jx l 1 create set inputoutput pairs associated c l ie foreach l foreach k theres common input x exist outputs chains x x j share common task foreach l identify associated sampling tasks ie js l j 1 create periodic sampler l take samples inputs l thus incoming channels inputs l tasks l intercepted new sampler task l returning original example repeat figure 3a since correlated inputs share center stream result single group correlated inputs g turn results formation single sampler assume low execution cost 1 new transformed graph shown right column figure 3b deadlineoffset requirements sampler l constrained following trivial relationship cor maximum allowable timedrift correlated inputs read l sampler tasks ensure correlated inputs read system within appropriate time bounds allows us solve process rates function freshness separation constraints vastly reduces search space however cannot ignore correlation altogether since merely sampling inputs time guarantee remain correlated pass system input samples may processed different streams running different rates thus may still reach join points different absolute times example refer back figure 3 f 2 disparity result underspecified system may tightened reason simple 6 period derived using correlation dominant metric resulting solution may violate tighter freshness constraints hand freshness dominant metric correlation constraints may achieved solve problem eliminating noise exists different set require ments thus whenever fresh output required ensure correlated data sets produce example leads tightening original freshness requirement f 2 jx 2 thus invoke technique general principle output correlated input sets associated freshness constraints adjusted accordingly 32 synthesizing freshness constraints consider freshness constraint f recall definition every output time value x used compute must read earlier time data flows task chain x task adds two types delay overhead datas endtoend response time one type execution time ie time required process data produce outputs etc paper assume maximum execution time fixed already optimized much possible good compiler type delay transmission latency imposed waits correlated inputs arrive processing transmission time fixed rather largely dependent derived processbased constraints thus minimizing transmission time goal achieving tight freshness constraints fortunately harmonicity relationship producers consumers allows us accomplish goal consider chain output task 1 input 1 2 3 1 harmonicity 2 2 precedence 1 oe 2 oe 3 3 chain size constraints figure 4 freshness constraints coupled tasks task harmonicity constraints get assuming tasks started time 0 whenever invocation output task n simultaneous invocations every task freshness chain consider figure 4 three tasks 1 2 3 freshness chain harmonicity assumption 3 jt 2 2 jt 1 constraints derived entire chain scenario within tasks minor frame input data gets read gets processed output data produced constraints worst case endtoend delay given freshness requirement guaranteed following holds note also require precedence producerconsumer task pair show figure 4 accomplished via offset deadline variables ie mandating approach following obvious drawback endtoend freshness f must divided fixed portions slack node global systemwide level type rigid flow control best solution clear distribute slack intermediate tasks without overconstraining system importantly rigid slack distribution table 1 constraints due freshness requirements consumer task would allowed execute offset even input data available 2 rather make straightforward priority assignment tasks chain let scheduler enforce precedence manner away intermediate deadline offset variables leads following rule thumb consumer task head tail chain precedence requirement deferred scheduler otherwise precedence requirement satisfied assignment offsets example consider freshness constraints example figure 3a f 1 15 requirement f 1 specifies chain window size 4 gamma 30 since 1 intermediate task precedence oe 1 handled scheduler however according rule thumb use offset 4 handle precedence 1 oe 4 leads constraints 1 4 similar inequalities derived remaining freshness constraints result shown table 1 33 output separation constraints consider separation constraints output generated task shown figure 5 window execution defined constrains time variability within period consider two frames execution widest separation two successive occur first frame starts early possible second starts late possible conversely opposite situation leads smallest separation thus separation constraints satisfied following holds true 2 note corresponding issues arise realtime ratecontrol highspeed networks latest latest earliest earliest figure 5 separation constraints two frames example consider constraints arise output separation requirements induced output tasks 4 6 derived constraints presented 34 execution constraints clearly task needs sufficient time execute simple fact imposes additional constraints ensure tasks maximum execution time fit window recall 1 use offset deadline period variables tasks handling external input output 2 use period variables precedence constraints intermediate constraints easily preserve restrictions dealing execution time external task following inequalities ensure windowsize sufficiently large cpu demand hand intermediate tasks handled imposing restrictions constituent chains single chain let e denote chains execution time head last intermediate task ie excluding outputting task chainwise execution constraints h e dm dm tm h heads offset dm tm last intermediate tasks deadline period respectively example revisiting example following executiontime constraints completes set taskwise constraints c imposed atg thus far shown one part problem c derived endtoend constraints endto requirements maintained runtime 1 solution c found 2 scheduler dispatches tasks according solutions periods offsets deadlines since many existing schedulers handle problem 2 turn attention problem 1 2 constraint solver constraint solver generates instantiations periods deadlines offsets addresses notion feasibility using objective functions 1 minimize overall system utilization 2 maximize window execution task unfortunately nonlinearities optimization criteria well harmonicity assumptions lead complex search problem present solution decomposes problem relatively tractable parts decomposition motivated fact nonlinear constraints confined period variables involve deadlines offsets suggests straightforward approach presented figure 6 1 entire constraint set c projected onto subspace c constraining 2 constraint set c optimized minimum utilization 3 since values instantiate original constraint set c forms new reduced set constraints c whose functions affine hence solutions found via linear optimization backedge figure 6 refers case nonlinear optimizer finds values corresponding solution exists hence new instantiation periods must obtained process continues either solution found possible values exhausted 41 elimination offset deadline variables use extension fourier variable elimination 6 simplify system constraints intu itively step may viewed projection n dimensional polytope described constraints onto lowerdimensional shadow nonlinear constraints linear constraints nonlinear constraints eliminate optimize wrt minu optimize wrt mind solution figure top level algorithm obtain task characteristics case ndimensional polytope object described initial constraint set c shadow subspace c free shadow derived eliminating one offset deadline variable time period variables remain stage new set constraints checked inconsistencies eg 0 5 situation means original system overspecified method terminates failure technique best illustrated small example consider following two inequalities w constraint defines line w 4 4 restricted nonzero solutions result 2dimensional polygon eliminating variable w 4 simple carried follows since searching integral nonzero solutions 4 integer considered candidate multiple constraints w 4 perhaps involving many variables figure 7 variable elimination integer solutions deviant case process used every constraint w 4 combined every constraint w 4 w 4 eliminated correctness method follows simply polytopes convexity ie original set constraints solution solution preserved shadow unfortunately opposite true hence requirement backedge figure 6 stated refined constraint set c may possess solution correspond integralvalued situation occasionally arises quest integer solutions essential preserving harmonicity assumptions example consider triangle figure 7 xaxis projection triangle seven integersolutions hand none exist since corresponding realvalued solutions trapped 1 2 obtaining full set left without integer values resort two possible alternatives 1 search rational solutions offsets deadlines reduce clockgranularity accordingly 2 try find new values hopefully lead full integer solution example application c c illustrate effect variable elimination example application presented earlier derived constraints impose lower upper bounds task periods shown also remaining original harmonicity constraints linear constraints harmonicity constraints utilizationbased pruning lcm child pruning search solution harmonic chain merging figure 8 finding pruning constraints output tasks 4 6 stem separation constraints impose upper lower bounds periods 42 c c deriving periods deadlines offsets eliminated set constraints involving task periods objective point obtain feasible period assignment 1 satisfies derived linear equations 2 satisfies harmonicity assumptions 3 subject realizable utilization ie 1 example maximum separation constraints typically mandate solutionspace bounded thus faced decidable problem albeit complex one fact cases defeat known algorithms cases alternative traversing entire cartesianspace n tasks may range within l fortunately atgs structure gives rise four heuristics aggressively prune search space strategy pictorially rendered figure 8 let predi succi denote set tasks predecessors successors task ie tasks directed path since harmonicity relationship transitive j 2 succ follows j jt simple fact leads three four heuristics harmonic chain merging extends following observation solve arbitrary variable arbitrary function rather combine chains processes solve base periods dramatically reduces number free variables gcd parent pruning used ensure head chain forms greatestcommon divisor entire chain tuples violate property deleted set candidate solutions utilization pruning ensures candidate solutions maintain cpu utilization 100 rather desirable constraint hard realtime system lcm child pruning takes opposite approach gcd parent pruning ensures tasks period multiple predecessors combined lcm since expensive pruning measure saved last harmonic chain merging first step pruning process extends simple frequently overlooked observation tasks often oversample discernible reason unnecessarily low easily steal cycles tasks truly need purposes translates following rule task executes period j 2 property also execute period words never run task faster needs run designs periods adhoc artifacts tuned achieve endtoend constraints approach would highly unsafe rate constraints analytically derived directly endtoend requirements know fast task needs run makes sense run faster allows us simplify atg merging nodes limit number free variables problem method summed following steps consequently j first pruning takes place propagating information tighten period bounds thus task bounds tightened follows 2 second step algorithm simplify task graph consider task outgoing edge maximum value constrained harmonicity restrictions simplification done merging j whenever safe set ie restricted solution space contains optimal solution following two rules give condition safe perform simplification rule 1 vertex single outgoing edge merged j rule 2 succ merged consider graph figure 9 parenthesized numbers denote costs corresponding nodes graph nodes 3 5 1 single outgoing edge using rule 1 1 14 8 6 2 356 8 14 8 1 356 8 figure 9 task graph harmonicity simplification merge 3 5 6 1 4 simplified graph succ g thus invoke rule 2 merge 2 scheme manages reduce original seven tasks three sets tasks set represented pseudotask period execution time equal sum constituent tasks point reduced structure atg much possible turn examining search space even still use harmonicity restrictions utilization bounds aggressively possible objective limiting search let phi denote set feasible solutions period whose initial solution space denoted g pruning takes place successively refining restricting phi task algorithm 41 combines three remaining pruning techniques gcd parent pruning utilization pruning lcm child pruning following paragraphs explain steps detail show applied example gcd parent pruning consider particular node task graph feasible set solutions node reduced considering harmonicity relationship successor nodes restrict phi values provide base clockrate successor tasks algorithm 41 prune feasible search space using harmonicity utilization constraints allowable utilization sort graph reverse topological order let sorted list n traverse list check utilization condition value phi j foreach foreach u min u min gamma u min u propagate restricted feasible set successors foreach figure 10 pruning feasible space period derivation within example three merged tasks following allowable ranges sampler tasks period restricted values integral multiples phi 14 phi 356 deleting members phi s2 fail satisfy property left following reduced set utilizationbased pruning let u max upper bound utilization wish achieve stage lower bound utilization task given u min lower bound overall utilization u min solution satisfies utilization bound consider single task consider value k tasks follows period lower bound utilization given clearly u umax feasible solution obtained hence may removed feasible set returning example point following solution space since 14 356 successors utilization bounds satisfied values restriction takes place consider s2 whose period comes original sampler task testing possible solutions utilization obtain reduced set phi 14g lcm childpruning general may several chains whose tasks restricted utilization test case two chains share common source general case reduced feasible set task may propagated successors k done restricting k integer multiples follow approach example end following solution space objective achieve optimality examining remaining candidate solutions probably unavoidable case optimal solution easily found 42 giving utilization 07619 remaining solutionspace large simple branchandbound heuristic employed control search carefully setting utilization bound limit search time required since tighter utilization bound greater pruning achieved thus starting low utilization bound successively increasing reduce amount search time required achieve optimally low utilization however objective simply finding solution solution remaining candidates selected 43 deriving offsets deadlines task periods determined need revisit constraints find solution deadlines offsets periods involves finding solution maximizes schedulability variable elimination allows us select values reverse order eliminated suppose eliminated following variable x eliminated remaining free variables x already bound values constraints immediately give lower upper bound x use fact assigning offsets deadlines tasks variables assigned values variable individually optimized recall feasibility task set requires task set never demand utilization greater one time interval use greedy heuristic attempts maximize window execution task tasks offset straightforward achieved maximizing deadline inputoutput tasks offsets also need fix position window timeline minimizing offset input tasks maximizing deadline output tasks order variables assigned given following strategy first assign windows input task followed windows output task assign offsets task followed deadline output task finally deadlines remaining tasks assigned reverse topological order task graph thus assignment ordering example application given fw g final parameters derived result ordering shown period 14 28 14 42 28 42 42 offset deadline 3 feasible schedule task set shown figure 11 note feasible schedule generated using fixed priority ordering 5 step 3 graph transformation constraintsolver fails replicating part task graph may often prove useful reducing systems utilization benefit realized eliminating tight harmonicity figure feasible schedule example application requirements mainly decoupling tasks possess common producers result constraint derivation algorithm freedom choosing looser periods tasks recall example application figure 3b constraints derived section 4 resulting system producerconsumer pair largest period difference 42 note constraint solver mandated tight period 2 due coupled harmonicity requirements 4 jt 2 5 jt 2 thus choose replicate chain including 2 sampler data object 2 decouples data flow 1 2 figure 12 shows result replication 6 d2 figure 12 replicated task graph running constraint derivation algorithm transformed graph figure 12 obtain following result transformed system utilization 06805 significantly lower original task graph 07619 periods subgraph replication technique begins selecting producerconsumer pair requires replication exist two criteria selecting pair depending desired goal goal reducing expected utilization producerconsumer pair maximum period difference chosen first hand goal achieving feasibility rely feedback constraint solver determining point infeasibility producerconsumer pair selected algorithm constructs subgraph using backward traversal task graph consumer order avoid excessive replication traversal terminated first confluence point resulting subgraph replicated attached original graph producer task replication may turn specialized output serves example consider task graph two consumers c1 c2 common producer p replicate producer two independent producerconsumer pairs namely serves c2 eliminate operations contribute output c1 done dead code elimination common compiler optimization specialization done p 6 step 4 buffer allocation buffer allocation final step approach hence applied feasible task graph whose timing characteristics completely derived step compiler tool determines buffer space required data object replaces associated reads writes simple macros macros ensure consumer reads temporally correlated data several data objects even objects produced vastly different rates reads writes nonblocking asynchronous hence consider buffer virtual sequence number combining set correlated data given confluence point appears nontrivial venture 1 producers consumers may running different rates 2 flow delays common sampler distinct producers may also different however due harmonicity assumption solution strategy quite simple given sufficient buffers data object following rule used whenever consumer reads channel uses first item generated within current period example let p producer data object let c 1 cn consumers read communication mechanism realized following techniques lcm 1in c least common multiple periods 1 data object implemented buffers 2 producer p circularly writes buffer one time 3 consumer c reads circularly slots 0 c figure 13 task graph buffers consider three tasks 2 4 5 example performed graph replication two consumer tasks 4 5 run periods 28 42 respectively producer 2 runs period 14 thus data object requires 6 place buffer slots 0 2 reads slots 0 3 figure 13 shows relevant part task graph buffer allocation buffer allocation compiler tool expands data object multiple place buffer replaces read write operations macros perform proper pointer updates figure 14 shows results macroexpansion applied 4 code figure 1b note 1 2 4 run periods 28 14 28 respectively 7 conclusion presented fourstep design methodology help synthesize endtoend requirements fullblown realtime systems framework used long following ingredients provided 1 entityrelationships specified asynchronous task graph abstraction 2 endtoend constraints imposed freshness input correlation allowable output separation model sufficiently expressive capture temporal requirements well modular structure many interesting systems domains avionics robotics control multimedia computing however asynchronous fully periodic model limitations example cannot support highlevel blocking primitives rpcs hand deficit yields int int every 28 f size buffer1 size buffer2 figure 14 instantiated code copyincopyout channels memorymapped io significant gains eg handling streamed tightly correlated data solely via virtual sequence afforded rateassignments much work carried first constraint derivation algorithm extended take full advantage wider spectrum timing constraints encountered inputdriven reactive systems also harness finergrained compiler transformations program slicing help transform tasks readcomputewritecompute phases even enhance schedulability used approach realtime compiler tool 7 reason believe use would even effective also streamlining search algorithm incorporating schedulingspecific decisions constraint solver believe used properly policyspecific strategies help significantly pruning search space greatest challenge lies extending technique distributed systems certainly global optimization impractical since searchspace much large rather taking compositional approach finding approximate solutions node refining nodes solutionspace accommodate systems bound network utilization acknowledgements authors gratefully acknowledge bill pugh invaluable resource critic friend throughout development paper particular bill best reference topic nonlinear optimization also grateful insightful comments timeware group members jeff fischer ladan gharai tefvik bultan dongin kang addition authors particular discussions ladan jeff great sounding boards formalized problem gave valuable advice developed solution r hard realtime scheduling deadlinemonotonic approach data consistency hard realtime systems esterel towards synchronous semantically sound high level language real time applications preemptive priority based scheduling appropriate engineering approach fixed priority scheduling periodic tasks varying execution priority safety analysis timing properties realtime systems realtime producerconsumer paradigm paradigm construction efficient scheduling algorithm multiprogramming hard realtime envi ronment priority inheritance protocols approach realtime synchronization using offset information analyse static priority preemptively scheduled task sets extendible approach analysing fixed priority hard realtime tasks scheduling processes release times decomposition approach realtime scheduling scheduling tasks resource requirements hard realtime system tr ctr namyun kim minsoo ryu seongsoo hong heonshik shin experimental assessment period calibration method case study realtime systems v17 n1 p4164 july 1999 tadaaki tanimoto seiji yamaguchi akio nakata teruo higashino real time budgeting method modulelevelpipelined bus based system using bus scenarios proceedings 43rd annual conference design automation july 2428 2006 san francisco ca usa minsoo ryu seongsoo hong toward automatic synthesis schedulable realtime controllers integrated computeraided engineering v5 n3 p261277 august 1998 luigi palopoli giuseppe lipari gerardo lamastra luca abeni gabriele bolognini paolo ancilotti objectoriented tool simulating distributed realtime control systems softwarepractice experience v32 n9 p907932 july 2002 victor braberman automatic verification realtime designs proceedings 21st international conference software engineering p716717 may 1622 1999 los angeles california united states di kang r gerber l golubchik j k hollingsworth saksena software synthesis tool distributed embedded system design acm sigplan notices v34 n7 p8795 july 1999 dinesh ramanathan ali dasdan rajesh gupta timingdriven hwsw codesign based task structuring process timing simulation proceedings seventh international workshop hardwaresoftware codesign p203207 march 1999 rome italy ali dasdan dinesh ramanathan rajesh k gupta rate derivation applications reactive realtime embedded systems proceedings 35th annual conference design automation p263268 june 1519 1998 san francisco california united states dongin kang richard gerber manas saksena parametric design synthesis distributed embedded systems ieee transactions computers v49 n11 p11551169 november 2000 huan li krithi ramamritham prashant shenoy roderic grupen john sweeney resource management realtime tasks mobile robotics journal systems software v80 n7 p962971 july 2007 ali dasdan dinesh ramanathan rajesh k gupta timingdriven design validation methodology embedded realtime systems acm transactions design automation electronic systems todaes v3 n4 p533553 oct 1998 richard gerber seongsoo hong slicing realtime programs enhanced schedulability acm transactions programming languages systems toplas v19 n3 p525555 may 1997 victor braberman miguel felder verification realtime designs combining scheduling theory automatic formal verification acm sigsoft software engineering notes v24 n6 p494510 nov 1999 dinesh ramanathan ravindra jejurikar rajesh k gupta timing driven codesign networked embedded systems proceedings 2000 conference asia south pacific design automation p117122 january 2000 yokohama japan
database support evolving data product design argue database support design processes still inadequate despite many transaction models put forth fill deficiency opinion substantial improvement gained introducing yet another transaction model questioning basic paradigm transaction processing instead usual view transactions destructive operations replacing outdated database state current one propose view design transactions nondestructive operations importing additional knowledge essentially unchanging final design solution leads model designing constraints natural way concurrent design give formal presentation model discuss implementation techniques centralized distributed constraint management b introduction product design like business processes today requires database support simple takings yet design processes differ ordinary business processes easily decomposable series independent steps would lend acid paradigm classical database transaction processing instead various subtasks design task tend highly interrelated design process best viewed set cooperative activities pursuing subtasks simultaneously consequently research database support design processes mostly focused developing alternatives strict isolation property classical database transac tions variety mechanisms define control cooperative transactions proposed proposals sometimes considerably departed notion serializability classic correctness criterion basic paradigm transaction funded german research council dfg project number sfb346 processing remained transactions effect state transitions consistent database states defined complete unambiguous descriptions current state miniworld consideration point view amount information database essentially constant consistent database state provides complete description exactly one state miniworld transactions switch states dictated evolution miniworld general increase amount information available state thus transactions essentially non monotonous information old state destroyed replaced information new state nonmonotonicity follows noncommutativity therefore importance serializability design process however information predominantly added information already available ideally design means continuous refinement specifications unique artifact singled words state world artifact eventual result design never changes instead amount knowledge available state increases monotonically course real design processes less straightforward proposed designs may prove infeasible case specifications must retracted nevertheless fundamental operation design narrowing solution space monotonous hence commutative operation believe therefore database system useful design processes support notion specification constraint admissible artifacts refinement release specifications primitives data model leeway offered commutativity refinement exploited transaction model first step direction propose constraintbased data model thus adopting perspective originally introduced constraint logic programming taken constraint database systems perspective database provide explicit characterization single state world assigning precise values state variables instead database contains set constraints variables delineate admissible values thereby possible states world put less abstract terms design database holds requirements design decisions gathered far thereby constrains set possible design solutions design proceeds constraints added either contradiction reached backtracking becomes necessary specification progresses point information needed eventual production artifact available sufficient precision fundamental primitives data model finement querying release constraints demonstrate primitives play together collaborative design given database always denotes approximation design solution notion consistency becomes rather simple constraints must contradictory least level system detect constraints introduced one party must released another party without proper authorization case single centralized database data model associated consistency guarantees implemented straightforward way using techniques known constraint databases situation becomes difficult data replication taken account eg sales representative loading set product specifications onto laptop making changes offline customer meeting reintegrating data main database maintain consistency case changes replicated data must certain extent arranged advance present locking protocol designed announce anticipated changes replicated data prevent pessimistic fashion conflicts reintegra tion however even protocol cannot observed unanticipated changes need made conflicting specifications detected reintegration time resolved manually summarize contributions paper fol lows demonstrate notion data constraints lends natural way concurrent design present protocols necessary coordinate concurrent access maintain consistency centralized distributed constraint store 2 related work view design refinement specifications fairly common design theory see eg 2 general setting specifications given arbitrary concepts concept denotes family related artifacts result design artifact defined intersection sufficient number concepts 13 however hope treating specifications general algo rithmically limit specifications constrain value attribute certain range specifications cover common cases practice admit efficient satisfiability tests pointed introduction constraint paradigm put fruitful use constraint database systems 7 10 8 primary motivation line research desire generalize ordinary relations ie finite collections tuples infinite relations maintaining finite description consequently constraint database systems become popular geographic temporal applications regions intervals containing infinite number points need manipulated transactions conducted applications however rather conventional particular nonmonotonous constraint databases yet able realize potential increased parallelism inherent constraint framework quite contrary parallelism main focus saraswats work parallel constraint programming 11 notion shared constraint store proposed elegant means communication synchronization cooperating agents data model rather simple application general framework laid thesis saraswat coming programming language background mostly concerned centralized constraint store although addresses distributed constraint systems discuss mechanisms maintain consistency setting gap filled protocol presented section 6 fuzzy sets 14 may viewed generalized constraints allow varying degrees satisfaction fuzzy database systems 1 3 proposed capture uncertainty specifications inherent early design stages 12 15 thus fuzzy database systems share view design refinement reduction uncertainty however research applying fuzzy technology design processes focused modeling aspects semantics fuzzy sets whereas mainly concerned coordinating parallel access design information yet data model protocols presented apply equally well crisp fuzzy constraints provided efficient consistency checking algorithms class constraints consideration available eg 6 constraint fuzzy database systems may regarded combinations nonstandard data model standard transaction model conversely also many attempts graft advanced transaction model onto conventional objectoriented relational database system seeking provide better support long running cooperative transactions typical design pro cesses space limitations forbid detailed discussion rather large body work see 5 survey general transaction models trade strong consistency guarantees offered serializable transaction processing flexible control transaction isolation notions consistency however flexibility comes price complex transaction management schemes worse perhaps depending user provide information desired semantics along transactions view bad tradeoff consistency guarantees semantics database system simple possible much less drastic modification classic acid paradigm notion fflserializability introduced 9 means trading precision concurrency fflseriali zability applicable data possess numerically quantifiable degree uncertainty extends ordinary serializability permitting transaction histories whose results differ according suitable metric quantity ffl serializable history unfortunately ffl serializability handle write transactions well absence knowledge internal workings write transaction one must assume small variations input lead arbitrarily large variations output hence accept possibility unbounded divergence database state result serial execution 4 addresses problem suggesting transactions went far astray periodically un done design setting transactions easily representing days work may prove costly 3 formal model constraintbased design view design manipulation specifications specification poses restriction admissible design solutions specifications imposed external agents ie design requirements specifications resulting decisions internal design process treated alike model design space finite collection x 1 design parameters types 1 2 n every possible design outcome uniquely characterized assignment values x 1 x 2 xn types 1 2 n arbitrary thus entirely conceivable design parameter describes say complex geometry specification general syntactical characterization subset 1 theta 2 theta delta delta delta theta n pointed section 2 notion broad algorithmically tractable limit specifications restrict value single design parameter x range syntactical characterization language l onedimensional specifications henceforth called conditions exact language l used express ranges left unspecified example might defined explicit enumeration numerical intervals logical formulas etc make certain assumptions l 1 ranges 1 2 sm expressible l expressible l well exists reasonably efficient procedure computing corresponding expression 2 exists reasonably efficient procedure deciding whether intersection collection 1 ranges expressible l empty 3 ranges expressible l convex following sense 1 2 sm expressible l technical particularly essential condition constrain operator introduced assumptions obviously true ranges defined numerical intervals also powerful logical frameworks cf 8 examples associated condition principal ie abstract representation agent imposed condi tion could individual designer design team manager customer entity authorized participate design process combination condition principal called constraint design state design database given collection constraints together describe values considered admissible x 1 x 2 xn particular state design state called consistent least one assignment values x 1 x 2 xn satisfying constraints notion consistency admittedly naive take interactions design parameters due physical laws technological limitations ac count example microprocessor design conditions clock rate 1000mhz power dissipation 1w formally consistent refer different design parameters currently simultaneously achievable desired dependencies design parameters could introduced model multidimensional conditions expense increased overhead consistency checking believe however even simpleminded consistency checks defined prove beneficial practice design proceeds means three basic operations operation carried atomically adds new constraint condition x 2 invoking agent principal design state operation succeeds new state consistent fails set constraints conflicting x 2 returned set well defined convexity property assumed removes specified constraint design state exists note affect constraints x operation succeeds invoking agent authorized remove constraints introduced principal p specific scheme whereby authorization obtained left open peekx returns condition describing set values admissible x current state ie intersection current constraints x let us briefly comment operations invariants imply constrain monotone operation used establish new design requirements new design decisions case discussed next section stake existing decisions release inverse operation used retract requirements decisions come fruition peek serves query current state typically beginning design task definition operations clear following two properties hold constraint consistency cc design state always consistent particular result peek operation never denotes empty set constraint durability cd constraint successfully established constraint satisfied design solution unless explicitly released properly authorized agent presumably notification constraints principal worth pointing notion durability described quite different one offered acid transactions latter refers protection system media failures effects transactions values written acid transactions safe transactions yet committed committed may overwritten time contrary semantics committed design de cisions supposed stable unless explicitly retracted 4 concurrent design constraints illustrate constraint manipulation primitives play together concurrent design design process usually begin determining major design requirements entering corresponding constraints design database soon sufficient set requirements established allow meaningful subdivision design task design subtasks may formulated assigned meanwhile acquisition requirements continues resulting constraints imposed designer charged certain design task initially use peek operation obtain current constraints relevant design parameters three outcomes possible 1 constraints solution possible case design process reached dead end constraints need released 2 problem underspecified extent nothing useful done case design task must postponed information forthcoming 3 constraints admit one solutions case solution determined constraints describing solution added database together constraints describe assumptions solution based simplest case additional constraints simply copies constraints obtained initial peek oper ations thus redundant frequently though design solution requires stronger assumptions design requirements additional constraints describing design assumptions actually narrow solution space way many design tasks proceed parallel virtue constraint durability designer rest assured assumptions results design remain valid throughout entire process unless explicitly retracted course also means attempt establish constraint may fail conflicts assumptions results another design activity attempt made resolve conflict automatically resolution typically requires domainspecific expertise recourse conflict contact principal offending constraint returned unsuccessful constrain negotiate solution note consistency durability guarantees offered constraint store require locking protocols besides executing primitive operation atomi cally follow simply definition monotonicity constrain 5 implementing centralized constraint store current prototype system standalone implementation using mainmemory database system layered implementation top conventional relational database system envisioned rather straightforward way first design parameters describing design space need identified hardly feasible submit every single dimension occurring engineering drawing every line code program constraint paradigm therefore one would try identify set parameters representing information truly needs shared among concurrent design activities use transaction management facilities underlying database system couple nonshared parameters govern ing shared parameters example two design groups working mechanical assembly needed exchange bounding box information respective com ponents coordinates bounding boxes would considered design parameters access dimensions would wrapped acid transactions ensure bounding box data remain consistent true geometry data second domain condition language need chosen every design parameter mechanical de sign information numerical lower upper bounds usually suffice conditions hand software engineering usually deals freetext specifica tions sort symbolic representation must found eg picking salient keywords defining conditions explicitly enumerating required keywords third design parameters associated sets constraints represented relational model example numerical design parameter constraints defined intervals might represented threecolumn table tuple principal lower bound upper bound constraint design parameter finally operations constrain release peek need implemented acid transaction procedures constrain peek would presumably invoke custom procedures satisfiability testing intersection respectively note scheme applications continue use ordinary acid transactions fact wrapper transactions written access nonshared parame ters transparently inserting calls constrain release governing shared parameters outlined applications need aware constraint framework 6 handling distribution replication goal extend cc cd guarantees distributed replicated constraint system assume replicas may operate temporarily disconnected mode without able exchange operations replicas case two incompatible constrain operations may executed different replicas raising conflict replicas eventually merged cc cd maintained assumptions conflicts allowed hence constrain operations must executed pessimistically release peek operations less critical never raise conflicts merge 61 intention locks introduce intention locks means protect disconnected replicas incompatible constrain operations intention locks acquired replicas still con nected held reconnection occurs idea behind intention locks announce changes anticipated period disconnected operation obvi ously advance knowledge changes necessary acquire proper locks unreasonable assumption sales representative copies data notebook meets customer discuss design probably rough idea data may change formally intention locks conditions sense section 3 ie onedimensional specifications expressed language l intention locks always associated replica unlike constraints princi pal also two kinds intention locks semantics somewhat different conditions two kind intention locks correspond classical shared exclusive locks reflect two different attitudes designer may exhibit towards design parameter firstly design parameter x may viewed input design task case designer presumably use peek obtain current range x use constrain reimpose range perhaps range somewhat nar rower design assumption semantics constraint prepared accept outcome design process long design assumption satisfied particular prepared accept arbitrary constraints imposed x principals perhaps replicas long constraints nonempty intersection express attitude enter disconnected mode would request shared intention lock x range equal minimum range acceptable shared intention lock x range held replica prohibits replicas imposing constraints x range disjoint similar constraint except shared intention locks immediately globally published whereas constraints eventually published see section protocol implementation second design parameter x may viewed yet unknown output design task case designer may foresee needs impose certain constraints x yet know constraints order keep designers restricting freedom choice want impose lock prohibits principals introducing constraints x eliminate values considers potentially interesting attitude expressed requesting exclusive intention lock x range union constraints designer might want introduce later exclusive intention lock x range held replica prohibits replicas imposing constraints x range include entire locking protocol determined following rules first two rules govern acquisition locks last rule governs execution constrain operations release peek operations always permit ted shared lock acquisition request shared intention lock design parameter x range granted iff following conditions met 1 another replica holds exclusive intention lock x range x x 2 another replica holds shared intention lock x range 0 0 6 exclusive lock acquisition request exclusive intention lock design parameter x range x granted iff following conditions met 1 replica holds exclusive intention lock x 2 another replica holds shared intention lock x range x constraint introduction request constrainx executed replica succeed iff following conditions met 1 replica holds shared intention lock x range 0 exclusive intention lock x range x 6 2 intersection constraints currently imposed x replica nonempty replica holds exclusive intention lock x meets range lock note admissibility constrain operation decided locally whereas acquisition locks requires global communication exactly global communication implemented discussed next 62 protocol implementation protocol acquisition intention locks may seem simple first details somewhat complex note first constrain operations executed locally replica without communication resulting constraints propagated eventually repli cas along release lock covering opera tion difficult part setting releasing intention locks call operations global must propagated replicas global operations executed asynchronously long replicas execute order particular disconnected replica see execute global operations originating replicas reconnection time long ordering preserved protocol remain correct set replicas usually divided set connected partitions easy show one parti tition permitted execute global operations problem decide partition allowed initiate global operations usually done using quorum consensus algorithm however scenario majority replicas might offline partition big enough achieve quorum case requirements quorum modified accordingly eg quorum could partition contains half members last quorum last least even inside quorum one replica initiate global operation replica initiate global operation preceding global operation completed replicas within quorum 7 conclusions open problems started observation design unlike business processes process successive refinement monotonous information accretion led us adopt constraints basic design objects investigated concurrent design achieved within constraint framework showed basic guarantees constraint model combined explication design assumptions lead natural coordination model require additional transaction management finally presented implementation mechanism centralized distributed constraint systems thus demonstrating basic feasibility approach interesting continuation work certainly handling multidimensional constraints constraint specify dependencies several design parameters unfortunately time needed compute intersection satisfiability multidimensional constraints tends grow rather fast number dimensions work necessary identify constraint languages implementation techniques handle multidimensional constraints reasonable performance r fuzziness database management systems mathematical theory de sign foundations fuzzy logic data modeling asynchronous consistency restoration epsilon serializability database transaction models methodology reduction imprecision engineering design process constraint query languages constraint databases relaxing limitations serializable transactions distributed systems constraint databases survey concurrent constraint programming fuzzy sets engineering design configuration general design theory cad system fuzzy sets zimmermann editor practical applications fuzzy technologies tr nested transactions approach reliable distributed computing rcsmyampersandmdasha system version control sagas cooperative transaction hierarchies transaction model support design applications toward unified framework version modeling engineering databases acta framework specifying reasoning transaction structure behavior principles realization strategies multilevel transaction management flexible adaptable tool kit approach transaction management non standard database systems multilevel transactions open nested transactions concurrent constraint programming implementing extended transaction models using transaction groups fuzzy logic data modeling constraint query languages preliminary report relaxing limitations serializable transactions distributed systems practical applications fuzzy technologies fuzziness database management systems mathematical theory design constraint databases constraint databases
modelcomposition problem userinterface generation automated userinterface generation environments criticized failure deliver rich powerful interactive applications specify powerful systems designers require multiple specialized modeling notations modelcomposition problem concerned automatically synthesizing powerful correct efficient user interfaces multiple models specified different notations solutions modelcomposition problem must balance advantages separating code generation specialized code generators able take advantage deep modelspecific knowledge correctness efficiency obstacles result separation present correct efficient solution maximizes advantage separation using runtime composition mechanisms b introduction building user interfaces uis time consuming costly systems graphical uis guis nearly 50 source code lines development time attributed ui 14 guis usually built fixed set modules composed regular ways hence gui construction natural target automa tion automated tools successful supporting presentation aspect gui functionality provide limited support specifying behavior interaction ui underlying application functionality modelbased approach interactive system development addresses deficiency decomposing ui design construction separate models declaratively specified 5 specified automated tools integrate models generate efficient system modelcomposition problem need efficiently implement automatically integrate interactive software specified separate declarative models paper introduces modelcomposition problem presents solution model declarative specification single coherent aspect user interface appearance interfaces interacts underlying application functionality focusing attention single aspect user interface model expressed highlyspecialized notation property makes systems developed using modelbased approach easier build maintain systems produced using approaches 23 e r e e ui synchronization toolkit module model model model dialogue application presentation presentation dialogue application module module module figure 1 modelbased code generation mastermind project 5 15 concerned automatic generation user interfaces three kinds models presentation models represent appearance user interfaces terms widgets widgets behave application models represent parts functions data applications accessible user interface dialog models represent enduser interac tions ordered affect presentation applica tion dialog model acts glue presentation application models expressing constraints sequencing behavior models modelspecific compilers generate modules code model resulting modules composed complete user interface figure 1 distinguishing characteristic mastermind modelspecific code generators work independently one another composing code generated multiple models difficult model de sign represents single aspect system neutral respect others 3 inevitably however functionality described one model overlaps dependent upon functionality described another button example specified presentation model behavior button influences behavior models pressing button causes widgets enabled dis abled effects described dialog model effect pressing button also cause application method invoked effects described application model code generated multiple models must cooperate redundancies dependencies difficult resolve resolving automatically means behavior different models must correctly unified mechanism unification must implemented efficiently modelcomposition problem concerned automatically synthesizing powerful correct efficient userinterfaces separate presentation dialog application models present twofold solution first formalize three models concurrent agents synchronize common events sec tion 3 second present runtime architecture supports composition modules generated independent model compilers section 4 present modelcomposition problem 3 results approach two examples give evidence show scales section 5 2 background modelbased approaches userinterface generation use models specified diverse often incompatible notations characteristic complicates model composition composition mechanisms one model may exist another section 21 prior research architecture userinterfaces suggests using communicating agents structure userinterface code section 22 formal models communicating agents provide technique called conjunction useful composing partial specifications system section 25 contribution paper extension conjunction specificationcomposition operator runtimecomposition mechanism 21 modelbased generation modelbased approach interactive system development expresses system analysis design implementation terms integrated collection mod els unlike conventional software engineering designers compose software documentation whose meaning relevance diverge delivered code modelbased approach designers build models critical system attributes analyze refine synthesize models running sys tems modelbased ui generation works premise development support environments may built around declarative models system developers using approach build interfaces specifying models describe desired interface rather writing program exhibits behavior 21 one characteristic modelbased approaches restricting focus model single aspect system modeling notations specialized highly declarative mastermind presentation model 6 example combines concepts terminology graphic design mechanisms describing complex presentations using functional constraints mastermind dialog model 19 uses state event constructs describe usercomputer conversation composition features include state hierarchy concurrency communication mastermind application model combines concepts terminology objectoriented design techniques 18 mechanisms composing complex behavior based method invocation figure 2 compares mastermind models terms domains dis course communication mechanisms runtime components com posed composition mechanisms one model may exist another model single one intramodel mechanisms sufficient composing three mastermind models modelcomposition problem restated need unify behavior multiple models without violating rules intramodel composition generating efficient code modelcomposition problem declarative instance problem constructing software system module process implementation action implementation intramodule composition application abstract method invocation subclassing aggregation presentation amulet objects constraints commands instantiation aggregation dialog state machines synchronous message passing orthogonal composition figure 2 multiparadigm action implementations jor components expressed programming languages different families paradigms zave called multiparadigm programming problem 24 22 multiagent userinterface architectures mastermind approach model composition builds prior work multiagent userinterface architectures provide design heuristics structuring interactive systems architectures describe interactive systems collections communicating agents independent computational units identity behavior two general frameworksmodelviewcontroller mvc 11 agent roles provide guidance agents connected mvc prescribes smalltalk simulations composed instantiating instances three types agents models confused masterimind models describing application state views providing presentations models controllers allowing users affect simulation behavior view registers interest one attributes model attribute changes registered views notified recompute display necessary pac framework closely matches mastermind mvc pac presentation agent maintains state display accepts input user abstraction agent maintains representation underlying application state controller agent ensures presentation abstraction remain synchronized mastermind presentation application dialog models descriptions roles played pacs presentation abstraction controller agents since mastermind models describe pac agents chose make mastermind models compose manner pac agents compose specifically presentation application models define actions ordered temporal constraints dialog model make ideas formal built upon prior work formal definitions agent composition modelcomposition problem 5 23 formal models agents pac framework provides heuristic definitions userinterface agent roles connections pac agents concurrent compose communicating control data messages among generate code models agents need formalize building blocks agents agent compo sition chose terminology definitions adopted various process algebras specifically lotos 4 process algebras formalize concurrency communication proved particularly useful describing ui software collection agents 1 2 notations statecharts 8 petri nets 16 also explored modeling ui agents alternative notations also provide definitions concurrency communication chose lotos composition lotos resembles conjunction 25 useful paradigm composing partial specifications section 25 model behavior agent using lotos abstraction called process computational entity whose internal structure discovered observing interacts environment processes perform internal unob servable computations interact concurrently executing processes interaction processes synchronous one process tries communicate process ready communicate former process blocks latter ready thus act communicating synchronizes concurrent processes process represents state agent procedure performing future actions action atomic computational step taken individual pro cess actions process observed events actions participate event observable unit multiprocess communication multiple processes participate event simultaneously performing actions gate gate primitive synchronization device used observe occurrence action process action associated single gate gates composite agent union gates constituents two constituents name gate actions gate proceed simultaneously processes associated constituent agents synchronize actions share gate name thus gates also represent class possible interprocess synchronization events event action offer one data values observed actions processes participating event complete agent modeled process represents initial state agent multiagent system modeled collection concurrent communicating processes composing system multiple agents designer must decide coordinate actions various processes model agents coordinated synchronizing actions labeled identically named gates 6 stirewalt rugaber 24 lotos lotos rich language specifying partial ordering actions within process structure multiprocess interactions complex processes may expressed either combining subprocesses using ordering operator eg process p sequential composition subprocesses p 1 p 2 conjoining subprocesses run independently synchronize actions gates event allows values flow participating actions lotos also describes semantics value passing respect synchronization actions lotos following structure action gate inputjoutput input output gate identifier action names gate zero inputs outputs input names variable record value offered action another process output expression computing value offer actions processes actions concisely represent occurrence many possible events like actions events associated particular gate unlike actions events concept input output rather represent unique values flow actions events following structure event gate value value note values always constants events unique assignments values synchronization lotos gates two conjoined processes required synchronize must specified vertical lines symbolize conjunction operator k example given following lotos process definitions process process process r process r behaves like p gate g 3 q gate g 4 r must behave like p q synchrony gates g 1 g 2 processes many gates lotos notation quickly becomes unreadable paper abbreviate conjunction operator using notational conventions similar used csp 9 abbreviated notation write conjunction p q p k q understanding p q must synchronize gates common agents whose states p q respectively represent suppose behavior agent described lotos process b agent perform action synchronizing event e denoted modelcomposition problem 7 behavior point defined another process systems study deterministic means always unique moreover system defined conjoining subprocesses compositional structure preserved throughout lifetime system occurs gate agent event observed process p also observed conjunction p processes fact important define observer function section 34 25 conjunction composition alexander uses conjunction compose separately defined application presentation agents 2 abowd uses agentbased separation illuminate usability properties interactive systems 1 approaches rely use conjunction compose agents defined separately interact fact conjunction general operator composing partial specifications system 25 idea partial specification imposes constraints upon variables case agents events mentioned partial specifications specifications conjoined common variables must satisfy constraints define behavior system generated mastermind models behavior consistent conjunction constraints imposed dialog presentation application models extend conjunction specification tool mechanism composing runtime modules 26 summary three issues must addressed solve modelcomposition problem solution must generate userinterfaces rich dynamic behavior correctness module composition must demonstrated generated modules must cooperate efficiently mastermind rich expressive power achieved specialpurpose modeling notations 15 5 remainder paper addresses generation correct implementations maximal efficiency preserving expressive power mastermind models 3 modelcomposition theory recall figure 1 class model code generator synthesizes runtime modules models class modules generated without detailed knowledge models run time however modules must cooperate prescribed conjunction models generated section describes relationship model composition mechanism associated modules cooperate runtime 31 notation subject paper automatic generation composition runtime modules designtime models module unit code generated single model use third class constructthe lotos processto define correctness model module composition formal arguments need refer three types constructs thus distinguish constructs using different fonts also need special functions map models modules comparable domains represent classes mastermind models using german letters symbols represent respectively classes mastermind presentation dialog application models use italic font represent lotos processes semantic models processes set p rocess represents set lotos processes specific processes written capital italic letters eg p respectively set racesets defines set event traces alphabet gates space values offered observed lotos actions function racesets maps lotos process set event traces observed process represent runtime entities using sans serif font set component represents class runtime components component block code provides gates observing actions component defining components runtime code provides gates observing behavior define function racesets maps component set event traces observed gates component provides two categories component mastermind architecture generated modules synchronous composition modules instances generated modules written pres dialog appl respectively also think modules synchronous composition component attained connecting generated modules using synchronization infrastructure de fined section 4 composite component written synchpres dialog appl name synch suggests component synchronization three generated modules brackets suggest generated modules fit larger system synch component 32 intermodel composition modelbased code generators construct runtime modules designtime mod els code generation strategy modelspecific reflecting specialization models particular aspect system run time however modules must co operate cooperative behavior must violate correctness constraints imposed models inherent distinction behavior modelcomposition problem 9 limited confines given model behavior affects affected models intermodel composition concerned managing latter intermodel behavior behavior highly model specific neither influences affected behavior specified models figure 2 illustrates mastermind presentation model graphical objects implemented using primitives amulet toolkit 13 attribute relations implemented declarative formulas runtime eagerly propagate attribute changes dependent attributes long changes attributes trigger behavior dialog application models aspects ignored considering model composition application model object specifications compiled abstract classes assumption designer later extend subclasses provide implementations abstract methods long details extensions trigger behavior dialog presentation models application behavior may also ignored defining model composition within module entities compose according modelspecific policy presentation model example objects compose partwhole aggregation attributes compose formula evaluation dependent attributes application model objects compose using combination subclassing aggregation polymorphism considering models compose details intramodel composition abstracted away models impose temporal sequencing constraints occurrence intermodel actions models contribute values computed entire system constraints contributions must captured form used reason model composition map intermodel behavior semantic domain common across models domain described lotos notation specifies temporal constraints actions data values assume lotos processes derived text model specification section 34 designers may example need designate actions interest models lotos processes capture behavior models composition express essential intermodel constraining behavior 33 example present example intermodel behavior expressed lotos process dialog model considered printsave widget similar found user interfaces drawing tools web browsers word processors see figure 3 widgets allow user format document printing either physical printer file disk call former task printing latter task saving options specific printing print orientation eg portrait vs landscape saving name file save typically enabled disabled depending upon users choice task ordering dependencies reflected dialog model widget shown lotos process figure 4 figure 3 screen shot printsave dialog box process p rintsave synchronize gates follow square brackets example gates print save go cancel layout kbd line 1 figure define points synchronizing presentation whereas gates lpr write define points synchronizing underlying application process parameters lpdhost f ilename line 2 store name default printer userselected filename respectively parameter doc represents document printed saved parameter port represents print orientation portrait true landscape false widget figure 3 specified separate presentation model shown model defines pair radio buttons labeled file printer two buttons labeled ok cancel buttons pressed offer events save print go cancel respectively presentation model also contains pair radio buttons specify paper orientation buttons display graphics page either portrait landscape mode selected offer event port value true choice portrait orientation false landscape orientation finally text entry box user type file name user edits name text box responds offering contents string typed far part kbd event note actual pressed returned editing functionality best handled text widget considered intermodel behavior separate application model shown defines procedures issuing print request saving file disk procedures responsive events lpr write respectively actions synchronize events offer number values including printer name lpdhost filename f ilename modelcomposition problem 11 1 process printsave print save go cancel layout kbd lpr write 2 3 p go lpr write layout kbd 4 5 process p go lpr write layout kbd 7 endproc 8 process f go lpr write layout kbd 9 edit go write kbd 10 endproc 11 process layout go lpr layout 12 13 go lpr lpdhost 14 endproc 15 process edit go write kbd 17 19 endproc figure 4 printsave dialog process temporal structure dialog presentation application model composition given behavior specification line 3 behavior p rintsave behavior process p defined lines 5 7 caveat may disabled terminated time observation cancel event disabling shown operator process p represents interactions application invocations must happen order send document printer functionality actually expressed subprocess layout defined lines 11 14 p behaves like layout normal case disabled save event observed recall save event offered whenever user presses save file button presentation model process f defined lines 8 10 likewise behaves like process edit defined lines 15 18 normal case disabled event print observed note f p disable means user switch back forth printing saving many times likes hitting go button gammagammagammagamma p rocess cd component obs gammagammagammagamma racesets figure 5 dialog compiler correctness 34 models modules processes like shown figure 4 useful understanding relationship models modules relationship complex describe first single model three models composition formalize correctness conditions mastermind dialog model similar formalization exists mastermind models figure 5 shows relationship dialog models members set runtime modules generated dialog models members set dialog intermodel behavior dialog models members set p rocess relationships sets defined functions map members one set members another function cd dialog maps dialog models runtime modules think cd abstract description dialogmodel compiler rocess maps dialog models lotos processes describing intermodel behavior think ad abstract interpretation dialog model expressing semantics lotos sets functions related commutative diagram figure 5 externally observable model behavior mapped lotos process ad set traces modules externally observable events recorded obs say dialog model 2 consistent module cd every trace set rad sequences 62 obscd intermodel behavioral interpretation agrees exactly observable behavior runtime module generated commutativity diagram requires property dialog model set 35 modelbased synthesis correctness relationship models modules figure 5 extended specify correctness module composition functions ap ad aa map models lotos processes processes compose conjunction also runtime component synch combines modules pres dialog appl single component whose actions observable obs function figure 6 shows constraints behavior entities let p 2 p 2 2 code generated modelcomposition problem 13 figure 6 modulecomposition correctness models correct observable behavior oe oe legal trace conjunction models equation defines conditions necessary correct module composition without assuming modelspecific interpretation actions serves therefore specification design requirements next section present implementation satisfies requirements 4 modulecomposition runtime architecture turn designs runtime synchronization module modelspecific compilers figure 1 essential design problem make generated modules compose retaining independence modelspecific compilers conditions figure 6 impose constraints designs tunately constraints require modelspecific knowledge eg graphical concepts presentation model data layout application model thus modulecomposition logic separated modelspecific functionality within module separation key making modelbased synthesis independent without sacrificing correctness module integration mastermind runtime library contains efficient primitive classes enable independent module synthesis correct composition conjunction library provides great deal generality flexibility code generation paper describe aspects library relevant supporting independent synthesis first introduce mechanism composing generated modules section 41 describe mechanism implements conjunction without sacrificing independence model synthesis section 42 demonstrate operation example section 43 41 design structures support conjunction facilitate independence model synthesis designed mechanism enables module compose modules without directly referencing figure 1 suggests generated modules compose aid special synchronization component called synch designed synch interface simplify generation modules section describes interface process model compilation integration figure 7 illustrates interface generated modules synch component modules contain action objects link explicitly refer gate 14 stirewalt rugaber action action action action action action gate gate gate synch dialog pres appl figure 7 structural depiction composition according synchpres dialog appl objects synch component names suggest action object reifies lotos action gate object reifies lotos gate runtime actions implement unit observable behavior module gates implement synchronization actions conjunction mathematical connection lotos actions gates reified using explicit links action gate objects links constitute mechanism composing generated modules synch component module plugs architecture linking action objects appropriate gate objects synch component dashed lines figure 7 illustrate many possible links architecture enables model synthesis treated separately module integration similar way compilation treated separately linking traditional programming separation allows module synthesized single model independent synthesis models synthesis modelbased compilers independently generate modules behavior must observed modules must packaged instance class action emitting code creates instance compiler also writes name associated gate auxiliary file consequently output model compiler module auxiliary file listing names dependent gates module integration module integrator reads auxiliary files creates synch component combines generated modules produce executable image going back running example consider compilation presentation model printsave dialog box figure 3 model processed compiler emits action objects interface directly ui toolkit widgets compilation pres module contain action widget dialog box example distinct action object paired ok cancel buttons radio buttons filename textentry widget integrate pres module modules actions must link gate objects synch component note actions emitted corresponding gate object yet exist gate created module integrator thus link action corresponding gate cannot established compile time instead action object instantiated name gate modelcomposition problem 15 void enable void disable action abstract modulesource void registerappl void unregisterappl dialappgate void registerpres void unregisterpres presdialgate gate abstract void confirmlistener void synchronize presdialappgate void unregisterdial void registerdial dialgate void execute command abstract listener abstract void listen void ignore generalization disjoint subclasses generalization overlapping subclasses legend synchronizes actionrole abstract figure 8 detailed design action gate classes must synchronize runtime action uses name locate corresponding gate module integrator creates gate named gate action object assume gate exist runtime design greatly simplifies model compilation presentationmodel compiler need concern locating object another component rather compiler simply creates module using action objects writes names gates auxiliary file 42 behavior design structures synthesis one mastermind model proceed independently synthesis models generated modules refer indirectly gate objects gate objects responsible determining synchronization occur dispatching control associated action objects appropriate order synchronization constraints satisfied conse quently action objects need concerned issues rather actions concerned implementing modelspecific functionality separation crucial supporting independence model synthesis figure 8 describes design classes action gate class gate designed internalize information modules whose actions required synchronize gate henceforth shall refer information synchronization constraint gate rules conjunction figure number possible variations constraint runtime gate determine whether synchronize checking whether constraint satisfied make determination gate must infer location module action wishes synchronize gate call process inference tabulation tabulation occurs action announces readiness synchronize announcements made action registering gate action registers passing invocation register operation gate gate determines constraint satisfied invokes synchronize operation dispatches control registered actions may execute gate tabulate modules request activity gate must able infer module every action registers means action must know module exists class action subclass called modulesource specializes three subclasses pres dialand appl shown figure concrete class every action must inherit one three subclasses implemented tabulation specializing register operation dispatches based subclasses subclasses gate contain module variations register function subclasses embody three possible synchronization constraints arise mastermind constraint associated class presdialgate requires pres dial actions present gate similarly constraint associated class dialapplgate requires dial appl actions present gate constraint associated class presdialogapplgate requires actions three modules present gate three types synchronization constraints required mastermindgenerated user interfaces next issue concerns dispatching control registered actions gates synchronization constraint satisfied mastermind supports two different action control mechanisms generalized actionrole one mechanism generic interface executing modelspecific operation class command mechanism generic interface reactively observing asynchronous event user interaction graphical widget class listener happens gates synchronization constraint satisfied depends upon control mechanisms used registered actions example two commands waiting gate satisfy synchronization constraint gate execute method commands invoked instead one actions listener command command invoked listener receives event listeners reactive need able announce reception event gate accomplished invoking confirm operation gate module requests performance action invoking operation enable enabling causes action register gate design abstracts logic requesting performance action enable disable methods correctly cooperate corresponding gate irrespective particular synchronization constraints thus logic completely encapsulated abstract class action modelcompiler writer need never modify moreover modelcompiler writers package modelspecific functionality using one two quite different control policies command listener one consequence design module integrator must determine type gate emit simple task however given information written modelcomposition problem 17 generalization legend pointer operation pseudocode void listen void ignore listener abstract widget amtextinputwidget void textfieldaction void listen void ignore pres figure 9 example use auxiliary files model compilers example gate cancel used printsave dialog used presentation model observes pressing cancel button dialog model observes completion dialog modules compose conjunction gate associated cancel always synchronizes action pres module action dialog module implement behavior module integrator emits instance presdialoggate returned associated actions link named gate 43 example demonstrate features work context printsave dialog recall figure 3 text entry field allows user enter file name save document dialog model figure 4 entry file name modeled atomic action gate kbd connect dialog action text entry widget ultimately witnesses action need presentation action knows attach text entry widget need gate object represent kbd gate figure 9 illustrates reusable action listens text entry created primitives introduced section 42 presentationmodel compiler emits instances class implement textentry boxes fig ure rendered primitive classes grey distinguish new objects classes modelcompiler writer creates new class called textfieldaction inherits class pres instances emitted pres module inherits class listener concerned monitoring controlling textinput widget class associated text input widget object association called widget object prede fined amulet toolkit 13 current version mastermind uses presentation support textfieldaction controls amulet object invoking start stop operations object instruct widget enable disable keyboard input invocations methods form implementation listen ignore respectively also need way widget signal action object event accomplished overriding method widget go find gate associated action invoke confirm operation gate signify occurrence event method thought callback function amulet invokes deliver event case event keyboard return example serves illustrate sequence behaviors enacted mastermind library primitives suppose object class textfieldaction registered gate associated kbd synchronization constraint gate satisfied gate invokes listen method textfieldaction invocation turn causes start method text input widget invoked enables user input widget synchronization context changes constraint longer satisfiedeither pres module disables textfieldaction another module disables action waiting gate gate invokes ignore operation causes textfieldaction invoke stop method text input widget disables text input hand user enters string hits return key method widget invoked causes invocation confirm method gate gate proceeds execute commands waiting 44 summary design enables independent code generation actions generated module insulated actions modules gate objects compose modules creating gate objects embody synchronization requirements models linking actions gates independence afforded approach allows modelbased code generators apply deep modelspecific knowledge synthesis code 5 results status evaluated solution modelcomposition problem respect power correctness efficiency multiparadigm actions proved easy specialize accommodate features disparate implementation toolkits architectures example specialized actions represent actions amulet object system 13 c object system specialpurpose statemachine language figure 2 summarizes different applications results modelcomposition problem 19 51 power able express user interfaces using modeling notations several case studies tested quality user interfaces two specific examples printsave widget described section 33 airspaceandrunway executive supports airtraffic controller atc 19 former demonstrates ability generate common highly reusable code standard graphical user inter faces latter demonstrates ability support complex application using directmanipulation interface atc example testifies power approach flight number keyed textentry box airplane graphic annotated flight number appears airspace planes come airspace controller keys flight number textentry box controller decides change position plane dragging airplane icon new location screen soon presses holds mouse button feedback object shaped like airplane appears follows mouse new location mouse released plane icon moves newly selected location presentation model atc example quite rich specifies gridding airplane graphics always uniformly placed within lanes specifies feedback objects present controllers information planes operation real deployment locations flights change response asynchronous application signals special hardware monitors deployment signals would connected listener actions would fit framework without change details case study printsave dialog see stirewalts dissertation 19 52 correctness addition able generate manage powerful user interfaces composition modules correct two aspects approach require justification grounds first design runtime action synchronization second synthesis runtime dialog components members set dialog models paper addresses theoretical issues involved design runtime action synchronization gate action classes traceable refinements corresponding concepts lotos practice found design quite robust one aspect synchronization correctness address paper show modelspecific specialization action violate delicate callback protocol underlies system example say appl modeled lotos observes value x offers value implemented using method invocation method bind x parameter bind return value since value offerings evaluated sequence sure ordering evaluation interfere invocation method vice versa currently check inspection investigating ways packaging problem model checker eg spin 10 smv 12 detect anomalies stirewalt used smv model checker validate interoperation action gate objects 19 mentioned earlier mastermind dialog model notation syntactic sugaring subset lotos language described greater detail 20 implemented prototype dialog model code generator whose correctness validated described stirewalt 19 code generator compiles dialog models without reference models 53 efficiency measured efficiency empirically applying code generator atc example generated dialog modules connected handcoded presentation application modules examples tried observed time delays interactions quantified results instrumenting source code measure use computation resources wallclock time maximum time taken interaction 004 seconds compares well de facto hci benchmark response time 01 seconds believe heavyweight middleware solutions implementing synchronization objectrequest brokers competitive results 54 future work currently completing robust dialog code generator new code generator incorporates statespace reduction technology improve interaction time prototype function depth dialog expression interaction executes constant time 6 conclusions generate code specialized modeling notation well understood problem integrating code generated multiple models integration much complicated merely linking compiled object modules models declarative must assume entities named one model behavior elaborated another model designers want treat presentation temporal ordering effect separately aspect isolation expressed highly specialized language would less clear required express aspects well interactive systems composition conjunction essential separating complex specifications manageable pieces unfortunately programming languages like c java provide conjunction operator operator difficult implement correctly effi ciently fact try implement rather casting model composition formal framework includes conjunction able express correct solution refine correct solution efficient de modelcomposition problem 21 sign key difference approach middleware solutions implement object composition general event registry callback results contribute body automated software engineering research two ways first framework practical solution helps automate engineering interactive systems second use formal methods identify design constraints subsequent refinement constraints objectoriented design may serve model researchers trying deal model composition context code generation formality approach allows us minimize design constraints key arriving powerful correct efficient solution r formal aspects humancomputer interaction structuring dialogues using csp developing software user interface introduction iso specification language lotos using declarative descriptions model user interfaces mastermind declarative models presentation pac objectoriented model dialog design visual formalisms communicating sequential processes model checker spin cookbook using model view controller user interface paradigm smalltalk symbolic model checking approach state explosion problem amulet environment new models effective userinterface software development survey user interface programming knowledgeable development environments using shared design models validating interactive system design verification formal task system models mecano project comprehensive integrated support modelbased user interface development automatic generation interactive systems declarative models design implementation mdl mastermind dialogue language declarative models userinterface construction tools mastermind approach beyond interface builders modelbased interface tools beyond hacking model based approach user interface design compositional approach multiparadigm programming conjunction composition tr
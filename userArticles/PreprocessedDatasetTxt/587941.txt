maximum edgedisjoint paths problem bidirected trees bidirected tree directed graph obtained undirected tree replacing undirected edge two directed edges opposite directions given set directed paths bidirected tree goal maximum edgedisjoint paths problem select maximumcardinality subset paths selected paths edgedisjoint problem solved optimally polynomial time bidirected trees constant degree apxhard bidirected trees arbitrary degree every fixed varepsilon 0 polynomialtime 53varepsilonapproximation algorithm presented b introduction research disjoint paths problems graphs long history 12 recent years edgedisjoint paths problems brought focus attention advances field communication networks many modern network architectures establish virtual circuit sender receiver order achieve guaranteed quality service connection request accepted network must allocate sufficient resources links along path sender receiver edgedisjoint paths problems heart arising resource allocation problems study maximum edgedisjoint paths problem medp bidirected tree networks bidirected tree directed graph obtained undirected tree replacing undirected edge two directed edges opposite directions bidirected tree networks studied intensively good model optical networks pairs unidirectional fiber links adjacent nodes 26 medp bidirected trees defined follows given bidirected tree e set p simple directed paths goal find subset p paths p 0 edgedisjoint cardinality p 0 maximized say algorithm aeapproximation algorithm medp always outputs subset edgedisjoint paths whose cardinality least 1aefraction cardinality optimal solution conflict graph set directed paths bidirected tree undirected graph vertex path edge two vertices corresponding paths intersect ie share edge one view medp bidirected trees maximum independent set problem conflict graph assume given tree rooted arbitrary node node v let pv denote parent v level node defined distance root node root level zero say path touches node begins node passes node ends node level path minimum levels nodes touches unique node path whose level equal level path least common ancestor lca path preliminary version article appeared proceedings 9th annual international symposium algorithms computation isaac98 lncs 1533 pages 179188 1998 institut fr informatik tu munchen 80290 munchen germany erlebachintumde z idsia lugano corso elvezia 36 6900 lugano switzerland klausidsiach denote path begins node u ends node v u v lca lcau v 11 results first x2 determine complexity medp bidirected trees medp solved optimally polynomial time bidirected trees constant degree bidirected stars max snphard bidirected trees arbitrary degree main result paper summarized following theorem theorem 11 every fixed 0 polynomialtime approximation algorithm maximum edgedisjoint paths problem bidirected trees approximation ratio 53 description algorithm proof claimed approximation ratio indeed achieved appear x3 x4 discuss results generalized weighted version problem maximum path coloring problem 12 related work path coloring bidirected trees previous work bidirected trees focused path coloring problem given set directed paths bidirected tree assign colors paths paths receive different colors share edge goal minimize total number colors used problem nphard even binary trees 8 24 best known approximation algorithms 11 10 use d53le colors l maximum load load edge number paths using edge thus lower bound optimal solution previous algorithms used 158l colors 26 74l colors 18 25 worst case special case alltoall path coloring shown optimal number colors equal maximum load 14 multicommodity flow trees garg et al 13 studied integral multicommodity flow problem undirected trees generalization medp undirected trees showed problem unit edge capacities equivalent medp undirected trees solved optimally polynomial time undirected trees edge capacities one two proved problem max snphard also presented 2approximation algorithm integral multicommodity flow trees works considering demands order nonincreasing levels lcas satisfying greedily approximation algorithm adapted medp bidirected trees also gives 2approximation main idea leads improved approximation algorithm medp bidirected trees consider paths lca simultaneously instead one one online algorithms medp trees medp also studied online scenario paths given algorithm one one algorithm must accept reject path without knowledge future requests preemption allowed easy see deterministic algorithm competitive ratio better diameter tree case awerbuch et al gave randomized algorithm competitive ratio olog n undirected trees n nodes 2 algorithm works also bidirected trees improved randomized algorithm competitive ratio olog undirected trees diameter given 3 medp topologies medp studied arbitrary graphs algorithm must solve routing problem selection problem arbitrary directed graphs edges medp recently shown nphard approximate within 12gamma 16 approximation algorithms approximation ratio p known unweighted case 20 28 weighted case 22 better approximation ratios achieved restricted classes graphs class edgedisjoint paths bidirected trees 3 planar graphs containing twodimensional mesh networks o1approximation algorithm devised 21 2 complexity results medp bidirected trees nphard general proved reduction 3dmatching similar reduction used garg et al prove nphardness integral multicommodity flow undirected trees edge capacities one two 13 omit details modification straightforward reduce bounded variant 3dmatching problem 19 reduction lreduction apreduction implying medp bidirected trees max snphard 27 apx hard 7 shows polynomialtime approximation scheme problem nevertheless medp solved optimally polynomial time input restricted certain ways first consider case maximum degree given tree bounded constant optimal solution computed dynamic programming case process nodes tree order nonincreasing levels every node v record possible subset edgedisjoint paths touching v parent note jsj 2 maximum number paths contained subtree rooted v accepted addition paths node v processed values known children enumerate possible edgedisjoint subsets paths touching v subset look corresponding values stored children v update values stored v accordingly note polynomially many subsets consider node root node processed optimal solution easily constructed another special case solved optimally polynomial time case given bidirected tree star ie contains one node degree greater one medp bidirected stars reduced maximum matching problem bipartite graph follows first assume without loss generality every given path uses exactly two edges star path uses one edge add new node star extend path one edge without changing set solutions observe every path uses exactly one edge directed towards center one edge directed away center star construct bipartite graph g including vertex every edge star adding edge two vertices u v g every path uses edges corresponding u v two paths edgedisjoint corresponding edges g share endpoint sets edgedisjoint paths correspond matchings g maximum matching g computed polynomial time 17 latter result actually generalized stars spiders spider bidirected tree one node center degree greater two medp bidirected spider solved polynomial time using algorithm maximumweight bipartite matching problem subroutine bipartite graph g constructed paths touching center spider weight edge e g specifies many fewer paths touching center spider accepted path corresponding e accepted details left reader 3 approximating optimal solution fix 0 let instance maximum edgedisjoint paths problem given bidirected tree set 4 erlebach k jansen p directed paths denote p arbitrary optimal solution given instance algorithm proceeds two passes first pass processes nodes order nonincreasing levels ie bottomup assume algorithm process node v let p v denote subset paths u w 2 p intersect paths accepted algorithm previous node use edges reserved fixed algorithm see sake simplicity assume without loss generality u otherwise could add additional child v path p v starting ending v make path start end new child instead every path uses exactly two edges incident v refer two edges top edges p say two paths equivalent use two edges incident v ie top edges set q paths lca defines partition q different equivalence classes paths natural way algorithm processes node v tries determine paths p v whether included solution paths called accepted paths called rejected sometimes however algorithm cannot make decision right away cases algorithm leave paths intermediate state resolve later possibilities paths intermediate states undetermined paths ii groups deferred paths iii groups exclusive paths iv groups 2exclusive paths refer undetermined paths paths groups exclusive paths groups 2exclusive paths unresolved paths paths groups deferred paths deferred paths status unresolved paths resolved later nodes first pass second pass algorithm proceeds topdown accepts one path group deferred paths 31 paths intermediate states following give explanations regarding possible groups paths intermediate states first algorithm sometimes leave single path p p v undetermined state p v one equivalence class paths accepting path might cause algorithm miss chance accepting two paths smaller level v later hence algorithm could best achieve 2approximation therefore instead accepting rejecting paths p v right away algorithm picks one makes undetermined path paths p v rejected undetermined path accepted rejected later node second situation algorithm accept reject paths right away sketched fig 31 following pairs oppositely directed edges drawn undirected edges figures situation algorithm decides accept one several intersecting paths p v defers decision one accept intersecting paths called group deferred paths paths group deferred paths use edge incident v child c v figure edge c v case deferred paths share edge v c symmetrical furthermore deferred path uses also edge v c 0 connecting v child c 0 6 c deferred edgedisjoint paths bidirected trees 5 e c fig 31 group deferred paths c c fig 32 possible configuration group exclusive paths lefthand side situation exclusive paths blocked righthand side paths use edge algorithm decides create new group deferred paths marks edge c v reserved assuring path accepted node processed v use edge leaves edges v c 0 children available reserved edge indicated dashed arrow fig 31 motivation introducing groups deferred paths follows first reserved edge blocks one path smaller level could accepted optimal solution second matter path using edge pv v accepted node processed v path uses one edges v c 0 still least one deferred path use particular edge v c 0 algorithm pick deferred path second pass processing later nodes first pass algorithm actually treats group deferred paths like single accepted path uses reserved edge deferred paths group exclusive paths sketched fig 32 lefthand side group consists one path q called lower path contained subtree rooted child c v one path p called higher path lca v intersects q one two paths accepted algorithm picks wrong one choice cause algorithm accept one path optimal solution would accept path one two additional paths hence algorithm defers decision path accept later node marks 6 erlebach k jansen fig 33 group 2exclusive paths consisting pair independent groups exclusive paths top edge path q intersected p fixed fixed edges indicated dotted arrows figures obviously group exclusive paths following property property e one path touching v using fixed edge accepted later node either p q still accepted two paths touching v accepted later node block p q accepted righthand side fig 32 shows two paths accepted later node block exclusive paths processing later nodes algorithm try avoid whenever possible last types unresolved paths sketched figures 33 34 groups 2exclusive paths consist set four paths two accepted precisely first possibility group 2exclusive paths consist two independent groups exclusive paths fig 33 ie two groups exclusive paths fixed edge one group directed towards root fixed edge group directed towards leaves furthermore two groups must either contained disjoint subtrees shown fig 33 lower paths contained disjoint subtrees higher paths intersect pair independent groups exclusive paths two fixed edges fixed edges groups second possibility group 2exclusive paths consist group exclusive paths contained subtree rooted child v two paths lca v intersect exclusive paths fixed edge way accepting p 1 p 2 would block exclusive paths accepted fig 34 two edges marked fixed namely top edge higher exclusive path intersected path lca v top edge lower exclusive path intersected path lca v difficult show case analysis group 2exclusive paths following property property 2e one path touching v using fixed edge accepted later node two paths group 2exclusive paths still accepted two paths touching v using fixed edge accepted later node least one path group 2exclusive paths still accepted processing later nodes algorithm try avoid accepting two paths touching v one path group 2exclusive paths accepted edgedisjoint paths bidirected trees 7 vfig 34 configurations groups 2exclusive paths 32 invariants x34 present details algorithm proceeds first pass time show approximation ratio achieved algorithm 53 order establish prove induction following invariants maintained invariants hold first node processed hold time additional node processed node v called root processed subtree node v already processed parent invariant every root v processed subtree paths subtree accepted rejected deferred except one following cases occurs subtree contains one undetermined path paths contained subtree accepted rejected deferred edge subtree marked fixed ii subtree contains one group exclusive paths paths contained subtree accepted rejected deferred edge marked fixed subtree one group exclusive paths iii subtree contains one group 2exclusive paths paths contained subtree accepted rejected deferred edges marked fixed subtree two group 2exclusive paths accepted paths edgedisjoint contain reserved edges every unresolved path edgedisjoint accepted paths contain reserved edges every deferred path contains exactly one reserved edge reserved edge group deferred paths path belongs deferred path p intersects accepted unresolved path q level q smaller p invariant b let set paths already accepted algorithm let f set paths p whose lca yet processed blocked accepted paths reserved edges fixed edges let number groups deferred paths contained processed subtrees let u set undetermined paths let x union groups exclusive paths groups 2exclusive paths subset f u x edgedisjoint paths satisfying following conditions jp j 53 b every group exclusive paths contains one path group every group 2exclusive paths contains two paths group intuitively set represents subset p containing edgedisjoint paths could still accepted algorithm following property algorithm accepts least 153 fraction paths addition 8 erlebach k jansen paths already accepted output 53 approximation optimal solution observe invariants satisfied initially easy see description algorithm invariant indeed maintained throughout first pass special care must taken prove invariant b maintained well 33 second pass invariants satisfied root node processed joj time still one undetermined path need contained therefore joj 2 f0 1g case one group exclusive paths contains exactly one path one group 2exclusive paths contains two edgedisjopint paths 2 undetermined path algorithm accepts group exclusive paths algorithm accepts one arbitrarily group 2exclusive paths algorithm accepts two edgedisjoint paths arbitrarily algorithm accepts least joj additional paths way resulting set 0 accepted paths satisfies ja therefore jp j 53 second pass algorithm processes nodes tree reverse order ie according nondecreasing levels topdown node v lca least one group deferred paths accepts one path groups deferred paths paths edgedisjoint previously accepted paths always done due definition groups deferred paths hence number paths accepted algorithm increases second pass set 00 paths accepted algorithm end satisfies ja 00 theorem 11 34 details first pass assume algorithm process node v recall p v p set paths lca v intersect previously accepted path fixed reserved edge let u v set undetermined paths contained subtrees rooted children v let x v set paths groups exclusive paths groups 2exclusive paths contained subtrees rooted children v following explain algorithm processes node v determines paths p v u v x v accepted rejected deferred left put unresolved state observe given set paths lca v problem determining maximumcardinality subset edgedisjoint paths equivalent solving medp star thus done polynomial time computing maximum matching bipartite graph cf x2 whenever use expression like compute maximum number edgedisjoint paths p v following imply computation carried employing reduction maximum matching use following property bipartite graphs 2 fact maximum matching bipartite graph g cardinality implies vertices g every edge incident least one vertices property holds arbitrary values known konig theorem 23 see eg book berge 4 pp 132133 observe child current node v root processed subtree invariant contain one following one undetermined path one group exclusive paths one group 2exclusive paths let k number children v undetermined path subtree let edgedisjoint paths bidirected trees 9 number children v group exclusive paths let number children v group 2exclusive paths use expression subtrees exclusive paths refer subtrees rooted children v either group exclusive paths group 2exclusive paths note one main difficulty lies determining paths u v accepted rejected k bounded constant possible combinations accepting rejecting paths u v x v tried polynomial time k large algorithm must proceed different way order make sufficiently good decisions exact threshold determining k considered large consequently runningtime algorithm depend constant let f u x denote quantities defined x32 instant algorithm processes node v let f 0 u 0 x 0 0 0 denote respective quantities right node v processed furthermore denote v number paths newly accepted processing v v number groups deferred paths newly created processing v assume set f u x edgedisjoint paths satisfying conditions b invariant b v processed every single case following case analysis show construct set 0 satisfies invariant b v processed 0 obtained replacing paths removing paths inserting paths required particular 0 must set edgedisjoint paths satisfying 0 f 0 u 0 x 0 therefore paths intersecting newly accepted path reserved edge newly created group deferred paths must removed note two paths smaller level v paths smaller level must use edge v pv pv v paths rejected algorithm must removed replaced new group exclusive paths group 2exclusive paths created 0 must contain one two paths respectively group condition b invariant b maintained furthermore must ensure jo 0 j smaller joj 5 value jajd increases v v processed ie ja implies condition invariant b holds also v processed ie case 1 2g algorithm try combinations accepting rejecting unresolved paths subtrees rooted children v undetermined paths two possibilities accepting rejecting path groups exclusive paths two possibilities accepting lower path accepting higher path groups 2exclusive paths either four possibilities case pair independent groups exclusive paths shown fig 33 page accepting lower higher path one group lower higher path group two relevant possibilities cases shown fig 34 page 7 accepting lower higher path group exclusive paths contained group 2exclusive paths edgedisjoint path among remaining two paths note accepting path group exclusive paths remaining two paths blocks paths f two possibilities hence need consider third possibility accepting two edgedisjoint paths group hence number possible combinations bounded 2 k 4 o1 combination fl algorithm computes maximum number fl edgedisjoint paths p v intersecting u fl paths u v x v tentatively accepted combination let maximum u taken combinations fl note cardinality maximumcardinality subset edgedisjoint paths algorithm nothing proceeds next node otherwise distinguish following cases case 11 case 111 one equivalence class paths pick one say p arbitrarily make undetermined path hence u reject paths p v contains path p 0 6 p p v replace p 0 p obtain 0 order ensure j obviously invariants satisfied p v one equivalence class paths must edge e incident v shared paths p v consequence konig theorem make p v group deferred paths reserved edge e contain one path intersecting edge e either path p v path smaller level suffices remove path order obtain valid set 0 get invariants satisfied case 112 one child c v undetermined path p lca w subtree possibly algorithm nothing leaves p undetermined state p v 6 paths p v must intersect p edge say edge u w case intersect p edge w u symmetrical algorithm picks arbitrary path q p v makes fp qg group exclusive paths fixed edge u w hence paths p v rejected must ensure 0 contains p q order satisfy condition b invariant b contain path p v u v property e either q inserted removing one path smaller level contains path p 0 p v u v already path replaced p q invariants satisfied case 113 1 one child v group exclusive paths subtree path p v could combined path group exclusive paths obtain two edgedisjoint paths assumed must hence algorithm nothing node v leaves group exclusive paths intermediate state case 12 2 observe k 2 many subcases case 12 algorithm yield v 2 contains one path removing path two paths smaller level clearly sufficient obtain valid set 0 subcases therefore repeat argument every relevant subcase instead discuss case contains two paths case 121 subtree rooted child v contains group 2exclusive paths must path p v could combined two paths x v form set three edgedisjoint paths hence algorithm nothing node v leaves group 2exclusive paths unresolved state case 122 two children v whose subtrees contain group exclusive paths note case path p v could combined one exclusive path subtree obtain set three edgedisjoint paths edgedisjoint paths bidirected trees 11 e fig 35 case 1231 pv contains two edgedisjoint paths lefthand side case 1232 fixed edge e direction righthand side fixed edges groups exclusive paths point direction ie directed root leaves algorithm accepts lower paths groups exclusive paths higher paths rejected edge marked fixed anymore 0 three paths must removed obtain valid set 0 two paths groups exclusive paths contained one path smaller level using edge v pv whose direction opposite direction formerly fixed edges fixed edges groups exclusive paths point different directions ie one directed towards root one towards leaves groups represent pair independent groups exclusive paths algorithm create new group 2exclusive paths note contains two paths new group 2exclusive paths already contained one path two groups exclusive paths x v due condition b invariant b therefore set invariants satisfied case 123 one child v group exclusive paths subtree one child v undetermined path subtree paths p v must intersect undetermined path otherwise path p v could combined undetermined path exclusive path obtain set three edgedisjoint paths case 1231 two edgedisjoint paths p v case situation must shown lefthand side fig 35 two edgedisjoint paths must intersect group exclusive paths way blocks exclusive paths accepted cannot kinds paths p v algorithm accepts lower path group exclusive paths undetermined path rejects paths marked fixed anymore note combination two edgedisjoint paths p v u v x v blocks least three four top edges paths accepted algorithm hence contains two paths contain one path smaller level intersecting paths accepted algorithm suffices remove three paths obtain valid e e fig 36 cases 1232 b 1232 c fixed edge e different directions case 1232 paths p v intersect edge e undetermined path case 1232 direction e fixed edge group exclusive paths see righthand side fig 35 algorithm accepts undetermined path lower path group exclusive paths paths rejected edge marked fixed anymore contains two paths p v use fixed edge edge e one path blocked paths accepted algorithm path must use edge v pv direction opposite direction e thus suffices remove three paths obtain valid set 0 case 1232 b direction e different fixed edge path intersect higher exclusive path see lefthand side fig 36 algorithm uses x v p undetermined path together create new group 2exclusive paths consisting pair independent groups exclusive paths paths p v rejected algorithm addition fixed edge old group exclusive paths edge e marked fixed note contains one path x v due condition b invariant b contains undetermined path path p let contains path p p v replace path either p undetermined path one must possible contain path p v u v contains path p 0 using edge v pv direction given edge e replace p 0 either p undetermined path one two must possible contain path p v u v path using edge v pv direction given edge e add either p undetermined path case invariants satisfied particular jo case 1232 c direction e different fixed edge paths p v intersect higher exclusive path see righthand side fig 36 algorithm accepts undetermined path lower path group exclusive paths rejects paths marked fixed anymore contains two paths must contain least one two paths accepted algorithm path uses top edge path accepted algorithm contains one path smaller level intersecting paths accepted algorithm suffices remove three paths order obtain valid set 0 edgedisjoint paths bidirected trees 13epe pp c c c pp p c c c fig 37 case 1241 pv contains two edgedisjoint paths block exclusive paths case 124 one child c v group exclusive paths subtree denote higher lower path group exclusive paths p q respectively assume without loss generality fixed edge e 0 group exclusive paths directed towards root tree shown fig 37 note distinguish cases regarding maximum number edgedisjoint paths p v case 1241 two edgedisjoint paths p 1 p 2 p v must intersect exclusive paths way blocks accepted see fig 37 let p 1 intersect p let p 2 intersect q let c 0 6 c child v p 1 uses edges c v v c 0 let c 00 6 c child v p 2 uses edges c 00 v v c note c top edge p intersected p 1 e 1 let top edge q intersected p 2 e 2 contains two edgedisjoint paths every path p must either intersect edge e 1 intersect edge e 2 intersect p 1 p 2 latter case possible c 0 6 c 00 paths p v intersect e 1 use edges c v v c 0 paths p v intersect e 2 use edges c 00 v v c case p 0 must use shown righthand side fig 37 case 1241 paths p v intersect e 1 use edges c v v c 0 paths p v intersect e 2 use edges first assume paths p v intersect either e 1 e 2 note exactly two equivalence classes paths p v case see fig 37 lefthand side algorithm uses group exclusive paths one representative two equivalence classes paths p v create group 2exclusive paths paths p v rejected fixed edge e 0 group exclusive paths longer marked fixed instead edges e 1 e 2 marked fixed contains two paths p v x v one must x v due condition b invariant b replaced path new group 2exclusive paths otherwise possible remove path x v one additional path resulting set contains path p v x v one 14 erlebach k jansen path smaller level touching v path smaller level intersecting fixed edge new group 2exclusive paths property 2e two paths new group 2exclusive paths inserted set obtain 0 invariants satisfied assume path p 0 2 p v intersects neither e 1 e 2 noted must c 0 6 c 00 case p 0 must use edges fig 37 righthand side algorithm accepts lower path group exclusive paths path p 0 rejects paths edge marked fixed anymore note combination two edgedisjoint paths blocks least three four top edges paths accepted algorithm hence contains two paths contain one path smaller level intersecting paths accepted algorithm suffices remove three paths obtain valid set 0 case 1241 b least two equivalence classes paths p v intersecting higher path group exclusive paths algorithm accepts lower path group exclusive paths makes paths p v intersecting higher path group deferred paths paths p v x v rejected edge marked fixed anymore reserved edge group deferred paths top edge shared paths contains two paths p v x v note one two paths must x v due condition b invariant b two paths also block top edges lower path group exclusive paths hence cannot contain path smaller level intersecting lower path contain one path smaller level intersecting reserved edge newly deferred paths suffices remove three paths obtain valid set 0 case 1241 c one equivalence class paths p v intersecting higher path group exclusive paths least two equivalence classes paths p v intersecting lower path group exclusive paths algorithm accepts higher path group exclusive paths makes paths p v intersecting lower path group deferred paths paths rejected edge marked fixed anymore reserved edge group deferred paths top edge shared paths contains two paths note one two paths must x v due condition b invariant b two paths also block edge e 1 hence cannot contain path smaller level intersecting e 1 contain one path smaller level intersecting reserved edge newly deferred paths top edge higher path directed towards leaves paths must use edge pv v suffices remove three paths obtain valid set 0 case 1242 p v contain two edgedisjoint paths let e edge incident v paths p v use edge e case 1242 least two different equivalence classes paths algorithm makes paths p v new group deferred paths reserved edge e accepts q lower path group exclusive paths path p rejected edge subtree marked fixed anymore contains two paths p v x v paths block two three top edges blocked algorithm fixed edge e 0 group exclusive paths edge e contain one path smaller level fig 38 case 125 sets two edgedisjoint paths use four top edges left hand side case 125 b one equivalence class paths using edge e 1 one class using edge e2 righthand side intersects path accepted algorithm reserved edge new group deferred paths suffices remove three paths obtain valid set 0 case 1242 b e 6 v c 0 children c 0 6 c v p v one equivalence class paths path p intersect q algorithm accepts p 0 q paths p v intersect q algorithm accepts p arbitrary path p v cases paths p v x v rejected edge subtree marked fixed anymore 2 assume contains two paths p v x v show suffices remove three paths obtain valid set 0 algorithm accepted p must also contain p path p v thus blocking least three four top edges paths accepted algorithm one path blocked paths accepted algorithm assume algorithm accepted q observe two paths must also use edges e 0 e thus blocking two four top edges paths accepted algorithm e e 0 direction contain one path smaller level intersecting paths accepted algorithm path must use edge pv v p v one equivalence class paths paths p v x v block three four top edges paths accepted algorithm suffices remove one path smaller level finally consider case p v one equivalence class paths e v c since edge e blocks paths smaller level top edge q directed towards leaves two paths p v x v fact block least many paths smaller level three four top edges paths accepted algorithm case 125 must two edges incident v paths p v use least one two edges konig theorem let e 1 e 2 two edges case 125 possible sets two edgedisjoint paths p v use four edges incident v see lefthand side fig 38 example algorithm picks two arbitrary edgedisjoint paths p v accepts rejects paths p v contains two paths p v removing two paths sufficient obtain valid set 0 use top edges paths accepted algorithm cannot contain path intersecting paths accepted algorithm following let set paths p v intersect paths p v words path p 2 p v p v contain path q edgedisjoint p note case 125 apply follows either paths p v n using edge e 1 using edge e 2 must one fig 39 case 125 c configurations two groups deferred paths created equivalence class paths case 125 b one equivalence class c paths p v n using one equivalence class paths p v n using edge e 2 intersecting path c see righthand side fig 38 case e 1 e 2 exchanged symmetrical furthermore note case one equivalence class c paths p v n using edge e 1 one equivalence class paths p v n using edge e 2 intersecting path c satisfies condition case 125 algorithm picks path p c arbitrarily accepts p makes paths using edge e 2 intersecting p group deferred paths reserved edge e 2 paths p v rejected contains two paths p v paths must also use top edges p newly reserved edge thus removing two paths sufficient obtain valid set 0 case 125 c one equivalence class paths p v n using one equivalence class paths p v n using edge e 2 case 125 apply algorithm makes paths p v n using e 1 group deferred paths reserved edge e 1 paths p v n using e 2 group deferred paths reserved edge e 2 paths p v rejected note matter paths smaller level accepted algorithm later still two paths one two groups newly deferred paths edgedisjoint paths smaller level otherwise case 125 would apply 2 contains two paths p v paths use e 1 e 2 well removing two paths sufficient obtain valid set 0 cannot contain path intersecting reserved edge newly deferred paths case 126 one child v undetermined path p subtree let p 0 denote set paths p v intersect p begin making simple observations first p 0 v must contain two edgedisjoint paths hence must edge e incident v shared paths p 0 v second implies maximum number edgedisjoint paths p v two must two edges e 1 e 2 incident v every path p v uses least one two edges let lca undetermined path v 0 let c child v whose subtree contains undetermined path possibly v 0 undetermined path uses edges v 1 number subcases regarding number equivalence classes p 0 v case 126 p 0 v empty let p 1 p 2 denote sets paths p v intersect p edge v edge v respectively note algorithm accepts arbitrary path p p one equivalence class paths creates new group deferred paths p otherwise undetermined path p rejected edgedisjoint paths bidirected trees 17 v v v v v fig 310 case 127 v two children undetermined paths subtrees 2 contains two paths p v u v removing two paths sufficient block least many paths smaller level newly accepted paths newly reserved edges case 126 b p 0 v one equivalence class paths algorithm accepts arbitrary path p 0 v undetermined path p paths p v rejected assume contains two paths p v u v contains p must also contain path p 0 v suffices remove two paths obtain valid set 0 contain p contains path p 0 must also contain path p v intersects p two paths block least three four top edges blocked algorithm suffices remove two paths one path smaller level finally contains neither p path p 0 must contain two paths p v intersect p different top edges least one intersects also top edge paths suffices remove three paths obtain valid set 0 case 126 c p 0 v one equivalence class paths let e edge incident v shared paths p 0 v algorithm accepts undetermined path p creates new group deferred paths paths paths p v rejected 1 assume contains two paths p v u v contains p must also contain path v suffices remove two paths obtain valid set 0 contain p contains path p 0 must contain path p v intersects two paths block least two three top edges blocked algorithm suffices remove two paths one path smaller level finally contains neither p path p 0 must contain two paths p v intersect p different top edges two paths block least two three top edges blocked algorithm suffices remove three paths obtain valid set 0 case 127 two children v undetermined paths subtrees denote undetermined paths p q see fig 310 every path p v must intersect least one undetermined path addition two paths p v intersect one undetermined path different top edges least one must also intersect undetermined path let p 1 p 2 denote sets paths p v intersect p q respectively note case 127 edgedisjoint paths p 1 p 2 p v p 1 intersects p top edge e 1 intersect q p 2 intersects q top edge e 2 intersect p e 1 e 2 different directions ie one directed towards root directed towards leaves algorithm makes p q p 1 p 2 group 2exclusive paths consisting pair independent groups exclusive paths rejects paths p v edges e 1 e 2 marked fixed contains two paths new group 2exclusive paths already let otherwise possible replace paths paths new group 2exclusive paths obtain 0 case jo case 127 b condition case 127 hold algorithm accepts p q rejects paths p v contains two paths p v u v contains p q suffices remove two paths contains one p q say p must contain path p v intersects q two paths block three four top edges blocked algorithm contains neither p q must contain two paths p v least one two paths intersects p q two paths block least three four top edges blocked algorithm paths intersect one p q must case one intersects p edge e 1 one intersects q edge e 2 e 1 e 2 direction contain one path smaller level intersecting path accepted algorithm e 1 e 2 different directions condition case 127 applies case 13 3 algorithm accepts paths rejects paths subtree marked fixed anymore maximum number edgedisjoint paths contain paths p v u v x v furthermore contain two paths f using edges v pv pv v two paths could possibly blocked paths accepted algorithm hence valid set 0 obtained deleting paths invariants maintained case 2 2g case algorithm cannot try possibilities accepting rejecting unresolved paths polynomial time instead calculates four candidate sets edgedisjoint paths chooses largest obtaining two four sets employ method removing paths arbitrary set edgedisjoint paths p v exclusive paths x v accepted addition paths remaining resulting set edgedisjoint paths x v cardinality jsj r number paths removed details method proof presented later lemma 31 tool ready describe candidate sets 1 subset paths p v intersect undetermined path u v 1 compute maximum number 1 edgedisjoint paths p 0 v 1 obtained taking paths k undetermined paths many additional edgedisjoint paths x v possible undetermined paths least paths groups 2exclusive paths x v due property 2e 2 2 obtained 1 removing r 1 paths 2m exclusive paths accepted 2 contains 2m exclusive paths according lemma 31 r m3 1 paths removed obtain 2 2 still contains k undetermined paths addition js edgedisjoint paths bidirected trees 19 2 contains k undetermined paths u v exclusive paths 3 3 obtained first computing maximum number 3 edgedisjoint paths p v adding many edgedisjoint paths x v u v possible js 3 j 3 3 contains least paths groups 2exclusive paths x v due property 2e 4 4 obtained 3 removing r 3 paths 3 p v 3 2m exclusive paths accepted way 2 obtained 1 according lemma 31 js 4 j m23s 3 algorithm accepts paths set maximum cardinality rejects paths p v u v x v note v js 2 j maxf3 2g implies 2 v let number paths p v contained v intersect least one k undetermined paths observe v contain k gamma b 0 2 undetermined paths u v note maximum number edgedisjoint paths p v 3 maximum number edgedisjoint paths p 0 v 1 using jo using jo upper bound jo v j lower bounds cardinalities four sets prove least one sets satisfies jo suffices remove jo paths order obtain valid set 0 implies invariants maintained jo following cases case 21 ff 32 v js 3 use 31 v js 4 j bound ratio jo v v case 22 v js 3 use 31 v js 2 j bound ratio jo v v 20 erlebach k jansen c e fig 311 set edgedisjoint paths pv case 23 ff 43 31 get jo 2m shown jo holds subcases case 2 complete description case 2 still explain method removing paths 1 3 order obtain 2 4 respectively method takes arbitrary set edgedisjoint paths p v removes paths obtain set 0 every subtree exclusive paths touched one path 0 motivation cause paths group exclusive paths blocked two paths intersect corresponding subtree property e similarly one path group 2exclusive paths accepted must contain two paths p v intersect corresponding subtree property 2e method proceeds follows consider graph g paths vertices edge two paths touch child v g maximum degree two consists collection chains cycles note every edge g corresponds child v touched two paths interested maximal parts chains cycles consist entirely edges corresponding children v roots subtrees exclusive paths following possibilities parts cycle paths cycle endpoints subtree exclusive paths ii chain paths ends one endpoint subtree exclusive paths internal paths endpoints subtrees exclusive paths iii chain path one end one endpoint subtree exclusive paths paths endpoints subtree exclusive paths iv chain paths endpoints subtree exclusive paths note every maximal part cycle chain length number paths least two contains least one edge method removing paths proceeds follows cycles even length chains handled removing every path starting second path chains cycles odd length handled removing two consecutive paths one place every path rest cycle consider example depicted fig 311 node v eight children named h six c h roots subtrees exclusive paths indicated edgedisjoint paths bidirected trees 21 ea gh ad dc hf fg cb fig 312 graph g representing structure paths exclamation mark set edgedisjoint paths p v sketched graph g obtained set shown fig 312 label vertex g uw corresponding path begins subtree rooted u ends subtree rooted w respect iiv g contains cycle type length three containing paths f g gh hf chain type ii length three containing paths ad dc cb according rules given three paths would removed two paths say f g gh cycle path dc chain length three easy see process always ensures end contains subtree exclusive paths one path endpoint subtree hence due properties e 2e filled edgedisjoint exclusive paths contains exclusive paths lemma 31 let v node children exclusive paths let p v set edgedisjoint paths let 0 set paths obtained removing paths according method described let proof let number cycles type let 1 length ith cycle denote number chains type ii b lengths b 1 b denote number chains type iii c lengths c denote number chains type iv lengths note number paths contained union chains cycles p furthermore considering number children exclusive paths covered chain cycle obtain p latter inequality adding two inequalities obtain p taking account p sigma iupsilon c da 2e 23a 2 lemma follows example displayed fig 311 sufficient remove 3 35 runningtime algorithm runningtime algorithm polynomial size input fixed 0 exponential 1 let bidirected tree e n nodes set p containing h directed paths path specified endpoints given arbitrary 0 claim approximation algorithm implemented run time details implementation well experimental results reported 9 22 erlebach k jansen note choose n still achieve runningtime polynomial size input resulting algorithm achieves approximation ratio therefore asymptotic approximation ratio 53 optimal solution contains many paths n must also large approximation ratio gets arbitrarily close 53 4 generalizations several generalizations medp first meaningful consider weighted version problem path certain weight goal maximize total weight accepted paths weighted version medp still solved optimally polynomial time bidirected stars spiders reduction maximumweight matching bipartite graph bidirected trees bounded degree minor modification dynamic programming procedure given x2 another generalization medp maxpc problem given bidirected tree set p directed paths number w colors maximum path coloring maxpc problem compute subset p 0 p w coloring p 0 goal maximize cardinality p 0 maxpc problem equivalent finding maximum induced w colorable subgraph conflict graph given paths studying maxpc motivated admission control problem alloptical wdm wavelengthdivision multiplexing networks without wavelength converters every wavelength color used establish set connections provided paths corresponding connections edgedisjoint number available wavelengths limited 5 weighted variant maxpc interesting well maxpc weighted maxpc solved optimally polynomial time bidirected stars using algorithm weighted version capacitated bmatching problem 15 pp 257259 number w colors maximum degree bidirected tree bounded constants maxpc weighted maxpc solved optimally polynomial time dynamic programming similar procedure x2 maxpc nphard arbitrary w bidirected binary trees path coloring nphard bidirected trees arbitrary degree equivalent medp case order obtain approximation algorithms maxpc arbitrary number w colors technique due awerbuch et al 1 employed allows reducing problem w colors medp small increase approximation ratio technique works maxpc arbitrary graphs g discuss trees let instance maxpc given bidirected tree set p paths number w colors approximation algorithm arbitrary number w colors obtained approximation algorithm 1 one color ie maximum edgedisjoint paths problem running w copies 1 giving input ith copy bidirected tree set paths accepted first copies 1 see fig 41 output union w sets paths output copies 1 paths ith set assigned color 1 shown algorithm obtained using technique approximation ratio ae 1 1 approximation ratio ae even different colors associated different network topologies identical networks application approximation ratio achieved even bounded aew smaller 11 gamma e gamma1ae w bound mentioned journal version 1 viewed adaptation similar result 6 proved easily using fact selected p k paths algorithm input bidirected tree set p paths number w colors output disjoint subsets p 1 p w p p edgedisjoint begin w begin fig 41 reduction many colors one color running k copies 1 still set least jp among remaining paths next copy 1 accepts least 1aefraction number reduction works also weighted case since optimal algorithm medp bidirected trees bounded degree 53 approximation algorithms medp arbitrary bidirected trees employ technique obtain approximation algorithms bidirected trees bounded degree ratio approximately 222 maxpc arbitrary bidirected trees acknowledgments authors grateful stefano leonardi pointing reduction maxpc arbitrary number colors maxpc one color adi rosen informing improved analysis ratio obtained reduction case identical networks colors supplying preliminary draft journal version 1 r competitive non graphs hypergraphs special issue dense wavelength division multiplexing techniques high capacity multiple access communication systems location bank accounts optimize float analytic study exact approximate algorithms structure approximation classes call scheduling trees optimal wavelength routing directed fiber trees optimal greedy algorithm wavelength allocation directed tree networks colouring paths directed symmetric trees applications wdm routing efficient wavelength routing directed fiber trees maximum bounded 3dimensional matching max snpcomplete approximation algorithms disjoint paths problems approximating disjointpath problems using greedy algorithms packing integer programs note optical routing trees improved access optical bandwidth trees efficient access optical bandwidth computational complexity improved approximations edgedisjoint paths tr ctr thomas erlebach klaus jansen implementation approximation algorithms weighted unweighted edgedisjoint paths bidirected trees journal experimental algorithmics jea 7 p6 2002 r sai anand thomas erlebach alexander hall stamatis stefanakos call control k rejections journal computer system sciences v67 n4 p707722 december thomas erlebach klaus jansen conversion coloring algorithms maximum weight independent set algorithms discrete applied mathematics v148 n1 p107125
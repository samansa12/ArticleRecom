inheritancebased subtyping play dual role mainstream statically typed objectoriented languages serving object generators object types languages inheritance implies subtyping contrast theoretical language community viewed linkage mistake focused subtyping relationships determined structure object types without regard underlying implementations paper explore inheritancebased subtyping relations useful describe two different approaches extending moby programming language inheritancebased subtyping relations addition present typed object calculus supports structural inheritancebased subtyping provides formal accounting extensions moby b introduction great divide study foundations objectoriented languages practice mainstream objectoriented languages like javaag98 c str97 one striking examples divide role class inheritance plays defining subtyping relations foundational descriptions oo languages language designs studies informed inheritance define subtyping relation whereas languages like java c inheritance defines subtyping hierarchy interesting distinction certain id ioms friend functions binary methods natural express inheritancebased subtyping framework require substantial complication handle structural subtyping framework paper explore inheritancebased subtyping relations useful present formal accounting small language supports subtyping relations begin examining common objectoriented idiom friend functions exploring one might implement idiom moby fr99a language structural subtyping example illustrates deficiency relying solely structural subtyping language design describe extension moby section 3 adds class types inheritancebased subtyping moby show extension supports number common idioms friend functions binary methods object cloning present xmoc section 4 object calculus supports structural inheritancebased subtyping well privacy xmoc provides model type system extended moby prove subjectreduction type system validate design extended moby section 5 describe related work conclude section 6 2 problem friends c java mechanisms allow classes functions greater access privileges classs members others c class grants access declaring certain classes functions friends java members annotated public protected private visible classes package outside package section examine support idiom moby language structural subtyping type rep bag objtype bag meth add int unit val union rep rep unit val mkbag unit rep class bag public field items var listint public meth add selfitems x selfitems public maker mk field items nil objtype objtype bag meth add int unit listapp s1add s2items fun mkbag new mk figure 1 bags friends using type abstraction flexible control classmember visibility fr99a include brief description moby appendix study demonstrates possible encode friends idiom language structural type relations resulting encoding appealing 21 friends via partial type abstraction standard way program friends use partially abstract types pt93 klm94 example figure 1 gives moby code implementation bag class union function friend example ascribed bagm module signature makes rep type partially abstract modules clients outside module object type rep use union function add method since rep subtype bag cannot access items field inside module rep type allows access members bag class 1 implementation union function exploits access unfortunately approach works final classes want extend bag class must reveal class signature bagm module done figure 2 version object created using mk maker cannot used argument union function rep type limitation also applies objects created subclasses bag 22 friends via representation methods support friends class extension class requires public mechanism mapping object abstract representation type mechanism recover representation type required friend functions example suppose extend bag class include method returns number items bag call new class cbag counting bag want use union function objects created cbag class figure 3 presents new implementation notice added public method bagrep interface bag 1 moby notation typeofc shorthand object type consists public members class c type rep typeofbag class bag public meth add int unit public maker mk unit val union rep rep unit val mkbag unit rep figure 2 revealing bag class class returns self representation type rep apply union function two bags b1 b2 write bagunion b1bagrep b2bagrep expression works even b1 andor b2 counting bags also note items field public inside bagm module part bags interface outside module example objects created subclasses bag subtypes rep although example include friends cbag class included representation method interface illustrates main weakness approach namely level class hierarchy must add representation types methods methods pollute method namespace effect partially encode class hierarchy object types furthermore suffers sourcecode version fragile baseclass problem refactor class hierarchy add new intermediate class add new representation method changes types objects created point hierarchy encoding approach appears adequate examples require strong connection implementation types awkward unpleasant 3 extended moby previous section showed use abstract representation types representation methods tie object types specific classes programmers perspective natural approach make classes serve role types connection needed section present extension moby fr99a supports class types inheritancebased subtyping intuitively object class type c object instantiated c one descendants inheritancebased subtyping form byname subtyping follows inheritance hierarchy illustrate extension using several examples 31 adding inheritancebased subtyping inheritancebased subtyping requires four additions mobys type system well couple changes existing rules ffl class c define c class type used type context module bagm type rep typeofbag class bag public meth add int unit public meth bagrep unit rep public maker mkbag unit val union rep rep unit class bag public field items var listint public meth add selfitems x selfitems public meth bagrep rep self public maker mkbag field items nil objtype listapp s1add s2items module type rep typeofcbag class cbag public meth add int unit public meth bagrep unit bagmrep public meth size unit int public meth cbagrep unit rep public maker mkcbag unit class cbag inherits bagmbag public field nitems var int public meth add selfnitems selfnitems1 public meth size int selfnitems public meth cbagrep rep self public maker mkcbag super mkbag field nitems objtype figure 3 bags friends using representation methods class b public meth m1 int public meth m2 class c public meth m2 public meth m1 bool maker mkc unit figure 4 example reusing private method name cs scope note meaning class type depends context inside method body class type host class allows access members whereas outside class public members accessed ffl extend class interfaces allow optional inherits clause given context class c interface includes inherits b clause view c subtype b omitting inherits clause cs interface causes relationship b c hidden ffl say c subtype relation corresponds fishers observation implementation types subtypes interface types fis96 ffl existing typing judgements method field selection require argument object type add new judgements case argument class type add new rules instead adding subtyping existing rules avoid technical problem described section 32 ffl typing methods class c give self type c likewise b cs superclass super type b ffl typing new expression assign corresponding class type result 32 inheritancebased subtyping vs privacy potential problem extended moby type system interaction inheritancebased subtyping mobys support privacy moby allows signature ascription hide object members eg items field figure 2 c subtype b even typeofc subtype typeofb problem arises case class c defined method name one bs private methods consider code fragment figure 4 example 2 given definitions typecheck expression new mkcm1 allow subtyping lefthand side method selection two incompatible ways example uses class interface annotation class b syntactic form avoids need wrap b module signature hide m2 meth module bagm class bag public meth add int unit public maker mkbag unit val union bag bag unit class bag public field items var listint public meth add selfitems x selfitems public maker mkbag field items nil listapp s1add s2items module class cbag inherits bagmbag public meth size unit int public maker mkcbag unit class cbag inherits bagmbag public field nitems var int public meth add selfnitems selfnitems1 public meth size int selfnitems public maker mkcbag super mkbag field nitems figure 5 bags friends extended moby typecheck expression avoid ambiguity different rules case lefthand side class type vs object type 3 33 friends revisited revisit bag class example using inheritancebased subtyping features extended moby new implementation see figure 5 use class type bag instead rep type allows us simplify code eliminating rep type representation method note interface cbag class includes inherits clause specifies subclass bag relation allows union function used values cbag type 3 note moby typing rules include subsumption rule class public meth getx unit int public meth clone unit b public maker mkb int maker copyb b public meth getx int selfpvtx public meth clone b new copybself public maker mkb field field maker field class c inherits b public meth clone c new copycself public maker mkc int super mkby maker super copyborig figure cloning privacy extended moby 34 binary methods binary methods methods take another object class argument bcc number different flavors binary methods depending objects subclasses treated using class types implement binary methods require access private fields argument objects example union function previous example implemented binary method follows class bag field items var listint public meth add selfitems x selfitems public meth union listapp selfadd sitems public maker mkbag field items nil object cloning another case inheritancebased subtyping useful typing copy constructors used implement userdefined object cloning mechanism 4 figure 6 gives example cloning extended moby class b private field pvtx makes object types insufficient type check cs use copyb maker function problem arises object type associated self typechecking c pvtx field field private b copyb maker function requires one thus need inheritancebased subtyping relationship allow copyc maker pass self typed c parameter copyb maker 4 note moby constructors called makers signature hasshow type initb class meth show unit string maker mk initb module class pr inherits mb public meth print unit consoleioprintselfshow maker super mkx class public meth show string hi public meth anothermeth unit maker mk module class pra inherits ppr public meth anothermeth unit self aanothermeth figure 7 encoding mixins extended moby know c inherits b application typechecks also exploit subtyping relation override clone method 36 encoding mixins moby support form multiple inheritance combination parameterized modules class types possible encode mixins bc90 fkf98 encoding mixin implemented class parameterized base class using parameterized module class interface base class contains components necessary mixin applying mixin particular base class create new class inherits mixed base class uses class types reconstitute methods base class hidden result module application without class types would possible make original classs methods visible example figure 7 gives encoding mixin class adds print method class show method applying printmix class define class pra reconstitutes anothermeth method notice need use explicit type constraint convert type self pra since subtyping method dispatch encoding cumbersome illustrates power class types also might serve definition derived form supported mixins directly class c oe e x new ce figure 8 syntax xmoc terms 37 efficiency method dispatch although main motivation worth noting method dispatch field selection object class type implemented easily constant time operation dispatched method final class type compiler eliminate dispatch altogether call method directly contrast object object type compiler knows nothing layout object making access expensive even exact layout class known abstraction eg mixin encoding previous section implement dispatch objects class type two memory references indirect jump frr99 developed functional object calculus called xmoc models type system extended moby validates design xmoc supports traditional structural subtyping inheritancebased subtyping section discuss intuitions behind xmoc state subject reduction results space considerations preclude detailed presentation full system given appendices b c 41 syntax term syntax xmoc given figure 8 xmoc program consists sequence class declarations terminated expression class declarations come two forms first class c declared inherit parent class b b none say c baseclass class parameterized x whenever object constructed c x bound supplied initial value second form class declaration class c derived existing class c 0 classinterface ascription produces class inherits implementation c 0 restrictive class interface oe class interface gives type class parameter name nearest revealed ancestor class none typed list available methods types include type variables function types recursive object types class types class declaration denote base class either special symbol none name base class applied argument method takes single parameter expression body syntax expressions e includes variables functions function application new object creation special variable self allowed inside method bodies method dispatch last expression form e c objectview coercion unlike extended moby xmoc map inheritance relation directly subtyping relation instead rely objectview coercions explicitly coerce type expression class one superclasses approach avoids problem discussed section 32 without requiring two typing judgements method dispatch possible automatically insert coercions xmoc representation program part typechecking translation similar typedirected representation wrapping done polymorphic languages ler92 42 dynamic semantics evaluation xmoc program occurs two phases first phase defined class linking relation written k p ae k takes dynamic class environment k links leftmost class definition p produce k 0 class linking terminates residual expression class declarations linked second phase evaluates residual expression value assuming termination phase defined expression evaluation relation write defining semantics linking evaluation requires extending term syntax runtime forms correctly handling classinterface ascription provides greatest challenge defining semantics xmoc using mechanism public method b made private subclass c subsequently reused name unrelated method descendant class c recall example figure 4 methods inherited b must invoke original method send message self methods defined must get new version one solution problem use rieckestone dictionaries semantics rs98 fr99b dictionaries provide ffconversion needed avoid capture mapping method names slots xmoc use related technique call views process class c tag method newly defined c label c using notation c inherited overridden methods retain existing labels furthermore replace occurrence self cs new overridden methods object view self c rule 4 appendix b describes annotation formally runtime represent object pair raw object denoted metavariable obj view denoted class name raw object contains list annotated methods implemented object view represents visibility context message send occurs methods scope class c available information check two conditions lookup method runtime object hobj ci first list methods provided obj second c descends class annotating method two conditions met return associated method otherwise search portion object inherited base class rules 1 2 appendix formally specify method lookup 43 static semantics xmoc typing judgements written respect static environment gamma consists set bound type variables subtype assumption map class environment c variable environment v definition environments complete set xmoc typing judgements given appendix c briefly discuss important rules mentioned earlier xmoc class name doubles object type associate type object whenever instantiate object class according typing rule c gammac new ce c looks class c gamma infers type 0 constructor argument e insures type subtype type class parameter contexts allow subtyping treat class type object type according following subtyping judgement rule corresponds property c subtype typeofc extended moby note ff cannot occur free types object type obj subject recursive winding unwinding unlike extended moby treat class type c subtype superclass type instead use object view constraint typed follows treat inheritance directly subtyping xmoc need one rule typing method dispatch 44 subject reduction proven subject reduction theorems xmoc first states linking relation produces dynamic class environment consistent static environment defined program linking change type program theorem 1 fg fg fg fg p gamma fg p ae k e gamma k gamma k e second theorem states welltyped expression evaluations expression compatible type theorem say program p yields value w k exists expression e given definition characterize complete evaluation program theorem 3 fg fg fg fg p gamma p yields w k gamma k w 0 5 related work class types motivated role classes play languages like c java main difference extended moby class types provided languages way abstraction supported extended moby allows partial hiding inherited components using signature ascription means typeofc may subtype typeofb even c known inherit b see section 32 related mechanism c private inheritance allows subclass inherit base class hiding inherited members concealing subtyping relationship extended moby flexible since allows hiding permember basis extended moby also allows class hierarchy hidden omitting inherits clause class interfaces c java full class hierarchy manifest class types except classes related using c private inheritance another point difference extended moby supports structural subtyping object types java object types called interfaces subtyping byname c independent notion object type fishers phd dissertation fis96 earliest formalization class types aware work class tagged row variable using form bounded existential row work adopt classes primitive notion use names classes fashion analogous fishers row variables weakness earlier work treatment private names provides way hide method later add unrelated method name use class names label methods object value xmoc see appendix b similar use role tags methods ghelli palmerinis calculus modeling objects roles gp99 likewise pairing objects state class name defines current view object similar representation object values main difference xmoc calculus surface language features modeled recently igarashi et al described featherweight java object calculus designed model core features javas type system ipw99 like calculus featherweight java notion subtyping based class inheritance calculus richer however number ways calculus models private members narrowing class interfaces also notion structural subtyping relate implementation structural subtyping notions notion type identity based implementation present original definition standard ml form structure sharing mth90 benefits structure sharing fairly limited dropped 1997 revision sml mthm97 6 conclusion paper presents extension moby supports classes types illustrated utility extension number examples also developed formal model extension proven subject reduction continuing work improving formal treatment class types implementationbased inheritance 5 one minor issue xmoc requires 5 since paper written developed elegant treatment xmoc based rieckestone dictionaries proven type soundness paper describing revised system available moby web page httpwwwcsbelllabscomjhrmoby class names unique program restriction avoided introducing mechanism stamps distinguish toplevel names eg see leroys approach module system semantics ler96 would also like generalize rule relates class types object types rule appendix c allow positive occurrences c replaced object types bound type variable believe generalization sound yet proven r java programming language hopkins object group type systems objectoriented programming languages classes mixins design class mechanism moby foundations moby classes calculus compiling linking classes foundations extensible objects roles featherweight java minimal core calculus java gj type system prototyping languages unboxed objects polymorphic typing syntactic theory type generativity sharing definition standard ml definition standard ml revised year1997year statically typed friendly functions via partially abstract types privacy via subsumption tr mixinbased inheritance unboxed objects polymorphic typing type system prototyping languages binary methods classes mixins java programming language 2nd ed design class mechanism moby featherwieght java c programming language third edition definition standard ml definition standard ml type systems objectoriented programming languages
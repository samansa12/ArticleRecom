chainsplit evaluation deductive databases abstractmany popularly studied recursions deductive databases compiled one set highly regular chain generating paths consists one set connected predicates previous studies chainbased query evaluation deductive databases take chain generating path inseparable unit evaluation however recursions especially many functional recursions whose compiled chain consists infinitely evaluable functions evaluated chainsplit evaluation splits chain generating path two portions evaluation immediately evaluable portion delayedevaluation portion paper necessity chainsplit evaluation examined points view efficiency finite evaluation three chainsplit evaluation techniques magic sets buffered evaluation partial evaluation developed study shows chainsplit evaluation primitive recursive query evaluation technique different kinds recursions implemented efficiently deductive databases extensions existing recursive query evaluation methods b introduction regular chain forms 8 9 21 interesting recursive query evaluation techniques 2 transitive closure algorithms 10 magic sets counting 1 applied efficient evaluation compiled chains deductive databases however interesting observe recursions especially many recursions containing function symbols may often evaluated appropriately different evaluation technique chain split evaluation like many researchers 2 21 assume deductive database consists three parts extensional database edb set data relations ii intensional database idb set hornclause rules iii set integrity constraints ics definition 11 predicate said imply predicate r r horn clause idb predicate r head body predicate r transitivity predicate r recursive r r r mutually recursive deduction level otherwise r r lower deduction level definition 12 rule linearly recursive body contains exactly one recursive predicate predicate defined deduction level head predicate rule nested linearly recursive body contains one recursive predicate one defined deduction level head predicate rule nonlinearly recursive recursive belong two categories definition 13 recursion single linear recursive predicates deduction level every recursive predicate defined one linearly recursive rule possibly nonrecursive exit rules recursion multiple linear recursive predicates deduction level every recursive work supported part natural sciences engineering research council canada grant opg 3723 research grant centre systems science simon fraser university preliminary version paper appeared proceedings 8th international conference data engineering tempe az february 1992 author school computing science simon fraser university burnaby bc canada v5a 1s6 predicate defined one linearly recursive rules least one defined multiple linearly recursive rules possibly nonrecursive rules recursion nested linear every recursive predicate recursion defined one linearly nested linearly recursive rule least one defined nested linearly recursive rule possibly nonrecursive rules recursion nonlinear contains nonlinearly recursive rules recursion functionfree contain function symbols otherwise function bearing functional example 11 rule set f11 12g defines popular functionfree linear recursion sg indicates generation relatives siblings parents generation relatives notations adopted similar datalog 21 recursion compiled highly regular compiled chain form 9 shown 13 2 parent x denotes disjunction parent x parent x ae true parent definition 14 chain length k k 1 sequence k predicates following properties 1 predicates name say p lth p chain denoted p l 2 least one identical variable every two consecutive predicates variable position first predicate j variable position second variables two positions identical ith variable p l identical jth variable p l1 every l 1 l k gamma 1 predicate p l called chain predicate chain generating path consists sequence connected predicates ie predicates contain shared variables unitlength chain trivially chain generating path 0length chain defined tautology linear recursion nchain recursion positive integer k exists kth expansion recursion consisting one chain synchronous length chains length greater k possibly predicates form nontrivial chain singlechain recursion multichain recursion otherwise recursion bounded equivalent set nonrecursive rules compiled nchain recursion rewritten form normalized linear recursion 9 consists set exit rules one normalized recursive rule form 14 x variable vectors c 1 n chain predicate notice chainpredicate c may null sense c predicate exit variable otherwise chain variable chain predicate c rule set f11 12g normalized form recursive rules complex variable connections normalized compilation process 9 normalization greatly facilitates systematic analysis recursions binding propagation regularities previous studies 8 9 show linear recursion compiled bounded recursion nchain recursion many kinds recursions also compiled chain forms compiled chain form viewed alternatively one set normalized recursions study focused chainsplit evaluation compiled normalized recursions 11 chainsplit efficient evaluation usually singlechain recursion evaluated efficiently transitive closure algorithm 10 multichain recursion magic sets counting 1 2 one may wondered whether queries multichain recursions evaluated efficiently merging multiple chain generating paths one applying transitive closure algorithms 11 however since multiple paths share variables merge implies iterative processing crossproducts several relations corresponding path terribly inefficient perform iterative evaluation crossproduct two database relations 14 contrast merging multiple chains one may split chain multiple chains evaluation split implies nchain recursion evaluated sophisticated n evaluation technique chainsplit improve performance query evaluation examine example example 12 suppose recursion scsg samecountry samegeneration relatives defined rule set f15 16 17g definition similar sg 2 except parents pair scsg must born country birth merged parentsx merged parents x since country connects two parentpredicates 15 three predicates merged one merged parents shown 18 compilation derives singlechain shown 19 country predicate provides weak restriction relation merged parents much smaller crossproduct two parent relations obviously would efficient split merged parents two subchains evaluation query 110 magic sets method encounters problem recursion since country links two parent predicates body recursive rule binding propagation merges nonrecursive predicates one 21 derivation magic sets requires iterative computation crossproductlike relation merged parents easily seen adorned rules 111 112 2 2 parent bf x parent fb 1 scsg bb x parent bf x parent bb 1 scsg bb x 12 chainsplit finite evaluation recursions containing functions evaluable predicates chainsplit evaluation may play another important role transforming infinitely evaluable program finitely evaluable one facilitate analysis functional recursions functionpredicate transformation performed maps function together functional variable predicate called functional predicate functional variable variable unifies returned values function function arity n transformed predicate last argument representing functional variable example transformed fx similar transformation also discussed researchers 12 15 17 since transformation maps functional logical rule functionfree one analysis functional recursion performed framework functionfree one notice transformation converts constructors predicates since constructors mainly serve constraints unification process transformation merely delays constraint solving unification transformation theoretically sound however transformed functional predicate usually represents potentially infinite relation constructible corresponding termlist construction function cons etc computable corresponding computational function sum etc relation cannot represented finite edb relation thus evaluation functional predicate still relies corresponding function definition facilitate compilation analysis logic programs rules different forms rectified 21 rules predicate p rectified functions rules mapped corresponding functional predicates functionpredicate transformation heads rules identical form example 13 functional linear recursion append defined rule set 113 114 xjl 1 denotes list construction function corresponding functional predicate consx l 1 l represents resulting list l formed taking x head l 1 remaining resulting list rule set rectified f115 116g compiled 117 9 cons functional predicate list construction function notice rectified rule set also normalized rule set recursion 9 appendu appendu appendu cons cons ae true cons since two cons predicates connected body 116 merged one merged cons shown 118 merged u w instantiated query gamma appenda b v b c iterative evaluation merged cons proceeds successfully however one u w instantiated evaluation merged cons cannot proceed since encounter infinitely evaluable predicates take query gamma appenda b c w example evaluation first chain generating path first cons consx finitely evaluable instantiation derives x unfortunately second cons consx 1 finitely evaluable instantiation however chain predicate merged cons split two subchains first subchain evaluated first result passed via body exit rule 115 instantiate second argument second subchain thus recursion finitely evaluable chainsplit evaluation 2 since chainsplit evaluation may lead efficient andor finite query evaluation worthwhile study chainsplit evaluation techniques remaining paper organized follows conditions query requires chainsplit evaluation examined section 2 techniques chainsplit evaluation studied section 3 extension chainsplit evaluation techniques complex classes recursions examined section 4 discussion summarized section 5 chainsplit evaluation applied section 1 shows chainsplit may sometimes lead efficient andor finite evaluation interesting examine conditions chainsplit evaluation applied discussion based analysis two different kinds chain split efficiencybased chainsplit finitenessbased chainsplit 21 efficiencybased chainsplit chain generating path contains neither functions evaluable predicates chainsplit evaluation performed split may lead efficient query evaluation plans evaluating components chain together ie chainfollowing general decision made based quantitative analysis competitive query evaluation plans chainfollowing vs chainsplit based upon size potential intermediate relations available accessing paths cost estimation functions database statistics 13 18 following quantitative measurements introduced discussion definition 21 propagation ratio ff xw relation p defined ratio number distinct values attribute w denoted nw attribute x denoted nx data relation join expansion ratio fi xy join expression join attribute variable vector shared predicates p q potential number distinct hx pairs generated distinct w join general formula 22 derived based following reasoning one distinct w value corresponds average ff wx distinct xs relation p ff wy distinct relation q w join attribute relations p q join two relations pairs distinct xs according definition join thus potential number distinct hx pairs generated w join ff wx theta ff wy notice imply number tuples relation xy p 1 q nw theta fi xy different w may share hx pairs nevertheless fi xy good indicator approximate size join relation example 21 predicate countryx defined example 12 suppose corresponding data relation birth countryx w bxw let nx 100000 nw 50 propagation ratio ff 2000 join expansion ratio fi ff wx thetaff indicates join two predicates birth countryx w birth countryy w may expect generate 4 million tuples distinct w one cannot expect weak binding propagation may lead efficient processing 2 general suppose compiled form nchain recursion 23 one chain generating path form px two predicates p q connected via set predicates predicate pair variables x igamma1 x linking corresponding variables consecutive chain generating paths chain notational convention p represents relation predicate p jp j size relation p measured number tuples relation etc examine chain generating path split evaluation efficiencybased chainsplit following heuristic heuristic efficiencybased chainsplit following evaluation strategy adopted evaluation chain generating path px compiled form 23 performed 1 chain evaluated evaluation exit portion body exit rule 2 instantiations x 0 0 highly selective 3 fi x0y0 1 ffl case 2 otherwise chainsplit evaluation performed x 0 0 highly selective fi x0y0 ae 1 ffl case 3 otherwise perform detailed cost analysis determine whether chainsplit benefits evaluation rationale chainsplit evaluation splits chain two connected subchains one evaluated first buffered evaluation exit portion passes bindings buffered chain obviously chainsplit performed chain downchain ie chain evaluated evaluation exit portion 2 suppose evaluation starts chain path p instantiated proceeds towards exit portion e chains compiled recursion efficient evaluation important examine size chain relation p x size ie number tuples chain relation cannot beneficial similarly x 0 0 highly selective evaluation entire chain generating path generates large relation one x 0 0 highly selective fi x0y0 ae 1 case 2 merged parents relation example 12 chainsplit evaluation performed evaluation split chain lead relatively efficient evaluation otherwise obvious method chainsplit chainfollowing efficient case 3 detailed cost estimation performed compare approximate size cost evaluation p 1 vs p 1 accomplished quantitative analysis two expressions incorporation available accessing structures database statistics etc 13 2 heuristic indicates easy judge obvious cases whether chainsplit evaluation applied based join expansion ratio selectivity provided query constants however detailed quantitative analysis performed nonobvious cases analysis similar query plan generation access path selection developed studies relational deductive query processing 21 13 presented detail study 22 finitenessbased chainsplit compiled functional recursion chain generating path may contain functions evaluable predicates defined infinite domains ensure evaluation generates answers terminates three issues examined 1 finite evaluability evaluation every ith formula compiled form generates finite intermediate relations 2 chainlevel finite evaluability evaluation chain generating path generates finite intermediate relations 3 termination evaluation generates answers terminates finite number iterations finitenessbased chainsplit based analysis first two issues justification finite evaluability relies query information finiteness constraints finiteness constraint predicate r implies value attribute x corresponds finite set values r 6 finiteness constraint strictly weaker functional dependency studied database theory 21 holds trivially finite predicates since edb relations finite arguments edb relations satisfy finiteness constraint functional predicate fx domains arguments finite v must finite matter whether f single multiplevalued function x specific finiteness constraints explored specific functions many cases one argument function computed values arguments value function example functional predicate sumxyz argument finitely computed two arguments finite relationship represented set finiteness constraints x z z x interesting finiteness constraint z x holds functional predicate consx z indicates list z finite finite number choices x since query constants may bind infinite domains variables finite ones analysis finite evalua bility incorporate query instantiation information similar notations used magic sets transformation 2 21 superscript b f used adorn variable indicate variable bound finite string bs fs used adorn predicate indicate bindings corresponding arguments algorithm 21 testing finite evaluability query nchain recursion input 1 nchain recursion consisting nchain recursive rule set exit rules 2 set finiteness constraints 3 query instantiation information output assertion whether query finitely evaluable ffl initialization variable finite edb predicate equivalent one set constants ffl test finite evaluability 1 exit rule set 2 first expanded exit rule set rule set obtained unifying nchain recursive rule exit rule set done pushing query binding information rules tested propagating finiteness bindings iteratively based following two finiteness propagation rules 1 finiteness constraint x 2 ffl return yes every variable two sets rules tested finite finiteness binding propagation otherwise remark 21 algorithm 21 correctly tests finite evaluability nchain recursion ok 2 time worst case k number predicates recursion rationale initialization query constant propagation variables edb predicates equivalent one set constants including query constants constants body rule finite propagate finiteness bindings body recursive exit rule according two finiteness propagation rules algorithm every variable predicate p finite propagation p removed list predicates tested iteration least one predicate removed list predicates tested otherwise rule finitely evaluable since initially k predicates body rule second iteration need test predicates total number predicates tested worst case sigma i0 12 thus worst case time complexity algorithm ok 2 notice recursive rules exit rules finitely evaluable recursion finite evaluable induction since nth iteration may treat derived previous gamma 1 iterations finite base relation derivation 2 algorithm 22 finitenessbased chainsplit chain generating path nchain recursion input 1 chain generating path compiled nchain recursion 2 set finiteness constraints 3 query instantiation information output finitenessbased chainsplit evaluation plan compiled chain nchain recursion ffl application algorithm 21 query finitely evaluable algorithm 21 returns otherwise proceed following steps ffl initialization variable finite edb predicate ii equivalent one set constants ffl propagation finiteness bindings chain generating path according two finiteness propagation rules algorithm 21 every variable chain generating path finite finiteness binding propagation chainlevel finitely evaluable otherwise path split two aportion bportion former consists set predicates every variable finite latter consists remaining set predicates chain generating path chainsplit evaluation performed first evaluating subchain formed aportion bportions evaluating exit portion remark 22 algorithm 22 determines correctly whether chainsplit evaluation performed based finite evaluability chaingenerating path split rationale query finitely evaluable iterative evaluation performed thus step 1 necessary query finitely evaluable chain generating path chain generating path split two portions immediately evaluable portion buffered portion evaluation evaluable portion chain exit portion binding obtained must make buffered portion finitely evaluable otherwise query finitely evaluable thus algorithm 2 example 22 predicate appendu v w 2 possible query binding patterns bbb bbf bfb bff fbb fbf ffb fff among eight patterns bff fbf fff finitely evaluable bbf fbb ffb require chainsplit remaining two require chainsplit one case presented query binding pattern ffb gamma appendu v b finitely evaluable variables exit rule first expanded exit rule adorned b binding propagation adornment transformation binding propagation first expanded exit rule presented 24 notation adornment ffb bbb indicates initial adornment ffb changed bbb binding propagation append ffbbbb u v w binding propagation proceeds follows 1 u 1 w adorned b according instantiations exit rule query 2 x 1 w 1 adorned b w b exists finiteness constraint w 3 v adorned b since finally 4 u adorned b x b since every variable rule adorned b binding propagation query finitely evaluable furthermore algorithm 22 asserts chainsplit evaluation performed chain generating path w b makes consx 1 finitely evaluable shown cons ffb x 1 cons bff x 1 therefore chain split two evaluated first conspredicate delayed first subchain exit portion evaluated adorned normalized linear recursive rule written chainsplit form follows append ffb u v w cons ffb x 1 cons bbf x 1 rewritten rule indicates doublecons chain split two subchains one subchain represented consx 1 evaluated first consx 1 delayed exit rule evaluated 2 3 chainsplit evaluation techniques two typical evaluation methods magic sets counting 2 evaluation nchain recursions without chainsplit appropriate modifications methods applicable chainsplit evaluation 31 efficiencybased chainsplit magic sets evaluation example 12 shows undesirably large magic sets could derived strictly enforcing binding propagation rules without consideration size intermediate relations 21 since binding propagation rules distinguish strong linkages effectively reducing size relevant sets weak ones involving huge crossproduct like relations bindings like one country bf x still passed next subgoal body rule via weak linkage obviously restriction enforced confine passing bindings via strong linkages effective magic sets still derived efficient seminaive evaluation idea efficiencybased chainsplit magic sets evaluation example 31 reexamine magic sets evaluation query gamma scsgjohn example 12 merged parents chain binding x b propagated parent bf x parent fb 1 suppose average person 2 parents less 5 children 2000 persons share country database 1 parent bf x x 1 2 2 country bf x 3 parent fb 1 5 clearly fi 4 000 000 indicates weak linkage thus binding propagation x 1 1 prohibited via linkage merged parent split two subchains parentx first one evaluated first second one delayed exit rule evaluated binding passing generates parent bf x parent fb 1 binding propagation derives magic sets sg recursion seminaive evaluation performed efficiently 2 join expansion ratio used simple judgement whether particular binding propagated another subgoal binding propagation relatively large number 100 set chainsplit threshold join expansion ratio greater threshold binding propagation cannot proceed hand relatively small number 10 set chainfollowing threshold join expansion ratio smaller threshold binding propagation proceeds two thresholds tuned based experimental results system behavior however join expansion ratio greater chainfollowing threshold less chainsplit threshold still necessary perform detailed quantitative analysis based chain characteristics database statistics compare relative costs chainfollowing vs chainsplit order make appropriate decision thus algorithm 31 efficiencybased chainsplit magic sets evaluation functionfree linear recursion input query compiled functionfree linear recursion output efficiencybased chainsplit magic sets query evaluation plan ffl derivation magic sets binding propagation rule 1 modified follows join expansion ratio hx chainsplit threshold binding propagated x chainfollowing threshold binding propagated x otherwise detailed quantitative analysis performed determine whether chainsplit beneficial ffl based modified binding propagation rules magic sets derived seminaive evaluation 1 performed sets relevant facts 2 based reasoning presented example easy see algorithm 31 derives efficient query evaluation plan method relies blind binding passing without distinction strong linkages weak ones 32 buffered chainsplit evaluation chainsplit evaluation implemented another technique buffered chainsplit evaluation splits chain generating path two portions evaluation 1 aportion set predicates evaluated 2 bportion set predicates buffered buffered portion evaluated exit portion body exit rule evaluated variable values shared b portions buffered evaluation aportion later use evaluation corresponding bportion chainmerged processing processing figure 1 chainfollowing vs chainsplit evaluation fig 1 shows distinction chainfollowing evaluation b buffered chainsplit evaluation chainfollowing evaluation b treated one merged predicate buffered chainsplit evaluation aportion first evaluated shared values buffered evaluation exit portion e bportion obtains sufficient binding information thus evaluation proceeds way similar evaluation regular multichain recursion except corresponding buffered values patched corresponding variables evaluation bufferedportion therefore name buffered chainsplit evaluation example 32 according discussion example 22 gamma appendu v b evaluated chainsplit chain generating path consx partitioned two portions upredicate consx w predicate shown fig 2 evaluation essentially passes exit portion derives first set answers upredicate finitely evaluable evaluation proceeds along w predicate derives w buffered w 1 passed exit portion making upredicate evaluable since available derives thus second set answer similarly evaluation may proceed w predicate derives w buffered w 2 passed exit portion making u upredicate evaluable derives thus third set answer cons cons cons cons cons figure 2 evaluation gamma appendu v b general following algorithm presents buffered chainsplit evaluation singlechain recursion buffering based chainlevel finite evaluability evaluation efficiency algorithm easily generalized multichain recursions algorithm 32 buffered chainsplit evaluation singlechain recursion input query compiled functional singlechain recursion output query evaluation plan applies buffered chainsplit evaluation suppose chain generating path partitioned two portions according available query bindings evaluated portion buffered portion b partition based chainlevel finite evaluability evaluation efficiency suppose ith chain generating path compiled form b share variable shares variable u 1st b shares variable w 1st b ffl first suppose query instantiates u 0 ith iteration based available binding u evaluated derives u buffers corresponding x value iteration terminates satisfies termination condition eg list shrinks empty cyclic counting method determines termination condition suppose terminates kth iteration ffl evaluate exit portion compiled form ffl pass bindings obtained processing exit portion b based available binding w buffered x b evaluated derives w igamma1 k gamma ith iteration evaluation terminates kth iteration w igamma1 derivable iteration 2 remark 31 buffered chainsplit evaluation performed algorithm 32 correctly evaluates compiled singlechain recursion rationale algorithm similar counting 1 except values variable x buffered processing evaluated portion chain generating path reused processing buffered portion notice linking two portions recursion would two chains compiled recursion counting applies since evaluated portion linked corresponding buffered portion via x chain generating path necessary buffer x reuse evaluation buffered portion evaluation exit portion buffered portion must finitely evaluable based finite evaluability recursion therefore chainsplit evaluation derives correct complete answers query processing 2 notice termination buffered chainsplit evaluation judged carefully functionfree recursion evaluation terminates easily acyclic data cyclic data method extended way similar cyclic counting algorithms 5 functional recursion termination often based monotonicity certain arguments 6 partial evaluation method also contributes termination chainsplit evaluation discussed next subsection 33 chainsplit partial evaluation buffered chainsplit evaluation every intermediate value shared split portions chain buffered along derivation path split chain sequence buffered values associated derived intermediate value evaluation buffered portion patching performed popping buffered value reverse sequence derivation sequence grows buffering patching could quite costly improvement simple buffering scheme partial evaluation performed buffered values many functional recursions follows instead storing sequence buffered values sequence buffered values evaluated much possible partially evaluated values carried along evaluation path partial evaluation reduces complexity patching buffered values often facilitates pushing query constraints judgement termination example 33 recursion travel defined rule set f32 33g represents flights sequence connected flights leaving departure city dep dtime arriving destination city arr atime total fare equals fare travelf dep dtimearratimefare f lightf dep dtimearratimefare 32 travelf nojl dep dtimearratimefare rule set rectified f34 35g sum functional predicate arithmetic function cons functional predicate corresponding list construction function according 9 rectified rule set normalized form compiled form 36 consists one chain three connected predicates flight sum cons suppose query find sequences connected flights vancouver ottawa departing 8 9 fare less 600 dtime 8 dtime 9 fare 600 37 difficult apply magic sets method evaluation query involves functional recursion seminaive evaluation cannot terminate recursions since fare length fnolist keep growing chainbased evaluation performed follows since query provides selective information departure end rather arrival end processing start departure end departure airport vancouver treated query constant similarly departure time constraint dtime 8 dtime 9 query constraint pushed departure end constraints f 600 pushed query processing based constraint pushing principles 6 propagation binding departure vancouver normalized recursive rule shown travel fbfff l ddt f f light fbfff travel sum bbf cons bbf evaluation starts departure end two functional predicates sum cons finitely evaluable uninstantiated sequence functional predicates sum l uninstantiated sequence functional predicates cons buffered chainsplit evaluation may proceed buffering sequence f fno values buffered generated tuple 2 corresponding f 2 buffered reaches ottawa corresponding buffered values patched evaluation sumf however preferable partially compute buffered values evaluation buffered predicates sumf 1 fno 1 instantiated values 2 buffered predicates sumf 2 instantiated values therefore general partially evaluable f light relation evaluated computed evaluation buffered portion trivial reaches ottawa point furthermore since lengthl monotonic functions used determination termination constraint pushing 6 600 continued search following intermediate tuple hopeless intermediate tuple pruned intermediate result buffer constraint fare 600 transformed 600 pushed iteration 2 algorithm 33 chainsplit partial evaluation compiled functional singlechain recursion input compiled functional singlechain recursion set integrity constraints query predicate set query constraints output query evaluation plan incorporates query constraints implements chainsplit partial evaluation ffl test whether query finitely evaluable terminable stop inform user ffl determine start end chain processing based relative selectivity query constraints ends compiled chain apply query constraints belonging end query instantiations reduce size initial set ffl compiled chain determine whether chainsplit evaluation performed based chainlevel finite evaluability evaluation efficiency chainsplit evaluation performed determine partition beingevaluated portion buffered portion ii partial evaluation plan possible buffered portion partial evaluation performed evaluating buffered portion partially evaluate much possible using instantiated values leave uninstantiated portion buffered carried next stage ffl instantiate termination constraints based monotonicity constraints remaining query constraints push termination constraints chain iterative chain evaluation 6 2 remark 32 algorithm 33 correctly incorporates query constraints implements chainsplit partial evaluation evaluation compiled functional singlechain recursions rationale step 1 necessary since query must finitely evaluable terminate step 2 necessary correct since selective information pushed compiled chain initial processing 3 step 3 correct since chainsplit evaluation performed partial evaluation explored step 4 correct based study constraintbased query processing deductive databases 6 2 similar algorithm derived constraintenforced chainsplit partial evaluation multichain recursions 4 chainsplit evaluation complex logic programs chainsplit evaluation confined single linear recursions since similar binding propagation rules may suffer kind inefficiency andor infinite evaluation problems complex classes logic programs chainsplit applied programs well section chainsplit evaluation complex classes recursive programs examined demonstrates chainsplit chainfollowing two basic recursive query evaluation techniques 41 evaluation nested linear recursions according definition nested linear recursion every lower level idb predicate nested linear recursion treated like edb predicate recursion level still viewed single linear recursion thus recursion level normalized independently query analysis performed normalized recursion example 41 insertion sort recursion isort defined following program 20 nested linear recursion predicate insert body recursive rule 41 turn defined linear recursion rectified following program every recursive rule normalized 9 treating insert like edb predicate recursion isort 46 47 normalized singlechain recursion recursion insert f48 410g also normalized single chainrecursion query analysis performed normalized recursion level taking query gammaisort5 7 1 example analysis proceeds follows adorned query predicate isort bf query binding propagation leads following adorned program notation indicates builtin predicate first argument free second one bound isort bf xxsy cons ffb x xs xxs isort bf xs zs insert bbf x zs 411 isort insert bbf x zs cons bbf x zs 413 insert bbf x zs cons ffb x bb cons bbf x zs 414 insert bbf x zs cons ffb insert bbf x zs cons bbf zs zs 415 comparison normalized adorned program predicates adorned program reordered based analysis finite evaluability example two predicates isort insert normalized rule 46 swapped adorned rule 411 query binding propagation following original ordering lead nonfinitely evaluable adorned predicate insert bff predicate ordering 411 makes every predicate finitely evaluable since two predicates consx xs xxs insertx zs chain generating path share variable x chainsplit evaluation performed recursion isort bf similarly chainsplit evaluation performed recursion insert bbf evaluation query gamma isort5 7 1 proceeds follows evaluation 411 leads buffered xs 7 1 call isort7 1 zs turn leads x 7 buffered xs call isort1 zs 0 leads x also buffered xs call isort zs 00 call executes 412 results zs executes sequence calls buffered values popped reverse sequence insert1 zs 0 evaluation sequence calls performed follows first insert1 zs 0 results zs since execute 413 second insert7 1 zs leads zs 1 7 since executes 415 turn calls insert1 7 zs executes rule 415 third insert5 1 7 calls insert5 7 zs cons1 zs leads final answer example demonstrates chainsplit evaluation popular technique evaluation nested linear recursions similarly shown chainsplit evaluation primitive query evaluation technique multiple linear recursions 42 evaluation nonlinear recursions finally demonstrate chainsplit evaluation also primitive query evaluation technique nonlinear recursions since many nonlinear recursions cannot compiled highly regular chain forms chain split misnomer however split set connected edb andor lowerlevel idb predicates evaluation nonlinear recursion shares spirit chainsplit evaluation linear recursion thus still called chainsplit evaluation one example examined subsection example 42 quick sort recursion qsort defined following program 20 nonlinear recursion recursive rule 416 nonlinear recursive rule rectified following program qsortlittles ls qsortbigs bs appendls xbsy treating lowerlevel predicates partition append edb predicates recursion qsort 421 422 nonlinear recursion whereas lowerlevel recursion partition multiple linear recursion append single linear recursion query analysis performed level recursions taking query gamma qsort4 9 5 example analysis proceeds follows adorned query predicate qsort bf query binding propagation leads following adorned program qsort bf xxsy cons ffb x xs xxs partition bbff xs x littles bigs qsort bf littles ls qsort bf bigs bs cons bbf x bs xbs append bbf ls xbsy 426 qsort partition bbff xxsyxlsxbs cons ffb x xs xxsx bb partition bbff xs ls xbs cons bbf x ls xls 428 partition bbff xxsyxlsxbs cons ffb x xs xxsx bb partition bbff xs xlsbs cons bbf x bs xbs 429 partition bbff xxsyxlsxbs notice transformed primitive predicates lowlevel idb predicates rectified rule 421 connected together shared variables however set connected predicates split two portions adorned rule 426 facilitate finite evaluation similar chainsplit performed adorned rules 428 429 recursion partition chainsplit also performed evaluation append bbf similar process demonstrated example 32 evaluation query gamma qsort4 9 5 proceeds follows ffl evaluation 426 leads qsortlittles ls qsortbigs bs ffl evaluation partition9 5 4 littles bigs leads ffl leads evaluation partition bbff 5 4 xlsbs ffl evaluation partition 4 xlsbs 0 applying rule 430 derives turn derives 432 431 becomes ffl evaluation qsort ls applying rule 427 derives ls evaluation qsort9 5 bs leads bs 5 9 similar process applying rule 426 finally cons4 5 9 4 5 9 append 4 5 9 leads example difficult see chainsplit primitive frequentlyapplied evaluation technique processing many nonlinear recursions well illustrate importance chain split evaluation evaluation nonlinear recursions examine nonlinear recursion form f435 436g let query form p bf usually binding x passed predicate 1 2 via variable w however binding passing via w weak leads infinitely evaluable predicate 2 chainsplit performed buffering intermediate value w delaying evaluation 2 first evaluating first recursive predicate p body evaluation p 2 evaluated efficiently finitely availability additional binding w 1 similar chainsplit process performed connected predicates b 1 b 2 respect second p body thus chainsplit commonly used technique evaluation nonlinear recursions conclusions interesting recursive query evaluation technique chainsplit evaluation investigated study chain split evaluation splits chain generating path set connected edb andor lowerlevel idb predicates two portions evaluation immediately evaluable portion delayedevaluation portion chainsplit evaluation applied split reduces size intermediate relations andor transforms infinitely evaluable subprogram finitely evaluable one study demonstrates chainsplit evaluation important query evaluation technique especially useful many functional recursions whose compiled chains consist infinitely evaluable functions necessity chainsplit evaluation judgement chain needs split based chainlevel finite evaluability andor evaluation efficiency studied three chainsplit evaluation techniques magic sets buffered evaluation partial evaluation developed magic sets chainsplit evaluation technique blocks binding propagation via unpromising paths magic rule rewriting leads derivation efficient magic sets buffered chainsplit evaluation buffers shared values evaluation one split subchain patches back buffered values later evaluation partial evaluation refinement buffered evaluation evaluating many buffered functional predicates possible reduce cost maintaining sequences buffered values facilitates termination judgement constraint pushing set frequentlyencountered interesting examples analyzed study analysis demonstrates chainsplit evaluation together chainfollowing evaluation forms two primitive evaluation techniques evaluation different classes recursions furthermore evaluation integrated existence checking constraintbased query evaluation techniques 6 achieve high performance evaluation sophisticated logic programs best knowledge detailed study chainsplit evaluation performed previous deductive database research 4 16 21 23 22 many deductive database system projects ldl 4 eksv1 23 coral 16 19 etc focused evaluation functionfree recursions whereas chainsplit evaluation frequently encountered functional recursions demonstrated study recent studies 4 16 19 extended datalog data model handle function symbols limited extent however based knowledge chainsplit evaluation performed projects analysis demonstrates large set logic programs different classes recursions implemented efficiently using compilationbased query analysis optimization technique originated deductive database research comparison logic programming implementation techniques deductive database approach derives efficient query evaluation plans based compilation normalization program transformation query analysis effectiveness completeness query evaluation deductive databases independent predicate ordering rules independent ordering rules facts logic programs independent different query forms flexibility analysis logic programs leads powerful efficient query evaluation mechanisms dataintensive logicintensive programs may represent interesting direction towards fully declarative programming logic programs currently implementing sophisticated query analyzer query evaluator part logicbase project 7 logicbase deductive database system consists two major components rule compiler query evaluator former classifies different kinds recursions compiles linear nested linear recursions normalized forms 9 whereas latter integrates chainfollowing chainsplit constraintbased evaluation techniques deductive query evaluation preliminary version logicbase system implemented unix system using lex yacc c successfully tested many interesting recursions append travel isort nqueens etc queries different inputoutput mode combinations evaluated correctly efficiently recursions independent predicate ordering rule ordering logic programs current implementation chainbased query evaluation logicbase confined logic programs consisting linear nest linear recursions scan example programs logic programming textbooks discover majority frequentlyused logic programs belong category many sophisticated logic programs beyond linear nested linear recursions cannot compiled highly regular chain forms ever similar chainbased evaluation techniques may still apply demonstrated analysis quick sort program systematic study performed analysis evaluation complex recursive programs may lead general efficient query analysis evaluation technique deductive database logic programming systems acknowledgement author would like express thanks ling liu zhaohui xie implementation method logicbase project anonymous referees constructive comments improved quality paper r magic sets strange ways implement logic programs amateurs introduction recursive query processing strategies bounds propagation selection logic programs ldl system prototype counting algorithm cyclic binary query system prototype deductive query evaluation asynchronous chain recursions automatic generation compiled forms linear recursions efficient transitive closure algorithms study transitive closure recursion mechanism framework testing safety effective computability extended datalog optimization logic based language knowledge data intensive applications safety recursive horn clauses infinite relations testing effective computability magic programs access path selection relational database management system pushing constraint selections art prolog principles database knowledgebase systems introduction aditi deductive database system aaai90 workshop knowledge base management systems tr ctr yangjun chen graph traversal linear binarychain programs ieee transactions knowledge data engineering v15 n3 p573596 march
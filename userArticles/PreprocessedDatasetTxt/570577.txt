correspondence translation heterogeneous data data integration often requires clean abstraction different formats data stored means specifying correspondencesrelationships data different worlds translating data one world another introduce paper middleware data model serves basis integration task declarative rules language specifying integration show using language correspondences data elements computed polynomial time many cases may require exponential time insensitivity order duplicates considered furthermore show practical cases correspondence rules automatically turned translation rules map data one representation another thus complete integration task derivation correspondences transformation data one world incremental integration new bulk data etc specified using single set declarative rules b introduction primary motivation new database technology provide support broad spectrum multimedia data available notably network data stored different formats sql odmg databases sgml latex documents dx formats scientific data step cadcam data etc integration active field research development see instance small sample 10 6 7 9 8 12 19 20 paper provide formal foundation facilitate integration heterogeneous data maintenance heterogeneous replicated data sound solution data integration task requires clean abstraction different formats data stored means specifying correspondencesrelationships data different worlds translating data one world another introduce middleware data model serves basis integration task declarative rules specifying integration choice middleware data model clearly essential one common trend data integration heterogeneous models always use integrating model encompasses source models take opposite approach ie model minimalist data structure use consists ordered labeled trees claim simple model general enough capture essence formats interested even though mapping richer data model model may loose original semantics data preserved integration data models facilitated model similar one used 7 oem model unstructured data see eg 21 20 surprising since data formats motivated works part formats framework intends support difference oem model view children vertex ordered crucial describe lists essential component dx formats also 13 introduces bnf generated trees unify hierarchical data models however due fixed number sons rule collections represented left right deep trees suitable casual users main contribution paper declarative specification correspondences data different worlds use datalogstyle rules enriched novel feature merge cons term constructors semantics rules takes consideration fact internal nodes represent collections specific properties eg sets insensitive order duplicates show correspondences data elements computed polynomial time many cases may require exponential time insensitivity order duplicates considered deriving correspondences within existing data one issue heterogeneous context one would also want translate data one representation another interestingly show authors permanent position inriarocquencourt france work supported air force wright laboratory aeronautical systems center arpa contract f336159311339 air force rome laboratories arpa contract f3060295c0119 work partially supported ec projects goodstep opal israeli ministry science practical cases translation rules automatically derived correspondence rules thus complete integration task derivation correspondences transformation data one world incremental integration new bulk data etc specified using single declarative set rules important result saves writing different specifications subcomponent integration task also helps avoiding inconsistent specifications noted language use define correspondence rules simple similar correspondences could easily derived using powerful languages previously proposed eg ldl 5 iql 4 languages would much difficult sometimes impossible derive translation rules given correspondence rules nevertheless language expressive enough describe many desired correspondencestranslations particular express powerful documentoodb mappings supported structuring schemas mechanism 2 3 seen correspondence rules simple intuitive graphical representation indeed present work serves basis system currently implemented specification integration heterogeneous data proceeds two phases first phase data abstracted yield treelike representation hiding details unnecessary restructuring eg tags parsing information second phase available data displayed graphical window starting representation user specify correspondences derive data paper organized follows section 2 introduces core data model section 3 core language specifying correspondences section 4 extend framework better deal collections section 5 deals translation problem last section conclusion examples figures given two appendixes 2 data model goal provide data model allows declarative specifications correspondence data stored different worlds dx odmg sgml etc first introduce model concept correspondence illustrate things use example simple instance sgml document given figure 1 tree representation document middleware model together correspondences tree forest representation reference bibliographical oodb given figure 2 21 data forest assume existence infinite sets name names ii vertex vertexes iii dom data values data forest forest ordered labeled trees ordered labeled tree tree labeling vertexes vertex ordering children internal vertexes trees labels name whereas leaves labels name dom vertex constraint vertex occurs leaf label also occur vertex forest observe rather conventional tree structure data model spirit complex value model 17 1 11 many others particularly influenced models unstructured data 21 20 tree model 7 particularity ordering vertexes important model data formats essentially described files obeying certain grammar eg sgml data forest f triple e gl e g finite ordered forest ordering implicit e set vertexes g set edges l labeling function maps leaves e e dom vertexes name vertex v e maximal subtree root v called object v set vertexes e forest f denoted vertexf set data values appearing f denoted domf remark observe definition allow leaf mapped name purposes may think leaves internal vertexes without children turn useful represent instance empty set empty list following refer word leaf vertexes v lv vertex dom illustrate notion well syntactic representations use example consider graphical representation forest describing oodb shown lower part figure 2 tabular representation part forest given figure 3 finally equivalent textual representation reference f 21 key f 211 acm96 f g g authors f 231 3 f abstract f 241 f g g g get morecompact representation omit brackets vertex single children omit vertex identifiers irrelevant discussion example reference tree may represented reference f key acm96 22 title correspondence authorsf 3 4 5 abstract g let us see various common data sources mapped middleware model consider three different types mappings first concerns relational databases also simple table formats second used objectoriented databases similar one fit graph formats finally last fit format bnf similar grammar description note three mappings invertible easily implemented relations represented tree whose root label relation name many children rows relation depth 2 nodes represent rows labeled label tuple depth 3 4 5 nodes labeled respectively attribute names types values object oriented database usually cyclic graph however using object identifier one may easily represents cyclic graph tree 4 pick one possible representation many ones proposed class extent represented tree whose root node labeled class name node many children objects extent labeled object type assume objects appear class extent specific class describe representation subtrees according types node labeled atomic type unique child whose label appropriate atomic value node labeled tuple one child attribute children labeled attribute names one child labeled appropriate type relevant structure node labeled set list bag many children elements collection one collection member lists order elements preserved child labeled appropriate type relevant structure node labeled object type unique child labeled identifier node representing object tree class extent belongs document described simplified representation parsing tree labels internal nodes resp leaves represent grammar nonterminal symbols resp tokens sgml html among formats allow references internal external data parsers interpret references usually consider strings context references interpreted possible object databases reference replaced identifier node containing referred data note identification data middleware model given nodes identifiers means responsability data sources keep relationships exported data node identifiers relationship always needed eg translation process may fine large grain according application needs data source capacities identification data data sources take various forms key row internal address relational databases object databases internal oid objects query leading objectvalue similar ideas relational case files offset file node parse tree etc 22 correspondence concerned establishingmaintaining correspondences objects objects may come one data source particular forest f 1 others another forest say f 2 simplify consider single forest viewed union two forests look correspondences within forest feel essential distinguish sources may assume nodes tree particular data source name source eg f 1 part label describe correspondences objects using predicates example 1 consider following forest sgml oodb trees figure 2 article f 12 title correspondence 13 author sabiteboul 14 author scluet 15 author tm ilo 16 abstract g reference f key acm96 22 title correspondence authorsf 3 4 5 abstract g may want following correspondences note essential difference two predicates relates objects represent real world entity whereas concat standard concatenation predicatefunction defined externally isrelationship represented figure 2 definition2 let r relational schema rcorrespondence pair f f data forest relational instance r values vertexf domf instance consider example 1 let r consists binary relation ternary one concat forest f correspondences example f rcorrespondence note restrict attention 11 correspondences correspondence predicates may arbitrary arity also data duplication nm correspondences may introduced 3 core language section develop core language style rulebased languages objects eg iql 4 ldl 5 flogic 15 precisely medmaker 19 language present section tailored correspondence derivation thus sense limited however consider next section powerful new feature assume existence two infinite sorts sort datavar data variables vertexvar vertex variables data variables start capitals distinguish names vertex variables start character followed capital letter rules built correspondence literals tree terms correspondence literals form datavertex variablesconstants tree terms form x l x l 1 x l x vertex vari ableconstant l label tree terms x ls also omitted rule obtained distinguishing correspondence literals tree terms body head semantics rules given sequel example consider following rule name r note distinction concat predicate data values thought given extension computed externally derived correspondence predicate reference f x 14 authorsf x 19 abstract x 11 g rule consists body head rule literals head said correspondence rule assume variables head correspondence rule also occur body define semantics correspondence rules given instance f correspondence rule r valuation f mapping variables r 1 maps data variables domf object variables vertexf 2 term h body r h correspondence literal h true b h tree term h object 5 f say correspondence cuv derived f using r cuv term h head r valuation f let p set rules let derived f using r pg denoted tp f p recursive may able apply tp tp f derive new correspondences limit exists application tp denoted pf theorem4 possibly recursive finite set p correspondencerules data forest welldefined particular sequence applications tp converges finite number stages furthermore pf computed ptime represent data forests using relational database relation succ gives portion successor function integers number facts derived polynomial step computed firstorder formula ptime 2 rule r example nonrecursive correspondence rule assume extension concat given see example recursive rule consider correspondence leftdeep rightdeep trees instance would like derive correspondence right left deep trees shown figure 4 achieved using program r2l consists following rules 5 recall object forest f maximal subtree f rooted vertex f u rightfx g suppose start forest f shown figure 4 derive correspondences computation r2l r2l r2l r2l r2l r2l kind deep trees frequent data exchange formats important able handle however seen quite powerful enough extended particular operations trees handle data collections described next 4 dealing collections data sources mapped middleware model forest vertexes may represent data collections observe rules tree describes vertexes bounded number children number depends term structure data collections may arbitrary number members thus need extend language deal vertexes arbitrary number children also observe ordered trees perfect represent ordered data collections lists arrays however want model database constructs sets bags consider properties insensitivity order duplicates rules developed far support section address two issues extending framework incorporate operators trees ii special collection properties 41 tree constructors consider two binary operations trees first const takes two objects input first one interpreted element second collection children vertexes operation adds element collection second operator merge allows merge two data collections one cons operator defined using merge singleton collection example formally let trees roots 0 00 label l n 00 respectively tree root labeled l children 0 n order tree root labeled l children 0 order cons merge operators provide alternative representations collections essential describe restructuring data trees forests consider reduced sense include cons merge vertexes using rules allowed consider alternative representations forest trees vertexesobjects trees cons merge regarded implicit instance data tree 1 mylistf2 3g view 1 cons2 v object v implicit structure mylistf3g indeed denote object v mylist1 3 specify object label mylist subcollection 1 single child 3 motivates following definition given forest f vertex v f children label l expression lv called implicit object f subsequence 6 set implicit objects f denoted implf 6 subsequence v obtained removing 0 elements head tail v1 vn observe vertexf viewed subset implf identify object definition v observe also cardinality implf polynomial size f use cons merge rules following example uses cons define correspondence list structured rightdeep tree list structured tree depth one observe example mylist keyword name particular semantics cons keyword semantics cons operation trees course use rules extend notion valuation allow terms containing cons new valuation may assign implicit objects object variables fixpoint computed using new definition valuation observe may contain correspondences involving vertexes implf f since interested correspondences vertexes f ultimately ignore correspondences pf restriction objects f instance consider rule tl tl tl tl tl tl tl sequel call problem computing pf matching problem theorem6 matching problem ptime even presence cons merge number facts derived polynomial step computed firstorder formula polynomial 2 42 special properties data models interest include collections specific properties eg sets insensitive order duplicates bags insensitive order context translates properties vertexes particular labels consider two cases namely insensitivity order called bag property insensitivity order duplicates called set property instance may decide particular label say mybag resp myset denotes bag resp set system distinguish fact implicit objects fundamental otherwise set would potentially infinite number representations computing correspondences would become undecidable context setbag properties definition implicit objects becomes little bit intricate given forest f vertex v f children label l implicit objects vertexes bagset properties obtained follows l set property lv v 1 subset fv 1 g fv g l bag property lv v 1 subbag ffv 1 gg ffv 1 v n gg notion valuation extended straightforward manner use implicit objects take consideration tree equivalence due insensitivity order duplicates details omitted lack space important observe point number implicit objects exponential size f next example shows cons set property used define correspondence list set containing one copy distinct list member label myset set mylist fg v myset fg observe symmetry rules set list distinction specification label myset using essentially proof theorem 6 reduction 3sat one prove theorem8 presence cons merge collections insensitive orderduplicates matching problem solved exptime even insensitivity order cons matching problem becomes nphard remark complexity data complexity may seem negative result expected matching commutative collections practice merging rarely achieved based collections often keybased rare cases based matching small collections eg sets authors conclude discussion correspondence rules demonstratethe usage cons merge let us consider following example correspondence articles oo references defined observe correspondence rule r presented beginning paper handles articles exactly three authors articlesreferences deal arbitrary number authors required title abstract author list ie authors appear order definition uses auxiliary predicate list first rule defines correspondence authors second third rules define auxiliary correspondence sequences world used rule r 4 defines correspondence articles references also defines correspondence titles abstracts worlds listx 2 x 5 listx 4 x 11 illustrated language using rather simple examples nevertheless quite powerful describe many desired correspondences particular documentoodb mappings supported structuring schemas mechanism 2 3 omitted 5 data translation correspondence rules used derive relationships vertexes next consider problem translating data first state general translation problem undecidable introduce decidable subcase captures practical applications interested based translation rules obtained moving tree terms body correspondence rules head start data forest set correspondence rules particular forest object v correspondence predicate c want know forest extended way v correspondence vertex v 0 sense v 0 could seen translation v call data translation problem input rcorrespondence f set p correspondence rules vertex v f binary predicate c output extension f 0 f cvv 0 holds pf 0 v 0 extension exists example consider forest f right deep tree 1 f1 f2 f3 fgggg assume want translate left deep tree format recall r2l correspondence rules define correspondences right deep trees left deep trees give translation problem rcorrespondence f root vertex 1 correspondence predicate r2l output forest f 0 vertex v 0 st r2l1v 0 holds tree rooted v 0 exactly left deep tree looking remark general case would like translate entire collection objects ii correspondence may predicate arbitrary arity simplify presentation consider restricted problem defined techniques work general case minor modifications turns data translation general difficult proof reduction acceptance problem turing machines proposition 51 translation problem undecidable even absence cons merge labels setbag properties although problem undecidable general show next translation still possible many practical cases often performed efficiently impose two restrictions 1 first restriction impose separate data two categories input vertexes output vertexes vertex variables labels similarly separated 7 assume presence output object depends solely presence input objects possibly correspondence conditions allows us focus essentially one kind recursion found source data structure 2 second restriction technical based property called body restriction defined sequel prevents pathological behavior mostly prevent correspondences relate inside tree terms restrictions typically apply considering data translation integration particular see examples appropriate properties basic idea use correspondence rules transform translation rules moving data tree terms containing output variables body rules head example consider r2l correspondence rules translate right deep tree left deep tree move terms left deep trees head rules obtain following translation rules variables prime used stress separation two worlds course need extend semantics rules tree terms head particular containing variables appear body used create new objects essentially data translation use skolem functions style 9 14 16 18 denote new object ids difficulties consider valuation second rule one may tempted use skolem term r 0 u x 0 denote new object since 0 created object may lead potentially nonterminating loop object creation avoid choose create objects function input objects new output created objects thus case created object denoted r 0 u 0 u x price may excluding object creation could interest ii may result inconsistencies eg object two distinct values accept although give class programs never occurs ii rely non determinism choose one value assigned one object note need form nondeterminism instance construct list representation set lack space give refined semantics rules given full paper state proposition9 finite set p translationrules rcorrespondence f possible sequences application tp converges finite number stages furthermore rules setbag labels sequence converges ptime otherwise exptime far program computation viewed purely syntactic guaranteed terminate dont know semantic properties constructed new objects derived correspondences turns evaluation translation rules allows solve translation problem large class correspondence rules clearly since problem unsolvable general 7 note vertexes easily distinguished using label particular covers rules presented previous section translations specified structuring schemas mechanisms 3 proof omitted next present conditions technique used correspondence rule r said body restricted body 1 variables correspondence literals leaves tree terms variable one occurrence correspondence literal 2 nonleaf variables one occurrence non leafs tree terms 3 variables input output tree terms share leaf variables considering correspondences specified inputoutput data forests proposition 52 consider inputoutput context let p set body restricted correspondence rules correspondence literals always relate input output objects let f rcorrespondence f input data forest v vertex f c binary correspondence predicate let p 0 translation rules obtained p moving output tree terms head rules translation problem solution input f p v c leaves input forest unchanged possible computations p 0 object computation p 0 derives cvv 0 object v 0 forest f 0 computed computation correct solution translation problem proposition 52 solve translation problem unmodified input body restricted rules need compute nondeterministically one possible outputs p test 6 conclusion presented specification integration heterogeneous data based correspondence rules showed unique specification served many purposes including twoway translation assuming reasonable restrictions claim framework restrictions acceptable practice particular one show documentoodb correspondencestranslations 2 3 covered currently working substantiating experimentation applying work presented number issues arise specification default values information missing translation complex one introduction simple constraints model eg keys another important implementation issue choose keeping one representations virtual vs materializing particular conceivable apply larger setting optimization techniques developed oodbsgml context queries 2 updates 3 acknowledgment thank catriel beeri comments first draft paper r power languages manipulation complex objects querying updating file database interface files update object identity query language primitive sets negation logic database language ldl1 data transformation system biological data sources programming constructs unstructured data towards heterogeneous multimedia information systems garlic approach using witness generators support bidirectional update objact based databases structured documents novel query facilities story o2 amalgame tool creating interoperating persistent grammar based approach towards unifying hierarchical data models ilog declarative creation manipulation objectidentifiers flogic higherorder language reasoning objects logical foundations objectoriented framebased languages logical data model logic objects medmaker mediation system based declarative specifications object exchange across heterogeneous information sources querying semistructured heterogeneous information tr sets negation logic data base language ldl1 flogic higherorder language reasoning objects inheritance scheme object identity query language primitive grammarbased approach towards unifying hierarchical data models ilog declarative creation manipulation object identifiers sgml handbook logical data model structured documents novel query facilities logical foundations objectoriented framebased languages using witness generators support bidirectional update objectbased databases extended abstract database interface file update foundations databases story o2 object exchange across heterogeneous information sources correspondence translation heterogeneous data querying updating file data transformation system biological data sources amalgame time algorithm isomorphism planar graphs preliminary report ctr natalya f noy mark musen promptdiff fixedpoint algorithm comparing ontology versions eighteenth national conference artificial intelligence p744750 july 28august 01 2002 edmonton alberta canada yannis kalfoglou marco schorlemmer ontology mapping state art knowledge engineering review v18 n1 p131 january olga brazhnik john f jones anatomy data integration journal biomedical informatics v40 n3 p252269 june 2007
chinook hardwaresoftware cosynthesis system abstract designers embedded systems facing ever tighter constraints design time computeraided design tools embedded systems kept pace trends chinook cosynthesis system addresses automation timeconsuming errorprone tasks embedded controller design namely synthesis interface hardware software needed integrate system components migration functions processors custom logic cosimulation design synthesis paper describes principal elements chinook discuss application variety embedded designs b introduction embedded system designers varied industry segments include consumer electronics automotive control medical equipment facing increased pressure create products quickly inexpensively trend coupled increasing levels integration performance programmability achievable offtheshelf integrated circuits including microprocessors programmable logic devices lcds network interface controllers speech generators designers find using devices advantageous low cost way facilitate rapid realization designs prototyping production well fact embedded controllers found everything consumer electronics automobiles smart credit cards medical equipment many products declining lifetimes make custom integrated circuits less economically viable option job embedded system designer also changed addition time market constraints designer must worry correctness cost effectiveness implementation thus designers need explore large design space potential solutions yet integrated cad tools available help task design must quickly defined simulated mapped onto cheapest combination components unlike generalpurpose computers embedded systems designed optimized provide specific functionality thus time consuming errorprone task embedded system design precisely detailed mapping abstract functional specification onto target components fact process timeconsuming many designers fix target architecture system components well complete evaluation final system perform one mapping often leads designers overdesign systems faster processors larger capacity logic devices really needed thereby increasing cost target architecture prove inadequate due performance capacity constraints designers would face costly remapping process clear design exploration tools automate mapping process thus provide faster feedback design decisions sorely needed many design automation tools frameworks proposed address problems tools either look highlevel specifications assist actual implementation help individual parts implementation provide system view examples former include behavioral simulators formal specification languages examples latter include compilers board layout tools logic synthesis systems recently tools dealing hardware software portions system proposed addressed system integration issues dominate design cycle 2 taxonomy hardwaresoftware codesign field hardwaresoftware codesign realtime embedded systems organized along three principal dimensions implementation technology application domain aspect design cycle 21 technology embedded system may implemented number technologies including offtheshelf components programmable logic fullcustom semicustom asics examples technologies include interface controllers fpgas standard processor cores cores either custom designed enhanced custom datapath io logic choice technologies significant impact priceperformance embedded system asics provide higher performance expensive design difficult modify fabricated fpgas processors reprogrammable used quickly prototype system available large quantities often competitive priceperformance ratios custom logic increasingly functionality moved software microprocessors deliver desired performance obviating need much custom logic thus design burden shifting software increases pressure automate tasks device driver generation scheduling meet realtime constraints 22 domains embedded systems divided two principal domains controldominated dataflow based upon characteristics application dataflow domain data sampled regular intervals processed order behavior system remains time time step set mathematical operators applied window data samples digital signal processing dsp systems canonical example dataflow domain control dominatedsystems span much wider range characterized complex conditional modal behavior rather mathintensive computations example controldominated system network controller avionics control system course many systems contain elements domains usually one dominates designers attention 23 design problems problems embedded systems design include specification behavior timing constraints partitioning interfacing scheduling codegeneration analysis simulation debugging point tools either exist contemplated aspects design process focus discussion dimension controldominated applications specification captures behavior requirements design part done informally using mixture natural language documents pseudocode block diagrams approach made design maintenance upgrading retargeting time intensive sometimes impossible several formal specification methods proposed including finite state machines 4 petri nets 18 csp 15 todays tools lie somewhere middle specifications written highlevel programming hardware description language simulatable enables early validation design still accepted formalization timing performance constraints critical many embedded applications constraints explicitly represented designers must devise validate software schedules interactions components hand simulators help task limited tests performed explicitly formal verification synthesis techniques needed guarantee constraints satisfied partitioning process determining components implement portions system functionality may split processor auxiliary logic set processors attempts automating partitioning included simulated annealing algorithms 9 hardware software migration 12 part ignored problems interfacing communication parts fact designers spend large fraction time interfacing system components operating environment including user interfaces bulk errors lie yet interfacing remains one least addressed areas many cosynthesis tools interfacing task may involve hardware software aspects interface well low level timing concerns may require glue logic interface generation described 20 though synthesis interface software addressed aspects embedded system design cycle include retargetable codegeneration different offtheshelf processors well custom designed ones performance estimation software critical importance required partitioning meet timing constraints done confidence analysis tools needed predict execution times possibly size code fragments finally simulators debuggers profilers needed evaluate final design detailed level 3 chinook cosynthesis system university washington approach cosynthesis realtime reactive embedded systems embodied chinook tool generates complete design specifications given single highlevel specification desired system functionality several features distinguish chinook work area motivated observations concerns outlined previous two sections using taxonomy section 2 chinook intended controldominated designs constructed offtheshelf components addresses aspects design process whose automation provide benefit designers terms shortening design cycle permitting design space exploration automating tasks errorprone cumbersome following elements chinook system principal innovations lie important note makes chinook unique combination elements rather single one ffl single specification designer writes one specification single specification language explicit timingperformance constraints rather separate netlist hardware descrip tion software languages implicit constraints key retargetability maintainability design ffl one simulation environment highlevel specification design simulated directly help debug designers intent well operational aspects design final synthesized result intermediate steps simulated environment augmented additional tools eg debuggers profilers software comprehensive software scheduling chinook synthesizes appropriate software architecture timing requirements system lowlevel partitioning ensure signal 4verilog specification parser processor device libraries driver synthesizer scheduler comm synthesizer interface synthesizer code generator netlist program behavioral simulation structural simulation mixed simulation figure 1 chinook cosynthesis system ing constraints satisfied possibly synthesized hardware modules static finegrained scheduling tailor device drivers customized dynamic schedulers interrupt handlers ffl interface synthesis interface hardware software system components cluding peripheral devices well multiple processors automatically synthesized appropriate changes reflected interprocessor communication device drivers ffl complete information physical prototyping chinook generates complete netlist assembling system complete code processors run cosynthesis system ready assembled evaluated intended environment chinook cosynthesis system consists parser processordevice library devicedriver synthesizer interface synthesizer communication synthesizer scheduler simulator see figure 1 parser accepts system description annotated verilog addition behavioral specification also contains structural specification instantiates principal components system including processors peripheral devices standard interfaces device library contains detailed generic specification device interfaces form timing diagrams verilog code models simulation c processors contains specifications interfaces well timing schemas software runtime estimation 19 devicedriver synthesizer compiles timing diagrams verilog device drivers customized code given processor makes lowlevel partitioning decisions meet signaling constraints interface synthesizer allocates io resources connect processor peripheral devices control customizes access routines reflect assignments communication synthesizer generates hardware software needed interprocessor commu nication resources allocated scheduler generates c code meet realtime constraints software c code compiled processorspecific compiler chinook also outputs netlist including necessary glue logic construct desired system chinook attempt attempt several tasks highlevel partitioning functionality hardware software processors instead assumes designers involved design exploration better position make assignments module andor task level chinook compile code target processors assumes existence appropriate c compilers also able provide scheduler feedback expected runtime code fragments finally focus realtime reactive systems assumes caches employed 4 specification single verilog file provided input chinook contains behavioral structural con structs behavioral style imposed chinook enables expression realtime reactive behavior well facilitating partitioning structural component merely lists proces sors peripheral devices communication interfaces used principal components system designer would like evaluate mapping desired functionality chinook expects designer tag tasks andor modules processor preferred implementation implementation untagged modulestasks assumed hardware separation functionality components allows designer quickly explore design space instantiating different processors alternative peripheral devices without modifying behavioral specification interactions devices interfaces specified using procedural abstraction layer long two interfaces eg scsi pcmcia support access routines eg read write easily interchanged model reactive behavior controldominated applications organize control states system set modes mode defines behavioral regime system respond inputs mode also defines scope set timing constraints must satisfied system within mode necessarily operating outside modes similar hierarchical states 14 capture sequential concurrent behavior chinook allows specification realtime requirements terms minimum maximum separation io events namely events system components system environment low level constraints may correspond setup hold times simply sequencing constraints successive ios high level minmax separation also used express response times system inputs rate constraints performance 8 given mode systems responses defined set handlers conceptually eventtriggered routines activation conditions checked timetriggered loop handlers respond generating io events andor causing mode transition handler consists trigger condition body trigger condition event expression consisting inputs environment handlers trigger condition evaluates true handler body executed example network interface chip may signal message pending triggers handler read message note handler body software hardware combination two depending tag ability processor meet timing constraints handler specification point view handler executed atomically may interleaved scheduler scheduling embedded systems timing constraints different levels interaction devices environment must respect lowlevel signaling constraints also performance requirements rate response time constraints satisfy highlevel constraints designers used processbased scheduling techniques based operating systems concepts 17 3 techniques coarsegrained prioritydriven dynamically preemptive assume processor perform io directly processes independent since timing constraints coarsegrained overhead incurred executive preemption dismissed however many embedded systems must perform direct io meet finegrained timing constraints constraints much difficult meet scheduler cannot afford incur much runtime overhead time must handle uncertainties execution delays instead chinook statically schedules lowlevel io highlevel operations grouped modes customized dynamic scheduler may generated larger modes ie top mode hierarchy chinook uses static nonpreemptive scheduling algorithm meet minmax timing constraints finegrained operations delay ranges 6 determines serial ordering operations inserts delays meet minimum constraints necessary complexity problem nphard employ heuristic ordering functions help exact algorithm quickly find valid short schedule experimental results show best heuristic consistently outperforms heuristic solves problem inexactly 13 high level rate constraints specified reference event successive itera tions response times constraints time takes mode transition statically scheduling software chinook first converts handlers within mode single handler containing bodies possibly using unrolling schedules single partiallyordered handler interleaving 8 note mode transition may triggered one handlers handlers run completion scheduler must maintain integrity handler states use critical regions achieve atomic execution disable interleaving necessary servicing devices long separation sequential events instead chinook allows user define safe points handlers potential mode transitions safely occur 5 parallel handlers must reach safe points mode transition allowed take effect 6 interface synthesis interface synthesis realization communication components via hardware software elements chinook handles wide range interface synthesis problems lowest level chinook synthesizes device drivers directly timing diagrams generates customized code particular processor used separates portions cannot implemented software synthesizing required external hardware processors general purpose io ports chinook employs efficient heuristic connecting devices processors using minimal interface hardware processors without io ports chinook automatically implements interface using memorymapped io including allocating address spaces generating required bus logic instructions synthesis solutions require knowledge interfaces processors devices captured libraries processor defined io resources builtin functionality eg serialline controller timer etc detailed architecture templates eg specific resistors capacitors required powerup reset device description contains interface information including ports skeletal access routines encapsulate timing diagrams successful interface synthesis chinook updates access routines binding device ports processors io ports memory bus taking account intervening glue logic may synthesized managing connectivity details generating interface across hardwaresoftware boundary interface synthesizer completes design enables simulation evaluation final implementation level 61 driver synthesis timing diagrams detailed level device interfaces described data sheets form timing diagrams show sequences signaling events make io transactions across interface timing diagrams usually annotated timing requirements timing delays timing guarantees first three requirements imposed user interface second two timing promises made device long user conforms requirements new devices added device library constraints corresponding timing diagrams entered via waveform editor 11 chinook parses waveforms synthesizes device driver code choosing linear schedule controller events inserting additional interface glue logic necessary 22 62 io port allocation many processors used embedded systems include io ports used directly sense manipulate processors environment ports accessed software like registers thus providing lowcost straightforward interfacing mechanism chinook provides port allocation scheme uses minimal amount glue logic furthermore device access routines customized reflect assignments pins 7 key idea io port may able service multiple devices without glue logic without performance penalties devices interfaces able isolate shared bus become active appropriate control signals guards enable thus guarded interface device share io port devices interfaces cannot active time necessary port allocator inserts glue logic add guards previously unguarded interfaces share busses chinook also synthesize ports create new interfacing point additional devices hardware synthesized create new port processors memory bus module decodes addresses translates control signals read write new io pins 63 memorymapped io io ports inefficient due multiple instructions manipulate values much additional hardware unavailable case higherperformance processors chinook synthesizes interface using memorymapped io first many parts processors well peripheral devices designed memorymapped io mind contain builtin address matching logic connected memory bus little glue logic second many components without builtin address comparators still connected little glue logic depending available address space user reserves io devices allocated portions address space processor controlling allocation done intelligently ie using onehot binary huffman encodings possible amount address matching logic required minimized memorymapped io also preferred method interprocessor communication used support pointtopoint shared memory schemes allow designer explore mapping functions multiple processors mapping tools must automatically synthesize interprocessor communication hardware software essentially view one processor processors peripheral devices requiring device drivers 7 communication synthesis requirements faster response times increased modularity frequently guide embedded system designers employ multiple processors processors often heterogeneous cost modularity concerns drive designers tailor processors specific functions cad support nonexistent types systems even debuggers support concurrent development programs two identical processors designers find heterogeneous multiple processor systems difficult debug thus constrain designs unnecessarily make debugging tasks tractable chinook provides support interprocessor communication synthesizing hardware software needed transfer data processors designer tags procedures modules processor used implement chinook determines data must transferred mechanism use transfers including interconnections processors glue logic andor buffers memory meeting timing constraints chinook adjust interface software running processors consider case fast processor communicating slow one handshaking slow processor may cause fast one violate constraints buffers reduce load fast processor eliminating direct handshaking communication becomes nonblocking data may processed bursts 71 interprocessor communication synthesis considering communication multiple processor systems many new issues arise including predictability interconnect topology access peripheral devices communication protocols interconnect topology could busbased pointtopoint hybrid scheme peripheral device may accessible via designated processor many processors may shared access communication protocol may contention based statically scheduled blocking nonblocking masterslave peers choice impacts performance predictability complexity scheduling hardware required chinook supports choices default uses model suitable realtime controldominated applications based nonblocking communication among peers designated peripheral processors interconnect may either pointtopoint busbased handler communicates environment device driver calls handlers via messages message event triggers another handler optional data value intraprocessor messages implemented shared variables interprocessor messages transmitted via communication channels synthesized elements communication library contains buffers fifos arbiters interconnect templates given partitioning handlers provided user chinook synthesize communication channels satisfy timing resource constraints communication components chosen connected respective processors using interfacing techniques section 6 multiple communication channels processors channel may mapped physical connection may share connections 72 migration processors keeping mind chinooks focus aiding designers exploration design space important designer free easily allocate functionality different processors assignment tags highlevel specification designer rapidly change partitioning functionality two processors processor direct hardware implementa tion chinook synthesizes interprocessor communication channels optimizes use task greatly simplified designer longer designer need radically alter code running one processor propagate changes others keeping track potential implications timing requirements resource access adjustments made automatically chinook migrating functionality divided three parts input parameter sending control sequenc ing output parameter receiving input output parameters mapped latches memory locations connected processor using interfacing techniques discussed earlier control sequencing may simply moved another processor moved hardware instantiated finitestatemachine datapath general solution requires behavioral synthesis quite straightforward cases involving io original software replaced routines pass inputs kickstart hardware software handler processor read back outputs 8 simulation design simulated different levels detail initial specification compatible behavioral verilog simulated without exact timing detailed io synthesis steps refine abstract communications operations concrete signals components outputs intermediate design steps final implementation also simulated cyclelevel accuracy simulator uses verilogxl programming language interface 2 communicate peripheral device models device models written c make xwindow calls visually p26 p20 ale p2 p0 speaker rxd p21 network processor io devices io driver net driver mem driver proc driver io handler proc handler net handler magic b figure 2 examples synthesized chinook portable electronic phonebook b communication magic system represent simulated device device model exports api application program simulation synthesis simulate specification early stages design api bound behavioral simulation model example scsi device exports send routine simulation user may popup window containing various fields scsi packet creating new packet designer selects send option calls send routine enables user simulate environment system designed consistent manner structural simulation system devices pin interface modeled running multiple fsms recognize possible io sequencings parallel fsm matches given io invokes corresponding behavioral routine simulate devices reaction given waveform chinook uses rtllevel processor models simulating final system implementation processor model also written c interprets machine code runs actual processor stage possible execute software debugger although synthesized code original verilog source binary code disassembled registers program counter stack internal memory builtin devices visible processor status window processor model faithfully reproduces within cyclelevel accuracy appropriate waveforms processors pins 9 examples several embedded systems designed using chinook tools following examples show type complexity current version supports portable electronic phonebook node controller distributed system mobile defibrillator 91 portable electronic phonebook portable electronic phonebook originally designed senior undergraduate students taking implementation reverseengineered high level specification run chinook tools see figure 2a generated solution required less hardware original implementation due interface synthesis algorithm able simulate entire system behavioral structural levels validate design building application hardware according generated netlist system operated correctly upon applying power 92 magic magic memory general interconnect controller custom node controller flash architecture 16 communicates processor network io devices dram see figure 2b modeled architecture three handlers one processor requests one network requests one io requests since dram initiate activity require handler communication dram occurs via device driver calls used magic application experiment using common api different peripherals specification written easy select scsi ethernet network interface chip demonstrates designers easily explore different high level options observe ramifications parts system scsi ethernet chips drivers device library straightforward implement systems require protocol chips using results synthesized chinook performed experiments simulator 93 mobile defibrillator purpose mobile defibrillator revive heartattack victims powerful electrical shock consider digital control subsystem containing extensive interface including display ecg waveforms voice synthesis digital audio recording pccard nonvolatile stor age difficulty guaranteeing timing constraints would respected commercial version application designed microcontroller asic currently exploring solutions using reprogrammable components increasing availability inexpensive powerful microprocessors fpgas designers embedded systems faced implementation choices ever given less time realize designs unfortunately computer aided design tools tracking trends chinook cosynthesis system facilitates design space exploration automates many aspects system integration often timeconsuming errorprone tasks embedded system design process design space exploration enabled use single system specification captures reactive realtime behavior system appropriately abstracts interactions environment enhance retargetability since timing requirements critical many embedded applications chinook uses static scheduling guarantee satisfaction construction several interface synthesis techniques employed interconnect system components necessary interface hardware software generated automatically minimal glue logic introduced higher level chinook facilitates easy migration functionality among processing elements manages communication requirements processors enables designers rapidly evaluate different architectural templates partitionings simulation supported throughout design cycle initial behavioral specification final structural implementation chinooks output consists netlist logic specification code processor elements needed construction complete system used chinook synthesize several embedded systems including electronic phonebook scsi interface vlsi chip tester handheld logic analyzer infrared network transceiver currently experimenting use evaluating design spaces automatic defibrillator multiprocessor io subsystem future work includes developing synthesis methods efficient communication using higher level knowledge dataflow control dependencies handlers instance routing data around processor may reduce processor load yield higher performance cost additional hardware ongoing work includes making chinook robust integrated especially scheduler compilerestimator addition investigating techniques permit partitioning software running workstationpc functionality peripheral device embedded system board attached system bus standard interface serialline pcmcia slot r esterel language cadence design systems things considered software scheduling cosynthesis reactive realtime systems interval scheduling finegrained software scheduling embedded systems synthesis hardwaresoftware interface microcontrollerbased systems scheduling reactive realtime systems specification design embedded hardwaresoftware systems specification timing digital system constrained software generation hardwaresoftware systems statecharts visual formalism complex systems communicating sequential processes stanford flash multiprocessor design realtime programming systems based process models petri nets properties predicting deterministic execution times realtime programs system level hardware module generation verilog hardware description language interface timing verification application synthesis tr communicating sequential processes statecharts visual formalism complex systems predicting deterministic execution times realtime programs stanford flash multiprocessor software scheduling cosynthesis reactive realtime systems interface timing verification application synthesis system level hardware module generation interval scheduling interface cosynthesis techniques embedded systems verilog hardware description language 4th ed synthesis fo hardwaresoftware interface microcontrollerbased systems hardwaresoftware cosynthesis digital systems hardwaresoftware cosynthesis microcontrollers specification design embedded hardwaresoftware systems hardwaresoftware codesign embedded systems scheduling reactive realtime systems constrained software generation hardwaresoftware systems ctr michael gasteier manfred glesner busbased communication synthesis system level acm transactions design automation electronic systems todaes v4 n1 p111 jan 1999 petru eles zebo peng1 krzysztof kuchcinski alexa doboli hardwaresoftware partitioning iterative improvement heuristics proceedings 9th international symposium system synthesis p71 november 0608 1996 paul pop petru eles zebo peng bus access optimization distributed embedded systems based schedulability analysis proceedings conference design automation test europe p567575 march 2730 2000 paris france r niemann p marwedel synthesis communicating controllers concurrent hardwaresoftware systems proceedings conference design automation test europe p912913 february 2326 1998 le palais des congrs de paris france verkest julio leao da silva jr chantal ykman kris croes miguel miranda sven wuytack francky catthoor gjalt de jong hugo de man matisse systemonchip design methodology emphasizing dynamic memory management journal vlsi signal processing systems v21 n3 p185194 july 1999 thomas benner rolf ernst approach mixed systems cosynthesis proceedings 5th international workshop hardwaresoftware codesign p9 march 2426 1997 pai chou ross b ortega gaetano borriello interface cosynthesis techniques embedded systems proceedings 1995 ieeeacm international conference computeraided design p280287 november 0509 1995 san jose california united states osamu ogawa sylvain bayon de noyer pascal chauvet katsuya shinohara yoshiharu watanabe hiroshi niizuma takayuki sasaki yuji takai practical approach bus architecture optimization transaction level proceedings conference design automation test europe designers forum p20176 march 0307 pai chou ross b ortega gaetano borriello interface cosynthesis techniques embedded systems readings hardwaresoftware codesign kluwer academic publishers norwell 2001 k van rompaey bolsens h de man verkest cowarea design environment heterogenous hardwaresoftware systems proceedings conference european design automation p252257 september 1996 geneva switzerland steven vercauteren bill lin hugo de man strategy realtime kernel support applicationspecific hwsw embedded architectures proceedings 33rd annual conference design automation p678683 june 0307 1996 las vegas nevada united states koen danckaert francky catthoor hugo de man system level memory optimization hardwaresoftware codesign proceedings 5th international workshop hardwaresoftware codesign p55 march 2426 1997 bill lin steven vercauteren hugo de man imec embedded architecture cosynthesis system integration proceedings 4th international workshop hardwaresoftware codesign p2 march 1820 1996 vincenza carchiolo michele malgeri giuseppe mangioni approach synthesis hw sw codesign proceedings 5th international workshop hardwaresoftware codesign p173 march 2426 1997 koen danckaert francky catthoor hugo de man system level memory optimization hardwaresoftware codesign readings hardwaresoftware codesign kluwer academic publishers norwell 2001 robert p dick niraj k jha mocsyn multiobjective corebased singlechip system synthesis proceedings conference design automation test europe p55es january 1999 munich germany steven vercauteren bill lin hugo de man constructing applicationspecific heterogeneous embedded architectures custom hwsw applications proceedings 33rd annual conference design automation p521526 june 0307 1996 las vegas nevada united states joerg henkel rolf ernst interplay runtime estimation granularity hwsw partitioning proceedings 4th international workshop hardwaresoftware codesign p52 march 1820 1996 algorithm synthesis large timeconstrained heterogeneous adaptive systems acm transactions design automation electronic systems todaes v6 n2 p207225 april 2001 baghdadi lyonnard n zergainoh jerraya efficient architecture model systematic design applicationspecific multiprocessor soc proceedings conference design automation test europe p5563 march 2001 munich germany steven vercauteren jan van der steen diederik berkest combining software synthesis hardwaresoftware interface generation meet hard realtime constraints proceedings conference design automation test europe p112es january 1999 munich germany jeanmarc daveau gilberto fernandes marchioro tarek benismail ahmed amine jerraya protocol selection interface generation hwsw codesign readings hardwaresoftware codesign kluwer academic publishers norwell 2001 kanishka lahiri anand raghunathan sujit dey efficient exploration soc communication architecture design space proceedings 2000 ieeeacm international conference computeraided design november 0509 2000 san jose california kanishka lahiri anand raghunathan ganesh lakshminarayana sujit dey communication architecture tuners methodology design highperformance communication architectures systemsonchips proceedings 37th conference design automation p513518 june 0509 2000 los angeles california united states paul lieverse pieter van der wolf kees vissers ed deprettere methodology architecture exploration heterogeneous signal processing systems journal vlsi signal processing systems v29 n3 p197207 november 2001 l freund israel f rousseau j berg auguin c belleudy g gogniat codesign experiment acoustic echo cancellation gmdfagr acm transactions design automation electronic systems todaes v2 n4 p365383 oct 1997 abid changuel jerraya exploration hardwaresoftware design space codesign robot arm controller proceedings conference european design automation p4247 september 1996 geneva switzerland jason cong yiping fan guoling han wei jiang zhiru zhang behavior communication cooptimization systems sequential communication media proceedings 43rd annual conference design automation july 2428 2006 san francisco ca usa baganne j l philippe e martin codesign methodology telecommunication systems case study acoustic echo canceller journal vlsi signal processing systems v22 n1 p2129 aug 1999 paoann hsiung timing coverification concurrent embedded realtime systems proceedings seventh international workshop hardwaresoftware codesign p110114 march 1999 rome italy ansgar bredenfeld codesign tool construction using apices proceedings seventh international workshop hardwaresoftware codesign p126130 march 1999 rome italy vincent mooney toshiyuki sakamoto giovanni de micheli runtime scheduler synthesis hardwaresoftware systems application robot control design abstract proceedings 5th international workshop hardwaresoftware codesign p95 march 2426 1997 felice balarin massimiliano chiodo attila jurecska luciano lavagno bassam tabbara alberto sangiovannivincentelli automatic generation realtime operating system embedded systems proceedings 5th international workshop hardwaresoftware codesign p955 march 2426 1997 octvio p dias isabel c teixeira j paulo teixeira metrics criteria quality assessment testable hwsw systems architectures journal electronic testing theory applications v14 n12 p149158 febapril 1999 abid ben ismail changuel c valderrama romdhani g f marchioro j daveau jerraya hardwaresoftware codesign methodology design embedded systems integrated computeraided engineering v5 n1 p6984 january 1998 jay k adams donald e thomas design mixed hardwaresoftware systems proceedings 33rd annual conference design automation p515520 june 0307 1996 las vegas nevada united states vincent j mooney iii pathbased edge activation dynamic runtime scheduling proceedings 12th international symposium system synthesis p30 november 0104 1999 vincent j mooney iii giovanni de micheli real time analysis priority scheduler generation hardwaresoftware systems synthesized runtime system proceedings 1997 ieeeacm international conference computeraided design p605612 november 0913 1997 san jose california united states vincenza carchiolo michele malgeri guiseppe mangioni hardwaresoftware synthesis formal specifications codesign embedded systems acm transactions design automation electronic systems todaes v5 n3 p399432 july 2000 gabriela nicolescu sungjoo yoo aimen bouchhima ahmed amine jerraya validation componentbased design flow multicore socs proceedings 15th international symposium system synthesis october 0204 2002 kyoto japan dirk ziegenbein kai richter rolf ernst lothar thiele jrgen teich spi system model heterogeneously specified embedded systems ieee transactions large scale integration vlsi systems v10 n4 p379389 august 2002 jrg henkel rolf ernst hardwaresoftware partitioner using dynamically determined granularity proceedings 34th annual conference design automation p691696 june 0913 1997 anaheim california united states r marculescu nandi probabilistic application modeling systemlevel perfromance analysis proceedings conference design automation test europe p572579 march 2001 munich germany giovanni de micheli rajesh k gupta hardwaresoftware codesign readings hardwaresoftware codesign kluwer academic publishers norwell 2001
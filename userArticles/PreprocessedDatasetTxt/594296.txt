new worstcase upper bounds sat 1980 monien speckenmeyer proved satisfiability propositional formula consisting ik clauses arbitrary length checked time order 2ik 3 recently kullmann luckhardt proved worstcase upper bound 2il 9 il length input formula algorithms leading bounds based isplitting method goes back davisputnam procedure itransformation rules pure literal elimination unit propagation etc constitute substantial part method paper present new transformation rule two algorithms using rule prove algorithms worstcase upper bounds 20 30897 ik 20 10299 il respectively b introduction sat problem satisability propositional formula conjunctive normal easily solved time order 2 n n number variables input formula early 1980s trivial bound reduced formulas 3cnf monien speckenmeyer 20 see also 22 independently dantsin 1 see also 4 2 many upper bounds sat subproblems obtained 21 17 25 13 14 26 16 8 23 24 authors consider bounds wrt three main parameters length l input formula number k clauses number n variables occurring conference proceedings version paper 9 best known worstcase upper bounds sat pl2 l9 16 pl2 k3 21 see also 16 p polynomial also upper bound pl2 l4 satisability problem general boolean formulas ie necessarily cnf known 28 recently paturi pudlak saks zane 24 proved 3sat checkable randomized time o2 0446n still work described paper presented 9th acmsiam symposium discrete algorithms soda98 9 steklov institute mathematics stpetersburg 27 fontanka 191011 stpetersburg russia email hirschpdmirasru url httplogicpdmirasruhirschindexhtml supported part grants intas rfbr unknown whether trivial upper bound 2 n general sat problem improved kullmann luckhardt 16 simplied algorithm monien speckenmeyer 21 presented also improved algorithm complexity pl2 k3 works better ratio number clauses number variables greater 264557 conference proceedings version paper 9 presented two algorithms improve bounds pl2 pl2 030897k pl2 010537l respectively journal version improve second algorithm prove worstcase upper bound pl2 010299l new algorithm uses pl2 030897k time algorithm subroutine proof corresponding upper bound much simpler proof conference proceedings version 9 popular methods solving sat local search method splitting method many experimental averagecase results show signicant power local search method references see survey 7 however best known worstcase upper bounds sat npcomplete subproblems obtained using splitting method 21 16 8 worstcase upper bounds local search method see 10 11 12 splitting method also useful proving worstcase upper bounds exact approximate maxsat solving 18 3 19 splitting method goes back davisputnam procedure 6 let l literal occurring formula f let f l formula obtained f assigning value rue literal l ie removing clauses containing l deleting occurrences l clauses short main idea davisputnam procedure f satisable least one formulas f l f l satisable wider sense 5 splitting algorithm constructs tree reducing satisability formula f satisability several formulas f 1 f obtained f assignments 1 spectively splitting algorithm simplies formulas f 1 f according transformation rules change satisability transformations take polynomial time role reduce parameters l k n formulas f 1 f simplify formulas eliminating pure literals literal pure negation occur formula 1clauses 1clause clause consisting one literal easy pieces recurrent equations often used complexity analysis algorithms kullmann luckhardt 16 described similar simpler technique useful estimation running time splitting algorithms one consider execution splitting algorithm branching tree ie tree formulas labelling children simpler formulas labelling parents leaves labelled simplest formulas node tree associate branching vector nonnegative numbers polynomial constructed vector one estimate number leaves tree using largest positive roots polynomials precise denitions formulations given sect 3 transformation rules play important role splitting algorithms two simplest rules proposed original paper davis putnam 6 eliminate pure literals 1clauses transformation rules use described sect 4 paper introduces new transformation rule goes following simple observation clause formula contains least one negative literal formula trivially satisable assignment variables value f alse let p l f property literal formula example f contains exactly two occurrences l least three occurrences l addition suppose variable v formula f one literals v v satises p given f literals satisfy property p referred p literals black white literals principle let f formula cnf least one following two alternatives holds 1 clause f contains p literal contain negations p literals 2 satisability f equivalent satisability formula obtained f removing clauses containing negations p literals formal proof black white literals principle given lemma 43 figure 1 illustrates principle white circles denote p literals black circles denote negations circles dots denote literals ie literals neither p literals negations p literals note negation literal neither p literal negation p literal columns correspond clauses formula gure contains two formulas rst one satises condition 1 second one satises condition 2 1 z 2 figure 1 two alternatives black white literals principle principle key point algorithm corresponding upper bound pl2 030897k algorithm use presence clauses contain p literal contain negations p literals certain property p black white literals principle kind insurance guarantees cannot nd required clause replace f simpler formula f contain p literals principle one reformulations following simple property partial assignment ie set literals contain simultaneously x x variable x formula f cnf either clause f containing literals setting values literals f alse change satisability f another known reformulations property generalized sign principle 16 autarkness principle 20 22 17 see also 16 comprehensive study autarkness principle found 15 use black white literals principle leads two new bounds sat presented paper also several upper bounds satisability problem formulas cnf11 8 formula cnf11 literal occurs positively satisability problem formulas npcomplete sect 2 give basic denitions section 3 contains technique allows us estimate size branching tree sect 4 explain transformation rules use algorithms sect 5 sect 6 describe algorithms upper bounds pl2 030897k pl2 010299l respectively corresponding proofs 2 basic denitions let v set boolean variables negation variable v denoted v given set u denote ug literals members set positive literals members set v negative literals negations w denotes negative literal v w denotes variable v clause nite set literals contain simultaneously variable together negation empty clause interpreted f alse formula cnf cnfformula nite set clauses empty formula interpreted rue length clause cardinality length formula sum lengths clauses length clause c denoted jcj kclause clause length k k clause clause length least k k clause clause length k say literal v occurs clause formula mean clause formula contains literal v however say variable v occurs clause formula mean clause formula contains literal v contains literal v assignment nite subset w contain variable together negation informally speaking assignment contains literal w means w value rue obtain f f assignment remove f clauses containing literals w delete occurrences literals w clauses short write f w assignment satisfying formula f f empty formula formula satisable exists satisfying assignment say two formulas f g equisatisable satisable unsatisable let w literal occurring formula f literal iliteral f contains exactly occurrences w ijliteral f contains exactly occurrences w exactly j occurrences w ij literal f contains exactly occurrences w least j occurrences w ij literal f contains exactly occurrences w occurrences w similarly dene denote number occurrences literal w formula f w sum lengths clauses containing w w meaning f clear context omit f literal w iliteral similarly dene 3 estimation size branching tree kullmann luckhardt introduced 16 notion branching tree intended estimating time complexity splitting algorithms since tree formulas algorithm splits branching tree one consider execution splitting algorithm tree whose nodes labelled cnfformulas node labelled cnfformula f sons labelled simplied formulas f 1 f 2 assignments suppose tree whose nodes labelled formulas cnf formula f attach nonnegative integer tree branching tree node complexity formula labelling node strictly greater complexity formulas labelling sons paper use number variables f number clauses f length f prove two upper bounds wrt k wrt l however section x concrete measure complexity let us consider node tree labelled formula f 0 suppose sons labelled formulas f 1 f 2 fm branching vector node mtuple positive numbers exceeding characteristic polynomial branching vector dened characteristic polynomial h x monotone function x interval 0 1 h exactly one positive root denote root call branching number suppose leaves omit one pair parentheses write example 31 example 069424 golden ratio branching number tree largest branching numbers nodes denote maxt following lemma proved kullmann luckhardt allows us estimate number leaves branching tree using branching number lemma 31 kullmann luckhardt 16 let branching tree let root labelled formula f 0 number leaves exceed maxt lemma already allows us estimate running time splitting algorithm know branching number splitting tree algorithm processes leaf polynomial time however algorithm corresponding upper bound calls algorithm corresponding upper bound pl6 7 6 7 k subroutine thus processes leaves exponential time estimate overall running time use following simple generalization lemma 31 lemma 32 8 let branching tree let root labelled formula f 0 let g l denote object labelling leaf l tree let l leaf proof induction construction tree base tree consisting unique node case step consider tree presented fig 2 let branching tuple root l leaf l leaf j fg l denition tuple figure 2 splitting tree denition h max maxt monotonicity h ut know branching number tree corresponding splitting algorithm estimate running time explicitly require algorithms perform splittings branching numbers greater wish need prove always exists splitting satisfying condition purpose algorithm compare branching numbers corresponding dierent vectors course done examination constant number cases use monotonicity however general statement holds lemma 33 kullmann luckhardt 16 let k natural constants x 1 positive rational numbers problem whether 1 solvable time polynomial maxx 1 x following estimating running time algorithms use frequently inequalities like 7 15 5 17 5 17 6 7 6 7 13 without proofs one check inequalities approximate calculation branching numbers however several simple observations may help prove inequalities easier lemma 34 kullmann luckhardt 16 1 permutations components branching vector aect corresponding branching number 2 branching number strictly decreases one components branching vector increase 4 transformation rules section f denotes formula cnf lemmas 31 32 allows us take consideration dierences complexity input formula complexities formulas obtained splitting higher dierences smaller number leaves thus obtain good algorithm reduce much possible complexities formulas obtained splitting explain transformation rules allow us precisely explain certain cases nd simpler formula equisatisable f following use rules never increase parameter consideration number clauses formula length formula elimination 1clauses f contains 1clause fag formulas f f equisatisable since assignments contain unsatisfying subsumption f contains two clauses c c f f nfdg equisatisable since assignment satises clause c satises also clause resolution subsumption suppose given literal clauses c literal satisfying conditions 2 c 2 case clause c n fa ag called resolvent literal clauses c denote rc let f contain clauses c clear adding rc formula change satisability however increases size avoid eect use rule rc case reduce satisability problem formula f satisability problem dg elimination variable resolution given literal construct formula dp adding f resolvents removing f clauses containing lemma 41 davis putnam 6 formulas f dp equisatisable transformation increase size formula orand number clauses use rule increase parameter consideration number clauses formula length formula note particular transformation increase parameters f pure literal thus eliminates pure literals elimination blocked clauses clause c blocked literal wrt f c contains literal literal occurs clauses f contain negation least one literals occurring c n fag note f may may contain c words resolvents clause c clause formula f cnfformula f literal occurring dene assignment ag j clause fa xg blocked wrt fg meaning f clear context omit f write ia notion blocked clause introduced investigated kullmann 13 14 use following two facts blocked clauses lemma 42 kullmann 13 14 1 clause c blocked literal wrt f f f n fcg f fcg equisatisable 2 given literal formula f satisable least one formulas f f ia satisable application black white literals principle let p binary relation literals formulas cnf variable v formula f one p v f p v f holds lemma 43 suppose clause f contains literal w satisfying p w f contains also least one literal b satisfying p b f f f fl j p l f g equi proof particular case autarkness principle 20 22 17 16 denote suppose g satisable consider satisfying assignment formula g clear assignment hand assignment satisfying f satises also g ut 5 bound wrt number clauses section present algorithm 51 checks satisability formula f time polynomial algorithm two subroutines function reducek function splitk function reducek simplies input formula using transformation rules see sect 4 function splitk intended reducing satisability problem input formula satisability problem several simpler formulas execution algorithm viewed follows function reducek simplies input formula splitk splits several formulas reducek sim plies following denote reducek formula function reducek outputs input f similarly dene splitk function reducek input formula f cnf output simplied formula cnf method kr1 elimination 1clauses f contains 1clause repeat step f contains 1clauses kr2 application black white literals principle clause c f contains 23 contains also 3 f f fa j 3 elimination variable resolution choose literal occurs f maximal several literals choose literal minimal 0 f dp repeat step f satises condition f changed steps kr1kr3 go step kr1 otherwise return f ut function splitk input formula f cnf output f satisable rue otherwise f alse method ks1 empty formula containing empty clause 2 f return f alse splitting two subproblems literal occurring f construct two exists literal kf choose formulas f 1 f 2 corresponding literal splitk returns rue least one return rue otherwise return f alse splitting four subproblems choose literal occurring f two literals b c occurring f f respectively construct four formulas f 11 reducek f 21 reducek f 22 reducek exist literals b c choose formulas f 11 f 12 f 21 f 22 corresponding literals returns rue least one return rue otherwise return f alse ut algorithm 51 input formula f cnf output f satisable rue otherwise f alse method return splitk reducek ut sect 4 explained none steps reducek changes satisability formula steps kr1kr4 cannot repeated kf since none increases number clauses number variables iteration kr1kr4kr1 least one quantities decreases steps takes polynomial time thus reducek change satisability formula returns answer polynomial time construct tree ects behaviour algorithm 51 together functions reducek splitk internal nodes labelled formulas algorithm 51 splits steps ks3 ks4 leaves labelled formulas satisfy conditions steps ks1 ks2 internal node labelled f two sons labelled f 1 f 2 four sons labelled f 11 f 12 f 21 f 22 since conditions steps ks3 ks4 guarantee corresponding branching numbers exceed 6 7 6 7 lemma 31 number leaves tree input formula thus algorithm 51 returns answer time plf 6 7 6 7 kf p polynomial remains prove algorithm 51 performs correctly ie formula cnf reduced reducek satises least one conditions steps ks1ks4 prove statement need two simple lemmas concerning output reducek lemma 51 let f 1 value f step kr1 function reducek point time maybe eliminating several 1clauses f 2 corresponding output formula function reducek e literals occurring f 1 1 1 1 2 e 1 1 clauses f contain e simultaneously 2 proof 1 reducek modies formula steps kr1 kr2 least one clause deleted otherwise least one clause eliminated step kr3 since kf 1 kdp 2 wlog suppose f 1 contains one 1clause clause contains 1literal eliminating clause formula f 1 contain 1clauses f 1 contains exactly one 1clause eliminated step kr1 one clause eliminated 1 since least one literals e remains let f 1 contain 1clauses reducek modies formula step kr2 least one clause ie least two occurrences eliminated f value f 1 step kr3 wlog suppose step kr3 step kr3 1 literal chosen rst application dp least one literals e remains 1 literal negation literal remains formula hence 1 least one clause eliminated ut lemma 52 let f formula cnf formula reducek contain 1clauses 1 literals 22literals proof function reducek eliminates 1clauses step kr1 1 literal 22literal kdp eliminates literals step kr3 ut theorem 51 algorithm 51 performs correctly stops time pl6 7 6 7 k pl2 030897k l length input formula k number clauses p polynomial proof shown suces prove formula f cnf reduced reducek satises least one conditions steps ks1ks4 suppose f satisfy conditions steps ks1ks4 consider possible cases prove cases impossible symbols meaning corresponding steps function splitk key observation formula f contains frequent variables transformation f f f literal apply lemma 51 prove formally case 1 formula f contains 3 clauses formula f containing literal disappear f clauses containing literal disappear f since 3 4 thus terms step ks3 ie condition step ks3 case 2 formula f contains clause contains 33literal 23 b three clauses formula f containing disappear f three clauses containing disappear f addition b becomes 1 1 literal f thus terms step ks3 1 1 lemma 51 hence ie condition step ks3 satised case 3 formula f contains 2clause consisting 2literals clauses formula f containing disappear f clauses containing disappear f lemma 52 23 3 similarly case 2 terms step ks3 1 1 addition c becomes 1clause f eliminated step kr1 ie 2 1 4 ie condition step ks3 satised case 4 formula f contains 3 consisting 2literals sg clauses formula f containing disappear f clauses containing disappear f lemma 52 23 addition 2 3 become f 1 c clause contains 2 3 simultaneously lemma 51 kf 1 kreducek 2 otherwise 3 becomes 03 f 2 ie kf 2 kreducek 2 depending two alternatives takes place choose 1 2 terms step ks3 ie condition step ks3 satised case 5 conditions cases 14 satised since step kr2 change f contains 3literals since f satisfy condition step ks3 literal 3 let literal occurring f prove exist literals b c condition step ks4 satised consider three subcases rst two similar cases 24 case 51 exists clause f 1 33literal 2 2literal suppose terms step ks4 similarly case 2 11 4 12 3 case 52 exists clause f 1 23literal 2literals suppose terms step ks4 similarly cases 34 11 3 12 4 11 4 12 3 note 51 literals j cannot occur together two clauses case 53 conditions cases 5152 satised since 51 steps kr1kr3 reduce number clauses formula f conditions cases 5152 satised formula consists clauses contain 22literals clauses contain 33literals since exactly three clauses formula f disappear f occurrences 33literal cannot disappear f hence contains least one 22literal b 1 let b 1 2literal formula f contain 2clauses 51 similarly cannot contain two clauses containing literals b 1 simultaneously thus f contains 3 2literals choose literal b 1 b clauses formula f contain b 1 disappear f b 1 addition clauses contain 22literals become literals thus lemma 51 3 hand two clauses f containing b 1 disappear f b 1 two clauses disappear lemma 51 since b 2 b 3 become literals note 51 formula f contains one clause contains b 2 b 3 simultaneously thus cases 5153 exists literal b f 7 literal c chosen similarly hence condition step ks4 satised ut 6 bound wrt length formula section present algorithm 61 checks satisability formula f time plf 2 010299lf p polynomial previous section dene two subroutines function reduce l function split l use similarly reducek splitk function reduce l simplies input formula split l splits several formulas reduce l simplies function reduce l input formula f cnf output simplied formula cnf method lr1 elimination 1clauses f contains 1clause repeat step f contains clause subsumption f contains two clauses c c f fdg repeat step f contains clauses elimination blocked clauses f contains blocked clause c f fcg repeat step f contains blocked clauses resolution subsumption f contains two clauses c rc dd f frcdg repeat step f contains clauses elimination variable resolution choose literal occurs f repeat step f satises condition f changed steps lr1lr5 go step lr1 otherwise return f ut function split l input formula f cnf output f satisable rue otherwise f alse method ls1 empty formula containing empty clause 2 f return f alse containing 2clauses f contain 2clauses apply algorithm 51 f return answer splitting two subproblems literal occurring f construct two exists literal lf choose formulas f 1 f 2 corresponding literal split l returns rue least one return rue otherwise return f alse ut algorithm 61 input formula f cnf output f satisable rue otherwise f alse method return split l reduce l ut similarly reducek function reduce l change satisability formula returns answer polynomial time construct tree ects behaviour algorithm 61 together functions reduce l split l leaves labelled formulas satisfy conditions steps ls1ls3 algorithm 61 processes polynomial time formulas satisfying conditions steps ls1 ls2 passes formulas satisfying condition step ls3 algorithm 51 processes formula f time polynomial note f contains 2 clauses since 1clauses eliminated step lr1 internal nodes tree labelled formulas algorithm 61 splits step ls4 internal node labelled f two sons labelled f 1 f 2 since condition step ls4 guarantees corresponding branching number exceed 32 running time algorithm 61 upper bounded qlg6 7 6 7 lg3 input formula g q polynomial remains prove algorithm 61 performs correctly ie formula cnf reduced reduce l satises least one conditions steps ls1ls4 need three simple lemmas concerning output reduce l prove statement lemma 61 let f formula cnf literal occurring 1 12 literal occurring 3 clause ldp 2 11 literal occurring 2 clause ldp 2 3 11literal ldp 2 proof straightforward calculations ut lemma 62 let f 1 value f one steps lr1lr5 function reduce l f 2 corresponding output formula function reduce l literal occurring 1 12 literal occurring 3 clause 2 11 literal occurring 2 clause 2 proof 1 note change formula steps lr1lr4 removal clauses andor change clauses subsets thus results decreasing length formula least one occurrence formula change step lr5 least one occurrence removed lemma 611 2 suppose f gets value f 1 function reduce l modies formula step lr4 modifying cannot result increasing length clause increasing number occurrences literal moreover formula changes steps least one occurrence removed one occurrence removed least one literals remains formula occurrence lemma 611 least one occurrence removed step lr5 2 holds otherwise becomes pure literal removed step lr5 thus 2 holds suppose reduce l modify formula step lr5 2 follows lemma 612 ut use following simple properties formula reduced function reduce l proof 61 without explicit mentioning lemma 63 let g 1 f satisfy conditions steps lr1lr5 2 1clauses f 3 pure literals 11literals f 4 2clauses f containing 1literal 5 literal occurring f 1literal occurring f 7 7 literal occurring f 5 proof 1 trivial 27 since f satisfy conditions step lr1and see also lemma 61 ut theorem 61 algorithm 61 performs correctly stops time pl6 7 6 7 l3 pl2 010299l l length input formula p polynomial proof shown sucient prove formula f cnf reduced reduce l satises least one conditions steps ls1ls4 suppose f satisfy conditions steps ls1ls3 consider two possible cases f contains least one 1literal contains 1literals prove cases f satises condition step ls4 informally done follows rst case show assignment ia contains many literals second case handled careful examination subcases choose 2clause fc dg f examine following subcases many occurrences clauses containing literal c f contains many occurrences literal c two subcases show many occurrences eliminated transformation f f c f c f f subsequent elimination 1clauses obtained clauses containing literals c c third subcase none previous subcases holds subcase one c 22literal occuring 2 3clauses allows us use lemma 61 one occurrence literal eliminated splitting another literal following denote f 2 literal meaning step ls4 algorithm 61 case 1 formula f contains 1literal clause containing let 7 lemma 63 max7 number 3 clauses among clauses contain transformation formula f f 2 occurrences literal clauses containing eliminated thus 5 transformation formula f f 1 clause occurrences literal eliminated 2clauses containing eliminated step lr1 since blocked wrt f exists clause f fa g clauses eliminated since clauses fa g blocked wrt f ie fa clauses containing clauses clause distinct thus r7 r ie condition step ls4 satised 1 case 2 formula f contain 1literals since f satisfy condition step ls3 contains 2clause dg let us note formula f contain clauses contain literal literal c literal literal c literal literal c simultaneously proposition true since f satisfy conditions steps lr2 lr4 also case ic fcg id fdg 62 denition let us denote one literals c shall choose later one denote remaining literal b let number 3 clauses among clauses contain note 1 let number 3 clauses among clauses contain count occurrences disappear transformation formula f f ia f f subsequent elimination 1clauses resulted 2clauses containing literals transformation formula f f 1 occurrences literal clauses containing eliminated 2clauses contain eliminated step lr1 clauses 1 kullmann luckhardt 16 prove similar algorithm case thus 5 17 condition step ls4 replaced 8 12 however would improve upper bound would make proof longer thus present simpler proof formula f contains 1clause fbg obtained 2clause eliminated step lr1 f contains 2clauses containing clauses obtained eliminated step lr1 number clauses 1 transformation formula f f 2 occurrences literal clauses containing b eliminated 62 clause containing b literals occur thus even count occurrences disappear clauses containing rst application step lr2 consider several subcases case 21 c 6 6 63 64 thus ie condition step ls4 satised case 22 c 3 3 let 2 fc dg literal 3 holds let b remaining literal fc dg thus 22 thus ie condition step ls4 satised case 23 5 let 2 fc dg literal remaining literal fc dg 4 b 5 b case b 2literal occurs one 2 3clause denote clause c b literal b becomes 12literal f ia f complete proof showing several literal occurrences eliminated addition occurrences counted 63 three subcases case 231 least two occurrences eliminated rst application step lr2 addition occurrences counted 63 case 9 20 case 232 exactly one occurrence eliminated rst application step lr2 addition occurrences counted 63 remind 63 counts occurrences clauses containing one literals aa 62 occurrence literal b clause c b occurrence literal b cannot eliminated transformation formula f formula f counted occurrences term 63 elimination 1clause fbg obtained 2clause fa bg since impossible two distinct identical clauses fa bg formula two occurrences another occurrence literal b occurrence literal b c b eliminated moment counted 63 fact contradicts assumption case 232 thus case b remains 12literal rst application step lr2 lemma 621 least one occurrence eliminated thus 6567 hold case 233 occurrences eliminated rst application step lr2 addition occurrences counted 63 similarly case 232 b remains 12literal rst application step lr2 transformations formula f function reduce l thus jc b two occurrences eliminated lemma 622 6567 hold however jc apply lemma 621 case thus 10 hence three subcases 231233 ie condition step ls4 satised ut 7 conclusion work paper improved existing upper bounds sat respect k number clauses l length formula key point algorithms proofs black white literals principle new transformation rule viewed reformulation two previously known principles autarkness 20 22 17 15 generalized sign principle 16 proofs well proofs previous upper bounds 21 16 neither short elegant would kind breakthrough nd compact way present proofs upper bounds splitting algorithms believable way could lead even better bounds since currently possibilities create new heuristics prove corresponding upper bounds limited length comprehensible proof hand challenging problem prove tight lower bounds class splitting algorithms currently exponential lower bounds resolution proofs see eg 27 far enough known upper bounds splitting algorithms splitting algorithms viewed resolution proofs vice versa another direction work nd randomized algorithms give better upper bounds sat nd way apply modern randomized algorithms already invented 3sat recent breakthrough papers 23 24 also remains challenging problem nd lessthan2 n upper bound n number variables r tautology proof systems based splitting method less 2 n satis approximation algorithms max sat better performance ratio cost longer running time exponential upper bounds satis machine program theoremproving computing procedure quanti algorithms satis separating signs satis two new upper bounds sat local search algorithms sat worstcase analysis hard formulas sat local search algorithms sat local search algorithms worstcase study new methods 3sat decision worstcase analysis investigations autark assignments algorithms complexity obere komplexit parametrizing guaranteed values maxsat maxcut new upper bounds maxsat upper bounds covering problems solving satis improved exponentialtime algorithm ksat solving 3satis ability less 1579 n steps pure literal look ahead o1497 n complexity propositional proofs satis tr ctr rainer schuler algorithm satisfiability problem formulas conjunctive normal form journal algorithms v54 n1 p4044 january 2005 bolette ammitzbll madsen algorithm exact satisfiability analysed number clauses parameter information processing letters v97 n1 p2830 january 2006 evgeny dantsin andreas goerdt edward hirsch ravi kannan jon kleinberg christos papadimitriou prabhakar raghavan uwe schning deterministic 2 2k 1n algorithm ksat based local search theoretical computer science v289 n1 p6983 23 october 2002 ramamohan paturi pavel pudlk michael e saks francis zane improved exponentialtime algorithm ksat journal acm jacm v52 n3 p337364 may 2005 tobias riege jrg rothe holger spakowski masaki yamamoto improved exact algorithm domatic number problem information processing letters v101 n3 p101106 february 2007 ryan williams algorithms quantified boolean formulas proceedings thirteenth annual acmsiam symposium discrete algorithms p299307 january 0608 2002 san francisco california haiou shen hantao zhang improving exact algorithms max2sat annals mathematics artificial intelligence v44 n4 p419436 august 2005 jens gramm edward hirsch rolf niedermeier peter rossmanith worstcase upper bounds max2sat application maxcut discrete applied mathematics v130 n2 p139155 15 august edward hirsch worstcase study local search maxksat discrete applied mathematics v130 n2 p173184 15 august laurent simon daniel le berre edward hirsch sat2002 competition annals mathematics artificial intelligence v43 n14 p307342 january 2005 oliver kullmann lean clausesets generalizations minimally unsatisfiable clausesets discrete applied mathematics v130 n2 p209249 15 august rolf niedermeier peter rossmanith efficient fixedparameter algorithm 3hitting set journal discrete algorithms v1 n1 p89102 february
zeroaliasing modeled faults abstractwhen using builtin selftest bist testing vlsi circuits circuit response input test sequence may consist thousands millions bits compacted signature consists tens bits usually linear feedback shift register lfsr used response compaction via polynomial division compacting function manytoone function result erroneous responses may mapped signature good response known aliasingin paper deal selection feedback polynomial compacting lfsr erroneous response resulting modeled fault mapped signature different good response lfsrs called zeroaliasing lfsrs zeroaliasing lfsrs primitive irreducible feedback polynomials considered due suitability bist test pattern generationupper bounds derived least degree irreducible primitive zeroaliasing lfsr polynomials bounds show practical test applications polynomial degree less 53 expected bounds derived show number faults less 106 degree 21procedures find irreducible primitive zeroaliasing lfsr polynomials 1 smallest degree 2 prespecified degree presented lowcomplexity procedure find zeroaliasing lfsr polynomial also presented worst case well expected time complexities procedures derived experimental results presented practical problem sizes demonstrate applicability proposed procedures b introduction builtin selftest bist capability circuit test idea behind bist create pattern generators pgs generate test patterns circuit response analyzers ras compact circuit response inputs applied circuit response may consist thousands millions bits compacted signature consists tens bits compacting function manytoone function result erroneous responses might mapped signature good response known aliasing erroneous responses mapped different signature good response zeroaliasing two previous schemes achieve zeroaliasing take account possible error sequences first gupta et al 7 14 scheme ra linear feedback shift register lfsr compacting function polynomial division good response feedback polynomial scheme requires quotient good response periodic achieved proper selection lfsr feedback polynomial good response known give bound n2 length required register test sequence length n second scheme due chakrabarty hayes 5 uses nonlinear logic detect error response number memory cells ra dlog ne bound extra logic required implement scheme major difference scheme aforementioned zeroaliasing schemes target specific set possible faults try achieve zeroaliasing error sequences resulting modeled faults try recognize possible error sequences mainly never occur fault model lets us focus probable error sequences result use less hardware aforementioned schemes previous method finding zeroaliasing feedback polynomials modeled faults presented pomeranz et al 13 different heuristics finding zeroaliasing polynomial suggested heuristics necessarily find minimum degree zeroaliasing polynomial necessarily find irreducible primitive polynomial important register also function pg work present upper bounds minimum degree irreducible primitive zeroaliasing polynomials provide algorithms find minimum degree polynomials pgs ras usually implemented reconfiguring existing registers registers configured pgs generate tests blocks logic reconfigured ras test blocks logic lfsr feedback polynomial serves purposes overhead reconfigurable design saved scheme lfsr used pg multiple input shift register misr used ra example misrbased ra shown figure 1 register configured shift register input cell xor function previous cell output bit circuit test cut depending linear feedback function feedback bit number cells k stage misr feedback coming cell kgamma1 feedback function represented polynomial feedback feeds cell iff f 1 feedback polynomial misr figure 1 1 difference lfsr misr extra inputs connected outputs cut pg lfsr ra misr use feedback polynomial overhead reconfigurable polynomials saved previous paper 11 showed select feedback polynomial pg paper deal selecting feedback polynomial ra since kstage pg primitive feedback polynomial generates nonzero ktuples opposed pg irreducible feedback polynomial prefer primitive zeroaliasing polynomials even though takes effort find compacting function misr polynomial division gf 2 effective output polynomial divided feedback polynomial signature remainder division cut k outputs k output sequences denote sequences input sequence length n viewed polynomial output value ith output time j effective polynomial l x l objective select feedback polynomial compacting misr given set modeled faults erroneous response resulting modeled fault mapped different signature signature good response cut outputs available register might short achieve zeroaliasing case need lengthen register adding flipflops keep hardware overhead minimum want add flipflops possible hence interested feedback polynomial smallest degree achieves objective register serve pg ra advantageous feedback polynomial degree available register hence interested feedback polynomial prespecified degree times might want find feedback polynomial fast even resulting misr requires extra flipflops optimum assume following test scenario input sequence cut designed effective output polynomial due target fault different effective polynomial good response ie error polynomials nonzero let r effective polynomial good response effective polynomial due fault represent r h linearity remaindering operation get different remainder erroneous polynomial iff h divisible feedback polynomial assume given error polynomials target faults problem deal paper following given set polynomials find polynomial relatively prime polynomials h polynomial referred nonfactor h nonfactor used feedback polynomial compacting misr zeroaliasing achieved set target faults particular irreducible primitive feedback polynomials present 1 upper bounds smallest degree zeroaliasing misr 2 procedures selecting zeroaliasing misr smallest degree 3 procedures determining whether zeroaliasing lfsr prespecified degree exists finding one 4 procedures fast selection zeroaliasing misr analyze worst case well expected time complexity proposed procedures note notation using logarithmic notation ln x denote natural logarithm x log x denote base 2 logarithm x polynomials fh g represent error polynomials degree h represented product polynomials h denoted h degree h h h product distinct degree j irreducible factors h denoted g ij ij degree g ij product polynomials g ij denoted g j nonfactor seek referred representing degree rest paper organized follows section 2 establish upper bounds degree nonfactor section 3 review polynomial operations gf 2 complexities section 4 presents procedures finding nonfactor smallest degree set h section 5 presents procedures finding nonfactor prespecified degree finding nonfactor fast also discuss effectiveness conducting exhaustive search least degree nonfactor section 6 presents experimental data conclude section 7 2 bounds least degree nonfactor set polynomial consider following problem problem 1 let h set jhj polynomials h give upper bound sd h degree irreducible polynomial upper bound pd h degree primitive polynomial divide h ie exists irreducible primitive polynomial degree sd h pd h divide h similarly let esh eph expected degree irreducible primitive polynomial nonfactor h bounds sd pd referred worst case bounds bounds esh eph referred expected bounds first establish worst case bounds proceed expected bounds 21 worst case bounds bound sd follow 10 let 2 j denote number irreducible polynomials degree j gf 2 degree product irreducible polynomials degree j j let sd denote least integer product irreducible polynomials degree less equal sd degree q sd greater replacing h q sd h least one root root h hence q sd h least one irreducible factor factor h thus sd h upper bound degree irreducible polynomial relatively prime polynomials set h following lemma provides bound sd h turn find bound pd number primitive polynomials degree gf 2 ism oeq euler function denoting number integers less relatively prime q 12 p 37 l p distinct prime factors q lemma 2 16 p 173 q 3 exception product first nine primes 5is replaced 250637 lemma 3 q 208 log log q proof first prove case q 65 lemma 2 208 log log q equation 1 verified directly help us derive bound pd introduce value let denote least integer ratio times number primitive polynomials degree times number irreducible polynomials degree greater 1 ie lemma 4 10 lemma 3 p 293 3 2 lemma 5 log log 2te proof definition verified expression lemma valid valid 2 prove case 2 q 4 function q 208 log log q increasing function hence 208 log logq 208 log log also 208 log logq 208 log log q thus since 1 1 208 log log q 208 log logq gamma 1 208 log log q least integer 2 0 208 log log 2 0 2 208 log log2 0 equation 1 5 get due lemma 4 thus definition 0 bound solve definition 0 must satisfy 208 log 0 setting 0 log log 2te log log2te 2 thus 2 0 log log 2te satisfies 3 hence log log 2te lemma pd denote least integer proof definition lemma 5 log2dlogd1ee lemma 1 definition sd example 1 table 1 values oe2 degree product primitive polynomials degree degree product primitive polynomials degree 2 tabulated long less maximum value table pd obtained table instead using lemma 6 example number modeled faults cut length test sequence degree product primitive polynomials degree less equal 33 first greater thus zeroaliasing lfsr primitive feedback polynomial degree 33 exists cut hand using bound lemma 6 get pd h closer look table 1 shows product primitive polynomials degree less equal 53 degree greater 14 thus long product number faults test sequence length less case practical test applications zeroaliasing misr degree less equal 53 exists 22 expected bounds deriving expected bounds assume polynomials fh g random polynomials denote product distinct irreducible factors degree j h g ij denote number distinct irreducible factors h degree j v value v range 0 minfbd jc 2 jg lemma 7 j 2 expected value v number irreducible degreej factors equal 1 proof let ir 2 set irreducible polynomials degree j gf 2 given polynomial q degree greater equal j define indicator function dp q one p divides q zero otherwise probability polynomial degree j divides random polynomial degree greater equal j 2 gammaj hence probability equal 2 gammaj thus type analysis used bound v arv variance v oe v standard deviation v lemma 8 j 2 variance number irreducible factors g ij less 1 standard deviation less proof variance v given v 2 j ik 2 j ik 2 j hence 2 j computed mean variance number irreducible factors degree j per polynomial compute confidence measure results lemma 9 j 4 expected number polynomials g ij 5 50 factors less jhj100 jhj10 000 proof using chebyshev inequality 8 p 376 probability v greater 5 less 001 using result define second random process random variable x 1 iff v greater 5 otherwise process bernoulli experiment 6 sec 64 expected number ij 5 factors upper bounded jhj100 variance similarly probability v greater 50 less 00001 expected number g ij 50 factors bounded jhj10 000 lemma 10 expected degree smallest irreducible nonfactor set polynomials h bounded dlog jhje 1 proof denote product polynomials g ij 1 jhj g j lemma 7 expected number necessarily distinct factors g j less jhjj smallest j 2 j exceeds value upper bound expected degree nonfactor hence ffi applying lemma 5 result lemma 10 corollary 11 expected degree smallest primitive nonfactor set polynomials h bounded 2 example 2 using numbers example 1 let first j exceeds jhjj hence expect find zeroaliasing misr primitive feedback polynomial degree less equal 14 opposed worst case 33 corollary 11 would give us upper bound 19 expected bound function number faults length test sequence expected degree zeroaliasing misr never exceed 53 fact long number faults less 1 million expect find zeroaliasing misr degree less equal 21 3 polynomial operations gf 2 search least degree nonfactor h use procedures sift factors degree given polynomial procedures based following lemma lemma 12 12 lemma 213 p48 x product irreducible polynomials degree l l divisor thus basic step finding distinct irreducible factors polynomial bx computation result operation product irreducible factors degree l ljm bx polynomials bx interest us 2 degbx therefore first compute analyzing complexity proposed procedures rely following results stated greater detail appendix complexity polynomial gcd operation oms log 1 pp 300308 degree larger polynomial operand ms complexity polynomial multiplication product degree complexity polynomial division also considered two multiplication algorithms first algorithm due schonhage 17 complexity os log log log second algorithm suggested cormen et al 6 p 799 complexity os log sequel shall use notation oms complexity polynomial multiplication whenever possible mean log otherwise taken log log log similarly notation ls denote either log log log log appropriate cost finding remainder x 2 divided bx without actually carrying division 3 15 omms thus computed omms ms log 4 finding nonfactor smallest degree given set polynomials establishing bounds least degree nonfactor h section 2 section addresses question finding least degree nonfactor h problem 2 given set polynomials let find irreducible primitive polynomial ax dega 1 equivalently h 6j 0 mod 2 irreducible primitive polynomials bx degb h j 0 mod b equiv alently exists h j 0 mod b one way solving problem factoring polynomials h would require much work since need know factors order find nonfactor need know small factors section present algorithms solving problem 2 analyze complexity complexity given two forms first worst case complexity bounds referred worst case complexity second expected complexity bounds referred expected complexity expected complexity refinement worst case complexity based expected size results procedures lemmas 1 6 section 2 upper bound depending whether looking irreducible primitive nonfactor using bound begin search process made three phases 1 h 2 h find g ij x product distinct irreducible primitive factors h degree j 2 found polynomials g ij determine whether irreducible primitive polynomials degree j factors h 3 irreducible primitive polynomials degree j factors h find one worst case complexities three phases irreducible case ojhju 2 mn log n ojhj 2 n 2 u 2 mu dominant term ojhj 2 n 2 u 2 mu worst case complexities three phases primitive case ojhju 3 mn ojhj 2 delta log n ojhj 2 n 2 u 3 mu log log u dominant term ojhj 2 n 2 u 3 mu log log u expected complexity first two phases ojhju 2 mn ojhj log jhju 2 delta log n expected complexity third phase ojhj log jhjd md find irreducible nonfactor ojhj log jhjd 2 log log md find primitive nonfactor dominant term ojhju 2 mn worst case complexity function jhj 2 n 2 multiplied terms logarithmic jhj n whereas expected complexity function jhjn multiplied terms logarithmic jhj n 41 product distinct factors degree given polynomial given polynomial h x upper bound u wish compute g ij product distinct factors h degree j u procedure computing polynomials g ij given figure 2 polynomials g ij computed three steps first u2 compute gamma x g ij product distinct irreducible factors h x degree j degree l ljj j less equal u2 2j u theorem 12 g i2j contains product irreducible factors degree l ljj h since degree g i2j much less degree h efficient compute g ij g i2j h thus step 2 end step 2 g ij contains factors degree ljj h sift factors degree less j g ij need divide g ij g il l ranges set divisors j carried step 3 procedure distinct factors enough looking primitive nonfactor end procedure g ij product distinct irreducible polynomials degree j factors h g ij need sift nonprimitive factors describing aspect introduce notion maximal divisors distinct prime factors q set maximal divisor q set example one prime factor polynomial gf q degree irreducible iff divides x divide x divisors k primitive degree iff irreducible divide x l gamma 1 l mdq ch 3 procedure distinct primitives shown figure 3 sifts nonprimitive factors g ij lemma 13 1 complexity procedure distinct factors ou 2 mn 2 complexity procedure distinct primitive ou 3 mn 3 complexity first phase ojhju 2 mn irreducible case ojhju 3 delta mn primitive case expressions irreducible case primitive case proof 1 worst case complexity procedure distinct factors follows step 1 procedure performs u2 gcd computations involving h complexity gcd computation ojmd thus total work first stage u step 2 procedure carries u2 gcd operations work required step step 3 every element sets divisors procedure performs division operation cost expression omd ojmd ij 2 complexity procedure distinct primitive follows iteration procedure distinct primitives reduces ij performs one gcd one division operation cost iteration ojmd ij u run procedure u times therefore additional work primitive case bounded ou 3 md cases values ij much less n hence actual work much less ou 2 mn dominant factor step 1 procedure distinct factors 3 set h based 1 2 complexity first phase jhju 2 mn irreducible case jhju 3 mn primitive case value u either sd h corresponding either irreducible primitive case lemma 14 expected complexity first phase ojhju 2 mn u equal either esh eph proof expected complexity procedure distinct factors dominated complexity step 1 ou 2 mn difference complexity steps worst case comes using expected size ij instead worst case size equal n expected complexity procedure including procedure distinct primitive set h thus ojhju 2 mn u equal either esh eph 42 number distinct factors degree set polynomials first phase degrees 1 j u jhj polynomials g ij product distinct irreducible primitive factors degree j h g ij might equal pairs might factors common goal find least degree nonfactor h first must determine whether irreducible polynomials degree j appear second three phases page 13 simple test compare degg j 2 j degg j nonfactor degree j primitive case compare oe2 j gamma1 j way determine whether irreducible primitive polynomials degree j factors g j find factors appear one g ij eliminate appearances except one considered two methods removing repeated factors first referred lcm method second referred gcd method lcm method shown faster also requires space might available lcm method first sort g ij according degrees place sets k g ij 2 k iff 2 sets fs k g ordered according index increasing order begin computing lcms two polynomials taken first set set one polynomial take second polynomial next set resulting lcm polynomial placed set corresponding degree process ends left one polynomial representing lcm polynomials g ij gcd method polynomials g ij sorted degrees iteration polynomial highest degree taken set pairwise gcds polynomials taken gcd greater 1 polynomial divided gcd end iteration none remaining polynomials set factor common polynomial taken thus procedure ends factor appears one g ij lemma 15 1 complexity second phase ojhj 2 mn log n 2 expected complexity second phase ojhj log 3 jhjln logjhjn proof 1 bound work required lcm method follows first assume jhj ij powers 2 bounding purposes increase nearest power 2 also assume polynomials leaves binary tree polynomials level degree level corresponds different set k assume every lcm step degree lcm sum degrees two operands ie operands relatively prime maximum degree final lcm jhjn computing lcm costs omjhjn logjhjn computing two lcms next last level costs o2 delta mjhjn2 delta logjhjn2 lower level twice many lcms computed costs less half cost level hence total cost bounded ologjhjnmjhjn logjhjn ou 2 mjhjn use lcm method need enough memory store final lcm required memory use gcd method work required ojhj 2 mn log n 2 taking account expected size polynomials g ij factorization becomes practical factoring algorithm used cantor zassenhaus 4 complexity factoring product r distinct irreducible polynomials degree j given ormrjj logrj lemma 9 expected number polynomials g ij 5 factors less jhj10 2k2 take number polynomials factors 99jh j polynomials 5 factors assumed 5 polynomials assumed 50 etc expected work required factor polynomials bounded ob 99jhj using fact 5j bound sum ob factorization completed irreducible factors sorted time ojhj delta log jhj unique factors counted summing log n since u log jhj expression becomes ojhj log 3 jhjln logjhjn 43 finding nonfactor third phase know smallest degree exists nonfactor h also jhj polynomials g id products distinct irreducible primitive factors h g id pairwise relatively prime every irreducible primitive factor degree h factor one polynomials want find irreducible primitive polynomial degree nonfactor h one approach divide product irreducible primitive polynomials degree product polynomials find factor result might pose problem product hand ie polynomials g id product large handle one polynomial another way randomly select irreducible primitive polynomials check whether factors nonfactors way check actual division division however regular long division fft division whenever divisor small degree compared degree dividend irreducible primitive polynomial relatively prime g ida nonfactor divides least one polynomials keep result division reduce work upcoming trials reduction requires polynomials repeat selection process lemma 1 complexity finding nonfactor known ojhj md irreducible case ojhj 2 n 2 3 md log log primitive case 2 expected complexity ojhj log jhjd md irreducible case ojhj delta log jhj delta 2 log log md primitive case proof 1 procedure generates random polynomials checks irreducibility primitivity whether factors expected number random polynomials tested irreducibility primitivity irreducible primitive polynomial degree found 2 dalog log 15 work required test polynomial irreducibility od md md 15 sum ij cannot exceed jhjn therefore jh jn da irreducible polynomials tried nonfactor found work involved try jhjn delta long division thus expected work required find nonfactor ojhj md primitive case work md log log 2 polynomials g ij factored see proof lemma 152 known draw irreducible primitive polynomials nonfactor found expect jhjd factors irreducible primitive polynomial drawn takes olog jhj check whether factor hence expected work required find non known bounded ojhj log jhjd md irreducible case ojhj log jhjd 2 md delta log log primitive case 5 practical scenarios section discuss practical scenarios finding zeroaliasing polynomials first want nonfactor prespecified degree second want find nonfactor fast third compare algorithm finding least degree nonfactor exhaustive search irreducible primitive polynomials ascending degrees cases type search faster 51 finding nonfactor prespecified degree cases register required function ra pg nonfactor prespecified degree needed thus problem 3 given set polynomials irreducible primitive nonfactor degree h problem exactly finding least degree nonfactor except need consider case instead iterating 1 j u first compute polynomials g determine whether nonfactor degree exists find one lemma 17 1 complexity finding nonfactor degree ojhj irreducible case ojhj 2 n 2 3 mt log log primitive case 2 expected complexity ojhjmnt log n proof 1 computing polynomials g involves computing g l 2 mdt computing f cost first gcd computation otmd cost jmdtj subsequent gcd divisions bounded olog ttmd md log substituting n get olog log n polynomials g need sift multiple instances irreducible polynomial using gcd method worst case cost ojhj 2 mn delta log n stage know whether nonfactor degree exists one exists carry phase 3 worst case complexity ojhj 2 dominant term whole process analysis primitive case hence worst case complexity finding irreducible primitive nonfactor given degree set polynomials h ojhj log log 2 turn analyze expected complexity h compute g x costs ojhjmnt log n cost sifting factors degree less g based expected number factors degree insignificant factoring sorting polynomials second phase expected cost ojhj log jhjt log n eq 5 expected number distinct irreducible factors degree h bounded jhjt thus cost finding nonfactor stage consists drawing jhj irreducible primitive polynomials expected cost ttmt tlog log delta 2 mt checking list factors bounded jhj ttmt logjhjt irreducible case ojhjlog jhj gamma log tt 2 mt log log primitive case hence expected complexity finding nonfactor degree h bounded ojhjmnt log n 52 finding nonfactor fast problem given set polynomials find irreducible primitive nonfactor h less 2 c tries sum degrees irreducible primitive polynomials degree less equal sd h pd h greater h look p u draw uniformly irreducible prim itive polynomials degree u 2 c drawings expect find nonfactor expected work cost case o2 c delta cost 2 c iterations drawing polynomial testing irreducibility one found dividing jhj polynomials candidate nonfactor using long division primitive case becomes o2 c delta u 3 mu log log u example 3 using numbers example 1 say want find nonfactor 8 tries compute bound p draw primitive polynomials computed bound use table 1 see instead looking polynomials degree less equal 33 need consider primitive polynomials degree 34 general 2 c 2 hence lemma 6 consider polynomials degree greater 2 case want minimum degree nonfactor also use expected bounds esd epd lower degrees candidate nonfactors 53 exhaustive search subsection compare algorithms exhaustive search least degree nonfactor look irreducible case assume least degree irreducible nonfactor degree also assume list irreducible polynomials ascending order number irreducible roots degree j less 2 j bound work required find nonfactor exhaustive search ojhjn2 da1 using expected bound olog jhj bound work n expected work required find least degree nonfactor algorithms ojhju 2 mn becomes ojhj log 2 jhj delta n log n substitute value u taking account constants involved two results ratio work required exhaustive search relative work required algorithm log 2 jhj log n assuming ratio less 1 n 1210 assuming ratio less 1 n 124 500 ratio less 1 n 365 284 284 suggests number faults interest small less 1024 exhaustive search might efficient algorithms however number faults increases algorithms efficient test sequences realistic length finally number faults greater 4096 practical test lengths algorithms efficient simple exhaustive search 6 experimental results following experiments conducted verify results experiments conducted hp700 workstation 61 random selections based absolute bounds experiment set follows generated set 1000 random polynomials degree 200 000 corresponds cut 1000 faults ie 1000 test length 200 000 ie degree product polynomials h less equal 200 000 000 wanted probability greater 12 finding nonfactor one drawing primitive polynomial looking table 1 achieve selecting set primitive polynomials degree less equal 29 polynomials drawn 2 step process first step selected degree primitive candidate second selected candidate first step selected number took value modulo number primitive roots fields gf 2 gf 2 29 result used determine degree primitive candidate looking first field gf 2 number primitive roots fields gf 2 gf 2 greater result selection actual polynomial done setting coefficients lfsr primitive feedback polynomial degree gamma 1 initialized random state guarantees candidate selected twice candidates chance considered candidates tested primitivity primitive tested nonfactors point found factors search continued current state degree ran 200 experiments 200 experiments first primitive candidate turned nonfactor nonfactors found 1 degree 21 2 degree 22 3 degree 23 2 degree 24 7 degree 25 13 degree 26 32 degree 27 35 degree 28 105 degree 29 number polynomials tested primitivity one found ranged 1 160 average number 16 time took find primitive polynomial ranged 001 seconds 079 seconds average time 0104 seconds took 15325 16668 seconds find nonfactor average 16050 seconds experiments show given error sequences faults interest easy find zeroaliasing polynomial circuit 62 random selections based expected bounds based expected bounds corollary 11 able find nonfactor degree 14 ran 100 experiment time selected primitive polynomials degree 11 expected bound based table 1 first primitive candidate selected nonfactor 66 100 experiments 19 experiments found nonfactor second candidate 11 third 2 fourth 1 fifth 1 sixth ran 100 experiments selecting primitive candidates degree 9 number primitive candidates tried nonfactor found ranged 1 28 average number candidates 75 test tightness expected bound ran 126 experiments 1024 random polynomials degree 200000 generated exhaustive search increasing order degrees conducted find least degree nonfactor expected bound least degree less 14 one experiment least degree 7 35 8 remaining 90 experiments least degree 9 experiments conclude error polynomials fact random polynomials expected bounds based analysis expected number factors certain degree random polynomial fact upper bounds least degree nonfactor set polynomials expected bounds obtained table 1 tighter corollary 11 63 experiments benchmark circuits tried worst case expected bounds error sequences two circuits berkeley synthesis benchmarks 2 first circuit in5 second in7 used fault simulator take account fault collapsing hence number faults twice number lines circuit stuckat0 stuckat1 faults line circuit in5 1092 faults six redundant hence 1086 detectable faults circuit 14 primary outputs used test sequence length 6530 detects nonredundant faults computed effective output polynomials faults nonzero hence cancellation errors one output errors another output thus 1086 error polynomials degree 6543 table 1 worst case bound degree primitive nonfactor 23 draw primitive nonfactor probability greater 1we need consider primitive polynomials degree 24 less conducted 20 experiments drawing zeroaliasing primitive polynomials based worst case bounds experiments first candidate nonfactor conducted another 20 experiments time drawing primitive polynomials degree 14 size register available circuit outputs experiments first candidate nonfactor based expected bounds table 1 find nonfactor degree 11 less tried finding nonfactor degree 11 9 7 degree 11 experiments 17 20 cases first primitive candidate nonfactor two experiments found nonfactor second try one third conducted 15 degree 9 experiments considering 48 primitive polynomials degree 9 48 primitive polynomials degree 9 33 factors 15 nonfactors average number candidates tried nonfactor found 3 1 primitive polynomials degree 7 factors circuit in7 568 faults 567 nonredundant circuit 10 primary outputs used test sequence length 9280 using worst case bounds ensure selection primitive nonfactor probability greater 1 considered primitive polynomials degree 24 less 20 experiments found nonfactor first candidate expected bound table 1 degree primitive nonfactor 10 tried find nonfactors degree 11 10 size register available outputs degree 11 experiments found nonfactor first try 13 found nonfactor first try 6 second one third circuits tried find least degree nonfactor using exhaustive search since fault extractor used fault collapsing error polynomials identical summing values nonzero erroneous output words simulated fault found least 292 different error polynomials in7 least 566 different error polynomials in5 would make expected bounds table 1 9 in7 10 in5 circuits least degree nonfactor degree 8 took 11 cpu minutes find polynomials experiments two benchmark circuits show assumption error polynomials behave random polynomials invalidate analysis results expected bounds case random experiments upper bounds least degree nonfactor conclusions paper presented procedures selecting zeroaliasing feedback polynomials misr based ras pgs ras designed lfsrsmisrs scheme combined algorithms selecting efficient feedback polynomials pattern generation 11 enables selection one feedback polynomial serves tasks thus reducing overhead reconfigurable registers presented upper bounds least degree irreducible primitive zeroaliasing polynomial set modeled faults showed practical test applications polynomial always degree less 53 fact expected bounds number faults less 10 6 degree 21 experiments conducted zeroaliasing polynomial degree less expected bound always found also presented procedures finding zeroaliasing polynomial objective minimize degree specific degree speed analyzed computational effort required worst case conditions expected conditions partial summary results presented table 2 worst case analysis expected analysis table 2 shows upper bounds smallest nonfactor computational complexity finding smallest nonfactor complexity finding factor given degree speed requirement showed find zero aliasing polynomial average two tries increasing degree polynomials consider two upper bound size minimum degree based analysis experiments conclusion error polynomials modeled target faults available zeroaliasing easily achievable goal thus ensure high quality tests premium put fault modeling automated test pattern generator design fault simulation tools available zeroaliasing problem acknowledgment wish thank professors l adleman breuer j ierardi l r welch many helpful discussions also wish thank anonymous referees helpful comments r design analysis computer algo rithms logic minimization algorithms vlsi synthesis factoring polynomials large finite fields new algorithm factoring polynomials finite fields introduction algorithms concrete mathematics complexity multiplication finite fields test embedding discrete logarithms introduction finite fields applications achieving zero aliasing modeled faults new framework designing analyzing bist techniques probabilistic algorithms finite fields book prime number records schnelle multiplikation von polynomen uber korpern der charakteristik 2 tr ctr krishnendu chakrabarty brian murray john p hayes optimal zeroaliasing space compaction test responses ieee transactions computers v47 n11 p11711187 november 1998 novk z plva j nosek hlawiczka garbolino k gucwa testperclock logic bist semideterministic test patterns zeroaliasing compactor journal electronic testing theory applications v20 n1 p109122 february 2004
reusing analogous components abstractusing formal specifications represent software components facilitates determination reusability precisely characterize functionality software welldefined syntax makes processing amenable automation paper presents approach based formal methods search retrieval modification reusable software components twotiered hierarchy reusable software components existing components analogous query specification retrieved hierarchy specification analogous retrieved component compared query specification determine changes need applied corresponding program component order make satisfy query specification b introduction major objectives reuse system classify reusable components retrieve existing library modify retrieved components satisfy query specification 1 2 previous investigations construction retrieval processes formally specified implemented 3 4 5 6 set reusable software components formally specified twotiered hierarchy software components constructed formal specifications represent software implemented verified correctness lowerlevel hierarchy created subsumption test algorithm determines whether one component general another level facilitates application logical reasoning techniques finegrained exact determination reusable candidates higherlevel hierarchy provides coarsegrained determination reusable candidates constructed applying hierarchical clustering algorithm general components lowerlevel hierarchy hierarchical structure provides means representing storing browsing retrieving reusable components furthermore formal specifications provide means verifying given software component correctly satisfies current problem figure 1 shows twotiered hierarchy set containerbased software components formally specified rectangular nodes represent specifications individual components oval nodes represent collection specifications clustered according syntactic similarities reusable components retrieved typically cannot used directly implementation query specification numerous software reuse projects explored use analogy similaritybased techniques determine software reuse due space constraints descriptions projects given may found 22 paper describes new approach retrieving components based analogies existing query specifications paper describes new approach modifying retrieved components based analogies existing query specifications analogical relationships query specification specification existing component used guide changes program code existing specification analogical reasoning long recognized important tool overcome search complexity finding solutions novel problems inducing generalized knowledge experience 7 analogy presents basic challenging question two specifications problem representations given purpose alike 8 development programs based series transformations extensively investigated 9 10 11 12 program modification different traditional program transformation program transformation typically correctness preserving respect figure 1 twotiered hierarchy adt software components original specification program modification approach needs program satisfies original inputoutput specification along specification new program dershowitz 13 developed approach program construction modification based observation programmers devote limited amount time effort newly develop code given specification programmers often apply knowledge earlier programs development similar problems work focuses augmenting dershowitzs methods order make amenable automatic applications facilitate software reuse remainder paper organized follows section 2 presents formal specification notation used describe reusable software component section 3 presents analogical matching process find set analogical matches existing specification query specification section 4 describes program modification model based analogy section 5 gives example modifying analogous component based analogical matches existing query specifications section 6 describes related projects used analogy similaritybased techniques determine software reuse section 7 gives concluding remarks briefly overviews future work formal specifications software components firstorder predicate logic fopl commonly used specify programs 14 15 16 17 order specify reason programs data types arrays simple variables sorts types added fopl obtain ordersorted predicate logic ospl moreover ordersorted specifications shown useful tool describing partially defined functions error handling specification abstract data types 18 19 ordersorted predicate logic ospl based ordersorted specifications used represent typed knowledge hierarchy gives relationships among different types sort refers data types given system sort hierarchy begins primitive data types int float addr recursively built using structures arrays sets use ordersorted predicate logic specify software components relationship two components reusability one component respect another based sort information logical subsumption test applied specification body details regarding syntax semantics ospl reader referred appendix general software component consist requirements design knowledge code segments test plans component used vehicle encapsulation data hiding also provides basic unit reusability define component explicitly userdefined type whose behavior described formal specification skeleton component specification shown component component name identifier f inherit component name identifier method method name identifier key word inherit indicates current component inherits properties components previously defined components specifications method section define behavior methods component format method specification method method namev ar domainsort requires preexpression modifies variables ensures postexpression expressions used specify method given component including preexpression postexpression based ospl method interface specifies domain sorts range sort requires clause describes restrictions arguments defines method may invoked although equality defined ospl expressions containing equality always transformed pure ospl expressions 20 variables prime latest value given variable interpret omitted requires clause equivalent requires true ensures clause places constraints behavior method requires ensures clauses relate two states program state method called call precondition state terminates call postcondition requires clause refers values precondition ensures clause may refer values pre postconditions modifies clause describes variables changed omitted modifies clause equivalent assertion modifies nothing meaning objects allowed change value execution method example method specification component stack shown figure 2 consists function prototype followed body specified terms pre postconditions component stack f method create modifies stack ensures method destroy stack modifies stack ensures trashedstack method requires fullstack modifies stack ensures topstacknewelement method requires emptystack modifies stack ensures topstack topelement method requires emptystack ensures topstacktopelement figure 2 component specification stack figure 2 asserts method create constructor component method destroy destructor component method push adds element stack method detach deletes element stack method topelement returns top element belongs stack moreover variables expressions without quantifiers assumed universally quantified 3 analogical matching analogical match defined group pairings symbols terms candidate query specifications pairings based type similarity consider following two expressions theory abstract data types f toppushstack matching process may generate following set analogical matches ftop 7 head push 7 enque stack 7 queue ff 7 fi 7g example exhibits bijective mapping terms toppushstack however features needed order increase flexibility analogical match example ffl variable predicate function constant symbols may matched different variable predicate function constant symbols respectively ffl arguments predicates functions matched may permuted matching process since argument order functions predicates often arbitrary obviously unreasonable insist matches preserve argument order therefore allow permutations arguments order increase scope applicability ffl semantic information sort hierarchy equivalence classes incorporated analogical matching process ffl techniques seek syntactical similarities used reduce computational complexity analogical matching process ffl symbols terms may left unmatched analogical matching process ie loosening restriction bijective mapping general universally accepted recognized algorithm determining software reuse based analogy furthermore formal theory rule rigorously describes process guarantee generation useful analogical match 21 therefore analogical matching algorithms use heuristics direct searches useful analogical matches given heuristic captures systemdefined criteria constitutes reasonable analogy 31 heuristics using example previous section matching association two terms ie subset cartesian product sets symbol occurrences terms example term contains 6 symbols cartesian product contains 6 theta 6 36 symbols hence 2 36 subsets clearly heuristics needed prune search space heuristic used analogical reasoning systems must determined kind information system enhance applicability heuristics contextual knowledge included heuristics order develop reuse system based analogy support use domainspecific knowledge domainindependent techniques search modification processes assumed majority domainspecific information supplied interactively user guided framework provided domainindependent techniques associations often believed make good analogues similarly matches containing high proportions identical associations make good analogies identical associations refer purely based syntactic information call approach identity heuristic however interesting analogies involve significant proportion nonidentical associations similarities incorporated determine analogical match promising similarity match defined distance associated terms definition distance defined section 32 call heuristic similaritybased heuristic heuristic already incorporated system classify set software components retrieve set candidate components component library 3 4 5 6 another promising analogical approach consider matches take account structure terms call approach structurebased heuristic analogical reasoning systems use form structural mapping find analogies two problems one approach make use sort hierarchy ie primitive types well types developed constructively type information make similarity judgement thus earning name sortbased heuristic define two terms analogous common ancestors sort hierarchy analogical matching process favor association two analogous terms heuristic criteria prefer matches items similar types according equivalence class partition symbols predicates function symbols constants call approach equivalencebased heuristic requires system designers define equivalence classes predicate function symbols specify software components system 3 4 5 6 construction process assesses equivalence class predicates functions constructs unified hierarchy software components example function lengthqueue gives length queue function sizestack gives size stack belong equivalence class cardinalitycontainer gives cardinality entity container analogical matches considered reuse framework predicates mapped predicates operators matched operators number arguments propositional connectives mapped propositional connectives therefore analogical matching process begins retrieving set components type syntactic similarity means filter components considered reuse based set analogies sought query specification retrieved specifications analogies found specifications used guide changes corresponding source code 32 computing similarity section simple evaluation method computing similarity given set candidate components similar query specification retrieved software library based degree similarity existing specifications query specification paper similarity quantified nonnegative magnitude value called distance distances computed several evaluation functions based knowledge available sort hierarchy concept equivalence class conceptual distance two terms evaluated distance shortest path corresponding sorts sort hierarchy used turn evaluate similarity query specification specification existing components distance two let distance two sorts 1 2 denoted sorts distance sort 1 sort 2 defined distance shortest path 1 2 sort hierarchy path exists path value set 1 1 2 distance zero figure 3 gives simple sort hierarchy set subsort container partialorderset subsort set distance sort stack sort doublelist 3 according definition 1 ie stack container stack set list queue partialorderset integerset doublelist singlelist figure 3 simple sort hierarchy distance terms let distance two terms 1 2 denoted refers terms operator least one argument let w 1 weight associated operator w 2 weight associated arguments assume 0 w 1 10 distance two terms defined follows equivalence class terms equivalence class considered similar 3 either 1 2 variable theta w 2 calculate recursively functions mthetan theta w 2 weights w 1 w 2 represent distances operators corresponding arguments contribute distance terms 1 2 weights provided either domain analysts component specifiers reflect design decisions domainspecific information distance expressions let distance two expressions ff fi denoted e ff fi distance two expressions defined follows pred fi equivalence class e ff fi j 0 pred fi e ff fi j ff fi 05 binary operator op represents predicate connectives implication iff computing distance two expressions input expressions skolemized hence variables assumed universally quantified based distances terms expressions distance two methods defined follows definition 4 distance two methods let distance two methods 1 2 denoted dm precondition 1 2 postm 1 postcondition 1 2 distance two methods follows finally distance two components defined terms distances corresponding methods distance two components let distance two components c 1 c 2 denoted c c 1 c 2 provided c 1 candidate component c 2 query component specification distance c 1 c 2 defined min 33 topdown matching approach second step analogical matching process assess analogical relationships query specification specifications retrieved based similarity context recognizing reusable candidate specifications solving query specifications analogical matching process flexible notion analogybased match rather imposing design bias towards single heuristic easily tailorable particular domainspecific strategies heuristics mentioned section 31 refined specific numerical metric created measure usefulness given analogy precise definition goodness analogy match given analogy problem regarded optimization problem optimization problem finding global optimum typically feasible therefore might want generate set local optimal analogies point analogical matching process regarded recursive problem solving process initial problem match specifications two terms matching process continues new subproblems produced recursively solved new subproblems produced two cases 1 one subproblems terms constant variable 2 new analogical match applicable subproblem analogical matching process generates set analogical matches two input expressions let list terms form terms empty list denoted similar prologs definition lists list head first element l tail list l except first element head deleted list define analogies pair lists length analogies two lists different cardinality discussed later definition 6 analogies pair lists two lists 1 following condition holds definition says result applying analogical matching pair lists equal union results matching corresponding terms two input lists since ospl used express behavior software components object language analogy system based upon firstorder logic sort hierarchies sort equivalencebased heuristics suggest matches two terms analogical matches limited terms equivalence class terms sort explore incorporate properties commutativity matching process unsatisfactory analogical matches pair terms based arbitrary preservation argument order generation subproblems matching process classified two kinds branches orbranch andbranch want match terms containing commutative operator set derived subproblems may suggest one way solving problem therefore orcase applies current problem branch set new subproblems generating new group analogical matches example consider following g since max min commutative operators matching process produces set partial matches fmax 7 ming respectively matching process generates following two orbranch subproblems hyg thus current state matching pair terms involves set partial matches two sets orbranch subproblems need solve one orbranch subproblems order proceed subsequent stages matching process orbranch subproblems generated permuting order arguments obtain new sets argument mappings let us consider another example f fi commutative operators matching process generates set partial matches f7g two andbranch subproblems generated follows f fi j hi g current problem split two new sets subproblems represented andbranch together partial matching newly generated matches two subproblems conflict inconsistent analogical matches generated define consistency shortly examples may conclude andbranch subproblems generated whenever argument matching within identical argument mapping performed orbranch subproblems generated whenever matching process encounters commutative terms attempts perform argument matching permuted argument mappings terms terms latter case include ordinary predicative connectives example according previous discussion define matchability two expressions ie attempt answer question two expressions matchable following definition checks matchability two expressions recursively simplest notion matchability two terms common ancestor sort hierarchy two terms equivalence class two expressions 1 2 matchable denoted matchablet 1 2 iff one following conditions holds analogous ie common ancestor sort hierarchy 2 either t1 term 2 t1 pred 2 term predicate equivalence class respectively analogical matching process two inputs 1 2 1 matchable 2 returns empty set definition consistency analogical matches defined terms conflicts conflict occurs given term one match set matches theta three separate cases enumerated indicate simple variables functions lists expressions definition 8 conflict let match oe simple identifiers functions lists terms oe 1 conflict existing set matches theta denoted one following conditions holds conflictff 7 gg theta therefore given match oe consistent set matches theta conflicts within theta definition 9 consistent match oe consistent existing set matches theta oe conflicts theta denoted consistentoetheta consistentoe theta j conflictoe theta matching algorithm restricted preservation argument order second requirement definition 8 never applicable matching process scoring function let phi set analogical matches form fx 1 7 g score phi computed scoring function distance function overloaded applied identifiers functions lists terms 34 matching algorithm analogical matching process generates set analogical matches two formally specified input expressions define application analogical matching process expressions follows given matching subproblem consists pair specifications ff fi well existing set matches phi matching algorithm attempts find new set consistent matches returns user assume variables pair inputs either skolemized universally quantified algorithm match expr matches two expressions given figure 4 algorithm matching two terms match term given figure 5 algorithms based analogical matching approach presented section 33 considering algorithm matching two expressions inputs terms algorithm matching two terms match term invoked condition two terms matchable case 3 algorithm match expr gives example generating andbranch subproblems consistency analogical matches corresponding items two input lists hold cases 5 6 7 algorithm match expr give examples generating orbranch subproblems set analogical matches smaller score returned calling function let us consider algorithm matching two terms algorithm match term case 1 matches two terms either one variable algorithm returns two terms new match matchable similar case 3 algorithm 1 case 3 algorithm match expr matches two lists case 4 matches two operators least one arguments noncommutative case 5 matches two operators input operators commutative arguments case 6 matches two operators different numbers arguments several heuristics exploited matching algorithms two algorithms use topdown scheme compare two input expressions terms predicate connectives two input expressions functor symbols two input terms matched arguments matchings performed hence structurebased heuristic applied however commutativity arguments incorporated matching algorithms term commutative algorithm 1 match input two sigmaexpressions current partial matches phi 4 sigmaexpressions 1 2 sigmaterms letomega fi predicate connectives output new set partial matches procedure begin switch case matching two terms returnmatch else returnphi case matching two empty lists case 3 e 1 matching two lists expressions returnmatch expr ail case matching two expressions returnmatch expr case 5 e matching two expressions match match case 6 e matching expression term case 7 e matching term expression end figure 4 matching two expressions algorithm 2 match input two terms set partial matches phi output new set partial matches procedure begin case 1 either 1 2 variable g else returnphi case matching two empty lists case 3 matching two lists returnmatch case matching two operators either f g noncommutative consistentff 7 gg phi f term g f pred g return match else return case matching two commutative operators consistentff 7 gg phi f term g f pred g match match else return case 6 matching two operators different numbers arguments returnmatch end figure 5 matching two terms operator several variations term permuted arguments created generate orbranch subproblems otherwise andbranch subproblems generated pair input arguments scoring function based distance notions used determine set matches returned therefore similaritybased heuristic incorporated matching algorithms notion equivalence class used determine two functors matched example cases 4 5 algorithm match term hence equivalencebased heuristic applied algorithm matching two terms definition predicate consistency given definition 9 therefore implicitly exclude possibility mismatched analogical match allows mapping one toone even though may useful analogy real world mismatches allowed analogical matching algorithms considerably large amount domain knowledge would need encoded systems knowledge base case 6 algorithm match term deals condition arguments two input terms different sizes 6 n case need transformation rules rephrase input terms make arguments cardinality transformation rules require domain knowledge example suppose want match p c since functions squareroot division different numbers arguments need transformed system rule 1 match easily found f 7 p 7 c 1 7 dg system rule theta 1 following algorithm provides framework domainindependent matching process domain knowledge tailorable specific types information complexity algorithm increases matching process encounters commutative operator let levelff denote depth operator ff example depth constant 0 depth leveloparg g pair commutative operators ff fi matching process generates two subproblems hence algorithms upper bound minflevelff levelfig theta 2 minflevelfflevelfig details regarding complexity analysis algorithsm please see 22 algorithm match term case 5 always generates two sets analogical matches currently operators able generate orbranch subproblems commutative consist two arguments assume case 6 algorithm match term transforms input terms one pair operators number arguments implementation section presents implementation matching algorithm prototype system facilitating software reuse implemented quintus prowindows language dialect prolog supports objectoriented organization graphical elements system provides functions constructing hierarchical library 3 retrieving existing components logicbased generality relationship query component 5 assisting users modification general analogous existing components satisfy query specification 6 let existing specification old spec specification stack class given figure 2 query specification query spec specification doublelist class given figure 6 addition constructor destructor operations component defines four methods addathead addattail detachathead detachattail purpose conciseness consider relationship two methods stackpush doublelistaddattail order find analogous existing component based query specification doublelist apply matching algorithm methods doublelist figure 7 shows results application matching algorithm method doublelistaddattail method stackpush left part figure 7 displays twotiered hierarchy group components described formal specifications compute analogies window displays query existing components methods respectively candidate analogies window displays matches found match expr matching algorithm matches helpful terms modifying existing components reuse users may discover inherent similarities two components logical relationships found automated reasoning given candidate matches user reuse redesign query component example system using match expr suggests several matches may useful modification process example result suggests order satisfy query specification input object changed stack dbllist new element added tail dbllist instead top stack 4 program modification model regard modification process problem solving process figure 8 contains framework modifying components based analogies found two formal specifications problems process defined specifications represent reusable software components solutions become executable implementations corresponding component doublelist f method doublelist modifies dbllist doublelist ensures method destroy dbllist modifies dbllist ensures trasheddbllist method doublelist modifies dbllist ensures headdbllistelement method doublelist modifies dbllist ensures taildbllistelement method doublelist requires headdbllistelement modifies dbllist ensures method doublelist requires taildbllistelement modifies dbllist ensures figure 6 component specification doublelist figure 7 implementation matching process specifications formal specifications used indexing mechanism traditional tasks classification retrieval search program modification amenable automated reasoning techniques greatly facilitate scalability compared keywordbased manual approaches software reuse objective software development context solve problem defined specification query spec finding appropriate implementation old spec referred candidate specification whose implementation old program known analogical matching process used guide modification process performed software developer set analogical matches found two specifications used basis potential changes existing specification corresponding software component satisfies relationship defines relationship specification implementation modules given specification two methods old spec query spec assume old spec specification method given component library query spec specification analogical matches queryprogram oldprogram queryspec oldspec satisfies satisfies program analogical matching modification figure 8 analogical reuse modification process method query component let old program implementation satisfies old spec suggested steps modifying existing program old program new implementation query program based analogical matches old spec query spec given figure 9 method specification old spec existing component analogous method specification query spec query component set analogical matches theta found analogical matching process presented section 3 according theta existing implementation old program modified program old program step also rewrite unexecutable statements modified program old program eg type incompatibility finally old program query spec supplied program synthesizer either semiautomated program synthesis system 12 23 programmer using formal approach program derivation 17 24 25 26 order obtain new implementation query program satisfies query spec input old spec query spec old program output query program procedure 1 analogical matching find theta set analogical matches old spec query spec 2 program replacement refine old program old program according theta 3 program adaption synthesize new segments old program obtainderive query program satisfies query spec figure 9 modification process based analogy analogical match candidate query specifications found effort required develop appropriate implementation query program significantly reduced since needed changes specification level clearly determined source code edited call approach modification existing program based analogical match two specifications analogical reuse modification process armp problem finding promising candidate specifications query specification large knowledge bases known implemented specifications referred base filtering problem 27 reuse system retrieval scheme based similarities among reusable components finds set candidate specifications similar query specification retrieval process augments armp model form preprocessing phase emphasized reuse finegrained component level limited amount domain knowledge needed order apply analogical reasoning furthermore comparison current techniques reuse largely based keyword searchers specificationbased reuse least effective addition amenable automated reasoning 5 modification example program modification combination analogy transformation synthesis verification section give example program modification based analogy show matching process plays important role modification process consider following specification square root program pre postconditions square root program respectively given two numbers e desired result approximation r real number square root tolerance value e assume existing program performs real division follows begin e qs c q q od end apply matching process algorithm match expr pair postconditions two programs case 1 ie r 1 r j g transformation rule 1 match found follows using algorithm match term case 7 c 7 match applied real division program becomes begin e od end however 1 contains expression objective implemented program need rewrite statement preserves semantics eliminates p program squaring addition comparison regarded elementary operations obtain following program begin e od end algorithm result r falls range 0s ie 0 r however 0 r 1 never find desired answer problem solved replacing initialization command 1 square root bounded 1 consequently desired program becomes begin e od end despite simplicity example potential benefits program modification apparent example section programmer save programming effort reusing modified program instead program everything scratch analogical match found programmer develop parts program cannot reused old one hopefully requires much less necessary generate entire program reuse framework applied development graphical user interfaces based specification existing graphical components 6 formal specifications motif widgets constructed applying classification scheme organized hierarchical structure user query structured terms highlevel implementationindependent specifications specification level user concerned setting specific attribute values given widget widgets combined achieve given behavior providing means user classify browse retrieve graphical components based behavior functionality enabled users focus high level requirements graphical interface search mechanism determined whether given component modified combined components satisfy query specification 6 related work section contains descriptions software reuse projects use techniques similar presented paper two major categories reuse techniques described first techniques involve use analogy discussed next techniques calculate similarity software components based representation software described 61 analogies specifications software reuse dershowitz 28 suggested formulation program using analogies basic tool program abstraction analogy first sought specifications given programs process yields abstract specification may instantiated given concrete specifications analogy used basis transforming existing program abstract schemas helping complete analogy given concrete specification new problem may compared abstract specification schema suggest instantiation schema yields correct program rose2 project 29 based knowledgebased refinement paradigm software development process usersupplied requirements used select customize highlevel design paradigm supported knowledge base highlevel design abstractions called design schemas refinement rules schemas rules used customize users designs satisfy users requirements design decisions bhansali 30 describes derivation concrete program semiformal specification problem used transformational approach based set transformational rules produce topdown decomposition problem statement level target language primitives topdown decomposition process combines ideas research planning generate programs efficiently reuse domain specific knowledge emphasized approach apu system uses proposed paradigm synthesize unix programs shell scripts semiformal specifications programs maiden sutcliffe 31 investigated potential specification reuse analogy possible benefits requirements analysis developed two realworld examples determine potential specification reuse analogy first example illustrates analogy airtraffic controller atc flexible manufacturing system fms second example identifies analogies atc classroom administration system cas fms cas propose software engineering analogy model based upon three types knowledge solution knowledge domain knowledge goal knowledge lung urban 32 proposed analogy model software reuse addition constraints proposed maiden sutcliffe added constraints handle software analogy analysis information due complexity software system proposed analogybased domain analysis method support high level reuse across domains purpose help users better understand domain support potential future reuse different domain caret analogybased retrieval system applied software design reuse design cases actual designs design schemas templates available reuse knowledge base caret consists background knowledge design library background knowledge contains basic object lattice data type lattice isapartof hierarchies composite types design library consists set domain dictionaries one per design family bookkeeping information facilitate retrieval set design schemas templates exists application domain domainspecific design schema corresponds design family specialized schemas correspond design subfamilies caret uses twophased approach retrieval first description query design case used determine belongs one design families dictionary entry design family provides similar design cases corresponding design schema search fails analogybased search pursued objecttype datatype lattices used establish relationships query design designs library similarity value calculated new design case retrieved design library computational model similarity developed support software reuse based analogy 33 telos language 34 used describe similarity different artifacts code design requirement specifications language structurally object oriented data model multiple meta classification multiple generalization typed attribution abstractions used model classification generalizationspecialization attribution four basic categories telos objects used calculate similarity entity tokens attribute tokens entity classes attribute classes model based similarity distance functions distances calculated objects classes respect identification classification hierarchies generalization attribution 62 similaritybased techniques software reuse number projects used casebased reasoning cbrlike techniques facilitate software reuse general cbr five general characteristics 35 first cbr attempts recall old cases help solve new problems next understanding new situation terms old cases old cases may applicable problem becomes better understood third cbr involves adapting old cases fit new needs fourth processing evaluating adapting old cases potentially process learning solve given problem new novel way information used future finally need able integrate new experience memory properly hierarchy cases built bottomup fashion existing cases order facilitate recall retrieval 35 cases clustered generalized according set common features types indices used cases include goals constraints feature combinations describe given problem solved remainder section overviews several projects use cbrlike techniques addressing problem software reuse based major characteristics cbr systems reuse framework shares similar objectives means achieving goals differ major difference formal specifications software components used means classification retrieval adaptation software automated reasoning applied logical analogical relationships specifications used determine set candidate components reuse also relationships specifications used determine type adaptation needed modify existing component satisfy requirements new component aireuse system airs 37 supports browsing software library components meet userspecified requirement representation scheme similar framebased system search mechanism based similarity computations much like used casebased reasoning systems 35 component defined set featureterm pairs feature represents information respect given classification scheme defined set related terms candidate reuse components retrieved based degree similarity target source descriptions similarity described terms distance factor proportional amount effort needed compose modify existing components satisfy target component effort calculation based information obtained experienced software developers domain specialists prietodiaz 38 developed faceted classification scheme support storage retrieval reusable software components facets refer important keywords obtained program descriptions documentation approach makes use faceted scheme thesaurus conceptual distance graph software component associated descriptor consists ordered terms facet thesaurus used help refine definition component provide context information conceptual distance graph provides means measure similarity facet terms used turn evaluate similarity required software specifications available components 37 faceted approach requires domain analysis constructing conceptual graph conceptual distances assigned based experience intuition common sense lassie large software system information environment 39 uses semanticnet based approach provide structured representation knowledge reasoned respect semantic information knowledgebase used store different types information large complex software systems focusing programmers view semanticbased search algorithm using logical inferencing used retrieve information large software components framebased language used represent classes objects actions domain analysis used extract descriptions objects actions based information gained reading large volumes architecture documents comments source code files frame definition contains superframes general classes set restrictions parent frames create specialized object slots used contain constraints restrictions frames using type representation hierarchy frames created information knowledgebase applicationspecific order achieve invisibility across different types software artifacts source code documentation error reports etc case assisted reuse object library carol 40 supports reuse class descriptions objectoriented programming carol computes similarity existing class descriptions target class specification similar descriptions returned case consists set prolog facts describe class terms name attributes relationships classes stored case format terms class names class type instance variables others class methods classified according type processing performed variables method modifying instance variable checking instance variable returning variable attribute oriented approach used search reusable classes attributes include class name taking consideration synonyms position class hierarchy attribute importance based userdefined weights users specify target class assistance templates reqcoll requirements collector 41 tool facilitates requirements capture analysis processes conceptual graphs cg 42 used capture domain information graph matching algorithm used determine whether existing cg matches cg new problem description reqcoll nodes either concepts relations problem description relations define concepts related one another concepts may either objects actions problem domain concepts relations associated types thus respective type hierarchies defined isa relationship directed arcs used connect concepts relations reqcoll stores patterns cgs specific application domains user describes problem terms cg reqcoll invokes matching process determines whether new cg matches cg stored system graph matching algorithm uses recursive approach calculate similarities pairs arcs subarcs respective cgs heuristics used means attempt reduce number computations necessary find best possible permutation arc pairs case two cgs number arcs matching algorithm constant weight factor account unmatched arcs depending amount similarity stored cg newly usercreated cg user may wish add information new cg make closely fit stored cg pursue requirements analysis process without use existing cg 7 conclusion paper described approach applying analogical reasoning reusing software components described formal specifications studies demonstrated analogical matching specifications effective means software reuse investigations also show supporting understanding candidate analogies important factor successful specificationlevel reuse reuse framework applied development graphical user interfaces guis existing graphical user interface components 6 general armp needs didactic support comprehension candidate specifications requires explanation facility help software developer understand target domain base specifications since automated armp unlikely achieve perfect match explanation systems domain experts also necessary evaluating appropriate target specifications currently investigating software reuse program adaptation existing specifications general abstract query specification 43 future investigations sophisticated knowledge incorporated evaluation function order increase number analogy candidates retrieved query specification also investigating specification designlevel descriptions systems order perform coarsegrained determination reuse level envisioned domainspecific information incorporated determining reuse order facilitate construction specifications reusable components complementary investigations pursued reverse engineering order abstract formal specifications existing software 44 45 46 area formal construction specifications requirements models 47 48 acknowledgements authors grateful detailed comments given anonymous reviewers helped greatly improve presentation paper also authors greatly appreciate assistance provided david leake george spanoudakis igor jurisica r identifying qualifying reusable software components reuse software issues research directions using formal methods construct software component library formal methods applied reuse using automated reasoning determine software reuse applying formal methods software reuse paradigm reasoning analogy computational approaches analogical reasoning comparative analysis reusability program transformations automating transformational development software reusing software developments kids semiautomatic program development system evolution programs axiomatic basis computer programming discipline programming applying formal methods automated software development ordersorted algebra equational deduction multiple inheritance overloading exceptions partial operations semantics ordersorted specifications ordersorted logic knowledge representation systems automated acquisition refinement reusable software design components reusing analogous components synthesis procedural data abstractions system software development using vdm science programming fundamentals deductive program synthesis mechanisms analogical reasoning program abstraction instantiation rose2 strategies supporting high level software design reuse domainbased program synthesis using planning derivational analogy exploiting reusable specifications analogy analogical approach software reuse similarity analogical software reuse computational model telos representing knowledge information systems morgan kaufman representation management issues casebased reasoning systems computing similarity reuse library system aibased approach implementing faceted classification software reuse lassie knowledgebased software information system application casebased reasoning cbr software reuse matching conceptual graphs aid requirements reuse information processing mind machine formal approach reusing general components constructing formal specifications program code twophase approach reverse engineering using formal methods strongest postcondition basis reverse engineering graphical environment formally developing objectoriented software formal semantics object models tr ctr guifa teng xiaodong liu support software evolution abstration rules programming knowledge patterns focus computational neurobiology nova science publishers inc commack ny 2004
architecture performance security protocols ensemble group communication system ensemble group communication system built cornell hebrew universities allows processes create process groups within scalable reliable fifoordered multicast pointtopoint communication supported system also supports communication properties causal total multicast ordering flow control like article describes security protocols infrastructure ensemble applications using ensemble extensions described benefit strong security properties assumption trusted processes corrupted communication secured tampering outsiders work extends previous work performed horus system ensembles predecessor adding support multiple partitions efficient rekeying applicationdefined security policies unlike horus used security infrastructure nonstandard key distribution timing services ensembles security mechanism based offthe shelf authentication systems pgp kerberos extend previous results group rekeying novel protocol makes use diamondlike data structures diamond protocol allows removal untrusted members within milliseconds work considering configurations hundreds members assume member trust policies symmetric transitive assumptions dictate design decisions b introduction group communication systems gcss used today industry reliability highavailability required group communication subject ongoing research many gcss built 1 2 3 4 5 6 7 commercial products 8 example gcs applications include groupconferencing distributed simulation server replication internet emerged mainstream use role gcss internet settings security emerged important topic secure gcs must efficiently protected malicious behavior outright attack paper describes security architecture ensemble 6 group communication system achieves desired properties fundamentally gcs introduces process group abstraction process group coherently binds together many processes one entity within context group reliable persource ordered messaging supported processes may dynamically join leave group groups may dynamically partition multiple components due network failurespartitions gcs responsible simplifying complex scenarios overcoming asynchronous nature network keeping group abstraction consistent processes provided membership views specifying list currently alive connected group members notification provided whenever network connectivity changes processes joinleave group virtual synchrony model vs 9 8 specifies relationship message delivery membership notification ensemble developed cornell hebrew universities written dialect ml programming language 10 order facilitate system verification design methodology behind ensemble stresses modularity flexibility 11 thus ensemble divided many layers implementing simple protocol stacking together layers much like one uses lego blocks user may customize system suit needs underlying work two fundamental presumptions first access standard offtheshelf authentication mechanism second application perform authorization secure group messages tampering eavesdropping signed encrypted possible use public key cryptography task find approach unacceptably expensive since group members mutually trusted share symmetric encryption signature key among key used protect group messages making encryption signature operations fast roughly 1000 times faster using key raises two challenges rekeying mechanism problem secure replacement current group key deemed insecure danger leaked adversary challenging since switching new key done without using old possibly compromised key dissemination naturally one could use public keys task yet leads high latency one assumes simple primary partition model single component group may function simple solution available one may designate centralized whose responsibility disseminate revoke refresh group keys group members contact server key hence function supporting multiple partitions difficult since one cannot rely centralized service secure key agreement group problem providing protocol whereby secure agreement reached among group members need select mutual key protocol restrict ensemble stack ie legal layer combinations still possible unobtrusive support multiple partitions protocol compose cleanly ensemble stacks regardless functionality protocol must efficiently handle case two group components merge network partitioning network partitions two components resulting group components use different keys simple approach taken example 12 add members one one effect transferring smaller group larger one however potentially slow since members added one time incurs cost proportional number added members solution much efficient contributions ffl demonstrate security properties decomposed introduced layered protocol architecture ffl support security properties multiple partitions earlier work either address issue group partition supports security semantics primary partition 7 ffl provide support dynamic applicationdefined authorization polices focus benign failures assume authenticated members corrupted byzantine fault tolerant systems built researchers 13 14 suffer limited performance since use costly protocols make extensive use public key cryptog raphy believe failure model sufficient needs practical applications demonstrated performance section system good performance scalability security architecture composable ensemble layers user thus freedom combine layers properties including security virtually synchronous vs group communication inherently limited scalability ex ample transis 2 scales members ensemble vs stack scales 100 members since group resilient scenarios network partitions group component completely autonomous therefore architecture rely centralized servers services form leader required elected dynamically throughout paper use term authentication signature referring public signature keyedmd5 1 signatures remainder paper structured follows section 2 describes model use describe system model attack section 3 describes ensemble specifics subsequent two sections describe architecture components situated message critical path parts tailored run efficiently section 4 describes ensemble routers secure router added section 5 describes encrypt layer next three sections describe subtle part architecture message critical path 1 md5 iv initial vector fed secret key section 6 describes key agreement protocol exchange section 7 sketches proof correctness section 8 describes rekey protocol optimization section 9 describes system performance section 10 lists related work section 11 gives conclusions section 12 contains acknowledgments appendix contains protocol details removed main body protocols clarity exposition model consider universe consists finite group u n processes processes communicate passing messages network channels system asynchronous clock drifts unbounded messages may arbitrarily delayed lost network consider byzantine failures may get partitioned partition occurs u split set disjoint subgroups process p communicate processes p subsets p sometimes called networkcomponents shall consider dynamic partitions networkcomponents dynamically merge split partition model general common crash failure model since crash failures may modeled partitions converse described earlier gcs creates process groups reliable ordered multicast pointtopoint messaging supported processes may dynamically join leave group groups may dynamically partition many components due network failurespartitions network partitions healed group components remerge gcs protocols information groups provided group members form view notifications particular process p view contains list processes currently alive connected p membership change occurs due partition group merge gcs goes short phase reconfiguration delivers new view applications reflecting new set connected members paper focus messages delivered order sent fifo sender property ensemble follows virtual synchrony vs model model describes relative ordering message deliveries view notifications useful simplifying complex failure message loss scenarios may occur distributed environments example system adhering vs ensures atomic failure process q view v fails members event time assume existence authentication service available group members authentication service allows members authenticate well create private authentic messages member p uses authentication service create secure message member q shall say sealed message reverse operation performed q open message called unseal follows p q denote ensemble processes v views member decides trust policy ensemble section p trusts q mark p q ensemble forms group components according symmetric transitive closure relationship marked p q named sttrust sttrust created follows symmetry p transitivity p sttrust distributed relation trust policies stable sufficiently long processes u sttrust becomes equivalence relation point u separated disjoint equivalence classes processes called stdomains partitions may prevent members stdomain merging together example assume vg st domains 1 vg two networkcomponents c 1 vg four components fp qg fsg ftg fr vg figure 1 vg stdomains vg network components c 1 vg four components fsg fp qgftg r q component member may dynamically change trust policy request ensemble reform component accordingly system exclude untrusted members allow trusted members join adversary access untrusted potentially dishonest machines may corrupt eavesdrop packet traveling network goal protect messages sent trusted members u provide protection denial service traffic analysis attacks rather restrict authenticity secrecy message content work existing operating system assume security correctness os vulnerability would cause breach ensemble security throughout paper assume members u belong single ensemble group describing exchange rekey protocols assume machines able authenticate trusted later refine model application trust policy thus trust relationship may dynamic may include multiple stdomains 3 ensemble ensemble gcs supporting process groups described addition reliable fifo ordered multicast pointtopoint communication also supports many protocols communication properties multicast total order multicast flow control protocol switching fly several forms failure detection see 6 details ensemble typically configured userlevel library linked application divided many layers implementing simple protocol applications may customize ensemble library use set layers require set layers desired composed ensemble stack members group must stack communicate ensemble keeps viewstate information information replicated group members includes data current protocol stack use group member names addresses number members group key etc order change information new view installed ensemble view unique leader known view members leader selected automatically ranking group members vs model ensures given view members consistent belief concerning member leader group key needs changed group prompted view change process leader broadcast new viewstate includes new group key members use new group key upcoming view ensemble divides messages two classes intragroup regular messages sent members view usually applicationgenerated messages though messages may generated part ensemble protocols behalf application addition intercomponent messages socalled gossip messages messages generated ensemble communication separate components ensemble group gossip message multicast u anyone hear normally communication possible group components due network partitions gossip messages used merge components together arrive destination network partitions link failures repaired receipt gossip message partitioned triggers merge sequence separate components fused together protocols use gossip messages typically make assumptions may lost reordered received multiple times regular secure ensemble stacks depicted table 1 top bottom layers cap stack sides group membership protocol gmp layer 2 computes current set live connected machines appl intf interfaces application provides reliable send receive capabilities pointtopoint multicast messages situated middle stack allow lower latency user sendreceive operations rfifo layer provides reliable persource fifo messaging exchange layer guarantees secure key agreement group members obtain symmetric key encryption signature rekey layer performs group rekeying upon demand layers manage groupkey part viewstate hence regarded gmp extensions furthermore layers message critical path normally dormant become active either user asks rekey components merge encrypt layer encrypts user messages message critical path situated appl intf layer layers discussed actually sets layers implementation also layer names changed clarity exposition table 1 ensemble stack left default stack includes application interface membership algorithm reliablefifo module secure stack right includes regular layers also exchange rekey encrypt layers regular secure top exchange rekey gmp appl intf encrypt rfifo bottom routers 31 policies user may specify security policy application policy specifies address 3 whether address trusted 4 application maintains policy ensemble enforce allow mutually trusted members component policy allows application specify members trusts exclude untrusted members component members use trust policies symmetric transitive otherwise member p trusting member q component containing members q trusts p member changes security policy request ensemble rekey rekey members longer trusted excluded new key chosen component thus old untrusted members able eavesdrop group conversations 32 cryptographic infrastructure design supports use variety authentication signature encryption mechanisms default system uses pgp authentication md5 15 signature rc4 16 encryption three functionalities carried independently combination supported authentication signature encryption systems used systems kerberos 17 idea 18 des 16 interfaced ensemble various stages 33 random number generation cryptographically secure random numbers vital resource secure system possible generate truly random numbers therefore one uses pseudorandom number gen erators plugged offtheshelf cryptographically strong random number generator 3 ensemble address comprised set identifiers example ip address pgp principal name generally address includes identifier communication medium endpoint using fudptcpmpiatmg 4 shall see later sections 67 authenticity members addresses ensured system 4 authentication router first describe simplest part security architecture authentication router module ensemble routers reside bottom protocol stack seen table 1 ensemble router module responsible getting messages member p set members g routers use transportlevel protocols mpi udp tcp ipmulticast send receive messages ensemble application may use several stacks sharing single router hence routers need decide transport send message one received protocol stack deliver modified normal router create signing router used application requests secure protocol stack signed router adds keyedmd5 signature sent message verifies signature incoming message handing protocol stack ensemble signs outgoing messages using group key regular messages may verified group members since share group key gossip messages problematic since initially different components share group key hence protected using authentication service message arrives signing router belonging group component router attempts verify using group key several cases regular message 1 correctly signed pass stack message sent group member 2 incorrectly signed drop message may come different group component shares key may also message sent attacker know key gossip message 1 correctly signed pass stack message gossip type sent member different component shares group key 2 incorrectly signed mark insecure pass stack message different component b signed bs group key ignore keyed md5 signature since cannot verify possibly inner message sealed authentication service exchange layer attempt unseal successful process ms contents exchange layer examines messages protocol layers use gossip messages ignore insecure gossip messages signing router uses hmac 19 standard compute message signatures cryptographically secure oneway hash function md5 used hash message content md5 keyed current group key adversary able forge messages router sender calculates keyed hash hm sends hm concatenated cleartext message receipt hm recalculated receivers key compared received signature match message verified summarize authentication router attempts authenticate messages regular unauthenticated messages dropped gossip unauthenticated messages still delivered marked insecure 5 encrypt layer ensemble optionally supports user message privacy encrypt layer encryptsdecrypts user messages group key user messages reliably delivered fifo sender order allowing use chained encryption 5 ensemble messages signed encrypted messages contain secret user information encryption would degrade performance currently use group key authentication encryption since md5 keys bytes long use first 5 bytes rc4 key improve performance upon view change create securityrelated data structures henceforth use view remains current using group key signature encryption makes encrypt layer strong weaker cryptographic system default configuration groupkey would thus strong rc4 key prevent emerging weakness architecture shall switch group key frequently needed prevent weaker encryption key cracked 6 exchange layer event network failure process group may become partitioned several disjoint components communication among impossible ensemble automatically elects leader group component later partitioned group may need merge communication restored ensemble treats former situation failures one group members system distinguish communication failures operational processes process crashes system uses gossip messages discover opportunities merge group specifically responsibility heal protocol discover partitioned group components active group component leader leader gossips iamalive message periodically includes name address leader hears remote leader group initiates merge sequence group components cannot communicate unless possess key insecure gossip messages allowed pass router exchange layer uses messages achieve secure agreement mutual group key idea one components securely switches key used component heal layer activate merge sequence components key exchange layer active component leader acting filter gossip messages outboundinbound gossip messages pass layer functions via creation recognition two types gossip message headers process p whose principal name 6 r p whose view key 5 modern encryption ciphers separate message fixed sized blocks one encrypt block separately using chained encryption use early blocks help encrypt current block 6 name user known authentication service contains r p nonce 7 header cheap create ticket contains data sent securely process q header created sealing data q header expensive generate since creation involves authentication service usually long currently 12kbytes following event handlers applied gossip messages process q ffl onto gossip message add ffl upon receiving idr p nonce p insecure p trusted r q ticket p gossip ticket data contains key q nonce p prove message freshness ffl upon receiving ticket p intended q p trusted authenticate check freshness nonce decrypt get key p key p key q ignore key otherwise new key key p prompt component go view change new key group key group key part viewstate view change complete new key installed groups routers group component leader q receives gossip message remote component leader checks whether lower id 9 q securely sends p key key q remote leader authenticates q decrypts key q switches component key key q gossip messages correctly signed key q accepted components merge using membership mechanism process fails within component new leader initiates view change group key switched since assume honesty failed members use knowledge current key malicious manner 61 example execution figures 234 5 show example execution exchange protocol initially two compo nents b executing begin using different keys key key b initially gossip messages marked insecure delivered coordinators communication occurs components authentication sequence involves coordinators following steps refer coordinators name component 1 coordinators b regularly broadcast gossip messages announcing presence system gossip messages contain id headers exchange protocol heal headers heal protocol heal protocol heals group partitions exchange layer examine gossip messages marked insecure 2 coordinator receives idb nonceb gossip message b marked insecure sends ticketkey nonceb gossip message b 7 one time random string used prove message freshness type comparison function may used 9 comparison function used figure 2 leaders b send gossip messages figure 3 leader hears bs gossip message sends key b 3 b receives ticketkey nonceb gossip message authenticates verifies freshness nonce check passed b also gets key b prompts group proceed empty view change 10 installing new view b installs key group components using key 4 b installed key b broadcast gossip messages accepted receiving coordinator marked insecure membership layers examine gossip messages results two components merging single component using key say view change empty group membership changes key switched figure 4 bs component switches keya figure 5 components merge since use key use nonces protocol rely local clocks synchrony order use local time nonce one needs use secure time service currently standard internet service section discuss security exchange protocol layers stack belonging security protocols handle group key done order separate security functionality rest stack hence order verify ensemble secure need examine security protocols confine discussing exchange layer manner exchange achieves secure key agreement protocol two properties safety sttrusted members learn group key progress assuming network remains stable sufficiently long period members eventually agree group key begin short discussion properties sttrust relation 71 sttrust sttrust distributed relation trust policies stable sufficiently long sttrust becomes equivalence relation consistent throughout u separates u disjoint stdomains purpose section assume partitions conditions disjoint components merge form group components according trust relationship components setwise contained stdomains example set members trust stdomain clearly component containing single member include rest hence case component equal stdomain possible component proper subset stdomain assume q j p trust components c leaders p c 1 c 2 merge since p trust 72 safety define safe key one known members single stdomain key may serve group key several views exchange protocol may invoked time several stages may interrupted failure specifically protocol designed failure occurs protocol restarted without risk possible security compromise classify failure two types malicious benign benign failures simple message loss scenarios three cases ffl iamaliver p nonce p message may reach destination ffl ticketr q nonce p may reach destination reach untrusted member ffl view installation phase p may fail must show none occurrences breaches safety ffl iamaliver p nonce p message reach component leaders ps component merge may temporarily prevent components merging together breach safety ffl ticketkey q nonce p may reach destination reach untrusted member ticket gets lost information revealed ticket opened p alone thus capture dishonest member breach safety ffl view installation phase p fails ps component members learn key q ps component sttrusted qs component sttrusted members learn key q malicious case adversary may try send corrupt message ffl iamalive adversary pretend trusted process q send iamaliveq nonce q process p receives sends ticketkey p nonce q q q decrypt adversary cannot make use ticket since cannot unseal ffl ticket adversary may send p ticket trusted process q however adversary cannot forge tickets hence ticket rejected another form attack replay attack resending old iamalive messages create new ticket messages attacker cannot decrypt replayed ticket messages discarded since contain stale nonce viewchange protocol involves another step assume two group components leader key key b leader b key b merging together assuming key key b safe ffl exchange passes key b key remains safe ffl second step b encrypts key key b multicasts b since key b safe trusted members learn key hence key remains safe partition occurs new members learn nothing hence component key remains safe 73 progress show protocol makes progress assume network faults occur sufficiently long period sent messages received timely fashion without loss corruption conditions assume stdomain members mutually trusted split two components b eventually iamalive messages reach b causing b send key components merge hence eventually ss components merge 8 rekey protocol occasionally need switch group key may several reasons lifetime expiration symmetric encryption keys bounded lifetime secure time dedicated adversary able crack currently ensemble uses rc4 20 default encryption mechanism relatively weak encryption scheme 40bit key clearly much stronger algorithms des 16 triple des 16 idea 18 employ longer keys 56bits 112bits 128bits respectively 128bit key would safe years even using top line machines try cracking however using weak encryption key allows us export ensemble system usa maintaining reasonable level security takes 64 mipsyears break rc4 key believe casual eavesdropper willing pay furthermore rc4 faster stronger encryption algorithms promotes efficient communication dynamic trust policy members may dynamically change trust policy thus old members may authorized listen current group conversations requires ability switch group key preventing old members eavesdropping os vulnerability work existing os perfect may penetrated persistent knowledgeable intruder intruder may penetrate old group members discover group key order rely assumption old members erase key need switch key old members leave group rekey protocol provides way securely synchronously switch communication used group unlike exchange protocol use old key disseminate new key new key unrelated old key rely old key dissemination thus possession old group key allow discovery new key eavesdropping current group conversations authenticate members using public keys assume never broken rekey protocol works follows 1 leader chooses new random key unrelated old group key 2 leader seals new key group member separately sends sealed messages pointtopoint members 3 group member upon receipt new key sends acknowledgment leader 4 leader receives acknowledgments group members starts view change new key installed router upcoming view members acknowledge receipt new key may crashed became partitioned network failure new view excluding faulty members takes place old key stays unchanged user notified rekeying failed may ask rekey second invocation likely succeed since faulty members removed 81 authorization polices rekey invoked leader checks current members trusted removes untrusted members view installing new smaller view exchange protocol prevent untrusted members rejoining group rekey requires correct participation untrusted members cannot exclude byzantine member application may dynamically change security policy entails revocation old group key prevent old untrusted members eavesdropping altering current group conversation thus rekey protocol needs invoked application whenever policy change performed 82 optimizing protocol protocol described fairly slow sealunseal operations costly terms cpu time memory example single operation using pgp pentium2 300mhz takes 025 seconds consider latency rekey operation taking account sealunseal operations group 64 members leader performs 63 seal operations member performs another unseal operation prior acknowledging key thus latency 63 protocol aims efficient scalable hence added following optimizations ffl spawn process perform sealunseal operation background removes expensive authentication service calls critical path protocol stack keep running usual similar optimization used horus 21 ffl increase scalability protocol use tree structure disseminate new key leader sends new key children turn pass tree figures 67 member sends acknowledgment ancestor collected acknowledgments children figure 8 leader receives acknowledgments children multicasts rekeydone messages group starts new view figure 9 ffl using tree structure latency rekey operation improved substantially suppose binary tree used cost level tree except first leader performs two seal operations children perform unseal operation amounts 3 operations latency becomes log 2 latency using treestructure analyzed still high improve introduced secure channels secure channel members p q created follows 1 p generates random symmetric key k pq seals q 2 p sends sealed key q 3 q acknowledges receipt k pq henceforth message sent secure channel encrypted signed using k pq secure channel allows sending private information two peers contrast group key allows multicasting private information whole group added secchan layer ensemble handles cache secure channels whenever private information needs passed p q secure channel created one already exist operation create secure channel expensive takes two sealunseal operations cost approximately 05 seconds test platform hand next private message p q encrypted symmetric key k pq much quicker operation lasting couple microseconds using cache typical group rekey operation run much quicker assuming static view v first rekey invocation run several seconds since new channels must set 11 next invocation run much faster since secure channels already set examine 64 member case focus actual rekeying performed without following view installation latency ffl ensemble achieves latency around 12ms members lan average latency reliable multicast ffl sending information downup tree costs 12ms 2 tree 24ms log 2 144ms ffl must add latency reliable multicast 156ms latency less 20ms orders magnitude less latency initial implementation channels refreshed periodically avoid exposure cracking whenever rekey operation invoked discard channels violate authorization policy 11 note need set secure channels pair members group pairs corresponding edges dissemination tree need set figure leader sends new group key k tree e sealed electronic envelopes containing k members p q respectively leader figure 7 upon receipt p q turn pass k subtrees leader 9 performance division work exchangerekey layers encryptrouters computationally efficient normal run time use symmetric key fast uses little memory relatively rare occasion merge requested rekey use authentication service tickets require computation memory one typically uses 1024bit rsa keys waits rpc style calls authentication server one exception measurements taken pentiumpro 200mhz machines running mosix operating system 22 connected 25gbitsec myrinet current os communication stack achieve maximal hardware performance figure depict latency ensemble stack numbers given sendrecv operation message arrives stack handed application sends immediate response latency measured message arrival message departure xaxis measures message size bytes yaxis time seconds see latency constant message sizes regular stack stack process message content basic latency increases authentication privacy stacks since aggressively optimized regular stack also initialize encryption figure 8 acknowledgments climb tree leader ack ack figure 9 leader receives acknowledgments children multicasts rekey done message group leader rekeydone rekeydone rekeydone rekeydone rekeydone authentication contexts allocate add 16bytes signature space message stacks latency also increases function message size since md5 hashing rc4 encryption pass message content theoretic processing times xbyte message disregarding initial costs encryption hashing linear lines asymptotically approach measured latencies table 2 md5 rc4 performance different cpus performance measured number bytes processed microsecond rc4 203 752 1245 figure 10 latency sendrecv operation using regular stack authenticated stack private authenticated stack xaxis show message size bytes yaxis shows latency seconds multiplier 10 gamma4 regular auth encrypt also tested achievable throughput ensemble shown table 3 ran ensemble application two machines one chosen leader sends many 1000byte messages member possible maximal achievable throughput using regular stack 3330kbytesec add authentication throughput drops 2850kbytesec add encryption throughput drops 1600kbytesec bottleneck cpu third column table shows amount cpu time per second used encryption verification table 3 ensemble throughput different stacks authentication encryption added stack performance drops due increasingly heavy cpu load stack kbytesec cpu timesec regular auth 2850 0132 authprivacy 1600 0286 next measured latency rekey operation used 8 pentiumpro 200mhz machines pentiums interconnected using 10mbitsec shared hub proxy pentiumpros created group static size performed 300 rekey operations succession time measured initiation rekey installation new view manner measured time required view change since rekey includes view change added cost rekeying difference two measurements figure 11 depicts times groups size 2 12 process different machine difference two lines grows logarithmically group size increases rekeying using binary tree employ dissemination costs 2 depth point topoint latency multicast latency setting latency 12ms group 12 members 2 3 12ms 84ms figure 11 latency rekey operation xaxis shows number members yaxis shows latency measured seconds view change related work ensemble descended earlier system named horus descended isis system 23 early work group communication security performed horus 24 21 work extends horus security architecture differs many ways added support multiple partitions horus permitted progress primary partition group rekey upon demand application defined security policies plugged offtheshelf authentication systems group communication system designed computer supported collaborative work cscw applications built university london 25 context cscw objects files typically shared applications different applications allowed perform different operations shared objects enforce restrictions trusted member group chosen leader message member wishes multicast forwarded leader leader filters messages discards malicious ones enforces shared objects security policy multicasts legal messages work however still preliminary stage time writing provide leader failure furthermore project oriented towards cscw applications rampart 13 group communication system built att resistant byzantine attacks third members rampart group may behave byzantine manner yet group would still provide reliable multicast facilities system providing similar guarantees built university santabarbara california 14 byzantine security rather costly however difficult develop applications resistant faults chose support fault model ensemble works ip multicast security area includes 26 27 28 papers describe management session keys large groups infrastructure required scalable efficient recent work 29 12 30 dealt efficient rekeying large multicast groups ip multicast concerned mainly onetomany multicast single application multicasts many clients whose membership dynamic necessarily known ensemble concerned mainly manytomany multicasts member may multicast group membership known secure ip multicast trusted centralized servers may used disseminate group keys ensemble possesses completely distributed architecture single point failure required conclusions developed security architecture ensemble supports multiple partitions primary partition group rekeying upon demand applicationspecific security policies offtheshelf authentication software freely available part ensemble project believe first freely available secure group communication system highest performance secure system available time writing acknowledgments would like thank tal anker improvements optimized rekey protocol yaron minsky helping develop exchange protocol insightful comments idit keidar helpful reviews r view synchronous communication large scale networks transis communication subsystem high availability fast message ordering membership using logical tokenpassing ring partitionalbe group membership specification algorithms high perfomance totally ordered multicast protocol building adaptive systems using ensemble horus flexible group communication system reliable distributed computing isis toolkit exploiting virtual synchrony distributed systems objective caml system release 107 ensemble system secure group communication using key graphs secure agreement protocols reliable atomic group multicast rampart securering protocols securing group communication md5 message digest algorithm data encryption standard kerberos authentication service computer networks markov ciphers differential cryptanalysis hmac keyedhashing message authentica tion stream cipher encryption algorithm security arcihtecture faulttolerant systems mosix multicomputer operating system high performance cluster computing isis system manual integrating security group oriented distributed system secure group communication groupware applications scalable multicast key distribution group key management protocol architecture group key management protocol specification iolus framework scalable secure multicasting multicast security taxonomy efficient constructions tr fault tolerance networks bounded degree entity authentication key distribution secure agreement protocols totem horus iolus faulttolerant meshes small degree secure group communications using key graphs bimodal multicast review experiences reliable multicast simple faulttolerant key agreement dynamic collaborative groups reliable distributed computing isis toolkit information theoretic analysis rootedtree based secure multicast key distribution schemes authorization attribute certificates widely distributed access control high performance totally ordered multicast protocol isaac design architecture microsoft cluster service practical approach highavailability scalability securering protocols securing group communication fast replicated state machines partitionable networks cliques secure group communication asynchronous networks failures state machine approach tutorial building adaptive systems using ensemble study group rekeying scalable framework secure multicast partitionable group membership specification algorithms ensemble system ctr eunjin jung alex x liu mohamed g gouda key bundles parcels secure communication many groups computer networks international journal computer telecommunications networking v50 august 2006 yair amir cristina nitarotaru jonathan stanton gene tsudik secure spread integrated architecture secure group communication ieee transactions dependable secure computing v2 n3 p248261 july 2005 randal burns fastpath optimizations cluster recovery shareddisk systems proceedings 2004 acmieee conference supercomputing p5 november 0612 2004 yair amir yongdae kim cristina nitarotaru john l schultz jonathan stanton gene tsudik secure group communication using robust contributory key agreement ieee transactions parallel distributed systems v15 n5 p468480 may 2004 miguel correia nuno ferreira neves lau cheuk lung paulo verssimo wormit wormholebased intrusiontolerant group communication system journal systems software v80 n2 p178197 february 2007 yair amir yongdae kim cristina nitarotaru gene tsudik performance group key agreement protocols acm transactions information system security tissec v7 n3 p457488 august 2004 emmanuel bresson olivier chevassut david pointcheval provably secure authenticated group diffiehellman key exchange acm transactions information system security tissec v10 n3 p10es july 2007
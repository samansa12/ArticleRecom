objectoriented framework block preconditioning general software preconditioning iterative solution linear systems greatly lagging behind literature partly specific problems specific matrix preconditioner data structures order solved efficiently ie multiple implementations preconditioner specialized data structures required article presents framework support preconditioning various possibly userdefined data structures matrices partitioned blocks main idea define data structures blocks upper layer software uses blocks transparently data structure transparency accomplished using objectoriented language thus various preconditioners block relaxations blockincomplete factorizations need defined work block type addition possible transparently interchange various approximate exact techniques inverting pivot blocks solving systems whose coefficient matrices diagonal blocks leads rich variety preconditioners selected operations blocks performed optimized libraries fundamental data types comparisons optimized fortran 77 code workstations cray supercomputers show framework approach efficiency fortran 77 long suitable block sized block types chosen b introduction iterative solution linear system preconditioner often used transform system one better convergence properties example leftpreconditioned case gamma1 referred preconditioning operator matrix general sequence operations somehow approximates effect gamma1 vector unfortunately general software preconditioning seriously lagging behind methods published literature part reason many methods general applicability robust general problems specialized need specific information eg general direction flow fluids simulation cannot provided general setting another reason one deal article specific linear systems need specific matrix preconditioner data structures order solved efficiently ie need multiple implementations preconditioner specialized data structures example finite element applications diagonal blocks particular fixed sparse structure block ssor preconditioner needs invert diagonal blocks use algorithm suited structure block ssor code treats diagonal blocks general way ideal problem encounter linear systems different applications need determine suitable preconditioning strategies iterative solution rather code preconditioners individually take advantage structure appli cation better framework software reuse also wide range preconditionings available choose method matches difficulty problem computer resources available article presents framework support preconditioning various possibly userdefined data structures matrices partitioned blocks main idea define data structures called block types blocks upper layer software uses blocks transparently data struc ture thus various preconditioners block relaxations block incomplete need defined work block type preconditioners called global preconditioners reasons soon become apparent code preconditioners almost readable code pointwise counterparts new global preconditioners added fashion global preconditioners need methods called local preconditioners approximately exactly invert pivot blocks solve systems whose coefficient matrices diagonal blocks example block stored sparse format might objectoriented block preconditioning delta 3 verted exactly approximate inverse might computed design permits variety inversion solution techniques defined block type transparency block types local preconditioners implemented polymorphism objectoriented language framework called currently implements block incomplete factorization block relaxation global preconditioners dense sparse block type variety local preconditioners block types users bpkit either use block types available add block types local preconditioners appropriate applications users may also define new global preconditioners take advantage existing block types local preconditioners thus bpkit intended complete library software rather framework software specialized relatively generic components appropriate make comments use block preconditioning many linear systems engineering applications arise discretization coupled partial differential equations blocking systems may imposed ordering together equations unknowns single grid point subdomain first case blocks usually dense latter case usually sparse experimental tests suggest advantageous preconditionings exploit block structure matrix chow saad 1997 fan et al 1996 jones plassmann 1995 kolotilina et al 1991 relative robustness block preconditioning comes partly able solve accurately strong coupling within blocks computational point view block matrix techniques efficient cached hierarchical memory architectures better data locality dense block case block matrix data structures also require less storage block data structures also amenable graphbased reorderings block scalings approximations also used diagonal pivot blocks ie approximations local preconditioners used techniques specifically called twolevel preconditioners kolotilina yeremin 1986 offer middleground accuracy simpler computations beginning underwood 1976 axelsson et al 1984 concus et al 1985 decade ago preconditioners motivated analyzed case block tridiagonal incomplete factorizations combined several types approximate inverses recently reached certain maturity implementations methods however flexible often coded particular block size inversion technique almost always coded dense blocks software framework presented derives flexibility use objectoriented language chose use c stroustrup 1991 real 64bit arithmetic objectoriented languages also appropriate framework computationally efficient since operations involving blocks performed code employs fundamental types optimized fortran 77 libraries level 3 blas dongarra et al 1990 lapack demmel 1989 sparse blas toolkit carney et al 1994 token users implementing block types local preconditioners may practically language long language linked c compilers bpkit also interface fortran 77 users chow heroux bpkit available httpwwwcsumneduchowbpkithtml c efforts numerical solution linear equations include lapack dongarra et al 1993 dense systems diffpack bruaset langtangen 1997 isis clay 1997 sparselib iml dongarra et al 1994 sparse systems also possible use objectoriented style languages eijkhout 1996 machiels deville 1997 smith et al 1995 section 2 discuss various issues arise designing interfaces block preconditioning preconditioned iterative methods general describe specification block matrix global local preconditioners interface iterative methods fortran 77 interface section 3 describe internal design bpkit including polymorphic operations blocks needed global preconditioners section 4 present results numerical tests including comparison optimized fortran 77 code section 5 contains concluding remarks 2 interfaces block preconditioning attempted general defining interfaces allow extensions functionality attempted accept precedents overlap related software particularly interface iterative methods concreteness describe several methods used numerical tests section 2 brings light various issues software design preconditioned iterative methods 21 block matrices matrix partitioned blocks called block matrix although bpkit storage scheme may used store blocks zero locations blocks within block matrix must still defined block matrix class data type available bpkit called blockmat contains pointer block block matrix pointers row blocks block row stored contiguously additional pointers first pointer block row analogy compressed sparse row data structure saad 1990 pointwise matrices pointers point blocks instead scalar entries global preconditioners bpkit assume blockmat class used possible users design new block matrix classes code new global preconditioners problems still use block types local preconditioners bpkit block matrix data structure described bpkit provides conversion routines data structure harwellboeing format duff et al 1989 one conversion routine block type eg one routine convert harwellboeing matrix block matrix whose blocks dense however routines provided illustration purposes practice users matrix already block form ie nonzero entries block stored contiguously usually easily converted user directly blockmat form general conversion routines allow two levels blocking many prob lems particularly linear systems arising discretization coupled partial differential equations blockings may imposed ordering together equa objectoriented block preconditioning delta 5 tions unknowns single grid point subdomain latter blocking produces coarsegrain blocks smaller nested blocks called finegrain blocks figure 1 shows block matrix dimension 24 coarse blocks dimension 6 fine blocks dimension 2 fig 1 block matrix coarse fine blocks blocks bpkit coarse blocks information fine blocks also provided conversion routines may desirable store blocks coarse blocks block structure ex ample variable block row vbr saad 1990 storage scheme store coarse blocks dense fine blocks reduced space optimized matrixvector product triangular solve kernels vbr block data structures provided sparse blas toolkit carney et al 1994 remington pozo 1996 local preconditioners block operations however defined fine blocks ie two levels local preconditioners apparent use small coarse blocks degrade computing performance due overhead procedure calls larger blocks give better computational efficiency convergence rate preconditioned iterative methods computations large dense blocks vectorized article rarely need mention fine blocks thus refer blocks distinction normally mean coarse blocks concrete give example conversion routine called block matrix defined statement blockmat bhbfile 6 dense 6 delta e chow heroux defines b square block matrix blocks dimension 6 blocks stored format indicated dense c enumerated type block type implemented csr stores blocks compressed sparse row format matrix read file hbfile must encoded standard harwellboeing format duff et al 1989 dimension matrix need specified declaration since stored within file specify variable block partitioning blocks different sizes interfaces available use vectors define coarse fine partitionings 22 specifying preconditioning preconditioning block matrix specified choosing 1 global preconditioner 2 local preconditioner diagonal pivot block exactly approximately invert block solve corresponding set equations example fully define conventional block jacobi preconditioning one must specify global preconditioner block jacobi local preconditioner lu factorization addition block size matrix role determining effect preconditioning one extreme block size one preconditioning entirely determined global preconditioner extreme one block preconditioning entirely determined local preconditioner block size parameterizes effect cost selected local global preconditioners best method likely somewhere two extremes example suppose symmetric successive overrelaxation ssor used global preconditioner complete lu factorization used local precondi tioner linear systems difficult solve ssor may used small block size challenging systems larger block sizes may used giving better approximation original matrix extreme matrix may treated single block method equivalent lu factorization global preconditioner specified simple form declaration case block ssor declaration two functions used specify local preconditioner provide parameters global preconditioner factorization blocks msetupb 05 3 bssoromega05 iterations3 b block matrix defined section 21 setup function provides real data preconditioner performs computations necessary setting global preconditioner example computation lu factors case therefore localprecon must called setup setup function must called local preconditioner changed interfaces local preconditioner specified diagonal blocks objectoriented block preconditioning delta 7 general however local preconditioners required applications different variables eg velocity pressure variables fluids simulation may blocked together may make sense write specialized global preconditioner interface allows different local preconditioners specified block 221 global preconditioners global preconditioners implemented bpkit listed table 1 along arguments setup function default argument values general reference works describing global preconditioners many local preconditioners described later axelsson 1994 barrett et al 1994 saad 1995 see also bpkit reference manual chow heroux 1996 briefly specify preconditioners make comments may applied table 1 global preconditioners setup arguments none level btif none bjacobi bsor bssor block versions diagonal successive overrelax ation symmetric successive overrelaxation preconditioners biluk block version levelbased incomplete lu ilu factorization btif incomplete factorization block tridiagonal matrices preconditioner matrix often expressed another matrix somehow approximation however need explicitly formed instead operation gamma1 vector required operation called preconditioning operation application preconditioner iterative methods based biorthogonalization transposed preconditioning operator gammat also needed also possible apply preconditioner split fashion preconditioner factored form example factored lu preconditioned matrix l operations l gamma1 u gamma1 vector required many preconditioners expressed factored form consider splitting block matrix da block diagonal gammal strictly lower block triangular part gammau strictly upper part block ssor preconditioner case one iteration defined chow heroux scale factor 12gamma important iterative method scale invariant used preconditioner relaxation parameter usually chosen 1 since selecting value difficult however one iteration used matrix far symmetric positive definite underrelaxation may necessary prevent divergence also simpler block sor preconditioner one iteration may preferable block ssor nonsymmetric k iterations block used preconditioner form although implemented way instead preconditioner applied vector v performing k sor iterations system starting zero vector level0 block ilu preconditioner certain structured matrices including block 5point matrices written similar form called generalized block ssor form block diagonal matrix resulting incomplete factorization general however levelbased block ilu preconditioner computed performing gaussian elimination neglecting elements factors fall predetermined sparsity pattern levelbased ilu preconditioners much accurate relaxation preconditioners general sparse matrices storage costs least original matrix incomplete factorization block tridiagonal matrices popular certain structured matrices blocks banded structure special case generalized block ssor form thus sequence diagonal blocks needs computed stored block partitioning may along lines 2d grid along planes 3d grid general striped partitioning yield block tridiagonal matrix inversefree form block tridiagonal factorization block diagonal matrix whose blocks defined recurrence starting inversefree form requires matrixvector multiplications preconditioning operation however blocks typically large approximate inverse used place exact inverse equation make factorization incomplete many techniques computing approximate inverses available chow saad 1998 222 local preconditioners local preconditioners either explicit implicit depending whether approximate inverses blocks explicitly formed example implicit local preconditioner lu factorization objectoriented block preconditioning delta 9 global preconditioners involve incomplete factorization require inverses pivot blocks large block sizes use approximate exact dense inverses usually requires large amounts storage computation thus sparse approximate inverses used cases implicit local preconditioners produce inverses usually dense therefore usually computationally useful block incomplete factorizations use implicit local preconditioners disallowed within bpkit also apply rule small block sizes since dense exact inverses usually efficient cases note explicit local preconditioner lp inverse csr block type meant used testing purposes also exact factorization sought usually efficient use lu factorization whole matrix global preconditioners involve block relaxation may use either explicit implicit local preconditioners usually implicit ones used explicit local preconditioners appropriate block relaxation blocks small local preconditioners also differentiated type blocks operate local preconditioners exist block types incomplete factorization example meaningful sparse types thus local preconditioner must chosen matches type block bpkit requires user aware restrictions two paragraphs selecting local preconditioner due dynamic binding c virtual functions violations restrictions detected runtime table 2 lists local preconditioners implemented along localprecon arguments block types whether local preconditioner explicit implicit contrast setup function localprecon takes default arguments included explicit exact inverse local preconditioner csr format comparison purposes would inefficient use block tridiagonal incomplete factorizations example table 2 local preconditioners localprecon arguments block type explimpl lp lu none dense implicit lp inverse none dense explicit lp svd alpha1 alpha2 dense explicit lp lu none csr implicit lp inverse none csr explicit lp ilut lfil threshold csr implicit lp apinv trunc semibw csr explicit lp apinv banded semibw csr explicit lp apinv0 none csr explicit lp apinvs lfil csr explicit lp diag none csr explicit lp tridiag none csr implicit iterations csr implicit iterations csr implicit lp gmres restart tolerance csr implicit lp lu lu factorization pivoting lp inverse exact inverse com chow heroux puted via lu factorization pivoting lp riluk levelbased relaxed incomplete lu factorization lp ilut thresholdbased ilu control number fillins saad 1994 may better indefinite blocks local preconditions prefixed lp apinv new approximate inverse techniques see chow saad 1998 chow heroux 1996 details lp diag diagonal approximation inverse using diagonal original block lp tridiag tridiagonal implicit approximation ignoring elements outside tridiagonal band original block lp svd uses singular value decomposition produce dense approximate inverse sigma sigma singular values thresholded ff 1 constant ff 2 plus factor ff 1 largest singular value oe 1 may produce stable incomplete factorization many blocks inverted close singular yeremin 1995 lp sor lp ssor lp gmres iterative methods used local preconditioners 23 interface iterative methods objectoriented preconditioned iterative method requires matrix preconditioner objects define small number operations bpkit operations defined polymorphically listed table 3 left right preconditionings functions apply applyt may used apply preconditioning operator gamma1 transpose vector split also called twosided symmetric preconditionings use applyl applyr apply left right parts split preconditioner respectively incomplete factorization lu applyl l gamma1 operation applyr anticipate possible functionality applyc function defines combined matrixpreconditioner operator used example implement eisenstat trick eisenstat 1981 eisenstat trick used flexible preconditionings described end section right preconditioner apply also needs used two functions listed matrix member functions return row column dimensions matrix useful iterative method code help preallocate workspace needed operations table 3 may defined matrix preconditioner objects many iterative methods require operations gmres iterative method example require transposed operations relaxation preconditioners usually define split operations case violate objectoriented programming paradigm give parent classes specializations children eg specific preconditioner may define applyl although generic preconditioner seen section 32 argument lists functions table 3 use fundamental data types iterative methods codes forced adopt particular data structure vectors interfaces use blocks vectors support iterative methods use multiple righthand sides implementation operations use level 3 blas whenever possible interfaces following form void multint nr int nc const double u int ldu double v int ldv const objectoriented block preconditioning delta 11 table 3 operations required iterative methods matrix operations mult matrixvector product trans mult transposed matrixvector product preconditioner operations apply apply preconditioner applyt apply transposed preconditioner applyl apply left part split preconditioner applyr apply right part split preconditioner applyc apply combined matrixpreconditioner operator applyct transposed nr nc row column dimensions input blocks vectors u v arrays containing values input output vectors respec tively ldu ldv leading dimensions respective arrays preconditioner operations defined const functions case preconditioner objects need change state iterations progress spectral information revealed example nonconstant operator used preconditioning flexible iterative method fgmres saad 1993 must used bpkit arises whenever gmres used local preconditioner users may wish write advanced preconditioners work iterative methods change example lack convergence simple way enhancing robustness iterative methods case iterative method written class function whose class also provides information convergence history possibly approximate spectral information wu li 1995 24 fortran 77 interface many scientific computing users unfamiliar c usually possible however provide interface callable language bpkit provides objectoriented type fortran 77 interface objects created pointers passed functions fortran 77 integers consider following code excerpt parameters important call blockmatrixbmat n ja ia numblockrows partit btype call preconditionerprecon bmat bjacobi 0d0 0d0 lplu 0d0 0d0 call flexgmresbmat sol rhs precon 20 600 1d8 call blockmatrix creates block matrix compressed sparse row data structure given number arguments wrapper function actually written c arguments available fortran 77 pro gram integer bmat actually pointer block matrix object c fortran 77 program meant interpret variable pass chow heroux functions preconditioner defines block preconditioner number arguments flexgmres solves linear system using flexible gmres similarly precon pointer preconditioner object constant parameters bjacobi lp lu used specify block jacobi preconditioner using lu factorization solve diagonal blocks matrixvector product preconditioner operations table 3 also wrapper functions makes possible use bpkit iterative solver written fortran 77 also another motivation use fundamental types specify vectors interface operations mult see section 23 calling fortran 77 c also possible done bpkit calls underlying libraries blas bpkit illustrates able mix use different languages 3 local matrix objects block matrix may contain blocks one type best choice types blocks depends mostly structure matrix may also depend proposed algorithms computer architecture example matrix reordered diagonal blocks diagonal diagonal storage scheme diagonal blocks best inversion blocks would automatically use appropriate algorithm diagonal block type local preconditioners would added user handle different block types way instances type implemented c polymorphic objects ie set related objects whose functions called without knowing exact type object block types derived local matrix class called localmat class defines common interface block types global preconditioners refer localmat objects localmat functions called appropriate code executed depending actual type localmat object eg dense csr addition block type variety local preconditioners explicitness implicitness local preconditioners need transparent since example either used block ssor thus types preconditioners derived base class particular local preconditioners given block type derived base class block type eg lp svd local preconditioner dense type derived dense block type gives user flexibility treat explicit local preconditioners regular blocks implicit local preconditioners derived separately logically related explicit local preconditioners block operations apply explicit preconditioners also apply local preconditioners however many operations inefficient local preconditioners use disallowed prevent improper usage implicit preconditioners cannot derived separately explicit preconditioners similarity point view global preconditioners localmat hierarchy illustrated figure 2 showing derivation block types subsequent derivation local preconditioners localmat classes form kernel bpkit allow global preconditioners implemented without knowledge type blocks local preconditioners used users may also add kernel deriving specific classes objectoriented block preconditioning delta 13 csr fig 2 localmat hierarchy challenge designing localmat class determine operations required implement block preconditioners give operations semantics allow efficient implementation possible block types operations implemented c virtual functions following subsections describe operations 31 allocating storage important difference dense sparse blocks storage requirement sparse blocks always known beforehand thus order treat dense sparse blocks way storage allocated block required optimization known dense blocks used eg conversion sparse matrix block matrix dense blocks storage may allocated beforehand user functions provided set data pointers block objects thus possible allocate contiguous storage array dense blocks 32 local matrix functions table 4 functions localmat objects amat amat mat addb c alpha amat mat multb c alpha beta amat amat trans vec multb c alpha beta amat vec solveb c amat trans vec solveb c 14 delta e chow heroux table 4 lists functions determined required implementing block preconditioners listed table 1 functions invoked block object represented b c blocks type b c components block vector object ff fi scalars default value ff 1 fi 0 createempty creates empty block 0 0 dimensions class function useful constructing blocks preconditioner without knowing types blocks used settozerodim1 dim2 sets zero resetting dimensions necessary operation combined createempty always necessary zero block creating zeroing block could relatively expensive block types copies argument block invoking block original data held invoking block released new block different size allocated space resized createinvlprecon provides common interface creating local preconditioners lprecon type describes local preconditioner arguments table 2 exact approximate inverse explicit implicit generated createempty createinv functions create new objects real data space functions return pointers new objects emphasize point overloading arithmetic operators blocks local preconditioners sacrificed since chained operations would inefficient implemented sequence elementary operations addition operators difficult implement without extra memory copying first store result temporary result copied operator functions found useful block preconditioners example used btif used biluk functions useful example matrixvector product triangular solve operations note particular mat trans mat mult useful function defined note local preconditioner objects also inherit functions although need objects implicit local preconditioners matrix formed operations addition mat mat add make sense blocks local preconditioner created solving system block mat vec solve allowed give parent classes specializations derived classes table 5 indicates functions allowed error condition raised runtime functions used incorrectly given operations onestep block sor code could implemented shown ap pointer block matrix object stores block structure csr format ia array stores block row pointers ja array stores block column indices pointers diagonal elements idiag inverses diagonal elements diag computed call setup v block vector object allows blocks vector accessed individual entries rest code selfexplanatory 1 i0 iapnumrow objectoriented block preconditioning delta 15 table 5 types objects may used function explicit implicit coarse local local function blocks precon precon createempty matcopy mat trans mat mat add mat mat mult mat vec mult mat trans vec mult mat vec solve mat trans vec solve 2 3 jiai jidiagi j 4 5 6 7 apvaljmatvecmultvjaj vi omega 10 8 9 10 diagimatvecsolvevi vi 11 block matrix mixes different block types must used carefully first restrictions different block types section 222 must violated second unless define arithmetic operations blocks different types incomplete factorization preconditioners cannot used main design alternative create block matrix class block type classes would polymorphic define set common operations preconditioners may use manipulate blocks significant advantage design impossible use local preconditioners wrong type eg use incomplete factorization dense block disadvantage different block types eg specialized types created particular application cannot used within block matrix another alternative implement metamatrices ie blocks nested cursively would complicated however users specify types matrices levels local preconditioners could used addition little need complexity actual applications twolevel design coarse fine blocks described section 21 sufficient 4 numerical tests numerical tests carried matrices listed table 6 sherman1 reservoir simulation matrix grid one unknown per grid point simple symmetric problem solve using partitioning chow heroux planes wigto966 euler equation model supplied larry wigton boeing fidap019 models axisymmetric 2d developing pipe flow fullycoupled navierstokes equations using twoequation kffl model turbulence bartht1a bartht2a matrices supplied tim barth nasa ames 2d high reynolds number aerofoil problem 1equation turbulence model bartht2a model solved preconditioner based less accurate sparser bartht1a model table 6 test matrices listed dimensions numbers nonzeros matrix n nonz tables 7 9 show results sherman1 block relaxation incomplete factorization global preconditioners using various local preconditioners arguments given global local preconditioners tables correspond displayed tables 1 2 respectively block size 100 used since matrix block tridiagonal biluk btif equivalent tables show number steps gmres fgmres appropriate required reduce residual norm factor 10 gamma8 dagger used indicate achieved 600 steps right preconditioning 20 krylov basis vectors zero initial guess used righthand side provided matrix since local preconditioners different costs tables 8 9 show cpu timings system user times bssor13 btif tests run one processor sun sparcstation 10 particular problem choice partitioning ilu local preconditioners required least total cpu time bssor13 btif exact solve efficient ie preconditioner exact solve table 7 number gmres steps solving sherman1 problem block relaxation global preconditioners various local preconditioners lp riluk00 93 71 53 402 48 objectoriented block preconditioning delta 17 table 8 number gmres steps timings solving sherman1 problem various local preconditioners precon solve total lp ilut20 44 003 173 176 table 9 number gmres steps timings solving sherman1 problem block incomplete factorization various local preconditioners precon solve total tables show number gmres steps bartht2a matrix random righthand side used initial guess zero gmres tolerance 10 gamma8 50 krylov basis vectors used table 10 block incomplete factorization used global preconditioner lu factorization used local preconditioner table 11 block ssor one iteration used global preconditioner level3 ilu used local preconditioner table 10 number gmres steps solving bartht2a problem biluklp lu block biluk level tables 12 13 show results wigto996 using block incomplete factor ization righthand side vector ones gmres tolerance parameters previous experiment failures table 12 due inaccuracy low fill levels instability high levels table 13 lp svd010 used local preconditioner gave chow heroux table 11 number gmres steps solving bartht2a problem block gmres size steps best results lp svd010 indicates singular values pivot blocks thresholded 01 times largest singular value table 12 number gmres steps solving wigto966 problem biluklp inverse block biluk level table 13 number gmres steps solving wigto966 problem block biluk level show results block tridiagonal incomplete factorization preconditioners using general sparse approximate inverses matrix fidap019 partitioned block tridiagonal system using constant block size 161 last block size 91 since matrix arises finite element problem careful selection partitioning could yielded better results rows system scaled 2norms columns scaled similarly since matrix contains different equations variables krylov subspace size 50 gmres used righthand side constructed solution vector ones compare result pair globallocal preconditioners biluk0lp svd050 using block size 5 lp svd050 gave best result several trials table 14 shows number gmres steps convergence timings setting preconditioner iterations number nonzeros preconditioner experiments carried one processor sun sparcstation 10 timings show combinations btif global preconditioner apinvs local preconditioner comparable biluk0lp svd050 use much less memory since approximate inverses pivot blocks need stored although actual number nonzeros matrix 259 879 39 355 block nonzeros required biluk therefore almost million objectoriented block preconditioning delta 19 table 14 test results fidap019 problem gmres cpu time steps precon solve total precon entries needed stored apinvs method produced approximate inverses sparser original pivot blocks see chow saad 1998 details often heated debate use c scientific computing ideally c fortran 77 programs coded similarly perform similarly however using objectoriented features c make program flexible maintainable researchers usually encounter 10 percent performance penalty jiang forsyth 1995 optimized kernels blas called c performance penalty small large problems larger fraction time spent kernels since c fortran 77 programs usually coded differently practical comparison made general code bpkit compared specialized fortran 77 code compare bpkit optimized block ssor preconditioner gmres accelerator code performs block relaxations form ii r block row ii ith diagonal block ith block column x ith block current solution r current residual vector notice update residual vector fast stored sparse columns blocks since bpkit stores matrix blocks flexibility interesting see performance penalty would case tables 15 16 show timings block ssor sun sparcstation 10 cray c90 supercomputer wigto966 matrix case righthand side constructed solution vector ones parameters programs optimized highest optimization level clock used measure cpu time user system c programs etime timef used measure times fortran 77 programs sun cray computers respectively one step block ssor used tests local preconditioner exact lu factorization results shown large range block sizes case bpkit dense csr storage schemes blocks last column table gives average time perform one iteration gmres results show specialized fortran 77 code better performance wide range block sizes expected update residual major computation affected blocking chow heroux dense blocks used bpkit competitive cray using large block sizes 128 blocks size contain many zero entries treated general nonzero entries dense storage scheme used however vectorization cray makes operations large dense blocks much efficient sparse blocks used bpkit competitive workstation moderate block sizes 8 16 operations smaller sparse blocks inefficient larger blocks imply larger lu factorizations local preconditioner comparison using block ssor dramatic since two different data structures used comparisons levelbased block ilu c fortran 77 show small differences performance since data structures used similar jiang forsyth 1995 conclusion types sizes blocks must chosen carefully bpkit attain high performance particular machine types sizes blocks also chosen conjunction requirements preconditioning algorithm block structure matrix based experiments table 17 gives idea approximate block sizes used bpkit given constraints 5 concluding remarks article described objectoriented framework block preconditioning polymorphism used handle different block types different local precon ditioners block types local preconditioners form kernel block preconditioners built block preconditioners written syntax comparable nonblock preconditioners work matrices containing block type bpkit easily extensible objectoriented code would al low distinguished explicit implicit local preconditioners deduced operations semantics useful polymorphically manipulating blocks timings specialized optimized fortran 77 code workstations cray supercomputers show framework approach efficiency code long suitable block sizes block types chosen believe found suitable compromise fortran 77like performance c flexibility significant contribution bpkit collection highquality preconditioners common concise interface block preconditioners efficient robust nonblock counterparts block size parameterizes local global method valuable compromising accuracy cost combining effect two methods combination local global preconditioners leads variety useful methods may applicable different circumstances acknowledgments wish thank yousef saad kesheng wu andrew chapman codes helpful discussions also wish thank larry wigton tim barth providing test matrices tim peck helping us editing article benefited substantially comments suggestions one anonymous referees grateful time patience objectoriented block preconditioning delta 21 table 15 timings specialized fortran 77 program block gmres time size steps precon solve total average bpkit dense blocks block gmres time size steps precon solve total average 128 212 366 55905 56271 26543 bpkit sparse blocks block gmres time size steps precon solve total average 128 212 442 16258 167 22 delta e chow heroux table 16 wigto966 bssor051lp lu cray c90 timings specialized fortran 77 program block gmres time size steps precon solve total average bpkit dense blocks block gmres time size steps precon solve total average bpkit sparse blocks block gmres time size steps precon solve total average 128 212 539 13292 13831 06524 table 17 recommended block sizes block type sun cray csr objectoriented block preconditioning delta 23 r iterative solution methods versions incomplete blockmatrix factorization iterative methods templates solution linear systems building blocks iterative methods revised proposal sparse blas toolkit bpkit block preconditioning toolkit approximate inverse techniques blockpartitioned trices approximate inverse preconditioners via sparsesparse iter ations block preconditioning conjugate gradient method lapack portable linear algebra library supercomputers ieee control systems society workshop computeraided control system design december year1989year set level 3 basic linear algebra subprograms sparse matrix library c object oriented design high performance linear algebra distributed memory architectures sparse matrix test problems parpre parallel preconditioners package efficient implementation class preconditioned conjugate gradient methods performance issues iterative solvers device simulation robust linear nonlinear strategies solution transonic euler equations users manual scalable library software parallel solution sparse linear systems block ssor precon ditionings highorder 3d fe systems family twolevel preconditionings incomplete block factorization type fortran 90 entry objectoriented programming solution partial differential equations sparskit basic tool kit sparse matrix computations flexible innerouter preconditioned gmres algorithm ilut dual threshold incomplete ilu factorization iterative methods sparse linear systems petsc 20 users manual approximate factorization procedure based block cholesky decomposition use conjugate gradient method bkat objectoriented block krylov accelerator toolkit presentation cray research private communication tr sparse matrix test problems set level 3 basic linear algebra subprograms c programming language 2nd ed flexible innerouter preconditioned gmres algorithm iterative solution methods performance issues iterative solvers device simulation fortran 90 objectoriented design preconditioned iterative methods diffpack approximate inverse techniques blockpartitioned matrices approximate inverse preconditioners via sparsesparse iterations iterative methods sparse linear systems ctr michael gertz stephen j wright objectoriented software quadratic programming acm transactions mathematical software toms v29 n1 p5881 march iain duff michael heroux roldan pozo overview sparse basic linear algebra subprograms new standard blas technical forum acm transactions mathematical software toms v28 n2 p239267 june 2002 marzio sala objectoriented framework development scalable parallel multilevel preconditioners acm transactions mathematical software toms v32 n3 p396416 september 2006 glen hansen andrew zardecki doran greening randy bos finite element method unstructured grid smoothing journal computational physics v194 n2 p611631 march 2004 mikel lujn l freeman john r gurd oolala object oriented analysis design numerical linear algebra acm sigplan notices v35 n10 p229252 oct 2000 glen hansen andrew zardecki doran greening randy bos finite element method threedimensional unstructured grid smoothing journal computational physics v202 n1 p281297 january 2005 michele benzi preconditioning techniques large linear systems survey journal computational physics v182 n2 p418477 november 2002
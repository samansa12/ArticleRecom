improvement mcmillans unfolding algorithm mcmillan recently proposed new technique avoid state explosion problem verification systems modelled finitestate petri nets technique requires construct finite initial part unfolding net mcmillans algorithm task may yield initial parts larger necessary exponentially larger worst case present refinement algorithm overcomes problem b introduction seminal paper 10 mcmillan proposed new technique avoid state explosion problem verification systems modelled finitestate petri nets technique based concept net un folding well known partial order semantics petri nets introduced 12 later described detail 4 name branching processes unfolding net another net usually infinite simpler structure mcmillan proposes algorithm construction finite initial part unfolding contains full information reachable states call initial part satisfying property fact slightly stronger one finite complete prefix shows use prefixes deadlock detection unfolding technique later applied verification prob lems 7 8 11 used check relevant properties speed independent circuits 5 unfoldingbased model checking algorithm simple branching time logic proposed although mcmillans algorithm simple elegant sometimes gen institut fr informatik technische universitt munchen email fesparzaroemerginformatiktumuenchende partially supported teilprojekt a3 sam sonderforschungsbereich 342 werkzeuge und methoden fr die nutzung paralleler rechnerarchitekturen institut fr mathematik universitt augsburg email waltervoglerinformatikuniaugsburgde j esparza romer w vogler erates prefixes much larger necessary cases minimal complete prefix size petri net algorithm generates prefix size o2 n paper provide algorithm generates minimal complete prefix certain sense defined prefix always smaller large prefix generated old algorithm paper organised follows section 2 contains basic definitions petri nets branching processes section 3 show mcmil lans algorithm element whole family algorithms construction finite complete prefixes section 4 select element family show generates minimal prefixes certain sense finally section 5 present experimental results 2 basic definitions 21 petri nets triple f net elements called places elements transitions places transitions generically called nodes identify f characteristic function set theta theta preset node x denoted ffl x set fy 1g postset x denoted x ffl set fy 1g marking net f mapping identify marking multiset containing copies every 2 4tuple net system f net 0 marking called initial marking sigma marking enables transition enabled occur occurrence leads new marking 0 denoted defined every place sequence transitions occurrence sequence exist markings 1 2 mn gamma mn mn marking reached occurrence oe also denoted 0 oe gamma reachable marking exists occurrence sequence oe 0 oe gamma reachability graph net system sigma labelled graph set reachable markings sigma nodes relations gamma markings edges marking net nsafe every place identify 1safe markings set places net system sigma nsafe reachable markings nsafe improvement mcmillans unfolding algorithm 3 paper consider net systems satisfying following two additional properties ffl number places transitions finite every transition nonempty preset nonempty postset 22 occurrence nets net let x 1 x 2 nodes x 1 x 2 conflict denoted x 1 x 2 exist distinct transitions 1 belong reflexive transitive closure f words x 1 x 2 conflict exist two paths leading x 1 x 2 start place immediately diverge although later converge x 2 x selfconflict xx occurrence net net ffl every b 2 b j ffl bj 1 ffl f acyclic ie irreflexive transitive closure f partial order ffl n finitely preceded ie every x set elements belongs transitive closure f finite ffl event e 2 e selfconflict elements b e called conditions events respectively minn denotes set minimal elements b e respect transitive closure f irreflexive transitive closure f called causal relation denoted symbol denotes reflexive transitive closure f given two nodes xy 23 branching processes branching processes unfoldings net systems containing information concurrency conflicts introduced engelfriet 4 quickly review main definitions results 4 two nets homomorphism n 1 n 2 1 mapping 4 homomorphisms defined net systems instead nets small technical difference without severe consequence 4 j esparza romer w vogler 1 net system two branching processes ffl every 2 1 restriction h ffl bijection ffl words homomorphism mapping preserves nature nodes environment transitions branching process net system occurrence net p homomorphism n 0 n restriction p minn 0 bijection minn 0 ii every e 1 figure 1 shows 1safe net system part two branching processes parts b c two branching processes net system isomorphic bijective homomorphism h n 1 n 2 intuitively two isomorphic branching processes differ names conditions events shown 4 net system unique maximal branching process isomorphism call unfolding system unfolding 1safe system figure 1 infinite two branching processes net system fi 0 prefix fi n 0 subnet n satisfying ffl condition belongs n 0 input event n also belongs n 0 improvement mcmillans unfolding algorithm 5 ffl event belongs n 0 input output conditions n also belong n 0 p 0 restriction p n 0 24 configurations cuts configuration c occurrence net set events satisfying following two conditions causally closed conditions occurrence net coset elements co relation maximal coset b 0 respect set inclusion called cut finite configurations cuts tightly related let c finite configuration branching process p coset cutc defined cut particular given finite configuration c set places pcutc reachable marking denote markc marking system sigma represented branching process fi sigma fi contains finite configuration c mark easy prove using results 1 4 every marking represented branching process reachable every reachable marking represented unfolding net system 1safe systems following result later used section 4 proposition 21 two nodes branching process 1safe net system x 1 co x 2 given cut c branching process unique subnet n whose set nodes restriction p nodes n 0 define pc multiset containing instance place pb every b 2 c following result also used later proposition 22 fi branching process n 0 c cut fi c branching process n pc 22 6 j esparza romer w vogler 3 algorithm construction complete finite prefix 31 constructing unfolding give algorithm construction unfolding net system first let us describe suitable data structure representation branching processes implement branching process net system sigma list nodes node either condition event condition pair e place sigma e input event event pair b transition sigma b set input conditions notice flow relation labelling function branching process already encoded list nodes express notions causal relation configuration cut terms data structure left reader algorithm construction unfolding starts branching process conditions corresponding initial marking sigma events events added one time together output conditions need notion events added given branching process definition 31 branching process net system sigma possible extensions fi pairs b b coset conditions fi transition sigma ffl fi contains event e satisfying pe fi denotes set possible extensions fi 31 procedure 32 unfolding algorithm input net system output unfolding unf sigma begin pe pe unf pe 6 append unf event pe condition e every output place pe pe unf endwhile improvement mcmillans unfolding algorithm 7 2 1safe net system unfolding prefix procedure necessarily terminate fact terminates input system sigma infinite occurrence sequence eventually produce reachable marking fairness assumption every event added pe eventually chosen extend unf correctness proof follows easily definitions results 4 constructing finite complete prefix say branching process fi net system sigma complete every reachable marking exists configuration c fi ffl mark ie represented fi ffl every transition enabled exists configuration cfeg 2 c e labelled unfolding net system always complete complete prefix contains much information unfolding sense construct unfolding least fixpoint suitable operation property hold require every reachable marking represented instance net system figure 2a figure 2b unfolding figure 2c shows prefix unfolding every reachable marking represented prefix lost information indicating 2 occur initial marking observe prefix complete since nsafe net system finitely many reachable markings unfolding contains least one complete finite prefix transform algorithm new one whose output prefix need preliminary notations definitions given configuration c denote c phi e fact c e configuration c say extension c e suffix c obviously c ae c 0 suffix c c phi let c 1 c 2 two finite configurations mark c 1 follows easily definitions cutc isomorphic 8 j esparza romer w vogler unfolding sigma isomorphic moreover isomorphism c2 c1 cutc 1 cut c 2 isomorphism induces mapping finite extensions c 1 onto extensions c1 e introduce three basic notions algorithm definition 33 partial order oe finite configurations branching process adequate order ffl oe wellfounded ffl oe refines ae ie c ffl oe preserved finite extensions meaning c 1 oe c 2 c1 edefinition 34 local configuration local configuration e event branching process set events e 0 e 0 e 2 34 definition 35 cutoff event let fi branching process let oe adequate partial order configurations fi event e cutoff event respect oe fi contains local configuration e 0 b ethe new algorithm parameter adequate order oe ie every different adequate order leads different algorithm algorithm 36 complete finite prefix algorithm input nsafe net system g output complete finite prefix fin unf begin fin pe pe cutoff 2 immediate prove e configuration improvement mcmillans unfolding algorithm 9 pe 6 choose event pe e minimal respect oe e append fin event e condition e every output place pe pe e cutoff event fin cutoff cutoff feg endif else pe pe n feg endif endwhile endmcmillans algorithm 10 corresponds order easy see oe adequate reason condition definition cutoff event intuitively clear light algorithm since mark e 0 marke continuations unf cute cute 0 isomorphic loosely speaking reachable markings find continuation unf cute already present continuation cute 0 need former fin role condition b technical fact mcmillans algorithm applied ordinary small examples condition b seems superfluous following strategy seems work event e added fin already contains local configuration e 0 mark mark e cutoff event following example also independently found k mcmillan shows strategy incorrect consider 1safe net system figure 3 marking fs 12 g reachable without condition b generate prefix figure 4 names events numbers indicate order added prefix events 8 10 cutoff events corresponding markings fs 7 also markings corresponding events 7 9 respectively prefix complete fs 12 g represented observe fin contains events set cutoff could modify algorithm remove events prefix obtained would still enjoy property every reachable marking represented however prefix would necessarily complete consider j esparza romer w vogler 3 1safe net system example net system figure 2a algorithm 36 generates branching process figure 2b one two events process maximal one respect oe cutoff event event removed obtain incomplete prefix prove correctness algorithm 36 proposition 37 fin finite proof given event e fin define depth e length longest chain events depth e denoted de prove following results 1 every event e fin de number reachable markings sigma since cuts correspond reachable markings every chain events contains two events e oe refines ae cutoff event unf finite prefix algorithm generate e j generated e e j recognized cutoff event fin 2 every event e fin sets ffl e e ffl finite definition homomorphism bijection denotes homomorphism fin similarly ffl pe p ffl e result follows finiteness n improvement mcmillans unfolding algorithm 11 4 prefix net system figure 3 3 every k 0 fin contains finitely many events e de k complete induction k base case set events depth k prove g 2 induction hypothesis k finite since ffl e k1 get property ii definition branching process e k1 finite follows 1 3 fin contains finitely many events 2 contains finitely many conditions 37 proposition 38 fin complete proof first prove every reachable marking sigma represented fin let arbitrary reachable marking sigma exists configuration c unf mark c configuration fin contains cutoff event e set events e definition cutoff event exists local configuration e 0 e 0 oe e mark e 0 consider configuration c e e since oe preserved finite extensions c 0 oe c morever markc 0 c 0 configuration fin iterate procedure j esparza romer w vogler find configuration c 00 c 00 oe c 0 mark c 00 procedure cannot iterated infinitely often oe well founded therefore terminates configuration fin show fin complete prove every reachable marking exists configuration c fi ffl every transition enabled exists configuration 2 c e labelled let arbitrary reachable marking sigma since represented fin set configurations c fin satisfying markc nonempty wellfoundedness set least minimal element cm respect oe cm would contain cutoff event would find another configuration c 0 satisfying contradicts minimality cm cm contains cutoff event let arbitrary transition enabled exists configuration cm feg unf 2 cm e labelled assume cm feg configuration fin since fin contains events set cutoff algorithm 36 also contains cutoff event e 0 e implies e 0 2 cm contradicts cm contains cutoff event cm feg configuration fin 38 4 adequate order 1safe case mentioned introduction mcmillans algorithm may inefficient cases extreme example due kishinevsky taubin family systems left figure 5 minimal complete prefix size size system see dotted line figure 5 branching process generated mcmillans algorithm size o2 n reason every marking local configurations e satisfying size therefore exist cutoff events respect mcmillans parametric presentation algorithm 36 suggests improve suffices find new adequate order oe r refines mcmillans order induces weaker notion cutoff event precisely every cutoff event respect oe also cutoff event respect oe r maybe way round therefore instance algorithm 36 uses new order generates least many cutoff events mcmillans instance maybe latter case algorithm 36 generates smaller prefix improvement mcmillans unfolding algorithm 13 sk sk sk sk sk copies sk minimal complete prefix 5 petri net unfolding order oe r particularly good addition total case whenever event e generated event e 0 mark e events generated accordance total order oe r e marked cutoff event following two properties ffl guard e cutoff event fin inner instruction algorithm 36 replaced fin contains local configuration ffl number events complete prefix cutoff events cannot exceed number reachable markings sequel let fixed net system let arbitrary total order transitions sigma extend partial order sets events branching process follows set e events let e sequence transitions ordered according contains transition often events e label say length e 1 lexicographically smaller e 2 note e 1 incomparable respect iff particular incomparable respect je define oe r generally suffixes configurations branching process recall set events e suffix configuration exists configuration c c phi e definition 41 total order oe r two suffixes configurations branching process fi let mine 1 mine 2 denote sets minimal elements respect causal relation say 14 j esparza romer w vogler notice definition would correct configurations need configuration even e one second condition definition could expressed foata normalform e 1 smaller e 2 respect cf eg 3 theorem 42 let fi branching process 1safe net system oe r adequate total order configurations fi proof oe r partial order easy see induction jej oe r irreflexive assume triples equalities apply induction otherwise apply induction e n mine also suffixes configurations r total configurations assume c 1 c 2 two incomparable configurations ie prove induction jc 1 base case gives c first prove minc 1 assume without loss generality contains event e 2 pe 1 ffl minc 2 subsets minn conditions different labels proposition 21 ffl e contradicts condition ii definition branching process configurations branching process cutminc 1 proposition 22 induction conclude c oe r wellfounded sequence c size c cannot decrease infinitely often also configurations size improvement mcmillans unfolding algorithm 15 decrease infinitely often respect since sequences drawn finite set analogous statement holds minc hence assume jc j c minc equal apply induction common size jc 0 infinite decreasing sequence impos sible otherwise conclude case b would impossible induction oe r refines ae obvious oe r preserved finite extensions intricate part proof complications definition 41 come play take c 1 oe r c 2 mark show c 1 phi c2 c1 e assume apply induction af terwards case c 1 c 2 easy hence assume c 1 particular jc show first e minimal c2 c1 e minimal c 0 eg let e minimal c 0 ie transition pe enabled initial marking let 2 ffl pe condition ffl 1 labelled since conditions would co relation slabelled condition ffl e contradicting proposition 21 thus c 1 contains event e 0 2 ffl pe 0 holds c 2 since therefore conditions cutc 2 label ffl pe minimal conditions fi c2 reverse implication holds analogously since c 1 c 2 used hypothesis c knowledge positions e c 0 1 c2 c1 e c 0 proceed follows see done minc 1 e 2 minc 0 hence c 0 2 finally minc 1 1 argue minc 1 configurations branching process inductive argument get c 0 also done case 42 close section remark minimality prefixes generated new algorithm ie algorithm 36 oe r adequate order figure 1b c minimal complete prefix prefix j esparza romer w vogler generated new algorithm 1safe system figure 1a spectively follows new algorithm always compute minimal complete prefix however prefixes computed algorithm minimal another sense algorithm stores reachable markings corresponding local configurations purpose discussion call local markings feature makes algorithm interesting concurrent systems local markings small subset reachable markings therefore storage unfolding may require much less memory storage state space order find prefix figure 1b complete also need know initial marking fs appears prefix nonlocal marking store information local markings prefix figure 1c minimal well prefixes generated new algorithm reason observation made local configurations fin induced cutoff events correspond different mark ings therefore prefix smaller fin lose information reachability marking 5 implementation issues experimental results implementation algorithm 36 carried context model checker described 5 allows efficiently verify formulae expressed simple branching time temporal logic storage petri nets branching processes developed efficient universal data structure allows fast access single nodes 14 data structure based underlying incidence matrix net places transitions arcs represented nodes doubly linked lists support fast insertion deletion single nodes computation new elements set pe involves combinatorial problem finding sets conditions b transition implemented several improvements combinatorial determination significant influence performance algorithm interested reader referred 6 algorithm 36 simple easily proved correct efficient particular computes set pe possible extensions time new event added fin clearly redundant similarly mcmillans original algorithm 10 implementation use queue store set pe possible extensions new events fin extracted head list event added new possible extensions generates appended tail simplest way organize list would sort events according total order oe r however inefficient involves improvement mcmillans unfolding algorithm 17 6 nbuffer original net unfolding time 1 results n buffer example 3 performing unneccessary comparisons solution sort events according size local configuration 10 compare events respect oe r really needed implementation new algorithm computes mcmillans two events e e 0 satisfy j precisely case algorithm behaves better always identifies either e e 0 cutoff event words complete prefix computed mcmillans algorithm minimal algorithm computes result time overhead running time new algorithm jbj set conditions unfolding denotes maximal size presets transitions original net notice measure size input dominating factor time complexity computation possible extensions space required linear size unfolding store fixed amount information per event finally present experimental results three scalable exam ples compare mcmillans algorithm new algorithm implemented using universal data structure improvements combinatorial determination mentioned first example model concurrent nbuffer see figure 5 net 2n places buffers capacity number reachable markings 2 n fin size 2 contains one single cutoff event see table 1 example complete prefix computed mcmillans algorithm minimal new algorithm computes prefix without time overhead expected second example figure 5 model slotted ring protocol taken 13 size prefix produced new algorithm grows j esparza romer w vogler givefreeslot1 p11 givefreeslot2 p12 free2 used2 goon2 owner2 used1 other1 goon1 other2 7 slotted ring protocol 2 original net mcmillans algorithm new algorithm 9 90 90 38 2 results slotted ring protocol example slowly case mcmillans algorithm output already one order magnitude smaller slow growth size cause even dramatic reduction running time original net mcmillans algorithm new algorithm 43 94 44 8 002 52 23 4 000 9 71 53 7423 5686 2834 512 2290 3 results milners cyclic table 3 give times example taken 2 models milners cyclic scheduler n tasks size unfolding produced mcmillans algorithm grows exponentially number tasks get linear size using new one 3 times measured sparcstation 20 48 mb main memory 4 times could calculated interrupted computation 12 hours improvement mcmillans unfolding algorithm 19 6 conclusions presented algorithm computation complete finite prefix unfolding used refinement mcmillans basic notion cutoff event prefixes constructed algorithm contain noncutoff events n number reachable markings net therefore guarantee prefix never larger reachability graph hold algorithm 10 recently kondratyev et al independently found another partial order events permits obtain reduced unfoldings 9 technique works bounded nets however partial order total upper bound size unfolding cannot derived acknowledgements thank michael kishinevsky alexander taubin alex yakovlev drawing attention problem burkhard graves detecting mistakes anonymous referee helpful comments r nonsequential processes petri net view evaluating deadlock detection methods combinatorics traces branching processes petri nets model checking using net unfoldings improvement mcmillans unfolding algorithm concurrent hardware theory practice selftimed design verification speedindependent circuits stg unfoldings analysis petri nets ordering relations technique state space search based unfolding trace theoretic verification asynchronous circuits using unfoldings petri nets petri net analysis using boolean manipulation implementation compositional partial order semantics petri boxes tr combinatorics traces branching processes petri nets executions new partialorder semantics petri nets model checking using net unfoldings technique state space search based unfolding improvement mcmillans unfolding algorithm using unfoldings avoid state explosion problem verification asynchronous circuits trace theoretic verification asynchronous circuits using unfoldings petri net analysis using boolean manipulation calculating place capacity petri nets using unfoldings ctr alessandro giua xiaolan xie control safe ordinary petri nets using unfolding discrete event dynamic systems v15 n4 p349373 december 2005 victor khomenko maciej koutny verification bounded petri nets using integer programming formal methods system design v30 n2 p143176 april 2007 victor khomenko maciej koutny alex yakovlev logic synthesis asynchronous circuits based stg unfoldings incremental sat fundamenta informaticae v70 n1 p4973 march 2006 victor khomenko maciej koutny alex yakovlev logic synthesis asynchronous circuits based stg unfoldings incremental sat fundamenta informaticae v70 n12 p4973 april 2006 victor khomenko maciej koutny alex yakovlev detecting state encoding conflicts stg unfoldings using sat fundamenta informaticae v62 n2 p221241 april 2004 fabre trellis processes compact representation runs concurrent systems discrete event dynamic systems v17 n3 p267306 september 2007 stefan haar probabilistic cluster unfoldings fundamenta informaticae v53 n34 p281314 december 2002 stefan haar probabilistic cluster unfoldings fundamenta informaticae v53 n34 p281314 august 2002
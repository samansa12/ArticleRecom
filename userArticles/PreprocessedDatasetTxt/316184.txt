type signatures legacy fortran subroutines currently developing methodological framework reverse engineering fortran77 programs used electriciteacute de france first step construction algebraic specification faithfully represents fortran code construct specification must decide coherent set profiles type signatures specifications fortran subprograms propose analysis dynamic aliases formal actual subprogram arguments order derive profiles many examples real fortran code analysis give satisfactory results arrays treated indivisible instead must take account fragment array may really accessed subprogram therefore implemented analysis extension pips code parallelisation tool provides us precise analysis interprocedural array dataflow b introduction much software currently use electricite de france edf though giving entirely satisfactory results written 15 20 years ago replacement existing systems new software redeveloped scratch expensive risky timeconsuming response problem developing methodological framework reverse engineering fortran77 source code using formal methods 10 algebraic specifications code different levels abstraction created compared propose start analysis source code creation specification lowest level ab straction believe step partially automated first specification must sufficiently close source code inspire complete confidence specifies exactly particular subprogram code must specified function however specifi work financed electricite de france contrat detude r321k2924er292 ot r32l02 appear acm sigplansigsoft workshop program analysis software tools engineering paste99 toulouse france sep 1999 cation must lowlevel prevent structured presented easier understand code aid maintenance engineer understanding code locating implementation particular aspects algebraic specification function called op eration operation profile declaring sort argument result ie profile specifies type signature function order construct algebraic specification fortran code must decide profiles operations specify fortran subprograms task address article several characteristics fortran77 language complicate task declaration fortran subprogram tell us declared parameters global variables ie variables common block declared visible really defined used 1 fortrans callbyaddress semantics means passing single array element subprogram enable access rest array element onwards passed element first array part array passed subprogram situation arise tran77 programs make extensive use arrays builtin datastructure 2 simulate data structures fortran77 builtin types support userdefined types typecorrrectness enforced compilation program may even respect declared types means base profiles used specification declared subprogram parameters types risk identifying true parameters true types also restricted fortran small set types case subprograms library routines belong particular application program lose information gleaned analysis variables actually used instantiate formal parameters indeed result fortrans impoverished type system programmer typically constructs subprograms parameters certain declared type integer say really designed instantiated subset program variables type eg variables numbering lines electrical network number 1 defined used used static analysis sense meaning respectively assignment new value variable reading value variable rest paper assume familiarity notions static analysis see chapter 10 1 2 apart chains characters versions ing nodes example reverse engineer reads code first time may clear parameter represents particularly since fortran variable names limited six characters situation would like able track values parameter may take find subprograms may passed via variables different names build understanding necessarily values involved rep resent words using type variables arbitrary names dont know types would like start finding consistent set type signatures subprograms finergrained based declared types type signatures profiles operations specifying sub programs specification sorts names types detect way hope correspond closely declared types programmers conceptual view code propose static analysis fortran code order automatically obtain precise definition variables really defined used subprogram thus group variables sets corresponding sorts set fortran variables created define sort contains least possible values variables define profiles operations specifying subprograms following section discuss approach comparing conventional type inference explaining hypotheses based treatment array regions using pips tool section 3 give detailed description analysis propose section 4 describes current implementation section 5 discusses possible extension related work compared section 6 followed conclusion discussion approach 21 conventional type inference want analysis distinguish integer line numbers integer nodenumbers also integer arrays used store linked lists line numbers integer arrays used store number node connected one end line indeed arrays vary sort value stored sort index values elements may also constrained taken together realise data structure linked list moreover given array order simulate dynamic memory allocation effectively referenced though composed several contiguous subarrays storing different information want able distinguish different parts propose make distinctions describing exactly array fragment accessed putting sort array fragments accessed way subprograms used mostly functional languages usually performed program already partially typed means type declarations set basic types typeconstructors predefined type variables assigned untyped terms type inference rules used unify type terms find consistent types function declarations function applications program include involving primitive operations assignment tests equality arithmetic operations arithmetic operations usually given predefined nonpolymorphic type signatures functions whose type signature known considered polymorphic default particular take functions arguments treatment arrays proposed classic polymorphic type inference certainly incapable giving different types different array fragments moreover wide use arithmetic opera tions classic polymorphic type inference seems incapable making distinctions different integers different whole integer arrays described indeed order avoid result close declared fortran types arithmetic operations utility operations integers integer arrays must considered polymorphic hand subsort polymorphism seems sufficient describe fortran programs analysed far found examples subprograms take subprograms arguments 3 parametric polymorphism subprograms operate lists regardless type elements list compared conventional type inference basic types propose ignore type declarations type formal parameters defined fortran subprograms use equivalent one rules conventional type inference one function ap plication instead explaining inference terms unification type terms using rule prefer describe inference relation parameters type enables us explain different occurrences appears parameter always type 22 treatment polymorphism contrast conventional type inference propose analysis restricted analysis subprogram calls synthesised declarations subprograms propose analyse calls builtin fortran arithmetic operations tests equality assignments analysis calls subprograms specific management electrical networks enable us make distinctions different integer variables integer array variables described section 21 however utility subprograms may used carry operations arbitrary integers arrays operation one profile take subprograms account could consider sorts linenumbers nodenumbers subsorts sort integers different sorts integer arrays distinguished subsorts sort integer arrays would allow implicit coercion subsort supersort necessary however would mean making analysis results much complicated order give consistent profiles routines going contribute understanding variables represent often calls utility subprograms violate declared types fact embody subsort relation programming trick desire include specification fact prefer limit analysis much less complex case profiles defined flat set sorts 3 case would able specify subprograms firstorder algebraic specification language attempt take possible subsort relation account implicit coercion algebraic specification certainly contain subsort relations leave part reverse engineer therefore propose try recognize utility subprograms may present code analysed eliminate code analysis carried 4 choice subprograms eliminate course subjective determines granularity sorts subsequently detected however experience utility subprograms easily determined studying callgraph program contains far calls subprograms specialised ones 23 reuse variables analysis relies hypothesis successive values fortran variable sort reuse variables save memory uncommon old fortran code successive values completely different nature get bad results one solution space discuss modify inference rules heuristic proposed longer consider identical two occurrences region value may modified two disadvantage solution obviously may unnecessarily give different sorts successive values variables reality always keep sort artificially split lot variable sets 24 treatment arrays would like detect array fragments subjected particular treatment subprogram analysed arises loop subprogram traverses array fragment even every element fragment accessed array fragments used realise data structures within fragment different array elements may used represent different things instead giving sort individual array element may accessed whole array case loops dont traverse whole array would like give sort traversed fragment pips tool performs static analysis fortran code sets accessed elements described convex array regions 4 25 array regions pips pips tool automatic parallelisation fortran77 programs developed ecole des mines de paris 6 parallelisation depends precise analysis carried interactively intra interprocedural array data flow pips characterises variables really accessed block code recursively propagates information pips array region defines linear limits upper lower values index accessed elements dimension array thus describes indices possibly accessed elements convex polyhedron parameterised scalar program variables 4 elimination calls certain subprograms must done care invalidate results automatic analysis problem already present analysis programs may include chains calls involving thousands subprograms unless find way eliminate dont really interest us pips region necessarily exact description set elements really accessed ffl obtained static analysis suffers limitation static analysis ie inability eliminate impossible execution paths ffl operations used propagate combine regions block code cannot always give exact result nonconvex result may approximated convex polyhedron nonlinear function scalar variables limits may overapproximated pips exact regions exactly describe set elements accessed either ffl possible execution paths ffl particular execution path pips express condition linear function scalar program variables regions may include elements actually accessed called may pips regions describe upwardly exposed uses regions describe definitions values may used exit code block redefined pips combines regions array code block one summary region respectively describe analysis using concept array regions 3 analysis propose 31 central rule detection sets variables corresponding sort based following simple rule expressed intuitively actual parameters instantiating formal parameter subprogram p specified sort formal parameter profile operation specifying let us describe interpret apply rule 32 example use example formal parameters called ipco ipce certain subprograms one real programs analysed callgraph subprograms annotated extracts fortran subprogram declarations calls shown figure 1 33 formal parameter regions borrowing pips terminology call access mode variable subprogram may must use may executed definitions variable subprogram call access mode definition subprogram may subsequently used outside subprogram overwritten define true output parameters subprogram ffl scalar variables may accessed mode figure 1 annotated callgraph subprograms example sub besti1 sub prefixna1 sub prxploipco ipce icco icce nrlo nrle sub prchenipcoicconrle sub camatna1 sub cacontna1nrlo nrle sub casdegipco icco nrle figure 2 formal parameter regions example ffl array elements may accessed mode instruction loop loop uses array index value doesnt vary successive loop iterations ffl array fragments true output parameters subprogram called instruction loop loop array fragment doesnt vary successive loop iterations ffl array fragments may traversed mode loop ie access array element fragment loop varies successive loop iterations convex envelope elements array may referenced mode case nested loops take fragment traversed outermost loop true input parameters similar definition except array fragment true output parameter every element may defined subprogram already true input param eter added true input parameters define inexact outexact inapprox outapprox regions respectively results pips analysis modified ffl calculate summary regions one separate region array access code block nonetheless integrating regions individual loop iterations access one region whole loop ffl distinguish regions exact limits call exact regions limits overapproximated call approx extending notion array region scalar variables regions 0 dimensions define regions output parameters outexact outapprox regions subprogram regions input parameters inexact inapprox regions addition necessary copy may nonconvex regions regions case several identical exact parameter regions keep one exact description true parameter however case several identical approx regions keep copies approx region may describe two different array fragments two different true parameters indeed parameter regions may describe fragments reality empty static analysis cannot identify ie true parameters really exist true parameters include fragments variables declared parameters subprogram common block call global parameters analysis based instantiation formal parameters actual parameters global parameters instantiated variables may named differently different subprograms instance static aliasing like use equivalence statements global variable accessed subprogram declared argument may even name ie declared caller note say use global variables analysis global parameter may used actual parameter call another subprogram moreover analysis carried variable static alias analysed variable thus sort easily detected added variable set true formal parameters true parameters less global parameters formal parameter regions defined accordingly formal parameter regions example shown figure 2 region enclosed contains name subprogram name array brackets values indices different dimensions represented phi1 comes mode precision limits exact approx fi nally braces list constraints index values inapprox regions besti1 prefix prxplo exist prchen may read values ipco ipce previously written prxplo pips unable determine case 34 actual parameter regions given subprogram p 2 one true formal parameter described region f callsite p2 subprogram p 1 actual parameter region callsite translation f namespace set declared parameters variables declared common blocks local p 1 carried pips case arrays array formal parameter belongs actual parameter may declared differently different dimensions even fortran types consequence region exact expressed terms indices formal array may approx expressed terms indices actual array 3 region parameterised store values variables start block code calculated however values variables parameterise regions may change execution subprogram compare regions parameterised store therefore define actual parameter region entrypoint actual parameter region call subprogram p2 p1 expressed terms store callsite reexpressed pips terms store entrypoint p 1 callsite loop actual parameter varies different iterations loop actual parameter arbitrary iteration loop described region parameterised store entrypoint case pips calculates new region loop contains actual parameter regions different iterations region reexpressed terms store entrypoint caller except exactregions parameterised variables change value execution loop actual parameter regions calls loops cannot reexpressed terms entrypoint caller also pips sometimes unable reexpress exact regions terms store entrypoint approximate approx regions 35 instantiations dynamic alias relation let us call instantiations pairs formal parameter region actual parameter region entrypoint define binary relation regions instantiated links pairs regions instantiation two variables generally said dynamic aliases share address memory virtue call subprogram means dynamic aliases different possible names variable define another binary relation regions dynamic alias links regions simultaneously addressspace memory particular path callgraph followed dynamic alias relation includes instantiated moreover instantiation r1 r2 call site subprogram p 2 subprogram p3 p2 called p1 r2 may also formal parameter region instantiation call p2 p 1 dynamic alias relation fact transitive closure instantiated ie 5 instantiated byf dynamic aliasf dynamic aliasr1 r2 dynamic aliasr2 r3 neither instantiated dynamic alias symmetrical let us call alias list list containing greatest possible number regions element except first instantiates one element except last instantiated one point execution program first element list instantiated ie subprogram deepest callgraph called elements alias list simultaneously share space memory list different names variable alias lists example shown figure 3 last actual parameter region list also formal parameter region ie neither caller shown figure mode calls prchen loop actual parameter regions cannot expressed terms store entrypoint prxplo two alias lists one element fact regions prchen give rise approx regions prxplo 36 sort relation consider group variables set sort define binary symmetric relation sort regions relation includes dynamic alias relation two regions dynamic alias relation two possible names variable consider possibility implicit coercions must therefore put set pair elements alias list thus sort relation subprogram formal parameter region f called two callsites callsites result different alias list identical f different f belong alias lists however initial rule section 31 say elements alias lists sort words sort transitive direction dynamic alias 5 following firstorder logic formulae suppose universal quantification variables example rule gives sort elements two alias lists starting region casdeg ipco moreover actual parameter precisely described exact region instantiates two different formal parameters actual parameter region belong two alias lists start differently identical region onwards parameter described region shares space memory variables alias lists successive alternative execution points suppose value stored address always sort infer elements alias lists sort case exact regions sort thus transitive directions exactasame example rule gives sort elements pair alias lists ending exact region besti1na1 fact make inference irrespective mode regions concerned let us make sort reflexive exact regions irrespective sort equivalence relation exact regions however approx region instantiates different formal parameter regions cannot sure array fragment described approx region case cannot make inference exact regions sort transitive case although parameter one sort approx region two different sorts describe two different parameters create sets containing greatest possible number regions region sort elements set exact regions sets equivalence classes sort set regions represents sort subprogram profiles constructed giving set name subprogram finding set formal parameter region belongs case several identical approx formal parameter gions instance region belong different set sorts example shown figure 4 37 overlapping regions inference make sorts two regions overlap extent situation resumed table shown figure 5 shows possible ways two regions overlap case inclusion one region another approx region cannot make inference may really inclusion array fragments described true partial overlap one region approx however case inclusion one region another exact one know really inclusion parameters case obvious explanation proper inclusion smaller region belongs subsort larger one however taking subsort relations account general would significantly complicate figure 3 alias lists example figure 4 sorts example conservative treatment approx regions figure 5 relation sorts inferred case overlapping regions overlap relation exact exact approx exact exact approx approx approx anomaly figure sorts example using heuristic approx regions analysis results could decide incorporate subsort supersort case give regions sort however example case seen programs analysed due utility routine see section 22 supersort exists purely operational purposes save lines code prefer therefore leave reverse engineer analyse cases case approx region exactly limits exact region suppose sort approx region subsort sort exact region proceed propose alternative approach cases cannot explain partial overlap two exact regions alert reverse engineer apparent anomaly 4 current implementation first implementation analysis realised new pips phase run three real legacy fortran programs 1000 3500 25500 lines code respectively aim first tentative implementation enable us quickly validate ideas real code based alreadycalculated pips regions trials obtained nearly one sort every two regions including scalars analysed programs number different callsites subprogram utility routine small implementation analysis nonetheless fails recognize many pairs regions describe array fragments 1 approximate implementation algorithm described modifications pips analysis described section 33 carried 2 programs give many approx regions analysis extremely conservative never concluding approx region describes array fragment another region however results provided implementation enabled us refine analysis 5 less conservative analysis treating approx region different regions array sort gives result conservative code contains many approx regions result explosion number apparently different sorts programs analysed many array accesses made index values depend value another array element recursively calculated loop containing access putting limits array fragment cases requires knowledge limits values another array andor inductive reasoning pips describe array accesses approx regions one approach look heuristics suggest two regions describe true parameter even though exact make inferences follow signalling need reverse engineer check hand hypothesis based example seems reasonable suppose array fragment may sometimes described exact region one access point approx region another heuristic works well codes analysed following exact region approx region array lower limit lower limit array upper limit approx region greater equal exact region suppose two regions describe array fragment heuristic applied care ffl two different candidate exact regions approx region heuristic cannot applied ffl regions calculated taking difference regions calculation one approx parameter region r1 uses another approx parameter region r2 heuristic must applied r2 first ffl deciding apply first implications heuristic must propagated back far possible regions recalculated results applying heuristic example shown figure 6 note inapprox regions besti1 prefix prxplo eliminated reverse engineer must check hand whether preconditions input variables value prchenn1 bounded 1 prxplons calls prxpl0 thus whether loop prxpl0 traverses first ns elements ipco ipce 6 comparison work related work includes ffl work alias analysis although mostly addresses programs written c array accesses notable feature rather analysis pointers poses problem work 12 9 compared type inference lackwit system 8 aim work described 12 9 flowinsensitive pointer alias analysis c programs 12 consider different names different subprograms memory location pointer also different names access paths obtained c using pointers dereferencing structure field accesses define relation two names may assignment value pointer subprogram call involving pointers refer memory location point execution transitive reflexive symmetric closure relation generate equivalence relation names enables partition code studied decide independent code fragment whether apply flowsensitive pointer alias analysis uses type inference nonstandard type system efficient way realise flowinsensitive pointer alias analysis c programs type system type represents set variable locations locations may pointed pointer type compo nent representing locations may pointed variables type pointers location type type component type system thus represents graph storage shape graph type equality standard structural equality components would obtained tagging types 8 apply c programs mlstyle 7 type inference types tagged aim detect variables representation ie type type inference rules give type two variables one assigned value one instantiates subprogram call however ml formal parameter may polymorphic several types exploit similarity alias analysis type inference use nonstandardtype inference alias analysis use alias analysis determine nonpolymorphic types formal subprogram parameters order construct algebraic specification analysis specifically adapted fortran based array regions 7 conclusion motivation work described paper reverse engineering legacy fortran77 code order construct algebraic specification fortran code need determine consistent set type signatures sub programs cannot rely fortran declarations analyse actual parameters used subprogram calls determine finergrained type formal parameter subprogram based operations used read write values may take case formal parameters array values cannot assume whole array type therefore use static analysis characterise array region array fragment may really traversed subprogram determine type region traversed fragment cannot always precisely characterised represented must take account regions overapproximations adopt conservative response approximate regions results many types detected decide types merged use heuristic checked user first approximate version analysis implemented extension pips tool offers precise interprocedural analysis array data flow acknowledgements would like thank jerome ryckbosch edf giving reallife problem work pips team ecole des mines particular beatrice creusillet francois irigoin fabien coelho corinne ancourt pierre jouvelot help thanks also supervisor michel bidoit patient rereading article r array region analyses applica tions interprocedural array region analyses efficiently computing single static assignment form control dependence graph semantical interprocedural parallelisation overview pips project theory type polymorphism pro gramming program understanding tool based type inference experiment reverse engineering using algebraic specifications algebraic specification program decomposition pointer aliasing step towards practical analyses tr compilers principles techniques tools semantical interprocedural parallelization algebraic specification efficiently computing static single assignment form control dependence graph pointsto analysis almost linear time program decomposition pointer aliasing interprocedural array region analyses ctr arie van deursen leon moonen documenting software systems using types science computer programming v60 n2 p205220 april 2006
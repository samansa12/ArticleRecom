communication complexity method measuring nondeterminism finite automata deterministic finite automata seem well understood surprisingly many important problems concerning nondeterministic finite automata nfas remain open one problem area study different measures nondeterminism finite automata estimation sizes minimal nondeterministic finite automata paper concept communication complexity applied order achieve progress problem area main results follows1 deterministic communication complexity provides lower bounds size nfas bounded unambiguity applying fact proofs several results nfas limited ambiguity simplified presented uniform way 2 family languages konk2 exponential size gap nfas polynomial leaf numberambiguity nfas ambiguity k partially provides answer open problem posed b ravikumar ibarra 1989 siam j comput 18 12631282 h leung 1998 siam j comput 27 10731082 b introduction paper classical models oneway nite automata dfas nondeterministic counterparts nfas rs59 investigated structure fundamental properties dfas well understood case nfas instance ecient algorithms constructing minimal dfas complexity approximating size minimal nfa still unresolved whereas nding minimal nfa solves pspace complete problem hromkovic seibert wilke hsw97 proved gap length regular expressions number edges corresponding nfas n log 2 n n log n exact relation unknown another principal open question determine whether exponential gap twoway deterministic nite automata twoway nondeterministic ones last partially successful attack problem done late seventies sipser s80 established exponential gap determinism nondeterminism socalled sweeping automata property sweeping essential m80 largest known gap general case quadratic hs99 main goal contribute better understanding power nondeterminism nite automata see rs59 mf71 mo71 sc78 early papers topic focus following problems 1 best known method proving lower bounds size minimal nfas based nondeterministic communication complexity hr97 known methods special cases method methods provide better lower bounds least languages one prove lower bounds size unambiguous nfas unfas nfas one accepting computation every word 2 well known fact mf71 mo71 exponential gap sizes minimal dfas nfas regular languages even known dfas unfas sc78 sh85 ri89 unfas nfas constant ambiguity sc78 ri89 ufas polynomial ambiguity nfas hl98 1 open ri89 hl98 whether exists exponential gap sizes minimal nfas constant ambiguity nfas polynomial ambiguity 3 degree nondeterminism measured literature three different ways let nfa rst measure advice n equals number advice bits inputs length n ie maximum number nondeterministic guesses computations inputs length n second measure leaf n determines maximum number apologize claiming results contribution extended abstract paper hkk00 instead referring sc78 sh85 ri89 hl98 computations inputs length n ambig n third measure equals maximum number accepting computations inputs length n obviously second third measure may exponential rst one question whether measures specically correlated attack problems establish new bridges automata theory communication complexity communication complexity twoparty protocols introduced yao y79 implicitly considered abelson ab78 initial goal develop method proving lower bounds complexity distributive parallel computations see instance th79 th80 hr97 kn97 due well developed nontrivial mathematical machinery determining communication complexity concrete problems see instance auy83 dhs96 hr97 hr00 kn97 l90 nw95 ps82 communication complexity established subarea complexity theory main contributions study communication complexity lie especially proving lower bounds complexity specic problems comparing power dierent modes computation rst time communication complexity applied study nondeterministic nite automata emphasis tradeo size degree nondeterminism nfas procedure mainly based following facts theory communication complexity contains deep results nature nondeterminism see eg knsw94 hs96 use combinatorial structure communication matrix computing problem representation ii dhrs97 hr97 hs00 nonuniform model communication protocols computing nite functions extended uniform model recognizing languages way several results communication complexity successfully applied uniform computing models like automata combining ii building new bridges communication complexity nfas establish following main results 1 let ccl resp nccl denote deterministic resp nondeterministic communication complexity l well known 2 ccl 2 nccl lower bounds sizes minimal dfa l minimal nfa l respectively first show regular languages l exponential gap 2 nccl minimal size nfas l means lower bound method based communication complexity may weak show somewhat surprising result 2 cclk 2 lower bound size nfas ambiguity k l furthermore show rankm 1k 1 lower bound number states nfas ambiguity k communication matrix associated l possible lower bound always better rst one see kn97 discussion quality socalled rank lower bound communication complexity corollary present sequence regular languages nidm size minimal nfa linear size every unfa nidm exponential substantially simplies proofs similar results sc78 sh85 2 establish relation advice n ambign leaf n oadvice n ambig n minimal nfa observe upper bound leaf n implies minimal unambiguous nfas may oadvice n dierent computations input size n exponential gap advice n leaf n possible degree ambiguity exponential n furthermore show leaf n always either bounded constant least linear polynomially bounded otherwise least exponential input length 3 present another sequence regular languages hl98 exponential gap size nfas exponential ambi guity nfas polynomial ambiguity result obtained showing small nfas polynomial ambiguity kleene closure l imply small unfas work correctly polynomial fraction inputs technique general proof method hing leung hl98 provides essentially shorter proof furthermore describe sequence languages kon k 2 exponential gap size nfas polynomial ambiguity nfas ambiguity k provides partial answer open question ri89 hl98 whether exponential gap minimal nfas constant ambiguity minimal nfas polynomial ambiguity paper organized follows section 2 give basic deni tions x notation order increase readability paper readers familiar communication complexity theory give details communication protocols build basic intuition relation nite automata section 3 devoted investigation relation size nfas communication complexity section 4 studies relation dierent measures nondeterminism nite automata presents remaining results denitions preliminaries consider standard oneway models nite automata dfas nondeterministic nite automata nfas every automaton la denotes language accepted number states called size denoted size every regular language l denote size minimal dfa l sl size minimal nfas accepting l nsl every alphabet ng ng nfa input x use computation tree ax computations x obviously number leaves ax number dierent computations x ambiguity nfa input x number accepting computations x ie number accepting leaves ax nfa ambiguity one inputs called unambiguous nfa unfa unsl denotes size minimal unfa accepting l generally nfa ambiguity k inputs called kambiguous nfa ns k l denotes size minimal kambiguous nfa accepting l every nfa measure degree nondeterminism follows let denote alphabet every input x 2 every computation c x dene advicec number nondeterministic choices computation c ie number nodes path c ax one successor advice computation xg advice every x 2 dene leaf x number leaves ax set leaf every x 2 dene ambig x number accepting leaves ax set ambig since language need contain words lengths dene ambiguity words length n makes measure monotone observe leaf advice measures monotone well note dierent denitions used authors see eg glw92 number advice bits maximized inputs minimized accepting computations inputs case nfas use constant less linear input length advice bits behavior known possible minimal nfas prove lower bounds size nite automata shall use twoparty communication complexity widely studied measure introduced yao y79 subject two monographs hr97 kn97 first introduce standard nonuniform model communica tion protocols computing nite functions twoparty communi consists two computers c c ii unbounded computational power sometimes called alice bob literature communication link p computes nite function following way beginning c gets input obtains input 2 v c c ii communicate according rules protocol exchanging binary messages one knows f c c ii may viewed functions communication arguments c c ii input whole previous communication history sequence c 1 messages exchanged c c ii output new message submitted also assume c c ii completely knows behavior c ii c situations arguments another important assumption every protocol prexfreeness property means communication history message c c prex c ii informally means messages selfdelimiting need special symbol marking end message formally computation protocol c c ii input sequence messages 2 z result computation communication complexity computation p input sum lengths messages exchanged communication communication complexity protocol p ccp maximum communication complexities inputs u v due prexfreeness property messages two computations protocol allows dierent computations communication complexity must least dlog 2 1 communication complexity f ccf communication complexity best protocol f ie protocols whose computations consist one message ie c sends message c ii c ii must compute result called oneway protocols every nite function f oneway protocol computing fg oneway communication complexity f representation nite function f uv f0 1g socalled communication matrix helpful investigating communication complexity f communication matrix f ju jjv j boolean matrix f u v dened u 2 u v 2 v f u v consists ju j rows jv j columns one wants x representation necessary relation communication complexity f one consider kind lexicographical order elements u v special order rows columns matter applications figure 1 presents communication matrix f boolean function dened addition modulo 2 denition 1 let two sets every 2 u row f row every 2 v column f number dierent rows f submatrix f intersection nonempty set rows nonempty set columns monochromatic submatrix 2 f0 1g f submatrix f whose elements equal figure 1 depicts 1monochromatic submatrix intersections rows 001 010 100 111 columns 000 011 101 110 figure set monochromatic submatrices boolean matrix f say cover f every element f exists 2 kg element mm say exact cover f cover f kg tiling complexity f exact cover f g ut work protocol c c ii f viewed game communication matrix f c input knows row row c ii input knows column column determine f 2 communication message c 1 submitted c c ii viewed reduction f submatrix f consisting rows c sends c 1 c ii knows behavior c similarly second message 2 sent c ii c restricts f columns f c 1 c ii second argument c 1 sends 2 note need estimate coordinates intersection row column knows result every computation c c ii nishes 1 0 denes 1monochromatic 0monochromatic submatrix f means inputs contained monochromatic submatrix computation protocol c c ii c c ii unambiguously determine exact cover f monochromatic subma trices precisely protocol k dierent computations determines exact cover cardinality k immediate consequence fact 1 every nite function another important consequence following fact fact 2 every nite function row f e proof two dierent rows row row oneway protocol computing f send message c c ii cannot determine result column dierent values intersections row row hand row dierent messages enough one message group identical rows construct oneway protocol f ut since number 1monochromatic matrices exact cover ones f trivial upper bound rank f fact 1 implies fact 3 every nite function every eld f neutral elements ccf dlog 2 rank f f e let q set rational numbers since wellknown eld neutral elements 0 1g formulate fact 3 every nite function f consider nondeterministic communication complexity relation combinatorial properties f nondeterministic protocol p computing nite function consists two nondeterministic computers c c ii nondeterministic choice nite number messages every input argument input say p accepts exists computation p ends result 1 computes 0 input rejects computations p end result 0 nondeterministic communication complexity p denoted nccp maximum communication complexities accepting computations p nondeterministic communication complexity f nondeterministic protocol computing fg let ncc 1 f denote oneway nondeterministic communication complexity f similarly deterministic case every accepting computation p f unambiguously determines 1monochromatic submatrix f union 1monochromatic submatrices must cover 1s f 0 f dierence deterministic case 1monochromatic submatrices may overlap corresponds fact p may several dierent accepting computations given input denition 2 let f boolean matrix let set 1monochromatic submatrices f say 1cover f every 1 f contained least one 1submatrices dene 1cover f g ut fact 4 every nite function proof consideration showing nondeterministic protocol accepting computations determines 1cover f cardinality implies since nccf ncc 1 f every f sucient prove ncc 1 f 1cover f oneway nondeterministic protocol c c ii work input follows c input nondeterministically chooses one matrices nonempty intersection row sends binary code index c ii column nonempty intersection c ii accepts since dlog 2 message length suces code dierent messages rst trivial bridge hr86 automata communication complexity says every regular language l every positive integer n l argument lower bound simple let dfa nfa accepting l sl nsl states oneway protocol compute f 2nl follows input c simulates work sends name state q reached reading c ii c ii continues simulation sux state q accepts c c ii accepts unfortunately lower bound 1 may arbitrarily bad sl nsl nonuniform approach cannot completely capture complexity uniform acceptance l shall overcome diculty next section 3 communication complexity finite automata improve lower bounds sl nsl communication complexity duris hromkovic rolim schnitger dhrs97 see also hr86 hs00 introduced uniform protocols communication matrices regular languages follows every regular language l dene innite boolean matrix since every regular language nite index myhillnerode theorem number dierent rows ml nite use protocols nite devices accepting l denition 3 let alphabet let l oneway uniform protocol pair c c ii function prex freeness property fc j 2 g nite set rejectg function say message complexity protocol ie number messages used message complexity l oneway uniform protocol accepting lg communication complexity oneway communication complexity l oneway uniform protocol accepting lg ut one wants give formal denition oneway nondeterministic protocol sucient consider c function nite subset f0 1g acceptance criterion l changes accept 2 c ii c 2 l denote oneway nondeterministic message communication complexity l observe main dierence uniform protocols standard protocols way input partitioned c c ii protocol computes boolean one view partition inputs f f0 1g rs prex r bits sux bits ie assigning rst r bits c rest c ii communication c c ii order compute value f uniform protocol considers every input partitions partitions must accept reject 2 l 62 l means matrices special boolean matrices 1 uniform protocol l must recognize membership l every partition c c ii following result dhrs97 hs00 shows fact oneway uniform protocols nothing else deterministic nite automata fact 5 let alphabet every regular language l idea proof reformulation myhillnerode theorem section 2 already observed row ml exactly number dierent messages used optimal oneway protocol 3 ut following idea simulation nite automaton protocol nondeterministic case following obvious fact hr97 fact 6 every alphabet every regular language l fact 6 provides best known lower bound proof technique size minimal nfas previously known techniques like fooling set approach special cases approach moreover fooling set method covers previous eorts proving lower bounds nsl languages provide exponentially smaller lower bounds method based nondeterministic communication complexity dhs96 rst question therefore whether nmcl used approximate nsl unfortunately possible note result similar lemma 1 also independently established jiraskova ji99 lemma 1 exists sequence regular languages fpart n g 1 n1 proof let part next considerations important observe condition equivalent condition x 6 z first describe nondeterministic uniform protocol c c ii part n uses 2 messages players c c ii compute lengths l l ii inputs c communicates l c ii rejects l l ii 6 3n assume l following case 1 l n c chooses position 1 l communicates c ii accepts accepts observe x 6 z accepting computation exists x 6 z however case 2 n l 2n c chooses position 1 n communicates furthermore c compares x n sends bit 1 strings equal bit 0 strings dierent c ii accepts x 6 z otherwise x 3 fact ml innite matter ml nite number dierent rows moreover would work innite number dierent rows ie automata innite number states eil74 two strings equal bit 1 received c ii accepts rejects otherwise note x 6 z accepting computation c ii accepts case 3 2n l 3n c chooses position l 2n n communicates furthermore c compares x c accepts otherwise c ii accepts x 6 z protocol uses 2 messages nmcpart n prove nspart n obviously every nfa b accepting must following properties accepting computation b every word xxx x 2 f0 1g n ie accepting computation b word xyx x 6 prove every nfa satisfying ii must least 2 nstates let us assume opposite let nfa fewer 2 nstates satises ii since l 1 lb exists accepting computation c x xxx every x 2 f0 1g n let p atternc x p state c x reading x q state c x reading xx since number states smaller 2 n 2 number dierent patterns smaller 2 exist two words v p atternc u states means starting work r u well v one reach reading u v immediate consequence accepting computations b uvu vuv well since u 6 v uvu vuv belong l 2 contradiction condition ii ut nd lower bound methods nsl provide results polynomially smaller nsl one central open problems nite automata following concentrate lower bounds nfas constant ambiguity even unambiguous automata nontrivial general method proving lower bounds known introduce method proving lower bounds nfas bounded ambiguity work communication matrices regular languages fact 5 observed every matrix ml nite number dierent rows index sl regular language l means exists sl sl nite submatrix ml row every eld f neutral elements thus instead introducing general twoway uniform communication protocols dene communication complexity l denoted ccl communication complexity best protocol communication matrix ml denition ml approach covers requirement protocol correctly decides membership input l prexsux partition input formulating main result section build intuition connection ccl unsl one simulates unambiguous automaton nondeterministic oneway protocol standard way described resulting protocol unambiguous means every 1 ml covered exactly one accepting computation ie unfa determines exact cover 1s ml cardinality size similarity deterministic communication complexity protocol determines exact cover elements communication matrix monochromatic submatrices nontrivial results communication complexity theory knsw94 needed relate ccl unsl via outlined connection theorem 1 every regular language l unsl rankq ml ns k l rankq ml 1k 1 c ns k l 2 cclk 2 proof let optimal unfa l simulated oneway nondeterministic protocol follows c simulates input communicates obtained state c ii continues simulation acceptsrejects accordingly obviously number messages equal size protocol works unambiguous nondeterminism easy see messages protocol correspond size many submatrices matrix ml covering ones exactly hence rank size shown rank lower bound communication complexity ms82 see fact 3 section 2 b observe simulation induces cover ones ml one covered k times following fact knsw94 done fact 7 let r denote minimal size set submatrices covering ones boolean matrix covered r times claim simulate oneway kambiguous nondeterministic protocol size messages results knsw94 see also l90 y91 imply kambigu ous nondeterministic oneway protocol messages simulated deterministic twoway protocol communication logm logm ccl logsize k c follow ut giving application lower bound method point neither 2 rankq ml lower bound method capable proving polynomially tight lower bounds minimal size unfas languages rst case trivial second case follows modication result separating rank communication complexity see kn97 gap rankq ml unsl may bounded pseudopolynomial function apply theorem 1 order present exponential gap nsl unsl specic regular language let every positive integer g theorem 2 every positive integer nidm recognized nfa ambiguity om size om ii nfa ambiguity k nidm size least 2 mk 1 particular unfa nidm must states log nidm polynomial size proof first nfa guesses residue modulo checks whether position p ii observe submatrix spanned words u v complement 2 2 identity matrix result follows assertions b theorem 1 iii immediate consequence ii ut see proof theorem 2 substantial simplication proofs similar results presented sc78 sh85 4 degrees nondeterminism finite automata easy see advice n leaf n 2 oadvice n also ambig n leaf n every nfa aim section investigate whether stronger relations measures hold lemma 2 nfa either advice n size leaf n size size advice n nsize 1 leaf n nsize 1 figure proof reachable state q belongs cycle q two edges label originating one edges belongs cycle advice n n size size nsize 1 otherwise words states nondeterministic decision traversed ut next lemma relates leaf function ambiguity initial idea computation tree minimal unfa input w could look like tree figure 2 exactly one path p root leaf computation several nondeterministic guesses paths one vertex common p contain nondeterministic branching words computation branches two computations p 1 p 2 least one p 1 p 2 completely deterministic able verify nice structure next result shows computation tree minimal unfa thin every level tree contain size 1 dierent computations follows state q nfa called terminally rejecting word computation accepts starting q ie q v contains accepting state word v clearly one terminally rejecting state minimal automaton otherwise states joined reducing size call states undecided lemma 3 every nfa one terminally rejecting state satises leaf x ambig jxj x size computation tree consists nodes marked terminally rejecting state tree one leaf claim trivial general case consider level computation tree x root level assume level contains k size nodes labeled undecided states called undecided nodes one undecided state q must appear least times level k computations prex x q reached q accepting prex x accepted contradiction since ambig monotone q rejecting undecided word v length size v accepted computation starting q prex x concatenated v accepted least k contradiction thus level tree root level contains k size undecided nodes overall jxj k size undecided nodes observe node one terminally rejecting child thus number terminally rejecting leaves equal number undecided nodes terminally rejecting child hence number terminally rejecting leaves number undecided nodes minus number undecided leaves thus overall number leaves number terminally rejecting leaves plus number undecided leaves number undecided nodes overall leaves ut theorem 3 every nfa one terminally rejecting state sat ises advice n ambig n leaf n oambig n advice n especially unfa advice proof observe n ambig ambig n since ambig monotone exponential ut next investigate growth leaf function lemma 4 variation result ir86 lemma 4 every nfa either leaf n nsize size leaf n n proof assume nfa contains state q q reentered two dierent paths starting q path labeled word w hard show case two dierent paths q q labeled word w length size 2 1 computation tree uw u leads starting state q least 2 2 n size size 2 leaves assume contain state nondeterministic state q ie state one successor letter computation tree following holds q label vertex v q appears level subtree v prove induction number k k size dierent nondeterministic states computation tree number leaves n size k claim certainly true nondeterministic states assume k nondeterministic states state q 1 appearing rst tree observe level entire computation tree contains q 1 occurrence q 1 computation tree x child overall number leaves maximized get tree one nondeterministic state less inductive hypothesis tree n size k 1 leaves appears level since size children q 1 level n size k leaves ut lemmas 2 4 give us theorem 4 every nfa leaf n either bounded constant linear polynomial n otherwise 2 n consider dierence polynomial exponential ambiguity resp polynomial exponential leaf number show languages small automata polynomial ambiguity related concatenation languages small unfas language kleene closure one unfa accepts large subset compare closures shown recognizable ecient nfas constant advice dfas theorem 5 let l innite regular language nfa l polynomial ambiguity size languages l l 1 l l l recognizable unfa osize states innitely many n regular language k using letter let nfa l polynomial ambiguity unfa 0 osize states decides l 0 l innitely many n proof dene ambiguity graph following way nodes reachable states edge q q j two paths q q j label sequence note ambiguity graph acyclic ambiguity polynomially bounded seen proof lemma 4 construct unfa ijk accepts words lead q q j via one edge q k assume longest path q q k ambiguity graph consists one edge q j reachable q ambiguity graph moreover demand edge q j q k states ijk states reachable q reachable ambiguity graph q plus state q k edges except edges q k come q j q start accepting state q k l ijk language accepted ijk consider words w 2 l n word accepted path leading q 0 accepting state q fix one accepting state constant fraction words w accepted make accepting states rejecting accepting path w states appear without violating topological ordering ambiguity graph may x sequence states q since nitely many sequences done b similar get k languages l decidable small unfas innitely many n partition letters words n given mapping nm letters k unfas n possible partitions partition must consistent accepting paths fraction 1poly n k n fix one partition words w unfa responsible prex u followed concatenation words form nally word form v x prex u sux v states q entered reading rst nal occurrence many words k n possible accepted xing least fraction size k 2 1poly n k n accepting paths consistent xing accepts less polynomial fraction compared projection k n responsibility region overall less polynomial fraction accepted hence one found q polynomial fraction words k nk leads non terminally rejecting states making one nonterminally rejecting state reached edge accepting removing original accepting states yields unfa accepts desired subset innitely many n ut applying theorem 5 prove exponential gap nfas nfas polynomial ambiguity proof also substantially simpler 4 proof exponential gap polynomial ambiguity exponential ambiguity language 0 theorem 6 family languages klm klm recognized nfa advice n leaf 2 n size polym every nfa polynomial leaf numberambiguity needs size least 2 recognize klm proof let lndisj size 32 universe sets nontriviallyg moreover let given polynomial ambiguity nfa klm get unfa accepting fraction 1polyn lndisj n innitely many n theorem 4b simulate unfa nondeterministic communication protocol player c receives x player c ii inputs protocol needs log size bits work correctly 1polyn fraction lndisj n unambiguous nondeterminism result hs96 implies task needs communication nm thus size 2 ut thus another strong separation size automata polynomial ambiguity size automata exponential ambi guity situation seems complicated one compares constant polynomial ambiguity ravikumar ibarra ri89 hing leung hl98 considered central open problem related degree ambiguity nfas show family kon languages small size nfas polynomial ambiguity nfas biguity exponentially larger following theorem describe candidate language ecient nfas ambiguity poly nomial furthermore language exhibits almost optimal gap size unfas polynomial ambiguity nfas proof rank communication matrix kon shown large reduction disjointness problem theorem 7 let kon contains words f0 1g number 1s divisible kon recognized nfa ambig n leaf nfa ambiguity k kon needs least 2 1k 2 states proof since upper bound theorem 7 obvious focus proving lower bound consider communication problem complement disjointness predicate ndisj l inputs form x 2 f0 1g l x 4 known results communication complexity free ie included measurement proof diculty interpreted incidence vectors subsets size l universe goal nd whether two sets nontrivial intersection note rank communication matrix ndisj l 2 l 1 reduce ndisj 1 kon ie identify submatrix mkonm communication matrix ndisj 1 consider inputs kon form 01 addition zz subset 1g one nd input x inputs correspond rows submatrix subset x input g 2 1 inputs correspond columns submatrix consider obtained submatrix r intersect nontrivially x r 2 kon hand r disjoint subword number 1s divisible r kon identied submatrix rank 2 1 1 applying theorem 1b obtain lower bound ut every constant language kon 2 theorem 7 recognized size om 2 leaf number ambiguity n advice n every ambiguous nfa size 2 jurdzinski ju00 observed kon 2 computed nfas constant ambiguity size polym therefore analysis theorem 7 cannot improved substan tially jurdzinskis observation also applies language f0 1g 0 k f0 1g proposed ri89 separating constant polynomial ambiguity 5 conclusions open problems shown communication complexity used prove lower bounds size nfas small ambiguity approach limited nontrivial bounds ambiguity smaller size minimal nfa possible prove lower bounds automata arbitrarily large constant ambiguity equivalent automata small size polynomial ambiguity exist context would also interest investigate ne structure languages regard constant ambiguity best one could show exponential dierences number states ambiguity k number states ambiguity k 1 observe however increase power impossible provided size unfas increase substantially complementation k00 analogous questions apply polynomial exponential ambiguity automata nonconstant sublinear ambiguity negative answer establishes theorem 3 also ambiguity complexity measure questions concern quality communication lower bound method far rank resp 2 ccl actual size minimal unfas note bounds polynomially tight alternative lower bound methods finally complexity approximating minimal number states nfa r lower bounds information transfer distributed computations notions informations transfer vlsi circuits measuring nondeterminism regular languages relation ambiguity nondeterminism separating exponentially amgigous sparseness personal communication lower bounds computation limited nonde terminism automata constant ambiguity communication complexity las vegas better determinism vlsi distributed computing economy description au tomata bounds stateset size proofs equivalence deterministic ranks vs communication com plexity communication complexity communication complexity relating type ambiguity finite automata decision prob lems lower bounds size sweeping automata succinctness descriptions contextfree equivalence containment problems unambiguous regular expressions complexity theory vlsi expressing combinatorial optimization problems linear programs complexity questions related distributed com puting tr sparseness ambiguity decision problems acceptors transducers communication complexity hierarchy relating type ambiguity finite automata succinctness representation measuring nondeterminism regular languages relation ambiguity nondeterminism finite automata nondeterministic communication complexity witnesses nondeterministic communication limited number advice bits comparison two lowerbound methods communication complexity communication complexity parallel computing communication complexity separating exponentially ambiguous finite automata polynomially ambiguous finite automata power las vegas oneway communication complexity obdds finite automata automata languages machines power las vegas ii twoway finite automata measures nondeterminism finite automata las vegas versus determinism oneway communication complexity finite automata polynomialtime computations translating regular expressions small epsilonfree nondeterministic finite automata communication complexity las vegas better determinism vlsi distributed computing extended abstract areatime complexity vlsi complexity questions related distributive computingpreliminary report notions information transfer vlsi circuits succinctness descriptions contextfree regular finite languages complexity theory vlsi ctr martin kutrib andreas malcher contextdependent nondeterminism pushdown automata theoretical computer science v376 n12 p101111 may 2007 galina jirskov state complexity operations binary regular languages theoretical computer science v330 n2 p287298 2 february 2005
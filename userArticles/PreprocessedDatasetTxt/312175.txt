fast estimation diameter shortest paths without matrix multiplication recent past considerable progress devising algorithms allpairs shortest paths apsp problem running time significantly smaller obvious time bound on3 unfortunately new algorithms based fast matrix multiplication algorithms notoriously impractical work motivated goal devising purely combinatorial algorithms match improved running times results come close achieving goal present algorithms small additive error length paths obtained algorithms easy implement desired property combinatorial nature hidden constants running time bound fairly smallour main result algorithm solves apsp problem unweighted undirected graphs additive error 2 time on25sqrtlog n algorithm returns actual paths distances addition give efficient algorithms running time footnotesize on15 sqrtk log n case required determine shortest paths k specified pairs vertices rather pairs vertices starting point results om sqrtn log n algorithm distinguishing graphs diameter 2 4 later extended obtaining ratio 23 approximation diameter time om sqrtn log n n unlike case apsp results approximate diameter computation extended case directed graphs arbitrary positive real weights edges b introduction consider problem computing allpairs shortest paths apsp unweighted undirected graph g n vertices edges recent work alon galil margalit agm91 alon galil margalit naor agmn92 seidel sei92 led dramatic progress devising fast algorithms problem algorithm based formulating problem terms matrices small integer entries using fast matrix multiplications achieve time bound denotes exponent running time matrix multiplication algorithm used current best matrix multiplication algorithm due coppersmith winograd cw90 contrast naive algorithm apsp performs breadthfirst searches vertex requires time thetanm given fundamental nature problem important consider desirability implementing algorithms practice unfortunately fast matrix multiplication algorithms far practical suffer large hidden constants running time bound consequently adopt view treating results primarily indicators existence efficient algorithms consider question devising purely combinatorial algorithm apsp runs time 3gammaffl admittedly vague term combinatorial algorithm intended contrast algebraic flavor algorithms based fast matrix multiplication understand distinc department computer science stanford university email donaldcsstanfordedu supported nsf graduate fellowship nsf grant ccr9357849 department computer science stanford university email chekuricsstanfordedu supported otl grant nsf grant ccr9357849 z department computer science stanford university email rajeevcsstanfordedu supported alfred p sloan research fellowship ibm faculty development award otl grant nsf young investigator award ccr 9357849 matching funds ibm schlumberger founda tion shell foundation xerox corporation 1 notation ofn denotes ofn polylogn tion believe instructive try interpret algebraic algorithms purely graphtheoretic terms even use simpler matrix multiplication algorithm strassen str69 currently best known combinatorial algorithm due feder motwani fm91 runs time yielding marginal improvement naive algorithm take step direction realizing goals outlined presenting algorithm solves apsp problem additive error 2 time 25 log n algorithm returns actual paths distances note running time better practical matrix multiplication algorithm strassen str69 used 281 algorithms described earlier explained also give slightly efficient algorithms sparse graphs approximating diameter algorithms easy implement desired property combinatorial nature hidden constants running time bound fairly small results presented case unweighted undirected graphs generalized case undirected graphs small integer edge weights details provided final version paper crucial step development result shift focus problem computing diameter graph maximum pairs vertices shortest path distance ver tices diameter determined computing allpairs shortest path apsp distances graph appears known way solve diameter problem fact fan chung chu87 earlier posed question whether 3gammaffl algorithm finding diameter without resorting fast matrix multiplication situation regard combinatorial algorithms diameter marginally better case apsp basch khanna motwani bkm95 presented combinatorial algorithm verifies whether graph diameter 2 time slight adaptation algorithm yields boolean matrix multiplication algorithm runs time bound thereby allowing us verify diameter graph constant time consider problem devising fast algorithm approximating diameter easy estimate diameter within ratio 12 om time perform breadthfirst search bfs vertex v let depth bfs tree obtained clearly diameter g lies 2d better approximation algorithm known problem fact even known distinguish graphs diameter 2 4 first result om log n algorithm distinguishing graphs diameter 2 4 later extended obtaining ratio 23 approximation diameter time om work suggests several interesting directions future work elementary combinatorial algorithm running time 3gammaffl distinguishing graphs diameter 2 3 belief problem efficiently computing diameter solved given decision algorithm work provides evidence support belief fact view bottleneck obtaining faster combinatorial apsp algorithm precisely problem distinguishing graphs diameter 2 3 also raises question whether strong equivalence diameter apsp problems eg complexity within polylogarithmic factors finally course removing additive error results remains major open problem rest paper organized follows begin presenting definitions useful observations section 2 section 3 describe algorithms distinguishing graphs diameter 2 4 extension obtaining ratio 23 approximation diameter section 4 apply ideas developed estimating diameter obtain promised algorithm additive approximation apsp finally section 5 present empirical study performance algorithm allpairs shortest paths preliminaries basic algorithm present notation result concerning dominating sets graphs underlies algorithms definitions respect fixed undirected graph gv e n vertices edges definition 21 distance du v two vertices u v length shortest path definition 22 diameter graph g defined max uv2g du v denote diameter graph g delta definition 23 kneighborhood n k v vertex v set vertices v distance k v ie degree vertex v denoted finally use notation n denote set vertices distance 1 v important keep mind set n v contains neighbors v also includes v definition 24 vertex v 2 v denote bv depth bfs tree g rooted vertex v throughout paper working parameter chosen later serve threshold classifying vertices low degree high degree threshold implicit following definition definition 25 define lv sg hv sg following generalization standard notion dominating set definition 26 given set v set b v dominating set vertex vertex n b one neighbors b following theorem underlies algorithms theorem 21 exists dominating set hv size os gamma1 n log n dominating set found om remark 21 easy see choosing set thetas gamma1 n log n vertices uniformly random gives desired dominating set hv high probability theorem effect derandomization resulting randomized algorithm proof suppose begin hv interested standard dominating set graph g problem computing minimum dominating set g reformulated set cover problem follows every vertex v create set gives instance set cover problem g goal find minimumcardinality collection sets whose union v given set cover solution c set vertices corresponding subsets c forms dominating set g size c vertex v occurs one sets sw 2 c thus either fast estimation diameter shortest paths 3 dominating set neighbor therein similarly dominating set g corresponds set cover cardinality greedy set cover algorithm repeatedly chooses set covers uncovered elements known provide set cover size within factor log n optimal fractional solution joh74 lov75 since every vertex degree least therefore corresponding set v cardinality least assigning weight 1s every set gives fractional set cover total weight fractional size equal gamma1 n thus optimal fractional set cover size ons greedy set cover algorithm must deliver solution size os gamma1 n log n gives dominating set g size implement greedy set cover algorithm keeping sets buckets sorted number uncovered vertices algorithm shown run time om consider case hv construct graph g adding set dummy vertices g every vertex new graph degree higher preceding argument construct dominating set g 0 size os gamma1 ns log n os none new vertices x connected vertices hv restriction dominating set v give dominating set hv size os gamma1 n log n finally running time increased addition new vertices edges since total number edges added ns ons get desired time bound 2 rest paper denote dominating set hv constructed per theorem 3 estimating diameter section develop algorithm find estimator e 2delta3 e delta first present algorithm distinguishing graphs diameter 2 4 shown algorithm generalizes promised approximation algorithm 31 distinguishing diameter 2 4 basic idea behind algorithm rooted following lemma whose proof straightforward lemma 31 suppose g pair vertices b 4 bfs tree rooted vertex v 2 n n b depth least 3 algorithm called algorithm 2vs4 computes bfs trees small set vertices guaranteed contain vertex one bfs trees certify diameter 2 algorithm 2vs4 1 lv choose v 2 lv b compute bfs tree vertices n v 2 else compute dominating set hv b compute bfs tree vertices 3 endif 4 bfs trees depth 2 return 2 return 4 assuming algorithms sets lv dv provided part input otherwise computed omns time theorem 31 algorithm 2vs4 distinguishes graphs diameter 2 4 running time oms proof clear algorithm outputs 2 graphs diameter 2 since graphs bfs tree depth exceeding 2 assume g diameter 4 fix pair vertices 4 show algorithm bfs vertex v 2 n n b since lemma 31 depth bfs tree rooted v least 3 algorithm output 4 consider two cases arise algorithm case 1 lv either b belong n v nothing prove bv 2 nothing prove therefore case remains b n 2 v see figure 1 since da b 4 paths b go vertex n 1 v implies since compute bfs tree vertex n v guaranteed bfs neighbor b completing proof size n v therefore time compute bfs trees bounded oms case 2 lv since dominating set v follows immediately n n b 6 establishing proof correctness theorem 21 4 aingworth chekuri motwani v less nodes figure 1 case 1 algorithm 2vs4 log n implies bound oms log n cost computing bfs trees case 2 choosing log n obtain following corollary corollary 31 graphs diameter 2 4 distinguished om log n time 32 approximating diameter basic ideas used algorithm 2vs4 generalized estimate diameter general fix two vertices b delta delta diameter graph suppose find vertex v n delta3 n delta3 b clear bv 2delta3 use bv estimator find small set vertices guaranteed vertex n delta3 n delta3 b compute bfs tree vertices use maximum depths trees estimator e reason choosing fraction 13 become apparent analysis algorithm fol lows simplify notation assume delta3 integer general though analysis needs modified use bdelta3c also assume delta 3 easy see case delta 2 easy handle separately key tool rest algorithms notion partialbfs defined terms parameter k kpartialbfs tree obtained performing usual bfs process point exactly k vertices including root visited lemma 32 kpartialbfs tree computed time ok 2 proof number edges examined vertex visited bounded k since kpartialbfs process terminated k distinct vertices examined implies total number edges examined ok 2 dominates running time 2 note kpartialbfs tree contains k vertices closest root set uniquely defined due ties typically k clear context mentioned explicitly definition 31 let pbfs k v set vertices visited kpartialbfs v denote pbv depth tree constructed fashion approximation algorithm diameter follows algorithm approxdiameter 1 compute spartialbfs tree vertex v 2 let w vertex maximum depth 3 compute bfs tree vertex 4 compute new graph b g g adding edges form u v u 2 pbfs v 5 compute dominating set b g 6 compute bfs tree vertex 7 return estimator e equal maximum depth bfs trees steps 3 6 following lemmas constitute analysis algorithm lemma 33 dominating set found step 5 size os gamma1 n log n proof b g vertex v 2 v adjacent vertices pbfs v respect graph g every vertex v degree vertex b g least theorem 21 follows find dominating set size os lemma 34 jn delta3 vj vertex proof consider particular vertex v 2 v v nothing prove otherwise since dominating set b g vertex u 2 u v edge b g u v g done since u 2 n v ae n delta3 v possibility u neighbor v g must case u 2 pbfs v condition jn delta3 vj implies pbfs v ae n delta3 v turn implies u 2 n delta3 v hence fast estimation diameter shortest paths 5 reader notice similarity preceding lemma case 2 theorem 31 lemma 34 follows general set cover ideas used proof theorem 21 holds even replace delta3 fraction delta crucial lemma given lemma 35 let set vertices v vertex w found step 2 belongs addition bw 2delta3 every vertex v pbfs w n delta3 v 6 proof verified vertex u 2 conversely vertex v v n delta3 conclude nonempty vertex largest depth belongs also vertex u 2 must n delta3 u ae pbfs u bw 2delta3 every vertex within distance 2delta3 w fact n delta3 w ae pbfs w follows proof lemma makes clear reason estimate within 23 diameter essentially need ensure deltak neighborhood w intersects deltak neighborhood every vertex happen bw sufficiently small small enough want bw good estimator balancing conditions gives us ratio 23 theorem 32 algorithm approxdiameter gives estimate e 2delta3 oms ms ns 2 choosing log n gives running time om proof analysis partitioned two cases let b two vertices delta case 1 vertices v jn delta3 vj either b done otherwise proof lemma 34 set vertex b since step 6 compute bfs trees vertex one v bv desired estimator case 2 exists vertex v 2 v let w vertex step 2 bw 2delta3 bw estimator done otherwise lemma 35 pbfs w vertex v 2 n delta3 n delta3 b since step 3 compute bfs trees vertex pbfs w one v bv desired estimator running time easy analyze partial bfs step 1 takes os 2 thus total time spent step 1 ons 2 step 2 implemented time step 3 compute bfs trees vertices requires total oms time time required step 4 dominated time required compute partial bfs trees step 1 theorem 21 implies step 5 requires 2 note graph b g could many edges lemma 33 step 6 takes oms time finally cost step 7 dominated cost computing various bfs trees steps 3 6 running time dominated cost steps 1 3 6 adding bounds gives desired result 2 additive factor approximations possible determine diameter allpairs shortest path distances within additive error 2 basic idea dominating set since contains neighbor every vertex graph must contain vertex within distance 1 shortest path since find small dominating set vertices hv treat lv vertices differently low degree allows us manage partialbfs combine information gleaned dominating set algorithm approxapsp comment define glv subgraph g induced lv 1 initialize entries distance matrix b infinity 2 compute dominating set hv size 3 compute bfs tree vertex v 2 update b shortest path lengths v obtained 4 compute bfs tree glv vertex shortest path lengths v obtained 5 u 6 return b apsp matrix largest entry diameter figure 2 illustrates idea behind algorithm 6 aingworth chekuri motwani actual shortest path path computed step 5 hi lo bfs node lo step bfs node step graph hi lo labeled figure 2 illustration algorithm approxapsp theorem 41 algorithm approxapsp vertices distances returned b satisfy 2 algorithm modified produce paths length b rather merely returning approximate distances algorithm runs time choosing log n gives running time 25 log n proof first show algorithm easily modified return actual paths rather distances achieve steps 3 4 associate updated entry matrix path bfs tree used update step 5 merely concatenate two paths step 3 sum whose lengths determine minimum value vertex u clear shortest path distance vertex v 2 v returned cannot smaller correct values since correspond actual paths see differ 2 need consider three cases case 1 u 2 case bfs tree v computed step 3 clearly distances returned correct case 2 definition must case u neighbor w clearly distances u w vertex cannot differ 1 distances w always correct per case 1 assignment step 6 guarantees 2 case 3 u 2 lv fix shortest path u v suppose path u v entirely contained lv du v set correctly step 4 otherwise path must contain vertex w 2 hv w contained correct distance computed per case 1 finally w 2 hv nd contains neighbor x clearly step 6 one possibilities considered involve path u x path x v since distances involving x correctly computed step 3 means b 2 finally analyze running time algo rithm step 1 requires 2 time theorem 21 implies perform step 2 stated time bound step 3 requires ms gamma1 n log n computing bfs trees step 4 may compute many omegagamma n bfs trees glv ons edges requires 2 time finally step 5 takes vertex pairs compares vertices implies desired time bound 2 although error algorithm 2 improved special case distinguishing diameter 2 4 based following two observations fact 41 u 2 hv distance delta vertex v b proof consider w vertex dominates u algorithm set b 5 algorithm would imply b exact vertices possible 2 fact 42 whenever algorithm reports 2 verify time ons per vertex thus performing verification vertices report distance 2 improve algorithm approxapsp always performs well diameter approximation algorithms previous section first fact also appears useful bringing diameter error 1 unfortunately vertices lv cannot handled easily larger diameters 5 experimental results evaluate usefulness algorithm ran two families graphs compared results carefully coded algorithm based breadthfirst searches algorithm approxapsp tweaked following heuristic improvement step 5 avoids many needless iterations node neighbor copy distances neighbor since differ 1 algorithm called fast approxapsp occasionally higher fraction incorrect entries seems fastest way solve allpairs shortest path problem fast estimation diameter shortest paths 7 approxapsp fast approxapsp approxapsp fast approxapsp speedup speedup accuracy accuracy gb median 059 395 069 053 gb average 244 1018 072 047 gb standard deviation 024 173 016 013 rg median 052 530 039 051 rg average 063 475 039 055 rg standard deviation 023 170 014 012 table 1 summary experimental results first family graphs random graphs g nm model bol85 graphs chosen uniformly random n vertices edges experiments chose random graphs n ranging 10 1000 2mn 2 ranging 003 090 graphs fast approxapsp runs 5 times faster bfs implementation half distances one second family graphs come stanford graphbase knu93 tested connected undirected graphs appendix c knuth knu93 ignoring edge weights heterogeneous family graphs including graphs representing highway connections american cities athletic schedules 5 letter english words expander graphs well combinatorial graphs thus results quite indicative practical performance although bfsbased algorithm runs fastest certain subfamilies graphbase fast approxapsp outperformed algorithms overall results summarized table 1 table gb rg refer graphbase random graphs spectively speedup numbers indicate inverse ratio execution time algorithms carefully coded bfs algorithm accuracy refers ratio total number exact entries distance matrix total number entries matrix families accuracy approxapsp could improved subtracting 1 step 5 seem necessary given bfs approach performed fast approxapsp fast approx apsp performed faster roughly 50 accuracy numbers indicate general graphs additive factor error acceptable fast approxapsp algorithm choice specific families graphs parameters adjusted even better performance acknowledgements grateful noga alon comments suggestions nati linial helpful discussions thanks also michael goldwasser david karger sanjeev khanna eric torng comments r exponent pairs shortest path problem boolean matrix multiplication shortest paths diameter verification boolean matrix multiplication random graphs diameters graphs old problems new results matrix multiplication via arithmetic progressions clique partitions approximation algorithms combinatorial problems ratio optimal integral allpairsshortestpath problem gaussian elimination optimal tr ctr david eppstein joseph wang fast approximation centrality proceedings twelfth annual acmsiam symposium discrete algorithms p228229 january 0709 2001 washington dc united states mattias andersson joachim gudmundsson christos levcopoulos approximate distance oracles graphs dense clusters computational geometry theory applications v37 n3 p142154 august 2007 toms feder rajeev motwani liadan ocallaghan chris olston rina panigrahy computing shortest paths uncertainty journal algorithms v62 n1 p118 january 2007 alan p sprague o1 query time algorithm pairs shortest distances permutation graphs discrete applied mathematics v155 n3 p365373 february 2007 mikkel thorup uri zwick approximate distance oracles proceedings thirtythird annual acm symposium theory computing p183192 july 2001 hersonissos greece joachim gudmundsson christos levcopoulos giri narasimhan michiel smid approximate distance oracles geometric graphs proceedings thirteenth annual acmsiam symposium discrete algorithms p828837 january 0608 2002 san francisco california michael elkin jian zhang efficient algorithms constructing 1 spanners distributed streaming models proceedings twentythird annual acm symposium principles distributed computing july 2528 2004 st johns newfoundland canada mikkel thorup uri zwick approximate distance oracles journal acm jacm v52 n1 p124 january 2005 joan feigenbaum sampath kannan andrew mcgregor siddharth suri jian zhang graph distances streaming model value space proceedings sixteenth annual acmsiam symposium discrete algorithms january 2325 2005 vancouver british columbia feodor f dragan estimating pairs shortest paths restricted graph families unified approach journal algorithms v57 n1 p121 september 2005 surender baswana telikepalli kavitha kurt mehlhorn seth pettie new constructions spanners purely additive spanners proceedings sixteenth annual acmsiam symposium discrete algorithms january 2325 2005 vancouver british columbia mikkel thorup uri zwick spanners emulators sublinear distance errors proceedings seventeenth annual acmsiam symposium discrete algorithm p802809 january 2226 2006 miami florida surender baswana sandeep sen approximate distance oracles unweighted graphs expected on2 time acm transactions algorithms talg v2 n4 p557577 october 2006 timothy chan allpairs shortest paths unweighted undirected graphs omn time proceedings seventeenth annual acmsiam symposium discrete algorithm p514523 january 2226 2006 miami florida rezaul alam chowdhury vijaya ramachandran externalmemory exact approximate allpairs shortestpaths undirected graphs proceedings sixteenth annual acmsiam symposium discrete algorithms january 2325 2005 vancouver british columbia surender baswana sandeep sen simple linear time randomized algorithm computing sparse spanners weighted graphs random structures algorithms v30 n4 p532563 july 2007 pairs shortest paths using bridging sets rectangular matrix multiplication journal acm jacm v49 n3 p289317 may 2002
evolutionary approach constructing effective software reuse repositories repositories software reuse faced two interrelated problems 1 acquiring knowledge initially construct repository 2 modifying repository meet evolving dynamic needs software development organizations current software repository methods rely heavily classification exacerbates acquistition evolution problems requiring costly classification domain analysis efforts repository used effectively article outlines approach avoids problems choosing retrieval method utilizes minimal repository structure effectively support process finding software conponents approach demonstrated pair proofofconcept prototypes peel tool semiautomatically identify reusable components codefinder retrieval system compensates lack explicit knowledge structures spreading activation retrieval process codefinder also allows component representations modified users searching information mechanism adapts changing nature information repository incrementally improves repository people use combination techniques holds potential designing software repositories minimize upfront costs effectively support search process evolve organizations changing needs b introduction libraries reusable software components continue grow issue retrieving components software libraries captured attention software reuse community burton et al 1987 devanbu et al 1991 frakes gandel 1990 frakes nejmeh 1987 frakes pole 1994 maarek et al 1991 prietodaz freeman 1987 sommerville wood 1986 especially componentbased reuse approaches developers compose software parts application libraries components necessary achieve software reuse componentbased software reuse faces inherent dilemma order approach useful repository must contain enough components support developers many examples available finding choosing appropriate ones becomes troublesome retrieval techniques diverse enumerated classification booch 1987 facets prieto daz 1985 prietodaz freeman 1987 framebased classification ostertag et al 1992 freetext indexing frakes nejmeh 1987 relational databases burton et al 1987 formal specifications chen et al 1993 employed address problem finding relevant components issues involving effective repositories built populated evolved meet changing needs development organizations received considerably less attention retrieval algorithms require predefined structure place designers effectively search repository minimum components must categorized placed repository valueadded approach building software repositories creates barrier real intellectual capital investments many organizations cannot overcome biggerstaff richter 1987 development organizations pressed deliver specific products cannot afford extra work required generalize categorize work products created individual projects methods needed provide adequate retrieval effectiveness minimal indexing structuring efforts allowing organizations take advantage valuable assets accumulated previous development efforts without large upfront investments addition costly structures required retrieval often static unable adapt dynamic development contexts structures created set stone changeable complex procedures often involving redesigning entire repository significant r problem proven exceedingly difficult get structure right first time also domain constantly evolving pressures changing technology project dynamics fluid nature customer needs purpose paper twofold describe problems indexing retrieval software repositories present set tools designed support incremental refinement component repositories scheme initial component representations created minimal structuring efforts allowing repositories built minimal upfront effort retrieval techniques employed compensate minimal retrieval structure help developers find reusable components developers use repository adaptive indexing techniques employed enhance retrieval structures evolve repository toward representation ways users reason development problems following sections begin overview current research retrieval methods software components evolutionary approach constructing repositories introduced followed sections describing repository seeding retrieval adaptive indexing capabilities peel codefinder experimental prototypes designed investigate issues creating maintaining software repositories conclude discussion future work based limited empirical investigations codefinder 2 supporting software reuse component repositories two basic technologies applied software reuse methodologies composition based reuse aka partsbased componentbased generative techniques aka languagebased reuse biggerstaff richter 1987 frakes pole 1994 composition technologies components selfcontained entities library routines data structures programs objects like reusing components accomplished developers finding understanding adapting components new application unix pipes code libraries programming languages examples composition techniques generative approaches closely related compiler technology pieces parameterized code invoked user selection create customized applications library problems exist generative technologies batory et al 1994 problem critical component technologies enough components must exist repository useful 21 component repositories structure repository key obtaining good retrieval results matter intelligent matching algorithm components indexed otherwise structured poorly difficult achieve good retrieval performance intuitive widely held assumption upfront investments structuring repository result proportional increase ease components reused barnes bollinger 1991 p 16 truth assumption retrieval methods created effectively use lowcost repository structures information retrieval techniques proliferated three decades research salton mcgill 1983 retrieval methods used software repositories divided three categories enumerated classification faceted freetext indexing frakes gandel 1990 hypertext systems also used although form retrieval necessary make hypertext effective large repositories halasz 1988 thompson croft 1989 enumerated classification wellknown retrieval method used dewy decimal system computing reviews classification system acm 1992 method information placed categories usually structured hierarchy subcategories much like unix file system appeal classification scheme ability iteratively divide information space smaller pieces reduces amount information needs perused issues involved using enumerated classification include inherent inflexibility problems understanding large hierarchies tradeoff depth classification hierarchy number category members domains lend many small classes effect users unfamiliar structure become lost morass possible classes halasz 1988 domains categories must necessarily contain many members case selection class first step retrieval process user must search large number category members relevant information another issue hierarchy place gives one view repository changes view may reverberate throughout taxonomy resulting extensive redesign class structures consequences entire contents repository enumerated classification requires users understand structure contents repository effectively retrieve information even well thoughtout classification systems library r congress shown problematic users blackshaw fischoff 1988 study helgon classificationbased retrieval system fischer nieperlemke 1989 subjects trouble distinguishing class labels proceedings inproceedings database computer science literature references foltz kintsch 1988 led misunderstandings contents classes ineffective retrieval behavior part problem information retrieval systems assume information space adequately represented single classification one classification correct circumstances impossible principle identify possible relevant features large information space furnas et al 1987 even naturally occurring information spaces like biological taxonomies need one structure satisfy different information needs researchers biology natural sciences lakoff 1987 structures evolved many years laborintensive nature enumerated classification remains significant barrier creating multiple structures faceted classification avoids enumerating component definitions hierarchy defining attribute classes instantiated different terms prietodaz freeman 1987 variation relational model terms grouped fixed number mutually exclusive facets users search components specifying term facets within facet classification techniques used help users choose appropriate terms similar attributevalue structures used number framebased retrieval techniques artificial intelligence brachman et al 1991 devanbu et al 1991 patelschneider et al 1984 except faceted techniques use fixed number facets attributes per domain restriction exists attributevalue methods frakes pole 1994 facets flexible enumerated schemes individual facets redesigned without impact facets usability problems remain facets make easy synthesize combine terms represent components becomes hard users find right combination terms accurately describe information need especially large complex information spaces frakes gandel 1990 method also requires users know library terms structured understanding significance facet terms arue used facet curtis 1989 field use faceted retrieval systems shown need r training people use facets effectively even extensive training necessary designing faceted information domains prietodaz 1991 freetext indexing aka automatic indexing methods use text document indexing document text applied stop list remove frequently occurring words remaining text used index document users specify query using key words applied indices find matching documents classification effort required although human indexers sometimes used augment automatically extracted index terms matching criteria range boolean match sophisticated methods vector model use statistical measures rank retrieved information salton mcgill 1983 free text methods simple build retrieve rely regularities linguistic texts need large bodies text become statistically accurate nonlinguistic nature source code fact clear accurate documentation necessary working code make methods less attractive software component repositories text documents freetext methods applicable domains extensive documentation unix man pages frakes pole 1994 maarek smadja 1989 would inaccurate characterize source code documented adequately methods although retrieval effectiveness freetext methods questioned within textintensive domains law blair maron 1985 low cost building repository coupled adequate performance made approach popular commercial text retrieval systems world wide web engines yahoo yahoo 1996 alta vista alta vista 1996 22 repository structure retrieval effectiveness methods define continuum enumerated classification requires extensive structure faceted classification requiring less structure freetext indexing requires structure classification schemes computationally simple retrieve although usability problems exist difficult build designers must get taxonomy right definition right elusive situationspecific dependent needs individuals harter 1992 faceted classification attributevalue methods suffer reduced form problemone must get attributes right becomes simple matter choosing terms within facets freetext indexing involves little upfront costs effective large corpus linguistic text available strength methods use sophisticated information structures people use knowledge contained structures lead relevant information weakness support possible information structured manner consistent user expectations creating specialized information labor intensive costly process prohibitory resources strained large information spaces concerned may true good structure crucial retrieval systems effectiveness sophisticated information retrieval techniques used finesse relationship repository structure retrieval methods question becomes relationship structure effective retrieval adequate retrieval effectiveness accomplished minimally structured repositories follows middle ground achieved investigating much accomplished assumptions existence specialized knowledge effectively utilizing information structures cheaply derived retrieval methods employed need little structure yet yield effective retrieval performance structures augmented context use people find information interaction system traced used improve existing structure result flexible integration retrieval repository construction methods improve underlying structures repository used 3 codefinder information access software reuse figure 1 shows repositories constructed minimal upfront effort incrementally improved repository used initial stages constructing repository software components important populate repository components even components explicitly designed reuse caldiera basili 1991 p 63 approach repository initially seeded fischer et al 1994 lowcost repository construction method semiautomatically indexes components terms phrases prototype system described paper called peel parse extract emacs lisp extracts components text files indexes combination automatic extraction interactive user support resulting repository created minimal retrieval structures may suffer incomplete inconsistent indexing making difficult keyword matching algorithms retrieve relevant information combination softmatching query reformulation techniques employed compensate minimal effort designing repository making easier find information codefinder system prototype retrieval tool uses combination retrieval techniques help users find reusable software henninger 1994 even effective retrieval tools repositorys effectiveness directly proportional quality indexing structures retrieval relevance feedback adaptive indexing two methods used improve repository structures reflect mental models used developers searching components empirical studies shown evolving network structures designed become effective time team setting people similar concerns use similar vocabulary belew 1987 addition system adapts changes organizations software development environment business needs codefinder repository librarian revoke kill arti cle yes wordsdeleted query mark ticle yes articl e yes currentquery words remove add new keywords toitem enter ter 1 stri ng done abort ermstobeadded vmkill subject developer adaptive indexing repository seeding retrieval figure 1 evolutionary construction repositories overall advantage approach costs incurred incrementally asneeded basis instead requiring extensive upfront repository design effort initially components required undergo whatever certification process necessary become part production system subsequent efforts incrementally add value components reused techniques adding value components studied extensively literature include methods extra certification procedures reusability caldiera basili 1991 various domain analysis methods prietodaz arango 1991 simos et al 1995 purpose work reported build repository infrastructure accommodate techniques incrementally add value purpose finding components meet developers task hand useful repository needs supported 1 tools create initial information structures 2 flexible mechanisms search browse repository 3 tools refine adapt information users work repository combination codefinder peel accomplish goal methods support semiautomatic extraction source code components query construction techniques adaptive indexing facilities figure 1 shows tools work concert support evolution software repositories 31 codefinderpeel repository codefinder peel designed investigate costbenefit tradeoffs associated building using repository support design process issues investigated domain emacs lisp customizations gnu emacs text editor cameron rosenblatt 1991 stallman 1981 components emacs lisp functions variables constants define two email three network news reader applications executed emacs text editor environment emacs lisp variant lisp specialized constructs primitives editing displaying text windows repository built files downloaded ftp sites news groups using peel extract components translate codefinder representation henninger 1993 source code extracted various newsgroups devoted emacs emacs lisp issues including compemacs gnuemacssources specialized groups gnuemacsgnus gnuemacsvminfo modest effort peel resulted creation repository consisting 1800 emacs lisp functions variables macros constants 2900 distinct terms 4 seeding repository seeding repository matter creating component representations indexing key terms phrases components take size form depending needs repository users peel reengineering tool translates emacs lisp files individual reusable components framebased knowledge representation language named kandor devanbu et al 1991 patelschneider et al 1984 used codefinder index components create framebased hierarchy retrieval concepts henninger 1994 peel extracts source code definitions functions variables constants macros source code file 1 information extracted components translated kandor objects kandor enables expression constraints members defined frame frame definitions organized hierarchically defined restrictions superframes part hierarchy emacs lisp repository shown figure 4 codefinder henninger 1994 well lassie devanbu et al 1991 argon patelschneider et al 1984 helgon fischer nieper lemke 1989 used inferencing capabilities inheritance classification retrieve information kandor representations kandors inferencing capabilities described detail elsewhere devanbu et al 1991 patelschneider et al 1984 purposes kandor representations viewed set attributevalue slots contain information given component peel used capture information place kandor slots knowledge representation system good knowledge contains automatic extraction certainly costeffective important slots need augmenting terms authors description slots shown figure 2 component peel display source code window lefthand side figure 2 allow user edit part representation window righthand side users free augment representation terms phrases deemed useful 1 point repository contains source code functions data structures nothing codefinder prevents placing types artifacts largergrained components supporting documentation desirable support higherlevel reuse subsystems wirfsbrock johnson 1990 architectures shaw garlan 1996 megaprogramming biggerstaff 1992 wiederhold et al 1992 functionality level granularity described characteristic current software reuse repositories designed find reuse functions objects create new programs r given use nonwords esoteric abbreviations common source code terms especially important retrieving software components example one mail systems parsed peel uses abbreviation mp message pointer throughout systems source code documentation important abbreviation needs captured peel uses threestep procedure process terms similar process extracting components basilis software factory caldiera basili 1991 first step fully automated terms extracted name function strings comments within immediately preceding definition common stop list applied extracted terms remove common words little semantic meaning others fox 1992 peel users also augment stop list add terms nonsense word list put term stop word list put term nonsense word list operations window shown lower part figure 2 earlier versions peel extracted terms variable function names proved descriptive researchers conclusion 2 second step display terms user users remove terms truncate list feature proved useful many components name descriptive highlight term source code window show term used see popup window personal conversation tom landauer lynn streeter bellcore one reason phenomena may variables closely tied implementation function lose sight function descriptive function works instead function since designers primary interest functions exist help perform task variable names generally less useful descriptors function names comments figure 2 highlighting indexing operations r lower part figure 2 third step allows users add terms include phrases words separated spaces punctuation figure 3 shows kandor representation component named scribeenvironmentshortform source code shown figure 2 much information automatically extracted although information entered source code file parsed include file name frame component belongs word processors frame used components extracted file scribeel including scribeenvironmentshortform rest slots filled extracting information elisp source component example elisp syntax allows string parameters used many programmers description function extracted placed description slot edited users codefinder also creates hyper links functions called component see function calls attribute figure 3 functions displayed mousesensitive text codefinder interface see example retrieved items pane figure 4 displaying immediate subsystem component therefore mouse click away time peel makes attempt assess reusability components software quality considerations dictate may wish extract components score well various measures halstead mccabe indicators caldiera basili 1991 others poulin caruso 1993 measures advantage automatic suffer assumptions based superficial information number operators variables component work described defines infrastructure accommodate metrics providing tools find components specific functionality show kandor represen tation figure 3 kandor representation object translated peel 5 compensating incomplete inconsistent indexing two major issues information retrieval interfaces need address first nature design problems people begin process illdefined notion needed go solving problem belkin et al 1982 borgman 1989 henninger 1994 second problem document indexing often inconsistent incomplete studies shown human indexers disagree terms used index documents indexer use different terms index document different times salton mcgill 1983 studies shown people use surprisingly diverse set descriptors describe objects furnas et al 1987 therefore retrieval systems built assumption quality indexing paramount factor efficacy information retrieval service fall short supporting users search process finding exact match biggerstaff richter 1987 henninger 1994 includes finding components provide partial analogous maiden sutcliffe 1992 solution problem inconsistent indexing always exist making necessary use retrieval methods algorithms go beyond simplistic keyword matching schemes belkin croft 1987 downfall traditional matching strategy queries viewed precise specifications user needs document representations precise descriptions repository objects alternative realistic strategy assume degree uncertainty document query representations mozer 1984 codefinder see figure 4 designed address issues employment intelligent retrieval methods support query construction intelligent retrieval provided associative spreading activation retrieval algorithm mozer 1984 extends exact match paradigm retrieve items associated query query construction supported retrieval reformulation williams 1984 technique allows users incrementally construct queries explore information space empirical studies indicate combination techniques achieves good performance face indexing problems illdefined information needs henninger 1994 work effectively minimally structured repository created peel r figure 4 codefinder user interface codefinder user interface category hierarchy window displays graphical hierarchy repository query pane shows current query top part query specifies two categories thing email search within bottom part specifies key terms related components retrieved items pane shows components matching current query order relevance query example retrieved items pane shows full entry top matching component component chosen user bookmarks pane holds history viewed objects related terms pane shows terms retrieved query r delete quit rmaildeleteforward terms delete message vmquit terms quit remove vmdeletemessage terms message delete remove gnuskill terms delete remove message figure 5 associative network associative network codefinder consists two layers nodes terms represented circles components rectangles boxed lines connections components terms defined terms field component link weights shown link boxes 51 retrieval spreading activation repository structure created peel collection component representations framebased organization attributevalue pairs see figure 3 given structure components retrieved matching query terms terms fields repository retrieve components codefinder also uses parameters description fields codefinder uses representation construct associative network see figure 5 associative spreading activation process based connectionist relaxation procedure retrieval mozer 1984 applied network retrieve information users specify query consisting either term component nodes query nodes given activation value 10 remains set value spreading activation process node positive activation value value passed links otherwise activation passed node computes sum incoming activation values modified link weight sum received activation values modulated fanin decay parameters resulting value fed squashing function keep activation values boundaries 2 1 asymmetrical values needed encourage flow positive activation mcclelland rumelhart 1981 example query specifying term remove figure 5 spread value 499 modified various parameters described component nodes vmquit vmdeletemessage next cycle vmquit vmdeletemessage propagate computed activation values r nodes connected example vmdeletemessage activate message delete third cycle previously activated nodes continue propagate values note message delete work together activate maildeleteforward gnuskill retrieving components even though directly indexed terms used query often referred query expansion salton buckley 1988 note also delete identified kind synonym remove keywords dynamically related items index compensating inconsistent indexing cooccurrence relationships system allowed cycle procedure stabilization reached maximum number cycles reached stabilization occurs cycle results small changes node activation values spreading activation nonboolean retrieval systems unlimited number documents may relevant degree activity values quickly dissipate activation passed away query nodes computational constraints codefinder allows users choose maximum number cycles henninger 1993 four five cycles usually allow partial stabilization occur still retrieving associations number items removed initial query 511 calculating activation values formally spreading activation defined activity levels documents 3 terms discrete time units corresponding cycles given parameter definitions found table 1 activity level document time t1 given 3 remain consistent standard information retrieval terminology document used place component section r symbo l number documents repository number distinct terms repository strength connection node node j idf inverse document frequency document decay rate decay rate maximum activity level 10 number terms document number documents indexed term j dt average number terms per document collection df average number documents per term collection document fanin term fanin table 1 associative spreading activation parameters previous activation valued reduced document decay rate net input document time given dt ux zerothreshold identity function doesnt allow negative activation values propagate x x 0 activity level term unit j found manner substituting term document parameters previous activation valued reduced document decay rate r net input term j time given df 512 parameters spreading activation algorithm activity level node combination previous activation reduced decay factor net input scaled difference previous activation value maximum minimum retaining part previous activity reduces wild fluctuations occur activity reaches node different times essentially integrating evidence node across cycles process belew 1987 value fed arctan function keep values maximum minimum decay factor q causes node lose fixed percentage activation cycle resulting exponential decay activation value time nodes receive initial activation lack confirming evidence form positive feedback activated nodes decay time toward resting value 0 prevents inertia phenomenon nodes receiving activation retain forever terms normally outnumber documents terms serve multiple sources find relevant documents decay rates terms need set higher documents decay rates shown experimentally work well henninger 1993 mozer 1984 net input modified fanin factor x prevent nodes large numbers connections receiving unduly large amounts activation dividing average number terms per document number terms given node inflates net input nodes less terms average reduces net input raising factor fanin exponent magnifies effect provides parameter adjusted bias nodes large numbers connections eliminated experiments codefinders repository found effectively removed fanin bias henninger 1993 513 link weights critical part structure spreading activation systems link weighting nodes associative network controls amount information passed spreading activation cycles previous spreading activation systems defined constant link weight nodes mozer 1984 based false conjecture terms equally related item example terms reply mail used index item vmreply would safe say reply descriptive function reply better discriminatorit better describes item retrieve vmreply higher probability mail kind discrimination accomplished associative net varying weight proportion discrimination value term better discriminators higher weights result spread larger activation values term item discrimination difficult define generalized manner difficult apply every termcomponent relationship large repository fortunately empirical observation tendency less frequent terms precise terms recall precision led effective approximations furnas et al 1987 sparckjones 1972 term low frequency occurs seldom information space good discriminator items indexes example item indexed terms b indexes 100 items b indexes 2 others b quite unique item retrieve rather high probability method called inverse document frequency idf proven quite effective retrieval systems number domains belkin croft 1992 salton buckley 1988 codefinder weight connection document descriptors w ji given weights connection j log n df j log n connected modified form standard idf weighting scheme log n df j 1973 modification dividing standard idf log total number documents normalizes weight values 0 10 note weight term indexes one document 10 ie logn logn r scheme gives one weight term repository better discrimination measure would recognize terms better discriminators certain items uniform weight across items indexes one measure term frequency tf frequency term given item document salton buckley 1988 codefinder uses idf measure software source code objects linguistic regularity large text documents tf measures rely codefinder achieves individual termtodocument weighting relevance feedback mechanisms see section 63 514 defining relationships content induced structure power combination peel codefinder indexing need exhaustive codefinder effectively locate software objects minimal indexing peel combined spreading activation browsing tools codefinder adequately supports process locating relevant source code empirically validated user studies fischer nieperlemke 1989 foltz kintsch 1988 henninger 1994 associative spreading activation model uses common connections keywords components induce relationships components terms mozer 1984 compensating queries using improper terminology structure repository predefined term component relationships spreading activation uses retrieve information induce relationships components particularly salient way demonstrate effect show related keywords retrieved singleword queries figure 6a shows query delete retrieve number synonyms semantic relationship delete components retrieved programmed system given structure repository terms delete remove kill cooccur components spreading activation able induce semantic relationship words referred content induced structure halasz 1988 figure 6c shows term open specified terms related things open operations server connection host others retrieved addition synonyms launch opened note terms would normally considered synonyms terms frequently cooccur programming idioms screen images shown figure 6 retrieved directly emacs lisp repository created peel without augmentation repository sampling kinds strong semantic r relationships derived spreading activation extent adequate associative structure exists kinds relationships found figure 6a figure 6b figure 6c spreading activation able find semantically related words captures idiosyncratic term usage repository example figure 6a relationship delete kill captures programming idiom term kill often refers deleting object addition one programs view mail kyle jones uses term delete deleting messages kill referring removing files figure 6b therefore shown figure delete query retrieved terms related messages kill query found number words related files kind idiosyncratic term usage missed traditional thesaurus methods based equivalence classes words important domains generate idiomatic terminology describe complex concepts software development medical fields others associative spreading activation uses structure repository find idiomatic word relationships additional laborintensive effort predefine word relationships computed word relationships displayed related keywords pane see figure 4 provide cues reformulating query figure capturing word relationships content induced structure highest rated terms relevant query related terms pane appear order highest top lowest bottom activation value semantically related queries figure 6a shows results query delete specified figure 6b uses term kill figure 6c uses open 52 retrieval reformulation beyond soft matching algorithms retrieval systems reduce effects poor repository structure supporting process query construction retrieval reformulation method supports incremental query formation building query results williams 1984 time user specifies query system responds query reformulation cues give users indication repository structured terms used index objects users incrementally improve query critiquing results previous queries supports refinement information needs accumulating knowledge acquired search process narrowing solution rabbit williams 1984 helgon fischer nieperlemke 1989 examples retrieval systems based retrieval reformulation paradigm codefinder supports retrieval reformulation providing number retrieval cues interface important example components appearing example retrieved items pane see figure 4 pane shows full representation component allowing user choose attributes inclusion exclusion query retrieval reformulation accomplished mouse action allows users simply point click components included query example user wanted add term subject shown terms attribute component vmkillsubject figure 4 would simply clickleft term term would placed terms field query pane retrieve button command pane would displayed bold indicating query changed choosing retrieve button would retrieve information based new query 4 codefinder enhances retrieval reformulation paradigm three ways first items automatically placed appropriate part query opposed query languages users responsible structure content queries users spared cognitive overhead deciding put attribute category term secondly codefinder imposes ranking criteria retrieval set automatically displaying highest rated item query important example provides cues characterize kinds items retrieved query 4 two step process used retrieval take nontrivial amount time large repositories users wish make multiple changes query would wait time change made retrieve button puts users control potentially timeconsuming operation takes place r improved better example easier converge satisfactory solution selecting good example addressed previous retrieval reformulation systems helgon example organized retrieval set alphabetic order displayed first example ordering fischer nieperlemke 1989 third codefinder displays terms related terms pane shown figures 4 6 terms also ranked order relevance query used refine query 6 supporting incremental refinement component repositories components captured minimal structure necessary evolve structure meet needs development organization necessary improve indexing structure repository also keep information current knowledge organization evolves henninger et al 1995 even innovative intelligent retrieval tools repositorys effectiveness influenced quality indexing problem indexing quality relative measure depending retrieval context arising different information needs perspectives differ individuals different information needs different times well different users different backgrounds harter 1992 therefore effective repository structures cannot designed front must allowed evolve context use ultimate goal component repository create indexing scheme similar knowledge structures possessed programmers working application area curtis 1989 date little research directed characterizing nature knowledge structures one potentially useful line research studied relationship people model problem solution spaces kintsch greeno 1985 theory distinguishes situation model designers model application domain specific problem faced system model set resources provided system programming languages environments example relationship models shown figure 7 one translation initial highlevel conceptualization users problem needs translated language used index desired items effectiveness repository improved minimizing mismatch situation system models formidable problem demonstrated figure 7 derived empirical study asked people keywords describe given object henninger 1994 note users often conceptualize retrieval problem terms application goal system terminology refers object implemented users unfamiliar implementation model difficulty finding desired functionality enough merely structure place structure user understand use something supports users model system curtis notes empirical studies shown programmers gain experience understanding knowledge particular domain gravitates toward common structure curtis 1989 also empirically shown indexing structures adaptive systems converge toward common themes groups similar interests belew 1987 difficult anticipate design needs uses design artifacts advance group users working moderately homogeneous environment tend approach problems way work together studies shown great deal effort project directed creating mutual understanding problem among developers walz et al 1993 best opportunity capture typical use situations provide means easily modify repository use provides critical insight designers view domainthe characteristics situation models 61 adapting repository context use adaptive techniques improve repository applied recording user actions incrementally changing representations based actions users interact system system migrate toward indexing scheme using kinds application goals typically encountered users overall goal system gradually build consensual representation users knowledge rose belew 1991 p 3 change knowledge organization evolves graphics drawcircle xcenter ycenter radius innerradius iradius gaps ngaps 0 system models implementation units ring washer situation models application goals figure 7 situation system models r bellcore study people choosing terms describe common objects cooking recipes editor commands items revealed probability two people choosing keyword objects 10 20 percent furnas et al 1987 using fifteen aliases achieve 6080 percent agreement thirty aliases get 90 percent agreement led notion unlimited aliasing term applied user describe object used descriptor index term object furnas et al 1987 note aliasing different traditional thesaurus methods using equivalence classes terms aliasing terms point directly objects terms thesaurus one problems unlimited aliasing approach potential precision problems terms used often describe objects repository probability system retrieving unwanted objects increases studies retrieval systems using large numbers aliases shown precision problems less severe theory would expect gomez et al 1990 occurs practice terms per object necessarily imply objects per term theoretical notion precision ratio irrelevant objects retrieved total retrieval set matters less recall ratio relevant objects retrieved total retrieval set interactive retrieval environment words long relevant objects retrieved people able find peruse objects matters less many irrelevant objects retrieved one method achieve unlimited aliasing without unwanted precision problems adaptive indexing furnas 1985 method collects term usage data interactively process real information seeking sessions adding terms object representation used search satisfied document codefinder supports unlimited aliasing adaptive indexing tracking term usage retrieval session allowing users associate terms indexing representation selected item process constructing query browsing information space user might remove number terms query enter terms system lexicon case error message warning deficiency posted terms used evidence situation model initial way thinking retrieval problem may also terms current query items current representation adding terms chosen item may enhance future retrievability item must guard situations misspellings undesired terms used retrieval session r figure 8 adaptive indexing codefinder codefinder addresses issue displaying information user inspection possible modification terms presented user click choose button example retrieved items pane see example matching items pane figure 4 clicking button number semantics placing example editor buffer invoking case tools analyze component fischer et al 1991 occurs adaptive indexing session invoked shown figure 8 users given option add items current representation chosen example allowed enter terms wish repository users also modify repository structure used kandorbased part codefinder pulldown menus one shown middletop figure 3 henninger 1995 kind modification perhaps best handled repository librarian important facility enables evolution repository 63 adjusting link weights relevance feedback addition assigning new terms component representation codefinder uses relevance feedback adjust termcomponent link weight relevance feedback typically used reformulate query usually adding documents representation query salton buckley 1990 codefinder accomplishes allowing users click circles righthand side retrieved items r pane see figure 4 item chosen placed query see related items portion query pane used part spreading activation query codefinder also uses action indication chosen components relevant terms shown terms portion query pane strengthening link weight components terms increase probability similar queries future get better retrieval results localized reinforcement belew 1987 learning technique normally adjusts weights activating input nodes results target vector output used strengthen weights user feedback used codefinder lieu target association wish strengthen terms query components chosen relevance feedback therefore component chosen relevance feedback indexed terms query weights adjusted following learning rule rose belew 1991 p 21 j activation value document node j f feedback given node user binary yesno value codefinder h learning rate usually value 0 10 values adjusted arctan squashing function keep values 10 10 since knowledge link weights smolensky 1988 potentially important contribution effectiveness spreading activation unfortunately evaluating effectiveness method runs credit assignment problem weights responsible results changed better performance however empirical studies shown retrieval performance indeed improve time especially used groups homogeneous interests belew 1987 sparse matrix multliplication kandor database codefinder user interface matrix creation kandor objects component query results subsumption queries termitem tuples input vector query results sparse matrix representation symbolics lisp machine unix source files new associations figure 9 codefinder architecture 7 design evaluation codefinder 71 implementation general architecture codefinder shown figure 9 codefinders interface built symbolics lisp machine reasons efficiency scaling repository spreading activation calculations implemented c routines executed unix machine socket interface used pass information different operating systems peel takes elisp source files inputs produces kandor objects create matrix codefinder extracts terms kandor objects creates series tuples form term item one term database object unix side tuple inserted sparse matrix representation statistics accumulated spreading activation parameters implementation spreading activation straightforward matrix multiplication adjustments algorithm parameters connections terms documents represented n n connection r matrix n vector containing documents terms initial query represented vector length n query nodes terms documents set 10 vector multiplied matrix resulting vector sums net input nodes connected query nodes adjusted algorithm parameters resulting vector multiplied connection matrix compute next cycle matrix multiplication especially large matrices expensive operation fortunately associative networks sparsely populate matrix allowing greater computational efficiency sparse matrix multiplication algorithms especially true structured associative networks used codefinder allow links terms components subsecond response time achieved emacs lisp repository using decstation 5000 rudimentary sparse matrix multiplier computational complexity algorithm proportional sparse matrix multiplication algorithm used implement spreading activation faster hardware better sparse matrix multiplication algorithms could easily accommodate repositories tens thousands items codefinder also allows storage matrix representation unix side matrix creation step omitted updates matrix adaptive indexing facilities see section handled sending tuples matrix creation module inserts tuple matrix updates parameters new term unique ie appear repository nothing else done existing term added component new termitem association changes link weight term keep mind weights determined idf measure weight must adjusted component term associated 72 empirical evaluation codefinder experiment conducted assess effectiveness codefinders interface retrieval methods minimal structures ie structure derived peel without benefit adaptive indexing henninger 1994 henninger 1993 subjects given tasks involved finding software components functionality tasks adapted observations people developing software emacs lisp environment codefinder compared two software component retrieval systems used direct matching retrieval algorithms limited capabilities reformulating r queries systems assessed ability help subjects solve problems along dimensions problem definition welldefined directed illdefined vocabulary match match mismatch results showed differences systems pronounced tasks illdefined vocabulary mismatch categories henninger 1994 codefinder scored best categories subjects finding items faster results indicate subjects problems systems using straightforward matching algorithms problems illdefined vocabulary mismatched greater degree success codefinder indicates softmatching retrieval algorithms spreading activation coupled query construction techniques necessary adequately support kinds tasks typically encountered developers searching information reusable components important underscore fact results consequence codefinders overall interface spreading activation algorithm experiment designed evaluate interface retrieval algorithms therefore evaluation criteria differed traditional recall precision measures salton mcgill 1983 focusing instead subjects ability use systems features find relevant information results thus agree studies concluding retrieval methods alone insufficient gain performance advantage frakes pole 1994 able control effects spreading activation retrieval reformulation henninger 1994 hypothesis codefinders better performance due least part coupling methods studies needed verify results improve understanding observations 8 conclusions future directions work described paper rooted need software development tools support process finding components reuse although true perfectly constructed indexed component repositories make relevant components easy find reality pragmatic inherent circumstances prevent creation repositories illdefined nature design problems one problem makes difficult index components future use another problem unfamiliar esoteric vocabulary often used software design process makes difficult potential reusers find useful components therefore difficult costly anticipate needsfor given component used even perfection could achieved fact people use diverse vocabulary describe diverse information needs prevent users always finding proper components addition costly structures required retrieval often static unable adapt dynamic development contexts structures created set stone changeable complex procedures often involve redesigning entire repository methods needed 1 provide adequate retrieval effectiveness minimal indexing structuring efforts allowing organizations take advantage valuable assets accumulated previous development efforts without large upfront investment reusability 2 help repository evolve changing needs people software development organization paper presents approach supporting kind lifecycle repositories repositories initially seeded structure index terms peel tool extracts repository information emacs lisp source code codefinder supports retrieval process retrieval reformulation spreading activation used help users find components face less thanperfect repository structures indexing using codefinder find components users given opportunity add structure index terms repository improving repository reflect kinds problems repository users typically encounter process advantage avoiding costly repository populating efforts capturing information may useful people encountering similar information needs future empirical studies shown codefinder able adequately support process finding relevant software components even minimal structures indexing performed peel henninger 1994 henninger 1993 results study merely provide evidence effectiveness repository tools provided codefinder studies needed better understand nature retrieval process context software development longitudinal studies context software development organizations also needed assess utility limitations adaptive facilities codefinder studies nature promise bring better understanding satisfy information needs problem solving contexts repositories evolve become effective time r studies also pointed number improvements needed peelcodefinder tool set become viable tool development organizations time attempt made assess reusability components capture component metrics work way apply methods described paper largergain software components nonsource code artifacts henninger 1997 henninger et al 1995 studies also needed compare codefinder repository retrieval methods faceted classification prietodaz freeman 1987 although upfront repository construction costs methods make comparisons difficult order software reuse methodologies feasible effective methods needed exploit valuable assets exist development organizations form existing code modules developed saved thought reuse tools building repository must developed extract modules represent repository form amenable specific set retrieval tools work presented takes steps toward addressing issues future work needed refine ideas subject rigorous empirical studies assess effectiveness learn nature component repositories built support software reuse techniques acknowledgments thank members gerhard fischers humancomputer communication group university colorado especially peter foltz gerhard fischer walter kintsch david redmiles curt stevens many discussions shared ideas discussed paper generous donations reusable software helga nieperlemke jonathan bein gave codefinder initial start grant mda90386c0143 army research institute supported research part r r alta vista search service making reuse costeffective genvoca model softwaresystem generators adaptive information retrieval machine learning associative networks retrieval techniques information filtering information retrieval two sides coin ask information retrieval parts 1 2 assessment analysis software reuse reusability framework assessment directions decision making online searching evaluation retrieval effectiveness fulltext documentretrieval system software components ada users information retrieval systems created equal exploration individual differences living classic use klonelike language reusable software library identifying qualifying reusable software components learning gnu emacs retrieval reusable software components cognitive issues reusing software artifacts lassie knowledgebased software information system cognitive tools locating comprehending software objects reuse seeding evolutionary growth reseeding supporting incremental development design r environments helgon extending retrieval reformulation paradigm empirical study retrieval reformulation helgon lexical analysis stoplists representing reusable software software reuse information retrieval empirical study representation methods reusable software components experience adaptive indexing scheme vocabulary problem humansystem communication right words finding want function richness indexing vocabulary reflections notecards seven issues next generation hypermedia systems psychological relevance information science using iterative refinement find reusable software information access tools software reuse organizational learning approach domain analysis locating relevant examples examplebased software design understanding solving word arithmetic problems information retrieval approach automatically constructing software libraries full text indexing based lexical relations application software libraries exploiting reusable specifications analogy interactive activation model context effects letter perception part 1 account basic findings inductive information retrieval using parallel distributed computation computing similarity reuse library system aibased approach argon knowledge representation meets information retrieval reuse metrics return investment model implementing faceted classification software reuse classifying software reusability connectionist symbolic hybrid improving legal research term weighting approaches automatic text retrieval improving retrieval performance relevance feedback introduction modern information retrieval software architecture perspectives emerging domain organization domain modeling odm guidebook proper treatment connectionism software components catalogue statistical interpretation term specificity application retrieval index term weighting emacs extensible customizable selfdocumenting display editor support browsing intelligent text retrieval system inside software design team knowledge acquisition sharing integration toward megaprogramming makes rabbit run surveying current research objectoriented design tr makes rabbit run evaluation retrieval effectiveness fulltext documentretrieval system vocabulary problem humansystem communication retrieval techniques reflections notecards seven issues next generation hypermedia systems termweighting approaches automatic text retrieval users information retrieval systems created equal exploration individual differences support browsing intelligent text retrieval system full text indexing based lexical relations application software libraries cognitive issues reusing software artifacts surveying current research objectoriented design implementing faceted classification software reuse identifying qualifying reusable software components representing reusable software connectionist symbolic hybrid improving legal research learning gnu emacs information retrieval approach automatically constructing software libraries lexical analysis stoplists exploiting reusable specifications analogy computing similarity reuse library system toward megaprogramming information filtering information retrieval inside software design team locating relevant examples examplebased software design evolutionary growth reseeding information access tools software reuse organizational learning approach domain analysis software architecture cognitive tools locating comprehending software objects reuse experience adaptive indexing scheme software component ada domain analysis software systems modeling introduction modern information retrieval making reuse costeffective using iterative refinement find reusable software genvoca model softwaresystem generators empirical study representation methods reusable software components emacs extensible customizable selfdocumenting display editor software classification scheme reusability libraries development adaptive information retrieval ctr justin clark chris clarke stefano de panfilis giampiero granatella paolo predonzani alberto sillitti giancarlo succi tullio vernazza selecting components large cots repositories journal systems software v73 n2 p323331 october 2004 hg gross melideo sillitti selfcertification trust component procurement science computer programming v56 n12 p141156 april 2005 martin gaedke jrn rehse supporting compositional reuse componentbased web engineering proceedings 2000 acm symposium applied computing p927933 march 2000 como italy bart george rgis fleurquin salah sadou methodological approach choose components development evolution processes electronic notes theoretical computer science entcs 166 p2746 january 2007 anita behle michael kirchhof manfred nagl ralf welter retrieval software components using distributed web system journal network computer applications v25 n3 p197222 july 2002 tamara sumner melissa dawe looking digital library usability reuse perspective proceedings 1st acmieeecs joint conference digital libraries p416425 january 2001 roanoke virginia united states organizing visualizing software repositories using growing hierarchical selforganizing map proceedings 2005 acm symposium applied computing march 1317 2005 santa fe new mexico yunwen ye gerhard fischer supporting reuse delivering taskrelevant personalized information proceedings 24th international conference software engineering may 1925 2002 orlando florida yunwen ye gerhard fischer brent reeves integrating active information delivery reuse repository systems acm sigsoft software engineering notes v25 n6 p6068 nov 2000 g fugini c bellettini hierarchyaware approach faceted classification objectedoriented components acm transactions software engineering methodology tosem v8 n3 p215262 july 1999 g fugini c bellettini corrigenda hierarchyaware approach faceted classification objectoriented components acm transactions software engineering methodology tosem v8 n4 p425472 oct 1999 yunwen ye gerhard fischer reuseconducive development environments automated software engineering v12 n2 p199235 april 2005
generalization resourcebounded measure application bpp vs exp problem introduce resourcebounded betting games propose generalization lutzs resourcebounded measure choice next string bet fully adaptive lutzs martingales equivalent betting games constrained bet strings lexicographic order show strong pseudorandom number generators exist betting games equivalent martingales measure e exp however construct betting games succeed certain classes whose lutz measures important open problems class polynomialtime turingcomplete languages exp superclass polynomialtime turingautoreducible languages expmartingale succeeds either classes betting games finite union property possessed lutzs measure one obtains nonrelativizable consequence mboxbpp neq mboxexp also show mboxexp neq mboxma polynomialtime truthtableautoreducible languages lutz measure zero whereas b introduction lutzs theory measure complexity classes usually defined terms resourcebounded martingales martingale regarded gambling game played unseen languages let standard lexicographic ordering strings gambler g starts capital places bet given fixed particular language bets outcome depends whether 1 2 bet wins new capital bet loses c gambler places bet membership string 2 3 forth gambler succeeds gs capital c grows toward 1 class c languages g succeeds subclass said measure zero one also says g covers c lutz others see lut97 developed rich extensive theory around measurezero notion shown interesting connections many important problems complexity theory propose generalization obtained lifting requirement g must bet strings lexicographic order g may begin choosing string x 1 place first bet oracle tells result may choose string x 2 second bet forth note sequences x may radically different different oracle languages complexitytheory parlance gs queries adaptive lone restriction g may query bet string twice call g betting game betting games remedy possible lack martingale theory one best explained context languages random classes e exp language l drandom l cannot covered dmartingale based ones intuition random 01 sequences language l likewise drandom flipx changes every 0 x 1 viceversa however closure property known erandom exprandom languages way martingales tied fixed lex ordering sigma betting games adapt easy permutations sigma induced flip similarly class c small sense covered betting game remains small languages permuted rerecursive theory random languages generalization similar kolmogorovloveland placeselection rules see lov69 make theory work complexity classes via novel definition running time tn infinite process new angle measure theory may useful attacking problem separating bpp exp recently gained prominence iw98 lutzs theory open whether class expcomplete setsunder polynomialtime turing reductionshas expmeasure zero fact set measure one results allender strauss as94 bpp 6 exp since oracles bpp exp hel86 kind absolute separation would major breakthrough show expcomplete sets covered exp betting gamein fact ebetting game one technical lack theory notion measure also interesting finite unions property holds betting games viz martingales enjoy permutationinvariance betting games bpp 6 exp finally show pseudorandom number generator prg security 2 nomegagamma1 exists every expbetting game g one find expmartingale succeeds sets covered g prgs higher securityomegagamma n likewise imply equivalence ebetting games emeasure ambosspies lempp asl96 proved expcomplete sets emeasure zero different hypothesis namely measure theory betting games help us dig questions prgs complexityclass separations tool notion autoreducible set whose importance complexity theory argued buhrman fortnow van melkebeek torenvliet bfvmt98 bft95 language l p autoreducible polynomialtime oracle tm q inputs x q l correctly decides whether x 2 l without ever submitting x query l q nonadaptive ie computes polynomialtime truthtable reduction say l p tt autoreducible show class p autoreducible sets covered ebetting game since every expcomplete set p autoreducible bfvmt98 implies results given subclass p tt autoreducible sets provides following tighter connection measure statements open problems exp ffl p tt autoreducible sets emeasure zero ffl p autoreducible sets emeasure one exp exp 6 bpp merlinarthur class babai bab85 bm88 contains bpp np since exp 6 strongly believed one would expect class p autoreducible sets emeasure zero proving thisor proving dozen measure statements corollaries 62 65would yield proof exp 6 bpp sum whole theory resourcebounded measure progressed far enough wind issues pseudorandomness stochasticity within exponential time tightly turn wheels notches seek greater understanding complexity classes places boundary measure one measure zero seems tightest section 2 reviews formal definitions lutzs measure martingales section 3 introduces betting games shows generalization martingales section 4 shows simulate betting game martingale perhapsunavoidably higher time complexity section 5 however demonstrates strong prgs allow one compute martingale order time section 6 presents main results pertaining autoreducible sets including main motivating example concrete betting game concluding section 7 summarizes open problems gives prospects future research preliminary version paper without proofs appeared proceedings stacs98 title generalization resourcebounded measure application martingales martingale abstractly defined function f 0 1 g nonnegative reals satisfies following average law w interpretation lutzs theory string w 2 f 0 1 g stands initial segment language arbitrary alphabet sigma follows let standard lexicographic ordering sigma language sigma write w v iff ith bit w 1 also regard w function domain range writing ws ith bit w martingale succeeds language sequence values dw w v unbounded j set strings w 2 f 0 1 g b 2 f 0 1 g dwb 6 dw implies jwbj 2 j say martingale active j stand possibly empty often uncountable class languages succeeds definition 21 cf lut92 may94 let delta complexity class functions class c languages deltameasure zero written delta martingale computable delta c 1 one also says covers c lutz defined complexity bounds terms length argument w denote n however also work terms largest length n string domain w n 0 n equals blog nc care complexity bounds languages want analyze naturally stated terms n prefer use n martingale complexity bounds following correspondence helpful measure exp convention lets us simply write e emeasure regarding delta e functions similarly exp expmeasure generally delta delta names language function class abusing notation similarly define definition 22 lut92 class c deltameasure one written delta concept resource bounded measure known robust several changes may94 following lemma appeared various forms may94 bl96 essentially says assume martingale grows almost monotonically sure winnings fast slow winnings lemma 21 slowbutsurewinnings lemma martingales let martingale martingale 0 1 1 0 computable time tn 0 computable time o2 n tn idea play strategy conservative way say start initial capital 1 deposit part c capital bank play strategy underlying remaining liquid part e capital start savings liquid capital 1 liquid capital e would reach 2 exceed level deposit additional 1 2 savings account c keep liquid capital range 1 2 times succeeds push liquid capital infinitely often 2 c grows infinity 0 succeeds since never take money savings account c liquid capital e bounded 2 total capital reached certain level never go 2 level anymore matter bad strategy underlying hand since add 2 c step 0 w cannot exceed 2jwj give formal proof proof lemma 21 define checking time space complexity bounds 0 straightforward show induction jwj follows 0 martingale succeeds ew always remain positive w v dwb infinitely often consequently lim wvjwj1 1 1 0 moreover 4 fact c decrease along sequence since c increase 2 every step cw 2jwj together 4 yields one also show 1 0 1 lemma 21 success set actually remains intact transformation lebesgue measure property resourcebounded measure zero monotone closed union finite unions property resourcebounded version closure countable unions also holds property becomes crucial resourcebounded measure whole space delta measure zero lutz calls measure conservation property slight abuse meaning 6 property written delta delta 6 0 particular delta require substantially fewer resources deltameasure zero example p emeasure zero indeed fixed c 0 dtime2 cn emeasure zero dtime2 n c expmeasure zero lut92 apart formalizing rareness abundance complexity theory resourcebounded martingales also used define concept random set resourcebounded setting definition 23 set deltarandom delta fag 6 0 words deltarandom deltamartingale succeeds betting games capture intuitions expressed lutz measure also many earlier papers random sequences formalize betting game infinite process rather turing machine finite computations string inputs definition 31 betting game g oracle turing machine maintains capital tape bet tape addition standard query tape worktapes works stages beginning stage capital tape holds nonnegative rational number c igamma1 initially c computes query string x bet bet amount b g computation legal long x belong set f x strings queried earlier stages g ends stage entering special query state given oracle language x 2 b 1 x 2 b new capital given c c query bet tapes blanked g proceeds stage 1 since require g spend time write bet full matter whether suppose new capital computed g updated instantly oracle paper lose generality allowing g crash loop without writing next bet query note every oracle set determines unique infinite computation g denote g includes unique infinite sequence x 1 query strings unique sequence telling gambler fares definition 32 betting machine g runs time tn oracles every query length made g made first tn steps computation similar definition made space usage taking account standard issues whether query tape counts space bound whether query preserved readonly mode computation machine definition 33 betting game g succeeds language written 2 1 g sequence values c computation g unbounded 2 1 g also say g covers main motivating example one may wish bet lexicographic order according fixed ordering strings deferred section 6 construct ebetting game succeeds class p autoreducible languages known lutz measure zero e exp want argue liberal requirement covered time tn betting game still defines smallness concept subclasses dtimetn intuitive sense lutz established measurezero notion following result good beginning theorem 31 every timetn betting game g construct language dtimetn covered g proof let q nonoracle turing machine runs follows input x machine simulates tjxj steps single computation g empty input whenever g bets queries string q gives answer causes g lose money rejecting case zero bet g queries x q likewise tjxj steps go without x queried q rejects x important point qs answer query 6 x answer q run input condition g cannot query string x length n tn steps elapsed ensures decision made q x queried affect anything else hence q defines language g never better initial capital c 0 succeed particular class e cannot covered ebetting game exp expbetting game put another way measure conservation axiom lut92 lutzs measure carries betting games really satisfy intuition small however hold union two small classes small moreover easy countable unions small classes small lut92 lack meeting finite union axiom later excused insofar non relativizing consequence bpp 6 exp theorem 31 still good enough measurelike results paper note also several robustness properties lutzs measure treated section 2 carry betting games apply underlying transformations capital function c g g defined follows definition 34 let g betting games 0 integer play ff length sequence imany oracle answers note ff determines first imany stages g together query bet next stage b c g ff capital c g end play ff next query note function c g martingale plays ff proof lemma 21 works c g obtain lemma 32 slowbutsure winnings lemma betting games let g betting game runs time tn construct betting game g 0 running time otn 1 g makes queries order g 2 proof proof lemma 21 carries additional observation c g 0 constructed fly allows g 0 run time otn begin comparing betting games martingales note first latter considered direct special case betting games say betting game g lexlimited oracles sequence x 1 queries made g lex order need equal lex enumeration theorem 33 let n collection time bounds closed multiplication 2 n 2 2 n o1 class c timet n measure zero iff c covered timet n lexlimited betting game proof martingale betting game g stage g bets amount b first bits characteristic sequence takes o2 n evaluations run g queries length n hence hypothesis time bounds n direction g lexlimited one simulate g finite initial segment w oracle stage queries answered w g make queries domain w one define dw capital entering stage martingale fulfills success runtime requirements left reader hence particular measure e exp martingales equivalent betting games constrained bet lex order see transform general betting game equivalent martingale 4 betting games martingales section associates every betting game g martingale dg 1 g 1 g begins examining complexity dg defining dg however pause discuss subtleties betting games computations given finite initial segment w oracle language one define partial computation g w betting game stage first makes query x domain w define dw capital c igamma1 g entering stage tempting think martingale succeeds g succeedsbut neither statement true general important reason may fail martingale see suppose x lexicographically least string domain w x indexed bit b wb w1 v iff x 2 possible g makes small even zero bet x goes back make bets domain w winning lots money definitions dw0 dw1 reflect added winnings values greater dw example suppose g first puts zero bet x bets money x proceeds x put another way finite initial segment w may carry much winnings potential definition dw reflects capture potential one needs consider potential plays betting game outside domain w happily one bound length considered plays via running time function g let n maximum length string indexed jwjc tn steps g cannot query strings domain ws potential exhausted define dg w average value plays happen given query answers fixed w use following definitions notation definition 41 tn timebounded betting game g string w 2 sigma define play ff tmaximal g completes first jffj stages query bet next stage within steps b play ff gconsistent w written ff g w stages j queried string x j domain w ff ff play could possibly happen given information w also let mff w stand number stages j whose query answered w c finally put dg ff tngammamaximalff gw weight 2 mffwgammajffj equation 7 following meaning suppose extend simulation g w flipping coin every query outside domain w exactly stages number coinflips resulting play ff length probability thus dg w returns suitablyweighted average tnstep computations g w fixed interested reader may verify averaging dwv v length 2 tn fixed longer length nonmartingale defined beginning section lemma 41 function dg w martingale proof first argue observe ff none queries answered fi domain w else definition g running time tn would violated likewise ff g w mff finally since c g martingale facts combine show equality 7 8 argument righthand side 8 unchanged replacing tn consider w jwj 1 power 2 n w0 w1 n dg w let p 0 stand set ff length tn gconsistent w0 w1 p 1 gconsistent w1 w0 p consistent set f ff equals disjoint union p p 1 furthermore ff 2 p 0 mff dg w0d g c g ff2 mffw1gammatn c g ff2 mffwgammatn c g ff2 mffwgammatn finally jwj power 2 dg w0 dg w1 use 0 length ff however first part proof replace tn 0 definition dg w without changing value second part goes way 0 hence dg martingale still case however dg may succeed languages betting game g succeeds ensure first use lemma 32 place betting games g suitable normal form satisfying surewinnings condition 5 lemma 42 g betting game satisfying surewinnings condition 5 1 g proof first let 2 1 g fix k 0 find finite initial segment w v long enough answer every query made play ff g c g ff long enough make tn definition dg w equation 7 greater jffj every ff 0 length tn form ff fffi surewinnings condition 5 implies righthand side defining dg w average terms size least k hence dg w k letting k grow infinity gives 2 1 g turn attention complexity dg g timetn betting game clear dg computed deterministically otn space need cycle ff length tn items 7 computable space otn particular every ebetting game simulated espacemartingale every expbetting game expspacemartingale however show next section one estimate dg w well without cycle ff using pseudorandom generator sample small fraction 5 sampling results first determine accuracy need estimate values dw hardtocompute martingale state stronger version result need section use strenghtening sections 62 63 recall lemma 51 let martingale active j f 0 1 g let ffli 1 i0 nonnegative sequence converges number k suppose compute time tn function gw jgw gamma dwj ffln w length n martingale 0 computable time o2 n tn section apply lemma 51 section 63 apply lemma 51 cases j finite proof first note w case inductively define note 0 satisfies average law 1 compute 0 w time o2 n tn induction jwj show using estimate 9 follows establishes lemma case generalization subsets j left reader next specify precisely function f g sample order estimate dg let g tn timebounded betting game consider prefix w let n denote largest length string domain w string ae length tn associate unique play game g defined using w answer queries domain w successive bits ae answer queries outside stop play tn stepsso stopped play tnmaximal ffand define f g w ae capital c g ff note compute f g w ae linear time ie time ojwj tn proportion strings ae length tn map play ff exactly weight 2 mffwgammajffj equation 7 dg w letting e stand mathematical expectation gives us apply two techniques obtain good approximation gw average ffl sampling using pseudorandom generators ffl approximate counting using alternation 51 sampling via pseudorandom generators first need relevant background pseudorandom generators definition 51 nw94 hardness ha n set length n largest integer circuit c size n inputs x uniformly distributed sigma n b pseudorandom generator prg function n maps sigma n sigma rn n function r called stretching say computable c every bit dy computable c given index bit binary c security sd n length n largest integer circuit c size rn inputs x uniformly distributed sigma rn sigma n purposes need pseudorandom generator computable e stretches seeds superpolynomially superpolynomial security infinitely many lengths use one provided following theorem theorem 52 6 exp pseudorandom generator computable e stretching log n integer k sd n n k infinitely many n proof follows directly next results babai fortnow nisan wigderson bfnw93 nisan wigderson nw94 combined padding theorem 53 bfnw93 6 exp set 2 exp integer k infinitely many n theorem 54 nw94 given set 2 exp pseudorandom generator computable exp stretching n log n sd nn also make use pseudorandom generators exponential security computable exponential time interesting property blow stretching exponentially without significantly reducing security theorem 55 ggm86 pseudorandom generator computable exp respec tively e security 2 n pseudorandom generator stretching 2 pn fixed polynomial p following general result shows prgs used approximate averages provides accuracy time bounds needed applying lemma 51 get desired martingale theorem 56 let pseudorandom generator computable time ffin stretching rn lineartime computable function constructible functions sn n following relations hold integer n 0 approximate within n gamma2 time o2 mn delta sn proof integer n 0 let partition interval gammarn rn subintervals length 1 note ji n 2 string w length predicate underlying w computed circuits size osn since sd mn 2 sn follows approximates w within additive error mn gamma1 compute time define approximation hw hw i2in since write hw i2in bound approximation error follows i2in i2in computing hw requires ji n evaluations results claimed upper bound time complexity h would like apply theorem 56 approximate 7 within n gamma2 setting however general betting game g running time tn guarantee upper bound rn tlog n jfw aej since sd exponential condition 10 would force mn omegagamma tlog n case theorem 56 yield approximation computable time 2 otlog n however assume wlog g satisfies slowwinnings condition 6 lemma 32 case upper bound holds term sn righthand side 10 dominates provided n taking everything together obtain following result transforming e exp betting games equivalent e respectively expmartingales theorem 57 pseudorandom generator computable e security 2 n every ebetting game g exists emartingale 1 g 1 pseudorandom generator computable exp security 2 nomegagamma1 every expbetting game g exists expmartingale 1 g 1 proof lemma 32 assume c g satisfies surewinnings condition 5 well slowwinnings condition 6 lemma 42 lemma 51 since series suffices approximate function dg w given 7 within n gamma2 given hypothesis e meet conditions applying theorem 56 obtain approximation dg need holds like manner exp sn 2 2 log n o1 52 approximate counting using alternation instead hypothesizing existence strong pseudorandom generators also use following theorem stockmeyer approximate counting theorem 58 sto83 h 2 p polynomial p function g 2 3 input w length n theorem 59 every ebetting game g exists emartingale 1 g 1 b np dtime2 log n o1 every expbetting game g exists exp martingale 1 g 1 proof plugs 12 sampling results similar manner 6 autoreducible sets oracle turing machine said autoreduce language lm strings input x query x one learn membership x querying strings x runs polynomial time pautoreduciblewe also write autoreducible also nonadaptive p autoreducible one always code oracles never queries inputthen call autoreduction hence define effective enumeration polynomialtime autoreductions language autoreducible iff exists lm technical aside may autoreduce different languages may autoreduce languages goes p autoreductions autoreducible sets brought polynomialtime context ambosspies as84 importance argued buhrman fortnow van melkebeek torenvliet bfvmt98 showed p complete sets exp p autoreducible complete sets classes demonstrate autoreducible sets important testing power resourcebounded measure 61 adaptively autoreducible sets stated introduction p autoreducible sets exp sufficiently p sets exp covered expmartingale exp 6 bpp nonrelativizing consequence however easy cover ebetting game indeed betting game uses adaptive freedom look ahead membership lexicographically greater strings betting nothing theorem 61 ebetting game g succeeds p autoreducible sets proof let enumeration p autoreductions runs time inputs length n betting game g regards capital composed infinitely many shares c one initially c letting hdelta deltai standard pairing function inductively define n stage makes query length less n looks answer table past queries whenever makes query length n sgamma1 g places bet zero string makes query g bets share c 0 n sgamma1 according answer simulation finally g cleans putting zero bets strings length n queries previous steps autoreduces share c doubles value stage hi ji makes total capital grow infinity g runs time 2 indeed cleanup phase needs much time corollary 62 following statements implies bpp 6 exp 1 class p autoreducible sets emeasure zero 2 class p complete sets exp emeasure zero 3 ebetting games emartingales equivalent 4 ebetting games finite union property holds replace e exp statements proof let c stand class languages p hard bpp allender strauss as94 showed c emeasure zero trivially also covered ebetting game let stand class p complete sets exp theorem 61 result bfvmt98 cited covered ebetting game contains exp ffl would emeasure zero would c hence exp contradicting measure conservation property lutz measure ffl ebetting games would finiteunion property c exp would covered ebetting game contradicting theorem 31 since 1 implies 2 3 implies 4 observations suffice establish corollary e proof exp similar since oracle giving exp bpp hel86 shows relativizable techniques cannot establish equivalence emartingales ebetting games expmartingales expbetting games cannot refute either since oracles relative strong prgs existall random oracles fact 62 nonadaptively autoreducible sets tempting think nonadaptively pautoreducible sets emeasure zero least expmeasure zero insofar betting games adaptive cousins martingales however adaptiveness also freedom bet fixed lexicographic order adds power betting games one carries proof theorem 61 cover class autoreducible sets using enumeration p autoreductions one obtains nonadaptive ebetting game defined formally independent oracle bets strings order given single permutation sigma permutation ecomputable might seem emartingale able untwist permutation succeed sets however next results strengthen corollary close nonrelativizing door proving current techniques theorem 63 k 1 p tt complete sets delta p p autoreducible proof idea follows techniques bfvmt98 theorem exp complete sets p autoreducible call closed propositional formula k blocks like quantifiers ie k gamma 1 quantifier alternations qbf k formula let tqbf k stand set true qbf formulas let p tt complete set delta p k since tqbf k sigma p k hard deterministic polynomialtime oracle turing machine accepts oracle tqbf k let qx stand ith oracle query made input x whether belongs tqbf k forms delta p question p reduce possible latter reduction include x among queries let b denote answer gives question provided query x answered yes similarly define case x answered holds particular x queried know correct answer b ith query situation occurs queries done run input x using b answers oracle queries b obtained without submitting possibly adaptive queries made rather applying latter tt reduction pair hx ii without submitting query x hence process satisfies requirements p tt autoreduction particular input x suppose b let minimal two opponents play kround game underlying qbf k formula constitutes ith oracle query one player claims b correct value b equivalent claiming x 2 claims b gamma correct write players strategies consist computing game history far determining optimal next move p tt reducing computation finally producing result reduction respective assumption x approach allow us recover game history polynomial time nonadaptive queries different x moreover guarantee opponent making correct assumption x plays optimally since opponent also one claiming correct value b win game output winners value b remains show compute strategies deterministic polynomial time sigma p oracle ie fp sigma p k seems crucial number k alternations constant proof theorem 63 let p tt complete set delta p accepted polynomialtime oracle turing machine oracle tqbf k let qx denote ith oracle query tqbf k input x qx written form 9y 1 8y stand vectors variables quantified block opposite form beginning block 8y 1 reasonable abuse notation also ley r stand string 01 assignments variables rth block without loss generality may suppose every oracle query made form j string length jxj c makes exactly jxj c queries taking constant c polynomial time bound note function q belongs fp sigma p k hence language belongs delta p k1 since p k1 polynomialtime nonadaptive oracle accepts l 0 oracle define b define languages reductions inductively follows k set l consists pairs hx ji 1 j jxj c smallest x following condition holds let sth bit r equal r hx si otherwise put hx ji l iff lexicographically least jth bit set 1 form definition shows l belongs delta p hence take n polynomialtime nonadaptive oracle tm accepts l oracle construct p autoreduction input x compute b well b r b 2 f0 1g 1 r jxj c latter quantity b r defined follows 1 jxj c sth bit b r equals n afxg r hx si r j b mod 2 n anfxg r hx si otherwise note compute values polynomial time making nonadaptive queries none equals x run input x using b answer ith oracle query since always holds least one b correct oracle answer b x faithfully simulate input x hence compute x correctly otherwise let first index b determine qx simulating input x asks ith query k claim value equals x order prove claim consider game history b k opponent claiming correct value b x gets play rounds allow win game provided plays well matter player since former opponent also one making correct assumption x inductive argument shows plays optimally stages string construction l exists plays key induction later stages 0 value r value stage player correct assumption x wins gamethat guess b x players guess order formalize strengthening corollary 62 results theorem 63 call betting game g nonadaptive infinite sequence x 1 queries g makes oracles g runs 2 time sequence hits strings sigma permutation standard ordering defined computable invertible 2 time computable amount time order hit strings g must bet strings f 0 1 g n within first 2 steps hence ith bet must made number steps singlyexponential length compute need run 2 ojx j steps since cannot query x time since inverse ecomputable reasonable candidate replace lexicographic ordering definition emartingales likewise expmartingales say class c emeasure zero c covered emartingale interprets input characteristic string order given theorem 64 class p autoreducible languages covered nonadaptive ebetting game hence ecomputable invertible permutation sigma class emeasure zero proof reference proof theorem 61 let enumeration tt autoreductions runs time n machine g proof automatically becomes nonadaptive since queries strings defines permutation sigma required properties corollary 65 following statements implies bpp 6 exp statements obtained replacing e exp 1 class p tt autoreducible sets emeasure zero 2 class p tt complete sets exp emeasure zero 3 nonadaptive ebetting games emartingales equivalent 4 two classes covered nonadaptive ebetting games union covered ebetting game 5 classes c ecomputable invertible orderings c emeasure zero c emeasure zero proof suffices make following two observations argue proof corollary 62 carries truthtable cases ffl construction allender strauss as94 actually shows class sets p tt hard bpp emeasure zero ffl theorem 63 implies p tt complete sets exp p bpp sigma p theorem 64 finiteunions property lutzs measures e exp rest last point corollary 65 asserts lutzs definition measure e invariant ecomputable invertible permutations permutations include flip introduction crucially theorem 64 hence robustness assertion lutzs measure implies bpp 6 exp bettinggame measure adaptive nonadaptive enjoy permutation invariance asserting finiteunions property also implies bpp 6 exp rest paper explores conditions lutzs martingales cover classes autoreducible sets thus attempting narrow gap betting games 63 covering autoreducible sets martingales puts spotlight question hypotheses show p autoreducible sets emeasure zero hypothesis must strong enough imply exp 6 bpp hope find hypotheses weaker assuming equivalence e betting games martingales assuming finiteunion property betting games need strong prgs cover p autoreducible sets close come covering p autoreducible sets emartingale final results show hypothesis 6 exp suffices assumption known yield prgs superpolynomial security infinitely many lengths rather exponential security almost lengths recall contains bpp np fact sandwiched np bpp bpp np theorem 66 6 exp class p tt autoreducible sets emeasure zero actually obtain stronger conclusion theorem 67 6 exp class languages autoreducible polynomialtime otms always make queries lexicographic order emeasure zero better convey essential sampling idea prove weaker theorem 66 stronger theorem 67 extra wrinkle latter theorem use prg twice construct set critical strings bet well compute martingale proof theorem 66 let enumerate p autoreductions running time n divide initial capital shares im im valued initially 1m 2 12 share im describe martingale active finite number strings x namely m2dlog 2 x belongs set constructed arrange whenever autoreduces infinitely many share im attains value 1 fact close along hence martingale defined shares succeeds also ensure active shares bets strings length n computable time 2 constant independent enough make whole martingale ecomputable complete proof describe betting strategy im first construct set im starting iterating follows let lexicographically least string length appear among queries made inputs x 2 add 3dlog 2 strings possible bound 3dlog 2 mem number queries could possibly make inputs less 2 moreover 2 bounds time needed construct thus arranged x 2 x x query 13 let j stand together queries makes inputs adapting ideas definition 41 context let us define finite boolean function consistent written fi x 2 run input x oracle answers given agrees value fix given characteristic prefix w also write fi w fix wx agree x j domain w since j depend obtain probability density function share im via martingale im standardly associated density lut92 definable inductively im im case im 0 already im w 0 im w1 im w0 set 0 note values im wb differ im w string x indexed b belongs j ie im active j sufficiently large share im could play strategy im value would rise least m2 im would multiply initial value least 3 see first note w v long enough contain j domain im want show v short enough domain disjoint im consider fixed 01 assignment fi 0 strings j n agrees v assignment determines computation lexicographically first string x 2 using fi 0 answer queries hence forces value fix order maintain consistency turn forces value fix 0 next string x 0 hence one 2 jij possible completions fi 0 fi consistent thus im 15 2 main obstacle 14 hence im w may computable time 2 independent number assignments fi count order 2 jjj use ecomputable prg superpolynomial stretching security obtained via theorem 52 hypothesis 6 exp sufficiently large stretches seed length least 3dlog 2 mem bits enough define assignment fi j agreeing given w estimate im w theorem 52 infinitely many good sd i4 69 large enough good every estimate suppose first note 14 16 depend w upto bits w index strings j hardwired circuits tests fi also done circuits size om i1 turing machine computation time r simulated circuits size log r pf79 hence get circuits size less sd achieving discrepancy greater 1sd contradiction proves claim 69 finally observe proof claim 68 gives us im w im w delta 3 also im w v good thus obtain estimates gw im w within error bounds applying lemma 51 gw yields martingale 0 im w computable time 2 constant independent 0 im w martingale computed actions share im since actually obtain jd 0 stronger needed conclude share im returns enough profit completes proof theorem 66 prove theorem 67 need construct sets im properties similar 13 case longer p autoreduction makes queries lexicographic order carry construction use pseudorandom generator second time actually need input 0 makes queries length making query length play modified strategy share im however appears require queries observe lex order proof theorem 67 recall hypothesis exp 6 yields prg computable stretching bits rm bits sufficiently large give rm infinitely many give hardness sd standard enumeration autoreductions constrained make queries lexicographic order running time need define strategies shares im whenever autoreduces infinitely many share im grows initial capital 1m 2 2 12 strategy im must still computable time 2 independent compute strategy im note first im left inactive strings length overall running time allowance 2 om permits us suppose time im becomes active needs considered initial segment w 0 language share happens playing indexes strings length hence may regard w 0 fixed ff 2 f 0 1 let ff stand computation w 0 used answer queries length ff used answer queries order makes queries queries answered w 0 ff answers coded string u 0 length string length equal define note given u 0 ff test ff queries computed circuits size om i1 hence using prg length compute uniformly e approximation pd x p x infinitely many said good pairs x give jp x algorithm constructing im start jij 3 log 2 following take lexicographically least string x 2 search succeed within jij delta i4 trials since particular x fewer i4 strings overall fail test even good involves pd pd involves simulating ds seeds enough room find provided holds sufficiently large whole construction completed within time 2 2am follows sufficiently large good x 2 x pr ff ff point would like define j together set strings queried inputs unlike previous case nonadaptive valid definition acknowledge dependence strings queried oracle defining ja queries g ja size j previous proof latter definition ok makes queries lexicographic order hence share im already computed without reference determine strings ja active fly lex order thus welldefine mapping fi f 0 1 g r f 0 1 g k r means query string happens kth order onthefly construction ja answered yes oracle may write j fi ja write place important given x 2 every fi welldefines computation fi x entitles us carry two consistency definitions proof theorem 66 finally may apply latter notion initial subsets define 1 3 log predicate query x k 610 pr fi r fi 12 base case query x 1 autoreduction whether fi x1 depends bit fi corresponding x 1 working induction suppose pr fi r r gamma1 fi holds taking fi 0 fi bit corresponding x flipped r holds however one r fi query x hence pr fi r fi 12pr fi r proves claim 610 possible neither r fi r fi 0 holds happens j hurt claim rejoin proof theorem 66 equation 14 defining probability density function im get martingale im im represents ideal strategy share im play statement corresponding claim 68 autoreduces good sufficiently large ideal strategy share im multiplies value least 3 2 along see note constructed pr ff ff follows d3 log 2 hence using claim 610 log get since fi defined satisfies fi follows reasoning claim 68 im profits least fraction 3 2 along proves claim 611 finally reuse prg expand seed length string fi least bits given w fi welldefines fi set j fi size r constructed using w answer queries domain w fi everything else obtain estimate equation 16 time complexity repeat claim 69 new context 612 large enough good every estimate im w satisfies j im w gamma im wj ffl fixed w estimate fails final key point always makes queries lexicographic order queries domain w need covered every fi hence corresponding bits w hardwired circuitry size r test fi thus still carried circuits size less i1 reach contradiction hardness value sd finally want apply lemma 51 replace im w martingale 0 im w yields virtually degree success computable time 2 unlike truthtable case cannot apply lemma 51 verbatim longer single small set j 0 active however along set values 0 im w 0 1 differ cases b indexes string small set j corresponding reader may check argument bounds lemma 51 go unscathed case finishes proof theorem 67 conclusions initial impetus work simple question measure pseudorandomness characteristic sequence invariant simple permutations induced flip introduction question flip tantalizingly still open however section 62 showed establishing yes answer permutation intuitively preserve complexitytheoretic degree pseudorandomness even single specific permutation simple proof nonadaptive version theorem 61 would major consequence exp 6 bpp betting games natural extension lutzs measures deterministic time classes preserve lutzs original idea betting means predicting membership language without tied fixed order instances one tries predict fixed order one goes gathering information language shown senses betting games robust wellbehaved also contend current defects theory betting games notably lack finiteunions theorem pending status pseudorandom generators trade lacks resourcebounded measure theory tied lexicographic ordering strings main open problems paper interesting connection recent work impagliazzo wigderson iw98 bpp vs exp problem first remark main result iw98 implies either bpp emeasure zero vm98 among many measure statements last section imply bpp 6 exp constrained easiest attack seems item 4 corollary 65 indeed specific relevant case starting assumption one given nonadaptive ebetting game g emartingale obtain desired contradiction proves bpp 6 exp one need construct expbetting game g 0 covers obtain randomized betting game g 00 flips one coin successive intervals input lengths decide whether simulate g interval intervals come proof theorem 64 hypothesis derandomize g 00 implies bpp 6 exp know whether hypotheses considered iw98 shown follow bpp 6 exp sufficient stepping back trying prove bpp 6 exp outright trying prove measure statements equivalent bpp 6 exp also problem narrowing gap bpp 6 exp sufficient condition exp 6 used results moreover exp 6 suffice make p autoreducible sets emeasure zero suffice simulate every betting game martingale equivalent complexity also inquire whether exist oracles relative strong prgs still exist work seems open many opportunities tighten connections among prgs structure classes within exp resourcebounded measure kind statistical sampling used obtain martingales theorems 56 57 originally applied construct martingales natural proofs rsc95 derandomization technique bfnw93 based exp 6 used also applied bvm98 kl98 lsw98 probabilistic martingales use sampling simulate betting games formalized studied rs98 paper also starts task determining well bettinggame randomsampling ideas work measures classes e even straightforward attempts carry lutzs definitions classes e run difficulties described may94 as94 as95 look toward applications ideas lowerlevel complexity classes acknowledgments authors specially thank klaus ambosspies ron book pace jack lutz organizing special schloss dagstuhl workshop july 1996 preliminary versions results ideas paper presented extensively discussed also thank referees helpful comments r measure small complexity classes measure p robustness notion algorithmic information theory randomness trading group theory randomness bpp subexponential time simulations unless exptime publishable proofs using autoreducibility separate complexity classes separating complexity classes using autoreducibility 13th annual symposium theoretical aspects computer science hard sets hard find construct random functions relativized exponential probabilistic complexity classes randomness vs time derandomization uniform assumption variant kolmogorov concept complexity resource bounded measure learn ability almost everywhere high nonuniform complexity quantitative structure exponential time contributions study resourcebounded measure hardness versus randomness relations among complexity measures probabilistic martingales bptime classes pseudorandom generators complexity approximate counting measure bpp tr ctr klaus ambosspies wolfgang merkle jan reimann sebastiaan terwijn almost complete sets theoretical computer science v306 n13 p177194 5 september
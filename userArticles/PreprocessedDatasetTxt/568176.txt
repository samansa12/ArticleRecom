searchbased binding time analysis using typedirected pruning introduce new way performing binding time analysis rather analyzing program using constraint solving abstract interpretation use method based search search guided type information significantly prunes size search space making algorithm practical claim compute new better information compute new novel way clarifies process involvedthe method based upon novel use higherorder multistage types rich expressive medium expression bindingtime specifications types could used starting point bta goal work demonstrate single unified system seamlessly integrates manual staging automatic btabased staging possible b introduction binding time analysis bta thought automatic addition staging annotations welltyped semantically meaningful term base language permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee asiapepm02 september 1214 2002 aizu japan programmer supplies two things 1 welltyped base language program 2 binding time specification set instructions parts program static parts dynamic analysis produces new program old program plus staging annotations successful new program called well annotated erasure staging annotations new program produces original base language program introduce new kind bta works searching space annotated terms produced adding one staging annotations welltyped base term added staging annotations must consistent original type program user supplied bindingtime specification search space explored lazily adding staging annotations maintain consistency path discovered could longer produce wellannotated term path immediately pruned search produce one wellannotated term directing search algorithm adjusted produce better wellannotated terms first 2 motivation work motivated work metaml metaprogramming system meta programming sys tem metaprograms manipulate objectprograms metaprograms may construct objectprograms combine object program fragments larger objectprograms observe structure properties objectprograms designed useful medium expression runtime code generators found many uses well metaml conservative extension core ml includes features standard ml except module system adds four kinds staging annotations con structing manipulating executing code first class object discuss three staging annotations partition program stages brackets surrounding expression lift surrounded expression next stage escape appear within brackets drops surrounded expression previous stage lift lift evaluates argument ground value first order value like 5 constructs program next stage constant value two stage world bracketed code dy namic unbracketed code static apriori restriction two stages common use metaml staging programs interpretive overhead improve runtime per formance reason partial evaluators often employed useful consider accomplished metaml earlier work22 identified 7 step process greatly abbreviate example use traditional one staging power function used process many programs orders magnitude larger first write unstaged program n0 1 else x power n1 x second identify source interpretive overhead power example looping variable representing exponent n third consider type unstaged function int int int consider extension type obtained adding code type constructor one places makes source interpretive overhead static parameters dynamic may several types example two dierent extensions powers type int int int int fourth choose one extension types place staging annotations bracket escape lift original program produce wellannotated program example staged version power type int function pow1 n0 1 else x pow1 n1 x choice extended type use guide annotation often depends context generator used sometimes obvious times subtleties beyond scope short introduc tion relevant since even automatic based system user must supply staging specification staged version used produce computation without interpretive overhead examples pow1 used several contexts generate code fragments right evaluatesto arrow fn z pow1 4 fn z z z z z 1 3 unified vision winter 2002 one authors taught course staged computation pattern emerged typical assignment consisted unstaged function type target extended type instructions write staged version unstaged function target type discussion arose class possibility automatically producing staged versions functions could mixed manually staged functions single system caused class instruc tor consider process followed staged function answer obvious used type information contained type original program target type guide placement staging annotations argued20 21 23 manual annotation gives programmer finer control automatic process ever achieve must admit many times automatic annotation would suce place less burden programmer couldnt tightly integrated system supported manual annotation practiced metaml automatic bta built view key obstacle system reconciling binding time specifications given bta rich type structure possible mix code types data structures higher order functions many btas driven binding time specifications simple directives indicating certain global variables andor parameters simply static dynamic newer ones extended partially static first order data metaml code types completely first class metaml possible data structures embed functions manipulate code kind partially static higher order functions ie metafunctions take metafunctions arguments missing bindingtime specifications key insight use metamls rich types binding time specifications key insight understood several smaller hurdles easily resolved btas described part partial evaluation system systems almost always based upon source source transformations work sourcefile level produce new sourcefiles compiled existing compilers hard reconcile metamls view staging annotations first class semantic objects part language definition viewing metaml types staging specifications easy next step view directions compiler produce new program whose meaning given terms metamls semanticly meaningful staging annotations output bta opaque users consists generating extension applied static arguments produces residual program annotations generating extension partial evaluation paradigm encourage users look understand generating ex tension users idea look like used metaml users already know staged programs look like write manually annotate programs conceptual barrier lower idea using higherorder partially static types func tion arrows code types directive guides automatic bta otherwise manually staged system provides fine level control previously miss ing yet still enables automatic staging desired elaborate vision integrated system encompassing manual automatic bta simple extension metaml produces annotated term suggested staged type metaml add new declaration form stage user wishes indicate desires annotated version f function f annotated extension type writes stage f compilers job produce function automatically cause compiletime error cant declaring following stage power int causes compiler generate compile new function pow1 n0 1 else x pow1 n1 x output produced hand similarly declaration stage power int int int causes compiler generate compile function pow2 n0 1 else x pow2 n1 x scheme quite flexible used stage functions partially static data partially static higher order types stage functions two stages partially static data consider list list map f stage b list b list leading automatic introduction map2 f higher order partially static types consider stage ba list b list leading automatic introduction map3 f staging programs two stages consider inner product function staged run three stages8 14 first stage knowing size two vectors oers opportunity specialize inner product function size removing looping overhead body function second stage knowing first vector oers opportunity specialization based values vector inner product vector taken many times vectors specialized removing overhead looking elements first vector time third stage knowing second vector computation brought completion nth v nnth w else 0 stage iprod int operator greaterthan operator metaml uses operator normal greater operator conflicts metamls use symbol staging annotation stage declaration would cause compiler automatically produce three stage annotated version lift nth v n nth w n else 0 4 framework section describe minimal language use describe bta examples previous section expressed metaml language considerably richer minimal language describe next properties show hold minimal language also hold metaml base terms structure base terms defined inductive set productions productions define set syntactically correct terms example variant lambda calculus integer constants could defined annotated terms staging annotations added set productions define set syntactically correct annotated terms example add productions bracket e lift erasure process removing annotations annotated term produce base term base types set base types base terms also inductively defined actual form types depends upon constructs concepts inherent base language lambda calculus variant types base terms defined introducing types constants like constructors like list function types list annotated types also extend set base types adding code type constructor produce set annotated types note brackets overloaded work annotated terms annotated types environments assume language full complement primitive functions operate base types etc built data structures head tail n et br es figure 1 judgments welltyped base terms extension wellannotated terms cons nil null etc environments map global constants lambdabound variables types welltyped terms type judgments select subset syntactically well formed terms semantically meaningful call terms welltyped top half figure 1 gives set judgments base terms form judgment n read environment term e assigned type stage n n natural number terms level terms without staging annotations general term level n surrounded n sets matching brackets base terms stage information safely ignored indeed erasing stage information top half figure 1 reduces familiar type judgments lambda calculus wellannotated terms adding type judgments staging annotations judgments base terms defines new judgment selects subset syntactically correct annotated terms called wellannotated terms bottom half figure 1 extends top half judgments annotations bracket escape lift stage information n judgment counts number brackets surrounding current term count ensures escapes appear within brackets variables used stages later binding stage annotated extensions two inputs process welltyped base term e base type t1 target annotated type t2 type t2 annotated extension type t1 type annotated term wish bta find relation base types annotated extensions related relation relation pbasetype annotatedtype intuitively means obtained removing staging annotations made precise following inductive rules use notation b basetype annotatedtype remind reader two arguments relation come dierent sets b b list list relation simply formalizes notion erasure types describe precise manner one type erasure another erase t2 t1 t2 note erase acts homomorphically type constructors except code bracket type constructor adding annotations program e type t1 cannot produce another program arbitrary type t2 types t1 t2 must related fashion made precise given two partial functions 1 2 representing envi ronments 1 maps term variables basetypes 2 maps term variables annotatedtypes domain lift relation pointwise environ ments 1 2 x dom1 21 x 2 x overloading terms overload relation pterms annotatedterms terms well types two meanings similar shouldnt problem conceptually b1 b2 b3 b b b use b baseterm annotatedterm lifted relation simply formalizes notion erasure terms e1 erasure e2 e1 e2 5 staging checking system given term e type target type extension wish find annotated term e need adjustments notation capture precisely first extension terms may seem syntactically rigid example terms equivalent related bound variable problem since intend generate annotated terms righthandside relation always use name bound variable second ordering terms quite satisfactory possible relate annotated terms well annotated welltyped base terms since care relating welltyped terms wellannotated terms well define new relation captures distinction overloading combine typing judgments type term relations one 1 1 given e1 t1 e2 t2 infer e2 could well annotated type t2 related e1 term overloading formalize writing new set judgments appear figure 2 lam app code escape figure 2 relating welltyped terms well annotated terms judgments derived straightforward manner figure 1 relation types terms 6 checking inference move type checking system checks two terms related staging annotation algorithm computes staged program unstaged program judgments figure 2 describe several rules checking relationships e1 e2 t1 t2 four known e2 unknown use rules guide search slight restructuring rules helps illustrate let notation e2 denote search well annotated term e2 whose erasure e1 let t1 type e1 t2 target type soughtafter term e2 current state well discuss states moment rules proceed searching annotations subterms e1 combined form e2 occasionally search annotation subterm fully intending wrap new set brackets around result get call number pending brackets level search part state search let n level search checking rule like leads naturally search rule like e4 e5 e6 note environment checking rule changes environment search rule checking rules map term variables types search algorithm map term variables annotated terms inference algorithm compute annotated term every unannotated counterpart term maps unannotated term variables wellannotated terms checking rules dont tell us order apply search rules rule fails point need make choice implementation mechanism use implement search prolog comes immediately mind would probably made good choice investigation suggested several annoying details choose functional language haskell ease could modify program even drastic changes considered search become clear follows except rules code escape lift rules syntax directed structure e1 rules driven syntactic structure t2 n use structure decide rules applicable unfortunately point one rule usually applicable must also careful rules code esc circular could lead derivations infinite height hence search infinite depth algorithm control parameters way key algorithm controlling two important aspects search partial may fail search nondeterministic may one annotated term given type eective way controlling search attempt escape rule first followed syntax directed rules structure e1 next apply lift code rules rules fail eective strategy discussed section 13 control circularity code escape embed algorithm small state machine three states clear abs app abs app abs app code escape escape code clear algorithm starts state clear use rule code moves state escape allowed use escape moves state code al lowed applying rule recurses sub term current term moves machine back state clear example integer constant searching term type state term suce terms substructure need search notations particular type given terms subterms example z z clear app code find annotated version f f given type annotated version x x find annotated version application f x search subterm fails search whole term fails search subterm produces one result search whole term may produce one result term two subterms b search produces n results search b produces results search whole term produce n results fortunately wellstudied formalism describing algorithms notion monadic com putation several papers give good overviews monadic computation 24 25 26 assume familiarity monadic programs case monad nondeterminism monad times called list monad data structure based monad multipleresults consider search rule specified subsearches perform first specify one fails succeed specify combination two sets results job monad express search implicit rule explicitly equation uses monadic notation z x return f x perform search annotation subterm x first succeeds search annotation f next succeeds combine results searches wise building newly annotated term f x using checking rules figure 2 build search rules use notation control search ele ments rule leads small search component complete search constructed using notation con trol sequence combine component searches complete algorithm found appendix written working haskell program program uses following definitions types terms data code list data el string e ev string x ei int 5 checking rule figure 2 derive one search components written haskell functions component type type monad multiple results rules lead single component consider rule app goal searching e1 e 1 t1 t2 known e2 e know e1 e 1 welltyped type t1 thus possible compute type e1 s1 t1 possible compute domain e2 labeled s2 rule know s1 s2 search rule based checking rule choose s2 correctly related s1 simple choices leads two dierent search rules program additional rules possible generic treatment discussed section 14 give taste component constructed discuss two rules two ways stage expression would stage whole term f type assume f type first way captured following component appcase1 component trace app1 n e t2 let dom sig e0 compute domain type e0 return ea e2 e3 note state search subterms reset clear component follows structure typing judgment relation one directed rules applied nonapplication default clause appcase1 component fail second component account code property argument appcase2 n sig phi t1t2e ea e0 trace app2 n e t2 let dom sig e0 compute domain type e0 arr code s1 t2 e0 return ea e2 e3 appcase2 main algorithm composed search strategy applied individual search components next section comment control mechanisms used direct strategy main algorithm 7 control search notation used control order search action failure propagate failure arises means single failure anywhere causes whole algorithm fail needed mechanism set several searches combine successful results one large set results monad multiple results supports several operations facilitate leftchoice leftchoice leftchoice xs first first first donen first first first xs many many many many operation leftchoice takes two computations producing multiple results first succeeds returns result ignores second first fails runs returns results second computation operation first iterates leftchoice list computations returns results first successful computation list operation many runs computations list returns concatenation results operation used specify branching search 8 main algorithm main algorithm called regroups syntax directed arguments tuple calls a2 algorithm a2 defined large search whose search strategy constructed using first many component searches strategy one possible strategy strategies possible discuss strategies section 13 function a1 takes input level n environments mapping term variables types sig term variables annotated terms phi two types t1 t2 term e1 produces multiple results hence return type e meant correspond roughly notation a2 step n sig phi first esccase step n sig phi x note esc case first intcase step n sig phi x varcase step n sig phi x abscase step n sig phi x appcase1 step n sig phi x appcase2 step n sig phi x appcase3 step n sig phi x ifcase step n sig phi x liftcase step n sig phi x codecase step n sig phi x 9 example trace section show trace search stage term fxf x type abs 0 fn f fn x f x int int int abs 0 fn x failed app1 failed failed app2 failed failed app1 failed failed app2 failed failed succeeded f esc succeeded f esc failed var succeeded x succeeded lift x esc succeeded lift x app1 succeeded f lift x code succeeded f lift x abs succeeded fn x f lift x abs succeeded fn f fn x f lift x 10 correct construction believe soundness search algorithm respect checking rules proved although yet done every node search space considered search algorithm generated welltyped source expression checking rule search program never considers invalid term algorithm may return multiple results results may better others valid extensions base term type given section 13 discuss use strategies order returned solutions best ones first algorithm uses strategy employed appendix easy argue algorithm always terminates measure function4 easily constructed arguments state decreases wellfounded relation every recursive call a1 n may increase code rule always accompanied decrease size t2 t2 brackets stripped must decrease size e1 one syntax directed rules failure three state automata encoded state enforces since measure function decreases every recursive call cannot fall zero algorithm must terminate 11 polyvariance polyvariance allows single function used multiple binding types algorithm needs changes support polyvariance recall one parameters search algorithm environment mapping term variables types annotated terms allowing environment map term variable dierent types dierent annotated terms polyvariance achieved example consider function f environment function h type int int int stage int producing bta environment several stagings h could better stage int stage int stage int stagings h could work statically using h1 h2 annotated version f produced automatically compiler although definition f mentions h automatic make use declared stagings h generates staging f polyvariant uses h tight integration automatic manual staging used mutual advantage consider manually staged versions op primitive multiplication operator metaml manually staged versions exploit arithmetic identities x beyond scope automatic bta without using semantic information yet programmer easily stage manually injecting semantic information system times1 times1 times2 times2 inform automatic bta times use variant stage declaration stage stage without type sux stage declaration checks times1 times2 manually staged versions staged type made precise relation adds environment process thus manually staged versions functions use semantic information force computation earlier stages used polyvariantly 12 polymorphism techniques easily extend language hindleymilner polymorphism hindleymilner polymorphism universally quantified types appear outer level allows simple preprocessing step extend bta language hindleymilner polymor phism consider example programmer wants stage standard function type c c consider types universally quantified outermost level free type variables tick marks like staged type annotated less gen eral type map order handle staging declaration like stage int c int c first unify erasure target type c c type map b b obtain substitution b apply source type unerased target type proceeding algorithm must treat type variables unknown types hence rules actual structure type immaterial may apply right thing 13 strategies strategy used order individual components matters two dierent properties output trying achieve simultaneously minimality optimality working precise definitions properties completely worked yet informally minimality means answer produced minimum number staging annotations example f x f extensions f x f type b x type first preferred fewer staging annotations second wish arrange search strategy minimal annotations found larger ones better yet search spaces containing nonminimal ones pruned completely three state automata guides use code escape rules prevents infinite derivations also prunes nonminimal ones annotation pruned since code rule cannot applied immediately escape rule without first descending subterm informally optimality means computation performed earliest stage possible static ifs x else preferred dynamic ones x else z first allows test performed earlier stage currently search strategy uses heuristic push optimal solutions front result list try esc rule first component esccase always fails level 0 levels greater zero searches solutions lower levels ie earlier stages placing first first many strategy order stages earliest possible computations first explains component escape first function a2 analysis proof always leads optimal results remains future work 14 complexity hard estimate complexity algorithm without knowing quite bit search strategy used strategy used appendix extremely simple consists single first control operator cause search whose maximum depth proportional depth term e plus number brackets target type environment maps term variable single annotated term type algorithm always find exactly 0 1 results breadth search easy estimate depends upon term annotated type annotation sought source algorithms complexity identified two places clever implementation techniques overcome complexity first naive algorithm performs redundant computa tions redundant computations possible search space annotated programs directed acyclic graph often two paths subproblem example algorithm trace showing behavior staging largecalc e1 else e2 rule fired staging largecalc bool large calculation rule failed rule fired staging largecalc e1 else e2 bool rule fired staging largecalc bool large calculation failed failed solved standard technique dynamic pro gramming memoize away results table compute table lookup attempting subsearches make sure recalculating anything second problem caused multiple app rules men tioned section 6 type checking rule app figure leads many possible search rules app one search rule every possible solution side condition deeply applications nested deeply nested code types appear target type branching blows observing structure two search rules appcase1 appcase2 see much common clever programming merge rules single case thus drastically reducing branching hence size search space trick perform subsearches s2 instantiated type variable maintain list constraints type variables thereafter whenever algorithm calls equality check two types algorithm employs unification types failure unify becomes failure search constraints initially form type variable base type inequality constraints either strengthened stronger inequalities collapsed equalities upon unification following single app rule encompasses previous two many others unification new variable generation constraint maintenance handled underlying monadic machinery thus structure algorithm changes slightly appcase n sig phi t1 t2 eea e0 trace app n e t2 let arr s2 t2 e0 return ea e2 e3 appcase generates new type variable s2 adds constraint s1 s2 changes dynamic programming use unification implemented reworking underlying monad upon search implemented observed traversed search space notably smaller currently working quantifying precise complexity bounds algorithm employs two techniques believe importance work lies describes new simple framework describe btas advanced features higherorder functions poly morphism polyvariance partially static firstorder data higherorder partially static functions unbounded number stages believe potential tuning algorithm highly ecient one remains 15 related work mogensen 16 bondorf 2 3 consel 5 present btas higher order languages based upon abstract interpretation three papers btas typed lambda calculi closely related work presented express type inference problem nielson nielson 18 give bta based upon type inference twolevel simply typed lambdacalculus given simple binding times compiletime runtime free variables typed expression show algorithm computes unique expression optimal set annotations minimizes runtime computation complexity algorithm worst case exponential size expression gomard 11 presents 3 algorithm annotating untyped lambdacalculus term similar manner work interesting uses crude type system perform bta untyped language type system treats second stage terms single type code terms except functions type value uses arrows simple types specify bindingtimes functions henglein 12 presents ecient algorithm uses similar trick expressing bindingtime similarly simple type system algorithm complexity n n inverse ackermans function n n intents purposes small constant algorithm uses constraint solving system determine annotations placed algorithm may look like type inference prob lem really search based algorithm easy identify search space search strategy employed possibility multiple solutions also separates type inference use types bta specifications found work le meur lawall consel15 describe module based system writing binding time specifications programs c system allows programmer name multiple binding time specifications function global variable module use named specifications specifications specifications written stageannotated types module system propagate information multiple usesites annotated functions allowing dierent specializations dierent occurrences unlike use annotated types binding time specifications limited first order functions many btas based upon abstract analysis btas partially static data presented launchbury13 mogensen17 polyvariant btas presented consel 6 1 dussart et al 7 rytz gengler 19 amongst others glueck joregensen 8 9 pioneered use multilevel languages work generalizes standard abstract interpretation technique multiple levels show search based techniques also generalize multiple levels techniques described incorporate features simple framework based upon search 16 contributions paper described radically new approach construction binding time analyses approach based upon exploring search space wellannotated extensions welltyped terms type information effective means prune search space makes algorithm practical algorithm surprisingly simple yet supports advanced features higherorder functions polymorphism polyvariance partially static firstorder data higherorder partially static data unbounded number stages complexity algorithm fully analyzed remains future work algorithm based upon use codeannotated extensions basetypes binding time specification types rich expressive mechanism subsumes mechanisms known authors expression bindingtime specifications argued integrated system combining manually staged functions automatically staged func tions eases burden programmer yet allows fine control manually staged systems supported includes use semantic information staged versions could never fully automated proposed system integrates bta semantic part language depend upon intervention external tool whose semantics separate language 17 acknowledgments work described supported nsf grant ccr0098126 mj murdock charitable trust department defense authors would also like thank students class cse583 fundamentals staged computation winter 2002 participated many lively discussions uses staging 18 r fixpoint computation polyvariant static analyses higherorder applicative programs automatic autoprojection higher order recursive equations computational logic binding time analysis higher order untyped functional languages polyvariant bindingtime analysis applicative languages polyvariant constructor specialisation automatic program generator multilevel specialization partial evaluator untyped lambda calculus projection factorizations partial evaluation deferred compilation automation runtime code generation towards bridging gap programming language partial evaluation binding time analysis polymorphically typed higher order languages partially static structures selfapplicable partial evaluator automatic binding time analysis typed lambdacalculus polyvariant binding time analysis advanced functional programming accomplishments research challenges metaprogramming dsl implementation using staging monads comprehending monads essence functional programming monads functional programming tr automatic binding time analysis typed myampersandlgrcalculus comprehending monads binding time analysis high order untyped functional languages automatic autoprojection higher order recursive equations efficient type inference higherorder bindingtime analysis essence functional programming polyvariant bindingtime analysis applicative languages fixpoint computation polyvariant static analyses higherorder applicative programs polyvariant constructor specialisation multistage programming explicit annotations automatic program generator multilevel specialization dsl implementation using staging monads towards bridging gap programming languages partial evaluation accomplishments research challenges metaprogramming efficient multilevel generating extensions program specialization binding time analysis polymorphically typed higher order languages monads functional programming deferred compilation automation runtime code generation
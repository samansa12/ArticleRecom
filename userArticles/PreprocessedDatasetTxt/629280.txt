structuring faulttolerant object systems modularity distributed environment objectoriented approach system structuring found widespread acceptanceamong designers developers robust computing systems authors propose asystem structure distributed programming systems support persistent objects anddescribe properties persistence recoverability implemented theproposed structure modular permitting easy exploitation distributed computingfacilities provided underlying system existing system constructed according tothe principles espoused examined illustrate practical utility proposedapproach system structuring b introduction one computational model advocated constructing robust distributed applications based upon concept using nested atomic actions nested atomic transactions controlling operations persistent longlived objects model object instance class class defines set instance variables object contain operations methods determine externally visible behaviour object operations object access instance variables thus modify internal state object assumed absence failures concurrency invocation operation produces consistent class specific state changes object atomic actions used ensure consistency preserved even presence concurrent invocations failures designing implementing programming system capable supporting objects actions based applications utilising existing distributed system services challenging task support distributed computing currently available systems varies provision bare essential services form networking support message passing slightly advanced services interprocess communication eg remote procedure calls naming binding locating named services remote file access challenge lies integrating services advanced programming environment paper present architecture claim modular nature overall system functionality divided number modules interact well defined narrow interfaces describe facilitates task implementing paper appear ieee trans parallel distributed systems architecture variety systems differing support distributed computing next section present object action model computation indicating number distribution transparency mechanisms integrated within model section 3 identifies major system components interfaces interactions components proposed system structure based upon retrospective examination distributed system arjuna 11 23 29 built newcastle main aspects system presented section 4 examined light discussion preceding section section also describe modular structure system enabled us port number distributed computing platforms arjuna system thus demonstrates practicality proposed approach system structuring discussed section 3 basic concepts assumptions assumed hardware components system computers nodes connected communication subsystem node assumed work either specified simply stop working crash crash node repaired within finite amount time made active node may stable crashproof nonstable volatile storage nonstable storage data stored volatile storage assumed lost crash occurs data stored stable storage remains unaffected crash faults communication subsystem may result failures lost duplicated corrupted messages well known network protocol techniques available coping failures treatment discussed assume processes functioning nodes capable communicating develop ideas first describe desirable transparency properties distributed system support common say distributed system transparent means made behave necessary like nondistributed counterpart several complementary aspects transparency 1 access transparency mechanisms provide uniform means invoking operations local remote objects concealing ensuing networkrelated communications location transparency mechanisms conceal need know whereabouts object knowing name object sufficient able access migration transparency mechanisms build upon previous two mechanisms support movement objects node node improve performance faulttolerance concurrency transparency mechanisms ensure interferencefree access shared objects presence concurrent invocations replication transparency mechanisms increase availability objects replicating concealing intricacies replica consistency maintenance failure transparency mechanisms help exploit redundancy system mask failures possible effect recovery measures stated earlier considering programming system application programs composed atomic actions atomic manipulating persistent longlived objects atomic actions nested concerned mainly tolerating lowerlevel hardware related failures node crashes assumed absence failures invocation operation produces consistent class specific state changes object atomic actions ensure consistent state changes objects take place despite failures consider application program initiated node root computation distributed execution achieved invoking operations objects may remote invoker operation invocation upon remote object performed via remote procedure call rpc since many objectoriented languages define operation invocation synchronous 30 rpc natural communications paradigm adopt support access transparency objectoriented languages furthermore operation invocations may controlled use atomic actions properties serialisability ii failure atomicity iii permanence effect serialisability ensures concurrent invocations shared objects free interference ie concurrent execution shown equivalent serial order execution form concurrency control policy enforced twophase locking required ensure serialisability property actions failure atomicity ensures computation either terminated normally committed producing intended results intended state changes objects involved aborted producing results state changes objects atomicity property may obtained appropriate use backward error recovery invoked whenever failure occurs cannot masked typical failures causing computation aborted include node crashes communication failures continued loss messages reasonable assume toplevel atomic action terminates normally results produced destroyed subsequent node crashes ensured third property permanence effect requires committed state changes ie new states objects modified atomic action recorded stable storage commit protocol required termination atomic action ensure either objects updated within action new states recorded stable storage committed atomic action aborts updates get recorded 5 13 object atomic action model provides natural framework designing faulttolerant systems persistent objects model persistent object use normally held passive state state residing object store object database activated demand ie invocation made loading state methods object store volatile store associating server process receiving rpc invocations atomic actions employed control state changes activated objects properties atomic actions given ensure failure transparency atomic actions also ensure concurrency transparency concurrency control protocols twophase locking access transparency normally provided integrating rpc preprocessor program development cycle produces stub code application object implementation variety naming binding caching strategies possible achieve location migration transparencies normally persistent state object resides single node one object store however availability object increased replicating thus storing one object store object replicas must managed appropriate replicaconsistency protocols ensure object copies remain mutually consistent subsequent section describe protocols integrated within action based systems provide replication transparency assume primitive features heterogeneous distributed system state object context independent representation ie free references specific addressspace implies objects deactivated storage transmission network ii executable versions methods object available nodes interest implies objects moved throughout network simply transmitting states iii machineindependent representations data obtained storage transmission requirement related distinct property enables interpretation passive state object heterogeneous environment several prototype objectoriented systems built often emphasising different facets overall functionality example systems argus 14 arjuna 11 23 29 sos 28 guide 4 emphasised faulttolerance distribution aspects languages psalgol 3 galileo 2 e 25 contributed understanding persistence language feature efforts 12 contributed understanding design object stores relationship database systems build efforts describe necessary features modular distributed programming system supporting persistent objects 3 system structure 31 computation model system modules discussion mind first present simple clientserver based model accessing manipulating persistent objects identify main system modules necessary supporting model stated earlier consider application program initiated single node root computation distributed execution achieved invoking operations objects may remote invoker assume persistent object least one node say functioning capable running object server execute operations object effect would require access executable binary code objects methods well persistent state object stored object store client invoke operation object must first connected bound object server managing object responsibility node provide connection service clients object question passive state also responsible activating object connecting requesting client server order get connection application program must able obtain location information object name node server object made available assume persistent object possesses unique system given identifier uid model application program obtains location information two stages first presenting application level name object string globally accessible naming service assuming object registered naming service naming service maps string uid object ii application program presents uid object globally accessible binding service obtain location information application program client obtained location information object request relevant node establish connection binding server managing object typical structure application level program shown create bindings invoke operations within atomic actions break bindings model bindings stable survive crash client server bindings servers created objects enter scope application program bound server subsequently crashes corresponding binding broken repaired within lifetime program even server node functioning surviving bindings explicitly broken objects go scope application program activated object longer use within scope client application clients bound server object deactivated simply destroying association object server process discarding volatile image object recall object always latest committed state stored stable object store disk representation object object store may differ volatile store representation eg pointers may represented offsets uids model assumes object responsible providing relevant state transformation operations enable state stored retrieved object store server activated object use operations abort commit processing assume object responsible performing appropriate concurrency control ensure serialisability atomic actions effect means object concurrency control object associated case locking method object operation acquiring necessary read write lock associated lock manager object accessing objects state locks released commitabort operations executed identify main modules distributed programming system services provide supporting persistent objects atomic action module provides atomic action support application programs form operations starting committing aborting atomic actions rpc module provides facilities clients connecting disconnecting object servers invoking operations objects naming module provides mapping usergiven names objects uids binding module provides mapping uids location information identity host server object made available persistent object support module provides object servers access stable storage objects relationship amongst modules depicted figure 1 every node system provide rpc atomic action modules node capable providing object servers andor stable object storage addition contain persistent object support module node containing object store provide object storage services via persistent object support module nodes without stable storage may access services via local rpc module naming binding modules necessary every node since services also utilised services provided rpc module application application application object action module rpc persistent object support operating system portable implementation system dependant implementation binder naming module figure 1 components persistent object system system structure also enables application programs made portable application program directly uses services provided atomic action module responsible controlling access rest modules persistent objects application references accessed via atomic action service interface portability application depends portability atomic action module implementation figure suggests atomic action naming binding services also implemented systemindependent portable way rpc persistent object support modules necessarily system dependent level rely directly operating system services possible make naming binding services portable structuring application level programs make use atomic action module manner suggested atomic action module made portable provided services requires rpc persistent object support modules easily mapped onto already provided underlying system example 6 describes uniform rpc system built making use existing rpc services application may well make use host operating system services directly eg window management case lose portability attribute see figure 1 surprisingly way regain portability application use portable subsystems services eg use x window system 26 portable graphics services following discussion initially make two simplifying assumptions object activated host node object store node without object store able provide object servers ii objects replicated restrictions removed subsequently 32 atomic action module module designed two ways module providing language independent primitive operations beginaction endaction abortaction used arbitrary application programs b objectoriented language specific runtime environment atomic actions main advantage latter approach ensuing class hierarchy provides scope application specific enhancements classspecific concurrency control difficult provide former approach although choice central ideas put forward discuss second approach mainly experience building environment c 30 described section 4 explain functionality required atomic action module way utilises services modules consider simple c program see figure 2 simple example application program updates remote persistent object called thisone class example option recovering state object condition met application program creates instance atomicaction called begins action operates object commits aborts action assume program first processed language specific stub generator eg 23 c whose function processes users application program generate necessary clientserver code accessing remote objects via rpcs detailed explanation steps follows 1 example b thisone bind server 2 atomicaction 3 abegin start atomic action 4 bop invocation operation op object b 5 aabort abortion atomic action 6 else aend commitment atomic action figure 2 atomic action example line 1 instance b client stub class example created executing constructor object string thisone used object creation time indicate name persistent object program wants access identifier b acts local name persistent object thisone b created following functions performed precisely actions performed client stub generated b operation naming service invoked passing string thisone obtain uid object ii operation binding service invoked obtain name host say server object made available finally iii operation local rpc module invoked create binding server associated object named uid node binding form communication identifier cid port server suitable rpc communications details given descriptions rpc persistent object support modules following subsections make clear binding established line 2 instance class atomicaction created line 3 begin operation invoked start atomic action line 4 operation op b invoked via rpc module objects responsible controlling concurrency method operation take necessary steps example acquiring appropriate lock line 5 action may aborted program control undoing changes b line 6 end operation responsible committing atomic action typically using twophase commit protocol done invoking prepare operation server b phase one enable b made stable prepare operation succeeds commit operation server invoked making new state object stable otherwise abort operation invoked causing action abort b goes scope program fragment shown figure destroyed executing destructor part clientside destructor stub destructor b breaks binding object server remote node specific rpc module operation required purpose functionality required rpc persistent object support naming binding modules explained detail 33 remote procedure call module rpc module provides distinct client server interfaces following operations initiate terminate operations establishment disestablishment bindings servers call operation rpc three operations provided client interface getrequest sendreply provided server interface operations provided rpc module generally used directly application program generated stubs client server produced stub generator mentioned clients servers communication identifiers cids sockets unix sending receiving messages rpc module node connection manager process responsible creating terminating bindings local servers implementation initiateuid hostname operation involves connection manager process cooperating local object store process see next subsection return cid object server caller client interface operations following semantics normal termination indicate reply message containing results execution received server exceptional return indicate message received operation may may executed normally occur crash server clients response abort current atomic action program structures shown previous subsections show binding creation destruction performed outside application level atomic actions instructive enquire would happen presence client server failure application level action started finished simple case crash server node automatic effect breaking connection clients client subsequently enters atomic action invokes server invocation return exceptionally action aborted client process breaking bindings occurred already difficult case client crash suppose client crashes immediately executing statement line 2 figure 2 explicit steps must taken break orphaned binding server node must detect crash break binding functionality connection manager process embellished include periodic checking connections client nodes 22 every active object associated object server server uses getrequest sendreply service operation invocations one server may manage several objects ie correlation server processes objects may onetoone internal details server thread management handling invocations relevant discussion 34 persistent object support module persistent object support module support rpc module hides potential remoteness stable object storage systems applications also hides system specific details stable storage provides uniform service interface persistent objects module composed two components objectmanager component responsible provision object servers ii objectstore component acts front end local object storage subsystem object store representation disk representation object may differ volatile store representation eg pointers may represented offsets uids assume disk representation objects instances class objectstate instances class objectstate machine independent representations states passive objects convenient transmission volatile store object store also via messages node node persistent object assumed capable converting state objectstate instance converting previously packed objectstate instance instance variables using operations savestate restorestate respectively figure 3 shows state transformations persistent object along operations produce transformations operations readstate writestate provided objectstore component primary function objectstore component store retrieve instances class objectstate readstate operation returns instance objectstate named uid writestate operation stores instance objectstate object store given uid addition assume two operations create delete creating deleting objects restorestate readstate nonvolatile storage volatile storage objectstate stable storage stablestorage storage objectstate memory user object stable state user object loading stable state saving state figure 3 object states typical implementation persistent object support module would follows storage retrieval objects managed store demon belonging objectstore component sequence events discussed previously reference program fragment figure 2 explained terms activities persistent object support module assume client program executing node n 1 object thisone object store node n 2 see figure 4 client process executing program fragment contain stub object b thus line 2 client execute generated stub b stub b responsible accessing naming binding services discussed earlier obtain location information object invoke nitiate operation local rpc module order send connection request connection manager n 2 upon receiving request manager invokes activateuid operation provided objectmanager component objectmanager responsible maintaining mappings uids activated objects corresponding servers assume first object currently active objectmanager return via connection manager cid server client n 1 thereby terminating invocation initiate n 1 assume object passive objectmanager make use node specific activation policy based either create new server object b instruct existing server activate b server uses store demon retrieving objectstate instance uid loads methods b server invokes restorestate operation b server acquires cid returns client thus terminating invocation initiate client store daemon object server connection manager figure 4 accessing object introduce three additional operations objectstore component necessary commit processing writeshadow commitshadow deleteshadow prepare operation commit processing received server volatile state object b converted instance objectstate using savestate operation provided b objectstore operation writeshadow invoked create possibly temporary stable version server subsequently receives commit invocation executes commitshadow operation objectstore make temporary version new stable state object response server abort operation execute deleteshadow operation discard volatile copy object summarise persistent object support module node provides eight operations single operation activate local connection manager process seven operations local object server processes create delete readstate writestate writeshadow deleteshadow commitshadow object server provides operations prepare commit abort commitabort processing persistent objects managing operations persistent object provide order make persistent recoverable savestate restorestate noted atomic action needs record recovery data stable storage eg intentions list committing aborting action presence failures example considered intention list split client server however details discussed extensively literature glossed support nested concurrent atomic actions complicates details managing commit records aspects also central present discussion 35 naming binding modules naming binding services together support location objects name management naming contexts services often designed part single name server becomes responsible mapping user supplied names objects locations eg 21 however two services provide logically distinct functions related applications whereas object name uid mappings maintained naming module expected static uid location mappings maintained binding module change dynamically system supporting migration replication usersupplied names associated objects convenience application programmer fundamental part systems operation within system object identified unique identifier uid mapping names persistent objects corresponding uids performed naming service operation lookup returns uid naming service implemented persistent objects making use services provided atomic action module apparent recursion design easily broken using wellknown cids accessing naming services addition lookup operation naming service also provide add delete operations inserting removing string names given naming context naming service always designed exploit existing service network information service 31 rather depending solely atomic action related modules persistent object storage binding service maps uids hosts also designed application atomic action services addition locate operation add delete operations must also made available enhancements functionality provided binding service required support migration replication objects discuss 36 provision migration replication transparencies architecture discussed far possesses functionality supporting transparencies described earlier except replication migration discuss enhancements necessary support two transparencies first observe naming service need affected since maintains name uid mappings objects binding service affected however example given object required state stored several object stores support replication aspects discussed starting migration simple quite effective form object migration facility made available supporting migration activation object permitting object activated away object store node achieved allowing operations persistent object support module invocable remote object servers local ones thereby permitting object server process obtain state methods object remote object store thus node without object store also run object servers node contain persistent object support module without objectstore component sake simplicity assume state methods object stored together single object store restriction removed easily without affecting main ideas discussed one possible way mechanising remote activation discussed assume objectmanager component persistent object support module longer maintains mappings uid servers activated objects rather information made part binding service thus passive object l ocateuid function binding service return client hostname object store node together list nodes object servers made available active object pair hostname cid indicating cid object server managing object node hostname passive object activated follows list containing names potential server nodes object store node returned binder client uses criterion eg nearest node selecting desirable server node activation say n directs initiate request connection manager process n giving name object store node say n k n object server process gets task activating object server fetches necessary methods state n k acquires cid returns cid client initiate operation terminates client registered cid binding service registration binder necessary ensure client accessing object also gets bound server since assuming object responsible enforcing concurrency control policy large extent solves problem migrating concurrency control information object since concurrency controller object move object scheme discussed extended permit movement objects invocations provided client locate object since moved simple way making migration information available clients leave forwarding address old site invocations directed automatically forwarded see 8 detailed discussion turn attention topic replication transparency far assumed persistent state object resides single object store node node object becomes unavailable availability object may increased replicating several nodes thus storing state one object store object replicas must managed appropriate replicaconsistency protocols ensure object copies remain mutually consistent consider case strong consistency requires replicas regarded available mutually consistent persistent states available replicas required identical discuss three aspects replica consistency management first third concerned mainly management information object replicas maintained binding service whereas second concerned mainly management replicas activated 1 object binding necessary ensure application program presents name uid object currently passive binding service service returns list containing information replicas object mutually consistent also b contain latest persistent state object information one replicas depending upon replication policy use see activated object activated already binding service must permit binding functioning servers managing replicas activated object assume dynamic system permitting changes degree replication object eg new replica object added system important ensure changes reflected binding service without causing inconsistencies current clients object 2 object activation access passive object must activated according given replication policy identify three basic object replication policies active replication active replication one copy passive object activated distinct nodes activated copies perform processing 27 ii coordinatorcohort passive replication several copies object activated however one replica coordinator carries processing 7 coordinator regularly checkpoints state remaining replicas cohorts failure coordinator detected cohorts elect one new coordinator continue processing iii single copy passive replication contrast previous two schemes single copy activated activated copy regularly checkpoints state object stores states stored 5 checkpointing performed part commit processing atomic action activated copy fails application must abort affected atomic action restarting action result new copy activated activated copies replicas cases ii must treated single group application manner preserves mutual consistency suppose replication policy active replication consider following scenario see figure 5 group g invoking service operation group g b single object b b fails delivery reply g suppose reply message received 1 2 case subsequent action taken 1 2 diverge problem caused fact failure b seen 2 1 avoid problems communication replica groups require reliable distribution ordering guarantees associated nonreplicated systems reliability ensures correctly functioning members group receive messages intended group ordering ensures messages received identical order functioning member 27 gb ga figure 5 operation invocation replicated objects 3 commit processing application finished using object necessary ensure new states mutually consistent object replicas get recorded object stores takes place commit time applications atomic action time also necessary ensure information object replicas maintained binding service remains accurate consider application modifies object say active replication use suppose start application two replicas available crash node makes one say modified commit time information maintained within binding service modified exclude 2 list available replicas otherwise subsequent applications may end using mutually inconsistent copies conclude subsection observing introduction migration replication transparencies enforces consistency requirements binding service best met composing service persistent objects whose operations structured atomic actions see 16 discussion 4 case study examination arjuna arrived system structuring ideas presented previous section based experience designing implementing distributed programming system called arjuna 11 23 29 arjuna objectoriented programming system implemented c provides set tools construction faulttolerant distributed applications constructed according model discussed section 2 arjuna provides nested atomic actions structuring application programs atomic actions control sequences operations upon local remote objects instances c classes operations upon remote objects invoked use remote procedure calls rpcs time writing december 1992 prototype system operational two years provided us valuable insight design development systems architecture presented section 3 regarded idealised version arjuna 41 arjuna systems support networking section paper first describes arjuna system designed implemented run unix workstations networking support distributed computing unix sockets message passing network five modules shown figure 1 atomic action naming binding persistent object support rpc modules implemented discussion focusing approach taken implementing atomic action module atomic action module implemented using number c classes organised class hierarchy familiar developers traditional single node centralised objectoriented systems application level objects visible entities client server processes actual work hidden arjuna server processes created dynamically rpcs made objects servers created using facilities provided underlying rpc subsystem rajdoot also built us 22 current implementation arjuna makes use unix file system long term storage objects class objectstore providing objectoriented interface file system design implementation arjuna object store discussed elsewhere 11 along object naming uid scheme implementation strategy object store acceptable performance understandably poor naming binding services implemented arjuna persistent objects statemanager atomicaction lockmanager lock abstractrecord user defined user defined locks lockrecord recovery record figure arjuna class hierarchy principal classes make class hierarchy arjuna atomic action module depicted figure 6 make use atomic actions application instances class atomicaction must declared programmer application illustrated figure 2 operations class provides begin abort end used structure atomic actions including nested actions objects controlled resulting atomic actions objects either instances arjuna classes userdefined classes derived lockmanager hence members hierarchy shown figure 6 arjuna classes derived base class statemanager provides primitive facilities necessary managing persistent recoverable objects facilities include support activation deactivation objects statebased object recovery thus instances class statemanager principal users object store service class lockmanager uses facilities statemanager provides concurrency control twophase locking current implementation required implementing serialisability property atomic actions implementation atomic action facilities recovery persistence management concurrency control supported collection object classes derived class abstractrecord turn derived statemanager example instances lockrecord recoveryrecord record recovery information lock userdefined objects respectively atomicaction class manages instances classes using instance class recordlist corresponds intentions list mentioned responsible performing aborts commits consider simple example assume userdefined persistent object application containing atomic action accesses object invoking operation op1 involves state changes serialisability property requires write lock must acquired modified thus body op1 contain call appropriate operation concurrency controller see figure 7 body op1 setlock new lockwrite actual state change operations follow figure 7 use locks implementing operations operation setlock provided lockmanager class performs following functions case check write lock compatibility currently held locks allowed ii use statemanager operations creating recoveryrecord instance lock write lock state object must retained modification insert recordlist iii create insert lockrecord instance recordlist suppose action aborted sometime lock acquired abort operation atomicaction process recordlist instance associated invoking abort operation various records implementation operation lockrecord class release write lock recoveryrecord restore prior state abstractrecord based approach managing object properties proved extremely useful arjuna several uses summarised recoveryrecord supports statebased recovery since abort operation responsible restoring prior state object however recovery capability altered refining abort operation take alternative course action executing compensating function principal means implementing typespecific recovery userdefined objects arjuna class lockrecord good example recoverable locking supported lock object abort operation lockrecord perform state restoration executes releaselock operation note locks surprisingly also treated objects instances class lock therefore employ techniques making recoverable object similarly special mechanism required aborting action accessed remote objects case instances rpccallrecord inserted recordlist instance atomic action rpcs made objects abortion action involves invoking abort operation rpccallrecord instances turn send abort rpc servers previous section described three object replication approaches performed trial implementations active single copy passive replication arjuna 15 17 active replication often preferred choice supporting high availability realtime services masking replica failures minimum time penalty considered highly desirable since every functioning member replica group performs processing active replication object requires functioning replicas object receive identical invocations identical order thus active replication requires multicast communication support satisfying rigorous reliability ordering requirements single copy passive replication hand implemented without recourse complex multicast protocols one replica carries computation time however performance presence primary failures poorer necessary abort action retry therefore believe fault tolerant system capable supporting number replication schemes main elements design summarised binding service implemented one arjuna objects maintains group view database gvd records information available replicas object gvd replicated using either techniques described database accessed using atomic actions ii passive replication access object application object first contacts gvd returns list containing location information consistent replicas simple static ordering scheme used primary selection application object uses rpc module operation initiate binding primary copy accesses replicated objects technique used commit time primary object responsible updating secondaries made possible arjuna state arjuna objects transmitted network execution action primary found become inaccessible eg node crashed action aborted part abort procedure gvd accessed name primary removed list available replicas since actions nested abortion need entire computation enclosing action retry crashed node containing replica repaired include copy object running join atomic action updates copy replica inserts name gvds list object summary major changes necessary nonreplicated version arjuna creation maintenance gvd modifications abort commit procedures hinted iii active replication activating object consists activating copies listed group view list returned gvd atomic actions access replicated objects accurate view current group membership object formed copy detected failed commit time current view used updating gvd thus failed replicas automatically get excluded incorporation active replication meant following two main changes nonreplicated version arjuna addition need creation maintenance gvd already discussed rpc module original unicast rpc replaced reliable group rpc capable invoking functioning copies object activated effect meant replacing original datagram based rpc implementation reliable multicast protocol based one 15 17 particular group rpc ensures replicated call one group another appears behave like single non replicated call atomic action module module responsible manipulating object group view information means atomic action required maintain exclude list replicas detected failed commit time list used removing names replicas group view list maintained gvd summary approach provide basic binding information object replicas via gvd arjuna object used providing either active passive replication passive replication scheme advantage supported top conventional rpc system important system like arjuna designed capable exploiting functionality offered underlying distributed system software current design arjuna elegantly sorting functions atomic action module classes fails separate interfaces supporting environment manner section 3 class statemanager combines operations relating persistent object support rpc naming binding management recovery persistence distribution concurrency control wellorganised around classes discussed interfaces services well organised present rpc facility supporting interface discussed also responsible creation object servers function performed persistent object support module naming binding services properly separated combined functions currently performed simple name server revisions system carry objectoriented design along lines presented section 3 paper currently underway revisions however represent major overhaul system thus system demonstrates distributed systems structured along lines figure 1 built 42 arjuna systems describe arjuna system described adapted run two quite different systems providing basic support distributed computing eg rpc enabling atomic action module arjuna utilise services host system place services modules built earlier system modular structure proposed able perform ports first port ansaware distributed computing platform ansaware platform developed ansa project 1 platform provides rpc object servers known capsules naming binding services via subsystem known trader networked workstations several operating systems supported far used unix porting relatively straight forward exercise start removed rpc module used original arjuna rajdoot mapped rpc operations initiate terminate call onto provided ansaware enables arjuna applications run top ansaware port automatically supports passive replication near future enhance port use ansaware trader registering arjuna naming binding services ansaware system recently upgraded support group invocations 20 active replication object storage services 19 believe services also used place original arjuna services used supporting active replication object storage also performed experiments ascertain whether arjuna made run integrated environments provided distributed operating systems 10 experimental configuration used consists locally distributed multiprocessor system twelve t800 transputers 2 mbytes memory interconnected form twodimensional grid see figure 7 transputer runs copy helios generalpurpose distributed operating system 24 helios file server program hfs running one transputers provides access disk used object repository hfs figure 8 multitransputer system helios operating system provides number facilities clientserver programming helios treats every file process device including processors object named using unix like path names object represented objectstructure contains information full pathname object object type eg file process etc helios locate function allows objectstructure obtained object system given name function accesses local processor name server initiate flood search throughout system objectstructure available locally result search local name server updated relevant object structure subsequent locates object handled entirely locally object located may opened use helios open function object process objectstructure contains helios port via messages may sent process using helios putmsg function messages received port using helios getmsg function process act server binding one communications identifier cid name service name registering service name local helios name server waiting communication cid process may obtain cid registered server using locate function port arjuna implemented number helios application programs collectively known object management layer layer implements rpc facility using putmsg getmsg functions helios object servers mapped onto helios servers may register discussed server may receive open requests clients communication port associated service name although several shortcuts taken exercise eg client server stubs hand crafted experiment show functionality required arjuna atomic action module mapped via object management layer onto underlying services provided helios 6 concluding remarks paper presented modular architecture structuring faulttolerant distributed applications encapsulating properties persistence recoverability shareability serialisability failure atomicity atomic action module defining narrow welldefined interfaces supporting environment achieve significant degree modularity well portability atomic action based objectoriented systems arrived ideas presented based experience building arjuna system made run number distributed computing platforms atomic action module provides fixed means combining stated object properties investigating whether provided individually permitting application specific selection system example could permit shareable objects need persistent viceversa although could furthermore properties enabled disabled runtime based application requirements initial work direction reported 9 18 indicates indeed possible acknowledgements arjuna project continues team effort critical comments graham parrington mark little stuart wheater gratefully acknowledged continued interactions colleagues ansaisa project proved beneficial ansaware helios ports performed joao geada stuart wheater jim smith steve caughey work reported supported part grants uk science engineering research council grant numbers grf38402 grf06494 grh81078 esprit projects isa project number 2267 broadcast basic research project number 6360 r advanced networked systems architecture ansa reference manual implementation galileos persistent values psalgol algol persistent heap architecture implementation guide objectoriented distributed system concurrency control recovery database systems remote procedure call facility interconnecting heterogeneous computer systems exploiting virtual synchrony distributed systems implementing location independent invocation shadows flexible runtime support systems objects distributed system implementing faulttolerant object systems distributed memory multiprocessors treatment persistent objects arjuna transaction management objectoriented database system notes data base operating systems guardians actions linguistic support robust distributed programs replicated k resilient objects arjuna maintaining information persistent replicated objects distributed system object replication distributed system developing class hierarchy objectoriented transaction processing persistent object infrastructure heterogeneous distributed systems model interface groups clearinghouse decentralized agent locating named objects distributed environment rajdoot remote procedure call mechanism supporting orphan detection killing reliable distributed programming c arjuna approach helios operating system persistence e language issues implementation x window system implementing faulttolerant services using state machine persistence migration c objects overview arjuna distributed programming system network programming tr c programming language concurrency control recovery database systems x window system remote procedure call facility interconnecting heterogeneous computer systems exploiting virtual synchrony distributed systems transaction management objectoriented database system implementation galileos persistent values helios operating system treatment persistent objects arjuna persistence e language issues implementation implementing faulttolerant services using state machine approach tutorial guardians actions linguistic support robust distributed programs overview arjuna distributed programming system implementing location independent invocation rajdoot developing class hierarchy objectoriented transaction processing notes data base operating systems maintaining information persistent replicated objects distributed system flexible support system objects distributed systems ctr elisa bertino sushil jajodia luigi mancini indrajit ray advanced transaction processing multilevel secure file stores ieee transactions knowledge data engineering v10 n1 p120135 january 1998 c little k shrivastava examination transition arjuna distributed transaction processing software research products proceedings 2nd conference industrial experiences systems software p44 december 08 2002 boston salvatore march charles wood gove n allen research frontiers object technology information systems frontiers v1 n1 p5174 july 1999
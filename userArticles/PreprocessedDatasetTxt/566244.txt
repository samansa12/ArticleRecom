decision lists related boolean functions consider boolean functions represented decision lists study relationships classes boolean functions turns elementary class 1decision lists interesting relationships independently defined classes disguised horn functions readonce functions nested differences concepts threshold functions 2monotonic functions particular 1decision lists coincide fragments mentioned classes investigate recognition problem class well extension problem context partially defined boolean functions pdbfs show finding extension given pdbf class 1decision lists possible linear time improves previous results moreover present algorithm enumerating extensions polynomial delay b introduction decision lists proposed 31 specification boolean functions amounts simple strategy evaluating boolean function given assignment approach become popular learning theory since bounded decision lists naturally generalize important classes boolean functions example kbounded decision lists generalize classes whose members cnf dnf expression clause term respectively k literals consequence also classes whose members dnf cnf containing k terms clauses respectively another class covered decision lists one decision trees 30 informally decision list written cascaded conditional statement form else b v means evaluation term ie conjunction boolean literals assignment v x b either 0 false 1 true important result established 31 kdecision lists ie decision lists term k literals k constant probably approximately correct pac learnable valiants model 35 largely extended classes boolean functions known learnable sequel decision lists studied extensively learning field see eg 18 8 16 9 however known decision lists generalize classes boolean functions 31 relationships classes horn functions readonce functions threshold functions 2monotonic functions widely used literature partially known cf 5 3 thus interesting know relationships particular whether fragments classes correspond decision lists fragments alternatively characterized issue intriguing since decision lists operationally defined classes horn functions readonce functions defined semantical terms models syntactical terms formulas basis respectively paper shed light issue study relationship decision lists classes mentioned focus elementary class 1decision lists c 1dl received lot attention subject number investigations eg 31 26 8 9 turns class relates interesting way several classes boolean functions particular coincides independently defined semantical syntactical classes well intersections wellknown classes boolean functions find following characterizations c 1dl coincides ffl c r dh renamingclosure class functions f f complement f horn 12 also called disguised double horn functions ffl cnd class nested differences concepts 20 concept described single intersection classes 2monotonic functions 29 readonce functions ie functions definable formula variable occurs 17 23 35 34 intersection threshold functions also called linearly separable functions 29 readonce functions ffl clr1 class linear readonce functions 12 ie functions represented readonce formula binary connective involves least one literal observe inclusion c 1dl c th cr1 follows result c 1dl c th 5 3 fact c 1dl cr1 however converse known results give us new insights relationships classes functions moreover provide us semantical syntactical characterization 1decision lists terms renamed horn functions readonce formulas hand obtain characterizations intersections wellknown classes boolean functions terms operationally semantically syntactically defined classes boolean functions show natural generalization results 1decision lists kbounded decision lists fails almost cases single exception coincidence nested differences concepts holds appropriate base class generalizing terms thus results unveil characteristic properties 1decision lists vices versa intersections classes boolean functions coincide furthermore study computational problems 1decision lists consider recognition formula also called membership problem 19 representation problem 4 1 problems context partially defined boolean functions partially defined boolean function pdbf viewed pair f sets f true false vectors v 2 f0 1g n respectively naturally generalizes boolean function allowing range function values input vectors unknown concept many applications eg circuit design representation causeeffect relationships 7 learning mention principal issue pdbfs following given pdbf f determine whether f particular class boolean functions c exists f f f f f f f denote sets true false vectors f respectively f called extension f c finding f known extension problem 6 27 since general pdbf may multiple extensions sometimes desired know extensions compute extension certain quality eg one described shortest formula smallest set f extension problem closely related problems machine learning typical problem following 4 suppose n boolean valued attributes find hypothesis terms boolean function f class boolean functions c consistent actual correlation attributes seeing sample positive negative examples known actual correlation function g c terms learning algorithm produces extension pdbf however subtle difference general extension problem learning problem latter problem extension priori known exist former unknown learning algorithm might take advantage knowledge find extension faster extension problem known consistency problem 4 1 corresponds learning sample possibly spoiled inconsistent examples context also interesting know whether pdbf given sample uniquely defines boolean function c learner recognizes fact shehe identified function g learned related question whether pdbf unique extension important context teaching 32 22 33 15 facilitate quicker learning sample provided teacher rather randomly drawn identification function g possible see eg 5 15 details sample allows identify function c called teaching sequence specifying sample 5 thus issue whether given set labeled examples teaching sequence amounts issue whether seen pdbf unique extension c slight variant sample known consistent function g c case problem amounts unique extension problem knowing extension exists general additional knowledge could utilized faster learning alternative teaching models considered sample given teacher precisely describe single function 16 however identification target function still possible since teacher knows learner proceeds vice versa learner knows teacher generates sample called teaching set 16 prevent collusion two sides target could simply encoded sample adversary allowed spoil teaching set adding examples main results issues summarized follows recognizing 1decision lists formula tractable wide class formulas including horn formulas 2cnf 2dnf unsurprisingly intractable general case ffl point extension problem c 1dl solvable linear time improves previous result extension problem c 1dl solvable polynomial time 31 consequence hypothesis consistent target function g c 1dl sample generated linear time particular learning possibly spoiled teaching sequence possible linear time obtain result improvement 16 shown learning function g c 1dl particular teaching set possible om 2 n time length shortest 1decision list g n number attributes input size assumed omn algorithm replace learning algorithm 16 finds target onm time ie linear time mention 8 presents result somewhat related 16 1decision lists k alternations ie changes output value pac learnable algorithm runs 2 time ffl present algorithm enumerates extensions given formulas pdbf c 1dl polynomial delay corollary problems deciding whether given set examples teaching sequence whether consistent sample teaching sequence solvable polynomial time moreover small number different hypotheses fact even polynomially many target function produced within polynomial time rest paper organized follows next section provides preliminaries fixes notation section 3 study relationships 1decision lists classes functions section 4 address recognition problem formulas section 5 study extension problem section 6 concludes paper preliminaries use x denote boolean variables letters u v w denote vectors f0 1g n ith component vector v denoted v formulas built variables using connectives term conjunction literals p clause c defined dually change resp c horn jntj 1 resp p c 1 use denote empty term truth empty clause falsity respectively disjunctive normal horn similarly conjunctive normal form cnf horn c horn eg term f2g horn clause thus horn partially defined boolean function pdbf mapping defined denotes set true vectors positive examples f f0 1g n denotes set false vectors negative examples simplicity denote pdbf seen representation total boolean functions bfs f called extension often identify formula bf defines term implicant bf f f holds usual ordering defined f g f g moreover prime proper subterm 0 implicant f dnf term prime implicant term redundant ie removing changes function decision list l finite sequence pairs defines bf f f0 1g f0 1g g call bf sometimes decision list f definable decision list terminology inherited restricted decision lists kdecision list decision list term contains k literals denote c kdl class functions represented kdecision lists particular c 1dl class decision lists term either single literal empty decision list monotone 15 term positive kdl denote restriction c kdl monotone decision lists bf f horn f denotes closure set f0 1g n vectors componentwise conjunction vectors c horn denote class horn functions known f horn f represented horn dnf f also represented positive dnf ie dnf term positive f called positive c pos denotes class positive functions vector w 2 f0 1g n define 0g renaming nary bf f w denoted f w bf fx phi w ie f w phi componentwise addition modulo 2 xor class bfs c denote c r closure c renamings renaming formula w denoted w formula resulting replacing literal involving variable x w opposite eg let renaming f 3 characterizations 1decision lists readonce functions function f called readonce represented readonce formula ie formula without repetition variables class cr1 readonce functions extensively studied literature cf 34 24 35 28 21 17 23 11 definition 31 define class flr1 linear readonce formulas following recursive form 2 2 flr1 x variable occurring x x x x 2 flr1 call bf f linear readonce 12 represented formula flr1 let clr1 denote class functions eg x 1 x 2 note two readonce formulas equivalent transformed associativity commutativity 21 hence latter formula represent linear readonce function following easy see cf also 5 p 11 proposition 31 note 2 flr1 convertible equivalent 1decision list linear time vice versa horn functions next give characterization terms horn functions bf f called double horn 13 f class functions denoted cdh note f double horn f f horn eg double horn horn alternatively bf f double horn horn dnf horn cnf representation previous example easily seen case class double horn functions considered 13 12 giving f f f balanced role process finding horn extension show somewhat unexpected result classes c r dh clr1 coincide hence c r gives precise syntactical characterization semantically defined class c r previous result semantical characterization c 1dl proof result based following lemma found 13 12 let ng permutation v let gamma set horn terms ng g lemma 32 13 let f bf variables x holds f represented dnf t2s permutation v algebraic transformations formula rewritten linear readonce formula even variables x 11 different since linear readonce formula transformed formula changing polarities variables obtain next result denote c rev class reversed double horn functions lemma also derived related result finite distributive lattices see 25 theorem 33 c r 1dl 2 thus exists interesting relationship 1decision lists readonce formulas disguised horn functions means relationship able precisely characterize prime dnfs functions c r dh immediate consequence next theorem theorem 34 every f 2 c r dh equivalently f 2 c 1dl f 2 clr1 renaming w f w positive represented unique prime dnf pairwise disjoint positive terms possibly empty particular 32 implies conversely every 32 represents f 2 c r equivalently f 2 c 1dl f 2 clr1 2 nested differences concepts 20 learning issues concept classes studied satisfy certain properties particular learning concepts expressed nested difference c 1 n considered c concept class closed intersection concept viewed bf f concept class c class bfs cc intersection property amounts closedness cc conjunction ie f clearly class bfs f definable single possible empty term enjoys property let cnd denote class nested differences c single term following holds proposition 35 c shall prove general result end section theorem 314 also give characterization c mon thus general learning results 20 apply particular class 1decision lists thus also disguised double horn functions linear readonce functions threshold 2monotonic functions let us denote c th class threshold functions c 2m class 2monotonic functions function f variables x threshold linearly separable weights w threshold w 0 reals fx function 2monotonic assignment size 2 either f f f f holds denotes opposite assignment 29 property 2monotonicity related concepts studied various names fields threshold logic hypergraph theory game theory property seen algebraic generalization thresholdness note c r following unexpected result theorem 36 c proof wellknown c th ae c 2m 29 ae proper inclusion moreover also c 1dl c th shown 5 3 notice 12 inclusion c r independently shown using form 32 proceeding similar 3 idea give variables j weight decreasing index j assign x weight every term weight threshold w 0 simply weight term thus results remains show c 2m cr1 c r dh holds recall function g x 1 regular 29 gv gw holds v w 2 c reg class regular functions following facts known cf 29 every regular function positive 2monotonic b every 2monotonic function becomes regular permuting renaming arguments c c reg closed arbitrary assignments ac remains show c reg cr1 clr1 claim function f 2 c reg cr1 written either f 0 regular readonce function depending x j induction using theorem 33 gives desired result completes proof since f readonce decomposed according one following two cases case 1 f depend disjoint sets variables b f decomposed similarly show jb holds one means f form assume contrary without loss generality jb 1 2 considering assignment kills f 3 function regular observe prime implicant g prime implicant f 1 f 2 length 2 since f readonce assumption decomposition let smallest index assume without loss generality 2 b 1 let prime implicant f 2 unit vector k note l h l 2 v definition holds indeed onw 6 p 1 consequently vectors v w thus g regular contradiction proves claim case 2 f depend disjoint sets variables b f decomposed similarly dual function f form case 1 recall formula representing dual f f obtained formula representing f interchanging 0 1 respectively since dual regular function also regular 29 follows f form implies f form ii 2 thus established main result section theorem 37 c generalization result interesting issue particular whether kdecision lists readk functions k constant similar relationships hold appears case using counting argument one show every k 1 c kdl contains function expressible readk formula fact stronger result obtained let integer function f n denote cr class bfs fx definable formulas variable occurs f n 1 times class integer functions f define cr f n2f cr pos c k pos classes positive bfs f prime implicants f size k resp k k constant lemma 38 every k 1 finitely many n k exists nary f 2 c k pos kk log n proof since prime implicants positive function positive c k pos contains functions n variables hand number positive functions cr bounded loss generality formula defining positive function contain negation assuming variables occur f n times formula tree leaves atoms nodes connectives written postorder traversal string denote atoms others connectives ways place atoms string different simplification suffice times 2 mgamma1 combinations connectives allow single use binary connective rx evaluates right argument may assume wlog contains exactly f n occurrences variable thus 34 upper bound positive readf n functions n variables clearly implicitly accounted since multiple trees eg counted us compare 33 34 clearly 34 bounded since take logarithm 33 35 base 2 consider inequality since amounts pn polynomial degree k gamma 1 f kk log n obtain kk log n thus kk log n k log n easily seen large enough n inequality holds proves lemma 2 let f n kk log n class functions f n f n n kk log n holds infinitely many n theorem 39 c k pos 6 cr f n kk log n every k 1 easy see every function c k pos cr n lowest polynomial degree pos cr n k 0 corollary 310 c mon kk log n kk log n every k 1 consequently generalization parts theorem 37 involving readonce functions characterization kdecision lists terms readk functions fails remains true even allow polynomial number repetitive variable uses degree polynomial smaller k gamma 1 let us consider possible generalization characterization terms horn functions since c kdl contains functions kcnf particular also parity function k variables hard see interesting relationships c kdl combinations restrictions horn functions nested differences concepts however natural generalization result theorem 37 let cnd c denote class functions definable nested differences bfs c let similarly denote cdl c class functions definable cdecision list ie decision list term except last replaced f 2 c following holds theorem 311 let c class bfs cdl contains complements functions f proof show induction 1 every f represented cdecision list length cnd c fg nested difference f 1 n f 2 n c fg cdl c basis two cdecision lists 0 1 respectively represented nested difference n respectively conversely 1 represents function f 2 c decision list f 0 1 obviously represents f observe f 2 c holds suppose statement holds consider case 1 first consider cdecision loss generality f 1 6j induction hypothesis tail l represented nested difference defining bf f 0 2 cnd c b defines function represented nested difference replacing f 0 0 nested difference functions c fg hence f 2 cnd c fg holds hand represents function equivalent f 1 f 0 since complement function g represented nested difference n g obtain already discussed scheme disjunction f represented nested difference replacing f 0 0 obtain nested difference functions c fg hence f 2 cnd c fg second let nested difference functions c fg induction hypothesis represents function f 0 2 cdl c thus represents function easy see c cdl c closed complementation 31 replace decision list b obtain decision list complement function hence f 0 represented c decision list l 0 f otherwise decision list f hence f 2 cdl c consequently induction statement holds 1 concludes proof result 2 proposition 35 immediate corollary result moreover get following result let c kcl denote class functions definable single clause k literals plus corollary 312 c thus cnd c kcl characterizes c kdl however c kcl closed conjunction thus strictly speaking instance schema 20 characterization instance nonetheless possible call subclass c 0 c disjunctive base class c every f 2 c expressed disjunction functions f c 0 lemma 313 c 0 disjunctive base c cdl c 0 proof suppose item f b occurs cdecision list l hypothesis replace item k items f resulting decision list equivalent l hence cdecision list converted equivalent c 0 decision list 2 theorem 314 c proof corollary 312 lemma 313 2 thus nested differences kcnf functions equivalent kdecision lists observe proof result linear time mappings nested differences equivalent kdecision exist similar equivalence c hold reason class singleterm functions base c kcnf makes impossible rewrite c kcnf decision list kdecision list general classes bounded monotone decision lists characterized similar way let c pos kdnf c neg kcnf subclasses c kdnf c kcnf whose members positive dnf negative cnf ie positive literal occurs respectively theorem 315 c mon kcnf thus particular c lit gamma denotes class negative literals plus obtain following corollary 316 c rev 4 recognition formula 1decision list thus also relatives recognized polynomial time formulas certain classes include horn formulas basis recognition algorithm following lemma lemma 41 bf f c 1dl either ia x holds j ii f holds j satisfying ia ib resp ic id 2 given formula recognition algorithm proceeds follows picks index j one iaid holds recursively proceeds ii details found 12 following result time complexity immediate fact recursion depth bounded n level test iaid made let formula denoted jj length ie number symbols theorem 42 let f class formulas closed assignments checking equivalence respectively done otn jj time 2 f 2 deciding whether given represents f 2 c 1dl done 2 tn jj time 2 hence algorithm polynomial many classes formulas including horn formulas quadratic 2cnf formulas since testing whether quadratic formula possible ojj time cf 10 14 obtain following corollary 43 deciding whether given horn dnf 2cnf represents f 2 c 1dl done theorem 42 yet another interesting corollary corollary 44 deciding arbitrary positive ie negationfree formula represents f 2 clr1 done polynomial time 2 fact deciding whether positive formula represents readonce function conpcomplete 21 11 turns class clr1 maximal subclass cr1 wrt inductive ie contextfree bound disjunctions conjunctions readonce formula deciding f 2 cr1 positive formula polynomial indeed follows results 11 21 part 2 definition 31 either disjunction term x 1 x 2 conjunction clause x 1 x 2 allowed recognition problem conphard general recognition problem unsurprisingly intractable theorem 45 deciding whether given formula represents function f 2 c 1dl conpcomplete proof recognition problem cr1 conp 2 easy see also conp c 2m since conp closed conjunction membership conp follows 37 hardness part easy class c projection property ie c closed assignments contains arity contain bfs conphard 19 obviously c 1dl enjoys property 2 kdecision lists turns recognition problem harder 1decision lists fact membership conp follows result kdecision lists exact learnable equivalence queries polynomial time proved nick littlestone unpublished also derivable results 20 theorem 314 result 2 classes exact learnable polynomial time equivalence membership queries minor constraints recognition problem conp hardness holds argument proof theorem 45 conclude section remarks concerning equivalence implication problem problems given kdecision lists l 1 l 2 representing functions f 1 f 2 respectively decide usual tn jj monotonic arguments respectively problems obviously conp complete fixed k 3 since subsume deciding whether kdnf formula tautology hand problems polynomial fact solvable linear time remaining case seen problem also polynomial underlying reason satisfiability problem 2cnf formulas polynomial 5 extension problems extension problem c 1dl already studied prove paclearnability class known 31 solvable polynomial time point result 31 improved ibby showing extension problem c 1dl solved linear time regarded positive result since extension problem renaming closures classes contain c 1dl mostly intractable eg c r horn c r pos c r linear time algorithms known describe algorithm extension equivalent class clr1 uses lemma 41 recursive extension test similar general algorithm described 31 also relative algorithm total recall 20 informally examines vectors f respectively see whether decomposition form l l possible l literal variable x discards vectors f covered excluded decomposition recursively looks extension projection f remaining variables cascaded decompositions handled simultaneously algorithm extension input pdbf f set ng indices extension f 2 clr1 projections f respectively otherwise step 1 true vectors false vectors step 2 go step 3 extension x possible else begin go recursion elseif else step 3 j else begin go recursion elseif else find extension given pdbf f algorithm called ng observe could equally well consider going recursive calls particular index intersection sets decompositions x equally good note execution steps 2 3 alternates recursion moreover algorithm remains correct subset may lead different extension proposition 51 given pdbf f correctly finds possible speed algorithm using proper data structures runs time linear time technical details found 12 particular data structures assure bit input looked times roughly counters ij record many vectors value j component ij bucket btt ij moreover list lt ij vectors v v component value j maintained component v link entry v respective list lt ij exists f analogous data structures used theorem 52 extension problem c 1dl equivalently clr1 cnd solvable time linear time 2 thus learning context obtain following result corollary 53 learning bf f 2 c 1dl arbitrary possibly spoiled teaching sequence f possible linear time size input turns algorithm used substitute learner teacherlearner model c 1dl described 16 algorithm based idea build decision list moving item b literal b output value beginning decision list towards end recognized example misclassified item initially possible items beginning procedure loops misclassification occurs see 16 details takes om 2 n many steps input size omn length shortest decision list target method 16 somewhat dual easily seen items remain beginning list whose literals selectable decomposition algorithm thus greedy nature algorithm constructs possibly spoiled teaching set 16 exactly target function shows c 1dl efficiently teachable class since teaching set constructible target linear time c 1dl nontrivial class optimal order ie linear time teaching learning 51 generating extensions computing extensions pdbf c 1dl describe algorithm outputs linear readonce formulas extensions employing decomposition property lemma 41 clr1 roughly algorithm outputs recursively extensions common prefix fl linear readonce formulas backtracking procedure similar extension far complicated reason multiple output extension must avoided indeed syntactically different renamed forms 31 may represent linearread function corresponds fact different 1decision lists may represent function eg function order avoid ambiguity single normal form adopt purpose innermost level renamed form 31 linear readonce function contains least two literals formula involves one level algorithm allextensions uses auxiliary procedure checks whether given pdbf f extension clr1 subject constraint decomposition starting conjunction literals given set lit resp lit used disjunction step resp conjunction step made constraint used take commutativity connectives account make concept constrained extensions precise convenience define set vectors v2s onv similarly v2s v moreover literal l selectable resp selectable either ons set selectable resp selectable literals denoted sellit resp sellit lit constraint extension f 2 clr1 pdbf f ng lit constrained extension lit set selectable literals linear readonce formula f form l 1 ff disjunction lit constraint extension f 2 clr1 pdbf f ng lit constrained extension lit set selectable literals f linear readonce formula f form l 1 ff conjunction use two symmetric algorithms restext restext handle cases look nontrivial ie different lit constrained resp lit constrained extension algorithm conjunction case follows algorithm restext ng set lit selectable literals output yes f lit constraint extension f 2 clr1 f 6 otherwise step 1 else output exit step 2 sigma fi j x try maximal decomposition use first literals occurring opposite sigma output yes exit extension l 1 exists output exit f extension clr1 f least 2 ji sigma j vectors cand empty list list decomp candidates subset j sigma begin lit j insert lit j decomp l 2 lit j insert lit j cand empty begin remove set cand n fv l j l 2 ag decompose literal selectable fa test extension jf j 6 2 ji jgamma1 output yes exit else l 2 insert n flg cand output exit 2 algorithm case lit constraint extensions restext completely symmetric roles f well interchanged since formulation algorithm straightforward omit lemma 54 restext correctly answers whether given pdbf f lit constrained extension clr1 runs time onjt proof first prove correctness easy see step 1 correct l 2 lit l extension jt ij 6 2 jij vector v 2 f0 1g n n exists case extension lit constrained extension jij 2 thus algorithm correctly outputs yes step 1 suppose outputs step 1 lit means one variable eligible jt means possible extension thus algorithm correctly outputs consider step 2 observed step reached f 6 holds suppose algorithm outputs yes first statement lit literals l sigma holds since otherwise f 0 sigma fg hence jf 0 sigma contradiction thus l 1 extension f clearly lit constrained therefore output correct sigma 6 let consider lit constrained extension f hence also case output correct otherwise yes output loop literal l selectable fa jf j 6 2 ji jgamma1 claim fa 6 holds let us assume contrary contradiction otherwise lit 6 l2a l represents extension clr1 easy see lit j l2lit j l extension clr1 well thus f 0 first statement step 2 satisfies jf 0 sigma j 6 2 ji sigma j otherwise contradiction therefore case fa loop would entered since algorithm halts first statement step 2 say fa extension clr1 represented linear readonce formula since fa 6 f extension clr1 oth erwise loop would entered indeed n fv l g consequently extension fi must different thus follows f extension l2a l l fi since clearly lit constrained output correct hand suppose algorithm outputs towards contradiction assume f lit constrained extension clr1 assume first means literals l j v l sigma literals lit property since extension set empty hence also set extension f 0 sigma implies jf 0 sigma j 6 2 ji sigma j since already observed lit 6 algorithm outputs yes first contradiction thus must form fi easy see l selectable fa either algorithm inserts cand loop 6 fl algorithm must find loop jf output yes hence inserts among possible others subset 1 n fl g fl cand l selectable fa 1 1 eventually algorithm must encounter jf k k j 6 2 ji k therefore algorithm outputs yes contradiction proves correctness algorithm concerning bound execution time clear step 1 done ojt j time step 2 sigma computable time f 0 onjf time test jf 0 sigma j 6 2 ji sigma j done onjf time computing set f 0 sigma onjf determining size call extension evaluated onjt theorem 52 thus first phase step 2 takes onjt time remaining second phase uses list cand easily organized lookup insertion removal set takes time multiple consideration set avoided accumulating sets inserted cand far list lookup insertion done time consider body outer loop second phase statements loop take 2 time order assess time loop note following fact fact 51 fixed j sigma algorithm encounters execution loop njf j different sets literal l selectable fa jf show let evidence w 2 l every l 2 w 2 f l every l 2 lit j must evidence w w serve evidence n encountered indeed suppose different sets unique selectable literals resp fa 2 evidence w implies either l 1 2 lit j l 2 2 lit j fact must hold verify suppose contradiction wlog l implies g f extensions consequently also extension l 11 contradiction proves follows 1 fl 1 obviously n gamma 1 sets 2 different 1 possible 6 lit j impossible hence 2 different 1 exists follows number encountered sets fact 51 bounded njf j resp jf j body loop computed time fa resp fa onjf maintaining counters subsequent tests whether literal selectable fa jf j 6 straightforward resp constant time inner loop done 2 time thus body loop takes onjf fact 51 onjf otherwise consequently fixed j sigma total onjf jnjf j n time spent whileloop fact 51 2 jf jnjf time since fact 51 implies nn 2 latter inserted cand thus fixed j sigma loop takes 3 jf time altogether body outer loop takes 3 jf since loop executed 2 ji sigma j jf j times follows second phase step 2 takes takes total onjt conclude similarly exploiting fact 51 second phase step 2 takes 2 jf steps 1 2 together take onjt proves lemma 2 remark selecting set maximum size removal cand whileloop rest ext plausible heuristics keeping running time short general organization cand maintenance selection stay within time straightforward similarly obtain symmetric result case disjunction lemma 55 restext correctly answers whether given pdbf f lit constrained extension clr1 runs time onn 2 jt main algorithm allextensions described algorithm store prefixes linear readonce formula string parentheses omitted redundant reinserted unambiguously technical convenience add x 0 front prefix example consider string representations proper prefixes fl represented algorithm allextensions input pdbf extensions f clr1 step 1 special treatment extension special treatment extension step 2 fl x 0 procedure allaux input pdbf f prefix fl linear readonce formula set available variable indices sets literals allowed decomposition output formulas flr1 extensions f 2 clr1 f fl prefix literal plus operator according lit lit step 1 expand fl conjunction step literal l 2 lit begin 0 n v l variable l v l longer available literal l decomposition complementary literal l output extension l begin expand fl l endftheng endfwhileg step 2 expand fl disjunction step literal l 2 lit begin 0 n v l variable l v l longer available literal l decomposition complementary literal l output extension l begin expand fl l endftheng endfwhileg 2 example provided appendix theorem 56 algorithm allextensions correctly outputs formulas extensions polynomial delay 6j j proof correctness algorithm shown induction jij delay consecutive outputs 5 jt correctly answers onjt j steps bodies loops steps 1 2 allaux take onjf j onjt j respectively 2 subsequent calls allaux yield output recursion depth bounded n recursive calls allaux made lead output checked using restext andor restext hence delay bounded 5 jt first last output happen within time bound result follows 2 observe 13 similar algorithm computing extensions cdh described however problem simpler since 31 unique form function cdh moreover set lit selectable literals resp set lit selectable literals may contain literal x opposite x conditions hold solving problem polynomial time much difficult needs insights present algorithm thus nontrivial generalization one 13 improvements allextensions made using appropriate data structures reuse intermediate results however remains see whether substantially better algorithm particular linear time delay algorithm feasible theorem 56 important corollaries corollary 57 polynomial delay algorithm enumerating unique prime dnfs extensions pdbf f clr1 resp c 1dl cnd c r proof theorem 34 prime dnf linear readonce formula obtained 2 time 2 denote cn class bf n variables c apply algorithm f members clr1 n hence corollary 58 polynomial delay algorithm enumerating unique prime dnfs c 1dl n cnd n c r transferred learning context obtain corollary 59 algorithm allextensions outputs hypotheses f 2 clr1 consistent given sample polynomial delay similar algorithms exist c 1dl cnd c r dh consequence sample almost identifies target function ie polynomially many different hypotheses consistent sample output polynomial time size another corollary theorem 56 checking whether pdbf f uniquely identifies one linearread function tractable corollary 510 given pdbf f deciding whether unique extension f 2 clr1 equivalently dh possible polynomial time learning gives us following result corollary 511 deciding whether given sample teaching sequence clr1 equivalently c 1dl cnd possible polynomial time example 51 consider pdbf f 001g algorithm allextensions outputs single extension corresponds 1decision list fact unique linearread extension f observe extensions f 2 clr1 form x 3 possible x 3 resp selectable literal since term x 3 x j implicant extension contains two vectors follows x 3 extension f clr1 2 6 conclusion paper considered relation decision lists classes boolean functions found number interesting unexpected relations 1decision lists horn functions intersections classes read oncefunctions results provide us syntactical semantical characterizations operationally defined class boolean functions vice versa operational syntactical characterization intersections wellknown classes boolean functions moreover allow us transfer results obtained one particular classes corresponding others way characterizations may useful deriving future results computational side shown problems 1decision lists relatives solvable polynomial time particular finding extension partially defined boolean function terms learning hypothesis consistent sample class feasible linear time enumeration extensions pdbf class terms learning hypotheses consistent sample possible polynomial delay furthermore unique extension problem ie recognition teaching sequence polynomial several issues remain research shown simple generalization characterizations 1decision lists terms classes boolean functions possible except single case would thus interesting see conditions generalization could possible observe inclusion c kdl c th k known 3 c th k denotes functions definable linearly separable function terms size k replace variables precise elegant description c kdl fragment within c th k would appreciated shown intersection readk functions apt moreover classes boolean functions fragments wellknown classes characterize kdecision lists would interesting know issues concern computational problems one possible extension polynomialtime delay enumeration result 1decision list extensions kdecision lists k 1 finding single extension possible polynomial time 31 avoiding multiple output extension rather difficult straightforward generalization algorithm hand intuitively terms size role makes checking whether items decision list redundant intractable general may thus expect general generalization algorithm k 1 possible acknowledgments authors thank martin anthony pointing equivalence clr1 c 1dl moreover greatly appreciate comments given anonymous stacs 98 reviewers previous version paper moreover thank leonid libkin pointing alternative derivation lemma 32 sending papers thank nick littlestone clarifying source exact learnability result c kdl r complexity theoretic hardness results query learn ing threshold functions computational learning theory specifying boolean functions labelled examples pac learning irrelevant attributes partial occams razor applications generating boolean double horn functions complexity timetable multicommodity flow problems complexity teaching teaching smarter learner criteria repetitionfreeness functions algebra logic lower bounds learning decision lists trees geometric separability boolean functions learning nested differences intersectionclosed concept classes complexity simple boolean formulas applications computational model teaching combinatorial characterization readonce formulae repetitionfree contact schemes repetitionfree superpositions functions algebra logic separatory sublattices subsemilattices learning irrelevant attributes abound new linear threshold algorithm horn extensions partially defined boolean function functions computed monotone boolean formulas repeated variables threshold logic applications induction decision trees learning decision lists learning helpful teacher teachability computational learning theory repetitionfree contact schemes theory learnable tr theory learnable generating maximal independent sets functions comuted monotone boolean formulas repeated variables complexity simple boolean formulas applications causeeffect relationships partially defined boolean functions learning nested differences intersectionclosed concept classes teachability computational learning computational learning theory computational model teaching combinatorial characterization readonce formulae exact transversal hypergraphs application boolean myampersandmgrfunctions complexity teaching specifying boolean functions labelled examples lower bounds learning decision lists trees teaching smarter learner bestfit extensions partially defined boolean functions double horn functions complexity theoretic hardness results query learning horn extensions partially defined boolean function learning decision lists induction decision trees learning quickly irrelevant attributes abound partial occams razor applications
use lemmas model elimination procedure model elimination procedure first proposed notion lemma put forth promising augmentation basic complete proof procedure lemmas used also discovered procedure proof run several implementations exist 1970s implementation explicitly examined lemma mechanism indifferent results report successful use lemmas using meteor implementation lemma device permit meteor obtain proofs otherwise obtainable meteor prover using lemmas wellknown challenge problems solved discuss several difficult problems including two challenge problems uniform generalpurpose provers meteor first obtaining proof problems selected simply show lemma device rather understand better thus choose problems widely different characteristics including one lemmas created automatically opposite normal behavior selection points potential problems lemma use biggest problem normally selection appropriate lemmas retain large number generated b introduction model elimination procedure defined 1960s 17 18 nearly coincident resolution procedure 22 little early work supported part nsf grants ccr8900383 ccr9116203 experimentation procedure received relatively little attention however basis slresolution procedure played historical role beginning logic programming major implementation completed early 1970s fleisig et al 14 provide direct comparison unit preference setofsupport refinement resolution wos et al 29 procedures implemented underlying inference tools individual wins found methods evidence prefer known refinements resolution forthcoming notion lemma introduced first papers implemented fleisig et al resulting indifference usefulness paper included statementthe use lemmas usually detrimental although short refutations obtained using lemmas poor performance due lack selection rules lemmas aggravated depthfirst nature search 14 p 135 paper strongly refute conclusion paper regarding value lemmas within report results date obtainable within framework use lemmas theorems proven include yet provable resolution techniques understand notion direct competition resolution oversimplistic procedure tends relatively well nonhorn problems resolution methods employed focused unlike chess theorems diverse lot different proof methods may excel different areas wellknown many research area idea kept alive work mark stickel notably stickel exploited fact extension sldresolution prolog develop prolog technology theorem prover pttp 24 25 late 1980s almost simultaneously three groups took one step building architecture warren abstract machine wam developed prolog logic programming community extended parallel machines projects parthenon cmu 9 partheo munich 23 meteor duke 4 3 munich 16 duke efforts included sequential provers also work reported implemented one meteor family provers changed 20 years makes lessons fleisig et al paper invalid part fair number things maybe important wam architecture ideas also important use iterative deepening introduced stickel sophisticated implementation exploiting wam ideas vastly powerful yet cheaper computers careful use techniques restrict lemma creation use look depth three examples theorems proven use lemmas would otherwise proved using two theorems theory continuous functions one collection three challenge problem 1960s solved automatically two three latter challenge problems solved weak fully automated mode initial restructuring problem done force generation lemmas done splitting problems two six cases respectively without knowledge problem solution details presented later mention problem subsequently solved strong fully automated mode semantic hyperlinking prover 11 knowledge prover succeeded problem noninteractive mode purpose paper look indepth nature lemma use papers 5 3 contain results meteor standard problems automated theorem proving atp community omit listings example astrachan stickel paper 5 discussing caching includes two tables results brief discussion lemma use caching applicable examples treat model elimination procedure linear input procedure one parent clause preceding clause clause input clause key property sldresolution allows compilation prolog programs elegantly implemented wam architecture use architecture structure also enjoy high inference rate however like prolog suffer high search redundancy due depthfirst search mode wam architecture use iterative deepening rather pure depthfirst search however lemmas shorten proofs thus reducing redundancy show example compression proof achieved lemma use striking gain occurs real vs toy problems note version restriction resolution 11 correspondence resolution version linear input procedure except restricted ancestor resolution operation resolution two deduced clauses necessary see toss procedure 19 1 thus procedure regarded encoding toss resolution restriction using 2sorted logic framed unframed literals noted strictly speaking resolution procedure highlighted fact linear input resolution complete small extension horn clause logic whereas complete firstorder logic paper organized follows sections 2 3 briefly describe proof procedure realization procedure meteor section 4 section 5 section 6 describe successful application lemmas three theorems none proved without lemmas using conclude short summary section 7 2 model elimination procedure like resolution model elimination refutation procedure formula refuted presented conjunctive normal form skolem functions 1 toss procedure corresponds slightly different procedure 2 none problems yields proof less 24 cpu hours using vanilla without lemmas used eliminate existential quantifiers see 10 19 details formula preparation 19 contains full description procedure view clauses sets literals formula set clauses corresponding entity derived clause resolution derived chain ordered list literals literal one two classes aliteral bliteral currently defined two basic operations 3 extension reduction basic operation extension like resolution operation retention one literals resolved upon retained literal promoted literal intuitively aliteral type ancestor literal give succinct presentation operations lemma mechanism followed example appendix gives expanded presentation procedure first chain deduction ordered input clause literals classified bliterals general oversimplify reference occurrences literals particular refer literal successive chains literal fact later literal may instantiation parent literal simplification cause confusion extension operation glues shortened input clause ordered user choice left current chain leftmost bliteral chain unifies complement literal input clause new chain instantiation current chain unifier unifying literal input clause dropped unifying literal leftmost literal current chain promoted aliteral newly added literals bliterals literals retain classification current chain 4 leftmost aliterals removed back leftmost bliteral reduction operation removes leftmost bliteral current chain unified complement aliteral chain new chain instantiation current chain unifier leftmost bliteral missing leftmost aliterals removed back leftmost bliteral creation lemmas occurs leftmost aliterals removed end extension reduction operations use unit lemmas although general notion lemma allowing multiliteral lemmas defined 19 lemma chains created complements removed aliterals aliterals produce lemma create unit lemmas eligibility mechanism simple reduction operation aliteral complements leftmost bliteral reduction aliteral reduction step aliterals strictly left reduction literal marked every aliteral newly created clause inherits mark parent aliteral aliteral unmarked time removal 3 early papers 17 18 three operations traditionally chains grew right prolog conventions replacing leftmost literal influenced recent implementations choose follow convention used meteor implementation creates lemma generated lemmas retained retention depends number criteria discussed later control user lemma retained acts exactly unit input clause regarding extension lemmas subject restrictions modifications shared input clauses however refutation figure 1 adapted 19 2 illustrates mechanisms 1 px qy input clause 2 px ry input clause 3 pa ry input clause 4 qx pa input clause goal chain begin proof 5 py qx pa extension 1 variable renaming clause 1 6 rz py qx pa extension 2 variable renaming clause 2 7 pa rz py qx pa extension 3 8 rz pa qx pa prior removal aliterals pa reduction unit lemmas formed pa 9 2 extension lemma pa proof completion lemma mechanism used 9 ry pa extension 3 10 px ry pa extension 2 reduction figure 1 refutation figure 1 unit lemmas created final stage reduction yields chain pa step 8 reduction creates aliteral pa parent py subsequent removal aliterals pa qx create lemmas removal rz cannot create unit lemma figure 2 present proof trees associated example one proof tree proof without lemma use one incorporates lemma use proof tree clause used extension represented clause number goal clause listed root proof tree literals clause represented child nodes clause clause actually appropriate chain clause used extension literal named reduction shown backwards arrow node labeled rn nth reduction arc ancestor node reduction labeled rn indicate aliteral reduction proof tree gives sufficient information reconstruct proof without backtracking instantiations variables determined tracing proof using proof tree proof tree right side figure 2 method displaying lemma use also representing proof tree without lemma use leftmost box encloses subdeduction defines lemma occurrences box deduction indicate positions lemma used box would replaced single node subdeduction box provides subtree could occur lemma device used note tree left shows slightly different deduction actually occurred lemma device used reporting device used later paper deductions considerably larger size give graphic feeling saving proof size realized lemma use reduction arrow boxes somewhat confusing instance reduction aliteral creates calls lemma right side box reduction arrow refers back literal calls lemma valid aliteral reduction lemma replaced deduction3 without lemma lemma figure 2 proof trees 3 meteor architecture provide brief description meteor architecture full description found 2 meteor written c runs workstations parallel distributed computing environments search engine used sequential parallel setting discussion architecture meteor emphasis parallel distributed modes appears 3 iterative deepening used ensure completeness search strategy cases meteor designed conform principles warren abstract machine wam 1 de facto standard prolog implementations ever clauses compiled wam code data structure interpreted runtime either sequential parallel search engine several different depth measures used bounding potential proof iterative deepening search report four measures described table 1 measure description inf inference depth bound total number inferences proof tree alit aliteral depth bound depth proof tree roll rollbackreduction combination inf alit preference given reductions dweight weight depth weight clauses per branch proof tree table 1 depth measures employed meteor measures inf alit commonly used provers default measures pttp setheo respectively bound entire proof tree use inf ensures minimallength proof terms extensions reductions found alit also used first implementation 14 point proof search one tell current depth respect alit measure counting number aliterals current chain whereas inf measure total number extensions reductions needed derive current chain course one include subsearches removed backtracking note depth proof tree corresponds number aliterals longest chain proof depth minimal alit depth proof tree found example deduction end last section lemma used inf 7 alit 3 mean proof found depth stated depth bound less stated would permit proof shown found seen given derivation consulting appropriate proof tree note proof tree inf measure determined counting nodes proof tree excluding root alit determined counting depth proof tree root depth 0 deduction using lemma inf 5 alit 3 latter depth assume left branch searched first right branch searched first alit 2 roll employed depth calculated inf regarding extension successful reduction operation results rolling back depth depth force aliteral reduction introduced chain bliteral measure discovered accident clear intuition definition simply noted worked well many cases one observation regarding success charges extension unit clauses eg lemmas whereas alit charge yet gives added resources explore consequences reduction alit measure indeed often resources alit gives example deductions last section roll 4 lemma use lemma use none measures uniformly superior others appear simple syntactic criteria used determine measure appropriate see 2 dweight used conjunction depth measures rather replacement input clauses annotated integral weight contributes weight chain clause used weight chain sum weight clauses whose literals appear chain dweight used incremented iterative manner depth bounds incremented iterative deepening search minimum value theorem first consider problem lemmas effective theorem consider minimum value theorem minvt also known atp literature am8 27 theorem minvt continuous function real closed interval b attains minimum interval table 2 give readable rendition axioms minvt numbers left refer clause numbers axioms given 27 order submitted meteor figure 3 give axioms submitted meteor clause numbering relates input clause counterpart table 2 nocontra suppresses contrapositive dichotomy axiom axiom 1 generated clearly needed costly axiom include dichotomy axiom line 16 naming skolem functions permit self nesting semantics problem made likely function needed nested figure 4 figure 5 present proof tree format proof found meteor proof tree given coded form lemmas labeled unwound full structure tree apparent figure 4 left shows proof actually discovered meteor proof involving seven input clauses four lemmas using depth measure inf would proof depth 10 actually took inf depth 12 done inf depth 11 discover proof lemmas used proof required depth discovered figures 4 right 5 present full proof inference labeled lemma label clause number dotted arrows bottom proof tree right figure 4 link appropriate subtrees figure 5 node labels beginning l refer lemmas numbering determined proof recovery procedure order lemma generation node labels refer input clauses number axioms total order 1 x x 2 x z roughly symmetry antecedent 3 x l minimum point al 4 l 5 l b point greater l smaller point smaller fvalue 79 x x hx smallest point ab st 1013 b x exists point kx ab negation theorem conclusion 141517 x table 2 axioms minimum value theorem minvt made point previously lemmas often discovered earlier failed parts search tree evident proof trees example top lemmas used proof invoked lemmas must established proof found particular note lemmas l2 l3 l4 labeled trees figure 4 derivations continuing figure 5 lemmas used proof lemmas clearly discovered time complex lemmas obtained note mean discovered earlier proof tree iteration lemmas retained successive iterations thus information later tree used early branches succeeding iterate general iterative deepening gives breadthfirst form search within search depthfirst effectiveness lemmas dramatically made noting depth proof given inf depth measure used employed use lemmas 600 search depth well beyond capability implementation prover know pointed resolution exactly kind compres sion resolvents lemmas also sense retaining intermediate results indeed noted unit lemmas resolvents tree portions reduction used difference noted lemmas nocontra 1 pxy pyx 2 pxypyz pxz 3 pxy pyx pfxfy 4 pal 5 plb 7 pax pxb paqx pxl 8 pax pxb pfxfqx pxl 9 pax pxb pqxx pxl 11 pax pxb phxb 12 pax pxb pfhxfx 13 pax pxb pay pyb pfyfx phxy 14 pax pxb pakx 15 pax pxb pkxb 17 pfxfkxpaxpxb figure 3 input clauses minimum value theorem minvt optional regarding completeness mean optional regarding realizing actual proof case demonstrates however priori concerned retain almost every nonredundant intermediate result achieve much trimming first proof obtained minvt taking 171 secs created retained 593 lemmas making 393000 successful inferences constraint besides unit lemma constraint universal us still con straint termlength stipulation 10 lemmas disallowance iterative nesting function speed considerations termlength check done term replacing variable substitution occurrence thus literal may contain many constant function letters bound indicates check done literals new chains well lemmas applied lemmas note way nesting restriction applied almost totally safe first run functions f skolem functions one never gain nesting nesting f makes heuristic sense given problem nature sensitivity term length quite modest termlength limited number lemmas retained problem limit nesting function symbol necessary order constrain number lemmas generated always case however thus illustrate point trade search input clauses less retention goal goal figure 4 toplevel proof am8 partial unrolling proof intermediate results many strategies resolution employ 5 wang challenge problem usual case generate many lemmas seek ways trimming lemmas without removing helpful proof therefore interesting situation encounter problem lemmas produced situation arose pursued challenge problem set fully proven automated theorem prover knowledge 1965 hao wang put forth several challenge problems automated theorem provers problems beyond capability theorem provers time 26 moreover proved difficult automated provers time problem set consider labeled exq1 exq2 exq3 wang treated section examples quantification theory although wang suggests intuitive understanding examples think f membership relation ffl suggestion achieve purpose us state three problems formulas refuted table 3 followed figure 6 one set axioms used meteor figure 6 replaces constant n axioms latter purely historical reasons problem exq1 solved number systems suspect also known wos 31 28 solved otter 20 one numerous problems circulate labels meaningful wos 31 easily determined provers solved figure 5 proof am8 lemmas unrolled exq1 conjunction following formulas unsatisfiable 1 6 n 2 n 6 k 3 4 5 exq2 replace 2 3 1 2 exq3 remove 1 exq2 table 3 axioms exq problems first problem otter solved exq2 exq3 although itp sense ancestor otter solve exq2 solved preconditioning manner presentation problem broke cases force generation lemmas previously mentioned semantic hyperlinking theorem prover chu plaisted subsequently provided fully automated proof first knowledge 11 problem particularly well suited prover highly nonhorn like logic puzzle turns poorly structured us high number reductions blocks production unit lemmas proof wos31 exq1 obtained using alit without breaking theorem cases using dweight reduces time onethird weighting employed note exq3 solution contains exq1 case terms inequalities three basic constants exq1 use alit case 6 exq3 cases use roll interesting 8 pyvpvyrympymrvmrvy 21 rxyrfxfy 9 rgybrybpyb 22 rxyrgxgy figure input clauses exq2 case 1 cases solved using roll easily solved cases using alit first ran exq2 lemmas generated proof obtained indeed overnight run 14 hours yielded 6 lemmas con trast exq1 87 lemmas created one successful run experience success lemmas made us consider immediately lemmas could generated unit lemma generation inhibited reductions decided introduce unit clauses allow frequent proof branch termination unit extension rather reduction although understand proof theorem still dont seem apparent exq1 exq2 effect dealing cases equality inequality three con stants kmn broke problem cases listed table 4 able prove theorem note case definition exq2 follows immediately axioms added define exq2 statistics cases provided table 4 exq2 cases case case exq3 cases case case case case case case problem depth time inferences lemmas measure secs case 1 roll dweight 4562 14462880 47 exq2 case 2 roll 46 12683 26 case 1 roll 108 170185 67 exq3 case 2 roll 14 19916 104 case case exq3 case 5 roll 9 12741 26 case table 4 cases statistics exq1 exq2 exq3 reported table 4 exq2case 1 used dweight although result obtained roll alone twice time 9784 sec double inference total 29886276 inferences weights entries seen end input clause interesting view case use weights weights entered prior weighted run using algorithm accounts clause length primarily high penalty known problem axioms equality axioms small adjustment general number free variables clause major gain using weights control equality axioms comment aspects meteor listing axiom set figure 6 lex predicate used order constant symbols use demodulation skolem predicate lists skolem functions mentioned previous section neither restriction used runs reported section demodulation used reported runs obtained lemmas use demodulation useful option problem initially specified demodulation could used input axioms seen differ small ways natural translation wang problem specification besides replacement b n appearance everywhere example done experiments axiom set obtained 27 tracing origin problem preparation paper chosen accept variance original problem statement since 27 become standard source problems including problem set feel discovered new technique breaking problems cases generate useful lemmas may even pay many lemmas generated severely limiting natural lemmas produced yield proof trying generate new lemmas case method clear yet automatable technique tries useful tried see discovery proof exq1 could speeded introduction cases however runs exq1 using added cases resulted increased time proof seen technique forcing lemma creation fruitful widely applicable idea awaits experience 6 bledsoe challenge problem third problem consider actually collection variants problem investigated bledsoe starting early 1970s using natural deduction style theorem prover special heuristics limit theorems bledsoe boyer 7 proved sum two continuous functions limit point limit sums point assigned label lim problem theorem since proven str prover hines bledsoe 8 15 general theorem prover special devices handling inequalities real line bledsoe recognized difficulty theorem uniform provers issued challenge set problems based lim problem 6 five different firstorder axiom sets designated challenge set two make explicit use equality predicate one formulation requiring use paramodulation another rule buildsin equality using meteor able prove first three formulations challenge problem lack full builtin equality mechanism mechanism paramodulation precludes attempt fifth formulation problem fourth formulation using equality without strong equality restriction simplification mechanism stronger unadorned demodulation mechanism lemmas much meteor point first three formulations use single predicate also used minvt theorem discussed section 4 several uniform provers obtained third formulation challenge problem meteor first achieve success level knowledge see digricoli 13 12 regarding proofs fourth fifth formulations done partially interactive mode purpose report experience meteor lemma use problem set third formulation hardest problem meteor succeeded hardest mean strongest set restrictions ever used needed obtain proof one proof requires 20 hours sun sparcstation 2 shorter proofs required insight proof count legitimate datapoints regarding capability meteor fully automated theorem prover proof attempts using proof knowledge used test various constraints shorter time periods make clear experiments use proof insight results presented figure 7 give clauses used three formulations roughly order meteor took input read lefttoright topto bottom clause numbers original presentation bledsoe 6 meteor normally reorders clauses number literals preference unit clauses attention degree generality also considered item n end clause assigns clause weight n discussed later give original nonclausal formulation clause set meaning clauses selfevident constants interpreted predicate lt denotes function ab denotes absolute value d1 d2 skolem functions regions see ha onehalf pl ng negative xs skolem function exception points delta regions min course minimum clauses 3 4 give continuity condition function f g respectively example clause 3 direct translation equation 1 clause 5 clauses 12 clause 12 clause 8 clause 81 clauses 34 clause 6 clause 91 clause 101 clause 92 clause 102 clause 911 clause 1011 clause 103 clause 113 ltx0lty0ltminxy06 ltxhaz ltyhaz ltplxyz6 clause 14 clause 15 clause 71 clause 72 figure 7 clauses bledsoe challenge problems goal clauses 71 72 give negation theorem assert conjunction clause 6 example clause 71 states clause 71 difficult goal achieve need use triangle inequality however change related need clause 81 significant changes formulation 2 much harder formulation 1 introduction dichotomy axiom axiom 14 especially transitivity axiom axiom 15 along axiom changes min makes formulation 3 considerably harder problem list three formulations clause set study third formulation first two problem variations meteor could handle relatively straightforwardly clauses three formulations formulation 1 clauses 1 2 3 4 5 6 72 911 1011 103 113 12 goal clause 72 formulation 2 clauses 1 2 3 4 5 6 71 81 911 1011 103 113 12 goal clause 71 formulation 3 clauses 1 2 3 4 5 6 71 8 91 92 101 102 113 12 14 15 goal clause 71 include data runs first two formulations little dis cussion see table 5 lemmaizing run ground lemmas stored ground subgoals extended lemmas reasons important combined restrictions labeled ground generalizations thm search parameters time secs number inferences alit dweight lemmaizing z one 12227 2854399 394 14682 2637 36232 two 38598 12294133 976 43980 102429 11682410 yusing alit dweight zground generalizations table 5 time inferences formulations one two also give proof tree second third formulations figure 8 proof second formulation left dotted boxes surrounding subtrees denote lemma occurrences discussed 61 third formulation list proof devices restrictions used tackle third formula tion many used experience limited others common comment general experience 1 use combination depth measures alit dweight tried often usually obtaining considerably improved performance one times proof obtained without device oversimplification proof obtained using combination roll dweight optimal limits parameters considerably timeconsuming alit dweight general attempts tried 2 ground lemmas stored used instantiation calling goal occurs trims branching factor one node 6 101 figure 8 proof trees second third formulations 3 lemma literals limited number symbols allowed 4 number occurrences specific input clause allowed proof controlled meteor sensitive parameter could set uninformed guess realize proof noproof knowledge proofs meteor increments upper bound clause occurrence count function current depth according ratio set user ratio needed moderately insensitive user setting terms obtaining proof time needed realize proof strongly sensitive ratio 5 literals containing terms certain forms retained exclusions range obvious redundancies possibly strong exclusions results several combinations exclusions 6 reduction restricted bliterals whose source transitivity axiom restriction natural sounds reasons stated 7 goal clause reordered usual rule ordering two literals binary choice normally would expand constrained literal first significant deviation rarely rotate literals goal clause yet case proof obtained using usual literal literal first expanded expand depth measure dweight utilizes clause weight appears appended end input clause depth measure functions alit except clause weight used increment count instead unit increase used alit depth measure may used conjunction measures proof development terminates appropriately depth count exceeded one gets conjunction depth criteria weights used clauses guessed changed following prescribed pattern adjustment strict formula occurred example min axioms constitute onethird axioms likely constitute onethird clauses used proof weighted higher initial guess use proof knowledge considered nonsensitive constraint controlling number occurrences input clause necessary proof succeed actuality control dichotomy transitivity crucial experiments show make quite safe guesses upper bounds axioms transitivity dichotomy axioms limited optimal count solved problem iterative incrementing clauses effectively equivalent binding dichotomy transitivity clauses 14 15 shown line 6 table 7 indicates limits clause use optimal plus twenty except dichotomy transitivity iterative deepening clause limits employed user still must pick ratio clauselimit increment depth bound increment less sensitive guessing clause count data line 7 table 7 increases count one every two levels increase alit count literals excluded retention certain terms created upon unification action chain level lemma level thus effect completeness small avenue taken large number proof branches explored seem expand along questionable routes dealing terms either unlikely occur proof redundant terms terms excluded range clearly safe exclusion perhaps quite risky stress obtain proofs theorem excluding safe exclusions performance definitely enhanced risky exclusions table 6 list exclusions used 1 d1d2x 2 d2d1x 3 d1d1x 4 d2d2x 5 d1plxy 6 d2plxy 7 minminxyz 8 minxminyz 9 13 minabxy 14 minplxyz 15 minxplyz 16 minxx 17 table terms excluded bledsoe challenge problems used four classes risk exclusion heuristic safe safe risk risk safe category nested skolem functions terms d1d2x also included term minx x still considered safe term haabx abhax excluded likewise included slightly riskier perhaps symbol count increased limit total number symbols allowed per literal limit used either 11 15 equally used 20 symbols still allowed proof others table 6 riskier discuss next paragraph line 3 table 7 gives data run using safe exclusions phrase ex 14 16 means terms 14 16 excluded terms run lines 4 5 provide data using subsets terms table 6 column labeled attinfs gives attempted inferences potential inferences identified prior unification attempt run statistics description time infs attinfs leminfs run sec 1 optimal termsize15 27858 23146 66485 115 590 2 optimal termsize20 23095 23052 66346 153 601 3y safe ex 1416 66609 65871 196968 186 1136 4y ex 14710121416 49206 47861 143409 133 1037 5y ex 1491016 64368 61499 186207 180 1124 limits 7 iter deepz 152077 129419 355250 181 2443 ytermsize limit 15 symbols zsparc elc increase limits 1 every stage table 7 altering limits extensions third bledsoe problem briefly consider riskier exclusions considered excluding similar terms may seem risky noticed proliferation terms led asking needed note terms type could still arise instantiation variables exclusion means unification cannot instantiate variable excluded term illustrate goal gammaltmine0 e0 minx e0 refuted exclusion terms table 6 obtaining proof term minmine0 e0 e0 generated x goal instantiated e0 thus excluded terms appearance forbidden use term embeds excluded term substitution instance reader see first extending clause 92 followed extension clause 91 even though completeness endangered reasonable action take type step may needed get difficult theorems adverse endangers completeness exclusions risky developing thesis basic hidden user play lemmas give table 8 data runs exclusions note exclusions needed proof run statistics description time infs attinfs leminfs succ run sec 1 limits 23324 23144 66994 2 roll limits 38663 37928 116069 71 1081 33 3 ex 117 38144 38450 116421 71 987 20 4 ex 110121618 23533 23709 68196 5 ex 1818 43228 38601 110147 75 664 22 6 ex 14781618 42101 37633 107665 75 659 22 7 ex min terms 26529 31290 89898 8y ex 14710121416 49206 47861 143409 133 1037 21 9y ex 1491016 64368 61499 186207 180 1124 12 10y ex 1416 66609 65871 196968 186 1136 12 14z trmsize15 27858 23146 66485 115 590 48 ytermsize zotherwise line 1 table 8 performance characteristics third formulation reductions restricted bliterals transitivity axiom actually came noting simpler proofs formulations 1 2 use reductions puts category cheating standards even though based knowing proof formulation three likely real world simpler versions problem around break heuristics even though arrived guess reason guess way similar situations guess would make similar situations reason seen many proofs nonhorn clauses nevertheless reduction needed initial tries tells us problem hard would first try without reduction would try allowing transi tivity often use first time problem strongly benefited restriction simply made observation reduction occurs problems experience needed tell whether pattern suggested really holds interchange literal order within goal hardest justify uniform grounds works way way usually starting instantiated literal first winning strategy normal ordering works first two formulations proof obtained without lemma use starting instantiated literal proof impossible find without lemmas literal ltd 0 expanded first situation reverses even easier formulations lemmas tried reason clear proof tree figure 8 see one follows second literal right branch key lemma dotted line box reached alit depth 8 pursuit branch requires depth 13 recall alit proof tree depth reader check directly counting branch lengths proof trees figure 8 note variable goal instantiated key lemma follows gammaltmind1hae0 d2hae0 0 instantiation gives found typical proof found analysis texts given epsilon ffl 0 corresponding delta minimum deltas ffi 1 corresponding half given epsilon min axioms necessary discovering instantiation however somewhat surprisingly min axioms removed input clause set proof obtained less 600 seconds limits clause use however case ltd1hae00 ltd2hae00 deduced giving less information provided min axioms included significantly less time summary plaisted 21 shown unit lemmas caching one goalsensitive procedures polynomial search time within propositional horn clause setting suitable sense result assumes used iterative deepening search normal mode meteor elsewhere see astrachan stickel 5 data given use unit lemmas caching horn clause domain presented examples nonhorn setting caching implemented easily designed demonstrated unit lemmas still effective considered examples illustrating different situations nearly ideal insufficient lemma supply situation case analysis provided needed lemmas barely adequate lemma supply one deep lemma used even created correct proof development wide scope situations believe demonstrates usefulness unit lemma addition model elimination procedure hope achieve enough knowledge lemma use henceforth view basic procedure black box collection lemmas data user views manipulates appendix give formal definition model eliminationme procedure used meteor fuller treatment procedures given 19 chain sequence literals literal aliteral bliteral chain ordered clause two types literals input chain chain bliterals obtained placing ordering clause conjunctive normal form cnf formula tested unsatisfiability clauses cnf formula called input clauses input clause n literals cnf formula must represented least chains literal input clause leftmost least one input chain empty chain denoted 2 l leftmost literal chain c write c gamma flg represent chain c leftmost occurrence l removed occasion remove literal leftmost literal sequence literals leftmost latter case regard literals removed one time literal becomes leftmost intermediate chain chain preadmissible iff 1 complementary literals separated aliteral 2 bliteral left identical aliteral 3 aliteral identical complementary another aliteral chain admissible iff preadmissible leftmost literal b literal practice sometimes enforce condition 2 user option let c 1 admissible chain let c 2 variabledisjoint input chain exists mostgeneralunifiermgu oe leftmost literal l 1 c 1 complement leftmost literal l 2 c 2 extension operation extends c 1 c 2 form chain c 3 promoting leftmost literal c 1 oe aliteral placing c goe left literals c arranged order user chooses literals c 3 oe inherit type parent literal c 1 c 2 noted exception promoted aliteral chain results preadmissible extension defined chain results preadmissible chain aliteral leftmost ie nonadmissible leftmost aliterals removed back leftmost bliteral yields admissible chain let c admissible chain exists mgu oe leftmost literal l c aliteral c reduction operation yields chain c gamma flgoe chain results preadmissible reduction operation defined chain results nonadmissible preadmissible chain aliterals left leftmost bliteral removed derivation sequence chains composed input chain first goal chain followed derived chains either extension preceding chain input chain reduction preceding chain refutation deduction empty chain lemmas optional property created aliterals removed transformation preadmissible admissible chain lemma informal label either lemma clause results process lemma creation chains created clause consider unit lemmas distinction pedantic lemma clause one chain created consisting single bliteral regarded ordered clause lemma chain treated input chain generation passes filters may eliminate generally usercontrolled options lemma clause complement aliteral removed literal eligible create lemma eligibility criterion exactly stated body paper repeated completeness definition correct unit lemmas reduction operation aliteral complements leftmost bliteral reduction aliteral reduction step aliterals strictly left reduction aliteral marked every aliteral newly created clause inherits mark parent aliteral aliteral unmarked time removal creates lemma clause r investigations model elimination based theorem prov ing meteor exploring model elimination theorem proving meteors high performance theorem provers using model elimination caching lemmaizing model elimination theorem provers challenge problems elementary calculus computer proofs limit theorems variable elimination chaining resolutionbased prover inequalities parallel theorem prover nonhorn clauses symbolic logic mechanical theorem proving semantically guided firstorder theorem proving using hyperlinking rue theoremproving system complete set limchallenge problems implementation model elimination proof procedure central variable strategy str mechanical theorem proving model elimination simplified format model elimination procedure automated theorem proving logical basis otter 20 search efficiency theorem proving strategies machineoriented logic based resolution principle partheo high performance parallel theorem prover prolog technology theorem prover implementation extended prolog compiler prolog technology theorem prover implementation extended prolog compiler hierarchical deduction efficiency completeness set support strategy theorem proving tr ctr allen van gelder fumiaki okushi lemma cut strategies propositional model elimination annals mathematics artificial intelligence v26 n14 p113132 1999 fumiaki okushi allen van gelder persistent quasipersistent lemmas propositional model elimination annals mathematics artificial intelligence v40 n34 p373401 march 2004 allen van gelder autarky pruning propositional model elimination reduces failure redundancy journal automated reasoning v23 n2 p137193 august 1999 allen van gelder fumiaki okushi propositional theorem prover solve planning problems annals mathematics artificial intelligence v26 n14 p87112 1999
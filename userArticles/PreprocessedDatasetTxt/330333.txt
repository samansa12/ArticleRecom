probabilistic loop scheduling applications uncertain execution time abstractone difficulties highlevel synthesis compiler optimization obtaining good schedule without knowing exact computation time tasks involved uncertain computation times tasks normally occur conditional instructions employed andor inputs tasks influence computation time relationship tasks represented dataflow graph node models task associated probabilistic computation time set edges represents dependencies tasks research study scheduling optimization algorithms taking account probabilistic execution times two novel algorithms called probabilistic retiming probabilistic rotation scheduling developed solving underlying nonresource resource constrained scheduling problems respectively experimental results show probabilistic retiming consistently produces graph smaller longest path computation time given confidence level compared traditional retiming algorithm assumes fixed worstcase averagecase computation times furthermore considering resource constraints probabilistic environments probabilistic rotation scheduling gives schedule whose length guaranteed satisfy given probability requirement schedule better schedules produced algorithms consider worstcase averagecase scenarios b introduction many practical applications interface systems fuzzy systems articial intelligence systems others required tasks normally uncertain computation times called uncertain probabilistic tasks brevity tasks normally contain conditional instructions andor operations could take dierent computation times dierent inputs dynamic scheduling scheme may considered address problem however decision runtime scheduler depends local online knowledge may give good overall schedule although many static scheduling techniques thoroughly check best assignment dependent tasks existing methods able deal uncertainty therefore either worstcase averagecase computation times tasks usually assumed assumptions however may applicable real operating situation may result inecient schedule iterative applications statistics uncertain tasks dicult collect paper two novel loop scheduling algorithms probabilistic retiming pr probabilistic rotation scheduling prs proposed statically schedule tasks nonresource assume unlimited number target processors resource constrained assume limited number target processors systems respectively algorithms expose parallelism probabilistic tasks across iterations well take advantage inherent statistical data system without resource constraints pr applied optimize input graph ie reduce length longest path graph probability longest path computation time less equal given computation time c greater equal given condence probability resulting graph implies schedule nonresource constrained system longest path computation time determines schedule length hand prs algorithm used schedule uncertain tasks xed number multiple processing elements produces schedule length given graph incrementally reduces length probability less previous length greater equal given condence probability order compatible current high performance parallel processing technology assume synchronization required end iteration parallel computing style also known synchronous parallelism 10 19 pr prs take input application modeled probabilistic dataow graph pg generalized version dataow graph dfg node corresponds task collection statements set edges representing dependencies tasks determine schedule loopcarried dependences dependency distances tasks dierent iterations represented short bar lines corresponding edges since computation times nodes either xed varied probability model employed represent timing tasks figure 1b shows example pg consisting 4 nodes note graph models code segment presented figure 1a example pg corresponds 1 2 code segment two bar lines edge nodes represent dependency distances two nodes computation time nodes c known xed 2 time units code uncertainty occurs computation nodes b assume arithmetic operation assignment operation take 1 time unit furthermore computation time comparison random number generating operations assumed negligible hence may take either 4 2 time units execute node b put another way 20 time 51 256 statement b 2 executed node b take 4 time units otherwise node b takes 2 time units b 3 one operation likewise approximately 25 64 256 node takes 4 time units 75 take 2 time units entry figure 1c shows probability associated nodes possible computation time probability distribution taking account varying timing characteristics proposed technique applied wide variety applications highlevel synthesis compiler optimization code segment b pg time nodes c timing information retimed pg figure 1 sample code segment corresponding pg computation time retimed graph considerable research conducted area nding schedule directedacyclic graph dag multiple processing systems note dags obtained dfgs ignoring edges containing one dependency distances many heuristics proposed schedule dags eg list scheduling graph decomposition 11 13 etc methods however consider neither exploring parallelism across iterations addressing problems probabilistic tasks instruction level parallelism ilp scheduling trace scheduling 9 used globally schedule dags rearraging operations graphs percolation scheduling used development environment 1 microcode compaction ie parallelism extraction horizontal microcode nevertheless graph model used techniques ect uncertainty node computation times class global cyclic scheduling software pipelining 16 used overlap instructions whereby parallelism exposed across iterations technique however expands graph unfolding unrolling 22 resulting larger code size loop transformations also common techniques used construct parallel compilers restructure loops repetitive code segment order reduce total execution time schedule 2 3 20 27 28 techniques however consider target systems limited number processors task computation times uncertain modulo scheduling 2426 popular technique compiler design exploiting ilp loops results optimized codes framework species lower bound called initiation interval ii start strives schedule nodes based knowledge much research introduced improve andor expand capability modulo scheduling example research presented improved modulo scheduling producing schedules considering limited number registers 7 8 21 17 combination modulo scheduling loop unrolling introduced applied impact compiler 4 ilp approaches however limited solving problems without considering uncertain computation times probabilistic graph model research considers uncertainty inherit computation time nodes ku de micheli 14 15 proposed relative scheduling method handles tasks unbounded delays nevertheless approach considers dag input explore parallelism across iterations furthermore even statistics computation time uncertain nodes collected method exploit information framework able handle imprecise propagation delays proposed karkowski otten 12 approach fuzzy set theory 29 employed model imprecise computation times although approach equivalent nding schedule imprecise tasks nonresource constrained system model restricted simple triangular fuzzy distribution consider probability values scheduling resource constraints rotation scheduling technique presented chao lapaugh sha 5 6 extended handle multidimensional applications passos sha bass 23 rotation scheduling attempts pipeline loop assigning nodes loop system limited number processing elements implicitly uses traditional retiming 18 order reduce total computation time nodes along longest paths also called critical paths dfg words graph transformed way parallelism exposed behavior graph preserved paper rotation scheduling technique extended deal uncertain tasks since computation time node pg random variable total computation time graph also random variable concept control step synchronization tasks within iteration longer applicable schedule conveys execution order pattern tasks executed functional unit andor dierent units order compute total computation time ordering probabilistic taskassignment graph ptg constructed ptg obtained pg nonzero dependency distance edges ignored node assigned specic functional unit system ptg also contains additional edges called owcontrol edges connection u v means u executed immediately v using functional unit note nonresource constrained scenario ptg dag portion pg subgraph contains dependency distance edges let us use example figure 1b assume term longest path computation time entails nd ing maximum summation computation times nodes along paths contain dependency distances examining possible longest paths graph likely 60 longest path computation time less equal 8 details value determined given section 3 note nodes graph assigned worstcase values longest path computation time schedule length nonresource constrained systems graph 10 one might wish reduce longest path graph nearly cases example reducing chance clock period greater 6 applying probabilistic retiming longest path computation time graph may improved respect given constraint modied graph retiming shown figure 1d longest path computation time graph less equal 6 20 chance need schedule nodes pg two homogeneous functional units possible ptg constructed shown figure 2a since input graph cyclic execution pattern ptg repeated synchronization applied end iteration shown figure 2a solid edges ptg represent zero dependency distance edges called dependency edges input graph see figure 1b gure nodes b assigned pe 0 node c bound pe 1 note implicitly executed therefore direct edge original input graph omitted corresponding static schedule shows one iteration execution pattern shown figure 2c ptg b initial execution pattern c schedule figure 2 example ptg corresponding repeated pattern static execution order resulting longest path computation time ptg less 9 units 90 certainty longest path timing probability also known schedule length resource constrained systems improve resulting schedule length applying probabilistic rotation scheduling algorithm pg ptg case algorithm rst selects root node rescheduled one dependency distance incoming edges node moved outgoing edges figure 3a shows resulting transformation graph pg new graph used reference later update ptg new execution pattern equivalent reshaping iteration window presented figure 3b rotate b reshaping iteration window figure 3 corresponding retimed pg repeated pattern changing iteration window applying prs algorithm node next iteration see figure 3b introduced static execution pattern note node interiteration dependencies associated therefore rescheduled available functional unit one possible schedule assign node immediately node c pe 1 resulting ptg new execution order shown figures 4a 4b respectively dotted arrow c new ptg represents owcontrol edge ptg resulting schedule length less 7 higher 90 condence remainder paper organized follows section 2 presents graph model used work required terminology fundamental concepts also presented section 3 discusses probabilistic retiming algorithm computing total computation time probabilistic graph probabilistic rotation scheduling algorithm supported routines discussed section 4 experimental results discussed section 5 finally section 6 draws conclusions research ptg b static execution order figure 4 resulting ptg execution order rescheduling preliminaries section graph model used represent tasks uncertain computation times introduced terminology notations relevant work also discussed begin examining dfg contains tasks uncertain computation time modeled probabilistic graph pg following gives formal denition graph denition 21 probabilistic graph pg vertexweighted edgeweighted directed graph ti v set vertices representing tasks e set edges representing data dependencies vertices function e set nonnegative integers representing number dependency distance edge v random variable representing computation time node v 2 v note traditional dfgs special case pgs probabilities equal one vertex weighted probability distribution computation time given v v discrete random variable corresponding computation time v 8x 1 notation probability random variable assumes value x probability distribution assumed discrete paper granularity resulting probability distribution necessary depends needed degree accuracy edge e 2 e u v u v 2 v denoted u e v path p starting u ending v indicated notation u v number dependency distances path p dp example figure 1b set edges ag number dependency distances edge 2 execution order execution pattern pg determined precedence relations graph one iteration graph vertex execution order computed exactly one time multiple iterations identied index starting 0 interiteration dependencies represented weighted edges dependency distances iteration j edge e u v dependency distance conveys computation node v iteration j depends execution node u iteration edge dependency distances represents data dependency within iteration legal data ow graph must strictly positive dependency distance cycles ie summation along cycle cannot less equal zero 21 retiming overview retiming operations rearrange registers circuit dependency distances dataow graph way behavior circuit preserved achieving faster circuit traditionally retiming 18 optimizes synchronous circuit graph ti nonprobabilistic functional elements ie vertices associated xed numerical timing value optimization goal normally reduce clock period cycle period g also known longest path computation time cycle period represents execution time longest path referred critical path zero dependency distance edges dened equations retiming graph ti transformation function vertices set integers z retiming function describes movement dependency distances respect vertices transform g new graph g represents number dependency distances edges g r positive negative value retiming function determines movement dependency distances retiming number dependency distances pushed incoming outgoing edges node outgoing incoming edges single dependency distance pushed incoming edges node u 2 v outgoing edges node u conversely one dependency distance pushed outgoing incoming edges u absolute value retiming function conveys number dependency distances pushed algorithm nd set retiming functions minimize clock period graph presented 18 polynomial time algorithm time complexity ojv jjej log jv j consider figure 5a illustrates simple graph four vertices b c numbers next vertices gure represent required computation times figure 5b represents retimed version figure 5a case movement dependency distances follows equivalent removing two dependency distances incoming edge vertex e adding onto edges e retiming functions nodes c b 1 means one dependency distance e pushed vertex b edge b e similarly one dependency distance edge e pushed vertex c c e equivalent set retimings figure 5b equivalent set retimings produces graph pushing dependency distances backward nodes b c instead forward nodes b c dotted lines figure 5a represent critical path graph critical path becomes illustrated dotted line figure 5b following summarizes essential properties retiming transformation 1 r legal retiming r e 0 8e 2 e 2 edge u e 3 path u 4 directed cycle l g g r r guarantees retimed graph edge containing negative number dependency distances properties 2 3 explain movement distances rv v 2 v b figure 5 retiming transformations retiming dotted edges represent critical path positive value distances deleted incoming edges v inserted onto outgoing edges vice versa rv negative value finally property 4 ensures number dependency distances loop graph remains constant requires cycles least one dependency distance since retiming optimization technique subject unlimited number target resources resulting longest path computation time transformation underlying schedule length consider dag part retimed graph edges nonzero dependency distances retimed graph ignored iteration boundaries schedule root nodes beginning iteration leaf nodes end iteration 22 rotation scheduling 5 chao lapaugh sha proposed algorithm called rotation scheduling uses retiming algorithm deal scheduling cyclic dfg resource constraints input rotation scheduling algorithm dfg corresponding static schedule ie synchronized order nodes dfg rotation scheduling reduces schedule length number control steps needed execute one iteration schedule exploiting parallelism iterations accomplished shifting scope static schedule one iteration called iteration window one control step looking static iteration rotation scheduling analogously rotates tasks top schedule iteration end process equivalent retiming tasks nodes dfg one dependency distance deleted incoming edges added outgoing edges resulting intermediate retimed graph parallelism extracted algorithm reassigns rotated nodes new positions schedule length shorter example cyclic dfg figure 6a scheduled using two processing elements figure presents one possible static schedule graph using rotation scheduling schedule optimized first algorithm uses node next iteration original graph retimed dependency distance e e moved outgoing edges see figure 6c node executed control step new iteration window assume rotation scheduling uses remapping strategy places node immediately node c pe 1 resulting static schedule length reduced one control step shown figure 6d section 4 concept schedule length remapping strategy extended handle probabilistic inputs cyclic dfg iter th iter b static schedule c retimed resulting schedule figure example present rotation scheduling optimizes underlying schedule length 3 nonresource constrained scheduling assuming innite available resources pg optimized respect desired longest path computation time condence level eect attempt reduce longest path computation time graph distribution dependency distances pg done according probabilistic timing constraint probability obtaining timing result longest path computation time less equal given value c greater condence probability value resulting timing information essentially schedule length nonresource constrained problem section presents ecient algorithm optimizing probabilistic graph respect desired computation time c corresponding condence probability order evaluate modied graph need know probability distribution associated computation time remaining subsections discuss issues 31 computing maximum reaching time let g dag dag portion subgraph edges dependency distances probabilistic graph g assume two dummy nodes v vd added g dag v connects source nodes roots vd connected sink nodes leaves traditionally longest path computation time graph computed maximizing summation computation times nodes along critical longest paths dummy nodes likewise probabilistic graph compute summation computation time path v vd graph case largest summation value called maximum reaching time mrt graph mrt pg exhibits possible longest path computation time graph associated probability therefore unlike traditional approach summation maximum functions computation time along paths pg become functions multiple random variables compute mrt pg need modify graph v vd connected dag portion original graph formally set zero dependency distance edges used connect vertex v roots connect leaves vertex vd since nontrivial eciently compute function dependent random variables algorithm 1 computes mrtg assuming random variables independent algorithm traverses input graph breadthrst fashion starting v ending vd general algorithm accumulates probabilistic computation times along traversed path reaches node one parent values associated parents maximized algorithm 1 calculate maximum reaching time graph g require probabilistic graph pg ensure 2 e e 3 8 4 queue 6 5 get node u top queue 7 u e 8 decrement incoming degree node v one 10 incoming degree node v becomes 0 11 insert node v queue 12 end 13 end 14 end lines 1 2 produce dag g 0 g containing edges e 2 e additional zero dependency distance edges connecting v every root node v 2 v r g connecting every leaf node l g vd line 3 initializes temp mrt v u value vertex u new graph sets computation time vs vd zero lines 412 traverse graph topological order compute mrt v respect v temp mrt v vd note temp mrt node v respect v originally set zero stores current maximum computation time node vs visited parents rst parent v dequeued v indegree reduced one line 8 temp mrt updated line 9 vertex vs parents turn dequeued process repeated eventually last parent node v dequeued maximized point node v inserted queue since parents considered ie indegree v equals zero line 10 node v eventually dequeued line 5 line 6 add v temp mrt node v producing nal mrt respect paths reaching node v noting initial computation times integers probabilities associated times greater given value c accumulated one value algorithm oc need stored vertex therefore time complexity calculating summation line 6 maximum line two vertices oc 2 since algorithm computes result breadth rst fashion running time algorithm 1 oc 2 jvjjej space complexity bounded ocjv j 32 probabilistic retiming using concept mrt algorithm 2 presents probabilistic retiming algorithm reduces longest path computation time given pg meet timing constraint constraint c desired longest path computation time graph condence probability requirement rewritten prmrtv algorithm retimes vertices whose computation time greater c probability larger acceptable probability value initially retiming value node set zero nonzero dependency distance edges eliminated v connected rootvertices resulting dag vd connected leafvertices dag lines 717 traverse dag breathrst search manner update temp mrt node algorithm 1 updating vertex resulting temp mrt tested see requirement prtemp mrt g c met line 19 decreases retiming value vertex v violates requirement unless vertex previously retimed current iteration algorithm repeats process using retimed graph obtained previous iteration algorithm nds solution given clock period nal retimed graph implies number required resources achieve schedule length line 19 pushes dependency distance onto incoming edges node violates timing con straint since descendents node also retimed line 19 essence moves dependency distance vd node words nodes u vd hence incoming edges vertex u additional dependency distance nodes retimed current iteration requirement prmrtv vd c met algorithm stops reports resulting retiming functions associated nodes graph requirement met algorithm repeats jvj times since computation maximum reaching time performed every iteration time complexity algorithm oc 2 jvjjej space complexity remains maximum reaching time algorithm resulting retiming function returned algorithm 2 guarantees necessary condition following theorem 31 given desired cycle period c condence probability algorithm 2 probabilistic retiming algorithm nds solution resulting retimed graph g r satises requirement prmrtg c 33 example consider pg probability distribution associated nodes graph figure 7 experiment let 6 desired longest path computation time 02 acceptable probability algorithm 2 works rst checking computing mrt v e topologically calculates mrt adjacent nodes e computes mrt node three iterations algorithm 2 computes results maximum reaching time v v including vd tabulated tables 13 rst iteration retiming value associated nodes f h shown column rv table 1 values columns 28 show probability algorithm 2 probabilistic retiming require probabilistic graph requirement prtemp mrt g c ensure retiming function r node meet requirement 1 8 node v 2 v initialize retiming function rv 0 2 3 retime graph g r retiming function rv 4 g directed acyclic portion dag g r 5 prepend dummy node v g 0 fconnects root nodesg append dummy node vd g 0 fconnected leaf nodesg 7 nodes g 0 8 temp mrt v 9 insert v queue timing two dummies zerog 11 end 12 queue 6 13 get node u queue 14 temp mrt v fadding two random variablesg 15 u e decrement number incoming degrees node v one fmaximizing two random variablesg u retimed dependency distance outgoing edges incoming edgesg 20 end 21 number incoming edges node v 0 22 insert node v ready queue 23 end 24 end 25 end 26 end g f time nodes b figure 7 example 9node graph corresponding probabilistic timing information mrtv v 8v 2 v ranges 1 6 greater 6 respectively retimed graph associated retiming value table 1 rst iteration presented figure 8a table 2 presents maximum reaching time dummy node v node v 2 v well retiming function vertex second iteration figure 8b presents retimed graph corresponding retiming function presented table 2 computing mrtv v retimed graph figure 8b becomes apparent nodes b c need retimed figure 8c illustrates nal retimed graph accordance retiming function presented table 3 note table 3 also presents nal maximum reaching time retiming value vertex satises required conguration nal retimed graph one could therefore allocate minimum processing elements order compute graph six time units 80 condence g f g f b g f c figure 8 retimed graph corresponding tables 13 table 1 first iteration showing probability distributions mrtv resourceconstrained scheduling section present probabilistic scheduling algorithm considers environment limited number resources traditional rotation scheduling framework extended handle probabilistic environment call algorithm probabilistic rotation scheduling prs given pg algorithm iteratively optimizes pg respect condence probability number resources presenting algorithm rst discuss two important concepts make scheduling probabilistic environment dierent traditional scheduling problems first probabilistic model table 2 second iteration showing probability distribution mrtv table 3 third iteration showing probability distribution mrtv synchronization control step available node begin execution parents already executed similar asynchronous model data request handshaking signals used communicate nodes schedule viewed directed graph edges show either data requirement execute node order node executed particular functional unit note synchronization applied end iterationsecond task remapping strategy prs take probabilistic nature problem account following subsections discuss concepts details 41 schedule length subject condence concept mrt used compute underlying schedule length hence conventional way calculating schedule length redened include mrt notion order update probabilistic data ow graph adding resource information extra edges two nodes executed consecutively functional unit data dependencies graph called probabilistic taskassignment graph ptg represents schedule probabilistic model denition 41 probabilistic taskassignment graph bi vertexweighted edge weighted directed acyclic graph v set vertices representing tasks e set edges representing data dependencies vertices w edgetype function e 2 e f0 1g 0 represents type dependency edge 1 represents type random variable representing computation time node v 2 v b processor binding function v 2 v fpe processing element n total number processing elements figure 9 example probabilistic taskassignment graph ptg nodes assigned pe 0 pe 1 example figure 9 shows example ptg two functional units pe 0 pe 1 nodes b assigned pe 0 edges consists c exists edges nodes scheduled processor edge true dependence edge ignored note also removing redundancy edges simple utilized speed calculation mrt figure 9 edge c e1 controltyped since dependency c execute c due resource constraints edges represent data dependencies applying mrt algorithm ptg dene probabilistic schedule length length expressed terms condence probability follows denition 42 probabilistic schedule length ptg respect condence level pslg smallest longest path computation time c prmrtg c 1 example consider probability distribution mrtg possible computation time prob given condence probability 08 probabilistic schedule length pslg 08 14 smallest possible computation time 14 prmrtg 14 02 ie 004365 007818 02 therefore 80 condence computation time g less 14 42 task remapping heuristic template scheduling subsection propose heuristic called template scheduling ts search place reschedule task remapping phase plays important role reducing probabilistic schedule length prs since computation time random variable xed control step within iteration long node placed parents scheduling location legal template scheduling schedule template computed using expectation computation time node template implies execution order also expected control step node start execution order determine expected control step node ptg visited topological order following computed denition 43 expected control step node v ptg computed e represents expected computation time node denition assumes node v start execution right parents nish execution observing template one ascertain long number control steps processing element would idle template scheduling decides reschedule node using degree exibility denition 44 given ptg degree exibility node u respect processing element pe exu computed u v assigned pe degree exibility conveys expected size available time slot within pe figure 10 shows typical case node v one parent u 1 u 2 u 3 parents node v parents figure 10 example obtain expected control step expected computation time 1 4 3 respectively order expected control steps nodes 3 47 37 respectively therefore expected control step according denition 43 degree exibility u respect pe 0 87 3 value conveys long pe 0 wait v executed note degree exibility node executed last pe undened following steps compute new g rescheduling node v algorithm 3 rescheduling rotated nodes using template scheduling heuristic require ptg rescheduled node v condence probability ensure resulting new ptg shortest psl 1 assume nodes ptg expected computation times precomputed 2 8 node u 2 v compute ecsu exu 3 target processors pe 4 using maximum dlfex select node x scheduled pe 5 schedule v x reconstruct new ptg associated pe assignment 7 compare others ptg get one best psl 8 end rescheduling policy hopes placing node processor expected biggest idle time slot results least potential increasing total execution time computation time node much smaller expected time slot approach may allow next rescheduled node placed also similar worstt policy scheduler strives schedule node biggest slot section 5 demonstrate eectiveness heuristic method exhaustively nds best place node note exhaustive search performed globally rather search done locally remapping iteration call heuristic local search ls 43 rotation phase discussed rescheduling heuristic following presents probabilistic rotation scheduling prs note previous heuristic rescheduling heuristic used rescheduling part prs algorithm experiments section 5 show ecacy prs framework dierent rescheduling heuristics algorithm 4 probabilistic rotation scheduling require pg designers condence probability ensure ptg shortest psl 1 2 g nd initial schedule fnding initial schedule pg keep g g 3 4 r roots dag portion g fthese nodes rotatedg 5 retime nodes r reschedule node one one using heuristic previously presented 7 compute psl new graph respect 8 pslg 9 g best g fconsidering g best initialized g rstg 11 end order use template scheduling expected computation time task precomputed initial schedule constructed nd initial schedule note algorithm creating initial schedule dag scheduling eg probabilistic list scheduling discussed previously rotation scheduling loops 2jv j times reschedule nodes graph least like traditional rotation scheduling nodes incoming edges nonzero dependency distances selected rescheduled one dependency distance drawn edges placed outgoing edges rotated nodes rescheduled one one using template scheduling technique rotated nodes scheduled resulting ptg better current one algorithm 4 save better ptg 44 example let us revisit pg example section 33 shown figure 11a corresponding computation time figure 11b condence probability given list scheduling applied initial execution order determined shown figure 12a corresponding ptg presented figure 12b nodes b h assigned pe 0 nodes e f scheduled pe 1 nodes c g assigned pe 2 edges b e g g e owcontrol edges g f time nodes b figure 11 example computation time graph figure 1b assignment mrt ptg computed following possible computation time therefore higher 80 condence probability pslg according structure ptg either e rescheduled rst rotation prs selects rescheduled one dependency distance moved incoming edges pushed outgoing edges resulting retimed graph pg shown figure 13a graph node requires direct data dependency node therefore placed position schedule figure 13b shows expected computation time expected control step degree exibility node ptg based values table figure 13b obvious expected waiting time b h pe 0 would 22 units template scheduling however decides place position b h pe 0 psl reduced resulting ptg execution order shown figure 14 pslg running prs iterations shortest possible schedule length found 15 th iteration figure 15 present resulting schedule length trial less 9 probability greater 80 pslg static execution order b ptg figure 12 initial assignment corresponding execution order g f new pg ex b ecs ex figure 13 probabilistic graph rotated template values g ptg b execution order figure 14 ptg execution order mrt rst rotation pslg g f pg g f b ptg c final execution order figure 15 nal pg ptg execution order pslg 9 5 experimental results section perform experiments using nonresource resource constrained scheduling two general classes problems rst class real applications may combination nodes probabilistic computation times xed computation times second well known dsp lter benchmarks since benchmarks contain two uniform types nodes namely multiplication addition basic timing information consisting three probability distribution assigned benchmark graphs order show usability proposed algorithm three applications proled get probabilistic timing information proler reports processing time requirement applications corresponding frequency time value frequency timing occurances used obtain node probability distributions node graphs may represent large number operations cause uncertain computation time well operations xed timing information timing information discretized smaller unit nanoseconds dsp lter benchmarks used experiments include biquadratic iir lter 3stage iir lter 4 th order jaunmann wave digital lter 5 th order elliptic lter unfolded 5 th order elliptic lter unfolding factor equal 4 4 allpole lattice lter unfolded allpole lattice lter unfolded allpole lattice lter dierential equation solver volterra lter rest benchmarks application image processing floydsteinberg application search solution maximize unknown function using genetic algorithm famous example application fuzzy logic area inverted pendulum problem experiments performed using sun ultrasparc tm 51 nonresource constrained experiments experiment given condence level used search best longest path computation time order current desired longest path computation time c varied based whether feasible solution found instance c small algorithm report feasible solution exists case c increased algorithm 2 reapplied process repeated smallest feasible c found table 4 shows results traditional retiming using worstcase computation time assumptions column c worst probabilistic model two high condence probabilities average running time experiments determined seconds including inputoutput interfaces algorithms implemented straightforward way array used store probability distributions column 3 table presents optimized longest path computation times obtained applying traditional retiming using worstcase computation time node graph benchmarks columns 08 probabilistic retiming algorithm applied benchmarks condence probabilities used input numbers show columns given c prmrtg c value c requirement smallest input value algorithm 2 nd solution satisfy requirement notice benchmarks longest path computation time still smaller computation time column 3 order quantify improvement probabilistic retiming algorithm columns list percent computation time reductions respect value column 3 benchmark nodes c worst c c biquad iir 8 78 di equation 11 118 81 31 77 35 3stage direct iir 12 54 44 19 41 24 allpole lattice 15 157 120 24 117 25 4 th order wdf 17 156 116 26 112 28 volterra 5 th elliptic 34 330 240 28 236 29 allpole lattice uf2 allpole lattice uf6 105 1092 811 26 806 26 5 th elliptic uf4 170 1633 1185 27 1174 28 genetic application fuzzy application 24 19 17 11 17 11 table 4 probabilistic retiming versus worst case traditional retiming average completion time running probabilistic retiming benchmarks 5310 seconds table 5 compares probabilistic retiming algorithm traditional retiming algorithm average computation times used node graphs first probabilistic nodes input graph converted xed time nodes resulting g avg ie node assumes average computation time rather probabilistic computation time traditional retiming applied resulting graph resulting graph g r purpose table compare g r avg obtained running traditional retiming g avg retimed pgs order compare results produced proposed algorithm placement dependency distance g r avg preserved original probabilistic computation times replaced average computation times put another way transformed g r avg back probabilistic graph algorithm 1 used evaluate graphs expected values result shown table columns 4 5 present expected values results obtained running probabilistic retiming pg condence probability 09 08 considered note results consistently better smaller value results obtained running traditional retiming g avg hence approach using expected values node neither good heuristic initial design phase give quantitative condence resulting graphs 52 resourceconstrained experiments tested probabilistic rotation scheduling prs algorithm selected lter application bench marks 5 th elliptic lter 3 stageiir lter volterra lter lattice lter floydsteinberg genetic algorithm fuzzy logic applications table 6 demonstrates eectiveness approach 2adder 1multiplier 2adder 2multiplier systems lter benchmarks specication 3 4 general purpose processors pes adopted three application benchmarks performance prs evaluated comparing resulting schedule length schedule length obtained traditional algorithm 2 benchmark mrtg r avg biquad iir 7040 5264 5230 di equation 7605 7307 7250 3stage direct iir 4190 3770 3836 allpole lattice 11445 11177 11140 4 th order wdf 10673 10644 10598 volterra 20400 20244 20200 5 th elliptic 23330 22841 22759 allpole lattice uf2 34217 33811 33762 allpole lattice uf6 80051 79402 79339 5 th elliptic uf4 80051 79402 79339 genetic application 15089 14401 11246 fuzzy application 1803 1608 1608 table 5 probabilistic retiming versus averagecase analysis modied list scheduling technique capable handling probabilistic graphs also show eectiveness template scheduling ts comparing results heuristics namely local search ls aslateas possible scheduling al average execution times al ts comparable 12 seconds running ultrasparc tm ls takes much longer time give outstanding results comparing ts rescheduling phase prs ls approach strives reschedule node possible legal location local search returns assignment yields minimum pslg method simple gives good schedule however time consuming practical try possible scheduling places every iteration prs furthermore ptg needs temporarily updated every trial order compute possible schedule length contrary al method reduces number trials attempting schedule task farthest legal position functional unit processor ts heuristic remaps scheduled node node highest degree exibility functional unit columns show results considering probabilistic situations condence probabilities 08 09 column pl presents probabilistic schedule length psl modied list scheduling applied benchmarks columns ls al ts show resulting psl running prs benchmarks using remapping heuristics ls al ts respectively among three heuristics ts scheme produces better results al uses simplest criteria yields good sometimes even better results given ls approach ts taking less time select rescheduled position node iteration ls method nds local optimal place however scheduling nodes positions always result global optimal schedule length table 7 based system 2 adders 1 multiplier lter benchmarks 3pes application benchmarks present comparison results obtained applying following techniques benchmarks modied list scheduling traditional rotation scheduling probabilistic rotation scheduling spec benchmarks nodes pl prs pl prs di equation 11 169 152 133 133 165 147 131 131 adds 3stage iir 12 188 184 151 151 184 179 147 147 allpole lattice 15 229 225 142 141 225 220 138 138 volterra 5 th elliptic 34 318 298 293 293 314 294 289 289 28 28 27 genetic application fuzzy application 24 52 46 43 43 di equation 11 120 103 83 90 117 100 83 91 adds 3stage iir 12 124 120 87 87 120 110 83 82 muls allpole lattice 15 229 225 140 139 225 220 136 136 volterra 5 th elliptic 34 288 288 274 271 284 274 270 267 26 28 38 24 24 24 genetic application fuzzy application 24 table comparison results obtained applying following benchmarks modied list probabilistic rotation scheduling using dierent remapping heuristics average completion time running al ls ts heuristics benchmarks 1196 4258 1246 seconds respectively using template scheduling heuristic traditional rotation scheduling considering average computation times columns l r show schedule length obtained applying modied list scheduling traditional rotation scheduling respectively benchmarks probabilistic computation times converted worstcase computation times obviously considering probabilistic case gives signicant improvement schedule length worst case scenario column pl presents initial schedule lengths obtained using modied list scheduling ap proach results column prs obtained table 6 prs using template scheduling heuristic column avg psls computed using graphs ptgs retrieved running traditional rotation benchmarks average computation time assigned node results demonstrate considering probabilistic situation performing rotation scheduling consistently give better schedules considering worstcase averagecase computation times spec benchmarks nodes worst case di equation 11 228 180 169 133 136 165 131 131 allpole lattice 15 312 204 229 141 153 225 138 149 volterra 5 th elliptic 34 438 396 318 293 299 314 289 294 genetic application fuzzy application 24 69 55 52 45 66 52 43 63 table 7 comparing probabilistic rotation traditional rotation running graphs average computation times 6 conclusion presented scheduling optimization algorithms operate probabilistic environments probabilistic dataow graph used model application takes probabilistic nature account probabilistic retiming algorithm used optimize given application nonresource constrained environments assumed given acceptable probability desired longest path computation time algorithm reduces computation time given probabilistic graph desired value concept maximum reaching time used calculate timing values probabilistic graph limited number processing elements considered probabilistic rotation scheduling algorithm probabilistic concept loop pipelining integrated optimize task schedule proposed based maximum reaching time notion probabilistic schedule length used measure total computation time tasks scheduled one iteration given probabilistic graph schedule constructed using taskassignment probabilistic graph probabilistic schedule length computed respect given condence probability probabilistic rotation scheduling applied initial schedule order optimize schedule produces best optimized schedule respect condence probability remapping heuristic template scheduling incorporated algorithm order nd scheduling position node r development environment horizontal microcode optimal loop parallelization unimodular transformations double loops impact architectural framework multiple instruction issue processor rotation scheduling loop pipelining algorithm static scheduling synthesis dsp algorithms various models stage scheduling technique reduce register requirements modulo schedule minimum register requirements modulo schedule trace scheduling technique global microcode compaction designing building parallel program concepts tools parallel software engi neering dynamic listscheduling nite resources retiming synchronous circuitry imprecise delays comparison multiprocessor scheduling heuristics relative scheduling timing constraints algorithm highlevel synthesis software pipelining retiming synchronous circuitry art parallel programming singular loop transformation framework based nonsingular matrices static rateoptimal scheduling iterative dataow programs via optimum unfolding loop pipelining scheduling multidimensional systems via rotation scheduling techniques easily schedulable horizontal architecture high performance scienti iterative modulo scheduling algorithm software pipelining loops high performance compilers parallel computing loop transformation theory algorithm maximize parallelism fuzzy sets basis theory possibility tr ctr meikang qiu zhiping jia chun xue zili shao edwin hm sha voltage assignment guaranteed probability satisfying timing constraint realtime multiproceesor dsp journal vlsi signal processing systems v46 n1 p5573 january 2007 jose l aguilar ernst l leiss data dependent loop scheduling based genetic algorithms distributed shared memory systems journal parallel distributed computing v64 n5 p578590 may 2004 rehab f abdelkader resourceconstrained loop scheduling highlevel synthesis proceedings 43rd annual southeast regional conference march 1820 2005 kennesaw georgia
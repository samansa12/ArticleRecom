finite state machines strings infinite alphabets motivated formal models recently proposed context xml study automata logics strings infinite alphabets conservative extensions classical automata logics defining regular languages finite alphabets specifically consider register pebble automata extensions firstorder logic monadic secondorder logic type automaton consider oneway twoway variants well deterministic nondeterministic alternating control investigate expressiveness complexity automata connection logics well standard decision problems results answer open questions kaminski francez register automata b introduction one significant recent developments related world wide web www emergence extensible markup language xml standard data exchange web 1 since xml documents tree structure usually defined dtds xml queries modeled mappings trees trees tree transduc tions schema languages closely related tree automata automata theory naturally emerged central tool formal work xml 5 17 18 19 20 21 22 23 connection logic automata proved fruitful understanding languages development optimization algorithms static analysis techniques however abstractions ignore important aspect xml namely presence data values attached leaves trees comparison tests performed xml queries data values make big dierence indeed cases difference decidability undecidability eg see 4 therefore important extend automata logic formalisms trees data values initial investigation model data values infinite alphabets consider simpler case strings rather trees strings also relevant tree case formalisms allow reasoning along paths tree case xml would accurate consider strings labeled finite alphabet attach data values positions preliminary version title towards regular language infinite alphabets appeared proceedings 26th international symposium mathematical foundations computer science mfcs 2001 czech republic 2001 postdoctoral researcher fund scientific research flanders author supported part national science foundation grant number iis9802288 string however would render formalism complicated bearing results although limited strings believe results provide useful starting point investigating general problem particular lowerbound results easily extended trees consider models accept precisely regular languages restricted finite alphabets useful observe infinite alphabets longer sucient equip automata states alone indeed automata least able check equality symbols two main ways 1 store finite set positions allow equality tests symbols positions 2 store finite set symbols allow equality tests symbols first approach however leads multihead automata immediately going beyond regular languages therefore instead equip automata finite set pebbles whose use restricted stack discipline automaton test equality comparing pebbled symbols second approach follow kaminski francez 15 14 extend finite automata finite number registers store alphabet symbols processing string automaton compares symbol current position values registers based comparison decide store current symbol register addition automata consider another wellknown formalism monadic secondorder logic mso precise associate strings firstorder structures standard way consider extensions mso fo denoted mso fo done gradel gurevich context metafinite models 8 mso proven good yardstick generalizations regular languages investigated eg trees infinite strings 25 graphs 6 results concern expressive power various models provide lower upper complexity bounds consider standard decision problems mentioned automata models consider deterministic nondeterministic n alternating control well oneway twoway variants denote automata models dcx 1 2 1 2 stand one twoway respectively n stand deterministic nondeterministic alternating pa ra pebble register automata main results following expressiveness results also represented figure 1 registers pursue investigation register automata initiated kaminski francez 15 particular investigate connection ras logic show essentially incomparable indeed show mso cannot define 2dra furthermore even properties fo cannot expressed 2aras proof latter based communication complexity 12 next consider relationship various ra mod els separate 1nras 2dras 2nras 2aras subject standard complexitytheoretic assumptions pebbles consider two kinds pas one every new pebble placed first position string one every new pebble placed position current pebble refer strong weak pas respectively clearly pebble placement makes dierence case oneway pas oneway case strong 1dpa simulate fo weak 1npa cannot whence names proof latter separation based communication complexity furthermore show pebble automata variants defined mso finally provide evidence strong pas robust notion showing power strong 1dpa strong 1npa 2dpa 2npa coincide decision problems finally consider decision problems ras pas answer several open questions kaminsky francez first show universality containment 1nras nonemptiness 2dra unde cidable next obtain nonemptiness undecidable even weak 1dpas ras orthogonal logically defined classes one might argue pas better suited define notion regular languages infinite alphabets indeed reasonably expressive lie fo mso furthermore strong pas form robust notion adding twowayness nondeterminism increase expressiveness class definable languages closed boolean operations concatenation kleene star capturing exactly mso likely requires significant extensions pas mso one express complete problems every level polynomial hierarchy computations 2apas p related work kaminski francez first consider ras called finitememory automata handle strings infinite alphabets showed 1nras closed union intersection concatenation kleene star showed nonemptiness decidable 1nras containment decidable 1nras automaton containment tested two registers input restricted finite alphabet pas recognize regular languages even presence alternation 18 point pebbling mechanism employ based one milo suciu vianu 18 liberal one used globerman harel 9 indeed case pebble placed automaton still walk whole string sense presence pebbles globerman harel prove certain lower bounds gap succinctness expressibility automata overview paper organized follows section 2 provide formal framework section 3 study register automata section 4 examine pebble automata conclude section comparing register pebble models section 6 consider decision problems end discussion section 7 consider strings infinite alphabet formally dstring w finite sequence 1 n language set dstrings often dealing 2way automata delimit input strings two special symbols left right end string neither ie automata always work strings form denote domw set 1 w w length w domw also write val w 21 register automata explained introduction register automata finite state machines equiped finite number registers registers hold values processing string automaton compares symbol current position values registers based comparison decide store current symbol register stress allowed operation registers apart assignment comparison symbol currently processed transition depends current state whether current symbol already present register transition relation specifies change state movement head possibly whether current symbol stored register follow definition kaminski francez 15 14 tuple q q 0 f 0 p q finite set states q 0 q initial state f q set final states initial register assignment p finite set transitions forms q q q q given string w configuration b w tuple j initial configuration 0 1 q 0 0 configuration j q q f accepting given transition p respectively p applies val w j 1 k given define one step transition relation configurations follows transition q q applies respectively transition q q applies j defined previous case obtained setting val w j denote transitive closure intuitively transitions q q applied value current position register transitions applied value current position diers values registers case current value copied register require initial register assignment contains symbols automata recognize boundaries input furthermore right transitions lefttransitions allowed usual string w accepted b 0 accepting configuration language lb accepted b defined v v accepted b automata defined far general nondeterministic automaton deterministic configuration one transition applies lefttransitions automaton oneway alternating automata defined subsection 23 explained introduction refer automata dcra 1 2 clearly input restricted finite alphabet ras accept regular languages 22 pebble automata pebble automata finite state machines equiped finite number pebbles ensure regular behavior use pebbles restricted stack discipline pebbles numbered 1 k pebble placed pebble present string highestnumbered pebble present string acts head automaton transition depends current state pebbles placed current position head equality type data values placed pebbles transition relation specifies change state movement head possibly whether head pebble removed new pebble placed pebble removed pebble becomes current head formal definition borrow notation milo suciu vianu 18 kpebble automaton tuple q q finite set states q 0 q initial state f q set final states finite set transitions form form p v q p v q 1 k form q q q stay left right placenewpebble liftcurrentpebble given string w configuration w form 1 k q q 1 domw call pebble assignment depth configuration pebble assignment sometimes denote depth configuration pebble assignment depth depth initial configuration 0 1 q 0 configuration q q f accepting transition p v p applies configuration 1 2 3 4 val w transition p v q applies 13 hold transition p v q applies intuitively p v p applies configuration pebble current head p current state v set pebbles see symbol top pebble p set pebbles sit position top pebble current symbol seen top pebble finite set transitions automaton identify finite number distinguished symbols hence every regarded constant register model constants determined initial register assignment define transition relation follows q q transition p applies q liftcurrentpebble definitions accepted language deterministic oneway analogous case register automata refer automata dcra c definition new pebbles placed position recent pebble alternative would place new pebbles beginning string choice makes dierence twoway case significant oneway case refer model defined weak pebble automata latter strong pebble automata strong pebble automata formally defined setting placenewpebble case definition transition relation 23 alternating automata automata models also define alternating version alternating automata additionally set u q universal states sets q u called existential automaton nondeterministic run w tree nodes labeled configurations follows 1 root labeled initial configuration 2 every inner node labeled existential configuration exactly one child 3 every inner node labeled universal configuration children labeled accepting run run every leaf node labeled final configuration language accepted defined w accepting run w 24 logic consider firstorder monadic secondorder logic dstrings representation well logics special instances metafinite structures logics defined gradel gurevich 8 string w represented logical structure domain domw natural ordering domain function instantiated val w atomic formula form x obvious semantics logic fo obtained closing atomic formulas boolean connectives firstorder quantification domw hence quantification allowed logic mso obtained adding quantification sets domw quantification allowed sentence defines set strings usual way precisely l w example consider defining set strings every position carries dierent symbol 25 complexity classes infinite alphabets separating results relative complexitytheoretic assumptions end consider straightforward generalization standard complexity classes like logspace nlogspace ptime case infinite alphabets define classes using generic turing machines gtm device introduced hull su 13 model computable queries infinite alphabets informally gtm turing machine two rightinfinite tapes tape alphabet infinite input consists string tape alphabet initially placed leftmost first tape moves similar classical turing machines except equality symbols heads tested move symbol one heads written tape cell head gtm also test equality constants distinguished finite subset tape alphabet write constants either tape classical complexity class c one define analog c gtm model natural way example p consists languages accepted gtms always stop polynomially many moves respect length input immediate show usual complexity 26 terminology sequel present several expressiveness complexity results first introduce notation b two formalisms defining languages dstrings write every language defined defined b every b b finally write b b b addition expressive power formalisms interested computational complexity following problems let formalism defining languages dstrings membership problem determining given w whether w la consider data complexity consider fixed hence complexity measured size w two problems interested universality containment first problem deciding whether given second determining whether complexity measured respect 1 2 respectively 3 register automata start investigating ras particular compare fo mso main result ras orthogonal logics cannot even express fo properties express properties definable mso separate variants ras subject standard complexitytheoretic assumptions 31 expressiveness show property dstrings definable mso easily expressible 2dra rest paper make extensive use symbol delimiter therefore assume theorem 3 2dra mso proof consider strings form uv u v define n u n v set symbols occurring u v respectively denote n u n v cardinalities show 2dra accepts uv n mso sentence first introduce notation string w denote lmow position w leftmost occurrence suppose n every j lmo u n u n v visiting lmo u 1 sequence hence n b reached simultaneously automaton rejects input string otherwise accepts remains explain 2dra visit lmo u 1 sequence clearly lmo u 1 lmo v b 1 first positions u v spectively values b stored registers compute i1 b i1 indeed compute i1 proceeds follows first moves head position lmow going left boundary afterwards walking right encounters tests positions lmow starting carry leftmost occurrence symbol done follows position lmow goes left either sees reaches left end string former case goes back lmow identified first proceeds lmow 1 latter case lmow carries leftmost therefore i1 identified computation b i1 done similar way assume towards contradiction mso sentence uv c set dsymbols occurring call string uv admissible dsymbol occurs u v c occurs u v let obtained replacing occurrence every occurrence every admissible string 1 n e 1 would mso definable therefore regular leads desired contradiction mso proven good yardstick generalizations regular string languages trees graphs 6 25 theorem suggests ras behave nonregular manner following proposition shows essentially due ability move head directions proposition 4 mso simulate every 1nra proof let describe construction mso formula holds input accepting computation w first guesses position w state b reading done existentially quantifying sets q qq next guesses position transition b applies reads w done quantifying sets tt assume accepting computation b w q qq tt chosen accordingly register j register content b reading position determined follows form q q j straightforward express mso even fo ability determine register contents easy check fo q qq tt consistent transition relation b far one might think 2way register automata simply strong compared mso logic next result provides evidence computation model based registers simply comparable logics precisely show ras cannot capture fo even alternation proof based communication complexity argument communication complexity see eg 12 input string divided predetermined manner two parties generally referred ii send messages according given protocol language accepted protocol string parties decide execution protocol whether string belongs language parties unlimited computation power part string protocol restricts way parties communicate typically restricting form number messages next sketch main idea separation 2dras fo basic idea extended deal alternation proof theorem 5 consider strings form uv u v encode sets sets dsymbols suitable way seen language u v represent set sets definable fo show language accepted 2dra note 2dra working strings form uv simulated protocol following way given u ii given v first party simulates 2dra computation tries cross delimiter right point sends present state q data values 1 k currently registers hence ii gets full information configuration position symbol fixed iisends turn current configuration process continues one parties detects final state kind protocol simulate behavior first need message every configuration suppose restrict n dierent data values strings uv q n k dierent messages needed k number registers q set states 2d ra call sequence messages dialogue need consider dialogues length every message sent every direction hence 2 dierent dialogues input strings consisting n dierent dsymbols latter value exponential n however 2 2 n sets sets n dierent dsymbols large enough n must dierent strings uu vv accepted protocol via dialogue means uv also accepted hence protocol define l implies 2dra accepts l proof theorem 5 extend idea alternation requires exchanging partial computation trees 2ara apply counting trick consider deeply nested hypersets proof technique inspired proof abiteboul herr van den buss che 2 separating temporal query languages etl tsfo end show every query etl special sort databases evaluated communication protocol constant number messages whereas case tsfo case simulate 2dra 2ara need powerful protocol number messages depends number dierent data values u v theorem 5 fo 2ara proof start terminology let finite infinite set 1hyperset finite subset 1 ihyperset finite set 1 hypersets often denote ihypersets superscript ease presentation assume contains natural numbers d1 j next let j 0 fixed inductively define encodings ihypersets j first string encoding 1hyperset j encodings w 1 w n 1hypersets iw 1 iw 2 iw n encoding ihyperset hw language uv u v encodings mhypersets dm lemma 6 l definable fo proof let k 1 fixed k define expressing input w intervals x x r r encode ihyperset x z abbreviate xx z clean abbreviate formula formula hyp express x x r encodes ihyperset therefore let 1 clean formula inductively defined follows 1 language l k expressed formula 1 max refer first last element string respectively 1 successor function next show 2ara recognize l described underlying idea large enough 2ara simply cannot communicate enough information two sides input string check whether hu definition 7 let p binary predicate ihypersets let k l 0 say p computed k lcommunication protocol two parties denoted ii polynomial p finite set finite alphabet size pd ihypersets x computed follows 1 gets x ii gets know 2 sends message 1 x ii ii replies message b message khyperset 3 sends message ii ii replies message b 4 exp l pd rounds message exchanges ii enough information decide whether p x holds precisely apply boolean function r1 x b r b r1 r ii evaluates true formally protocol consists functions 1 r1 b 1 b r1 note computing power ii completely arbitrary lemma 8 4 l cannot computed 22communication protocol proof suppose protocol computing l every finite set el ements number dierent possible messages number 2hypersets exp 2 pd call complete sequence exchanged messages 1 b 1 2 b 2 dialogue every dialogue exp 2 pd rounds hence dierent dialogues however number dierent mhypersets exp hence 4 large enough mhypersets protocol gives dialogue p x x means also gives dialogue p x leads desired contradiction refer strings form uv u v contain split strings communication protocol computes strings assigning u v ii lemma 9 split strings language defined 2ara recognized 22communication protocol proof let working split strings assume wlog transitions possible final configurations assume b never changes direction symbol hence split string uv leaves u right enters v vice versa define p polynomial pn qn k number configurations assumed position labeled strings n dierent data values let uv input split string let set data values occurring w let position string split symbol e set e q set configurations assumed position split symbol refer configurations note essence parties compute partial runs send configurations b walks part string party concrete computes runs b u leaves runs consist configurations final configurations inner vertex labeled configuration sends ii set sets configurations appearing leaves runs party ii turn computes information runs starting sets configurations received sends process repeated exp 2 messages message containing empty set input accepted final configurations transmitted presence empty set indicates run leaves accepting configurations next describe formally configuration q called uconfiguration e vconfiguration configuration called uconfiguration assumed left vconfiguration assumed right note assumption never changes direction distinguish two sets configurations introduce following notions arbitrary configuration run run root labeled leaves labeled final configurations configurations inner vertex besides possibly root labelled configuration run define leaflabelst set configurations occurring leaves set c configurations define c 1 set sets configurations note c 1 computable set c 1 configurations finally set 2 sets configurations define 2 2 c 1 singleton 2hyperset containing singleton set 0 0 0 recall 0 initial configuration define sequence 2hypersets configurations i1 1 note 0 even 2hyperset vconfigurations odd 2hyperset uconfigurations let us call run ipass run leaf configurations either accepting configurations reached computations visited exactly times clearly c 1 ipass run b w c 1 vice versa hence b accepts w c 1 containing empty set protocol works follows party starts sending 1 0 party ii receives 2i1 responds 2i party receives 2i responds 2i1 parties accept whenever 2hyperset empty set transmitted exp 2 dierent 2hypersets parties reject empty set never obtained exp 2 rounds messages lemma 8 9 l computable 2ara hence theorem 5 follows 32 control previous section related ras logic section compare ras various kinds control kaminski francez already showed 1dras weaker 1nras property data values dierent 2dra 1nra separate classes relying complexity theoretic assumptions explained next main observation strings special shape ras simulate multi head automata strings even length odd positions contain pairwise distinct elements even positions carry symbols finite alphabet say b storing unique ids preceding bs ra remember positions heads multihead automaton note 2dras check whether input string desired form deterministic nondeterministic alternating multihead automata recognize precisely logspace nlogspace ptime languages respectively membership 2dra 2nra 2ara hard classes respectively 24 16 furthermore easy see respective membership problems also belong infinite alphabet variants classes actually even complete classes one always encode string infinite alphabet binary alphabet thus show following proposition proposition 10 1 membership 2dra complete logspace 2 membership 2nra complete nlogspace 3 membership 2ara complete ptime indexing technique cannot used 1nras cannot check whether odd positions form unique index however extend 2 1nras using direct reduction nlogspacecomplete problem ordered reachability proposition 11 membership 1nra complete nlogspace proof clearly membership nlogspace hardness use reduction ordered reachability given ordered graph property edge u v u v path first node last one problem hard nlogspace indeed ordinary reachability complete nlogspace nlogspace following logspace reduction ordinary reachability ordered reachability given graph g n nodes source sink construct graph g vertices graphically edge j edge g source sink 1 n respectively clearly reachable g n reachable 1 g g computable logspace hence ordered reachability hard nlogspace next reduce latter membership problem 1nras input 1nra form 1 11 1i 1 2 21 2i 2 n j j1 ji j encodes edge j jl 1nra accepts n reached 1 following edges every ordered graph encoded list hence since ordered reachability hard nlogspace membership 1nra consequence proposition 11 four classes defined mentioned automata models dierent unless corresponding complexity classes collapse refer reader figure 1 visual representation relationships 4 pebble automata next focus pebble automata show pas better behaved ras respect connection logic sense pas regular ras indeed show strong 1dpas simlate fo even liberal pebble model 2apa defined mso furthermore separate 2aras mso usual complexitytheoretic assumptions next show weak oneway pas suce capture fo proof based communication complexity finally prove strong pas oneway twoway deterministic nondeterministic variants collapse together straightforward closure boolean operations concatenation kleene star results suggest strong pas define robust class languages 41 expressiveness proposition 12 fo strong 1dpa proof clearly fo cannot define dstrings even length 1dpas strong easily inclusion note fo sentence prenex normal form evaluated straightforwardly strong 1dpa use one pebble quantifier pebble 1 used outermost quantifier pebble largest number used innermost quantifier automaton cycles possible assignments positions pebbles hence variables records state information equalities inequalities among symbols pebbled positions next show pas subsumed mso thus behave regular manner theorem 13 mso simulate 2apa proof proof extension infinite alphabets proof 18 shown alternating treewalking pebble automata finite alphabets simulated mso brief reduce simulation problem kpebble automaton alternating graph accessibility problem agap 10 alternating graph andor graph graph e whose nodes v partitioned andnodes nodes consists pairs g x g alternating graph x accessible vertex g accessibility defined follows andnode accessible successors accessible ornode accessible least one successors accessible note andnodes successor definition accessible shown set accessible nodes definable mso therefore mso indeed consider formula reversecloseds unary relations containing andnodes respectively given alternating kpebble automaton string construct following andor graph e ornodes configurations w whose states existential andnodes configurations whose states universal together additional distinguished andnode set edges e accepting follows directly definitions la agap string w la initial configuration 0 accessible graph gaw hence remains show express agap problem gaw mso diculty lies fact nodes gaw tuples nodes input structure w configuration represented ituple 1 q depend w encoded separately hence set 1 longer unary circumvent rely special property gaw namely two nodes described ituple 1 jtuple 1 j connected edge either tuples agree last position follows stack discipline pebbles last pebble moved allows us quantify independently dierent portions graph construction relies observation outline construction next simplicity assume wlog universal state q either p v q two states q 1 q 2 p v q also convenient assume q partitioned disjoint states q control pebble furthermore enumerate states q consider first case uses single pebble illustrate one encodes state configuration encode transitions simplicity consider transitions involving constants dealing transitions without constants easy generalization case one pebble configurations assimilated pairs q x transitions simplified q p stayleftright mso formula defining acceptance uses dierent unary relation j state q j q namely reverseclosed reverseclosed formula stating 0 closed reverse transitions according andor semantics thus states initial configuration accessible andor graph gaw follows holds accepts w formula reverseclosed direct representation transitions edges gaw mso transition q u q u existential reverseclosed includes one conjunct example corresponding conjunct succx fo formula defining successor relation domw q u universal q u transitions q u reverseclosed includes conjunct see holds w accepts w suces notice similarity 1 3 one needs observe formula reverseclosed general graph 2 becomes formula instantiated gaw example notice andnode gaw zero two successors hence universal quantifier 2 becomes conjunction extend 3 case k arbitrary define predicate reverseclosed stating n i1 1 n closed reverse transitions mso formula equivalent 3 reverseclosed replaced reverseclosed 1 predicate reverseclosed assumes pebbles fixed positions described free variables x 1 x also free variables predicate considers moves aecting pebbles partition transitions set transitions states q reversedclosed transitions lifting placing pebble reverseclosed except also inspects presenceabsence previous i1 pebbles tests equalityinequality corresponding values current value example corresponding general transition p v q use formulas new transitions liftcurrentpebble placenewpebble transitions determine following conjuncts reverseclosed reverseclosed i1 v note resemblance i1 3 q v acts initial state pebble 1 note q u acts terminal state pebble completes proof translation mso note stack discipline imposed use pebbles essential construction proof open whether inclusion strict however show following proposition 14 every n mso formulas membership problem hard p respectively contrast membership 2apas ptimecomplete proof ajtai fagin stockmeyer 3 showed every level polynomial hierarchy ph mso formula graphs model checking hard level hence suces observe graphs readily encoded strings describe translation mso formulas mso formulas translation graphs e strings wg g hence model checking hard level ph model checking corresponding level ph end define wg string consisting blocks form 1 k ei j let vertexx obtained replacing every occurrence ex inductively replace inside outside every occurrence subformula xx x xvertexx xvertexx xx xx vertexx xx xx vertexx completes description translation latter statement proposition recall configuration kpebble 2apa consists state k positions pebbles takes logarithmic space size input therefore 2apa simulated alogspace equals ptime hardness follows reduction agap defined proof theorem 13 proposition 12 theorem 13 show pas fall nicely fo en mso next subsection show determinism nondeterminism one twoway coincide strong pas open whether alternating control yields additional power end subsection considering weak pas recall weak pas place new pebbles location current head rather beginning string clearly makes dierence oneway models unlike strong counter parts show weak pas cannot simulate fo justifies name proof based communication complexity show language defined proof theorem 5 cannot computed weak 1npas however use dierent kind communication protocol better reflects behaviour weak 1npa theorem 15 fo weak 1npa proof proof similar theorem 5 show communication complexity argument fo expressible language l 2 defined proof theorem 5 cannot recognized weak 1npa recall l 2 consists strings form uv u v encode 2hyperset let k fixed let sets new protocol one agent arbitrary access string u limited access string v u computational power unlimited access v restricted follows let fixed function agent evaluate f arguments v tuple length k symbols u 1 based information u agent decides whether uv accepted first show function f agent recognizes towards contradiction assume otherwise let 1 2 f corresponding finite sets advice function respectively let uv input string let denote set symbols occur u containing 1 2 u correctly encodes 2hyperset let assume wlog agent always evaluates f possible arguments k 1 arguments k 1dierent interactions agent function f important protocol nonadaptive ie order questions matter let let u 1 u h encodings h possible 2hypersets 1 2 large enough respect k 1 2 2hypersets 1 2 dierent interactions hence must encodings u u 2hypersets hu hu interactions uu u u hence agent accepts uu accepts contradiction remains show split strings weak 1npa simulated protocol intuitively works follows input uv consider oneway weak pas whenever current pebble enters v computation remains v pebble lifted therefore set states obtained lifting pebble depends v symbols pebbles placed u placement information pebbles located positions hence define fv set states reached pebble enters v state q pebbles placed symbols indicating pebble present q coded additionally also contains position placement pebbles u function provides enough information agent simulate 1npa 42 control next result shows variants strong pebble automata without alternation collapse suggests strong pas provide robust automaton model theorem 16 following expressive power 2npa 2dpa strong 1npa strong 1dpa proof show 2npa strong 1dpa b accepts language actually construction b uses number pebbles therefore let pebbles technical simplicity assume wlog lifts pebbles right delimiter instead lifting pebble arbitrary position remember target state q go right delimiter lift pebble moving state q first informally describe idea construction recall classical powerset construction translates nondeterministic 1way automaton finite alphabet without pebbles deterministic one intuitively computes prefix u input string set states might reach reading u performs online simulation sense step computation corresponds exactly one step one cannot expect online simulation work 2way automata even finite alphabets nondeterministic behaviour 2way automaton might involve moving dierent directions instead finite case without pebbles deterministic automaton compute position input string w function f describes aggregate behaviour w 1 w ie portion input lefthand side ith position functions f computed inductively left right forgetting f i1 f computed end f n knowledge possible first states automaton assumes right delimiter input provide necessary information decide whether w accepted maybe bit surprising approach large adapted case pebbles present alphabet infinite proceed follows first assume normalized accepts input configurations 1 q ie one pebble virtually adding two steps view accepting computation consisting 1 first step first pebble placed first position 2 computation always least one pebble present 3 final step remaining pebble removed writing 0 virtual configuration without pebble determine whether accepts one find whether 0 q 0 0 q final state q latter done recursively solving subproblems form q q subscript indicates subcomputations considered every step pebbles present formally show following claim induction starting claim 17 0 k finite set r strong 1dpa b k pebbles whenever b starts configuration p p r next configuration depth b p q particular set states b contains r r 2 qq first noted theorem follows claim end set intended initial state b 0 obtain automaton ends state p 0 set q q q 0 q 0 0 q set final states b 0 simply consists states p 0 contains pair proof claim trivial configurations depth k hence b k compute p staytransition therefore let k suppose claim holds j intuitively set computed one lefttoright pass i1st pebble pass b computes position l string sets pairs q q subcomputation starts state q position l position 1 respectively ends state q position l without moving pebble positions l l note subcomputations might move pebbles j positions l compute information automaton b i1 used repeatedly first introduce notation let input string w length n fixed l n let l denote 1pebble assignment coincides first pebbles l l write l set pairs q q states computation starting 1 q l reaching includes configurations j q fulfill j 1 j intuitively says pebble allowed move right position l write l set pairs q q states l reached subcomputation satisfying property ready complete proof claim set l computed follows let r l set pairs q q one following holds exist 1dra 1nra mso w1dpa w2npa figure 1 inclusions classes consideration solid lines indicate inclusion strictness shown dotted lines indicate classes incomparable dashed lines indicate strict inclusion subject complexitytheoretic assumptions straightforward see simply transitive closure r information needed computed one lefttoright pass pebble 1 induction assume subautomaton b i1 computes position l part r contributed condition b note c computation transitive closure require pebble movements pass automaton compute position l set l computation l makes use sets n n transition relation one deduce lift pebble step set claim note n position right delimiter recall lifts pebbles position completes proof claim theorem registers versus pebbles known inclusions classes considered depicted figure 1 pebble register models rather incomparable indeed connection logic deduce following 2dra already express nonmso definable properties twoway register model subsumed pebble model conversely strong 1dpas already express fo strong pebble model subsumed register model open problems relationships register pebble automata given section 6 5 decision problems briefly discuss standard decision problems ras pas kaminski francez already showed nonemptiness 1nras decidable decidable whether la lb 1nra 1nra b 2registers next show universality automaton accept every string 1nras un decidable implies containment arbitry 1nras undecidable kaminski francez asked whether decidability nonemptiness extended 2dras show cannot regarding pas show nonemptiness already undecidable weak 1dpas due fact pas lift pebble control transferred pebble 1 therefore even weak 1dpas make several lefttoright sweeps input string proofs use reduction post correspondence problem pcp wellknown undecidable 11 instance pcp sequence pairs instance solution n 1 1 n x 1 x asks whether given instance problem solution suppose wlog integer numbers 1 n values b denote latter set symbols sym consider input strings form delimiter u v strings representing candidate solution pcp instance suitable way check whether candidate indeed solution roughly check whether corresponding pairs taken 2 strings corresponding positions x 1 xm carry symbol check 1 2 use double indexing system based unique data values describe encoding detail item x j encoded string separator sym represents j unique data value b x j represent position x unique data value achieve uniqueness symbols allowed occur u correspondingly j encoded string j corresponding conditions hold string uv syntactically correct properties described far fulfils following two conditions projection u ie string consisting entries u equals projection v projection u equals projection v syntactically correct string uv represents solution pcp instance numer right u v symbol b right u v next show universality 1nras weak 1dpas undecidable former case construct 1nra accepts input string w syntactically correct represent solution hence accepts inputs pcp instance solution construction nondeterminism comes play automaton simply tries guess error encoding represented input string showing undecidability universality weak 1dpas construct automaton checks whether error occurs encoding represented input string happens several sweeps input string 51 register automata theorem undecidable whether 1nra universal proof initial register assignment assigns values sym first n registers construct 1nra accepts input string w syntactically correct represent solution hence accepts inputs pcp instance solution checks one following conditions holds input string w 1 w wrong form w form uv u v form 1 1 n b x 1 k entry u 1 k entry v 2 projections wrong first u diers first v b last u diers last v c two u two v successors u v latter three conditions involve nondeterministic guesses positions failure takes place 3 projections wrong done completely analogous fashion 4 w represent solution value u dierent corresponding value v b abvalue u dierent corresponding abvalue v clearly w solution one conditions holds corollary 19 containment 1nras undecidable next question also raised kaminski francez section 32 observed twoway ras simulate multihead automata strings special shape nonemptiness multihead automata undecidable next proposition easily follows proposition 20 undecidable 2dra whether 52 pebble automata next result implies standard decision problems undecidable classes pebble automata theorem 21 undecidable whether weak 1dpa nonempty proof weak 1dpa first checks whether input desired form accepts input encodes solution pcp instance pebbles moved right keep first pebble first position invoke subroutines position performed pebbles puts first pebble first position operates follows 1 checks whether u v form 1 k respectively entries u v achieved one left right scan second pebble reaching end string pebble simply lifted 2 check w syntactically correct verifies following u dierent places second pebble first scans u third pebble dierent first one second pebble moved next process repeated b checking v dierent similar c first u equals first w puts second pebble first uses third pebble run first w checking last u equals last w similar successors u also successors v involves four pebbles numbered 2 5 second pebble cycles u value automaton proceeds follows third pebble placed right second pebble fourth pebble cycles symbols v finds found fifth pebble placed right consistency checked check fails found v input rejected otherwise three recent pebbles removed f analogous way also verified form index 3 check w represents solution pcp instance proceeds follows checks x picked u corresponding choice v hereto second pebble cycles values u keeps corresponding value finite memory uses third pebble run v checks whether entry latter conforms entry former b analogous way also check avalues corresponding entry completes description construction straightforward check accepts input represents solution pcp instance hence pcp instance solution la nonempty 6 discussion investigated several models computations strings infinite alphabet one main goal identify natural notion regular language corresponding automata models particular notion agree finite alphabet case classical notion regular language considered two plausible automata models ras pas results tend favor pas natural two indeed expressiveness pas lies fo mso inclusion fo provides reasonable expressiveness lower bound mso upper bound indicates languages defined pas remain regular natural sense moreover strong pas quite robust variants without alternation one twoway deterministic nondeterministic expressive power results paper quite intricate proofs bring play variety techniques confluence communication complexity language theory logic along way answered several questions ras left open kaminski francez several problems remain open weak 1dpa weak 1npa simulated 2dras ii 1dra 1nra subsumed pebble model know defined mso 1nras hard nlogspace likely cannot simulated 2dpas iii weak 1npas strictly powerful weak 1dpas iv 2apas strictly powerful 2npas r data web closure monadic np xml data values typechecking revisited formal model expressive fragment xslt monadic secondorder logic graphs handbook formal languages metafinite model theory complexity results twoway multipebble automata logics limits parallel computation introduction automata theory communication complexity parallel computing algebraic calculus query languages recursively typed complex objects structured document transformations based xsl type checking xml transformers extensions attribute grammars structured document queries query automata expressive e dtd inference views xml data tapebounded complexity classes multihead finite au tomata tr graph rewriting finitememory automata limits parallel computation complexity results twoway multipebble automata logics communication complexity parallel computing languages automata logic metafinite model theory temportal connectives versus explicit timestamps query temporal databases alternation data web intractability decision problems finitememory automata typechecking xml transformers dtd inference views xml data expressive efficient pattern languages treestructured data extended abstract closure monadic np web odyssey xml data values power walking querying treestructured data foundations databases query automata finite trees introduction automata theory languages computation formal model expressive fragment xslt automata logic xml ctr michael kaminski tony tan regular expressions languages infinite alphabets fundamenta informaticae v69 n3 p301318 august 2006 mikolaj bojaczyk claire david anca muscholl thomas schwentick luc segoufin twovariable logic data trees xml reasoning proceedings twentyfifth acm sigmodsigactsigart symposium principles database systems june 2628 2006 chicago il usa stphane demri ranko lazi david nowak freeze quantifier constraint ltl decidability complexity information computation v205 n1 p224 january 2007 luc segoufin static analysis xml processing data values acm sigmod record v36 n1 march 2007 thomas schwentick automata xmla survey journal computer system sciences v73 n3 p289315 may 2007
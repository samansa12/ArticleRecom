resource bounds selfstabilizing messagedriven protocols selfstabilizing messagedriven protocols defined discussed class weak exclusion contains many natural tasks ellexclusion token passing defined shown execution selfstabilizing protocol task class configuration size must grow least logarithmic rate last lower bound valid even system supported timeout mechanism prevents communication deadlocks present three selfstabilizing messagedriven protocols token passing rate growth configuration size three protocols matches aforementioned lower bound protocols presented twoprocessor systems easily adapted rings arbitrary size results interesting interpretation terms automata theory b introduction distributed system set state machines called processors communicate either shared variables messagepassing first case system shared memory system second case system messagepassing system distributed system selfstabilizing started possible global state started system regains consistency without kind outside intervention selfstabilization property useful systems processors may crash recover spontaneously arbitrary state intermediate period one recovery next crash long enough systemstabilizes selfstabilizing systems defined discussed first fundamental paper dijkstra dij74 work dij74 well following work selfstabilizing systems assume communication model shared variables among papers kr79 tc81 dij82 la86 bgw87 bu87 bp88 ij90 ij90a dim90 dim91 study fault tolerant messagepassing systems customarily assumed messages might corrupted links hence processors may enter arbitrary states link contents may arbitrary selfstabilizing protocols treat problems naturally since designed recover inconsistent globalstates surprisingly papers address selfstabilizing messagepassing systems earliest research model done gouda multari mu89 gm91 work developed selfstabilizing sliding window protocol twoway handshake use unbounded counters proved selfstabilizing message passing protocol must use timeouts infinite number safe states following gm91 two additional works dealt selfstabilizing protocols model work katz perry kp90 presents general tool extending arbitrary messagepassing protocol selfstabilizing protocol work afek brown ab89 presents selfstabilizing version wellknown alternatingbit protocol see eg bsw69 work research complexity issues related selfstabilizing messagepassing sys tems define configuration messagepassing system list states processors messages transit link size configuration messagepassing system number bits required encode configuration entirely protocol messagepassing system messagedriven action processors initiated receiving message work gouda multari gm91 proven messagedriven protocol possible configuration processors waiting messages messages link unwanted situation called communication deadlock selfstabilizing system stabilize started possible initial configuration including configuration communication deadlock implies nontrivial completely asynchronous selfstabilizing system cannot messagedriven problem dealt least two methods gouda multari gm91 proposed use timeout mechanism preserves message driven structure protocol expense compromising complete asynchronisity hand katz perry kp90 chosen give messagedriven structure present protocols configuration least one processor whose next operation sending message thus execution every atomic step message sent message ever received execution size configurations grows linearly work define study class selfstabilizing messagedriven protocols argument gm91 exists selfstabilizing messagedriven protocol completely asynchronous since look protocols whose configuration size grow linear rate resort slightly limited assumptions asynchronous behavior lower bounds assume abstract timeout device detects communication deadlocks initiates system upon occurrence consequently lower bounds present take account executions communication deadlock occurs upper bounds assume every initial configuration least one message link assumption much weaker assumption general timeout mechanism specific task study details tokenpassing informally tokenpassing task pass single token fairly among systems processors usually assumed systems predefined initial configuration exists single token selfstabilizing system predefined initial configuration execution reach configuration exactly one token present entire system tokenpassing basic task fault tolerant systems among works studied dk86 fault tolerant messagepassing systems ij90 selfstabilizing shared memory systems tokenpassing task looked special case mutualexclusion since possession single token interpreted permission enter critical section first part presentation prove lower bound configuration size protocols large class tasks called weakexclusion weakexclusion class contains nontrivial tasks require continuous changes systems configuration particular class includes exclusion tokenpassing show configuration size selfstabilizing protocol realizes weakexclusion task least logarithmic number steps executed protocol lower bound holds messagedriven protocols weekexclusion task including protocols systems equipped timeout mechanism result compared result gm91 shown messagedriven selfstabilizing protocol necessarily weekexclusion task must infinitely many safe system configurations specific execution must contain infinitely many distinct configurations implied results lower bound specify part system grows size memory used state machines size messages stored links number messages stored links together present three selfstabilizing messagedriven protocols tokenpassing communication deadlock problem avoided assumption least single message present communication link using assumption present three tokenpassing protocols two processors rate growth configuration size three protocols matches aforementioned lower bound protocols presented systems two processors easily adapted work rings arbitrary size without increasing asymptotic complexity done considering ring single virtual link first protocol processors memory messages size grow unboundedly time protocol uses ideas similar ideas sliding window protocol gm91 second protocol improvement first protocol size memory processors grows logarithmic rate size link content bounded second protocol improvement deterministic alternating bit protocol ab89 third protocol selfstabilizing tokenpassing protocol processors deterministic finite state machines messages fixed size growing part system number messages links rate growth matches lower bound mentioned results described also terms automata theory follows let sigma alphabet define queue machine q finite state machine equipped queue initially contains arbitrary non empty word sigma initially q arbitrary state step performs following reads deletes letter head queue b adds one letters sigma tail queue c moves new state computational power queue machine severely limited fact input alphabet work alphabet identical particular queue machine cannot perform simple tasks like computing length input word even deciding whether input word contains specific letter assume alphabet contains specified subset token letters queue machine tokencontroller starting nonempty queue arbitrary content eventually queue contains exactly one occurrence letter forever lower bound result implies tokencontroller exists every computation size queue must grow least logarithmic number moves machine third protocol implies token controller whose configuration size growth matches lower bound exists view fact queue machine cannot compute estimation number occurrences letters input word latter result appears somewhat counter intuitive selfstabilizing messagedriven systems 21 asynchronous messagedriven systems asynchronous distributed messagepassing system contains n processors processor state machine processors communicate using messagepassing along links edge stands two directed links one p p j p j p message sent p p j delayed unbounded amount time connecting link messages reach destination yet stored link transferred fifo first first order processor uniquely defined set atomic steps whenever processor active executes one atomic steps messagedriven protocol atomic step processor p begins receive operation p receives message one incoming links atomic step ends zero send operations sends messages along outgoing links atomic step p defined state 1 e link p receives message msg e 1 outgoing links along p sends msg respectively 2 state p following execution atomic step let n number processors links respectively system denote set states p configuration system vector states processors together lists list every link messages stored link configuration denoted cs 1 theta 2 theta delta delta delta n theta e 1 theta e 2 em list messages stored e j 1 j let c configuration atomic step applicable p c p state 1 c msg first message stored e c application c yields result configuration c 0 denote fact c sequence atomic steps applicable configuration c 0 first atomic step sequence 1 applicable c 0 second atomic step applicable c 1 1 delta finite infinite sequence starts arbitrary configuration c 0 every 0 c sequence atomic steps applicable c 0 note since deal selfstabilizing systems assume particular initial configuration every configuration valid initial configuration execution e fair every atomic step applicable infinitely often executed infinitely often execution e defines partial order atomic steps e relation happened lamport la78 1 j atomic steps executed processor e appears j e happened j 2 message msg sent j message msg received happened j 3 happened j j happened k happened k also adopt definition concurrent atomic steps la78 atomic steps 1 said concurrent execution e 1 happen j j happen e following proposition gives sufficient condition set steps concurrent execution k distinct processors let set atomic steps j aplicable p configuration c exists execution atomic steps 1 delta delta delta k concurrent proof observe step applicable processor p configuration c step remains applicable p subsequent configurations execution e defined execution starts c processors p activated one processor p j executes j proof follows since processors distinct since e message sent received k executed note proposition holds system step applicable remains applicable long executed asynchronous protocol pr defined set n processors definitions asynchronous protocol defines set executions satisfy following 1 delta arbitrary execution pr every prefix e also execution pr 2 arbitrary finite execution pr every atomic step configuration c satisfying c r c pr execution e ffi c 1 1 sequences 1 denotes concatenation 1 22 selfstabilizing messagedriven protocols selfstabilizing system demonstrates legitimate behavior time started arbitrary configuration natural way specify behavior abstract way set sequences configurations define tasks sets legitimatesequences semantics specific task expressed requirements sequences intuitively legitimate sequence thought execution protocol require formally instance mutualexclusion task defined set sequences configurations processor subset states called critical section configuration one processor critical section every processor critical section infinitely many configurations formally define task one specify possible system st set legitimate sequences st task defined union legitimate sequence set possible systems configuration c system safe respect task protocol pr fair execution pr starting c belongs proving lower bound results selfstabilizing messagedriven protocols assume system recover communication deadlock called deadlock words prove lower bounds assume protocol stabilizes executions deadlock occurs purpose distinguish two types deadlocks global local configuration c global deadlock configuration atomic step applicable c first lower bound holds asynchronous systems recover global deadlocks applying global timeout mechanism abstract mechanism initiates system global deadlock configuration default initial configuration deadlock occurs bring requirement selfstabilizing systems equipped global timeout mechanism definition system required reach safe configuration every infinite fair execution note definition infinite fair execution deadlock configuration assuming global timeout mechanism let pr le message driven protocol set legitimate sequences respectively protocol pr sellfstabilizing relative le every c execution pr starts c every infinite fair execution reaches safe configuration respect le pr later prove lower bound holds systems immuned stonger type communication deadlock called local deadlock processor p local deadlock execution e p activated ie executes atomic step finitely many times e second lower bound holds systems equipped abstract local timeout mechanism prevents executions eg enabling processor idle sufficiently long time initiate system default configuration deadlock possible note local timeout mechanism strictly stronger global timeout mechanism assuming local timeout mechanism let pr le message driven protocol set legitimate sequences respectively protocol pr sellfstabilizing relative le every c execution pr starts c every infinite fair execution processor activated infinitely often reaches safe configuration respect le pr 3 lower bound section prove lower bound rate configuration size grows along every execution protocol large class tasks called weakexclusion class contains nontrivial tasks require continuous changes systems configuration particular class includes exclusion tokenpassing execution e denote e set distinct atomic steps executed p e task belongs class weakexclusion set legitimate sequences le satisfies e 2 le exists set two atomic steps j 2 j e atomic steps b never concurrent e first consider selfstabilizing protocols systems equipped global timeout mech anism protocols prove every execution communication deadlock occurs configurations distinct conclude configuration size every selfstabilizing protocol realizes weakexclusion task least logarithmic number steps executed protocol throughout proof assume pr selfstabilizing messagedriven protocol arbitrary weakexclusion task system global timeout mechanism end section present slightly weaker lower bound systems local timeout mechanism configuration c link e denote c e sequence messages present e c execution e denote e es er sequence messages sent received along e e proposition 2 every execution every link e c 0 er cr e proof left hand side equation contains messages present e c 0 concatenated messages sent e e right hand side equation contains messages received e e concatenated messages left e c r hard verify sides equation represent sequence messages execution configuration c equal initial configuration c 0 called circular execution link e active circular execution e messages received hence circularity e messages sent along e e repeating circular execution e forever yields infinite execution e 1 necessarily fair original execution may applicable step never executed e step applicable throughout e 1 never executed avoid problem original circular execution changed removing messages links active throughout e result execution still called e still circular infinite repetition e 1 fair infinite execution observe execution certain configuration appears circular subexecution thus show every execution pr configurations distinct assume pr circular subexecution e reach contradiction showing pr selfstabilizing using e construct initial configuration c init changing list messages transit systems links link e list messages transit e c init obtained concatenating list messages transit e c 0 list messages sent e e roughly speaking effect change creating additional layer messages helps decouple send counterpart receive achieve additional flexibility system enables proof lower bound formally c init obtained c 0 follows ffl state processor c init equal state c 0 ffl active link e c init e e es nonactive link e c init e empty let ai sequence atomic steps executed p e define mergea set sequences obtained possible mergings sequences ai 1 keeping internal order ai note sequences mergea finite length contain atomic steps different orders lemma 3 every 2 mergea applicable c init resulting execution circular execution pr proof let arbitrary sequence mergea let p arbitrary processor system initial state p c init equal initial state c 0 ii c init messages p receives e stored p appropriate incoming links right order iii atomic steps p appear order appear ai imply sequence applicable c init application c init yields execution ea result configuration c res whose state vector equal state vector c init every active link ea es es ea er er prove obtained execution circular remains shown content every link result configuration c res equal content c init ie c init e cres e arbitrary link e holds 1 c init e es er cres e proposition 2 fact ea es es er er 2 c 0 e proposition 2 circularity e replacing c init e equation 1 explicit contents yields 3 c 0 cres e using equation 2 replace c 0 e es er e equation 3 gives 4 e er e es er cres dropping er two sides equation 4 yields desired result c init cres e proves lemma define blowupe set executions whose initial sate c init whose sequence atomic steps belongs mergea notice every circular execution e every execution holds lemma 4 set atomic steps e execution e 2 blowupe contains configuration atomic steps b concurrent proof notational simplicity assume g let sequence constructed follows first take steps a1 precede 1 take steps a2 precede 2 take steps precede n applying sequence constructed far c init results configuration applicable sequence completed sequence mergea taking remaining atomic steps arbitrary order keeps internal order pr selfstabilizing messagedriven protocol arbitrary weak exclusion task system global timeout mechanism pr circular execution pr infinite fair execution e 1 none whose configuration safe proof let e arbitrary execution blowupe define e 1 infinite execution obtained repeating e forever definition blowupe e 1 fair remains show configuration e 1 safe assume way contradiction configuration c 0 e 1 safe construct finite circular execution e 0 whose sequence atomic steps 0 obtained concatenating sequences mergea pr protocol weak exclusion task e 0 set atomic steps never applicable single configuration c e 0 reach contradiction refuting statement choose arbitrary enumeration sets containing n atomic steps n distinct processors execution e 0 constructed first continuing computation c 0 e configuration c init reached apply lemma 4 extend e 0 consecutive executions contains configuration steps b k applicable ends c init proof follows note execution e 0 repeated forever obtain infinite execution suffix le thus protocol pr even pseudo selfstabilizing see bgm90 proof lower bound completed following theorem theorem 6 let pr selfstabilizing messagedriven protocol arbitrary weak exclusion task system global timeout mechanism every execution e pr configurations e distinct hence every 0 size least one first configurations e least dlog 2 te proof assume way contradiction exists execution e pr configurations distinct e contains circular subexecution e lemma 5 exists infinite execution e 0 pr obtained infinite repetition execution blowupe never reaches safe configuration contradiction proving similar lower bound systems local timeout mechanism definition circular execution must modified removing messages non active links construct infinite execution e proof theorem 6 may yield infinite execution processor enabled finitely many times order allow repetitions finite executions form infinite fair execution every processor active infinitely often require finite execution contains atomic step processor system need concept round execution let e 0 minimal prefix execution e every processor receives message e 0 first round e let 00 suffix e satisfies second round e first round prefix contains first atomic steps e let number rounds e next theorem presents lower bound systems equipped local timeout mechanism proof similar proof theorem 6 theorem pr selfstabilizing messagedriven protocol arbitrary weak exclusion task system local timeout mechanism every execution e pr contain circular subexecution contains complete round conclude execution pr e first rounds contain least distinct configu rations hence every 0 size least one configuration e least dlog 2 particular fair execution configuration size unbounded 4 upper bound tokenpassing task defined informally set executions single token present entire system passed fairly among systems processors tokenpassing special case mutualexclusion since possession single token interpreted permission enter critical section reason tokenpassing also satisfies weakexclusion property hence lower bound section 3 holds particular means selfstabilizing messagedriven protocol pr tokenpassing must use unbounded resource since infinite execution system size grows beyond bound section present three selfstabilizing tokenpassing protocols systems two proces sors protocol configuration size grows every execution rate matches lower bound protocols easily adapted work rings arbitrary size without increasing asymptotic complexity considering ring single virtual link similar ideas used adapting protocols arbitrary rooted tree systems standard symmetry argument exists selfstabilizing deterministic tokenpassing protocol processors identical hence section assume system consists two distinct processors called sender receiver connected two links first link carries messages sender receiver second link carries messages receiver back sender receiver processor identical three protocols probably simplest possible finitestate machine program copy message receives incoming link outgoing link without alteration outside world combined behavior receiver two links looks like behavior single queue whose head tail used receiver analysis ignore receiver consider systems single processor sender communicating using single link messages kept fifo order step sender consumes message head link puts one messages back tail link tokens represented special symbol appended messages protocols specify messages carry token use explicitly token symbol protocol guarantee eventually unique message system appended protocols assume initially least one message link assumption weaker global local versions timeout mechanism last assumption requirement link never becomes empty equivalent requirement whenever message received least one message sent hence every step protocol sender receives message head single link puts one messages links end three protocols present protocol 1 protocol sender infinite state machine every execution link capacity unbounded protocol 2 protocol sender infinite state machine infinite execution link capacity bounded bound specific execution depends initial configuration protocol 3 protocol processors finite state machines forever 3 msg counter counter token arrives 4 begin send new token 5 counter msg counter 1 6 sendcounter 8 else sendcounter 9 end figure 1 protocol 1 protocol 1 sender appears figure 1 sender uses variable called counter message consists present value counter possibly token symbol whenever sender receives message whose counter value msg counter smaller counter sets counter msg counter sends new value counter together token otherwise sender sends current value counter without token token letter used protocol correctness protocol based fact eventually value counter larger values appear messages present link initial configuration asymptotic size counter execution number messages sent details proof omitted 41 aperiodic sequences protocols 2 3 use following method message associated ternary number called color protocol considers message whose color different color previous message carrying token sender local variable called token color given configuration sender sending sequence messages whose color equal value token color time sender waits message whose color equal token color long sender receives messages different colors sends messages whose color equal token color sender receives message whose color equal token color chooses new token color initiates new sequence messages whose color new token color sending first message new sequence first message carrying virtual token sender continues sending messages new token color without tokens receives message new token color goal reach configuration link always holds two consecutive sequences messages colors messages sequence equal every step sender consumes single message first sequence whose color previous token color produces one messages whose color equal present token color last message whose color previous token color consumed link contains single sequence messages whose color token color next step sender receives token carried sequence sends initiating new sequence messages whose color new token color described configurations exists single token carried first message sequence whose color token color correctness protocols follows fact sequences tokencolors sent receiver aperiodic defined sequence 1 positive integer k sequence eventually periodic suffix periodic aperiodic eventually periodic aperiodic sequences integers f0 1 2g used ab89 order obtain self stabilizing data link protocols sequences created either random number generator infinite state machine first case algorithm randomized elements sequence used protocol ab89 whenever decide ternary number sent new message paper aperiodic sequences generated using counter sequence xor defined definition integer xori sum bits mod 2 binary representation eg 0 sequence denoted xor show later sequence xor aperiodic sender appears figure 2 improvement protocol appears ab89 sense achieves lower bound previous section sense achieves lower bound previous section amount memory used producing aperiodic sequence addressed specified ab89 protocol 2 forever token color token arrives 4 begin send new token 6 counter counter 1 8 sendtoken color 9 end figure 2 protocol 2 sender keeps counter local memory whenever message new color sent counter incremented new color 2 f0 1 2g determined previous color applying xor counter roughly speaking correctness protocol implied fact since xor aperiodic sequence colors generated sender aperiodic well nature variables correctness proof protocol 2 easily derived description protocol 3 correctness proof hence omitted 42 informal description protocol 3 present protocol 3 processors finite state machines easily observed aperiodic sequence supplied external device finite state machine use sequence perform protocol ab89 construction uses fact finite state machine augmented previously described fifo link generate aperiodic sequence finite state machine uses link messagepassing generating aperiodic sequence size kept within optimal bound protocol 3 easily transformed selfstabilizing data link protocol processors finite state machines protocol 3 appears figure 3 protocol message pair color bit 1g local variables color token color ternary variables variables counter bit counter xor carry new counter bit binary binary xor operation denoted phi sequence messages ns denotes integer whose binary representation bit k bit least significant bit maximal sequence consecutive messages color sent sender called block block b nb denotes integer described jbj denotes number messages b first message block viewed token show protocol selfstabilizing prove eventually link contains exactly one message first message block goal achieved making sequence colors blocks aperiodic sender uses local variable called token color denotes color block sending continues send messages color long colors messages receives different token color sender receives message whose color equal token color eventually means messages link belong block possibly sends one last message current block b changes value token color c sends first message new block new color forever receivecolorcounter bit token color token arrives new token 6 token color color 7 counter xor 0 9 end counter xor counter xor phi counter bit new counter bit carry phi counter bit carry carry counter bit send token colornew counter bit 14 end figure 3 protocol 3 lemma 8 show every execution sender initiates infinitely many blocks sequence blocks initiated sender color b integer represents nb defined protocol designed following properties kept p1 sequence colorb 1 p2 every large enough nb bit field last message b nb const constant const representation nb b leading zeroes implying jb prove p1 implies eventually one token system p2 guarantees size system logarithmic number steps show protocol indeed satisfies p1 p2 describe two rules sender computes bits colors sends need following definition 1 denote k sequence messages whose colors different received sender sends block b k ns k integer represented k note k consists one complete blocks rule 1 rule computing counter bits counter bit sent message sent k nb k eg words counter bits sent block b k obtained adding 1 binary number represented messages received block sent rule 2 rule computing token color receiving message whose color equal value token color new value token color color next block b k1 determined follows colorb k1 note rule 1 implemented binary adder set zero initiation new block rule 2 implemented counter mod 2 thus rules easily implemented finite state machine 43 correctness complexity proofs protocol 3 lemma 8 every fair execution e sender initiates infinite number blocks proof sender initiates new block whenever receives message whose color equal current value token color every atomic step sender receives message whose color equal token color sends message say whose color token color since link carries messages fifo order message eventually received sender initiates new block later upon receipt lemma follows configuration execution called limit configuration next step sender new token color computed color next arriving message equal present value token color observe limit configuration c link contains finite possibly zero number complete blocks one possibly incomplete block tail link block may incomplete since upon receipt next message sender may send one message block executing line 5 code first block color last possibly incomplete block execution e denote k index kth limit configuration e words c k limit configuration b k initiated next prove number blocks consecutive limit configurations increase lemma 9 let k number blocks limit configuration c k including possibly incomplete block k k1 equality k single block number blocks k subexecution starting c k ending c k1 one block added link namely b k k blocks k removed therefore next show number blocks limit configurations must eventually get one first need technical lemma lemma 10 sequence xor aperiodic b let 1 delta eventually periodic sequence let b sequence delta also eventually periodic c let 1 delta eventually periodic sequence sequence delta also eventually periodic proof assume contradiction sequence xor eventually periodic exist st q nonnegative integer 2 q let integer satisfying q consider following cases 1 definition holds xor2 thus thus exist b 1 b 2 xorb contradiction b claim trivial c let j j every p 1 holds k kp thus sequence ai p eventually periodic period length lemma 11 every fair execution e exists suffix number blocks limit configurations always one proof lemma 9 number never increases hence eventually remains l constant l 0 forever shall assume l 1 derive contradiction call limit configuration c k ultimate k number blocks c k l c k ultimate hence lemma 9 k single block must b kgammal thus first block follows k b kgammal1 protocol b k terminated sender receives message whose color equal color b k therefore color messages block b kgammal1 equal color messages b k hence sequence eventually periodic period length way colorb k1 computed ultimate configuration c k xornb eventually periodic bxor shall derive contradiction showing sequence bxor aperiodic implies order show bxor aperiodic sufficient show positive p sequence bxori delta aperiodic observe ultimate configuration c k must hold nb k 1 hence integer thus bxoril suffix sequence xor aperiodic lemma 10 hence bxoril also aperiodic yields desired contradiction lemma 11 proof imply properties p1 p2 hold property p1 holds since proof lemma 11 shows sequence colors aperiodic property p2 proved follows let e 0 suffix e satisfying lemma 11 let c k limit configuration e 0 rule 1 nb easily implies p2 show space complexity protocol 3 indeed matches lower bound previous section since number states processor number distinct messages protocol constants size configuration proportional number messages therefore bound size configuration enough bound number messages next lemma show execution delta protocol size ith configuration e c olog 2 let denotes kth limit configuration e let b k corresponding block shall prove jb k lemma 12 every large enough k number messages limit configuration c k dlog 2 proof lemma 11 exists suffix e 0 e every limit configuration contains one block clearly suffices prove lemma e 0 observed property p2 eventually holds every limit configuration e 0 lemma follows corollary 13 number messages c th configuration e olog 2 proof let e 0 suffix e lemma 12 assume large enough c belongs e 0 number messages c equal number messages next limit configuration c k olog 2 k proof completed observation since j j j since configuration c precedes c e 44 larger systems describe use protocols directed rings two processors processors ring denoted p receivers whenever processor p message p sends similarly whenever p n receives message p sends p 1 thus ring behaves like virtual link sender p 1 hard see existence single message entire ring prevents communication deadlocks thus assume timeout mechanism guarantees condition timeout mechanism invoked recover initial deadlock configuration proved way similar previous proofs protocols guarantee eventually exactly one token encircles ring sender actually protocols used connected system hardwiring directed ring spans entire system 45 construction token controller subsection define queue machines token controllers interpret results terms queue machine q finite state machine equipped queue initially contains nonempty word sigma finite alphabet sigma step computation q performs following reads deletes letter head queue b adds zero letters sigma tail queue c moves new state computation terminates q halts queue becomes empty prevents q performing steps main difference queue machines various types turing machine input alphabet work alphabet queue machine identical reason queue machine cannot perform simple tasks like deciding length input word even deciding whether input word contains specific letter 2 define token controller special type queue machine assume alphabet sigma contains specified subset token letters queue machine token controller starting nonempty queue arbitrary content eventually queue contains exactly one occurrence letter forever priori clear token controller exists observe token controller exists queue never becomes empty since queue empty remains forever importantly token controller exists never halt since cannot guarantee upon halting queue contains exactly one occurrence token letter last two observations imply token controller viewed special case tokenpassing system sigma set messages sent protocol set messages carry token show transform sender protocol 3 token controller define alphabet sigma set triplets color bit color bit protocol 3 either case message carries token ie first message block nil case set defined set possible triplets whose third component two antiparallel fifo links sender receiver considered single queue receiving message regarded deleting letter head queue sending message regarded appending message end queue since protocol 3 guarantees eventually exactly one message every configuration carrying token queue machine described token controller moreover lower bound results imply tokencontroller optimal respect rate size queue grows stabilizing simulation shared memory section present method simulating selfstabilizing sharedmemory protocols selfstabilizing messagedriven protocols simulated protocols assumed variant queue machine use arbitrary work alphabet fact oblivious turing machine powerful standard turing machine sharedmemory model defined dim90 model communication neighbors carried using twoway link link implemented two shared registers support read write atomic operations processor p reads one register writes functions reversed p j implementing system every link simulated two directed links one p p j p j p heart simulation selfstabilizing implementation read write operations proposed simulation implements operations using selfstabilizing tokenpassing protocol pair neighbors run protocol two links connecting order implement selfstabilizing tokenpassing protocol need define link processors acts sender processors acts receiver assume processors distinct identifiers every message sent processors carries identifier processor eventually processor knows identifier neighbors link processor larger identifier acts sender processor acts receiver since pair neighbors uses different instance protocol separate timeout mechanism needed every pair words correct operation simulation requires pair neighbors exists least single message one two links connecting neighbors describe simulation arbitrary link e connecting p shared memory model e implemented register r ij p writes p j reads register r ji roles reversed simulating protocol processor p local variable called r ij r ji keeps values r ij r ji respectively every token additional field called value every time p receives token p j current value r ij value field token write operation p r ij simply implemented locally writing r ij read operation p r ji implemented following steps 1 receives token p j 2 p receives another token p j value read value attached second token correctness simulation proved showing every execution e whose initial configuration contains least one message link possible linearize simulated read write operations executed e eventually every simulated read operation r ij returns last value written ie protocol simulates executions sharedmemory model registers eventually atomic see la86 define time simulated write operation r ij time local write operation r ij executed define time simulated read operation p j r ij time p sends value local variable r ij attached token later reaches p j step 2 simulated read link holds single token operations register r ij linearized every read operation r ij returns last value written r ij acknowledgments thank alan fekete helpful remarks r selfstabilization alternatingbit protocol selfstabilizing token system stabilization pseudo stabilization uniform selfstabilizing rings note reliable fullduplex transmission halfduplex links selfstabilizing rings without demons selfstabilizing systems spite distributed control selfstabilizing systems spite distributed control ewd391 self stabilization dynamic systems assuming readwrite atomicity resource bounds self stabilization message driven protocols uniform dynamic selfstabilizing leader elec tion token survival stabilizing communication protocols token management schemes random walks yield self stabilizing mutual exclusion selfstabilizing ring orientation selfstabilizing extensions messagepassing systems selfstabilization spite distributed control treestructured systems time clocks ordering events distributed system solved problems unsolved problems nonproblems concurrency interprocess communication part basic formalism toward theory selfstabilizing protocols tr ctr rodney r howell mikhail nesterenko masaaki mizuno finitestate selfstabilizing protocols messagepassing systems journal parallel distributed computing v62 n5 p792817 may 2002 kleoni ioannidou transformations selfstabilizing algorithms journal high speed networks v14 n1 p85105 january 2005 bertrand ducourthial sbastien tixeuil selfstabilization path algebra theoretical computer science v293 n1 p219236 3 february paolo boldi sebastiano vigna universal dynamic synchronous selfstabilization distributed computing v15 n3 p137153 july 2002
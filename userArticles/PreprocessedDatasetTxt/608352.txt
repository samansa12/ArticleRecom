polynomialtime decomposition algorithms support vector machines paper studies convergence properties general class decomposition algorithms support vector machines svms provide model algorithm decomposition prove necessary sufficient conditions stepwise improvement algorithm introduce simple rate certifying condition prove polynomialtime bound rate convergence model algorithm satisfies condition although clear existing svm algorithms satisfy condition provide version model algorithm algorithm show slack multiplier c satisfies sqrt12 c ml number samples l matrix norm takes 4lc2m4epsi iterations drive criterion within epsi optimum b introduction soft margin formulation cortes vapnik 1995 advantage provides design criterion support vector machines svms separable nonseparable data maintaining convex programming problem maintain computationally feasible approach across kernels algorithms developed wolfe dual quadratic program qp problem whose size independent dimension ambient space gram matrix wolfe dual number data samples large storage requirements matrix excessive thereby preventing application many existing qp solvers barrier overcome decomposing original qp problem smaller qp problems employing algorithmic strategies solve sequence smaller qp problems class algorithms considered smaller qp problems restrictions original qp problem optimization allowed subset data called working set key select working sets guarantee progress toward original problem solution step algorithms commonly referred decomposition algorithms many existing svm algorithms fall class cristianini shawetaylor 2000 joachims 1998 keerthi shevade bhattacharyya 1998 paper provide model algorithm decomposition prove necessary sucient conditions stepwise improvement algorithm conditions require working set contain certifying pair dened section 3 computation certifying pair takes om time dene simple rate certifying condition certifying pairs enables proof polynomialtime bound rate convergence clear working sets chosen existing svm algorithms contain certifying pairs satisfy condition hand provide om log algorithm determining certifying pair next section sets stage development providing formal denition problem establishing basic properties preliminaries nite set observations twoclass pattern recognition problem x 1g support vector machine svm maps space covariates x hilbert space h higher dimension possible innite ts optimal linear classier h choosing map way known easy evaluate function k sucient conditions existence map provided mercers theorem vapnik 1998 let z linear classier h given lanl technical report laur003800 2 preliminaries soft margin formulation cortes vapnik 1995 optimal given optimizes wolfe dual quadratic programming problem st choice unspecied parameter c 0 investigated address determined optimal value b given v low b v high v low v high dened section 3 paper concerned analysis class algorithms wds motivated situations large direct storage q prohibitive let wds denote instance wolfe dual dened sample set let represent set feasible solutions wds note convex compact denote wolfe dual criterion let represent set optimal solutions wds rg verifying q symmetric positive semidenite thus r concave function r unique lagrangian wds takes form lanl technical report laur003800 3 optimality using certifying pairs karushkuhntucker kkt conditions eg see avriel 1976 p96 wds take form made use relation three regimes two equals bound one falls bounds combining conditions three regimes obtain simpler set conditions equivalent kkt conditions possible use satisfaction equations stopping condition optimization algorithms involve alternative set optimality conditions introduced keerthi et al 2001 keerthi gilbert 2000 use next section present conditions use develop simple optimality test 3 tests optimality using certifying pairs dene partition index set based upon data low low g let i2i low i2i high sup inf empty set dened 1 1 respectively lanl technical report laur003800 3 optimality using certifying pairs denition 1 properly ordered jv int low v high jv int low v int v prove result rst stated keerthi gilbert keerthi gilbert 2000 theorem 1 keerthi gilbert feasible wolfe dual problem wds optimal properly ordered proof optimality conditions 7 rewritten low suppose optimal equations 12 imply low low rst equation implies jv int second equation implies v low v high jv int second third equations imply low v int v high properly ordered hand suppose properly ordered jv int denitions v low v high clear low low choose point v low high conditions 12 satised consequently optimal properly ordered tests proper ordering simplied dene low low int high high int i2 low high properly ordered wds low v proof statement follows directly proof theorem 1 lack optimality determined existence certifying pair denition 2 certifying pair 2 pair indices j index set whose values v sucient prove properly ordered note keerthi et al keerthi gilbert 2000 refer violating pair however later dene rate certifying pair decided adopt terminology theorem 2 properly ordered exists certifying pair certifying pair obtained making one pass data making two comparisons proof suppose properly ordered exists indices 2 high low v v j choose pair determine certifying pair make one pass data keeping track indices represent high v low stop rst point high v low 4 general decomposition algorithm algorithmic solutions wolfe dual must consider fact large storage requirements q excessive barrier overcome decomposing original qp problem smaller qp problems suppose partition index set working set w nonworking set w c note w indexes subset data partitioned accordingly q partitioned follows qw c w qw c w c w 3 written xed becomes qp problem size dimw generic properties original motivates algorithmic strategies solve sequence qp problems dierent working sets key select working set step guarantee progress toward original problem solution theorem 3 consider subset constrained wolfe dual problem dened follows consider feasible dene subset w index space complement w c optimize wolfe dual criterion respect subject constraint w c let denote solution constrained problem r r w contains certifying pair proof since r concave nonoptimal wds feasible innitesimal 0 16 solution constrained wolfe dual produces increase r feasible constrained nontrivial components w dr consequently prove theorem sucient show feasible w exists satises w contains certifying pair derivative r given feasible directions satisfy terms conditions become high low decompose components subsets dened high low int 16 written high v high low v low feasibility constraints high 1 low low 0 int free 18 assume w contains certifying pair must satisfy one following inequalities low low four cases verify 1718 choosing certifying pair proof nished assume feasible w dr w 0 1718 restrictions v int int indices w jv int w j 1 two components certifying pair jv int w high v high low v low combining 18 gives high v high v low v low v 1 0 high 0 low 0 inequality hold least one two terms must negative make rst term negative least one component v high v 1 must negative similarly make second term negative least one component v low v 1 must positive either case gives certifying pair finally jv int w high v high low v low 0 high low 1 high 0 low 0 without loss generality let components high low normalized i2i high i2i low high v high low v low dierence convex combinations v high w convex combinations v low w dierence negative two convex hulls must overlap implies certifying pair nishes part proof nished theorem 3 motivates class algorithms form algorithm 1 members class solve sequence decomposed qp problems form 15 working sets vary size 2 jsj contain least one certifying pair initialization ensures w 0 contains least one certifying pair qpsolve routine line 11 solves qp problem restricted current working set w k 1 line 14 chooses certifying pair inclusion next working set algorithm terminates certifying pair longer exists anysubset routine line chooses subset samples included certifying pair next working set subset irrelevant issue guaranteed improvement likely eect rate convergence e algorithm decomposition algorithm 1 2 3 4 output 5 7 8 low 9 10 w 0 subset least one sample class 12 loop 13 14 update membership low high samples w k 1 low high v v j 17 19 end 22 end loop convergence general stepwise improvement algorithm 1 sucient guarantee convergence indeed keerthi ong keerthi ong 2000 provide example working set contains certifying pair algorithm 1 converge optimal solution however convergence results proved special cases eg see keerthi gilbert 2000 chang hsu lin 2000 lin 2000 convergence result keerthi gilbert 2000 denes optimal satises v low high shows generalized smo gsmo algorithm converges optimal solution nite number steps gsmo algorithm special case algorithm 1 anysubset function returns empty set analysis keerthi gilbert 2000 leaves open question accuracy respect optimal solution provides bound jr r j chang et al 2000 give proof convergence special case algorithm 1 working set dened indices corresponding nontrivial components e solution optimization problem st q 2 proof shows choice working set algorithm 1 produces sequence fkg whose limit point optimal wds recently lin 2000 provided similar proof convergence sv light working set dened joachims joachims 1998 indices corresponding nontrivial components solution slightly dierent optimization problem st q 2 analysis chang et al 2000 lin 2000 asymptotic therefore leaves open question nite step convergence optimum following section provide nite step convergence proof special case algorithm 1 corresponds chunking 51 finite step convergence chunking chunking described cristianini shawetaylor 2000 decomposition method working set contains support vectors current solution plus additional set samples violate optimality condition optimality condition chosen additional set always contains least one certifying pair 1 resulting algorithm takes form algorithm 1 anysubset routine returns minimum indices samples 0 following theorem holds class chunking algorithms theorem 4 let nite set observations containing least one sample class consider algorithm 1 anysubset routine returns set contains indices samples 0 algorithm converges solution wds nite k proof algorithm 1 terminates certifying pairs terminates 2 assume qpsolve provides exact solution constrained wolfe dual theorem 3 guarantees solution criterion wds strictly increased one step next ie rk nontrivial contribution r made working set thus working set revisited since nite number working sets r unique termination nite k guaranteed requires slight modication chunking algorithm cristianini shawetaylor 2000 e show proper choice certifying pair provide polynomialtime bounds run time algorithm 1 52 convergence rate section give nite step convergence result algorithm 1 working set contains rate certifying pair dened also provide bounds convergence rate specically give polynomial bound number iterations required drive jr r j within optimum note criterion strong dependence size sample set general r becomes unbounded 1 consequently development convergence rates requires normalization r terms number samples example empirical risk minimization standard divide number training errors number samples obtain fraction training errors however present know natural normalization r therefore allow incorporation appropriate normalization implicitly denote error tolerance function notation let optimal parameter value r optimal criterion value concavity rewritten dene obtain let denote parameter value diers two places dene 0 1 bound distance optimum use determine bound convergence rate algorithm 1 let k denote value state kth iteration let k denote parameter diers k two indices note previous sections subscripted k used kth component vector parenthetic k used state algorithm kth iteration however present analysis need components vector feel use k state kth iteration better notation section let r e denition 3 algorithm 1 rate certifying algorithm exists certifying pair chosen line 14 satises k rate certifying pair pair indices index set iteration k rate certifying algorithm chang et al chang et al 2000 establish relationship type particular choice rate certifying pair use prove asymptotic convergence following theorem gives bound number iterations sucient drive criterion within optimum rate certifying algorithm theorem 5 let k denote sequence states generated algorithm 1 rate certifying algorithm r bl iterations r r 0 l maximum norms 2 2 matrices determined restricting q indices words wish get accuracy sucient performq bl proof let fi jg w k denote indices rate certifying pair working set following dunn 1979 consider following auxiliary equations let k dier k two indices dr k e written show induction k b k follows control k plugging denition k equation 26 equation 27 k obtain latter case j putting two equations 28 together obtain since k therefore dunn 1979 equations 29 30 imply going back relations l k b k implies consequently bl proof nished 53 ecient computation rate certifying pair previous section determined k k sucient establish chang et al 2000 show certifying pair always exists considering solution linear programming lp problem similar lp problem k restricting solution two indices section show solve lp produce rate certifying pair om log operations current solution dene let solution linear program st note solution problem 19 related section 3 dene low low high choose low high chang et al 2000 know certifying pair j given rate certifying pair rate following lemma establishes pair determined computationally ecient manner lemma 1 given rate certifying pair computed om log time proof describe algorithm computes pair om log time algorithm solves lp 31 computes two indices using 3233 lp solved straightforward implement 3233 om steps describe lp solution consider lp 31 recall dr karushkuhntucker conditions solution 0 0 equations written high low int low e solve equations x determine satisfy high low v 0 example v set determine use constraint written becomes i2i low z i2i high z i2i int strategy choose splits samples low high way rst second sums cancel closely possible cancel exactly shift split occurs value v thereby placing samples value int allowing us choose parameters satisfy equality specically sort values v increasing order use k index sorted list ie v k v k1 increases 1 1 jumping values determined value monotonically increasing must pass negative positive fact easy see increases c time individual sample jumped suppose increasing function achieves value 0 interval v k v k1 let value interval since int empty chosen satisfy 35 solution suppose increasing function skips value 0 jumps 0 b 0 total 1 samples value v ie set place rst samples low rest remain high ac integral gives solution samples satisfying 35 equality ac integral remainder used determine km 1 component corresponding v km 1 gives places sample int solution note many solutions equations construction gives necessary implement 3233 takes om log steps sort v followed additional pass list initialize placing samples high yielding 0 since begins 0 increases c time increased past data point components points k c c changed c placing low 0y c integral remainder used determine component moved int updating way requires one complete pass list completes proof algorithm 53 computes rate certifying pair using method described proof addition sort algorithm makes total four passes list number computations procedure sometimes reduced let j rate certifying pair v v j opposite sides since j also certifying e must lie high low dened 13 14 means sorting operation required search restricted v interval since sorting operation dominates run time lead substantial savings number samples interval small algorithm certifying pair algorithm inputs v current iteration fsample indices rate certifying pairg fl ordered list indices nondecreasing order fv g v v ll1 g finitially place samples high compute 0 yg else end fdetermine split point index move samples low g l betadotycc l end fif needed move sample int g etadoty l l else value v use v li fdetermine indices rate certifying pairg lanl technical report laur003800 6 discussion 54 summary rates use algorithm 2 choose rate certifying pair 2 theorem 5 algorithm 1 drive criterion within optimum iterations neglecting lower order terms number iterations simplies case working sets size two use result establish worst case overall run time algorithm 1 iteration must solve 2 2 qp problem update v k determine next certifying pair time solve 2 2 qp problem constant takes order operations update v k add log operations determine certifying pair worst case run time order consider choice obtained appropriate normalization r see discussion beginning section r tends increase increasing function although form function yet known clearly improve runtime bounds presented example order polynomial bounds reduced p 6 discussion paper considers class algorithms support vector machines decompose original wolfe dual qp problem sequence smaller qp problems dened subsets data following work keerthi et al keerthi gilbert 2000 keerthi et al 2001 provide scalar condition necessary sucient optimality qp problem leads naturally introduction certifying pairs necessary sucient condition stepwise improvement motivates use algorithm 1 model algorithm problem leveraging results chang et al chang et al 2000 developed algorithm 2 selecting certifying pair algorithm 1 theorem 5 shows number iterations instantiation algorithm 1 om 4 overall run time om 5 log many existing svm algorithms either special cases algorithm 1 made slight modication example platts sequential minimal optimization smo algorithm chooses working sets size two designed choose pair give strict increase r step platt 1998 original algorithm however contains aw lanl technical report laur003800 references lead improper behavior keerthi et al 2001 keerthi gilbert 2000 behavior traced inability guarantee certifying pair working set forcing working set contain certifying pair corrected algorithm guaranteed convergence also improved performance keerthi et al 2001 sv light algorithm joachims 1998 uses modication zoutendijks method zoutendijk 1970 choose working sets size q 2 choice shown contain q2 largest v low q2 smallest v high thus guaranteeing least one certifying pair chunking algorithm described cristianini shawetaylor 2000 decomposition algorithm osuna et al 1997 attempt ensure improvement r choosing working sets include support vectors current solution plus subset samples violate optimality condition respect solution strict implementation algorithms described papers lead undesirable behavior cannot guarantee certifying pair working sets however guarantee achieved slight modication chunking algorithm section 51 clear algorithms satisfy rate certifying condition denition 3 necessary establish rates described new svm algorithm satises rate certifying condition polynomialtime rates yet clear algorithm compare existing algorithms practice note keerthis gsmo algorithm keerthi et al 2001 jochamins sv light algorithm joachims 1998 require om time determine certifying pair 2 requires om log time however know bounds rates convergence gsmo sv light although seem work well practice guarantee polynomial convergence rate use 2 finally note polynomialtime bound number iterations scales 4 unattractive leave open issue tightness bound although suspect may loose closely related issue determination proper normalization r would give rise explicit functional dependence likely improve rate r nonlinear programming analysis methods 1st edition analysis decomposition methods support vector machines introduction support vector machines kernelbased learning methods 1st edition rates convergence conditional gradient algorithms near singular nonsingular extremals convergence generalized smo algorithm svm classi improvements platts smo algorithm svm classi convergence decomposition method support vector machines support vector machines training applications fast training support vector machines using sequential minimal optimiza tion statistical learning theory methods feasible directions study linear nonlinear pro gramming tr ctr hong qiao yanguo wang bo zhang simple decomposition algorithm support vector machines polynomialtime convergence pattern recognition v40 n9 p25432549 september 2007 tobias glasmachers christian igel maximumgain working set selection svms journal machine learning research 7 p14371466 1212006 rongen fan paihsuen chen chihjen lin working set selection using second order information training support vector machines journal machine learning research 6 p18891918 1212005 thorsten joachims training linear svms linear time proceedings 12th acm sigkdd international conference knowledge discovery data mining august 2023 2006 philadelphia pa usa nikolas list hans ulrich simon general polynomial time decomposition algorithms journal machine learning research 8 p303321 512007 hush patrick kelly clint scovel ingo steinwart qp algorithms guaranteed accuracy run time support vector machines journal machine learning research 7 p733769 1212006 chengru lin kenhao liu mingsyan chen dual clustering integrating data clustering optimization constraint domains ieee transactions knowledge data engineering v17 n5 p628637 may 2005 luca zanni thomas serafini gaetano zanghirati parallel software training large scale support vector machines multiprocessor systems journal machine learning research 7 p14671492 1212006
new results monotone dualization generating hypergraph transversals paper considers problem dualizing monotone cnf equivalently computing minimal transversals hypergraph whose associated decision problem prominent open problem npcompleteness present number new polynomial time resp outputpolynomial time results significant cases largely advance tractability frontier improve previous results furthermore show duality two monotone cnfs disproved limited nondeterminism precisely polynomial time olog2 n suitably guessed bits result sheds new light complexity important problem b introduction part work carried visiting tu wien permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed prot commercial advantage copies bear notice full citation rst page copy otherwise republish post servers redistribute lists requires prior specic permission andor fee stoc02 may 1921 2002 montreal quebec canada recall prime cnf monotone boolean function f unique formula cs c conjunctive normal form set prime implicates f ie minimal clauses c logical consequences f paper consider following problem problem dualization input prime cnf monotone boolean output prime cnf dual well known problem dualization equivalent transversal computation problem requests compute set minimal transversals ie minimal hitting sets given hypergraph h words transversal hypergraph trh h actually problems viewed problem clauses monotone cnf identified sets variables contain dualization search problem associated decision problem dual decide whether two given monotone prime cnfs represent pair f g dual boolean functions analogously decision problem transhyp associated transversal computation deciding given hypergraphs h g whether trh dualization several problems like transversal computation known computationally equivalent dualization see 13 interest various areas database theory eg 34 43 machine learning data mining eg 4 5 10 18 game theory eg 22 38 39 artificial intelligence eg 17 24 25 40 mathematical programming eg 3 distributed systems eg 16 23 mention output cnf exponential size currently known whether computed outputpolynomial polynomial total time ie time polynomial combined size algorithm dualization transversal computation would significantly advance state art many problems application areas similarly complexity dual transhyp open since 20 years cf 2 13 26 27 29 note dualization solvable polynomial total time class c hypergraphs dual ptime pairs dual known conp best currently known upper timebound n olog n 15 determining complexities dualization dual equivalent problems transversal problems prominent open problem witnessed fact problems cited rapidly growing body literature referenced various survey papers complexity theory retrospectives eg 26 30 36 given importance monotone dualization equivalent problems many application areas given long standing failure settle complexity prob lems emphasis put finding tractable cases dual corresponding polynomial totaltime cases dualiza tion fact several relevant tractable classes found various authors see eg 6 7 8 10 12 13 31 32 35 37 references therein moreover classes formulas identified dualization polynomial totaltime conjuncts dual formula enumerated incremental polynomial delay ie delay polynomial size input plus size conjuncts far computed even polynomial delay ie delay polynomial input size main goal main goal paper present important new polynomial total time cases dualization correspondingly ptime solvable subclasses dual significantly improve previously considered classes towards aim first present new algorithm dualize prove correctness dualize regarded generalization related algorithm proposed johnson yannakakis papadimitriou 27 dualization algorithms dualize reduces original problem self reduction smaller instances however subdivision subproblems proceeds according particular order induced arbitrary fixed ordering vari ables turn allows us derive bounds intermediate computation steps imply dualize applied variety input classes outputs conjuncts polynomial delay incremental polynomial delay particular show positive results following input classes degenerate cnfs generalize notion kdegen erate graphs 44 hypergraphs define kdegener ate monotone cnfs resp hypergraphs prove constant k dualize works polynomial delay kdegenerate inputs moreover works outputpolynomial time olog ndegenerate cnfs readk cnfs cnf readk variable appears k times show readk cnfs problem dualization solvable polynomial delay k constant total polynomial time olog result constant k significantly improves upon previous best known algorithm 10 higher complexity bound polynomial delay outputs clauses specific order result olog nontrivial generalization result 10 posed open problem 9 acyclic cnfs several notions hypergraph resp monotone cnf acyclicity 14 general wellknown acyclicity shown 13 dualization polynomial total time acyclic cnfs acyclicity hereditary version acyclicity far less general similar result acyclic prime cnfs left open give positive answer show acyclic prime dualization solvable polynomial delay formulas bounded treewidth treewidth 41 graph expresses degree cyclicity treewidth extremely general notion bounded treewidth generalizes almost notions nearacyclicity following 11 define treewidth hypergraph resp monotone cnf treewidth associated bipartite variableclause incidence graph show dualization solvable polynomial delay exponential k treewidth bounded constant k polynomial total time treewidth olog log recursive applications dualize kcnfs show dualize applied recursively recursion depth bounded constant dualization solved polynomial total time apply provide simpler proof known result 6 13 monotone kcnfs conjunct contains k variables dualized outputpolynomial time deriving results turn attention section 5 fundamental computational nature problems dual transhyp terms complexity theory complexity limited nondeterminism landmark paper fredman khachiyan 15 proved problem dual solved quasipolynomial time pre cisely first gave algorithm solving problem n time complicated algorithm b whose runtime bounded n 4n n defined n noted 15 n log n log log olog n therefore duality checking feasible n olog n time best upper bound problem dual far shows problem likely npcomplete natural question whether dual lies lower complexity class based resources runtime present paper advance complexity status problem showing complement feasible limited nondeterminism ie nondeterministic polynomialtime algorithm makes polylogarithmic number guesses survey complexity classes limited nondeterminism several references see 19 first show simple selfcontained proof testing nonduality feasible polynomial time olog 3 n nondeterministic steps observe improved olog 2 n nondeterministic steps result surprising researchers dealing complexity dual transhyp believed far problems completely unrelated limited nondeterminism believe results presented paper signif icant confident prove useful various contexts first hope various polynomialoutput polynomial cases problems identify lead better general methods various application areas show eg learning data mining 10 based algorithm dualize future modifi cations relevant tractable classes identified second hope discovery limited nondeterminism provides new momentum complexity research dual transhyp push towards settling longstanding open problems 2 preliminaries notation boolean function short function mapping f 0 1 n 0 1 v 0 1 n called boolean vector short vector usual write g f f g satisfy function f monotone positive implies fv fw v w 0 1 n boolean variables x1 x2 xn complements x1 x2 xn called literals clause resp term disjunction resp conjunction literals containing one x x variable clause c resp term implicate resp implicant function f f c resp moreover prime implicate c c implicant f monotone consists positive literals denote p set prime implicants f conjunctive normal form cnf resp disjunctive normal form dnf conjunction clauses resp disjunction terms prime resp monotone members prime resp monotone cnf resp dnf denote number clauses resp terms furthermore formula denote v set variables occur length ie number literals wellknown function f monotone monotone cnf furthermore prime implicants prime implicates monotone f monotone unique prime cnf given conjunction prime impli cates example monotone f 0111 1111 unique prime recall dual function f denoted f defined f x complement f respectively definition f de morgans law obtain formula f one f exchanging well constants 0 1 example f given represented monotone prime cnf f de morgans law f unique prime dnf thus regard dualization also problem computing prime dnf f prime cnf f 3 ordered generation transversal follows let f monotone function prime cnf assume wlog variables x j n appear let n cnf obtained fixing variables x 1 definition example 31 consider similarly prime dnf f denote dnf obtained fixing variables x clearly denoted f proposition 31 let cnf dnf f respectively denote n cnf consisting clauses i1 example 32 example note denote cnf consisting clauses c c contains literal i1 appears example follows 2 lemma 32 term pi f i1 let g function represented pi g proof let 3 implicant hence exists ts note v tv hence v otherwise exists clause c v c pi g let ts respectively discussion completes proof describe algorithm dualize generating set pi f inspired similar graph algorithm johnson yannakakis papadimitriou 27 regarded generalization say term smaller term ie vector lexicographically smaller algorithm dualize input prime cnf monotone function f output prime dnf f ie prime implicants function f compute smallest prime implicant min f set q min step 2 q begin remove smallest q output x begin compute prime dnf ti function represented term ti begin i1 prime implicant f begin compute smallest prime implicant f theorem 33 algorithm dualize correctly outputs increasing order proof sketch first note term inserted output larger indeed 1 i1 disjoint v x1 x i1 hence every term q larger terms already output output sequence increasing show induction smallest prime implicant f output yet already q clearly proves result clearly statement true assume min smallest among prime implicants output yet let largest index prime implicant f welldefined since otherwise must hold contradiction 1 n 2 prime implicant fn f 2 follows maximality let pi f v let k holds since x i1 v term x j k x j prime implicant i1 exists pi f since sx i1 pi f i1 note i1 0 moreover since smaller induction already output therefore considered inner forloop algorithm since prime implicant f i1 algorithm added smallest prime implicant f finally claim otherwise let k first index dier k contradicting maximality let us consider time complexity algorithm dualize store q binary tree leaf represents term left resp right son node depth root depth 0 encodes x step 1 compute min time initialize q time step 2 let ti time required compute prime dnf ti analyzing substeps see iteration step 2 requires x v ti time note smallest prime implicant function obtained f fixing x 0 x thus theorem 34 output delay algorithm dualize bounded tpi f time dualize needs total time tpi f ti bounded polynomial input length dualize becomes polynomial delay algorithm since holds pi f x hand bounded polynomial combined input output length dualize polynomial total time algorithm ti holds lemma 32 using results 2 construct dualize incremental polynomial time algorithm dualization however might output pi f increasing order summarizing following corollary corollary 35 let bounded polynomial n algorithm dualize ont polynomial delay algorithm ii polynomial n algorithm dualize polynomial total time algorithm moreover dualization solvable incremental polynomial time next section identify sucient conditions boundedness fruitfully apply solve open problems improve previous results 4 polynomial classes 41 degenerate cnfs first consider case small generalizing notion graphs ie monotone 2cnfs 44 call monotone cnf kdegenerate exists variable ordering x1 xn k call variable ordering x1 xn smallest last 44 x chosen order smallest variables chosen clearly smallest last ordering gives least k k degenerate therefore check every integer k 1 whether kdegenerate time holds ti n k apply distributive law remove terms x j v thus theorem 34 implies following theorem 41 kdegenerate cnfs dualization solvable k1 polynomial delay k 1 constant applying result 33 monotone cnf olog n many clauses dualizable incremental polynomial time obtain polynomiality result also nonconstant degeneracy theorem 42 olog degenerate cnfs problem dualization polynomial total time following discuss several natural subclasses degenerate cnfs 411 readbounded cnfs monotone cnf called readk variable appears k times clearly readk cnfs kdegenerate fact readk kdegenerate every variable ordering applying theorems 41 42 obtain following result corollary 43 readk cnfs problem dualization solvable k1 polynomial delay k constant ii polynomial total time note corollary 43 trivially implies dualization solvable k2 time constant k since kn improves upon previous best known algorithm 10 k3 time polynomial delay outputs pi f specific order corollary 43 ii nontrivial generalization result 10 posed open problem 9 412 acyclic cnfs like graphs acyclicity appealing hypergraphs resp monotone cnfs theoretical well practical point view however many notions acyclicity hypergraphs cf 14 since dierent generalizations graphs possible refer berge acyclicity stated 14 following proper inclusion hierarchy known bergeacyclic acyclic acyclic acyclic notion acyclicity came relational database theory monotone cnf acyclic reducible gyoreduction 21 45 ie repeated application one two rules 1 variable x occurs one clause c remove x clause c 2 distinct clauses c c satisfy clause c 0 ie empty clause note acyclicity monotone cnf checked suitable gyo reduction output time 42 monotone cnf acyclic every cnf consisting clauses acyclic shown 13 prime implicants monotone f represented acyclic cnf enumerated thus dualization solved p time p polynomial however time complexity dualization general acyclic prime cnfs left open problem show solvable polynomial delay let 1 prime cnf let a1 a2 aq gyo reduction th operation removes x c removes c consider unique variable ordering b1 b2 bn b occurs b j j example 41 let x3 since gyoreduction sequence obtain variable ordering easily checked ordering shows 1degenerate ordering 1degenerate example accidental lemma 44 every acyclic prime cnf 1degenerate note converse true lemma 44 theorem 41 imply following result corollary 45 acyclic cnfs problem dualization solvable 2 delay observe prime acyclic n thus slightly modify algorithm dualize check advance done linear time preprocessing phase need considered step 2 resulting algorithm delay observe algorithm 13 solves minorly adapted enumerative output dualization acyclic cnfs delay thus modification dualize order 413 cnfs bounded treewidth tree decomposition type monotone cnf tree node ww labeled set xwv following conditions 1 ww 2 every clause c exists w w v c xw 3 variable x xw induce connected subtree width maxww xw 1 treewidth denoted tw 1 minimum width tree decompositions note usual definition treewidth graph 41 results case 2cnf similarly acyclic ity several notions treewidth hypergraphs resp monotone cnfs example tree decomposition type ii cnf cc c defined typei tree decomposition incident 2cnf ie graph g 11 20 clause c introduce new variable yc construct denote typeii treewidth proposition 46 every monotone cnf holds tw 2 proof let tree decomposition width tw 1 introduce c new variables c add c every xw clearly result typei tree decomposition g thus typeii tree decomposition since 2 xw many yc added xw every w w result follows means tw 1 bounded constant tw 2 moreover tw 1 implies kcnf discuss kcnfs section 42 consider tw 2 note shown full paper family prime cnfs tw 2 bounded constant k kcnf k n readk k n 1 family prime cnfs kcnfs constant k resp acyclic tw 2 bounded constant show boundedtreewidth implies bounded degeneracy lemma 47 let monotone cnf tw 2 k 2 k degenerate proof sketch let e show reversely construct variable ordering choose leaf w let pw node w adjacent w xw xpw yc c remove w hand complete repeating process claim shows let w chosen process assume xw xpw clause c must either yc xw v c xw let corollary 48 cnfs tw 2 k dualization solvable 2 k 1 polynomial delay k constant ii polynomial total time 42 recursive application algorithm dual ize algorithm dualize computes step 2 prime dnf ti function represented since prime cnf monotone function recursively apply dualize computing ti let us call variant rdualize following result theorem 49 recursion depth rdualize solves dualization d1 d1 time proof min every 1 means pi ftmin 1cnf ie clause contains exactly one variable thus case rdualize needs time recall algorithm dualize needs 5 time ti therefore rdualize needs time 3 corollary 35ii implies algorithm rdualize needs time d1 d1 recall cnf called kcnf clause k literals clearly apply algorithm rdualize monotone kcnf recursion depth rdualize k thus obtain following result establishes dierent means main positive result 6 13 corollary 410 algorithm rdualize solves dualization time k1 k1 ie polynomial total time monotone kcnfs k constant 5 limited nondeterminism previous section discussed polynomial cases monotone dualization section turn issue precise complexity problem purpose consider decision problem dual instead search problem dualization appears problem dual solved limited nondeterminism ie polylog many guessed bits polynomialtime nondeterministic turing machine result might bring new insight towards settling complexity problem adopt kintala fischers terminology 28 write gnp class sets accepted nondeterministic turing machine polynomial time making gn nondeterministic steps every input length n every np p hierarchy consists classes lies p np kp classes appear rather robust closed polynomial time logspace manyone reductions complete problems cf 19 complement class kp denoted cokp start recalling algorithm 15 reformulated cnfs follows view cnfs also sets clauses clauses sets literals algorithm reformulated cnfs input monotone cnfs representing monotone f g st v cv c c c output yes vector w form delete redundant ie nonminimal implicates step 2 check v conditions fails f g witness w found polynomial time cf 15 step 3 1 test duality o1 time step 4 2 find variable x occurs wlog frequency 1 log let call algorithm two pairs forms calls return yes return yes otherwise obtain w fw g w polynomial time cf 15 original input pair cnfs define volume shown 15 step 4 algorithm divides current subproblem volume selfreduction subproblems a1 a2 respective volumes assuming x frequently occurs recursion tree generated input ie root labeled node labeled leaf stops input steps 13 otherwise left child l right child ar corresponding a1 a2 ie labeled 1 0 1 1 0 1 respectively l high frequency move splitting variable observe every node determined unique path root thus unique sequence seqa right left moves starting root ending following key lemma bounds number moves type certain inputs lemma 51 suppose node seqa contains v right log 2 v left moves proof 6 7 move decreases volume v node label thus length seqa particular number right moves bounded v obtain better bound left moves use following wellknown inequality 1e 1 8 fact sequence 1 1x monotonically converges 1e inequality 6 volume va label node seqa contains log 2 v left moves bounded follows log n log 2 v 8 follows log v thus must leaf hence every seqa contains log 2 v left moves theorem 52 problem dual co3p proof sketch instances either c c c c sequence seqa empty easily solved deterministic polynomial time remaining cases f g exists leaf labeled nondual pair seqa known compute simulating branch described seqa entire path root labels check nondual steps 2 3 polynomial time observe noted 15 binary length standard encoding input polynomially related algorithm reaches step 3 thus prove theorem sucient show seqa obtainable polynomial time olog 3 v suitably guessed bits see let us represent every seqa sequence seq 0 number leading right moves number consecutive right moves ith left move seqa seq 2 3 0 lemma 51 seq length log 2 v 1 thus seq occupies olog 3 v bits binary moreover seqa trivially computed seq polynomial time remark 51 also follows f g witness w found polynomial time within olog 3 n nondeterministic steps fact sequence seqa failing labeled describes choice values variables v v completing values show nonduality obtain polynomial time vector w fw g w aim proof show simple means duality polynomially checked limited nondeterminism involved proof applied algorithm b 15 runs n 4no1 thus time prove following sharper result theorem 53 deciding monotone cnfs nondual feasible polynomial time log n nondeterministic steps thus problem dual co2p independently developed methods dierent 1 previous result may also obtained beigel fus theorem 11 1 show convert certain recursive algorithms use disjunctive selfreductions runtime bounded fn polynomial algorithms using log fn nondeterministic steps cf 1 chapter 5 however yields somewhat complicated nondeterministic algorithm full paper also prove algorithm b qualifies 6 acknowledgments work supported part austrian science fund project z29inf tu wien scientific collaboration grant scientific grant aid ministry education science sports culture japan would like thank reviewers constructive comments paper 7 r molecular computing complexity identification dualization positive boolean functions generating minimal integer solutions monotone system linear inequalities complexity generating maximal frequent minimal infrequent sets dual subimplicants positive boolean functions time recognition 2monotonic positive boolean functions given oracle dualization regular boolean functions private communication conjunctive query containment revisited exact transversal hypergraphs application boolean identifying minimal transversals hypergraph related problems degrees acyclicity hypergraphs relational database schemes complexity dualization monotone disjunctive normal forms assign votes distributed system incremental recompilation knowledge data mining limited nondeterminism hypertree decompositions tractable queries universal relation theory coteries mutual exclusion distributed systems translating horn representations characteristic models g stampacchia generating maximal independent sets refining nondeterminism relativized polynomialtime bounded computations generating maximal independent sets nphardness polynomialtime algorithms combinatorial optimization problems trends maximum latency identification positive boolean functions fast simple algorithm identifying 2monotonic positive boolean functions generating maximal independent sets boundeddegree hypergraphs retrospective onmtime algorithm computing dual regular boolean function coherent structures simple games every one winner theory diagnosis first principles graph minors ii algorithmic aspects treewidth simple linear time algorithms test chordality graphs minimal keys antikeys colouring stable sets perfect graphs algorithm treequery membership distributed query tr simple lineartime algorithms test chordality graphs test acyclicity hypergraphs selectively reduce acyclic hypergraphs assign votes distributed system design exmple application armstrong relations minimal keys antikeys theory diagnosis first principles dualization regular boolean functions generating maximal independent sets oitalicnmitalictime algorithm computing dual regular boolean function exact transversal hypergraphs application boolean myampersandmgrfunctions identifying minimal transversals hypergraph related problems complexity identification dualization positive boolean functions colouring stable sets perfect graphs limited nondeterminism complexity dualization monotone disjunctive normal forms polynomialtime recognition 2monotonic positive boolean functions given oracle data mining hypergraph transversals machine learning extended abstract maximum latency identification positive boolean functions generating maximal independent sets boundeddegree hypergraphs fast simple algorithm identifying 2monotonic positive boolean functions hypertree decompositions tractable queries degrees acyclicity hypergraphs relational database schemes efficient readrestricted monotone cnfdnf dualization learning membership queries dualbounded generating problems theory coteries conjunctive query containment revisited generating minimal integer solutions monotone system linear inequalities npcompleteness horn envelopes hypergraph transversals complexity generating maximal frequent minimal infrequent sets ctr dimitris j kavvadias elias c stavropoulos monotone boolean dualization conplog2n information processing letters v85 n1 p16 january thomas eiter kazuhisa makino computing abductive explanations eighteenth national conference artificial intelligence p6267 july 28august 01 2002 edmonton alberta canada georg gottlob reinhard pichler fang wei tractable database design bounded treewidth proceedings twentyfifth acm sigmodsigactsigart symposium principles database systems june 2628 2006 chicago il usa leonid khachiyan endre boros khaled elbassioni vladimir gurvich global parallel algorithm hypergraph transversal problem information processing letters v101 n4 p148155 february 2007 peter l hammer alexander kogan bruno simeone sndor szedmk paretooptimal patterns logical analysis data discrete applied mathematics v144 n12 p79102 november 2004
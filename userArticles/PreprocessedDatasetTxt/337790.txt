faster simpler algorithm sorting signed permutations reversals give quadratic time algorithm finding minimum number reversals needed sort signed permutation algorithm faster previous algorithm hannenhalli pevzner faster implementation berman hannenhalli algorithm conceptually simple require special data structures study also considerably simplifies combinatorial structures used analysis b introduction paper study problem sorting signed permutations reversals signed permutation permutation integers number also assigned sign plus minus reversal j transforms minimum number reversals needed transform one permutation another called reversal distance problem sorting signed permutations reversals nd given signed permutation sequence reversals minimum length transforms identity permutation 1 motivation studying problem arises molecular biology concurrent fast progress human genome project genetic dna data many model organisms accumulating rapidly consequently ability compare genomes dierent species grown dramatically one best ways checking similarity genomes large scale compare order appearance identical genes two species thirties dobzhansky sturtevant 7 already studied notion inversions chromosomes drosophila late eighties jerey palmer demonstrated dierent species may essentially genes gene orders may dier species taking abstract perspective genes along chromosome thought points along line numbers identify particular genes genes directionality signs correspond direction palmer others shown dierence order may explained small number reversals 17 18 19 20 12 reversals correspond evolutionary changes history two genomes numa preliminary version paper presented eighth acmsiam symposium discrete algorithms 13 attlabs research 180 park ave florham park nj 07932 usa hklresearchattcom z department computer science sackler faculty exact sciences tel aviv university research supported part grant ministry science arts israel us department energy grant defg0394er61913a000 shamirmathtauacil x department computer science princeton university princeton nj 08544 usa intertrust technologies corporation sunnyvale ca 94086 usa research princeton university partially supported nsf grants ccr8920505 ccr9626862 oce naval research contract n0001491j1463 retcsprincetonedu ber reversals ects evolutionary distance species hence given two permutations reversal distance measures evolutionary distance mathematical analysis genome rearrangement problems initiated sanko 22 21 kececioglu sanko 16 gave rst constantfactor polynomial approximation algorithm problem conjectured problem nphard bafna pevzner 3 recently christie 6 improved approximation factor additional studies revealed rich combinatorial structure rearrangement problems 15 14 2 9 10 quite recently caprara 5 established sorting unsigned permutations nphard using combinatorial tools developed bafna pevzner 3 1995 hannenhalli pevzner 11 showed problem sorting signed permutation reversals polynomial proved duality theorem equates reversal distance sum three combinatorial parameters see theorem 23 based theorem proved sorting signed permutations reversals done 4 time recently berman hannenhalli 4 described faster implementation nds minimum sequence reversals 2 n time inverse ackermans function 1 see also 23 study give 2 algorithm sorting signed permutation n elements thereby improving upon previous best known bound 4 fact reversal distance r algorithm requires n addition giving better time bound work considerably simplies algorithm combinatorial structure needed analysis follows basic object work implicit representation overlap graph dened later contrast interleaving graph 11 4 overlap graph combinatorially simpler interleaving graph result easier produce representation overlap graph input maintain searching reversals consequence ability work overlap graph need perform padding transformations work simple permutations 11 4 deal unoriented oriented parts permutation separately makes algorithm much simpler notion hurdle one combinatorial entities dened 11 duality theorem simplied handled symmetric manner search next reversal much simpler requires special data structures algorithm computes connected components simple implementation suces obtain quadratic time bound con trast 4 logarithmic number connected component computations may performed per reversal using unionnd data structure paper organized follows section 2 gives necessary preliminaries section 3 gives overview algorithm sections 4 5 give details algorithm summarize results suggest research section 6 2 preliminaries section gives basic background primarily theory hannenhalli pevzner base algorithm reader may nd helpful refer figure 21 main denitions illustrated start denitions unsigned permutations let permutation ng augment permutation n vertices adding pair called gap gaps classied two types breakpoint otherwise adjacency denote b number breakpoints reversal j permutation transforms say reversal j acts gaps c 45 23 fig 21 breakpoint graph b permutation edges solid gray edges dashed oriented edges bold b b decomposes two disjoint alternating cycles c overlap graph ov black vertices correspond oriented edges 21 breakpoint graph breakpoint graph b permutation edgecolored graph n 1g join vertices j black edge gray edge j breakpoint 1 dene onetoone mapping u set signed permutations order n set unsigned permutations order 2n follows let signed permutation obtain u replace positive element x 2x negative element x 2x 2x 1 signed permutation let note b every vertex either isolated incident exactly one black edge one gray edge therefore unique decomposition b cycles edges cycle alternate gray black call reversal j odd j even even reversal reversal 2i1 2j u mimics reversal i1 j thus sorting reversals equivalent sorting unsigned permutation u even reversals henceforth consider latter problem reversal always mean even reversal let c number cycles b figure 21a shows breakpoint graph permutation eight breakpoints decomposes two alternating cycles ie 2 two cycles shown figure 21b figure 22a shows breakpoint graph seven breakpoints decomposes two cycles arbitrary reversal permutation dene b c c reversal permutation clear context abbreviate b b c c bafna pevzner 3 observed following values taken b c depending types gaps acts 1 two adjacencies 2 2 breakpoint adjacency 3 two breakpoints belonging dierent cycle 4 two breakpoints cycle c gray edges 2 b exactly one c neither gray edge breaking c neither gray edge breaking c dierent paths call reversal proper b c 1 ie either type 4a 4b 4d say reversal acts gray edge e acts breakpoints correspond black edges incident e gray edge oriented reversal acting proper otherwise unoriented notice gray edge oriented k l even example gray edge 0 1 graph figure 21a unoriented gray edge 7 22 overlap graph two intervals real line overlap intersection nonempty neither properly contains graph g interval overlap graph one assign interval vertex two vertices adjacent corresponding intervals overlap see eg 8 permutation associate gray edge interval j overlap graph permutation denoted ov interval overlap graph gray edges b namely vertex set ov set gray edges b two vertices connected intervals associated gray edges overlap shall identify vertex ov edge represents interval representation thus endpoints gray edge actually endpoints interval representing corresponding vertex ov note endpoints intervals representation distinct integers connected component ov contains oriented edge called oriented component otherwise called unoriented component figure 21c shows interval overlap graph one oriented component figure 22b shows overlap graph permutation two connected components one oriented unoriented 45 fig 22 breakpoint graph obtained figure 21 reversal 7 10 equivalently reversal dened gray edge 2 3 b overlap graph 0 23 connected components overlap graph let x set gray edges b dene xg equivalently one look interval overlap representation ov mentioned dene span set vertices x minimum interval contains intervals vertices x major object algorithm work ov though eciency considerations avoid generating explicitly contrast pevzner han nenhalli worked interleaving graph h whose vertices alternating cycles b two cycles c 1 c 2 connected edge h exists gray edge e 1 2 c 1 gray edge e 2 2 c 2 overlap following lemma corollary imply partition imposed connected components ov set gray edges identical one imposed connected components h lemma 21 set gray edges b corresponds connected component ov minm even maxm odd proof assume minm odd must spanm ie exist l 1 spanm l 1 1 thus minm neither maximum minimum element set f spanmg hence either maximum element minimum element spanm j minm j maxm denition b must gray edge contradicting fact connected component ov proof maxm odd similar illustration lemma 21 consider figure 22a let 10 15 corollary 22 every connected component ov corresponds set gray edges union cycles proof assume contradiction c cycle whose gray edges belong least two connected components ov assume 1 2 two components two consecutive gray edges along c since spans dierent connected components ov cannot overlap two dierent cases consider 1 e 1 e 2 dierent components cannot overlap thus either right endpoint e 2 even equals maxm 2 left endpoint e 2 odd cases contradiction lemma 21 2 disjoint intervals wlog assume maxm 1 right endpoint e 1 even equals maxm 1 contradicts lemma 21 note particular corollary 22 implies overlap graph cannot contain isolated vertices 24 hurdles let 1 subsequence 0 consisting elements incident gray edges occur unoriented components ov order 1 circle cr j let unoriented connected component g set endpoints edges unoriented component hurdle elements em occur consecutively cr denition hurdle dierent one given hannenhalli pevzner 11 simpler sense minimal hurdles maximal one treated dierent ways using corollary 22 one prove hurdles dened identical ones dened hannenhalli pevzner let h denote number hurdles permutation hurdle simple one deletes ov unoriented component becomes hurdle super hurdle otherwise fortress permutation odd number hurdles super hurdles following theorem proved hannenhalli pevzner theorem 23 11 minimum number reversals required sort permutation b c h unless fortress case exactly one additional reversal necessary sucient 3 overview algorithm denote reversal distance ie fortress following theory developed 11 turns given permutation h 0 one perform permutation 0 h 0 ov unoriented components algorithm rst nds reversals transform 0 oriented components method clearing hurdles uses theory developed hannenhalli pevzner section 5 describe ecient implementation process uses implicit representation overlap graph ov implementation runs time assuming ov already partitioned connected components recently berman hannenhalli 4 gave onn algorithm computing connected components interval overlap graph given implicitly representation using algorithm clear hurdles permutation onn time overlap graph 0 ov 0 oriented components section 4 prove neighborhood oriented gray edge e oriented gray could e reversal acting e 1 create new hurdles call reversal safe reversal develop ecient algorithm locate safe reversal permutation least one oriented gray edge algorithm uses implicit representation overlap graph runs time second stage algorithm repeatedly nds safe reversal performs long ov empty clearly overall complexity n r number reversals required sort 0 31 representing overlap graph assume input given sequence n signed integers representing 0 first permutation constructed described section 21 stored array also construct array representing 1 straightforward verify two arrays determine element whether left right endpoint gray edge constant time case element endpoint gray edge also nd endpoint check whether edge oriented constant time thus arrays 1 comprise representation ov algorithm maintain two arrays carrying reversals nds time update arrays proportional length interval reversed shall give highlevel presentation algorithm use primitives like scan oriented gray edges increasing left endpoint order easy see implement primitives using arrays 1 shall omit details easy produce list intervals representation ov sorted either left right endpoint arrays 1 also possible maintain without increasing asymptotic time bound algorithm practice may faster maintain lists instead addition 4 eliminating oriented components first introduce notation recall vertices ov gray edges b order avoid confusion usually refer vertices ov hence vertex ov oriented corresponding gray edge oriented unoriented otherwise let e vertex ov denote reversal acting gray edge corresponding e denote ne set neighbors e ov including e denote one subset ne containing oriented vertices une subset ne containing unoriented vertices section prove oriented vertex e exists ov exists oriented vertex f 2 one rf proper safe also describe algorithm nds proper safe reversal permutation contains least one oriented edge start following useful observation observation 41 let e vertex ov let obtained ov following operations 1 complement graph induced ov ne feg ip orientation every vertex ne feg 2 e oriented ov remove ov 3 exists oriented edge e 0 ov note e oriented vertex component ov feg may split several components ov 0 compare gures 21c 22b denote components 0 k e k 1 refer 0 simply whenever e clear context let c clique oriented vertices ov say c happy every oriented vertex e 62 c every vertex f 2 c e f 2 eov exists oriented vertex g 62 c g e 2 eov g f 62 eov example overlap graph shown figure 21c f2 3 10 11g f6 7g happy cliques f2 3 10 11 8 9g rst theorem claims one vertices happy clique denes safe proper reversal theorem 41 let c happy clique let e vertex c every e 0 2 c reversal safe proof let assume contradiction 0 e unoriented assume exists 2 ne 0 62 c clearly must oriented ov since c happy must also oriented neighbor 0 adjacent e ov stays oriented adjacent ov 0 contradiction assumption 0 unoriented hence may assume ne 0 let z 2 une vertex z oriented ov 0 adjacent ov 0 obtain contradiction hence z adjacent must adjacent ov hence obtain une uny ov corollary 22 implies component 0 cannot contain alone thus must neighbor x 0 x adjacent e ov thus obtain x 2 ov x e 62 ov x unoriented ov since already proved une uny implies une uny contradiction choice e example theorem 41 implies reversal dened gray edge 10 11 safe proper reversal permutation figure 21 since corresponds vertex maximum unoriented degree happy clique 11g hand reversal dened 2 creates new unoriented component yields permutation shown figure 22 following theorem proves happy clique exists neighborhood oriented edge theorem 42 let e oriented vertex ov exists oriented vertex f 2 one components ov 0 oriented proof theorem 41 suces show exists happy clique c one exists 2 onx 62 oneg exte contains oriented neighbors e oriented neighbors outside one case 1 case 2 exte one feg let clique let k j maximal clique j dene nal clique set straightforward verify two cases c indeed happy clique next section describe algorithm nd oriented edge e safe given representation ov described section 31 algorithm rst nds happy clique c searches vertex maximum unoriented degree c according theorem 41 vertex denes safe reversal even though theorem 42 guarantees existence happy clique neighborhood xed oriented vertex algorithm search one particular neighborhood prove algorithm guaranteed nd happy clique assuming exists least one oriented edge therefore algorithm provides alternative proof weaker version theorem 42 claims existence happy clique somewhere graph 41 finding happy clique section give algorithm locates happy clique ov let e oriented vertices ov increasing left endpoint order algorithm traverses oriented vertices ov according order let le left right endpoints respectively vertex e realization ov traversing e algorithm maintains happy clique c subgraph ov induced vertices assume jc vertices c vertices c maintained linked list ordered increasing left endpoint order exists interval contains intervals c algorithm maintains minimal interval clique c vertex exists satisfy following invariant invariant 41 every vertex e l 62 c l le 1 must adjacent ie adjacent vertex c either adjacent interval e p p le adjacent fact c happy subgraph induced e invariant initialize algorithm setting c g initially 1 dened let current interval e i1 j guaranteed happy ov since remaining oriented vertices adjacent c hence algorithm stops returns c answer see figure 41a assume le i1 show obtain c i1 i1 consider following cases case 1 interval dened figure 41b case 2 interval dened i1 obtained adding e i1 c figure 41c clique c i1 consists e i1 alone figure 41d c previous case c g case i1 set e j last interval c see figure 41e following theorem proves algorithm produces happy clique theorem 43 let c l current clique algorithm stops c l happy clique ov proof straightforward induction number oriented vertices traversed algorithm proves c l l satisfy invariant 41 algorithm stops either l equal number oriented vertices either case since c l happy subgraph induced e must happy ov running time algorithm proportional number oriented vertices traversed since constant amount work performed vertex 42 searching happy clique locating happy clique c ov need search vertex maximum number unoriented neighbors section give algorithm performs task e c fig 41 various cases algorithm nding happy clique topmost interval always three thick intervals comprise c dotted interval corresponds e i1 intervals c ordered increasing left endpoint order clearly rj thus endpoints j vertices c partition line 2j 1 algorithm consists following three stages stage 1 let e unoriented vertex nonempty intersection interval l1 rj mark es endpoints index interval contains stage 2 let array j counters corresponding vertex c intention assign values sum p l oi unoriented degree vertex e l 2 c counters initialized zero unoriented vertex e overlaps interval l1 rj change four counters follows let l r intervals le occur respectively may assume l r otherwise e adjacent vertex c ignore continue according one following cases case 1 r j vertices e l1 e r adjacent e increment ol decrement case 2 j l vertices e l j1 e r j adjacent e increment decrement case 3 l j j r let vertices e 1 e adjacent e increment o1 decrement om vertices e l1 e j adjacent e increment counter ol stage 3 compute jg return e f following theorem summarizes result section omit proof straightforward theorem 44 given clique c vertex e f 2 c computed algorithm maximum unoriented degree among vertices c complexity algorithm proportional size c plus number unoriented vertices ov hence 5 clearing hurdles case unoriented components ov exists sequence r reversals transform 0 dh2e section summarize characterization given hannenhalli pevzner reversals outline nd using implicit representation ov use following denitions reversal merges hurdles h 1 h 2 acts two breakpoints one incident gray edge h 1 incident gray edge h 2 recall circle cr dened section 2 endpoints edges unoriented components ov ordered consistently order two hurdles h 1 h 2 consecutive sets endpoints occur consecutively cr ie hurdle h eh separates eh 1 eh 2 cr following lemmas essentially proved hannenhalli pevzner though stated dierently paper lemma 51 11 let permutation even number say 2k hurdles sequence k 1 reversals merges two nonconsecutive hurdles followed reversal merging remaining two hurdles transform 0 oriented components lemma 52 11 let permutation odd number say 2k hurdles least one hurdle h simple reversal acting two breakpoints incident edges h transforms 0 2k hurdles 1 fortress sequence k 1 reversals merging pairs nonconsecutive hurdles followed two additional merges pairs consecutive hurdles one merges two original hurdles next merges hurdle created rst last original hurdle transform 0 0 oriented components outline turn lemmas algorithm nds particular sequence reversals r properties described first ov decomposed connected components described 4 one identify unoriented components hurdles task done traversing endpoints circle cr counting number elements run consecutive endpoints belonging component run contains endpoints particular unoriented component hurdle similar fashion one check hurdle whether simple hurdle super hurdle traversing cycle list hurdles order occur cr created next stage list used identify correct hurdles merge assume given endpoint one locate connected component constant time easy verify data maintained possible theorem 53 given ov decomposed connected components algorithm outlined nds reversals apply obtain 0 hurdlefree algorithm implemented run time proof correctness follows lemma 51 52 time bound achieved always merge hurdles separated single hurdle ith merge merged hurdles h 1 h 2 separated h h merged 1st merge carrying merges way guarantees span hurdle h overlaps two merging reversals second eliminates h 6 summary figure 61 gives schematic description algorithm algorithm signed reversals signed permutation 1 compute connected components ov 2 clear hurdles 3 sorted iteration begin nd happy clique c ov b nd vertex e f 2 c maximum unoriented degree perform safe reversal e f c update representation ov 4 output sequence reversals fig 61 algorithm sorting signed permutations theorem 61 algorithm signed reversals nds reversal distance r n time particular 2 time proof correctness algorithm follows theorem 23 theorem 41 lemmas 51 52 algorithm berman hannenhalli 4 takes time theorem 53 step 3 takes time per reversal discussion section 4 intriguing open question whether faster algorithm sorting signed permutations reversals exists certainly might case one nd optimal sequence reversals faster date nontrivial lower bound known problem acknowledgments thank donald knuth sridhar hannenhalli pavel pevzner itsik peer comments preliminary version paper r zum hilbertshen aufbau der reelen zahlen sorting permutations transpositions siam journal computing fast sorting reversals dicult inversions chromosomes drosophila pseu doobscura algorithmic graph theory perfect graphs polynomial algorithm computing translocation distance genomes transforming men mice polynomial algorithm genomic distance problems transforming cabbage turnip polynomial algorithm sorting signed permutations reversals including parallel inversions faster simpler algorithm sorting signed permutations reversals physical mapping chromosomes using unique probes tricircular mitochondrial genomes brassica raphanus reversal repeat con evolutionalry signi edit distance genome comparison based nonlocal operations genomic divergence gene rearrangement tr ctr tannier anne bergeron mariefrance sagot advances sorting reversals discrete applied mathematics v155 n67 p881888 april 2007 anne bergeron elementary presentation hannenhallipevzner theory discrete applied mathematics v146 n2 p134145 1 march 2005 glenn tesler efficient algorithms multichromosomal genome rearrangements journal computer system sciences v65 n3 p587609 november 2002 adam c siepel algorithm enumerate sorting reversals proceedings sixth annual international conference computational biology p281290 april 1821 2002 washington dc usa max alekseyev pavel pevzner colored de bruijn graphs genome halving problem ieeeacm transactions computational biology bioinformatics tcbb v4 n1 p98107 january 2007 haim kaplan elad verbin sorting signed permutations reversals revisited journal computer system sciences v70 n3 p321341 may 2005 isaac elias tzvika hartman 1375approximation algorithm sorting transpositions ieeeacm transactions computational biology bioinformatics tcbb v3 n4 p369379 october 2006 severine berard anne bergeron cedric chauve christophe paul perfect sorting reversals always difficult ieeeacm transactions computational biology bioinformatics tcbb v4 n1 p416 january 2007
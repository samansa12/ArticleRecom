decomposition timed decision tables use presynthesis optimizations presynthesis optimizations transform behavioral hdl description optimized hdl description results improved synthesis results introduce decomposition timed decision tables tdt tabular model system behavior tdt decomposition based kernel extraction algorithm experimenting using named benchmarks demonstrate tdt decomposition used presynthesis optimizations b introduction presynthesis optimizations introduced 1 sourcelevel transformations produce better hdl descriptions instance transformations used reduce controlflow redundancies make synthesis result relatively insensitive hdl codingstyle also used reduce resource requirements synthesized circuits increasing component sharing behaviorlevel 2 tdt representation consists main table holding set rules similar specification fsmd 3 auxiliary table specifies concurrencies data dependencies serialization relations among datapath computations actions delay table specifies execution delay action rule section model based notions condition action condition may presence input input value outcome test condition conjunction several conditions defines rule decision table collection rules map condition conjunctions sets actions actions include logic arithmetic inputoutputio messagepassing operations associate execution delay action actions grouped action sets compound actions action set associate concurrency type serial parallel dataparallel 4 condition stub condition entries action stub action entries figure 1 basic structure tdts structure rule section shown figure 1 consists four quadrants condition stub set conditions used building tdt condition entries indicate possible conjunctions conditions rules action stub list actions may apply certain rule action entries indicate mapping rules actions rule column entry part table consists two halves one condition entry quadrant called decision part rule one action entry quadrant called action part rule additional set rules specified main table rule section tdt representation includes two auxiliary tables hold additional information information specified auxiliary tables include execution delay action serialization data dependency concurrency type pair actions example 11 consider following tdt 11 12 21 22 31 32 11 12 21 22 31 p 32 delay actions 11 12 selected execution since action 12 specified successor 11 action 11 executed one cycle delay followed execution 12 symbols p indicate actions dataparallel ie parallel modulo data dependencies parallel actions respectively arrow row 11 column 12 indicates 11 appears 12 contrast arrow row 11 column 12 indicates 11 appears 12 2 execution tdt consists two steps 1 select rule apply 2 execute action sets selected rule maps two action sets may selected execution order execute action sets determined concurrency types serialization relations data dependencies specified among action sets 4 indicated p table action tdt may another tdt referred call tdt contained action tdt corresponds hierarchy specified hdl descriptions consider following example example 12 consider following calling hierarchy c action needs invoked call tdt 2 forces evaluation condition c 2 resulting actions 2 3 executed additional information concurrency types needs specified action 1 tdt 2 since lie different control paths reason omit auxiliary table tdt 2 2 procedurefunction calling hierarchy input hdl descriptions results corresponding tdt hierarchy tdts calling hierarchy typically merged increase scope presynthesis optimizations process presynthesis optimizations merging flattens calling hierarchy specified original hdl descriptions paper present tdt decomposition reverse merging process first flattening calling hierarchy extracting commonalities may find efficient behavior representation leads improved synthesis results allows us restructure hdl code code structuring similar heuristic optimizations multilevel logic synthesis paper introduce coderestructuring addition presynthesis optimization techniques columnrow reduction action sharing presented earlier 1 4 2 rest paper organized follows next section introduce notion tdt decomposition relate problem kernel extraction algebraic form tdt section 3 presents algorithm tdt decomposition based kernel extraction section 4 shows implementation details algorithm presents experimental results finally conclude section 5 presents future plan tdt decomposition process replacing flattened tdt hierarchical tdt represents equivalent behavior mentioned earlier decomposition reverse process merging together merging allows us produces hdl descriptions optimized subsequent synthesis tasks relatively insensitive coding styles since decomposition uses procedure calling abstraction arbitrary partitions table conditionaction matrices useful understand tdt structural requirements consider example example 21 consider following tdt notice common patterns condition rows c 6 c 7 action rows 6 7 8 2 example 21 flattened tdt first three columns identical condition entries c 1 c 2 identical action entries 1 2 columns differ rows corresponding conditions fc 4 c 5 g actions fa 3 4 5 g appear first three columns may result example merging subtdt consisting conditions fc 4 c 5 g actions fa 3 4 5 g note common pattern flattened tdt may result merging procedure called twice main program may simply correspond commonality original hdl description whatever cause extract common part make separate subtdt execute action main tdt figure 2 shows hierarchy tdts specify behavior tdt example 21 conditions explained later equivalence verified merging hierarchy tdts 4 note conditions actions partitioned among tdts ie conditions actions repeated amongs tdts 9 1 5 8 figure 2 one possible decomposition tdt example 21 always possible decompose given tdt hierarchical tdt shown figure neither always valid merge tdt hierarchy flattened tdt 4 two transformations valid specified concurrency types data dependencies serializations preserved particular example assume order execution actions follows order appear condition stub transformations valid also require ffl actions 1 2 modify values used evaluation conditions c 4 c 5 ffl actions 1 2 modify values used evaluation conditions c 6 c 7 suppose given hierarchical tdt shown figure 2 start merging phase get flattened tdt shown example 21 decomposition phase choose factor tdt 3 called overall effect merging followed tdt decomposition equivalent inline expansion procedure corresponding lead obvious improvement hardware synthesis however reduces execution delay description implemented software component overhead associated software procedure calls commonality flattened tdt may result multiple calls procedure indicated tdt 3 figure 2 could also result commonality input hdl specification case extraction lead size reduction synthesized circuit structural requirements tdt decomposition efficiently captured twolevel algebraic representation tdts 2 representation captures control dependencies action sets hence strictly sub set tdt information mentioned earlier tdts based notion conditions actions condition variable c define positive condition literal denoted l c corresponds value condition entry also define negative condition literal denoted l c corresponds n value condition entry pair positive negative condition literals related corresponds condition variable tdt define delta operator two action literals two conditions literals represents conjunction operation operation commutative associative tdt set rules consists condition part determines rule selected action part lists actions executed rule selected execution condition part rule represented l c l c ncond number conditions tdt cei condition entry value ith condition row rule action part rule represented l nact number actions tdt aei action entry value ith action row rule rule tuple denoted become clear later purpose tdt decomposition rule expressed product corresponding action condition literals call product cube given tdt define algebraic expression e consists disjunction cubes corresponding rules simplicity drop delta operator denotation use c instead l c l algebraic expressions tdts however note particular c c shorthand notations l c l c follow boolean laws symbols follow algebraic laws symbolic computation treatment algebra reader referred 4 example 22 algebraic expression tdt example 21 6 7 8 c 3 1 9 6 7 8 c 3 1 2 7 8 c 3 1 2 8 note specification delay concurrency type serialization relation data dependency also notice c c shorthand notations l c l c l respectively 2 21 kernel extraction tdt decomposition important keep action literal condition literal within one subtdt decomposed tdts must partition condition action literals capture introduce notion support tdt support definition 21 support expression set literals appear expression definition 22 tdtsupport expression e set action literals positive condition literals corresponding literals support expression e example 23 expression c 1 c 2 c 3 c 6 c 7 2 8 cube support fc g tdt support fc g 2 consider tdt decomposition subtdts disjoint tdtsupports tdt decomposition uses algebraic division tdtexpressions using divisors identify sub tdts define algebraic division folllows definition 23 let ff dividend remainder g algebraic expressions say f divider algebraic divisor f divider f dividend tdtsupport f divisor tdtsupport f quotient disjoint f divisor delta f quotient nonempty algebraic divisor called factor remainder void expression said cannot factored cube definition 24 kernel expression cubefree quotient expression divided cube called cokernel expression example 24 rewrite algebraic form tdtexample 21 follows c 7 8 expression c 4 3 4 5 c 5 3 cubefree therefore kernel tdtexample 21 corresponding cokernel c 1 c 2 1 2 similarly c 6 c 7 6 7 8 8 also kernel tdtexample 21 two corresponding cokernels c 1 c 2 c 3 2 c 1 1 2 2 3 algorithm tdt decomposition section present algorithm tdt decomposition core algorithm similar process multilevel logic optimization therefore first discuss compute algebraic kernels tdtexpressions show complete algorithm calls kernel computing core addresses important issues preserving datadependencies actions tdt decomposition 31 algorithms kernel extraction naive way compute kernels expression divide cubes corresponding power set support set quotients cube free weeded others saved kernel set 5 procedure improved two ways 1 introducing recursive procedure exploits property kernel kernel expression also kernel expression 2 reducing search exploiting commutativity delta operator algorithm 31 shows method adapted kernel extraction algorithm due brayton mcmullen 6 takes account two properties reduce computational complexity algorithm 31 recursive procedure used kernel extraction input tdt expression e recursion index j output set kernels tdt expression e extractkernelre n j getcubesete l j 2 largest cube set containing l st getcubesete l k 62 c8k endfor algorithm getcubesete c returns set cubes e whose support includes c order literals condition literals appear action literals use n index last condition literal since cokernel containing action literals correspond valid tdt decomposition notice l c l c two different literals explained earlier algorithm applicable cubefree expressions thus either function e cubefree made dividing largest cube factor determined intersection support sets cubes example 31 running algorithm 31 algebraic expression tdt 21 get following set kernels c 4 c 5 3 c 7 7 8 c 5 3 c 7 8 note k 6 cube action literals indicates tdt rule action selected execution k 6 leads valid tdt decomposition however k 6 eliminated kernel set explained later 2 32 tdt decomposition present tdt decomposition algorithm based kernel extraction algorithm presented earlier decomposition algorithm works follows first algebraic expression tdt constructed set kernels extracted algebraic expression eventually used reconstruct tdt representation hierarchical form algebraic kernels may useful tdt decomposition since algebraic expression carries subset tdt information use set filtering procedures delete kernel sets kernels corresponds invalid tdt transformations transformations producing models results inferior synthesis results algorithm 32 tdt decomposition input flattened tdt tdt output hierarchical tdt root tdt f return tdt 0 procedure constructalgebraicexpression builds algebraic expression tdt following algorithm 32 function expression builds expression set sets according data structure choose twolevel algrebraic expression tdts complexity algorithm oar cr number action tdt r number rules tdt c number conditions tdt symbol oe algorithm denotes empty set algorithm 33 constructing algebraic expressions tdts construct positive condition literal l c construct negative condition literal l c endfor construct action literal l endfor r gammaoe empty set r gammaoe cei cei endfor return procedure extractkernelsop calls recursive procedure extractkernelrsop 1 get set kernels sop algebraic expression tdt kernels appear algebraic expression tdt kernels would help reducing resource requirement therefore trimmed k using procedure trimkernel1 algorithm 34 shows details trimkernel1 function co gamma kernelsk e returns set cokernels kernel k expression e number cokernels corresponds number times subtdt corresponds certain kernel called hierarchy tdts algorithm 34 removing kernels correspond single occurrence pattern tdt matrices foreach k 2 k j cokernelsk endforeach example 32 look kernels example 31 kernel k trimmed trimkernel1 since one cokernel 2 since information data dependency captured algebraic form tdts kernels k may corresponds decomposition preserves datadependencies specified original tdt kernels trimmed using procedure trimkernel2 algorithm 35 removing kernels corresponds invalid tdt transformation e tdt f foreach k 2 k flag gamma0 foreach foreach action literal l q action modifies condition corresponding condition literal k foreach action literal l ff k l specified appear l ff flag endforeach endforeach endforeach flag endforeach worst case complexity algorithm oarcr since program checks conditionaction literal corresponding condition entry action entry tdt example 33 suppose example 21 2 modifies c 6 result 2 also used 6 2 modifies c 6 hierarchical tdt need specify c 6 comes tdt 2 preserve behavior however violates data dependency specification 2 6 therefore condition given kernel k c 7 8 removed trimkernel2 2 expression may kernel cokernel 1 kernel free however kernel useful tdt decomposition use procedure trimself delete expression kernel set used fro tdt decomposition also mentioned earlier kernel expressions kernel kernel expression however paper limit discussion tdt decomposition involving two levels calling hierarchies reason removing expression kernel sets also delete smaller kernels also kernels kernels expression algorithm 36 kernel trimming routines foreach k 2 k compute q r st tdtsupportk tdtsupportr disjoint endforeach g foreach k 2 k foreach q 2 k different k q kernel k endforeach endforeach example 34 look kernels e tdt21 kernels k 5 eliminated trimkernel3 since 5 8 also used cubes reason k 6 k 7 also eliminated 2 finally reconstruct hierarchical tdt representation using remaining algebraic kernels tdt expression algorithm outlined consists two procedures reconstruct tdt kernel constructtdt called procedure build tdt algebraic expression worse case complexity algorithm ocr ar algorithm 37 construct hierarchical tdt using kernels input flattened tdt tdt algebraic expression exp set kernels k exp output new hierarchical tdt construct tdt kernelstdt k exp f foreach k 2 k generate new action literal l compute q r st endforeach return constructtdttdt e form condition stub using conditions tdt least corresponding condition literal e form condition matrix according condition literals appearing cube e form action stub using conditions tdt least corresponding action literal e new action literals corresponding extracted subtdts form action matrix according action literals appearing cube e using components return example 35 assume expression c 6 c 7 6 7 8 8 kernel left trimming procedures performed kernel set k algebraic expression tdtexample 21 hierarchical tdt shown constructed running reconstruct tdt kernels 9 1 4 implementation experimental results show effect using tdt decomposition presynthesis optimizations incorporated decomposition algorithm pumpkin tdtbased presynthesis optimization tool 4 figure 3 shows flow diagram process presynthesis optimizations ellipse titled kernel extraction figure 3 show tdt decomposition algorithm fits global picture presynthesis optimization using tdt assertions parser merger merged tdt optimizer optimized tdt code generator optimized hdl input hdl assertions user specification b merged tdt column reduction row reduction kernel extraction optimized tdt action sharing figure 3 flow diagram presynthesis optimizations whole picture b details optimizer experimental methodology follows hdl description compiled tdt mod els run optimizations finally output hardwarec description output provided olympus highlevel synthesis system 7 hardware synthesis minimum area objectives use olympus synthesis results compare effect optimizations hardware size hdl descriptions hardware synthesis performed target technology lsi logic 10k library gates results compared final circuits sizes term number cells addition merging algorithms column row optimization algorithms originally implemented pumpkin 1 added another optimization step tdt decomposition evaluate effectiveness step turn column reduction row reduction action sharing pahses run pumpkin several highlevel synthesis benchmark designs table 1 synthesis results cell counts tdt decomposition carried design module circuit size cells delta daio phase decoder 1252 1232 2 receiver 440 355 19 comm dma xmit 992 770 22 exec unit 864 587 cruiser state 356 308 14 table 1 shows results tdt decomposition examples designs design daio refers hardwarec design digital audio inputoutput chip daio 8 design comm refers hardwarec design ethernet controller 9 design cruiser refers hardarec design vehicle controller description state vehicle speed regulation module designs found highlevel synthesis benchmark suite 7 percentage circuit size reduction computed description listed last column table 1 note improvement depends amount commonality existing input behavioral descriptions 5 conclusion future work paper introduced tdt decomposition complementary procedure tdt merging presented tdt decomposition algorithm based kernel extraction algebraic form tdts combining tdt decomposition merging restructure hdl descriptions obtain descriptions lead either improved synthesis results efficient compiled code experiment named benchmarks shows size reduction synthesized circuits code restructuring sequential decomposition sd proposed 10 map procedure separate hardware component typically specified process hdls using sd procedure mapped offshelf component fixed communication protocol complement protocol constructed accordingly rest synthesizable part system therefore future plan research presented paper plan combine sd tdt decomposition obtain novel system partitioning scheme works tabular representations investigate possible advantagesdisadvantages approach partitioning approaches r hdl optimization using timed decision tables limited exception modeling use presynthesis optimizations specification design embedded systems system modeling presynthesis using timed decision tables synthesis optimization digital circuits decomposition factorization boolean expressions olympus synthesis system digital design design digital input output chip decomposition sequential behavior using interface specification complementation tr high level synthesis asics timing synchronization constraints specification design embedded systems hdl optimization using timed decision tables limited exception modeling use presynthesis optimizations synthesis optimization digital circuits olympus synthesis system ctr jian li rajesh k gupta hdl code restructuring using timed decision tables proceedings 6th international workshop hardwaresoftware codesign p131135 march 1518 1998 seattle washington united states j li r k gupta algorithm determine mutually exclusive operations behavioral descriptions proceedings conference design automation test europe p457465 february 2326 1998 le palais des congrs de paris france sumit gupta rajesh kumar gupta nikil dutt alexandru nicolau coordinated parallelizing compiler optimizations highlevel synthesis acm transactions design automation electronic systems todaes v9 n4 p441470 october 2004
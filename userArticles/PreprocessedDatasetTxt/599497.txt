analysis optimization active databases introduce new formal semantics active databases relies transaction rewriting technique userdefined transaction viewed sequence atomic database updates forming semantic atomic unit translated means active rules induced ones transactions embody active rule semantics either immediate deferred rule semantics confluence equivalence optimization formally investigated characterized solid framework naturally extends known model relational database transactions b introduction active databases based rules allow us specify actions taken system automatically certain events occur conditions met widely recognized active rules provide powerful mechanism management several important database activities eg constraint maintenance view materialization 6 7 reason largely used modern database applications extensively studied last years 2 4 5 9 12 14 21 22 23 however various approaches active rule execution generally specified informal naturallanguage descriptions follows often number rules increases active rule processing becomes quickly complex unpredictable even relatively small rule sets 23 goal paper provide formal approach active rule processing relies method rewriting user defined transactions reflect behavior set active rules show known results transaction equivalence extended framework preanalyze properties transactions rules start introducing simple transaction language based well known model relational databases 1 transaction viewed collection basic update operations forming semantic unit quite general active rule language whose computational model setoriented like 23 differently approaches 22 consider two different execution models active rules immediate deferred delayed 8 14 former temporal decoupling event condition action parts latter temporal decoupling event part one side condition action parts side define context rewriting process takes input user defined transaction set active rules produces new transaction 0 embodies active rule semantics sense explicitly includes additional updates due active processing deferred modality new transaction original one augmented induced actions whereas immediate modality new transaction interleaves original updates actions defined active rules follows execution new transaction passive environment corresponds execution original transaction within active environment defined given rules approaches consider rewriting techniques 11 22 usually apply restrictive context formal con versely believe formal simple approach improve understanding several active concepts make easier show results said execution model transactions extends relational transaction model extensively investigated 1 reason choice twofold firstly wish use well known framework formal setting solid transaction execution model secondly wish take full advantage results already available transaction equivalence optimization 1 13 way able formally investigate statically several interesting properties active rule process ing first check whether two transactions equivalent active database due results transaction equivalence also able provide results confluence finally optimization issues addressed final remark note approach active rule processing require specific runtime support simpler implement others built scratch 10 remainder paper organized follows section 2 detailed overview relational database system confluenceoptimization transaction rewriting loop checking figure 1 components approach approach presented using several practical examples section 3 define basic framework sections 4 5 introduce systematic way notion active database rewriting transaction technique respectively property equivalence investigated section 6 study several results active rule processing derived section 7 finally section 8 draw conclusions overview approach section informally present approach described figure 1 basic idea express active rule processing four step computation given user defined transaction set active rules p first step checks whether p presents kind recursion time present simple characterization address issue detail present paper second step takes p transforms transaction induced ones embodies semantics rules p general step several transactions generated different induced transactions take account fact update original transaction may trigger several rules time corresponding actions executed different orders yielding different results third step confluence optimization issues active rule processing investigated analyzing transactions computed second step done extending known techniques testing equivalence database transactions 1 13 last step according results analysis one transaction finally submitted relational database management system point two important aspects approach firstly relies formal basis allows us derive solid results secondly rewriting confluenceoptimization steps done statically without accessing underlying database therefore performed efficiently compile time said consider immediate deferred active rule execution models immediate modality reflects intuition rules processed soon triggered deferred modality suggests rule evaluated executed end original transaction 14 thus two different rewriting procedures given specifically consider user defined transaction sequence updates transaction transformed immediate modality induced one denotes sequence updates computed immediate reaction update respect set active rules p reaction derived matching update u event part active rules clearly obtained updates trigger rules hence reaction computed recursively noted several transactions obtained way note immediate modality induced transaction interleaving user defined updates rule actions deferred modality induced transaction form hence reaction deferred postponed end user transaction induced updates trigger rules reactions original updates recursively computed using immediate modality give number practical examples clarify discussion following active rules react updates personnel database composed two relations empnamednamesal depdnamemgr rules expressed generic language refer specific system whose intended meaning evident indeed rules easily expressed practical active rule language r1 deleted dep delete emp dnameddname r2 inserted newe emp namenewename dnamenewedname r3 inserted newe emp newesal 50k insert dep values dnamenewedname mgrnewename intuitively first rule states department deleted employees working department must removed cascading delete second one serves enforce constraint employee work one department states employee tuple say johntoy40k inserted relation emp old tuples john associated department different toy must deleted finally last rule states inserted employee salary greater 50k eligible manager department works according tuple name department new employee inserted relation dep provide following simple user defined transaction first toy department removed employee added department salary 60k insert emp values namebilldnametoysal60k inspecting given active rules easily realize run time first update t1 trigger rule r1 whereas second update trigger rules r2 r3 therefore immediate modality t1 rewritten compile time following transaction t1i denotes immediate modality unfolding t1 respect active rules new transaction prefix denotes induced update insert emp values namebilldnametoysal60k insert dep values dnametoynamebill obtained transaction describes behavior transaction t1 taking account active rules immediate modality note another possible translation last two updates switched second update original transaction triggers two rules time namely r2 r3 therefore two possible execution orders effects rules follows general user defined transaction actually induces set transactions one goals paper show many cases possible statically check whether transactions equivalent induced transactions equivalent state active program confluent respect transaction t1 case execution one obtained transactions implements expected behavior user defined transaction within active framework note assume presence partial ordering rules framework easily extended take account let us turn attention deferred execution model assume want move employee john toy book department implemented means following transaction t2 insert emp values namejohndnamebooksal50k inspecting transaction rules statically decide first update t2 trigger rule r3 since condition satisfied salary new employee greater 50k thus rewrite transaction taking account active rules deferred modality following possible translation t2d denotes deferred modality effect rules postponed end transaction executing transaction observe fact second update discarded without altering overall effect transaction since effect included effect third update shows optimization performed induced transactions transaction implements expected behavior follows contrast user defined transaction updates induced transactions independent updates indeed induced others fact consequence execution semantics induced transaction assume instance runtime execution update u induced transaction null effect database example condition hold effect invalidated subsequent update reasonable updates induced directly indirectly u executed well interpretation need define new transaction semantics takes account inducerinduced relationship among updates clearly techniques achieve confluence optimization must take account fact clarify point consider transformation transaction t1 deferred modality according previous discussion rewriting process generate following transaction insert emp values namebilldnametoysal60k insert dep values dnametoynamebill however easy see third update invalidates effect second one follows last two updates transaction t1d induced update must executed run time rewriting transaction t1 deferred modality simplified follows thus need develop specific techniques check equivalence optimize induced transactions done extending already existing framework equivalence optimization relational databases rest paper devoted formalization characterization issues discussed section 3 model transactions notion transaction use paper based model relational transactions introduced abiteboul vianu 1 informally transaction mean sequence basic update operations namely insertions deletions tuples viewed semantic unit specifically restrict attention important class domainbased transactions selection tuples involves inspection individual values tuple differently model described 1 also allow comparisons predicates 31 preliminaries let u finite set symbols called attributes 2 u let doma infinite set constants called domain usual use notation indicate single attribute singleton fag also indicate union attributes sets thereof means juxtaposition names moreover assume technical reasons domains disjoint totally ordered relation scheme object rx r name relation x subset u database scheme u collection relation schemes fr 1 x distinct relation names union x u tuple v set attributes x function x union domains 2 x va doma relation relation scheme rx finite set tuples x database instance database scheme function rx 2 srx relation rx denote tupx set tuples set attributes x insts set database instances database scheme throughout rest paper always refer fixed database scheme set attributes u 32 conditions let x set attributes attribute x atomic condition x expression form 1 ac c 2 doma comparison predicate 6 2 2 meaning symbols gamma1 1 evident 2 gamma1 c 2 equivalent c 2 reason allowing form atomic condition clarified shortly definition 31 condition complex condition simply condition set attributes x finite set atomic conditions x tuple v x satisfies atomic condition ac condition c satisfies every atomic condition occurring c assume conditions always satisfiable contain atomic conditions always false eg 2 c 2 doma atomic conditions mutually exclusive eg condition c set attributes x uniquely identifies set tuples x satisfying condition set called target c definition 32 target condition target condition c set attributes x denoted targc set tuples fv 2 tupx j v satisfies cg note targc empty c satisfiable say condition specifies complete tuple 33 transactions let us first introduce basic update operations definition 33 insertion insertion relation scheme r j expression form r j c c condition x j specifies complete tuple effect insertion r j c mapping eff r j c insts insts defined r definition 34 deletion deletion relation scheme r j expression form gammar j c c condition x j effect deletion gammar j c mapping eff gammar j c insts insts defined r update relation scheme insertion deletion note sake simplicity consider modify operations actually similarly 1 modifications accommodated framework complexity notation would increase dramatically update operations generally executed within transactions collections data manipulation operations viewed semantic atomic unit definition 35 user transaction user transaction finite sequence updates effect transaction composition effects updates contains mapping eff example 31 sql transactions described section 2 easily expressed using notation introduced instance transaction t1 page 6 expressed follows two user transactions equivalent always produce result applied database instance effect definition 36 equivalence user transactions two user transaction 1 2 equivalent denoted case eff 1 34 normalization transactions according 1 describe characterize section transactions satisfying property called normal form transactions syntactically distinct updates disjoint targets therefore interfere convenient form since simplifies results algorithms moreover make easier specification reaction active rules updates involved transaction also show transaction brought special form means preprocessing phase called normalization operation performed polynomial time definition 37 normal form transaction normal form pair updates u u j relation conditions c c j c 6 c j case targc following result easily follows definitions states transaction normal form 1 two updates different targets targets empty intersection 2 two updates target condition lemma 31 transaction normal form 1 targets pair updates either identical disjoint 2 conditions pair updates target syntactically equal proof 1 assume way contradiction transaction normal form two updates u u j conditions c c j targc targets u u j different c 6 c j definition 37 implies targets disjoint contradiction 2 assume transaction normal form two updates target different conditions definition transaction normal form implies targets indeed disjoint contradiction 2 transaction transformed equivalent transaction normal form splitting target condition sufficiently many targets end introduce number axioms called split axioms used transform transaction equivalent transaction normal form intuitively axioms show 1 transform transaction equivalent transactions contains atomic conditions form axioms sa2sa4 2 transform transaction way possible interferences pair updates two forms avoided axioms sa5 sa6 1 axioms sa1 sa7 useful order apply others specifically former shows generate conditions composed singletons various attributes latter shows add condition attribute condition mention definition 38 split axioms following axioms called split axioms c condition x 2 x cj denotes set atomic conditions c 1 clearly one possible way enforce normal form g g c atomic condition cg cg cg c element doma c 1 following result easily proved lemma 32 split axioms sound proof let us consider instance axiom sa2 let let easy see definitions 34 35 eff similar considerations apply axioms 2 show axioms practically used normalize transactions let us first introduce property conditions used algorithm follows property 31 let c condition x z set attributes c finite set constants attribute 2 x z 1 cja form g c 2 doma c split algorithm used normalize transactions reported figure 2 following result theorem 31 let transaction c set constants appearing z set attributes mentioned 1 algorithm split terminates c z generates transaction split polynomial time 2 2 split 3 split normal form 2 hereinafter polynomial time means time polynomial respect length transaction algorithm split input transaction set constants c set attributes z output new transaction split begin update u r whose condition satisfies property 31 sets attributes x z set constants c transaction obtained splitting u according split axiom gammafupdates unsatisfiable conditionsg end figure 2 algorithm split proof 1 assume contains one update structure split axioms iteration loop algorithm split jt moreover algorithm tries enforce property 31 allows updates atomic conditions form follows number different forms atomic condition i1 take execution algorithm bounded 2 corresponds number ordered pairs k symbols atomic conditions form 2 plus cardinality c atomic conditions form c since update split respect constant follows every jt j bounded ju j number complex conditions universe u attributes formed different atomic conditions thus sequence strictly increasing bounded therefore algorithm terminates contains multiple updates split algorithm applied separately update results concatenated obtain split follows algorithm split terminates transaction generates output transaction polynomial time 2 part easily shown basis lemma 32 induction number transformations applied algorithm split 3 way contradiction assume split normal form pair updates set attributes x syntactically different conditions say c whose targets disjoint let attribute x condition 1 property 31 output algorithm split c j c j j form two possible cases c j form form targets would disjoint b c j form 2 c form 2 c cases least one two conditions satisfy condition 2 property 31 contradicts split output algorithm split 2 example 32 let domains integers consider transaction transaction normal form since tuple targets two updates contains applying algorithm split obtain 1 2 axiom algorithm terminates second step outputs normal form let us consider transaction normal form note 0 satisfies property 31 since first update even mention attribute b applying algorithm split obtain 1 0 algorithm terminates first step outputs 0 1 indeed normal form 4 active databases section introduce formally notions active rule program consider simple form active rules however captures considerable portion rules described literature implemented systems particular 19 considered core several concrete active rule languages whose rule execution specified informal descriptions shown framework possible describe main features languages 41 active rules programs represent active rule using notation introduced express transactions allows us easily describe way updates active rules interact specifically event condition parts rule described update whereas action part described transaction according definitions section 33 difference variables used place constants variables used describe bindings passed event condition action rule 3 simplicity example write 1 thus let us fix set symbols called variables call generalized update update condition variables occur place constants generalized transaction transaction composed generalized updates active rules defined follows definition 41 active rule active rule form 1 u e generalized update case insertion condition necessarily specify complete tuple 2 generalized transaction variable occurring also occurs u e left hand side right hand side rule also called event part action part respectively definition 42 active database active program p set active rules active database pair p database instance p active program note event part active rule allows us specify update triggering rule condition met effective execution rule 23 intuitive semantics rule follows update u matching u e executed database perform transaction using bindings matching u u e example 41 active rules described section 2 page 5 easily expressed using notation introduced said one important point temporal relationship execution components rule event action temporal decoupling deferred execution model whereas immediate execution model temporal decoupling approach semantics active database respect transaction given terms execution new transaction induced defined section 5 along definition rewriting technique 42 triggering rules describe updates active rules interact first introduce preliminary notions let union domains attributes u v set variables substitution oe function v v identity constants matching atomic conditions defined follows ground atomic condition ca atomic condition without variables matches generalized atomic conditions c 0 attribute either 1 c 0 contains variables substitution oe called binding 2 c 0 ground least one tuple v x v satisfies ca c 0 targca let c 1 ground condition c 2 generalized condition set attributes x say attribute 2 x occurring c 1 j matches c 2 j composition bindings various atomic conditions forms binding c 1 c 2 easy show two condition match matching unique renaming variables definition 43 triggering let update r active rule u e say u u e perform type operation relation 2 c matches c e update u triggers rule r u e oe binding say u induces sequence updates oet rule r note condition variables active rule see definition 41 ground update always induces ground updates example 42 update empnamebilldnametoysal60k triggers following active rule binding associates bill variable n toy variable note sal60k matches sal50k follows update induces update depdnametoymgrbill 5 transaction transformation section present algorithms transform user defined transaction induced one embodies active rules behavior consider immediate deferred cases 51 transaction transformations figure 3 reported recursive algorithm computes reaction single update algorithm symbol ffl denotes concatenation operator sequences note general different outputs generated algorithm depending order triggered rules selected first step loop clearly algorithm generalized way possible reactions update generated moreover according several approaches described literature algorithm modified first step loop order take account partial order rules unfortunately algorithm guaranteed terminate possible input since kind recursion occur active program however syntactical restriction given algorithm reaction guaranteed terminate result follows based construction special graph g p describing relationship rules p construction graph based notion unification updates generalizes notion matching follows algorithm reaction input update u active program p set constants c set attributes z output sequence p updates induced directly indirectly u p begin triggered triggered ug triggered u p empty pick rule r triggered u p let oe binding u u e u ffl end figure 3 algorithm reaction say two generalized updates u 1 u 2 possibly containing variables unify ground substitution oe called unifier targoeu 1 graph g p nodes represent rules p edge rule r update unifies u 0 e lemma 51 graph g p acyclic algorithm reaction guaranteed terminate p update u k proof algorithm reaction performs recursive call update oeu u update occurs action part triggered rule r oe matching causes triggering call causes turn triggering set rules rules number recursive calls algorithm reaction let rule triggered oeu definition 43 means substitution oe 0 targets oeu oe 0 e nonempty intersection since assume rules different variables oe ffi oe 0 unifier r r 0 therefore two rules p cause recursive call edge r r 0 g p since g p acyclic follows number recursive calls always finite algorithm terminates 2 hereinafter consider active program p graph g p acyclic indeed less restrictive conditions given achieve termination also algorithm modified order take account presence kind recursion discussed issues elsewhere 18 ready present notion induced transactions definition 51 induced transaction let user defined transaction p active program c set constants includes constants occurring constants occurring p z set attributes includes attributes mentioned attributes mentioned p output algorithm c z consider following transactions say induced p immediate deferred modality respectively actually following refer induced transactions without making explicit reference modality transaction transformation computed since various results hold independently aspect induced transactions following property holds lemma 52 let user defined transaction p active program transaction induced p normal form computed polynomial time proof definition 51 update occurring transaction 0 induced split using algorithm split either preprocessing step execution algorithm reaction respect set constants set attributes include occurring therefore theorem 31 0 normal form let us consider complexity construction 0 hypothesis acyclicity graph g p easily follows one execution algorithm reaction requires worst case number recursive calls equals jp j number rules p bounded jp j 2 moreover call algorithm reaction involves one execution algorithm split requires polynomial time theorem 31 number concatenation operations bounded maximum number updates occurring action part rule p follows algorithm reaction requires polynomial time since algorithm used update occurring original transaction induced transaction computed polynomial time 2 point given user defined transaction active program may several different induced transactions depending possible different outputs algorithm reaction even number induced transactions always finite may large however number reduced checking instance certain ones obviously equivalent eg certain rules trivially commute problem efficient generation induced transactions management beyond goal paper addressed elsewhere 18 52 semantics induced transaction said section 2 induced update induced transaction executed 1 inducing update effectively executed 2 invalidated afterwards new notion effect transaction needs defined according call new semantics active effect induced transaction since takes account relationship inducing updates induced ones due active rules relationship known always made explicit generation induced transaction several ways instance means labeling technique described 18 let u update database instance say effect u visible also let transaction 1 j n denote tj j transaction composed first j components definition 52 active effect active effect eff ff induced transaction mapping eff ff insts insts recursively defined follows induced update u effect u visible eff ff finally ready define semantics transaction respect active database definition 53 effect transaction active database potential effect user transaction active database p coincides eff ff 0 0 transaction induced p 6 equivalence active databases many interesting problems systematically studied formal framework defined among equivalence optimization confluence active databases section shall consider equivalence show property decidable polynomial time 61 equivalence induced transactions transaction equivalence extensively investigated relational model 1 13 major results study concern deciding whether two transactions equivalent transforming transaction equivalent less expensive one unfortunately results cannot directly used within framework different semantics defined transactions let us introduce new definition equivalence refers induced transactions definition 61 equivalence induced transactions two induced transactions 1 2 equivalent denoted 1 ff 2 case eff ff algorithm summary input induced transaction output summary sigma begin u induced u embedded sigma sigma else case u end figure 4 algorithm summary present simple method testing equivalence induced transaction actu ally method works transaction normal form based representation behavior transaction call summary annotated condition following syntax hr ci r relation c complex condition summary induced transaction pair sets annotated conditions generated summary algorithm reported figure 4 algorithm make use following notion given summary sigma say update u condition c embedded sigma either summary sigma describes succinct way behavior induced transaction specifically let n cardinalities sigma sigma gamma respectively consider transaction b defined follows hr ci 2 update gammarc one first n positions hr ci update rc one positions actually since sigma sigma gamma sets several different way build b however since transactions obtain always deletions followed insertions nonactive effects always thus order updates occur b immaterial consider deterministic construction following lemma 61 eff ff proof proof proceeds induction length n basis since case easy see definition 52 eff ff regard induction step assume eff ff definition 52 instance update u j executed eff ff tj j gamma1 induced update u occurring tj j gamma1 visible eff ff condition inductive hypothesis u visible also eff b construction simply implies u occur b tj j gamma1 means u embedded execution algorithm summary annotated condition corresponding u j included sigma j therefore u j occur b j j follows instance u j effectively executed eff ff active effect semantics u j occurs b tj j eff ff tj completes induction part theorem 61 let 1 2 two induced transaction set constants set attributes 1 ff 2 sigma 1 proof let sigma 1 assume without loss generality b lemma 61 eff ff let eff ff instance relation scheme rx let v tuple srx v 62 eff ff 1 srx clearly also v 62 eff ff 2 srx consider transactions b update u update u induced transaction set constants set attributes therefore concatenation 1 2 transaction normal form since non empty intersection lemma 31 follows thus annotated condition hr c 1 occurs sigma gamma considerations apply insertions follows 2 interesting aspect point notion active effect induced transaction indeed generalizes notion effect userdefined transaction implies characterization equivalence also hold ordinary transactions passive environments 62 equivalence user transactions notion equivalence user transactions naturally extended active environment since seen transaction potentially produces different results active database depending different induced transactions generated assume two transactions equivalent able produce always results database instance definition 62 equivalence transactions active framework two user transactions 1 2 equivalent respect active program p transaction 0 induced 1 p transaction 0 induced 2 p 0 2 vice versa results section state following result theorem 62 equivalence two user transactions active framework decided polynomial time proof given user transaction lemma 52 construct transactions induces polynomial time number transactions induced single update active program p bounded constant depends size p specifically bounded denotes cardinality p number transactions induced bounded k theta jtj definition 62 equivalence two user transactions 1 2 requires test equivalence pair transactions induced 1 2 respectively number tests bounded k 2 theta jt 1 j theta jt 2 j theorem 61 equivalence two induced transactions requires 1 construction summaries means algorithm summary requires time linear respect length transaction bounded jtj theta jp j 2 2 test equality two summaries requires time proportional jt 1 j theta jt 2 j theta jp j 4 follows equivalence 1 2 decided polynomial time 2 63 axiomatization transaction equivalence closing section present two simple intuitive axioms proving equivalence induced transactions provide much insight relationship updates induced transaction since axioms show transactions manipulated without altering overall effect call manipulation axioms also show axioms suggest way optimize efficiently transactions active environment order present axioms need introduce preliminary notions first use notation inducedu denote updates induced directly indirectly update u induced transaction moreover say two updates collide relation scheme conditions identical finally introduce notion validity update transaction syntactical counterpart notion visibility recursively defined follow update u induced transaction valid 1 induced 2 induced directly update u j preceding u valid update u k u j collides u j definition 63 manipulation axioms following axioms called manipulation axioms involve induced transactions 1 2 eventually empty subtransactions switching axiom 1 u u j collide 2 u valid update 3 u j collide update u k occurring 1 u merging axiom 1 u u j collide 2 u j valid update 3 0 updates inducedu intuitively axiom ma1 states updates u u j collide u j cannot invalidate effect updates inducing u switched instead axiom ma2 states u collides u j execution equivalent execute u j provided 1 updates induced directly indirectly executed well 2 updates induced directly indirectly however executed happens u j induced u lemma 62 manipulation axioms sound 1 man 2 implies 1 ff 2 proof let us first consider ma1 since u u j collide u cannot invalidate u j execute latter first moreover definition 52 switching effective execution u depends updates occurring 1 u j collide update inducing u switching execution u still depends updates occurring 1 finally switching effective execution u j depends updates occurring 1 u therefore u j induced u switching effective execution u j still depends updates occurring 1 hand u j induced u problem arises since u valid u j executed anyway follows given conditions active effect coincides active effect let us consider ma2 since u u j collide u j valid u j invalidates u therefore u deleted without altering effect transaction moreover since u invalidated u j effect visible execution 2 updates induced directly indirectly u deleted 2 except induced also u j case u j induced u given conditions active effect coincides active effect theorem 63 sound complete set axioms proving equivalence induced transactions proof lemma 62 sound prove completeness axioms consider two induced transaction 1 2 1 ff 2 using manipulation axioms transform transactions two new transactions 0 deletions performed insertions done two steps first one updates transaction collide another update deleted second one deletions moved front transaction insertions first step performed using manipulation axioms follows starting second update iterating updates transaction move forward using axiom ma1 updates preceding one currently consideration collide updates deleted using axiom ma2 easy show work always done first step pair updates transaction collide second step easily move deletions front transaction using axiom ma1 since axioms sound lemma 62 2 0 also since pair updates 0 collide easily follows 0 since 0 theorem 61 sigma 0 sigma 0 construction b coincide permutation deletions permutation insertions follows b 1 transformed b using repeatly axiom ma2 sum man 0 man man 2 2 7 analysis active rule processing basis results transaction equivalence derive section number results important properties active databases 71 confluence confluence strong property applications may actually need weaker notion 2 propose two notions confluence former weaker latter since refers specific transaction however notion nicely characterized turns practical importance definition 71 weak confluence active program p confluent respect user transaction transactions induced p equivalent definition 72 strong confluence active program p strongly confluent confluent respect user transaction following result show practical method testing weak confluence theorem 71 weak confluence decidable tested polynomial time proof given user transaction lemma 52 construct transactions induced polynomial time definition 71 confluence respect p requires test equivalence pair transactions induced number tests done bounded square maximum number transactions induced k 2 theta jtj 2 k constant depends size p see proof theorem 62 since theorem 61 testing equivalence two induced transactions requires polynomial time follows confluence respect p also performed polynomial time 2 introduce another interesting notion confluence independent specific transaction let p active program c set constants occurring p r u e rule p denote u r set updates obtained r follows atomic condition ca u e involving variable x let set intervals 2 constant c 2 ca c 2 since ca finite psi actually finite partition doma let k set constants contains one element whichever every note since psi finite partition doma ka always finite set u r contains possible updates obtained applying u e substitution attribute occurring u e maps variables u e occurring ca constants ka intuitively set u r contains representatives triggering updates rule r specify different ways rule r triggered update definition 73 local confluence active program p locally confluent rule confluent respect update u r active program p locally confluent confluent every rule p note theorem 71 follows check local confluence active program polynomial time following result states local confluence although restrictive desirable property active program theorem 72 active program locally confluent strongly confluent proof let user transaction normal form respect set constants occurring p set attributes mentioned p note restrictive hypothesis since theorem 31 transaction transformed transaction satisfying property using algorithm split proof proceeds showing update u triggering rule r 2 p sequence updates induced u mapping constants 1 u 2 u r 2 u induces sequence updates 0 0 specifically mapping defined follows atomic condition ca occurring u identity constants ka maps constant c 62 ka constant c 0 2 ka belongs interval containing c clearly u 2 ka moreover definition 43 triggering algorithm split easy show induction number step algorithm reaction sequence updates generated algorithm starting u algorithm able generate sequence starting u definition local confluence sequences updates induced u equivalent easily follows sequences updates induced u also equivalent thus p confluent respect sequence updates induced update easily shown given transaction partition sequences adjacent updates confluent respect confluent respect therefore definition 51 induced transaction follows independently modality transaction p confluent respect p strongly confluent 2 possible show local confluence implies strong confluence converse true general even weak confluence active programs locally confluent confluent respect certain transactions notion local confluence gives us sufficient condition confluence checked efficiently let p active program p conf set rules p locally confluent note set derived one definition time following characterization weak confluence simply requires update transaction one test matching event part rules p corollary 71 let p active program user defined transaction p confluent respect update triggers rules p conf proof p conf indeed strongly confluent program therefore theorem 72 confluent respect p conf respect p 2 72 optimization major objective research provide tools optimizing induced transac tions particularly important since approach optimization technique induced transactions yields method optimizing overall activity active rule processing according 1 two types optimization criteria transactions considered first related syntactic aspects eg length complexity updates transaction whereas second related operational criteria number atomic updates performed transaction criteria formally investigated section let us first introduce preliminary notion let p partition tuple space partition set tuples v 2 tupx every rx scheme say transaction based p condition c occurring update targc 2 p according implementations assume deletion operation complex insertion operation denoted u ordering may invalid certain implementation updates however changing ordering affect results follow definition 74 transaction based p syntactically optimal every transaction 0 based p equivalent exists permutation given transaction denote nopt mapping insts theta associates instance pair number tuples inserted number tuples deleted moreover denote order relation theta defined follows k ratio cost insertion operation cost deletion operation intuitively order relation takes account number update operations together preference attributed insertions deletions definition 75 transaction based p operationally optimal every transaction based p equivalent instance 2 insts note definitions refer possible pair equivalent transactions rather transactions based partition tuple space however convenient form since possible show transactions based partition syntactically operationally optimality cannot attained simultaneously general definition 76 transaction optimal operationally syntactically optimal let us consider manipulation axioms introduced previous section defini tion 63 easy see one application merging axiom yields strictly simpler transaction whereas switching axiom affect complexity translation however useful order apply merging axiom simple observation leads method optimizing induced transactions intuitively method consists applying number times switching axiom followed application algorithm optimize input induced transaction output new transaction opt begin repeat collides update u j j precedes u i1 transaction obtained deleting u j updates inducedu j else updates examined end figure 5 algorithm optimize merging axiom modification performed method effectively implemented simple way means algorithm figure 5 recall inducedu denotes induced transaction updates induced directly indirectly update u following theorem confirms algorithm always terminates polynomial time produces optimal transaction theorem 73 let induced transaction 1 algorithm optimize terminates generates transaction opt polynomial time 2 opt ff 3 opt optimal proof 1 algorithm simply involves iteration updates requires worst case time linear length transaction note however step involve reduction average execution algorithm even efficient 2 part proved showing step loop algorithm new transaction i1 equated transaction previous step obtained number applications switching axiom move close u followed one application merging axiom show note algorithm eliminates collisions updates soon encountered iterating updates transaction implies step sequence updates 1 preceding update u consideration pair updates collide updates valid therefore step freely use switching axiom 1 see definition 63 particular update u j 1 collides u move u j close u apply merging axiom thus obtaining exactly transaction i1 lemma 62 follows ff termination opt ff 3 first note consequence shown part 2 opt pair updates collide assume way contradiction opt syntactically optimal let 0 transaction based partition p equivalent opt less update operations opt according order implies update u opt condition c visible eff ff opt instance must update u 0 condition c 0 0 therefore since opt updates 0 least update u x opt visible possible u x invalidated another update opt opt normal form obtained deleting updates transaction normal form lemma 31 implies two updates opt collide contradiction assume way contradiction opt operationally optimal let 0 transaction based partition p equivalent opt nopt 0 opt instance 2 insts implies opt either perform two times insertiondeletion tuple tuple first inserted deleted deleted inserted opt normal lemma 31 possible two updates opt collide contradiction 2 conclusions presented formal technique allows us reduce several important cases active rule processing passive transaction execution specifically user defined transactions translated new transactions embody expected rule semantics immediate deferred execution modalities shown many problems easier understand investigate point view tackled formal setting naturally extends already established framework relational transactions fact turns several important results derived transactions passive environment taken across active one firstly able formally investigate transaction equivalence framework active database secondly results transaction equivalence used check interesting practically useful notions confluence finally optimization issues addressed believe approach active rule processing suitable interesting investigations practical point view studied efficient ways generate keep induced transactions context implementation method top commercial relational dbms 18 theoretical point view believe various results extended several ways take account general frameworks finally rewriting technique applied data models one based objects 16 r equivalence optimization relational transactions static analysis techniques predicting behavior active database rules model active objectoriented database automatic generation production rules integrity maintenanace chimera model language active dood sys tems deriving production rules constraint maintenance deriving production rules incremental view maintenance structured approach definition semantics active databases ode active database constraints triggers design implementation chimeras active rule language combining theory practice integrity control declarative approach specification transaction modification subsystem rule processing active database systems simplification rules complete axiomatization relational update transactions architecture active data base management system active databases paradigm enhanced computing environ ments rewriting technique implementing active object systems rewriting technique analysis optimization active databases transaction transformation approach active rule processing framework specification active rule language semantics implementing large production systems dbms environment concepts algorithms integration rule systems database systems rules tr equivalence optimization relational transactions architecture active database management system theory rule triggering systems deriving production rules constraint maintenance setoriented production rules relational database systems rules procedure caching views data base systems simplification rules complete axiomatization relational update transactions rule processing active database systems termination confluence rule execution automatic generation production rules integrity maintenance static analysis techniques predicting behavior active database rules structured approach definition semantics active databases logicbased integration active deductive databases design implementation chimera active rule language active rule analysis optimisation rock myampersandamp roll deductive objectoriented database foundations databases integration rule systems database systems refined triggering graphs transaction transformation approach active rule processing rewriting technique analysis optimization active databases expressiveness complexity active databases ode active database deriving production rules incremental view maintenance implementing language specifying active database execution models algebraic approach rule analysis expert database systems using delta relations optimize condition evaluation active databases investigating termination active database systems expressive rule languages rewriting technique implementing active object systems framework specification active rule language semantics combining theory practice integrity control termination analysis active databases ctr burcin bostankorpeoglu adnan yazici fuzzy petri net model intelligent databases data knowledge engineering v62 n2 p219247 august 2007
packaging system heterogeneous execution environments packaging system allows diverse software components easily interconnected within heterogeneous programming environments described interface software stubs generated programmers automatically programmers express applications geometry simple rules module interconnection language attributes generating custom interface code application based analysis extraction interfacing requirements system able produce executables whose runtime performance comparable manually integrated applications system implemented within unix environment b introduction era escalating software costs reuse software components economic necessity equally acute need integrate components presence heterogeneity whether source languages architectures communication media unfortunately additional software must developed implement interfacing decisions heterogeneous configuration application programs must adapted use desired architecture communication media must extended interface software expensive create must rewritten whenever components reused different configurations one way increase potential software reuse limit growth dependencies components example module interconnection languages mils effective managing structural dependencies ie concerning visibility compatibility variables interface names 5 however availability heterogeneous systems increases likelihood geometric coupling dependencies due relation components execute underlying architecture minimize dependencies programmers typically organize programs calls underlying communication system isolated possible hope stubs localize impact subsequent changes communication system therefore reduce cost reusing component approach generally successful still manual tasks identifying remote interfaces creating stub code determining stub integrated application programmers must adapt components new application economic benefits reuse lost order regain must turn automatic techniques several questions arise generate interface software needed one application component interoperate another components interface software packaged together executable objects analyze source programs discover potential dependencies first place problems focus paper describe method automating generation custom interface software heterogeneous configurations whereas previous research focused stub generation alone approach generates stubs well configuration methods needed integrate application using approach developers may build support tools hide details software configurations packaged executables method implemented system called polygen within unix environment polygen integrates heterogeneous components generating interface software needed integrate transform instance compile link configuration set executable objects programmers provide source code application components plus abstract characterization decisions concerning desired geometry configuration polygen acts linker analyze information generate necessary interface software process guided set abstract composition rules characterize integration capabilities environment manner components composed reused different applications without modified explicitly software developer software partitioned many reasons modules identifiable homogeneous possibly divisible units computation consider simple application implemented figure 1 two modules implemented different programming languages c common lisp may configured execute either single processor two processors sharedmemory multiprocessor two different machines distributed system case must modified use common interface mechanism comparison integration task trivial modules implemented programming language configured run single processor modules would integrated single executable object without use interface software except implemented native linkerloader eg using stack jump instructions many cases however integration task trivial way adapt modules integration general cases depends part source languages execution location available hardware configuration interprocess communication ipc facilities available environment figure 2 gives example module adaptations one execution environment extra code cases necessary modules reside separate executable objects integrated communication mechanisms connection established run time environment rendezvous functions call byteswap function may necessary processes runs two hosts differing representations integer lisp function dispatcher routine becomes new main program typical read eval print operation lisp must replaced order process act server support modules general might place extra code separate module gain procedural transparency module called stub would linked loaded separately source language execution location ipc properties shown example implementation differences increase coupling decrease reuse requiring programmers adapt modules use interface software would like reuse modules many different configurations environments possible without manually creating modifying source code achieve goal need adapt modules automatically generating interface software abstract specifications applications capability would reduce coupling increase possibilities reuse isolating architectural communication dependencies programmers also need assistance generation stubs desired configuration requires different communication mechanisms integration strategies stubs generated commands needed integrate new files enumerated tools makefiles 7 help programmers obtain executables reliably problem identifying program units generating appropriate commands eg generating makefile mixed language programs first place tedious task programmer interested performing manually existing stub generation systems often replace manual adaptation source programs manual task establishing configuration control application include clienth f char int retval printfname printfs ext key retval else printfs foundkey printfname setq dave defun lookup name tablelookup name table defun tablelookup name list cond null list equal name caar list cadar list figure 1 module main left function lookup right simple application client server modules integrated execution environment use interprocess communication primitives source module however must modified use facilities integration methods different environment require adaptations depending capabilities local compilers linkers interpreters include clienth f char int retval int fd ip printfname sendfd receivefd buffer printfs ext else f printfs foundkey printfname setq dave defun lookup name tablelookup name table defun tablelookup name list cond null list equal name caar list cadar list defun dispatcher h desc receive h receive h send sender desc invoke desc figure 2 two modules must modified integration remote procedure call specification compilers existed many years coupled configuration management tools matchmaker 9 courier 21 sunrpc 19 xdr 18 rpc compilers example stub generators compilers must ported manually cases handle environmentspecific details hrpc 4 horus rpc compilers 8 notable exceptions horus stub generator parameterized system language schema files hrpc project extends parameterization include rpc protocols interface description language idl 15 project also implements stub generator cases integration stubs source components existing servers left designer alternative static generation stubs projects designed efficient remote evaluation mechanisms heterogeneous applications distributed applications gain substantial performance improvements use customized interface mechanisms like rpc rev stubs 3 14 17 6 stubs projects often handwritten rewritten generated automatically performance critical many systems design often dependent upon context use configuration comparison polygen accommodates many approaches parameterizing stub generation process shown stubs components customized software configurations well environments modules implemented language execute host stubs may necessary efficient interface mechanisms created without sacrificing interconnection abstractions advantage coordinating stub production configuration management tools polygen also relies upon technology module interconnection language community past mil projects focused primarily upon issues interface module compatibility recently polylith system showed mils could employed control communication issues distributed network 13 polylith introduced software bus organization encapsulate interfacing decisions way software components interface directly interoperate efficiently particular communication system chosen generate stubs within polygen since polylith simplifies many data coercion relocation requirements inscape project 11 alternate mil approach primarily focuses semantics module composition processes also conic 10 durra 2 projects recently addressed problems polylith similar toolkit approach without aid composition abstractions like software bus number rulebased software composition models constructed specific programming languages environments 1 establish rules composing objects producing infrastructure needed construct applications particular environments xconinrime project 16 example also addresses software reuse problems describing components composition methods using assertions rules method however unites approach methods handling heterogeneity application local tools compilers linkers stub generators configuration management programs created packaging system meet integration needs motivated last section system called polygen allows designers reuse modules many different environments separating logical design application geometry implementing design system collection tools used build executable objects source modules tools transform mil specifications modules interfacing mechanisms integration methods needed interconnect modules particular environment interfacing mechanisms sometimes called wrappers usually thought stubs come many forms may specify macro substitutions perform source transformations implement stub procedures general interfacing mechanisms must consist set modules along commands necessary prepare interoperation resources configuration 31 module specification abstract description software component important role describe interfaces defined module well interfaces resources module uses module specification also describes properties component project polylith mil used support integration activities properties organized namevalue pairs name may keyword userdefined identifier value either primitive type integer string boolean float constructed type structure array predicate expression sequence values set values interfaces module defined similarly interface name properties separated characters module specifications simply describe properties interfaces component called primitive modules figure 3 contains module specifications components shown figure 1 example pattern property used describe interface pattern order type parameters interface module specification also used compose modules application composite specification describes collection modules bindings interfaces example composite specification uses components figure 3 shown figure 5 described sense application represented directed graph node graph corresponds instance module edge graph corresponds connected pair interfaces use definition module specifications may many possible implementations written variety source languages associated specification another form module property user develops composite specification source programs must united appropriate program stubs transformed executables may span several files due heterogeneity system collection source programs generated stubs commands build executables called package packaging activity analyzing source program interfaces determining compatibility source available communication media generating stubs creating necessary configuration commands module client f use interface printf use interface gets use interface lookup module server f define interface lookup define interface tablelookup list g figure 3 module specification client component left server component right 32 polygen distinct phases packaging shown figure 4 polygens utility process based upon primitive module specifications available source programs case specifications available source system provides users tool extract interface descriptions first place done techniques discussed later section 324 321 composition first phase design activity composition developers create composite specification application terms primitive module specifications expression applications modular structure represent design meeting functional requirements ideally contain extensive information concerning geometry architectures module execute communication mechanisms would bind modules together since information added separately course ability separately annotate logicallycorrect design geometric information leverage approach found since programmers free vary annotations quickly order experiment different configurations rapidly geometric properties attached modules bindings values either guide packager build executables desired architecture represent constraints concerning configurations feasible polygen provides editing tool programmers add annotations without changing design specifications composite specification figure 5 describes application composed two unique modules description bindings interfaces case interfaces bound implicitly name sample annotated design shown figure 6 desired locations execution module declared method intermodule communication constrained tcpip via polylith network bus 322 generation key phase packaging composite specification may realized many ways depending upon application available execution en vironments implement application given environment polygen must analyze constraints affecting compatibility select interconnection options interfaces generate necessary stubs enumerate configuration commands needed integrate components resulting package specific application target execution environment polygen creates package partitioning configurations sets components compatible integration executable image according constraints given environment often refer sets partitions partitions determined commands creating executables generated example multiple source files written programming language call x may compiled using x compiler linked single executable using x link editor compatibility encoded composition rule used polygen partition configurations partitioning possible configuration polygen generates package needed create applications executa bles otherwise target environment support desired integration polygen reports error detailed description partitioning algorithm given section 4 order reason modules compatibility polygen requires characterization interconnection capabilities target execution environments plus abstract description compatibility various programming languages within environments information given terms rules created site administrator discussed section 4 polygen applies rules produce interface software needed implement composition particular environment package includes source programs stubs plus configuration commands needed compile link invoke interconnect programs execution time configuration commands given terms unix makefile example source programs figure 2 would part package demonstration problem would makefile necessary translate integrate modified source programs 323 construction finally construction phase consists applying configuration commands actually obtain executables polygen means makefile executed construction tools provided host execution environments form compilers linkers loaders configuration management tools number executable objects may produced generated implementation executable objects come many forms binary images scripts types interpreted programs may execute processes separate hosts interoperate via runtime instance software bus stubs interprocess communication facilities available execution environment existing source primitive interface extraction optional user design activity library composite annotated design geometric data added configuration rule base polygen package executables extraction phase generation phase composition phase construction figure 4 polygen packaging process module test f tool client tool server bindall figure 5 design phone application module test f client bindall figure annotated design phone application 324 extraction extraction tools used existing module mil specification first place wish verify implementation consistent specification extraction tool transforms source code abstract structural descriptions collection assertions properties interfaces module signature created automatically compilers parsing tools 12 manually cases extraction tools unavailable polygen scan tool used extract information source modules results contain declarations properties interfaces module specifications based useful integrating old implementations new environments managing consistency implementations specifications development thus create mil representatives existing libraries gain leverage reusing many configurations permitted implementations extraction straightforward task necessary phase system one ways research distinct efforts provide stub generation userdefined interface descriptions currently extraction tools provided c pascal ada lisp 33 example implementation characterized set modules stubs configuration program execution environment unix environment local area network correspond source files stubs commands needed build executable objects commands part configuration program unix makefile 7 produced package tool along interface descriptions wish create executable application given code shown figure 1 script entire process includes user commands execution configuration initially user source code scan clientcl clientc create module specification client component scan servercl serverlsp create module specification server component clientcl servercl next user creates design specs see figure 5 polygen testcl finally user polygen create package option asks executables constructed hence following output commands called makefile created automatically polygen csc testcl compiles application specification testco csc clientcl compiles client specification clientco csc servercl compiles server specification serverco csl testco clientco serverco test creates root executable executes a1 a2 wrapgen a1w creates clienth a1c wrappers cc c clientc compiles client component cliento cc c a1c compiles a1c wrapper a1o cc a1 cliento a1o lith creates first executable object binary image wrapgen a2w creates a2lsp wrapper echo bincsh f a2 creates second executable object shell script echo kcl serverlsp a2lsp a2out chmod x a2 test user may run application figure 7 script design user commands prefixed prompt program shown figure 7 using extraction tools first create specifications shown figure 3 next construct system specification shown figure 5 invoke package tool create implementation unix makefile interface description files a1w a2w makefile contains configuration program needed create necessary stubs integrate modules executable objects finally makefile executed according rules specific environment creates two separate executable objects modules cannot linked together conventional linker ie incompatible execution environment generated stubs clienth a1c a2lsp shown figure 8 example involves difference source languages two modules generated implementation designed integrate two modules despite difference packaging system determines whether two modules loaded single executable object methods linked together way developer ignore details composition concentrate description interconnections geometry application packager system uses description set constraints produce appropriate implementation 34 interconnection subsystem polygen replace existing forms communication interconnection systems rather assists users utilizing resources polygen currently relies upon polylith software clienth define main client main extern int lookup a1c include polylithh mainargcargv f int client mainargcargv mh shutdownallrnull lookuparg1 char arg1 f int mh writelookup null null arg1 mh readlookup null null r return defun mhdispatcher message mhreadselect mhreadselect interface car message car message nil neverreturned cond equal interface lookup mhwrite lookup lookup car cadr message mherror message figure 8 wrappers client left server right instances terconnection system communication mixedlanguage programming requirements 13 however inference capability limited polylith polygen generate packages execution environments compatibility rules methods expressed inference engine polylith polygen important difference responsibilities former provides interconnection services programmers latter helps reason access services experience pair modules declared compatible respect cited execution environment communication system two modules might loadcompatible polylith polylith link editor build two modules object code process image might able interoperate alternate communication system used polygen enriched information modules interconnected using new communication resources users gain flexibility applications configured key properties affect compatibility program units type representation data interface polygen attempt infer coercion mechanisms heterogeneous data directly rather inherits transformation capabilities whatever communication system characterized rule base described section 4 choice polylith principle interconnection subsystem within polygen greatly simplified issues initial experiments system since software bus organization elides programmer representation issues primitive record data types hence polygen users may base design decisions composition phase upon single type system polylith cinstance client csource server kclsource a1 cexecutable a2 kclexecutable test polylithtcpip i2 kclinstance figure 9 partitioning complete example mil using techniques described 13 ability transmit abstract data types across polygencreated interfaces similarly dependent upon interconnection rules characterize compatibility installed underlying inference engine package depends upon integration capabilities environment earlier example two modules configured separate executable objects incompatible degree could composed appropriate stubs generated environments might possible load execute heterogeneous components within single address space polygen must enough inference capability distinguish cases determined target configuration must generate stub source programs methods integrating final application section describes method determining contents package environments interconnection capabilities constrain types integrations possible given constraints one determine whether possible describe application terms sets compatible components polygen sets called partitions represented directed acyclic graphs whose internal nodes represent integration methods terminal nodes represent source components partitioning example section 33 shown figure 9 case partitioning tree modules based distinct source components exists single composition method root ie polylith tcpip bus partitioning single root called valid partitioning package may created configuration configuration valid partitioning depending integration capabilities available environment several valid partitionings may constructed single configuration valid partition created bottomup fashion first identify types components configuration next determine methods integrating larger objects ie partitions integration activity continues module client f see figure module server f see figure module test f tool client tool server bindall pmoduleclient languageclientc sourceclientclientc includeclientclienth mainclient importclientlookupintstr pmoduleserver languageserverkcl sourceserverserverlsp exportserverlookupintstr instanceofi1clienttest locationi1flubbercsumdedu instanceofi2servertest locationi2flubbercsumdedu bindi1lookupi2lookuptest packagetestpolylith tcpip figure 10 module specifications converted prolog assertions iteratively single method found integrates objects previous iteration final method represents root valid partitioning includes components configuration polygen implements method prolog site administrator programmer describes interconnection capabilities environment terms rules constrain satisfaction partitioning goals construct package polygen first reads given module specifications application converted set prolog assertions figure 10 encode facts modules bindings configuration reading assertions figure 10 polygen attempts satisfy goal asks question possible create least one package configuration named test using polylith tcpipbased bus environment goal satisfied least one package created given configuration prolog inferencing mechanism searches rule base attempts satisfy package rule modulesnm instancesni createpackagemintp prolog assigns variable n name test variable name polylith tcpip attempts satisfy subgoals first two subgoals determine modules clientserver module instances i1i2 used test configuration next possible partitioning instances found placed list p case partition goal form partition predicate asks exist partitioning modules execution environment partitioning list forms list module instances ie implementations partitionings leaves partitioning instances list method name composition method used integrate objects label symbolic name assigned partition example goal 2 asks exist valid partitioning instances i1 i2 integrated tcpipbased bus environment goal would satisfied partitioning states composition created using tcpipbased bus two separate objects created instance prolog inference engine attempts satisfy partition goals using composition rules current environment rules authored system administrators kept readonly system file composition rules shown figure 11 example used determine whether set instances composed single executable object according rules figure 11 set instances composed using c executable method components instances modules written c execute host set one main entry point set valid partitionings determined instances configuration goal called createpackage acts code generator composition methods 3 c executable kcl executable invoked satisfying goal methods generate package since partitioning simply tree whose leaves module instances interface software generated traversing partition root invoking composition method node current polygen driver code implemented 50 prolog rules composition method consists 50 rules including compatibility rules rules generating stubs makefile rules add new composition method one must write new compatibility rules code generation rules compatibility predicate form samelocation locationxs applistlocationsl compatiblexc executable typexc instance compatiblexlc executable countmainxlm samelocationxl compatiblelc executable figure 11 compatibility rules used package tool l list partitions instances name composition method two types code generation rules composition method environment makefile rules stub rules types invoked satisfying createpackage subgoal package goal partitioning root composition method need given explicitly package goal may determined composition rules using deductive capabilities prolog composite specification figure 6 example require use particular bus implementation case package goal would form subsequent partition goal would form bus implementation b determined attempt satisfy partition goal environment goal 5 satisfied variable assignments based properties instances i1 i2 specified figure 6 instance i2 server located host machine konkycsumdedu environment host implement polylith tcpipbased bus implement xnsbased version luckily host flubbercsumdedu i1 resides implements bus versions developer unaware generated stubs configuration file case look different result location annotations composite specification 5 conclusion described packaging system allows diverse software components easily interconnected within heterogeneous programming environments interface software stubs generated programmers automatically express applications geometry simple rules mil attributes generating custom interface code application based analysis extraction interfacing requirements approach able produce executables whose runtime performance comparable manuallyintegrated applications important feature approach easy system managers add new language execution environment polygen time new rule declaring compatibility added manager provide set possible commands would make two components compatible according rule example done manually would entail writing source code reasonably given entirety certainly source programmer would want generate manually without need ease one tailor application programs use workstations addition small set rules yields packager layer network rpc stubs underneath wrapper codes needed integrate application powerful window system result simple example used throughout paper run distributed application component set interact users via window local host workstation user elect run different window system source components adapted automatically use new platform availability early stub generation systems relieved programmers create interface software manually polygen also relieves programmers identify extract interfaces first place tell configuration management system stub programs incorporated application r knowledgebased environment development software parts composition systems developing applications heterogeneous mechina networks durra environment high performance crossaddress space communication remote procedure call facility interconnecting heterogeneous computer systems programmable interface language heterogeneous distributed sys tems program maintaining computer programs stub generator multilanguage rpc heterogeneous environ ments interface specification language distributed processing constructing distributed systems conic inscape environment parse tree annotations polylith software bus performance firefly rpc interface description language assessing maintainability xconin rime coping problems large rule base implementing remote evaluation external data representation reference manual remote procedure call protocol specification solving rpc problem gnu c xerox special information systems tr stub generator multilanguage rpc heterogeneous environments remote procedure call facility interconnecting heterogeneous computer systems programmable interface language heterogeneous distributed systems constructing distributed systems conic inscape environment knowledgebase environment development software parts composition systems interface description language definition use parse tree annotations performance firefly rpc implementing remote evaluation polylith software bus matchmaker highperformance crossaddress space communication ctr gio wiederhold role government standards standardview v1 n2 p1116 dec 1993 j bishop r faria characteristics modern system implementation languages proceedings 1995 acm 23rd annual conference computer science p1825 february 28march 02 1995 nashville tennessee united states jim q ning adean architecture design environment componentbased software engineering proceedings 19th international conference software engineering p614615 may 1723 1997 boston massachusetts united states nenad medvidovic peyman oreizy richard n taylor reuse offtheshelf components c2style architectures proceedings 19th international conference software engineering p692700 may 1723 1997 boston massachusetts united states gordon novak jr creation views reuse software different data representations ieee transactions software engineering v21 n12 p9931005 december 1995 nenad medvidovic peyman oreizy richard n taylor reuse offtheshelf components c2style architectures acm sigsoft software engineering notes v22 n3 p190198 may 1997 elizabeth l white james purtilo integrating heterogeneous control properties software modules acm sigsoft software engineering notes v17 n5 p99108 dec 1992 mary shaw robert deline daniel v klein theodore l ross david young gregory zelesnik abstractions software architecture tools support ieee transactions software engineering v21 n4 p314335 april 1995 francois bronsard douglas bryan w kozaczynski edy liongosari jim q ning sgeir lafsson john w wetterstrand toward software plugandplay acm sigsoft software engineering notes v22 n3 p1929 may 1997 david rine human exploration development space using xml database space wide web information sciencesinformatics computer science international journal v150 n34 p123151 april patrcia gomes soares remote procedure call proceedings 1992 conference centre advanced studies collaborative research november 0912 1992 toronto ontario canada alexander stoyen plamen v petrov towards mobile code management environment complexrealtime distributed systems realtime systems v21 n12 p165189 julyseptember 2001 richard n taylor tracz lou coglianese software development using domainspecific software architectures cdrl a011a curriculum module sei style acm sigsoft software engineering notes v20 n5 p2738 dec 1995 gerardo canfora aniello cimitile ugo de carlini logicbased approach reverse engineering tools production ieee transactions software engineering v18 n12 p10531064 december 1992
multiplerank modifications sparse cholesky factorization given sparse symmetric positive definite matrix mathbfaatr associated sparse cholesky factorization mathbfldltr mathbflltr develop sparse techniques updating factorization either adding collection columns deleting collection columns techniques based analysis manipulation underlying graph structure using framework developed earlier paper rank1 modifications davis w w hager siam j matrix anal appl 20 1999 pp 606627 computationally multiplerank update better memory traffic executes much faster equivalent series rank1 updates since multiplerank update makes one pass l computing new entries series rank1 updates requires multiple passes l b introduction paper presents method evaluating multiple rank update downdate sparse cholesky factorization ldl matrix aa n precisely given r matrix w evaluate cholesky factorization aa either 1 corresponding update w arbitrary 1 corresponding downdate w consists columns aa aa ww must positive denite follows case update n r case downdate one approach multiple rank update express series rank1 updates use theory developed 10 updating sparse factorization rank1 change approach however requires multiple passes l updated rank1 change paper develop sparse factorization algorithm makes one pass l dense cholesky factorization onepass algorithm update factorization obtained method c1 18 making changes associated one column l moving next column done following algorithm overwrites l new factors aa performs oatingpoint operations algorithm 1 dense rankr updatedowndate r end r work supported national science foundation davisciseu edudavis po box 116120 department computer information science engineering university florida gainesville fl 326116120 phone 352 3921481 fax 352 3921220 tr99006 june 1999 revised sept 2000 z hagermathu eduhager po box 118105 department mathe matics university florida gainesville fl 326118105 phone 352 3920281 fax 352 3928357 davis william w hager end r l end end end develop sparse version algorithm accesses modies entries l change theory rank1 paper 10 shows columns change correspond nodes elimination tree path starting node k associated rst nonzero element w k1 w r 1 show columns l change correspond nodes subtree elimination tree express subtree modication elimination tree aa also show reordering columns w arranged inner loop elements row p w updated elements change adjacent sparse techniques develop lead sequential access matrix elements ecient computer memory trac techniques modify sparse factorization many applications including linear program dual active set algorithm leastsquares problems statistics analysis electrical circuits power systems structural mechanics sensitivity analysis linear programming boundary condition changes partial dierential equations domain decomposition methods boundary element methods see 19 section 2 describes notation section 3 present algorithm computing symbolic factorization aa using multisets determines location nonzero entries l sections 4 5 describe multiple rank symbolic update downdate algorithms nding nonzero pattern new factors section 6 describes algorithm computing new numerical values l either update downdate experimental results presented section 7 2 notation background given location nonzero elements aa perform symbolic factorization terminology introduced george liu 15 matrix predict location nonzero elements cholesky factor l actuality predicted nonzeros may zero due numerical cancellation factorization process statement mean l ij symbolically nonzero main diagonals l always nonzero since matrices factor positive denite see 26 p 253 nonzero pattern column j l denoted l denotes collection patterns similarly j denotes nonzero pattern column j collection patterns elimination tree dened terms parent map see 22 node j j row index rst nonzero element column j l beneath diagonal element min x denotes smallest element convention min empty set zero note j j except case diagonal element column j nonzero element children node j set nodes whose parent j ancestors node j denoted pj set successive parents j ancestor sequence nite sequence nodes j j j forming pj called path j associated tree root nal node path collection paths leading root form elimination tree set trees elimination forest typically single tree whose root however column j l one nonzero element diagonal element j root separate tree number elements size set x denoted jx j jaj jlj denote sum sizes sets contain 3 symbolic factorization matrix form aa pattern l j column j union patterns column l whose parent j column whose smallest row index nonzero entries j see 16 22 min akj modify 31 update downdate without recomputing scratch need keep track entry entered l j 10 example c changes may need remove term l c n fcg cannot simply perform set subtraction since may remove entries appear terms keep track entries enter leave set l j maintain multiset associated column j form 4 timothy davis william w hager multiplicity mi j number children j contain row index pattern plus number columns whose smallest entry j contain row index equivalently 6 j increment equation one ensure diagonal entries never disappear downdate set l j obtained l removing multiplicities dene addition multiset x set following way similarly subtraction set multiset x dened multiset subtraction x undoes prior addition multiset x set contrast x n equal x x disjoint sets using multiset addition instead set union 31 leads following algorithm computing symbolic factorization aa algorithm 2 symbolic factorization aa using multisets c end k min end end 4 multiple rank symbolic update consider pattern l changes aa replaced aa ww since essence augment w order evaluate new pattern column l according 31 new pattern l j column j l update min akj w pattern column w throughout put bar matrix set denote new value update downdate following theorem consider column j matrix l pattern modied sets w let l j denote multiset column j rankr update downdate applied theorem 41 compute new multiset l j perform following modications case pattern column case b c c child j old new elimination tree case c c c child j new tree old one case c c child j old tree new one proof cases ad account adjustments need make l j order obtain l j adjustments deduced comparison 31 41 case simply add w multisets 41 appear 31 case b node c child node j update case must adjust deviation l c l c 10 prop 32 rank1 update l c l c w denotes ith column w hence updating aa ww equivalent r successive rank1 updates aa repeated application 10 prop 32 l c l c rankr update aa 6 timothy davis william w hager follows l c l c deviate set l c n l c consequently case b simply add l c n l c case c node c child j new elimination tree old tree case need add entire set l c n fcg since corresponding term appear 31 similarly case node c child j old elimination tree new tree case entire set l c nfcg deleted case c child j either old new elimination tree result adjustment since corresponding l c term absent 31 41 algorithm updating cholesky factorization based theorem would visit nodes j 1 consider possible children c j hand nodes j 1 need considered since columns l change aa modied 10 thm 41 show nodes whose patterns change contained pk 1 dene rankr update let p ancestor map associated elimination tree cholesky factorization matrix 10 thm 41 nodes whose patterns change rankr update contained union patterns although could evaluate dicult eciently since need perform series rank1 updates evaluate ancestor map hand 10 prop 31 10 prop 32 p j p i1 j j follows p consequently nodes whose patterns change rankr update contained set 1ir theorem 42 shows node also contained one sets p k follows nodes precisely nodes entries associated columns l change rankr update presenting theorem illustrate simple example shown figure 41 left figure 41 shows sparsity pattern original matrix aa cholesky factor l corresponding elimination tree nonzero pattern rst column w 2g performed single rank1 update causes modication columns 1 2 6 8 l corresponding nodes original tree encircled nodes form path p 1 8g node 1 root node 8 second tree middle figure 41 shows matrix rank1 update factor elimination tree entries second 1 dier original matrix aa shown small pluses second column w nonzero pattern w 7g rank1 update aects columns p 2 l columns form single path nal elimination tree shown right gure rst rank1 update set columns actually change p 1 8g subset path nal tree use p1 guide work associated column 1 w visit columns second update first update elimination tree elimination tree first update elimination tree original factor l factor second update factor first update original matrix second update1 t6743 original fig 41 example rank2 update need modied plus column 7 node 7 set nodes p3 aected second rank1 update however shown following theorem theorem 42 paths contained conversely contained p proof theorem observe paths contained suppose node j lies tree need prove contained p largest integer pk contains j let c child j c lies path pk j lies path pk since j parent c since j lie path pk follows c lie path pk applying argument recursively conclude none nodes subtree rooted j lie path pk let j denote subtree rooted j since contained pk none nodes j lie paths thm 41 patterns nodes outside path unchanged let l c pattern column c cholesky factorization 42 since node c contained j lie 8 timothy davis william w hager dc e f c fig 42 example rank8 symbolic update subtree paths c l since k node j path p must include j figure 42 depicts subtree example rank8 update subtree consists nodes edges one paths pk 1 paths form subtree general graph since paths initial node root elimination tree matrix l subtree might actually forest l elimination forest rather elimination tree rst nonzero positions w 1 w 8 correspond nodes k 1 k 8 example node k 4 happens lie path p 1 k 1 nodes paths rst intersect shown smaller circles labeled f nodes along paths shown curved arrow denotes single subpath example arrow nodes b e denotes subpath b e pb subpath denoted pb e figure 42 following algorithm computes rankr symbolic update keeps track array pathqueues one column l queue contains set pathmarkers range 1 r denote paths pk 1 next two paths merged one paths needs considered arbitrarily select highernumbered path represent merged paths set pathqueues requires om removing inserting pathmarker pathqueue takes o1 time outputs algorithm new pattern l elimination tree namely l j columns aected rankr update dene l node j case c occur c j prior visiting column c since thus place c lostchildqueue column c encountering case c nodes c j algorithm visits node c lostchildqueue contain nodes case holds set lostchildqueues set pathqueues although exactly one lostchildqueue one pathqueue column j l algorithm 3 symbolic rankr update add new matrix w find starting nodes path r place pathmarker pathqueue column k end consider columns corresponding nodes paths pk 1 pathqueue column j nonempty pathmarker pathqueue column j let c prior column path case j rst node path pk prior c else case b c old child j possibly changed else case c c new child j lost child c place c lostchildqueue column c endif end case consider lost child j c lostchildqueue column j end move one step paths let largest pathmarker pathqueue column j place pathmarker pathqueue column j pathqueue column j nonempty end optimal time general rankr update davis william w hager actual time taken algorithm 3 slightly higher namely om bookkeeping required pathqueues practical cases om term dominant term run time algorithm 3 used compute entire symbolic factorization start factorizing identity matrix ii ldl iii case j initial elimination tree forest nodes edges determine symbolic factorization aa using rankr update algorithm matrix identical symbolic factors aa case apply column corresponding min akj term 31 since c 0 c cases b apply column j case c apply children elimination tree corresponding term 31 since duplicate paths discarded merge modify column j child c elimination tree work performed symbolic factorization algorithm algorithm 2 ojlj hence algorithm 3 equivalent algorithm 2 apply update aa run time optimal case 5 multiple rank symbolic downdate downdate algorithm analogous downdated matrix aa ww w subset columns downdate pk pk thus rather following paths pk follow paths pk entries dropped downdate thus l j l j j j start l j make following changes case pattern w removed column j case b c child j old new tree need remove l entries old pattern l c new pattern l c case c node c c child j old elimination tree new tree compute multiplerank modifications 11 case node c c child j new tree old one compute case c occur c j prior visiting column c since thus place c newchildqueue c encountering case c nodes c j algorithm visits node c newchildqueue contain nodes case holds algorithm 4 symbolic rankr downdate remove matrix w find starting nodes path r place pathmarker pathqueue column k end consider columns corresponding nodes paths pk 1 pathqueue column j nonempty pathmarker pathqueue column j let c prior column path case j rst node path pk prior c else case b c old child j possibly changed else case c c lost child j new child c place c newchildqueue column c endif end case consider new child j c newchildqueue j end move one step paths let largest pathmarker pathqueue column j place pathmarker pathqueue column j pathqueue column j nonempty end davis william w hager time taken algorithm 4 slightly higher optimal time practical cases om term asymptotic run time algorithm 4 dominant term 6 multiple rank numerical update downdate following numerical rankr updatedowndate algorithm algorithm 5 overwrites l updated downdated factors algorithm based algorithm 1 onepass version method c1 18 presented section 1 algorithm used symbolic update algorithm algorithm 3 found subtree corresponding nodes whose patterns change symbolic downdate algorithm algorithm 4 found since columns matrix w reordered without aecting product ww reorder columns w using depthrst search 6 march tree consecutive columns w utilized computations reordering improves numerical datedowndate algorithm placing columns w aect given subpath next eliminating indexing operation reordering columns sparse matrix prior cholesky factorization common 3 22 23 25 improves data locality simplies algorithm reordering w multiple rank updatedowndate depth rst ordering tree changes elimination tree changes columns w must ordered update downdate illustrate reordering consider subtree figure 42 rank8 update depthrstsearch algorithm visits child subtrees left right resulting reordering shown figure 61 subpath figure 61 labeled range columns w aect subpath order subpath processed algorithm 5 consider path node c e figure 42 columns l corresponding nodes subpath updated columns 2 8 3 5 w order reordered subtree figure 61 columns subpath updated columns 5 8 reordered w algorithm 5 sparse numeric rankr modication add ww columns w reordered r end subpath depthrstsearch order let c 1 c 2 columns w aect subpath column j subpath e f c 13th 2nd 1st 6th 3rd 4th 7th 8th 9th 10th 11th 12th 3 47885th fig 61 example rank8 update depthrstsearch reordering end l end end end end time taken r rank1 updates 10 r l j pattern column j ith rank1 update time asymptotically optimal single rankr update cannot determine paths uses pk instead thus time taken algorithm 5 rankr update r slightly higher 61 14 timothy davis william w hager table dense matrix performance 64by64 matrices 64by1 vectors operation ops dgemm matrixmatrix multiply 1716 dgemv matrixvector multiply 1300 dtrsv solve daxpy vector computation ddot dot product ith column w necessarily aect columns path pk w aect column j w ji zero inner loop algorithm 5 example occurs figure 41 column 1 w aect column 7 l could check condition reduce asymptotic run time r practice however found paths dier much including test improve overall performance algorithm time taken algorithm 5 rankr downdate similar namely r numerical algorithm updating downdating essentially ldl 4 24 dierence diagonal scaling either ldl symbolic algorithms identical 7 experimental results test methods selected experiment earlier paper singlerank update downdate 10 mimics behavior linear programming dual active set algorithm 20 rst consists 5446 columns larger 6071 arising airline scheduling problem dfl001 13 5446 columns correspond optimal solution linear programming problem starting initial ldl factorization matrix added columns b corresponding update obtained factors 10 6 bb removed columns rstinrstout order corresponding downdate obtained original factors lp dasa algorithm would perform much work 6784 updates 6784 dates solve linear programming problem experiment took place sun ultra enterprise running solaris 26 operating system eight 248 mhz ultrasparcii processors one processor used 2gb main memory dense matrix performance millions oatingpoint operations per second ops blas 12 shown table 71 results presented codes except colmmd spooles blas written c programming language using double precision oating point arithmetic rst permuted rows b preserve sparsity cholesky factors bb done eciently colamd 7 8 9 21 based table average update downdate performance results ops r seconds update downdate update downdate 9 14 approximate minimum degree ordering algorithm 1 however keep results consistent prior rank1 updatedowndate paper 10 used permutation experiments colmmd 17 colamd matlabs colmmd compute ordering without forming bb explicitly symbolic factorization bb nds nonzero counts column factors step takes amount space proportional number nonzero entries b gives us size static data structure hold factors updating downdating process numerical factorization bb required second symbolic factorization nds rst nonzero pattern l initial numerical factorization computes rst factors l used nonsupernodal factorization code similar sparspak 5 15 since updatedowndate algorithms use supernodes supernodal factorization code spooles 3 multifrontal method 2 14 get better performance factorization method used impact performance update downdate algorithms ran dierent experiments one using dierent rankr update downdate r varied 1 16 rankr update solved sparse linear system ldl using dense righthand side b compare performance rank1 update rankr update r 1 divided run time rankr update r gives us normalized time single rank1 update average time ops rate normalized rank1 update downdate entire experiment shown table 72 time update downdate solve increases factors become denser performance terms ops fairly constant three operations rst rank16 update factor l sparsest takes 047 seconds 00294 seconds normalized runs 655 ops compared 651 ops table 72 average speed rank16 updates performance step summarized table 73 rank5 update takes time using updated factors solve sparse linear system even though rank5 update performs 26 times work work terms oatingpoint operations varies slightly r changes rank1 updates total work updates 17293 billion davis william w hager table dense matrix performance 64by64 matrices 64by1 vectors operation time sec ops notes colamd ordering 045 symbolic factorization bb symbolic factorization rst l 046 831 thousand nonzeros numeric factorization rst l code 2007 240 numeric factorization rst l spooles 1810 266 numeric factorization bb code 6104 185 required numeric factorization bb spooles 1780 633 required average rank16 update 063 651 compare rank1 average rank5 update 025 510 compare solve step average rank1 update 0084 303 average solve ldl point operations 255 million per rank1 update rank16 updates worst case total work increases 17318 billion oatingpoint operations downdates take total 17679 billion oatingpoint operations 261 million per rank1 downdate rank16 downdates take total 17691 billion operations conrms nearoptimal operation count multiple rank updatedowndate compared optimal rank1 updatedowndate solving l sparse b dense computing sparse ldl factorization using nonsupernodal method give rather poor computation tomemoryreference ratio 23 tried loop unrolling technique used updatedowndate code sparse solve sparse ldl factorization codes resulted improvement performance sparse rankr update downdate implemented onepass algorithm much better memory trac series r rank1 modications numerical experimentation dfl001 linear programming test problem rankr modication twice fast r rank1 modications r 11 superior performance multiple rank algorithm explained using computationtomemoryreference ratio c algorithm 5 subpath aected one column w shown ratio 45 l j large ratio c aected 16 columns w 6435 l j large hence going rank1 rank16 update improves computationtomemoryreference ratio factor 23 column j l many nonzeros comparison level1 blas routines dense matrix computations vector computations daxpy ddot 11 computationtomemoryreference ratios 23 1 level2 blas dgemv dtrsv example ratio 2 8 summary improved memory locality multiplerank sparse updatedowndate method twice fast prior rank1 updatedowndate method performance new method 651 ops sparse rank16 update compares favorably dense matrix performance 815 ops solve dense system sparse matrix performance 180 ops solve sparse system observed peak numerical factorization 633 ops spooles computer used experiments although strictly optimal multiplerank updatedowndate method nearly operation count rank1 updatedowndate method optimal operation count multiplerank modifications 17 r approximate minimum degree ordering algorithm vectorization multiprocessor multifrontal code spooles objectoriented sparse matrix library cholesky downdating algorithm systolic simd architectures sparspak waterloo sparse matrix package introduction algorithms column approximate minimum degree ordering algorithm column approximate minimum degree ordering algorithm modifying sparse cholesky factorization philadelphia siam publications set level3 basic linear algebra subprograms distribution mathematical software via electronic mail multifrontal solution inde computer solution large sparse positive de data structure sparse qr lu factorizations sparse matrices matlab design implementation methods modifying matrix factorizations updating inverse matrix approximate minimum degree column ordering algorithm role elimination trees sparse factorization supernodal cholesky factorization algorithm sharedmemory multiprocessors new york tr ctr w hager dual active set algorithm application linear programming computational optimization applications v21 n3 p263275 march 2002 ove edlund software package sparse orthogonal factorization updating acm transactions mathematical software toms v28 n4 p448482 december 2002 matine bergounioux karl kunisch primaldual strategy stateconstrained optimal control problems computational optimization applications v22 n2 p193224 july 2002 nicholas gould jennifer scott yifan hu numerical evaluation sparse direct solvers solution large sparse symmetric linear systems equations acm transactions mathematical software toms v33 n2 p10es june 2007
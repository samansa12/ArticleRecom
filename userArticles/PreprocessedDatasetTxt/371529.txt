implementing etransactions asynchronous replication abstractthis paper describes distributed algorithm implements abstraction etransaction transaction executes exactlyonce despite failures algorithm based asynchronous replication scheme generalizes wellknown activereplication primarybackup schemes devised algorithm threetier architecture mind enduser interacts frontend clients eg browsers invoke middletier application servers eg web servers access backend databases algorithm preserves threetier nature architecture introduces acceptable overhead respect unreliable solutions b introduction recently threetier architectures leading edge development tools supported small number productionlevel applications implemented threetier applications becoming mainstream match logical decomposition applications presentation logic data software hardware structuring pcs workstations clusters clients diskless eg browsers application servers stateless contain core logic application eg web servers backend databases contain state applications basically client submits request application server behalf enduser application server processes clients request stores resulting state backend database returns result client simple interaction scheme heart socalled ebusiness game today motivation partitioning application several tiers provides better modularity scalability however multiplicity components interdependencies make harder achieve meaningful form reliability current reliability solutions threetier architectures typically transactional 1 2 ensure atmostonce request processing form allornothing guarantee major limitation solutions precisely impossibility clientside software accurately distinguish nothing scenario failure occurs middle backend tier request processing timeout period expires client side enduser typically receives exception notification convey actually happened whether actual request indeed performed 1 practice endusers typically retry transaction risk executing several times eg 1 transactional guarantee ensures request indeed performed eects made durable scenario otherwise eects discarded nothing scenario 3 user charged twice short current transactional technology typically ensures atmostonce request processing retrying transactions endusers typically obtain atleastonce guaran tees ensuring exactlyonce transaction processing hard basically transaction outcome information made highly available clear exactly information preserved stored long motivation work define implement abstraction exactlyoncetransaction etransaction threetier architecture intuitively abstraction masks physical transaction aborts adds liveness dimension transactional systems also includes client side frees enduser burden resubmit transactions protocol paper presents distributed protocol implements etransaction abstraction integrate replication scheme guarantees etransaction liveness property transactional scheme ensures traditional safety counterpart integration involves client application servers database servers deal inherent nondeterminism interaction thirdparty databases make use writeonce registers woregister consensuslike abstractions capture nice intuition cdroms written read several times building abstractions leads modular protocol enables us reuse existing results solvability consensus distributed systems eg 4 2 indirectly contribute better understand safety aspect transactions practically mixed liveness feature replication consensus abstraction help achieve mix related work considerable work devoted transaction execution replicated data 3 however know approach replicate actual transaction processingstate order ensure faulttolerance transaction ie eventually commits exactlyonce traditionally assumed transaction cannot access enough replicas aborted 3 issue reliably determine transactions outcome possibly retry addressed fact addressing issue requires careful use form nonblocking transaction processing highly available recovery information reflects transaction processing state 6 problem exactlyonce message delivery addressed communication channels author pointed importance reliably storing message recovery information context exactlyonce transaction processing recovery information represent transactionprocessing state several approaches proposed literature store state recovery purposes eg 7 8 9 nevertheless approaches guarantee highavailability state furthermore rely disk storage client application server relying clients disk problematic client java applet right access disk solutions based disk storage specific application server would make server host dependent threetier architectures considered scalable precisely prevent form host dependence middletier 10 etransaction protocol uses replication scheme highly available storage transactionprocessing state eective way retry transactions behind scenes contrast replication schemes know 11 12 13 14 assume stateless servers interact thirdparty databases replication schemes usually designed clientserver context servers stateful interact thirdparty entities another woregister also viewed distributed form software counter 5 characteristic replication scheme asynchronous nature tolerates unreliable failure detection may vary runtime form primarybackup 12 form active replication 11 practical considerations etransaction protocol designed practical objective mind particular assume functionality database server given state ful autonomous resource runs xa interface 15 xopen standard database vendors supposed comply distributed transactionprocessing applications preserve threetier nature applications relying disk access client site application server site make assumption failure detection scheme used clientside software detect crash application servers tolerate failure suspicion mistakes among application servers overhead etransaction protocol acceptable practical setting application servers run orbix 23 object request broker 16 database servers oracle 803 database management system 17 terms latency viewed client protocol introduces overhead 16 baseline protocol oer reliability guarantee roadmap rest paper organized follows section 2 defines system model section 3 describes etransaction problem section 4 describes protocol assumptions underlying correctness finally section 5 puts contribution perspective final remarks appendix 1 describes pseudocode used express protocol appendix 2 discusses protocol correctness appendix 3 performance implementation threetier model consider distributed system finite set processes communicate message passing processes fail crashing point time process either crash causes transition recovery causes transition crash process impact stable storage process behaves according algorithm assigned processes behave maliciously following outline representation three types processes threetier application clients application servers database servers clients client processes denoted c 1 c 2 c k c client assume domain request request values describe requests domain submitted application servers clients operation issue invoked request parameter eg behalf enduser say client issues request operation issue invoked issue primitive supposed return result value domain result say client delivers result eg enduser result value result domain represents information computed business logic reservation number hotel name must returned user practice request vector values case travel application instance request typically indicates travel destination travel dates together information hotel category size car rent etc corresponding result typically contains information flight reservation hotel name address name car company etc issued client request processed without input client furthermore client issues requests oneatatime although issued client two consecutive requests considered unrelated clients cannot communicate directly databases application servers assume request result uniquely identified furthermore assume every result uniquely associated transaction say result committed resp aborted actually mean corresponding transaction committed resp aborted presentation simplicity assume result corresponding transaction identifier simply represent indentifiers using integers application servers application server processes denoted 1 2 appserver application servers stateless sense maintain states accross request invocations requests sideeects state application servers database state thus request cannot make assumption previous requests terms applicationserver state changes stateless application servers important aspect threetier applications stateless servers host anity means freely migrate moreover failover fast wait server recover state model chained invocation application servers model client invokes single application server server invoke application servers chained invocation present additional challenges reliability standpoint application servers stateless ignore aspect model simplify discussion application servers interact databases transactions presentation simplic ity explicitly model commitment processing business logic sql queries performed application servers use function called compute abstract tran database manipulations performed business logic travel example compute would query database determine flight car availabilities perform appropriate bookings however compute function commit changes made database simply returns result since commitment processing fail may call compute multiple times request however compute nondeterministic result depends database state assume result returned compute nonnil particular model userlevel aborts regular result values userlevel abort logical error condition occurs business logic processing example seats requested flight rather model userlevel aborts special error values returned compute model regular result values databases refuse commit every application server access local failure detector module provides information crash application servers let 1 2 two application servers say server 2 suspects server 1 failure detector module 2 suspects 1 crashed abstract suspicion information predicate suspect let 1 2 two application servers execution suspecta 1 server 2 returns true 2 suspects 1 time database servers database server processes denoted 1 2 n server since want approach apply otheshelf database systems view database server xa 15 engine particular database server pure server invoke servers responds invocations represent full xa functionality represent transaction commitment aspects xa prepare commit use two primitives vote decide represent transaction commitment functionality vote primitive takes parameter result identifier returns vote domain vote yes roughly speaking yes vote means database server agrees commit result ie corresponding transaction decide primitive takes two parameters result identifier outcome domain abort decide primitive returns outcome value input value abort returned value also abort b database server voted yes result input value commit returned value also commit 3 3 exactlyonce transaction problem roughly speaking providing etransaction exactlyoncetransaction abstraction comes ensure whenever client issues request unless crashes corresponding result computed application server result committed every database server eventually delivered client servers might go sequence aborted intermediate results one commits client delivers corresponding result ensuring database consistency requires database servers agree outcome every result abort commit clientside consistency requires committed result returned enduser following state specification etransaction problem details underlying intuition rationale behind problem specification given 18 sake presentation simplicity without loss generality consider one client assume client issues one request assume existence serializability protocol 3 hence omit explicit identifiers distinguish dierent clients dierent requests together identifiers relate dierent results request define etransaction problem three categories properties termination agreement validity termination captures liveness guarantees preventing blocking situations agreement captures safety guarantees ensuring consistency client databases validity restricts space possible results exclude meaningless ones termination t1 client issues request unless crashes eventually delivers result t2 database server votes result eventually commits aborts result agreement delivered client unless committed database servers commits two dierent results decide dierently result 3 terms xa vote primitive corresponds prepare operation decide primitive patterned commit operation validity client delivers result result must computed application server parameter request issued client server commits result unless database servers voted yes result termination ensures client remain indefinitely blocked t1 intuitively property provides atleastonce request processing guarantee enduser frees burden retry requests termination also ensures database server remains blocked forever waiting outcome result t2 ie matter happens client nonblocking property important database server voted yes result might locked resources remain inaccessible result committed aborted 3 agreement ensures consistency result a1 databases a3 also guarantees mostonce request processing a2 first part validity v1 excludes trivial solutions problem client invents result delivers result without issued request second part v2 conveys classical constraint transactional systems result committed least database server refuses basically point section 5 etransaction specification adds traditional termination properties distributed databases properties bridge gap databases clients one hand atleastonce exactlyonce hand 4 exactlyonce transaction protocol protocol consists several parts one executed client one executed application servers one database servers figure 1 client interacts application servers interact database servers complete algorithms given figure 2 figure 3 figure 4 figure 5 figure 6 describe pseudocode used algorithms appendix 1 give correctness proofs appendix 2 client protocol client part protocol encapsulated within implementation issue primitive figure 2 primitive invoked request input parameter supposed eventually return result basically client keeps retransmitting request application servers receives back committed result client might need go several tries intermediate results gets committed result optimize failurefree scenario client initially send request application servers unless receive result backo period line 7 figure 2 application server protocol application servers execute call asynchronous replication protocol figure 5 figure 6 nice run process crashes suspected crashed protocol goes follows default primary application server supposed initially receive clients request primary application server computes result clients request orchestrates distributed atomic commitment protocol among database servers commit abort result application server informs client outcome result outcome might commit abort according votes databases figure 1 b application server suspects crash primary becomes primary tries terminate result figure 6 result already committed new primary finishes commitment result sends back decision client figure 1 c otherwise new primary aborts result informs client abort decision figure 1 form synchronization needed 1 result computation nondeterministic 2 several primaries might performing time assume reliable failure detection need ensure application servers agree outcome every result factor synchronization complexity consensus abstraction call writeonce registers simply woregisters woregister two operations read write roughly speaking several processes try write value register one value written written value written process read value invoking operation read precisely write takes parameter input returns parameter output returned parameter either input process indeed written value value already written register read returns value written register initial value value v written register process keeps invoking read operation unless process crashes eventually value returned value v intuitively semantics woregister looks much like cdrom fact woregister simple extension socalled consensus object 19 simply assume existence waitfree woregisters 19 easy see one could obtain waitfree implementation woregister consensus protocol executed among application servers eg 4 every application server would copy register basically writing value woregister comes proposing value consensus protocol read value process simply returns decision value received consensus protocol returns consensus triggered database server protocol figure 3 illustrates functionality database servers database server pure server client servers waits messages application servers either vote decide results database server protocol parameter indicates whether protocol called initially recovery parameter bound variable recovery used body protocol take special recovery actions line 2 figure 3 recovery database server informs application servers coming back correctness assumptions prove correctness protocol appendix 2 proofs based following assumptions discuss practicality assumptions section 5 client transactional manipulation databases prepare yes ackack commit result appservers regdwriteresultcommit request a2 a3 client transactional manipulation databases prepare ackack appservers request a2 a3 abort abort regdwritenilabort client transactional manipulation databases prepare yes appservers regdwriteresultcommit request a2 a3 crash suspect client transactional manipulation databases appservers request a2 a3 crash suspect failover abort failover commit ack commit result ack abort abort c failurefree run commit b failurefree run abort figure 1 communication steps various executions class clientprotocol list appserver alist theappservers list application servers appserver 1 theprimary default primary period theperiod backo period issuerequest request appserver application server decision decision pair resultoutcome begin true send requestrequest j 1 3 timeout period set timeout period 4 wait receive resultj decision expirestimeout 5 expiredtimeout 6 send requestrequest j alist 7 wait receive resultj decision 9 returndecisionresult delivers result exits figure 2 client algorithm class dataserver list appserver alist theappservers list application servers mainbool recovery outcome outcome outcome result commit abort appserver application server integer j result identifier begin recovery initial starting case send ready alist recovery notification 3 true receive preparej 6 send votejthisvotej receive decidej outcome 9 send ackdecidej terminateinteger j outcome outcome commit abort result voteinteger determine vote result figure 3 database server algorithm class appserverprotocol client c client list appserver alist theappservers list application servers list dataserver dlist thedataservers list database servers array decision woregister regd array decision woregisters array appserver woregister rega array application server woregisters mainarray decision woregister r appserver woregister r begin 3 true computation thread cleanning thread 7 coend terminateinteger j decision decision repeat 3 send decidej decisionoutcome dlist 4 wait every k dlist 5 receive ackdecidej ready k 6 receivedackdecidej every k dlist 7 send resultj decision c 9 prepareinteger send preparej dlist 3 wait every k dlist 4 receive votej vote k ready k 5 every k dlist receivedvotejyes k 6 returncommit 7 else returnabort clean figure 4 application server algorithm request request request client appserver application server decision decision nilabort pair outcomeresult integer j result identifier begin true receive requestrequest j c 4 send resultj decision c result already committed 5 else 6 regajwritethis 9 decisionoutcome thispreparej decision regdjwritedecision figure 5 computation thread decision decision nilabort pair outcomeresult appserver application server list integer clist list cleaned results integer j result identifier begin true 2 every alist cleanning results initiated 5 regajread 6 j clist 7 decision regdjwritenilabort 9 add j clist figure cleanning thread assume majority application servers correct always failure detector among application servers supposed eventually perfect sense 4 words assume following properties satisfied completeness application server crashes time time permanently suspected every application server accuracy time correct application server ever suspected application server also assume database servers good 1 always recover crashes eventually stop crashing 2 application server keeps computing results result eventually commits 4 assume clients application servers database servers connected reliable channels guarantees provided reliable channel abstraction captured following properties termination process p sends message process p j unless p eventually delivers integrity every process receives message message previously broadcasts process messages supposed uniquely identified concluding remarks specification etransactions intuitively etransaction abstraction desir able client issues request within etransaction unless crashes request executed exactlyonce client eventually delivers corresponding result client crashes request executed atmostonce database resources eventually released conveyed specification section 3 properties underlying etransactions encompass players threetier architecture client application servers databases surprisingly properties similar nonblocking transaction termination 3 sense properties ensure nonblocking atmostonce basically specification etransactions extend bridge gap atmostonce exactlyonce semantics asynchrony replication scheme heart etransaction protocol asynchronous replication scheme performed among application servers roughly speaking patient client reliable failure detector replication scheme tends similar primary backup scheme 12 one active primary time impatient client unreliable failure detector may easily end situation application servers try concurrently commit abort result case like active replication scheme 11 single primary application servers equal rights one characteristics replication protocol precisely may vary runtime two extreme schemes practicality protocol many assumptions made needed ensure termination properties protocol appendix 2 include assumption majority correct application servers assumption eventually perfect failure detector among application servers assumption every database server eventually always 4 assumption results eventually commit mean eventually seat full flight means application server eventually stop trying book seat full flight instead compute result actually run completion example result informs user booking problem liveness properties woregisters communication channels words properties violated protocol might block would violate agreement validity property specification appendix 2 practice terminationrelated assumptions need hold processing request example need assume request majority application servers remains every database server eventually stay long enough successfully commit result request 5 furthermore assumption majority correct processes needed keep protocol simple explicitly deal application server recovery without assumption majority correct processes one might still ensure termination properties making use underlying building blocks explicitly handle recovery 22 23 assumption reliable channels exclude link failures long assume link failure eventually repaired practice abstraction reliable channels implemented retransmitting messages tracking duplicates finally simplify presentation protocol consider garbage collection issues example address issue cleanning woregister arrays integrate garbage collector task one needs state atmostonce guarantee ensured client retransmit requests known period time able state kind guarantees would require timed model eg along lines 24 failure detection schemes important notice protocol makes use three failure detection schemes architecture actually surprising given nature threetier systems 1 among application servers assume failure detector eventually perfect sense 4 pointed failure suspicions however lead incon sistency 2 application servers rely simple notification scheme tell database server crashed recovered practice application servers would detect database crashes database connection breaks database server crashes application servers would receive exception error status trying manipulate database implemented without requiring database servers know identity application servers 3 clients use simple timeout mechanisms resubmit requests design decision reflects expectation clients communicate servers across internet basically gives rise unpredictible failure detection practicality implementation current implementation built using otheshelf technologies orbix 23 object request broker 16 oracle 803 database management system 17 prototype however aimed exclusively testing purposes terms latency viewed client protocol introduces overhead 16 baseline protocol oer reliability guarantee see appendix 3 overhead corresponds steadystate failure suspicion free executions executions likely occur practice protocols usually optimized nevertheless complete evaluation practicality protocol one obviously needs consider actual 5 ensuring recovery every database server within reasonable time delay typically achieved running databases clusters machines 20 21 cluster ensure databases always recover within reasonable delay must still assume system reaches steady state database servers stay long enough guarantee progress request processing asynchronous system however explicit notion time notion long enough impossible characterize simply replaced term always responsetime protocol case various failure alternatives go use underlying consensus protocols also optimized case failures failure suspicions eg 25 23 r microsoft transaction server changes com programming model object management group concurrency control recovery database systems unreliable failure detectors reliable distributed systems supporting nondeterministic execution faulttolerant sys tems reliable messages connection establishment implementing recoverable requests using queues ecient transparent application recovery clientserver information systems integrating object transaction service web corba faulttolerance add replication management using state machine approach primarybackup approach delta4 approach dependability open distributed computing systems semipassive replication xopen company ltd orbix 22 programming guide oracle8 application developers guide exactlyoncetransactions waitfree synchronization clusters highavailability primer hpux solutions design architecture microsoft cluster servicea practical approach highavailability scalability failure detection consensus crashrecovery model lazy consensus timed asynchronous model simple fast asynchronous consensus protocol based weak failure detector tr ctr francesco quaglia paolo romano reliability threetier systems without application server coordination persistent message queues proceedings 2005 acm symposium applied computing march 1317 2005 santa fe new mexico paolo romano francesco quaglia bruno ciciani lightweight scalable etransaction protocol threetier systems centralized backend database ieee transactions knowledge data engineering v17 n11 p15781583 november 2005 wenbing zhao louise e moser p michael melliarsmith unification transactions replication threetier architectures based corba ieee transactions dependable secure computing v2 n1 p2033 january 2005 svend frlund rachid guerraoui etransactions endtoend reliability threetier architectures ieee transactions software engineering v28 n4 p378395 april 2002 roberto baldoni carlo marchetti threetier replication ftcorba infrastructures softwarepractice experience v33 n8 p767797 10 july
indexbased checkpointing algorithm autonomous distributed systems abstractthis paper presents indexbased checkpointing algorithm distributed systems aim reducing total number checkpoints ensuring checkpoint belongs least one consistent global checkpoint recovery line algorithm based equivalence relation defined pairs successive checkpoints process allows us cases advance recovery line computation without forcing checkpoints processes algorithm wellsuited autonomous heterogeneous environments process know private information processes private information type distinct processes related eg clock granularity local checkpointing strategy etc also present simulation study compares checkpointingrecovery overhead algorithm ones previous solutions b introduction checkpointing one techniques providing faulttolerance distributed systems 6 global checkpoint consists set local checkpoints one pro cess distributed computation restarted failure local checkpoint state process saved stable storage global checkpoint consistent local checkpoint set happens 9 another one 4 10 three classes algorithms proposed literature determine consistent global checkpoints un coordinated coordinated communication induced 6 first class processes take local checkpoints independently upon occurrence failure procedure rollbackrecovery tries build consistent global checkpoint note consistent global checkpoint might exist producing domino effect 1 12 worst case rollbacks computation initial state second class initiator process forces pro cesses failurefree computation take local work partially supported scientific cooperation network european community olos contract erb4050pl932483 checkpoint using control messages coordination either blocking 4 nonblocking 8 however cases last local checkpoint process belongs consistent global checkpoint third class coordination done lazy fashion piggybacking control information application messages communicationinduced checkpointing algorithms classified two distinct categories modelbased indexbased 6 algorithms first cate gory example 2 14 target mimic piecewise deterministic behavior process 7 13 well providing dominofree property indexbased algorithms associate local checkpoint sequence number try enforce consistency among local checkpoints sequence number 3 5 11 indexbased algorithms ensure dominofree rollback gener ally less overhead terms number checkpoints control information modelbased ones paper present indexbased checkpointing protocol reduces checkpointing overhead terms number checkpoints compared previous indexbased algorithms protocol well suited autonomous environments process private information processes design algorithm extract rules used indexbased algorithms update sequence number points checkpoints due process increasing sequence numbers hence derive algorithm using equivalence relation pair successive checkpoints process allows recovery line advance without increasing sequence number worst case algorithm takes number checkpoints 11 advantages algorithm quantified simulation study showing checkpointing overhead reduced 30 compared best previous solution price pay application message piggybacks control information one vector integers compared previous proposals paper organized follows section 2 presents system model section 3 shows class indexbased checkpointing algorithms context autonomous en vironments section 4 describes equivalence relation proposed algorithm section 5 simulation study presented 2 model distributed computation consider distributed computation consisting n interact messages ex changing pair processes connected two ways reliable channel whose transmission delay unpredictable finite autonomous sense share memory share common clock value 1 access private information processes clock drift clock granularity clock precision speed recovery actions due process failures considered paper process produces sequence events event moves process one state another assume events produced execution internal send receive statements moreover simplicity consider checkpoint c particular type internal event process dumps current process state onto stable storage send receive events message denoted respectively sendm receivem distributed execution modeled partial order events set events happenedbefore relation 9 checkpoint process p denoted c sn called index sequence number checkpoint process takes checkpoints either pace ba sic checkpoints induced communication pattern forced checkpoints assume process p takes initial basic checkpoint c i0 sake sim plicity basic checkpoints taken periodic algorithm use notation nextc indicate successive checkpoint taken p c checkpoint interval set events c nextc message sent p p j called orphan respect pair c receive event occurred c jsn j send event occurred checkpoint c set local checkpoints one process global checkpoint c consistent orphan message exists pair local checkpoints belonging c fol lowing denote c sn global checkpoint formed checkpoints sequence number sn 2 1 indexbased algorithm presented 5 assumes example standard clock synchronization algorithm provides common clock value process use term consistent global checkpoint csn recovery line lsn interchangeably 3 indexbased checkpointing algorithms simplest way form consistent global checkpoint time basic checkpoint c taken process start explicit coordination coordination results consistent global checkpoint c sn associated local checkpoint strategy induces checkpoints one process per basic checkpoint briatico al 3 argued previous centralized strategy decentralized lazy fashion piggybacking application message index sn last checkpoint taken denoted msn let us assume process p endows variable sn represents sequence number last check point briaticociuffolettisimoncini bcs algorithm sketched using following rules associated action take local checkpoint basic checkpoint scheduled sn increased one checkpoint c taken upon receipt message sn checkpoint cimsn taken sn set msn message processed using rules proved c sn consistent 3 note due rule takeforcedbcs could gap index assigned checkpoints process hence process assigned index sn first local checkpoint process sequence number greater sn included consistent global checkpoint c sn worst case bcs algorithm number forced checkpoints induced basic one n gamma 1 best case processes take basic checkpoint physical time number forced checkpoints per basic one zero however autonomous environment local indices processes may diverge due many causes process speed different period basic checkpoint etc pushes indices processes higher time one processes sends message another one extremely likely number forced checkpoints close induced reduce number checkpoints interesting observation comes manivannansinghal algorithm 11 designed nonautonomous distributed systems reason take basic checkpoint least one forced checkpoint taken current checkpoint interval let us assume process indicates least one forced checkpoint taken current checkpoint period flag set false time basic checkpoint scheduled set true time forced checkpoint taken version manivannansinghal ms algorithm well suited autonomous environment sketched following rules basic checkpoint scheduled skip increased one checkpoint upon receipt message sn msn checkpoint cimsn taken sn set msn skip message processed even though ms algorithm produces reduction total number checkpoints number forced checkpoints caused basic one equal bcs takeforcedms actually similar takeforcedbcs section propose algorithm includes takebasicms rule however basic checkpoint taken local sequence number updated occurrence particular checkpoint communication pattern rationale behind solution time basic checkpoint taken without increasing sequence number force checkpoints reduces total number checkpoints end let us first introduce relation equivalence defined pairs successive checkpoints process 41 equivalence relation checkpoints definition 41 two local checkpoints c nextc process p equivalent respect recovery line l sn denoted lsn lsn sn sn 2sn figure 1 examples pairs equivalent checkpoints example let consider recovery line l sn depicted figure 1 2sn process p 2 executes either send events receive events messages sent checkpoints included recovery line lsn recovery line l 0 sn created replacing c 2sn nextc 2sn l sn figure also shows construction recovery line sn starting l 0 sn using equivalence c 1sn nextc 1sn respect l 0 sn shown examples equivalence relation simple property see lemmas 41 42 section lsn set l 0 fc gfnextc g recovery line hence presence pair equivalent checkpoints allows process locally advance recovery line without updating sequence 42 sequence equivalence numbers recovery line suppose process p owns two local variables sn sequence number en equivalence number variable sn stores number current recovery line variable en represents number equivalent local checkpoints respect current recovery line sn en initialized zero hence denote c isnen checkpoint p sequence number sn equivalence number en en also called index check point thus initial checkpoint process p denoted c i00 index checkpoint updated according following rule c isnen lsn nextc isnen c isn10 process p also endows vector eq n integers jth entry vector represents knowledge p equivalence number p j current sequence number sn thus ith entry corresponds en eq updated according following rule application message sent process p piggybacks current sequence number sn msn current eq vector meq upon receipt message updated meq taking componentwise maximum msn sn values meq msn copied eq sn let us remark set l recovery line sketch proof property given lemma 44 knowledge p vector eq actually represents recent recovery line sequence number sn 43 tracking equivalence relation upon arrival message sent p j p checkpoint interval isnen one following three cases true sent left side recovery line sent right side recovery line 8j c jsneq j sent right side recovery line p aware according previous cases time checkpoint nextc isnen one following three alternatives message received isnen falls case 2 3 c isnen lsn nextc isnen equivalence tracked process using local context time checkpoint nextc isnen thus nextc isnen equivalence shown figure 2 example behavior ii exists message falls case 3 c isnen equivalent nextc isnen thus nextc isnen iii message falls case 3 exists least message received isnen falls case 2 checkpoint nextc isnen causally related one checkpoint belonging recovery line formed communication pattern shown figure due c 2sn0 nextc 1sn0 consequence process p cannot determine time taking checkpoint nextc isnen lsn optimistically provisionally c isnen lsn provisional indices cannot propagated system time first send event nextc isnen equivalence still undetermined nextc isnen 0 otherwise provisional index becomes permanent figure 2 shows case message 0 brings information encoded 0 eq p 1 sending lsn recovery line advanced p 2 l sn l 0 sn case p 1 determine c 1sn0 equivalent nextc 1sn0 respect l 0 sn advances recovery line l 00 sn 44 algorithm checkpointing algorithm propose bqf takes basic checkpoints using takebasicms rule however update sequence number optimistically assuming basic checkpoint equivalent previous one lsn sn sn figure 2 upon receipt 0 p 1 detects sn basic checkpoint scheduled skip skip else en checkpoint cisnen taken index provisionally set sn due presence provisional indices caused equivalence relation algorithm needs rule sending message order disseminate permanent indices checkpoints sending message en send event en index provisional lsn index sn permanent else sn index last checkpoint replaced permanently sn message sent last rule algorithm takeforcedbqf refines bcss one using simple observation upon receipt message msn sn reason take forced checkpoint send event current checkpoint interval isnen deed causal relation established last checkpoint c en checkpoint belonging recovery line l msn thus index c en replaced permanently index msn 0 takeforcedbqf upon receipt message en sn msn least send event en begin forced checkpoint cimsn0 taken index permanent b sn msn send event en begin index last checkpoint c en replaced permanently message processed example figure 3a local checkpoint c 3snen3 belong recovery line l sn1 index replaced forced checkpoint b c3snen 3 c3sn10 nextc2snen c3snen 3 figure 3 upon receipt c 3snen3 part l sn1 c 3snen3 cannot belong l sn1 b contrary due send event 3snen3 depicted figure 3b forced checkpoint index taken processing message point b takeforcedbqf decreases number forced checkpoints compared bcs else alternative sendmessagebqf part takeforcedbqf represent cases action take basic checkpoint leads update sequence number consequent induction checkpoints processes data structures process behavior assume process p following data structures first send skip provisional past boolean variable first send set true least one send event occurred current checkpoint interval set false time checkpoint taken boolean variable provisional set true whenever provisional index assignement occurs set false whenever index becomes permanent present j represents maximum equivalence number en j piggybacked message received current checkpoint interval p falls case 2 section 43 upon taking checkpoint updating sequence number present initialized 1 checkpoint basic present copied past initialization time message received past past j set 1 predicate past indicates message received past checkpoint interval sent right side recovery line case 2 section currently seen p process behavior shown procedures message handler executed atomic fashion implementation assumes exist one provisional index process time two successive provisional indices detected first index permanently replaced sn init en 0 first send false past h gamma1 8h present h gamma1 arrives p begin first send begin take checkpoint c forced checkpoint first send false assign index sn last checkpoint c provisional false index permanent past h gamma1 8h present h gamma1 present j meqj else begin present j meqj present j meqj 8h past h meqh past h gamma1 process message sends data provisional past begin assign index sn last checkpoint c provisional false index permanent past h gamma1 8h present h gamma1 8h eq h 0 packet message send p first send true basic checkpoint scheduled skip skip false skip basic checkpoint else begin provisional two successive provisional indices past begin past h gamma1 assign index sn last checkpoint c index permanent else 8h past h present h take checkpoint c taking basic checkpoint en assign index sn last checkpoint c provisional true index provisional present h gamma1 first send false 45 correctness proof let us first introduce following simple observations derive directly algorithm observation 1 checkpoint c isn0 exists message msn sn observation derives rule takeforcedbqf considering c isn0 first checkpoint sequence number sn observation 2 checkpoint c isnen exists message msn sn received isnen observation derives rule takeforcedbqf observation 3 message sent derives rule sendmessagebqf lemma 41 set sn 0 recovery line process p checkpoint index sn 0 first checkpoint must included set proof sn 0 recovery line definition otherwise suppose way contradiction recovery line exists message sent process p j process p k orphan respect pair c jsn0 c ksn0 hence c contradicts observation 1 suppose process p k checkpoint sequence number sn case lemmas assumption replace c ksn0 c ksn 0 0 sn 0 sn orphan wrt pair c received checkpoint interval ksn 00 en msn sn 00 contradicting observation 2 suppose process p j checkpoint sequence number sn case lemmas assumption replace c jsn0 c jsn 0 0 sn 0 sn orphan wrt pair c jsn 0 contradicts observation 1 hence cases assumption contradicted claim follows 2 lemma 42 let c isnen nextc isnen two local checkpoints c isnen lsn set en 0 recovery line l sn set recovery line proof c isnen lsn definition 41 message sent p j thus orphan message ever exist respect pair checkpoints 0 2 lemma 41 trivially follows lemma 43 set l 8j eq recovery line lemma 41 lemma 42 checkpoint belongs least one recovery line particular belongs recovery lines sequence number sn 00 lemma 44 set recovery line proof sketch let us assume way contradiction recovery line 8j eq assumption contradicted otherwise exists message sent process p j process p k orphan respect pair c jsneq exists causal message chain brings information p encoded eq hence upon arrival message falls case 2 section 43 case index associated c ksneqk j provisional see third point section 43 p k sends first message 0 forming causal message chain index permanent hence according algorithm index replaced sn reset piggybacked 0 soon last message causal message chain 00 arrives consistent lemma 43 initial assumption contradicted claim follows 2 5 performance study simulation model simulation compares bcs ms proposed algorithm bqf uniform point topoint environment process send message destination message uniformly distributed random variable assume system processes process executes internal send receive operations probability respectively time execute operation process message propagation time exponentially distributed mean value equal 1 10 time units respectively also consider bursted pointtopoint environment process probability enters burst state executes internal send events probability interval uniform pointto point environment described basic checkpoints taken periodically let bcf basic checkpoint frequency percentage ratio tt time elapsed two successive periodic checkpoints total execution time example bcf 100 means initial local checkpoint basic one bcf 01 means process takes 1000 basic checkpoints also consider degree heterogeneity among processes h example means processes checkpoint period means 25 resp 75 processes checkpoint period remaining 75 resp 25 checkpoint period first series simulation experiments conducted varying bcf 01 100 measured ratio tot total number checkpoints taken algorithm total number checkpoints taken bcs second series experiments varied degree heterogeneity h processes measured ratio e total number checkpoints taken bqf ms interested counting many local states recorded checkpoints overhead due taking checkpoints considered simulation run contains 8000 message deliveries value bcf h several simulation runs different seeds result within 4 thus variance reported plots results experiments figure 4 shows ratio tot ms bqf uniform pointtopoint environment small values bcf 10 send receive events checkpoint interval leading high probability equivalence checkpoints thus bqf saves 2 10 checkpoints compared ms value bcf higher 10 ms bqf takes number checkpoints probability two checkpoints equivalent tends zero reduction total number checkpoints amplified bursted environment figure 5 equivalences checkpoints processes running burst mode disseminated processes causing equivalences case values bcf bqf saves 7 18 checkpoints compared ms performance bqf particularly good heterogeneous environment processes shorter checkpointing period processes would push higher sequence number leading high checkpointing overhead using either ms bcs figure 6 ratio e function degree heterogeneity h system shown case uniform bursted pointtopoint environment best performance 30 less checkpointing ms obtained one process checkpoint frequency ten times greater others 2 figure 7 show ratio tot function bcf case environment bqf got maximum gain see figure 6 due heterogeneity bcf range 1 10 slowest processes would like remark whole range checkpointing overhead bqf constantly around 30 less ms bcf checkpoint period total execution time02040608 tot total ckpt total ckpt ms figure 4 tot versus bcf uniform pointto point environment bcf checkpoint period total execution time0408 tot total ckpt total ckpt ms figure 5 tot versus bcf bursted pointto point environment 6 conclusion paper presented indexbased checkpointing algorithm well suited autonomous distributed systems reduces checkpointing overhead compared previous algorithms lies equivalence relation allows advance recovery line without increasing sequence number algorithm optimistically provisionally assumes basic checkpoint c process equivalent previous one process assigning provisional index hence time first send total ckpt total ckpt ms figure uniform pointtopoint environment bursted pointtopoint environment 10 30 50 70 90 bcf checkpoint period total execution time060080tot total ckpt total ckpt ms figure 7 tot versus bcf slowest processes bursted pointtopoint environment event c equivalence verified provisional index becomes permanent otherwise index increased 3 11 directs forced checkpoints processes presented simulation study quantifies saving checkpoints different environments compared previous proposals price pay application message piggybacks information compared one integer used previous algorithms acknowledgements authors would like thank bruno ciciani michel raynal jeanmichel helary achour mostefaoui anonymous referees helpful comments suggestions r modeling consistent checkpoints domino effect distributed systems communicationinduced checkpointing protocol ensures rollbackdependency trackability distributed dominoeffect free recovery algorithm determining global states distributed systems timestampbased checkpointing protocol longlived distributed computations survey rollbackrecovery protocols messagepassing systems manetho transparent rollback recovery low overhead checkpointing rollbackrecovery distributed systems finding consistent global checkpoints distributed computa tion system structure software fault tolerance volatile logging nfaulttolerant distributed systems consistent global checkpoints contains set local checkpoints tr ctr manivannan singhal asynchronous recovery without using vector timestamps journal parallel distributed computing v62 n12 p16951728 december 2002 b gupta k banerjee rollforward recovery scheme solving problem coasting forward distributed systems acm sigops operating systems review v35 n3 p5566 july 1 2001
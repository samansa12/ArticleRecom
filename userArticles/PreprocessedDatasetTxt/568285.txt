decidability edt0l structural equivalence show tree pushdown automaton verify arbitrary nondeterministically constructed structure tree correspond valid derivation given edt0l grammar way reduce structural equivalence problem edt0l grammars deciding emptiness tree language recognized tree pushdown automaton ie emptiness problem contextfree tree languages thus establish structural equivalence edt0l grammars decided effectively result contrasts known undecidability result et0l structural equivalence b introduction contextfree type grammars g 1 g 2 said structurally equivalent corresponding syntax tree g 1 producing terminal word grammar g 2 syntax tree structure vice versa structure syntax tree leaflabeled tree obtained removing nonterminals labeling internal nodes importance notion structural equivalence contextfree grammars due fact decided effectively 12 14 18 whereas language equivalence undecidable work supported natural sciences engineering research council canada grants ogp0041630 ogp0147224 department computing information science queens university kingston ontario k7l 3n6 canada email ksalomaacsqueensuca z department computer science university western ontario london ontario n6a 5b7 canada email syucsduwoca structural equivalence remains decidable also parallel contextfree e0l grammars 15 16 17 25 surprisingly shown 23 parallel derivations controlled finite set tables et0l grammar structural equivalence undecidable cannot even decide whether e0l grammar et0l grammar two tables structurally equivalent show structural equivalence becomes decidable tables grammars restricted homomorphisms edt0l grammars thus structural equivalence problem cross borderline undecidable decidable restricting tables grammar homomorphisms proof uses automata theoretic methods differs considerably automata theoretic decidability proofs e0l structural equivalence 25 et0l strong structural equivalence 10 e0l structure trees well et0l structure trees augmented information controlsequence used recognized deterministically bottomup using tree automaton model equivalence decidable appears possible edt0l structure trees since arbitrary choice sequence tables makes derivation inherently nondeterministic reduce edt0l structural equivalence emptiness problem tree pushdown automata guessarian 8 automata recognize exactly contextfree tree languages emptiness decided algorithmically show given edt0l grammars g 1 g 2 tree pushdown automaton verify nondeterministically guessed structure tree g 1 correspond valid derivation g 2 decidability proof relies strongly nondeterminism actual algorithm following proof requires multiple exponential time seen easily edt0l structural equivalence pspacehard one cannot expect find efficient algorithm shown 24 e0l structural equivalence hard deterministic exponential time edt0l case obtained exponential time lower bound preliminaries assume reader familiar basics formal language theory 29 briefly recall definitions concerning parallel contextfree type grammars tree automata information regarding parallel grammars interested reader asked consult 21 regarding tree automata refer reader 5 6 cardinality finite set denoted power set sometimes identify singleton set fag sets positive nonnegative integers denoted respectively 0 set nonempty finite words denotes empty word length w 2 jwj let finite sets define mappings pi 1 setting tree domain 6 nonempty finite subset satisfies following two conditions u 2 every prefix u ii every u 2 exists rank u 2 0 ui 2 0 node u successors alabeled tree mapping domt gamma domt tree domain node u 2 domt said labeled tu 2 node v successor respectively immediate successor assume notions height root leaf internal node subtree tree known height denoted hgt use convention height onenode tree zero subtree node u tu level node u 2 domt mean distance u root ie juj clearly maximal level node hgt tree said balanced leaf nodes level set level k subtrees sub k 0 k hgt defined note sub k set trees opposed set occurrences subtrees thus sub k contains one copy tree 0 occurs subtree defined level k node also ftg decidability proof use topdown tree pushdown automaton model guessarian 8 give brief informal description model sufficient purposes interested reader find formal algebraic definition 6 8 tree pushdown automaton extension finite tree automaton copy finitestate control access auxiliary pushdown store automaton begins computation root input tree given initial state q 0 initial symbol pushdown store state q node u labeled b input tree z topmost stack symbol depending tuple q b z either change internal state pop z stack ii change state push symbol stack iii go immediate successor nodes u states q sending nodes copy pushdown stack node u assumed rank automaton accepts input tree nondeterministic reaches leaves accepting state tree language recognized denoted general automata 8 employ tree structure stack automaton model described called restricted tree pushdown automaton 8 restricted general tree pushdown automata recognize exactly family contextfree tree languages 3 4 6 20 given contextfree tree language terms tree pushdown automaton contextfree tree grammar effectively construct indexed grammar generates yield since emptiness decidable indexed grammars 1 2 following result proposition 21 decide effectively whether tree language recognized given tree pushdown automaton empty 3 structural equivalence recall invent notations concerning parallel contextfree grammars 21 structure trees derivations 23 24 et0l grammar g tuple 1 v finite alphabet nonterminals sigma finite alphabet terminals initial nonterminal h finite set tables table h 2 h finite set rewrite rules allow rewriting terminals grammar g edt0l deterministic et0l grammar every table h 2 h contains exactly one rule left side nonterminal 2 v thus h morphism v gamma v sigma ha denotes right side rule h nonterminal left side grammar g e0l contains one table grammar said propagating right side production empty word ie h 2 h paper dealing mainly structure trees edt0l derivations define structure trees arbitrary et0l grammars since definition essentially simpler deterministic case remainder section g always et0l grammar 1 let fg denote set v sigma trees new symbol used label nodes corresponding empty word define parallel derivation relation g par union relations par defined follows let obtained 1 follows assume 1 leaves note leaf 1 labeled terminal derivation cannot continued 1 choose rule 2 2 node u k successors labeled respectively symbols 1 2 node u one successor labeled symbol 1 u leaf 2 denote 0 singleton tree node labeled initial nonterminal 0 set syntax trees sg g defined syntax tree 2 sg terminal leaves labeled elements sigma set terminal syntax trees g denoted tsg case g edt0l grammar rule 2 determined uniquely table h call words alphabet h controlsequences given edt0l grammar g controlsequence g syntax tree obtained initial nonterminal applying sequence tables specified thus g unique tree tree 3 exists otherwise g undefined g propagating every syntax tree g paths root leaf length ie balanced nonpropagating grammars paths root leaf labeled element v sigma length note definition allow rewriting terminal symbols ie assume grammars synchronized 21 restriction since arbitrary edt0l grammar easily transformed synchronized edt0l grammar way transformation preserves structural equivalence grammars transformation e0l grammars explained 15 obtained catenating natural lefttoright order leaves labels leaves yield syntax tree defined morphism defined setting e e syntax tree yieldt sentential form generated g derivation corresponding language lg generated g consists terminal words generated g ie clearly definition equivalent standard definition language generated edt0l grammar 21 structure syntax tree 2 sg strt tree obtained relabeling internal node oe oe new symbol v sigma denote elements stsg called terminal structure trees g g known sometimes speak simply sigmastructure trees since leaves labeled elements sigma note rules g determine maximal number immediate successors node structure tree g thus course alphabet sigma determine set sigmastructure trees grammars g 1 g 2 said language equivalent lg 1 well known language equivalence undecidable already contextfree grammars shall consider following two restricted notions equivalence let g 1 g 2 et0l grammars grammars g 1 g 2 ffl structurally equivalent stsg 1 ffl syntax equivalent equal modulo renaming nonterminals note syntax equivalence implies structural equivalence structurally equivalent grammars turn always language equivalent syntax equivalence incomparable notion strong structural equivalence 10 et0l grammars syntax structural equivalence decidable contextfree e0l grammars 7 12 14 15 18 25 formally defined notions sequential contextfree grammars definitions analogous parallel case syntax equivalence strong structural equivalence decidable also et0l grammars et0l structural equivalence undecidable 10 23 consider structural equivalence problem deterministic et0l grammars 4 main result show edt0l structural equivalence decided effectively first introduce notations concerning width trees intuitively structure tree said width distinct subtrees level definition 41 set sigmastructure trees said subtreewidth 2 distinct subtrees level k ie definition note sub k j set sigma foeglabeled trees ie elements consist occurrences subtrees j note also subtreewidth need minimal number distinct subtrees given level ie width 0 0 code structure arbitrary derivation edt0l grammar g 1 string using string encoding stack tree pushdown automaton verify one computation controlsequence another grammar g 2 generates structure tree construction relies essentially fact failure edt0l derivation respect given control sequence checked following one nondeterministically chosen path tree lemma 41 let edt0l grammar exists 2 every controlsequence 2 h structure tree strg width proof since tables h homomorphisms follows always nodes domg length labeled nonterminal gu choosing strg width 2 structure trees constant subtreewidth coded strings ith symbol left codes information level subtrees direct descendants level nodes ith symbol also codes order occurrences level subtrees number distinct level subtrees bounded constant furthermore need consider constant number level nodes correspond pairwise different subtrees define described coding structure trees subtreewidth prove regularity property codings lemma 43 propagating edt0l grammars restriction propagating grammars done avoid unnecessarily complicated notations afterwards explain result straightforwardly extended grammars allowing erasing productions definition 42 let propagating edt0l grammar let 2 define setomegagamma consist tuples mapping j every element occurs tuple j set final f defined consist tuples mapping note sigma j set ordered jtuples elements sigma set strings length j sequence w omegagamma said wellformed consider stuple structure trees denotes structure tree level one subtrees left right standard algebraic notation trees allow symbol oe variable arity corresponding wellformed sequence w 7 define inductively 11 tuple sigmastructure trees xiw say wellformed sequence w represents xiw first final represents 1 tuple structure trees inductive definition denote w 0 suffix w obtained deleting first symbol assume note since w wellformed denote 1 example 41 let tree given figure 1 choose c c c c c c c c b b b b oe oe oe oe oe oe oe figure 1 following lemma proved using induction maximal height trees lemma 42 let 2 fixed let set sigmastructure trees subtreewidth max 1im exists wellformed sequence w 2 omegagamma 7 furthermore i1 cardinality set level word w 2 omegagamma omega f said simple first symbol w form 1 w simple wellformed xiw onetuple sigmastructure tree practice identify xiw immediate consequence lemma 42 corollary 41 every sigmastructure tree subtreewidth exists simple wellformed sequence w 2 omegagamma omega f xiw following lemma states given simple wellformed sequence w 2 omegagamma omega f controlsequence edt0l grammar g finite automaton determine whether lemma 43 let propagating edt0l grammar 2 let alphabets andomega f definition 42 denote l set words 2 omega f simple wellformed denote mappings pi simply pi 2 claim l regular language proof condition easily verified finite automaton hence sufficient show given 2 satisfying finite automaton verify whether ii holds note hold xipi 1 necessarily defined may denote ordered tuple trees set states initial state fs 0 g assume state u reading input symbol goes rejecting state rej construction follows possible condition hold assume goes accepting state acc also goes accepting state acc x 2 u reads rest input verifying holds remaining possibility x 2 u form case reading symbol goes state z sets z constructed follows x 2 u following add element set z j sets z nonempty satisfies condition 5 intuitively u consists elements v derivation g following morphisms read far second components input reaches nodes corresponding ith subtree representative say kth level xipi 1 thus condition 8 holds derivation reaches level k node u xipi 1 symbol 2 v number immediate successors u equal jhaj condition contains terminal symbol thus derivation using next table h cannot structure xipi 1 condition ii holds case conditions 8 9 hold corresponds situation parallel derivation step determined h level k immediately violate structure tree sets z constructed consist respectively nonterminals appear 2 subtree representatives following level remains define operation reaches final symbol h state u following idea done accepts exactly derivation step h produces leaf representative b 2 sigma wrong terminal symbol nonterminal possibility corresponds situation hold need consider possibility derivation step h produces correct terminal symbols leaves means ii hold rejects hand enters accepting state x 2 u lemma 43 formulated proved propagating grammars however exactly proof works also general edt0l grammars possibility erasing productions adds one subtree representative level structure tree modify definition 42 symbols 4 partial function undefined represents node immediate successor cases defined new symbol belonging g proof lemma 43 simply modified dividing conditions 8 9 cases depending whether defined thus prove following lemma 44 statement lemma 43 holds without assumption g propagating show tree pushdown automaton single computation verify whether possible derivations given edt0l grammar violate given structure tree constant width lemma 45 let g edt0l grammars let constant guaranteed g 1 lemma 41 effectively construct tree pushdown automaton exists width proof denote k tree pushdown automaton receives inputs trees internal node exactly k immediate successors internal nodes labeled symbol 0 set stack symbols omegagamma assume automaton accepts balanced kary input tree beginning computation nondeterministically pushes stack word ff top stack left intuitively stack contents guessed omega f simple wellformed satisfies following property denote 11 corollary 41 exists w satisfying 12 reading input symbol always pops topmost stack symbol remaining stack contents forwarded k successor nodes initial nondeterministic guesses push symbols stack states consist two components operate parallel first component verifies condition 12 holds proof lemma 44 see done using finitestate memory first component operates identically paths input tree ignores input symbols treats initial stack contents input path leaf input 1 second component verifies proof lemma 44 follows possible using finitestate control second component ignores second components h stack symbols hence different paths input verifies xiw structure syntax tree controlsequence 0 length verifies xiw 62 stsg 2 hand branch computation consume entire stack accepted input tree necessarily balanced thus accepts input tree exists tree 10 holds subtreewidth 2 note proof lemma 45 essential guessed instance 2 stsg 1 pushdown stack string encoding although general tree pushdown automaton model 8 allows fact trees also stack shown tree pushdown automaton cannot nondeterministically push balanced tree arbitrary height stack 22 one could directly store arbitrary 2 stsg 1 tree stack beginning computation furthermore simulating derivations g 2 given different controlsequences directly tree would following problem paths leading failure derivation g 2 may branch earlier corresponding controlsequences branch input tree specifically tree pushdown automaton find controlsequence g 2 least one path leads failure controlsequences correspond different paths input general possible two controlsequences long common prefix whereas corresponding paths branch already root situations like cause problems string encoding xiw pushdown stack simulate paths input distinct subderivations g 2 within structure combining lemmas 41 45 proposition 21 proved following result note constant lemma 41 independent controlsequence chosen theorem 41 given edt0l grammars g 1 g 2 decide effectively whether exactly proof lemma 45 given edt0l grammars g 1 g 2 nonemptiness reduced deciding whether tree pushdown automaton recognizes nonempty tree language since number nonterminals g 1 g 2 finite new proof decidability syntax equivalence result follows also 23 theorem 42 syntax equivalence decidable edt0l grammars 2 5 discussion open problems decidability results syntax equivalence structural equivalence strong structural equivalence edt0l grammars summarized table 1 table stands decidable u undecidable decidability strong structural equivalence et0l grammars proved 10 e0l grammars notion coincides structural equivalence language equivalence naturally undecidable cases note e0l edt0l language families incomparable syntax equiv structural equiv strong struct equiv e0l edt0l et0l u table 1 decidability syntax strong structural equivalence proof theorem 41 gives multiple exponential time algorithm edt0l structural equivalence know exact complexity problem deterministic exponential time hardness result obtained 24 e0l structural equivalence cannot used least directly prove similar lower bound complexity edt0l structural equiva lence hand cannot expect obtain efficient algorithm edt0l case since known already structural equivalence problem linear grammars pspacecomplete 9 structural equivalence linear grammars easily logspace reducible edt0l structural equivalence note sentential forms one nonterminal constant number occurrences nonterminals edt0l grammar simulate contextfree derivation simply different table rule intuitively decidability proof previous section relies following two properties edt0l derivations current nonterminal remaining controlsequence determine uniquely subderivation ii controlsequences generate structure tree one level time properties enabled us produce string encoding w structure tree failure possible controlsequences produce structure verified finite automaton reads w controlsequence parallel necessity conditions ii illustrated considering indian parallel grammars ip grammar contextfree grammar derivation relation defined derivation step one rewrites occurrences one nondeterministically chosen nonterminal b given sentential form using rule left side b nonterminals rewritten formal definition reader may consult 2 19 26 27 well known languages generated ip grammars strictly included edt0l languages sequence rules used derivation ip grammar viewed control sequence ip grammars clearly property however different sequences rules generate distinct parts given structure tree completely different order analogy condition ii seems hold ip grammars thus spite fact edt0l grammars strictly powerful ip grammars terms family generated languages appear possible use proof method previous section decide structural equivalence problem ip grammars conjecture ip structural equivalence decidable e0lip grammars 11 structural equivalence shown decidable exactly proof theorem 41 e0lip grammars combine indian parallel e0l rewriting mechanisms derivation step occurrences every nonterminal rewritten using rule russian parallel rp grammars 2 13 28 extend ip grammars allowing also sequential contextfree derivation steps decidability rp structural equivalence problem remains open r extension contextfree case regulated rewriting formal language theory io oi grammars macrolike productions tree automata akademiai kiado handbook formal languages system sci pushdown tree automata strong equivalence et0l grammars study parallel rewriting systems characterization parenthesis languages grammars global productions russian normal form structurally equivalent e0l grammars defining families trees e0l grammars simplifications e0l grammars classifications indian parallel languages mappings grammars trees mathematical theory l systems academic press deterministic tree pushdown automata monadic tree rewriting systems complexity e0l structural equivalence decidability structural equivalence e0l grammars parallel contextfree languages parallel contextfree languages decomposition theorems various kinds languages parallel nature theory computation john wiley tr deterministic tree pushdown automata monadic tree rewriting systems classifications indian parallel languages decidability structural equivalence eol grammars defining families trees e0l grammars tree languages parenthesis grammars theory computation regulated rewriting formal language theory mathematical theory l systems structural equivalences et0l grammars extended abstract
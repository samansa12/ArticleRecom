controlled experiment assess benefits procedure argument type checking type checking considered important mechanism detecting programming errors especially interface errors report describes experiment assess defectdetection capabilities static intermodule type checking experiment uses ansi c kernighanritchie kr c relevant difference ansi c compiler checks module interfaces ie parameter lists calls external functions whereas kr c experiment employs counterbalanced design 40 subjects cs phd students writes two nontrivial programs interface complex library motif subject writes one program ansi c one kr c input compiler run saved manually analyzed defects results indicate delivered ansi c programs contain significantly fewer interface defects delivered kr c programs furthermore subjects gained familiarity interface using ansi c programmers remove defects faster productive measured delivery time functionality implemented b introduction notion data type important concept programming languages data type interpretation applied datum otherwise would sequence bits early fortran compilers already used type information generate efficient code expressions instance code produced operator depends types operands userdefined data types records classes later programming languages emphasize another aspect data types tool modeling data space problem domain thus types simplify programming program understanding benefit type checking compiler interpreter determine whether data item certain type permissible given context expression statement compiler detected defect program defectdetection capability type checking interest paper debate whether dynamic type checking preferable static type checking strict type checking whether explicitly declared types helpful implicit ones however seems overall benefits type checking virtually undisputed fact modern programming languages evolved elaborate type systems checking rules languages c typechecking rules even strengthened later versions furthermore type theory active area research 3 however seems benefits type checking largely taken granted based personal anecdotes instance wirth states 21 typechecking facilities oberon helpful evolving oberon system many programmers recall instances type checking could helped however could find single report controlled repeatable experiment testing benefits typing 9 costbenefit ratio type checking far clear type checking free requires effort behalf programmer providing type infor mation furthermore good arguments relying compiler type checking may counterproductive inspections 12 pp 263268 conclude actual costs benefits type checking largely unknown situation seems odds importance assigned con cept languages type checking widely used vast majority practicing programmers affected technique daytoday work purpose paper provide initial hard evidence effects type checking describe repeatable controlled experiment confirms positive effects first applied interfaces type checking reduced number defects remaining delivered programs second programmers use familiar interface type checking helped remove defects quickly increased productivity knowledge effects type checking useful least three ways first still lack useful scientific model programming process understanding types frequencies circumstances programmer errors important ingredient model second better understanding defect detection capabilities type checking may allow us improve finetune finally still many environments type checking missing incomplete confirmed positive effects type checking may help close gaps experiment analyze effects type checking programming interface subjects given programming tasks involve complex interface motif library one group subjects worked type checker without dependent variables follows completion time time taken receiving task delivering program functional units number complete correct functional units program functional unit interfaces library corresponds one statement gold program model solution interface use productivity measured functional units per hour completion time number interface defects number program defects applying library interface defect either argument missing many wrong type incorrect position use inappropriate function interface defect lifetime total time particular interface defect present solution de velopment note time may sum one time intervals since defect may first eliminated later reintroduced conjecture type checking makes type defect removal quicker reliable thus also speeding overall program development concretely attempt find support arguments following three hypotheses checking increases interface use productivity ffl hypothesis 2 type checking reduces number interface defects delivered programs ffl hypothesis 3 type checking reduces interface defect lifetimes related work aware two closely related studies one snickering type checking experiment 1 mesa language work compilergenerated error messages involving types diverted secret file programmer working compiler two different programs shown error messages finished programs asked estimate much time would saved seen messages right away interestingly programmer independently removed defects detected type checker claimed one program entirely work type checking would helped appreciably another program involved interfacing complicated library estimated type checking would saved half total development time obvious type study many flaws knowledge never repeated controlled setting different approach taken second experi ment performed gannon 9 experiment compares frequencies errors programs written statically typed typeless language subject writes program twice lan guage different order languages used half experiment group experiment finds typed group fewer distinct errors fewer error reoccurrences fewer compilation runs fewer errors remaining program 021 vs 064 average problem experiment significantly harder program typeless language task programmed involved strings typed language provided data type typeless language gannon reports difficulties encountered subjects actually due bittwiddling required lack typing relatively errors resulted uses data wrong type 9 p591 hence experiment tell us useful type checking research error defect classifica tion bearing experiment several publications describe analyze typical defects programs written novices eg 6 18 results necessarily relevant advanced pro grammers furthermore type errors play important role studies defect classification also performed larger scale software development settings eg 1 10 type checking explicit concern stud ies cases related information de rived instance basili perricone 1 report 39 percent defects 90000 line fortran project interface defects conjecture fraction could found type checking defectdetection capabilities testing methods 2 8 22 received attention corresponding psychological problems also investigated 20 also considerable literature debugging eg 7 13 16 17 psychology eg 17 19 however defects found testing debugging already passed type checks results studies would applicable focused defects detectable type checking several studies compared productivity effects different programming languages either used programmers little experience small programming tasks eg 6 somewhat larger tasks experienced programmers lacked proper experimental control eg 11 addition studies inherent problem confound many factors draw conclusions regarding type checking even languages provide type checking others appears cost benefits interface type checking yet studied systematically 3 design experiment idea behind experiment following let experienced programmers solve short modestly complex programming problems involving complex li brary control typecheckingnotype checking variable let every subject solve one problem kr c another ansi c save inputs compiler runs later defect analysis number observations regarding realism setup order short modestly complex task means difficulties observed stem using library solving task thus errors occur interfacing library effects type checking thought pronounced furthermore using complex library similar development module within larger project many imported interfaces must handled ensure results would confounded problems language used experienced programmers familiar programming language however programmers experience library another similarity realistic software development new modules often written within relatively foreign context essence used two independent variables two separate problems solved described two alternative treatments ansi c kr c ie type checking type checking balance learning effects sequence effects intersubject ability differences used counterbalanced design subject solve problems different language groups balanced respect order problem language giving total four experimental groups see table 1 subjects assigned groups randomly design also allows study third independent variable namely experience library first task subject previous experience second task experience first task present following subsections describe tasks sub jects experiment setup observed variables discuss internal external validity experi ment detailed information found technical report 15 31 tasks problem 2 theta 2 matrix inversion open window four text fields arranged 2 theta 2 pattern plus invert quit button see figure 1 quit exits program closes window fields represent matrix real values values entered edited invert button pressed replace values coefficients corresponding inverted matrix print error message matrix invertible formula problem b file browser open window menubar containing single menu menu entry select file opens fileselector box entry open table 1 tasks compilers assigned four groups subjects first problem first problem b problem b problem first ansi c group 1 group 2 kr c 8 subjects 11 subjects first kr c group 3 group 4 ansi c 8 subjects 7 subjects figure 1 problem 2 theta 2 matrix inversion selected file pops separate scrollable window displays contents file previously selected file selector box quit exits program closes windows see figure 2 figure 2 problem b file browser solving tasks subjects use native motif special wrapper library wrapper provides operations similar motif improved type checking instance functions fixedlength parameter lists motif often provides variablelength parameter lists checked wrapper also defines types resourcename con stants motif resources handled typelessly furthermore wrapper provides simplification additional convenience functions stance single function creating row columnmanager setting orientation packing mode motif requires several calls tasks although quite small trivial subjects understand several important concepts motif programming widget resource callback function furthermore learn use abstract documentation without example programs used examples felt would made programming tasks simple typically subjects took one two hours first task half time second 32 subjects total 40 unpaid volunteers participated study 6 removed sample one deleted protocol files one obviously inexperienced almost 10 times long others 4 worked one two problems mortality ab groups 88 subjects ba groups 117 subjects consider still sufficiently balanced 4 34 subjects following education 2 postdocs computer science cs 19 phd students cs completed ms degree cs another subject also cs phd student held ms physics 12 subjects cs graduate students bs cs subjects 4 19 years programming experience 11 written least 3000 lines c one least 300 lines 8 subjects programming experience xwindows motif 3 written 300 lines xwindows motif 33 setup subject received two written documents one instruction sheet left alone sun4 workstation solve two problems subjects told use roughly one hour per problem time limit enforced subjects could stop working even programs operational instruction sheet onepage description global steps involved experiment read sections 1 3 instruction document fill questionnaire section 2 initialize working environment typing make tc1 solve problem subjects obtained following mate rials paper files 1 halfpage introduction purpose ex periment 2 questionnaire background sub ject 3 specifications two tasks plus program skeleton 4 short introduction motif programming one page useful commands example search manuals online 5 manual listed first names types constants functions might required followed descriptions including signature semantic description several kinds crossreferences document also included introductions basic concepts motif xwindows manual hand tailored contain information required solve tasks hardly anything else 6 questionnaire experiment filled end subjects could also execute gold program task gold program solved task completely correctly used backup verbal specifications subjects told write programs duplicated behavior gold programs subjects write programs scratch instead given program skeleton contained necessary include commands variable function declarations initialization statements addition skeleton contained pseudocode describing step step statements inserted complete program subjects task find functions use arguments supply almost statements function calls following example pseudostatement skeleton register callbackfunction button pushed invert button number 1 client data implemented thus xtaddcallbackfinvert xmcactivatecallback button pushed xtpointer1 variations possible implementation pseudocode programming environment captured program versions submitted compilation along time stamp messages produced compiler linker time stamp start end work phase problem also written protocol file environment set call standard c compiler sunos 413 using command cc c g kr tasks version 270 gnu c compiler using gcc c g ansi pedantic wimplicit wreturntype ansi c tasks 34 dependent variables hypotheses 2 3 observed individual defect program introduced removed also divided defects nonoverlapping classes used following procedure experiment finished program version protocol files annotated hand different defect occurred programs identified given unique number instance call xtaddcallbackf shown 15 different defect numbers including 4 wrong argument types 4 wrong argument objects correct type another 7 specialized defects program version annotated defects introduced removed changed another defect additional annotations counted number type de fects semantic defects syntactic defects actually provoked one error messages compiler linker time stamps corrected work pauses lasted 10 minutes order capture pure programming time summary statistics computed defect classified one following categories ffl slight defects resulting slightly wrong functionality program minor programmer may feel need correct fore class also ignored order avoid artifacts results invis defects invisible ie compromise functionality unspecified properties library implementation changes library implementation may result misbehaving program example supplying integer constant pack column instead expected boolean value true works correctly long constant happens nonzero value rare class defects ignored invis defects hardly detected thus relevant experiment ffl invisd invis except defects detected ansi c parameter type checking kr c invis class excludes visd severe defects resulting significant deviations prescribed functionality ffl severed severe except defects detected ansi c parameter type checking kr c severe class excludes severed categories mutually exclusive defects removed program would pass even kr c compiler linker ignored unless otherwise noted defect statistics discussed computed based sum severe sev ered invisd metrics observed number compilation cycles versions time delivery ie time spent subjects delivering program whether complete correct metrics annotations additional statistics computed instance frequency defect insertion removal number attempts made defect finally removed interface defect lifetime number type defects remaining final program version see also definitions section 1 measuring productivity unimplemented func tionality define functionality unit fu single statement gold program example call xtaddcallbackf shown section 33 one fu using gold programs reference normalizes cases subjects produce one statement instead fus thus better measure program volume lines code gold program contains contains 11 annotated programs number gaps ie number missing fus fu counted missing subject made attempt implement 35 internal external validity following problems might threaten internal validity experiment ie correctness results 1 defects kr ansi c compiler produce error message messages might differ might influence productivity subjective judgment purposes experiment error messages compilers although sometimes quite different overall comparable quality furthermore none subjects experienced one particular compiler would understand messages faster others 2 may annotation errors insure consis tency annotations made per son annotations crosschecked first simple consistency checker looking whether errors introduced removed times plausible etc checked manually number annotation mistakes found manual check negligible 4 3 learning effect first second task might different kr subjects ansi c subjects problem related ones accounted counterbalanced experiment design following problems might limit external validity experiment ie generalizability results 1 subjects professional software en gineers however quite experienced programmers held degrees many ad vanced computer science 2 results may domain dependent objection cannot ruled experiment therefore repeated domains graphical user interfaces 3 results may may apply situations subjects familiar interfaces used question might also worth separate experiment despite problems believe scenario chosen experiment nevertheless similar many real situations respect typechecking errors another issue worth discussing learning effect performance change first task second task larger treatment effect performance change kr c ansi c would problem learning reduced treatment effect 16 pages 106 113 however see case treatment effect actually increased learning making experiment results conservative ones explicitly considering programmers highly familiar interface used therefore learning natural necessary part setting artifact improper subject selection 4 results discussion many statistics interest study clearly nonnormal distributions sometimes severe outliers therefore present medians precise interpolated 50 quantile rather arithmetic means median values zero higher quantiles given results shown tables 2 4 altogether ten different statistics appearing three main columns first column shows statistics tasks independent order second third columns reflect observations tasks tackled first second respectively columns used assess learning ef fect main column reports medians higher quantiles indicated tasks programmed ansi c kr c plus pvalue pvalue result wilcoxon rank sum test mann whitney u test roughly speaking represents probability given observations medians two samples equal p 005 test result considered statistically significant call distributions significantly different significant results marked boldface tables result significant nothing said may may difference 41 productivity table shows three measures describe overall time taken productivity exhibited subjects statistic 1 time delivery shows significant difference ansi c kr c first task tasks taken together ignoring programming language time spent second task shorter first p 00012 shown table indicating learning effect second task ansi c programs delivered significantly faster kr c programs plausible explanation started programmers good understanding library struggling concepts interface explanation confirmed studying compiler inputs type checking unlikely help gain better understanding type checks became useful programmers overcome initial learning hurdle statistic 2 number program versions compiled show significant difference ansi c programmers compile often kr c programmers describes productivity measured functional units per hour fuh contrast time de livery value accounts functionality implemented subjects find significant difference first task weakly significant difference second task ansi c median productivity 20 higher kr c productivity suggesting ansi c helpful programmers initial interface learning phase observation supports hypothesis 1 combined languages productivity rises significantly first task second task p 00001 shown table also reported subjects confirms strong learning effect induced sequence tasks actual distri ansi kr figure 3 boxplots productivity fuhour tasks ansi c left boxplot kr c right boxplot upper lower whiskers mark 95 5 quantiles upper lower edges box mark 75 25 quantiles dot marks 50 quantile median boxplots following structure ansi kr figure 4 boxplots productivity fuhour first task figure 5 boxplots productivity fuhour second task butions productivity measured fuh shown figures 3 5 see ansi c makes pronounced increase productivity first task second 78 median kr c 26 median table 2 overall productivity statistics medians statistics ansi c vs kr c versions programs pvalues statistical significance wilcoxon rank sum tests two values 005 indicate significant differences medians column pairs 1st2nd 1st 2nd problem tackled chronologically subject respectively entries include data points problem problem b tasks 1st task 2nd task statistic ansi kr ansi kr ansi kr 1 hours delivery 13 135 16 16 09 13 versions 15 3 fuh 86 97 72 85 128 107 table 3 statistics internals programming process see table 2 explanations tasks 1st task 2nd task statistic ansi kr ansi kr ansi kr 4 accumul interf dfct lifetime median 03 12 05 21 02 11 5 right wrong 75 quant 10 10 10 10 00 10 42 defect lifetimes table 3 gives insight programming process statistic 4 time introduction interface defect removal end experiment accumulated interface defects introduced subject distributions variable tasks also shown boxplots figure 6 accum severed error lifetime2610 ansi kr figure boxplots accumulated interface defect lifetime hours tasks see kr total defect lifetimes higher spread much wider range difference signifi cant note frequency defect insertion num ber interface defects inserted per hour shown table show significant differences languages indicating ansi c little help defect prevention opposed defect removal taken together two facts support hypothesis 3 ansi c helps remove interface defects quickly statistic 5 indicates number defects interface introduced previously correct repaired statements program hardly difference first task value significantly higher kr c second task speculate happens type error messages ansi c allow subjects avoid trial anderror defect removal techniques would used kr c effect occurs second task subjects gained basic understanding motif concepts 43 defects delivered programs table 4 describes quality products delivered subjects statistic 6 says unimplemented functionality units gaps kr c programs statistic 7 confirms defects delivered kr c programs ansi c pro grams see also distribution shown figure 7 difference much pronounced second task though reason probably advantages ansi c become fully relevant initial problems mastered statistics 8 10 confirm reason difference lies indeed type checking capabilities ansi c rare invisd defects statistic 8 severed defects statistic 10 see also figure 8 much less frequent delivered ansi c programs kr c programs defects detected ansi c type checking hand severe defects statistic 9 see also figure 9 frequent delivered ansi c programs kr c programs defects cannot detected type checking see boxplots distributions severe table 4 statistics delivered program see table 2 explanations lines 6 8 list medians quantiles instead indicated tasks 1st task 2nd task statistic ansi kr ansi kr ansi kr 6 gaps 75 quantile 025 7 remaining errs delivered program 10 20 10 20 10 20 9 severe 10 10 10 00 10 10 remaining errors figure 7 boxplots total number remaining defects delivered programs tasks severed remaining errors ansi kr figure 8 boxplots number remaining severed defects delivered programs tasks defects differ upper tail whereas distributions severed defects differ dramatically favor ansi c resulting significant overall advantage ansi c observations support hypothesis 2 severe remaining errors ansi kr figure 9 boxplots number remaining severe defects delivered programs tasks detailed analysis defects remaining delivered programs indicates slight statistically significant tendency besides type defects classes frequent defects also reduced ansi c programs using wrong variable parameter assignment target using wrong constant value parameter p 035 unknown whether systematic sideeffect type checking explained significant differences two tasks results hardly change one considers tasks b separately 44 questionnaire results finally subjective impressions subjects reported questionnaires follows 26 subjects 79 noted learning effect first program second 9 subjects 27 reported found ansi c type checking helpful 11 33 found considerably helpful 4 12 found almost helpful 5 15 found helpful subjects could decide 1 questionnaire lost 5 conclusions work experiment results allow following statements regarding hypotheses ffl hypothesis 1 interface use productivity programming interface type checking increases productivity provided programmer gained basic understanding interface ffl hypothesis 2 interface defects delivered program type checking reduces number interface defects delivered programs ffl hypothesis 3 interface defect lifetime type checking reduces time defects stay program development one must careful generalizing results study situations instance experiment unsuitable determining proportion interface defects overall mix defects designed prevent errors interface errors hence unclear large differences defect classes declaration defects initialization defects algorithmic defects controlflow defects included nevertheless experiment suggests many realistic programming tasks type checking interfaces improves productivity program quality fur thermore resources otherwise expended inspecting interfaces might allocated tasks corollary library design strive maximize typecheckability interfaces introducing new types instead using standard types appropriate instance motif experiment library based negative example respect work repeat similar error defect analyses different settings eg tasks complex data flow objectoriented languages particu lar would interesting compare productivity error rates compiletime type checking runtime type checking type inference important questions concern influence disciplined programming process personal software process 12 finally analysis errors occurring practice might help devise effective defect detection mechanisms acknowledgments thank paul lukowicz patiently guineapigging experimental setup dennis goldenson detailed comments early draft larry votta pointing important reference providing many suggestions report last least thank subjects solution problem program ansi c version represents canonical solution problem including comments given subjects start insert statements marked fu 1 etc places previously held pseudocode comments described section 33 numbers fu comments count functional units defined section 1 include stdioh include stdlibh include stdmotifh void buttonpushed widget widget xtpointer clientdata xtpointer calldata fields matrix coefficients 0123 abcd int main argc argv int argc char argv manager manager square buttons square manager 4 textfields buttons manager 2 pushbuttons quit pushbutton xtappcontext app xmstring invertlabel quitlabel 1 initialize x motif already complete changed globalinitialize argc argv fallbacks null 2 create configure widgets 2 false fu 1 2 true fu 2 buttons xmstringcreatelocalized invert matrix xmstringcreatelocalized quit 3 register callback functions invert xmcactivatecallback buttonpushed 4 realize widgets turn control x event loop already complete changed xtrealizewidget toplevel return 0 functions void buttonpushed widget widget xtpointer clientdata xtpointer calldata callback function called clicking pushbuttons occurs double mat4 new4 old new matrix coefficients det determinant string intclientdata 99 exit 0 fu 12 else intclientdata 1 int xtgetstringvalue mwi xmcvalue fu 13 det xtsetstringvalue mwi xmcvalue ftoanewi82 fu 15 else matrixerrormessagematrix cannot invertedmat82fu 16 solution problem b see description appendix include stdioh include stdlibh include stdmotifh void handlemenu widget widget xtpointer clientdata xtpointer calldata int main int argc char argv menubar oneentry menu bar menu pulldown menu label label displayed work window xtappcontext app 1 initialize x motif already complete changed globalinitialize b argc argv fallbacks null 2 create configure widgets xmstringcreate file browser large f fu 2 xmstringcreate lutz prechelt small fu 3 xtsetwidgetvalue mainw xmcworkwindow label fu 4 xmstringcreatelocalized select file f xmstringcreatelocalized open selected file xmstringcreatelocalized quit q 3 register callback functions handlemenu already registered nothing done 4 realize widgets turn control x event loop already complete changed xtrealizewidget toplevel return 0 functions void handlemenu widget widget xtpointer clientdata xtpointer calldata intclientdata first menu entry selected xtmanagechild fs fu 8 else intclientdata 1 second menu entry selected toplevel 25 80 fu 9 xtsetstringvalue scrolltext xmcvalue readwholefile selectedfile fu 10 else intclientdata 2 third menu entry selected exit 0 fu 11 r software errors complexity empirical investigation software testing techniques typing objectoriented languages achieving expressibility safety experimental methodology spohrer editors empirical studies program mers fifth workshop novice programmer errors language constructs plan composition tales debugging front lines experimental comparison effectiveness branch testing data flow testing experimental evaluation data type conventions practical results measuring software quality haskell vs ada vs c discipline software engi neering analysis online debugging process empirical studies program mers second workshop controlled experiment measuring impact procedure argument type checking programmer productiv ity psychological study program ming empirical studies programmers analyzing high frequency bugs novice programs cognitive bias software engineering positive test bias software testing professionals whats right whats wrong gedanken zur software explosion certification software components tr ctr maurizio morisio daniele romano ioannis stamelos quality productivity learning frameworkbased development exploratory case study ieee transactions software engineering v28 n9 p876888 september 2002 adrian birka michael ernst practical type system language reference immutability acm sigplan notices v39 n10 october 2004 matthew tschantz michael ernst javari adding reference immutability java acm sigplan notices v40 n10 october 2005 robin abraham martin erwig type inference spreadsheets proceedings 8th acm sigplan symposium principles practice declarative programming july 1012 2006 venice italy martin erwig deling ren update calculus expressing typesafe program updates science computer programming v67 n23 p199222 july 2007 andreas zendler preliminary software engineering theory investigated published experiments empirical software engineering v6 n2 p161180 june 2001
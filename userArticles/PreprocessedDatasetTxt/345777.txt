reducibility completeness private computations define notions reducibility completeness twoparty multiparty private computations let g nargument function say function f reducible function g n honestbutcurious players compute function f nprivately given black box g secretly give inputs get result operating g inputs say g complete private computations every function f reducible gin paper characterize complete boolean functions show boolean function g complete g cannot computed nprivately black box available namely nargument boolean functions notions completeness nprivacy complementary characterization provides huge collection complete functions nonprivate boolean function compared examples given implicitly previous work hand nonboolean functions show two notions complementary b introduction consider two party multiparty private computations quite informally given arbitrary n argument function f tprivate protocol allow n players possessing individual secret input satisfy simultaneously following two constraints 1 correctness players learn value f 2 privacy set faulty players learns initial inputs players implicitly revealed f output problem also known secure computation examined literature two substantially different types faulty players malicious ie byzantine players honestbutcurious players discuss known results respect two types players secure computation malicious players malicious players may deviate prescribed protocol arbitrary manner order violate correctness privacy constraints first paper based completely covers two conference papers 1991 paper kilian k91 1994 paper kushilevitz micali ostrovsky kmo94 nec research institute new jersey email joeresearchnjneccom z department computer science technion research supported e j bishop research fund fund promotion research technion part research done author aiken computation lab harvard university supported research contracts onrn0001491j1981 nsfccr9007677 email eyalkcstechnionacil x laboratory computer science mit supported nsf grant ccr9121466 bell communication research mcc1c365b 445 south street morristown new jersey 079606438 email rafailbellcorecom honestbutcurious players malicious players computational model yao82 gmw87 assuming trapdoor permutations privatechannels model figure 1 number faulty players tolerable basic secure computation models general protocols secure computation given yao82 yao86 twoparty case gmw87 multiparty case solutions given eg ghy87 gv87 bgw88 ccd88 bb89 rb89 ckor97 based various assumptions either intractability assumptions physical assumptions existence private untappable communication channels pair players solutions give tprivacy ndepending assumption made see figure 1 summary main results secure computation honestbutcurious players honestbutcurious players must always follow protocol precisely allowed gossip afterwards namely players may put together information possession end execution order infer additional information original individual inputs realized honestbutcurious model enforcing correctness constraint easy enforcing privacy constraint hard honestbut curious scenario interesting eg modeling security outside listeners passive adversary wants remain undetected importance also stems compiler type theorems one proved gmw87 1 extensions many subsequent papers example bgw88 ccd88 rb89 type theorems provide algorithms transforming tprivate protocol respect honestbutcurious players 0 private protocol respect malicious players 0 surprisingly much research efforts devoted complicated case malicious players case honest players far well understood paper examine latter setting information theoretic privacy 2 information theoretic model first examined bgw88 ccd88 particular prove every function dn2eprivate setting honestbut curious players see figure 1 information theoretic model subject considerable work eg cku89 bb89 cgk90 cgk92 cfgn96 kor96 hm97 bw98 particularly cku89 characterized boolean functions nprivate protocols exist nargument boolean function f nprivate represented f boolean namely f nprivate exclusiveor n local functions immediate corollary boolean functions nprivate even respect honestbutcurious players contribution formally define notion reducibility among multiparty protocol problems say f reducible g protocol allows n players compute value f 1 reader referred g98 fully detailed treatment yao82 gmw87 results 2 oppose computationalprivacy nprivately information theoretic sense repeatedly using blackbox trusted party computing g round protocol players secretly supply arguments blackbox blackbox publicly announces result operating g arguments stress means communication among players interacting blackbox ie evaluating g example clear every function reducible players secretly give private inputs blackbox announces result naturally also define notion completeness function g complete every function f reducible g importance notion relies following observation g complete g computed tprivately reasonable setting 3 settings gmw87 bgw88 etc function f computed tprivately setting moreover construction stronger result follows addition implementation g efficient implementation f see observation holds since definition reduction requires highest level privacy n strongest notion privacy information theoretic simple use g black box avoids making physical computational assumptions hence straightforward simulation invocation blackbox g replaced invocation tprivate protocol g works reasonable setting ie setting weak prevent simulation yields tprivate protocol f previously easy way translate protocols one model models yao82 gmw87 bgw88 ccd88 rb89 fkn94 models seen g complete g cannot nprivate inverse less obvious part since definition completeness requires function g used computing functions f since definition reductions seems restrictive may somewhat surprising complete functions exist examples complete functions implicitly appear literature without discussing notions reducibility completeness first results shown yao82 gmw87 k88 work prove existence complete functions nprivate computations moreover previous research concentrated finding single complete function main theorem characterizes boolean functions complete main theorem n 2 nargument boolean function g complete g nprivate result thus shows strong dichotomy every boolean function g either simple enough computed nprivately information theoretic model sufficiently expressive blackbox enables computing function boolean nprivately ie g complete stress restriction g beside nonnprivate boolean function relation function g function f wish compute assumed note using characterization cku89 easy determine whether given boolean function g complete boolean function g complete cannot represented g boolean features result prove completeness function g present appropriate construction following additional properties ffl consider interesting scenario reduced function f function g nargument functions n number players enables us organize reduction rounds round player submits value single argument g value 3 setting consists defining type communication type privacy assumptions made etc argument supplied exactly one player 4 thus player excluded round evaluation g results however remain true even number arguments g different number arguments f ffl construction evaluates nargument function g constant number ntuples hence partial implementation g may sufficient ffl talk privacy put computational restrictions power players hence get informationtheoretic privacy however talk protocols measure efficiency terms computational complexity f ie size circuit computes f terms parameter k protocol allows error probability 2 gammaomegagamma protocol introduce efficient polynomial measures 5 stress though ntuples use function g chosen nonuniformly namely encoded protocol particular choices g n size network ntuples depend though neither size inputs protocol function f main theorem gives full characterization boolean functions g complete nprivate nonboolean functions considered turns simple characterization longer true show nonboolean functions nprivate yet complete overview proof proof goes along following lines 1 define notion embeddedor twoargument functions appropriately generalize notion case nargument functions show nargument function private contains embeddedor case immediately characterization cku89 case n 2 requires additional technical work 2 show embeddedor used implement oblivious transfer ot channelprimitive 6 emphasized ot channel multiparty setting additional requirement listeners get information prove however property already implied basic properties twoparty ot finally follows work ghy87 gv87 k88 bg89 gl90 nprivate computation function f implemented given ot channels together main theorem follows organization paper section 2 specify model provide necessary definitions section 3 prove main lemma shows existence embeddedor every non n private boolean function section 4 use main lemma ie existence embeddedor implement ot channels players section 5 use construction ot channels prove main theorem finally section 6 contains discussion results open problems completeness include appendix known protocol private computations using ot channels including formal proof player submits argument permutation specified reduction evaluating g assignment assumed take unit time operations communication computation steps etc measured regular way 6 oblivious transfer protocol two players sender holds two bit b0 b1 receiver holds selection bit end protocol receiver gets bit bs information value bit sender information model definitions let f nargument function defined finite domain consider collection n 2 synchronous computationally unbounded players communicate using blackbox g described beginning execution player p input x 2 addition player flip unbiased independent random coins denote r string random bits flipped p sometimes refer string r random input p players wish compute value function fx 1 end use prescribed protocol f ith round protocol every processor p j secretly sends message j blackbox g 7 protocol f specifies argument blackbox provided player blackbox publicly announces result evaluating function g input messages formally round protocol associates permutation value computed blackbox round denoted message sent p j blackbox ith round determined input output blackbox previous rounds say protocol f computes function f last value last sequence values case nonboolean f announced blackbox equals value confidence parameter probability choice r let f nparty protocol described communication sx r concatenation messages announced blackbox executing f inputs x inputs often consider communication fixing x r case communication thought randomvariable r fixed chosen according corresponding probability distribution example set players variable describing communication player p holds input x player holds random input r random inputs players chosen randomly definition privacy considers distribution random variables f nparty protocol computes function f let ng set players coalition say coalition learn additional information execution f following holds every two input vectors x agree entries ie every choice random inputs coalitions parties fr g i2t every communication informally definition implies inputs look coalitions point view particular f value communication also look identically distributed therefore executing f coalition cannot infer information inputs follows inputs value function computing f using blackbox g tprivate coalition players learn additional information execution protocol function f tprivate respect blackbox g exists tprivate protocol uses blackbox g computes f nargument function say blackbox g alternatively function g complete every function f nprivate respect blackbox g 7 notice assume private pointtopoint communication among players hand allow private communication players blackbox computing g oblivious transfer protocol two players sender r receiver first defined rabin r81 since studied many works eg w83 fmr85 k88 il89 ovy91 variant ot protocol use often referred originally defined egl85 shown equivalent notions ot see example r81 egl85 bcr86 b86 c87 k88 ck88 formalization ot give terms probability distribution communication transcripts two players definition 4 oblivious transfer ot let k confidence parameter sender initially two bits b 0 b 1 receiver r selection bit c protocol completion following holds correctness receiver r gets value b c probability greater 1gamma2 gammaomegagamma probability taken cointosses r formally let r r r 2 f0 1g polyk random tapes r respectively denote communication string commfb one r r r unspecified comm becomes random variable k c b following holds pr r r r rc rc r r comm denotes output receiver r selection bit c random input r r communication protocol comm senders privacy receiver r get information b 1gammac words r view case b case b 1 formally k c b c 2 f0 1g r r communication comm pr r receivers privacy sender get information c words view case case c 1 formally k b r communication comm pr r r remark emphasize r honest curious assumed follow protocol ot defined respect cheating players usually allowed probability information leak however needed honest players 3 new characterization nprivate boolean functions section prove main lemma establishes new combinatorial characterization family nprivate boolean functions first define means twoargument boolean function embeddedor use cku89 claim twoargument boolean function 1private contains embeddedor generalize definition claim multiargument functions appropriate way definition 5 say twoargument function h contains embeddedor exist inputs output value oe hx 1 definition 6 say nargument n contains embeddedor exist jg twoargument function contains embeddedor following facts proven cku89 follow trivially 1 nargument boolean function dn2eprivate written fx 2 twoargument boolean function f 1private contains embeddedor 3 nargument boolean function dn2eprivate nprivate 4 nargument boolean function f dn2eprivate every partition indices ng two sets size dn2e twoargument boolean function f defined 1private main lemma extends fact 2 case multiargument functions boolean nargument function function g dn2eprivate contains embeddedor proof clearly g contains embeddedor partition indices fact 4 corresponding twoargument function g contains embeddedor eg indices guaranteed definition 6 include index index j partition indices arbitrarily two halves hence g 1private fact 4 g dn2eprivate direction since g dn2eprivate fact 4 partition indices ng g 1private simplicity notations assume n even n2g fact 2 twoargument function g contains embeddedor hence definition 5 exist inputs u v w z value oe 2 f0 1g form following structure u 6 v w 6 z complete proof show possible choose four inputs u 6 v exactly one coordinate w j 6 z j exactly one coordinate j show g satisfies condition definition 6 end first show based inputs find u 0 v 0 different exactly one coordinate based new u similar argument find w different exactly one coordinate process done way maintains orlike structure therefore using values j fixing arguments u 0 k arguments w 0 k get g contains embeddedor ng set indices u v disagree ie indices k u k 6 v k define following sets vectors tm set vectors obtained vector u replacing value u k exactly coordinates l v k 6 u k value v k particular fvg addition define following two sets vectors w z specific vectors choose particular claim must exist namely vector u 0 x 1 vector v 0 differ exactly one coordinate suppose towards contradiction true ie show implies tm x 1 contradicting fact v jlj belongs x 2 proof induction true contains u x 1 suppose induction hypothesis holds tm x 1 vector x tm1 vector tm differs x exactly one coordinate since assumed exist immediately implies x also x 1 hence tm1 x 1 needed therefore reached contradiction implies existence u found differ single index ie u 0 u still form orlike structure oe similar argument shows existence w differ single index j vectors form orlike structure oe shows g contains embeddedor indices required definition 6 2 constructing embedded oblivious transfer first simple observation given blackbox function g contains embedded actually compute two bits suppose n players wish compute bit held player p k b bit held player p let indices inputs guaranteed definitions 5 6 player p k provide black box ith argument x b k ie b argument provided p k x 0 b argument x 1 player p provide black box jth argument x b players provide fixed values arbitrary order blackbox answer value oe orb different oe orb hence showed compute main goal section show based blackbox compute implement oblivious transfer ot protocol start twoparty case proceed general case builds upon twoparty case 41 twoparty case section show implement twoparty ot protocol start implementing variant ot called random ot rot short different standard ot ie rot protocol sender bit sent end protocol receiver r gets bit 0 probability 12 bit 0 equals probability 12 bit 0 random receiver knows two cases happened sender idea case start formal definition rot primitive definition 7 random oblivious transfer rot let k confidence parameter sender initially single input bit receiver input protocol completion following holds correctness probability greater outputs pair bits referred indicator otherwise r outputs fail usual probability taken cointosses r ie r r r 2 f0 1g polyk moreover output r satisfies ie pr r r r senders privacy probability r outputs pair exactly 12 pr r r r receivers privacy sender get information words view case 0 case 1 formally k 2 f0 1g r communication comm pr r r comms r transformations rot protocols wellknown c87 8 rot protocol implemented follows 8 assume sender two bits b0 b1 receiver r selection bit c players r repeat following times time tries send r pair random bits s1 s2 using two invocations rot trials receiver gets actual bit trials gets random bit try another time receiver got exactly one s1 s2 sends sender permutation indices ie either 1 2 2 1 c known sender replies b1 phi receiver retrieve bit bc knows nothing bit sender observing learns nothing c since know invocation rot protocols invocation receiver got actual bit got random bit thus get protocol based rot protocol sender receiver r repeat following c chooses pair 1 2 two pairs f1 0 0 1g probability 12 r chooses pair b three pairs f1 0 0 1 1 1g probability 13 r compute using blackbox c b c r receiver r outputs outputs addition r outputs c times choices 1 2 b c protocol halts r outputs fail analyze protocol observe following properties 1 b happens two six choices 1 2 b four choices get c therefore probability failure exponentially small 2 conditioned case c four remaining cases b 3 case b 1 case r outputs 1 needed case b 1 1 two choices 1 2 equally likely therefore 1 hence also w 0 random ie value 0 probability 12 value 1 probability 12 case r outputs 0 needed 4 argued 3 protocol fail r knows correct value since knows values b sender hand based 1 2 cannot know two equallyprobable events b happened therefore sees view whether case 1 case 0 properties 1 3 imply correctness rot protocol properties 2 4 imply senders privacy receivers privacy respectively hence combining construction including transformation rot protocol lemma 2 otchannel two players realizable given blackbox g non2private function g 42 multiparty case n shown main lemma lemma 1 non nprivate function g contains embedded thus explained use blackbox g compute two bits held two players p k p players assist specifying fixed arguments given main lemma based ability compute showed section 41 two players implement ot channel way satisfies properties ot particular privacy sender receiver respect however subtle difficulty implementing private otchannel multiplayer system must address beside usual properties ot channel specified definition 4 guarantee information transmitted two owners channel revealed potential listeners ie players ot channel implemented physically clearly information revealed listeners however since implement ot using blackbox function g publicly announces outcomes must also prove reveals information listeners communication comm distributed way values b following lemma shows security ot protocol respect listeners fact already guaranteed basic properties ot protocol namely security protocol respect receiver sender lemma 3 consider twoplayer ot protocol every possible communication comm probability pr r r r values b 0 b 1 sender c receiver words listener sees probability distribution communications matter inputs held sender receiver ot protocol proof consider following 8 probabilities corresponding possible values b 1 pr r r r 2 pr r r r 3 pr r r r 4 pr r r r 5 pr r r r 7 pr r r r 8 pr r r r receivers privacy property implies terms 1 2 equal 3 4 equal 5 equal 7 8 equal senders privacy property implies terms 1 3 equal 5 7 equal 2 6 equal 4 8 equal together get 8 probabilities equal desired 2 5 completeness theorem multiparty boolean blackbox reduction section state main theorem provide proof based protocol tolerate honestbutcurious players assuming existence otchannel pair players protocols appear ghy87 gv87 k88 bg89 gl90 works deal also malicious players works get following lemma selfcontainment protocol proof security appear appendix lemma 4 given ot channels pair players nargument function f computed nprivately time polynomial size boolean circuit f ready state main theorem theorem 1 main let n 2 let g nargument boolean function function g complete nprivate proof first show complete g cannot nprivate towards contradiction let us assume exists function g nprivate complete implies functions nprivate instead using blackbox g players evaluate g using nprivate protocol g however contradicts results bgw88 cku89 show existence functions nprivate next bulk work show compute function nprivately given blackbox g nprivate recall exists protocol tolerate honestbutcurious players assuming existence otchannels lemma 4 also shown blackbox computing nonprivate function used simulate ot channels lemma 2 3 combining together get result 2 theorem implies boolean functions complete boolean function xorform cku89 complete 6 conclusions extensions 61 nonboolean functions shown nonnprivate boolean function g complete namely blackbox function g used computing function f nprivately finally let us briefly turn attention nonboolean functions first emphasize function g contains embeddedor still complete even nonboolean arguments go particular note definitions 5 6 embeddedor apply nonboolean case well nonboolean case state following proposition proposition 2 every n 2 exists nonboolean nargument function g nprivate yet g complete proof proof 2argument g follows nonprivate twoargument functions contain embedded examples functions shown ku89 see figure 2 show embeddedor one cannot compute function assume towards contradiction twoargument function f embeddedor yet could used compute function since f used compute function use implement ot lemma 2 hence exists implementation ot based f embeddedor however k91 shown twoargument functions ones contain embeddedor used implement ot deriving contradiction nargument functions notice define function g n arguments depend first two arguments back 2argument case resulting function nprivate 2 conclude shown boolean case notions completeness privacy exactly complementary nonboolean case figure 2 nonprivate function contain embeddedor 62 additional remarks section briefly discuss possible extensions easy generalizations results first issue address need protocol specify permutation used round mapping players arguments blackbox g note construction use blackbox computing function two arguments need map two players p k p holding two arguments special coordinates j guaranteed definition embeddedor therefore without loss generality sequence permutations made oblivious ie independent function f computed price 2 multiplicative factor rounds time moreover price 4 sequence permutations even made independent nonnprivate function g finally note g symmetric function often interesting case need permute inputs g next recall assumption number arguments g number arguments f ie n follows constructions essential results needed ability two players wish compute function certain step providing two distinguished arguments fixed arguments provided arbitrary players eg p 1 definitions require perfect privacy require two distributions definition 1 identical one relax definition privacy require statistical indistinguishability distributions computational indistinguishability distributions definitions refer reader papers mentioned introduction note f computed privately notions using blackbox g g computed tprivately notions also function f computed tprivately appropriate notion privacy ie weaker among two finally note negative result cku89 allows probability error hence even weaker notion reduction allows errors computing f change family complete functions impossibility result ie first direction main theorem still holds even allow players communicate using blackbox also using types communication point topoint communication channels 63 open questions results easily extended show boolean g complete also used private computation multioutput function f ie function whose output ntuple output given p lemma 4 still holds hand interesting question characterize multioutput functions g complete even boolean case output g f0 1g clear extend model results case malicious players full generality notice however appropriate definition model given blackbox twoargument function still implement private channels see kmo94 details hence bgw88 ccd88 implement f n3privately respect malicious players suppose relax notion privacy computationalprivacy yao82 gmw87 case computationally nprivate implementation informationtheoretically nonn private equivalently complete boolean function g implies existence oneway function since shown implementation g implies implementation ot turn implies existence oneway function il89 however best known implementation protocols function g requires trapdoor oneway permutations gmw87 important question whether exists implementation based oneway function permutation functions without trapdoor question partial answers particular one players superpolynomial power possible ovy91 however focus polynomialtime players protocols result paper together work ir89 implies complete functions use blackbox reductions difficult separating p np thus using blackbox reductions complete functions seem hard implement computational privacy without trapdoor property notice however nonboolean functions shown functions nprivate complete known even functions implemented without using trapdoor although results ir89 apply case acknowledgments wish thank oded goldreich helpful discussions useful com ments thank mihir bellare pointing us 1991 works chor kushilevitz kilian complementary thus imply special case general result finally thank amos beimel helpful comments r completeness theorems noncryptographic faulttolerant distributed computation applications oblivious transfer minimum disclosure proofs knowledge information theoretic reductions among disclosure problems multiparty computation faulty majority adaptively secure multiparty computation multiparty unconditionally secure protocols private computations integers structure privacy hierarchy equivalence two flavors oblivious transfer randomized protocol signing contracts minimal model secure computation cryptographic computation secure faulttolerant protocols publickey model secure multiparty computation play mental game solve protocol problem efficiency improvement fair computation general functions presence immoral majority knowledge complexity interactive proof systems complete characterization adversaries tolerable secure multiparty computation limitations certain oneway permutations basing cryptography oblivious transfer completeness theorem twoparty secure computation privacy communication complexity characterizing linear size circuits terms privacy amortizing randomness private multiparty computations reducibility completeness multiparty private computations randomnessrounds tradeoff private computation fair games allpowerful adversary verifiable secret sharing multiparty protocols honest jority exchange secrets oblivious transfer protocols secure computations tr ctr danny harnik moni naor omer reingold alon rosen completeness twoparty secure computation computational view proceedings thirtysixth annual acm symposium theory computing june 1316 2004 chicago il usa
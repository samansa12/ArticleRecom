real number computation gray code embedding propose embedding g unit open interval set 0 11 infinite sequences 0 1 one undefined element embedding based gray code topological embedding natural topology 0 11 also define machine called indeterministic multihead type 2 machine inputoutput sequences 0 11 show computability notion induced real functions embedding g equivalent one induced signed digit representation type 2 machines also show basic algorithms expressed naturally respect embedding b introduction one ways dening computability real function representing real number x innite sequence called name x dening computability function existence machine called type2 machine inputs outputs names oneway left right notion computability dates back turingtur36 basis eective analysis wei85wei00 notion computability depends choice representation use signed digit representation equivalent ones cauchy representation shrinking interval representation commonly used property every arbitrarily small rational interval including x obtained nite prex name x therefore induces computability notion function f computable machine output arbitrary good approximation information fx rational interval arbitrary good approximation information x rational interval given naturality computability notion also justied fact coincides de preprint submitted elsevier science 15 june 2000 ned many approaches grzegorczyks grz57 pourel richards per89 domain theoretic approacheses98 gia99 one properties representations injective wei00 precisely uncountably many real numbers innitely many names respect representations equivalent signed digit representation bh00 kind redundancy considered essential many approaches exact real arithmetic bcro86ep97gia96gia97vui90 thus computability real function dened two steps rst computability functions innite sequences dened using type2 machines connected computability real functions representations redundancy representations means cannot dene computability real function directly considering embedding real numbers set innite sequences type2 machine operates paper consider direct denition extending notion innite sequences modifying notion computation innite sequences embedding called gray code embedding based gray code expan sion another binary expansion real numbers target embedding set f0 1g 1 innite sequences f0 1g one means undenedness allowed dene embbeding g unit open interval explain extended whole real line nal section 1 natural topological structure subspace f0 show g topological embedding space f0 1g 1 existence machine cannot sequential access inputs outputs however appears deal putting two heads tape allowing indeterministic behavior machine call machine indeterministic multihead type 2 machine im2machine short indeterministic computation means many computational paths produce valid results she75bra98 thus dene computation using im2machines consider induced computational notion embedding g show computational notion equivalent one induced signed digit representation type2 machines also show basic algorithms like addition expressed represen tation one remarkable thing representation three recursive structures though characterized two recursive equations fact used composing basic recursive algorithms introduce gray code embedding section 2 im2 machine section 3 dene gray code computability real functions section 4 show equivalent computability induced signed digit representation type 2 machines section 5 section 6 study topological structure number binary code gray code 9 1001 1101 fig 1 binary code gray code integers section 7 8 consider basic algorithms respect embedding discuss embedding extended r give experimental implementations give conclusion section 9 notation let alphabet include write set nite sequences set innite sequences set innite sequences n instances undenedness character allowed exist x multivalued function x f subset x considered partial function x power set call number form 2 n integers n dyadic number gray code embedding gray code another binary encoding natural numbers figure 1 shows usual binary code gray code integers 0 15 way nbit gray code composed putting nth bit reversing order coding n 1bits instead repeating coding n1bits usual binary code importance code lies fact one bit diers encoding number successor code used many areas computer science image compression asd90 nding minimal digital circuits dew93 conversion two encodings easy gray code obtained usual binary code taking bitwise xor sequence onebit shift therefore function convert binary code gray code written using notation functional language haskell hj92 follows conv function type int int int haskell type possibly innite list integers ab means list composed head b tail xor exclusive dened xor 0 xor 0 xor 1 xor 1 zip function taking two lists length l returning list pairs length minl conversion injective inverse written empty list extend coding real numbers since function conv applicable innite lists obtain gray code expansion real number x applying conv binary expansion x gray code expansion real numbers unit interval 0 1 visualized figure 2 horizontal line means corresponding bit value 1 line value 0 otherwise gure ne fractal structure shows symmetricity bits greater n every dyadic number 2 n bit3 bit6fig 2 gray code real numbers usual binary expansion two expansions dyadic numbers example expressed 0110000 also 0101111 also case gray code expansion example applying conv sequences two sequences 0101000 0111000 however one nd two sequences dier one bit case 2nd means information number remaining bits 2nd bit contribute fact therefore would natural introduce character denoting undenedness consider sequence 011000 unique representation note sequence bit dier always 1000 thus dene gray code embedding modication gray code expansion dyadic number represented s1000 denition 1 gray code embedding unit open interval injective function g 1 maps x innite sequence 0 follows odd number holds even number integer call gx modied gray code expansion x simply gray code x 0 according x bigger equal less tail function maps x g 1 1 denotes socalled tent contrast binary expansion tail function binary expansion denotes function note gray code expansion coincides itinerary tent map essential symbolic dynamical systems hy84 3 indeterministic multihead type 2 machine consider calculating real number x 0 x 1 limit approximations output result modied gray code expansion precisely consider calculation produces shrinking intervals r successively lim n1 know x n write 0 rst digit know n write 1 however neither happen cannot ever write rst digit even know skip rst write 1 second digit know third digit thus continue producing digits skipping rst one write sequence second digit order produce gray code x result need rst cell impossible cannot obtain information nite time solve dene blank character output tape consider output tape lled beginning thus cell skipped lled eternally left suppose know written second digit 1 skipping rst one next output two possibilities write third digit 0 know write rst digit obtain information x therefore consider machine gray code output output tape written oneway left right present behavior simple way consider two oneway heads h 1 h 2 output tape move automatically output beginning h 1 h 2 located rst second cell respectively output h 2 h 2 moved next cell output h 1 h 1 moved position h 2 h 2 moved next cell thus order output tape hj h h 1 h 2 means output j h head movement rule cell lled cell lled eternally h 1 located cell output made solely h 2 sth tth cell output tape ith cells already output longer accessible therefore h 1 always located rst second unlled cells machine treats tape os next consider input modied gray code expansion real number dene input mechanism nite input contains approximation information therefore machine recognize cell head character preceding prex species number exactly requirement also supported way input tape lled produced output another machine character may overwritten 0 1 future impossible recognize particular cell left eternally therefore machine needs something usual sequential access solve consider multiple heads consider machine waits multiple cells lled since one cell left unlled two heads sucient purpose therefore consider two input tape move way output heads input characters note character cannot recognized machine unlike blank character used turing machine thus dene machine two heads inputoutput tape though explaind idea based modied gray code expansion machine inputoutput sequences 1 generally order give computational power turing machine consider state machine controlled set computational rules ordinary work tapes addition inputoutput tapes order machine continue working even cell h 1 input tape need time rule applicable reading h 1 h 2 therefore condition part rule include input h 1 h 2 also means head positions input tape lled may one applicable rules since machine may execute rules computational paths produce valid results summarize following denition denition 2 let inputoutput alphabet let worktape alphabet includes blank character b indeterministic multihead type 2 machine im2machine short k inputs composed following tapes named 1 one output tape named tape two heads ii several work tapes one head iii nite set q states one initial state q 0 2 q iv computational rules following form q q 0 states q j heads dierent input tapes head output tape w w 00 heads work tapes c j j c characters j 0 characters j j part rule optional may rule without oc example meaning rule state q characters heads c j e respectively change state q 0 write characters c 0 heads respectively move heads w 00 backward depending whether move heads inputoutput tapes follows head moved position h 2 h 2 moved next cell h 2 position h 1 left unchanged moved next cell machine starts output tape lled work tapes lled b state set q 0 heads work tapes located rst cell heads h 1 inputoutput tape located rst second cell respectively step machine chooses one applicable rule applies one rules applicable one selected nondeterministic way note 1 dene indeterministic multihead type 2 machine generally inputoutput tape may inputoutput sequences dene head movements inputoutput operation follows inputoutput made h l l n moved position h j1 h n1 moved next cell inputoutput made h n1 h n1 moved next cell note 0 nothing tape one head moves next cell inputoutput note 2 acted full contents input tapes given beginning however input usually generated output another machine given incrementally case machine behaves like repeats executing applicable rule rule applicable waits input tapes lled one rules become applicable repeats process indenitely note 3 machine dierent inputoutput types tapes putoutput types consider n n 0 may write 0 extend im2machine sequence indicating k input tapes type one output tape type 0 n corresponding tape properties written note 1 corresponding tape alphabet fbg one head moves next cell readswrites character case blank cells initialized b addition 0 consider machine halting state machine stops execution gray code computability real functions seen im2machine nondeterministic behavior thus many possible outputs input therefore consider im2machine computes multivalued function note multivalued functions appear naturally consider computation real numbers bra98 denition 3 im2machine k inputs realizes multivalued function 1 computational paths input tapes lled p outputs set outputs forms subset f p say f im2computable realized im2machine denition generalized multivalued function case note nondeterministic computation dierent nondeterminism used example nondeterministic turing machine nondeterministic turing machine accepts word one computational paths accepts word whereas computational paths produce valid results machine distin guish use word indeterminism instead nondeterminism following she75 bra98 denition 4 multivalued function f realized gf realized say f graycodecomputable g f g 1 im2 computable denition 5 partial function f k graycodecomputable computable multivalued function 5 equivalence computability induced signed digit repre sentation prove gray code computability equivalent computability induced type2 machine restricted signed digit representation denition 6 type2 machine im2machine whose type includes whose computational rule deterministic denition equivalent one wei00 proposition 1 let im2machine deterministic im2machine computes f proof part immediate part need construct deterministic machine indeterministic machine case inputoutput tapes one head suppose im2machine realizes f since set rules nite give numbering determine whether rule applicable input tapes character therefore modify construct deterministic machine 0 chooses rst applicable rule respect numbering result 0 uniquely determined f x denition 7 representation set x surjective partial function x representation x name x denition 8 representations say reducible 0 0 computable function f dom say 0 equivalent 0 0 0 denition 9 1 signed digit representation sd uses alphabet denoting 1 partial function sd dened j 6 1 l 6 1g returns 1 2 1 2 restricted signed digit representation sdr restriction sd smaller domain j 6 1 l 6 1g without rst character 1 1 sd 38 innitely many names domain sdr means use name lasts therefore 38 two sdr names proposition 2 sdr sd proof easy exercise give algorithm converts sd name sdr name denition representation multivalued function computable type2 machine type p 2 domf input p produces innite sequence q partial function computable computable multivalued function denition easily extended function several arguments equivalent representations induce computability notion explained introduction equivalence class signed digit representation belongs induces suitable notion computability real numbers proposition 3 let im2machine realizes multivalued function im2machines realize multivalued functions suppose imhg im2machine hn realizes multivalued function composition multivalued functions f g dened 2 proof first consider case write n n 1 use input tapes n n output tape n use work tape alphabet fbg connects parts representing n work tapes simulate head movements input tape output tape n easy change rules n reads n writes also need modify rules rst looks applicable rule coming rule looks rule coming n possible former rules access input tapes therefore machine determine whether particular rule applicable k 1 need copy input tapes onto work tapes shared parts representing n dene executes rules coming n outputs character switch next part show section 7 followings lemma 4 im2machine type f1 0 1g 1 converts sdr name x gx x 2 lemma 5 im2machine type f0 1g gx sdr name x x 2 prove equivalences theorem 6 multivalued function f k graycodecomputable proof suppose im2machine gray code computes f composing im2machines lemma 4 lemma 5 form proposition 3 im2machine type f1 0 outputs sdr name member f names x given therefore desired type2 machine proposition 1 hand suppose type2 machine sdr computes f since type2 machine special case im2machine composing im2machines lemma 4 lemma 5 form im2machine gray code computes f 6 topological properties 1g section show g 1 homeomorphic therefore topological embedding since character may overwritten 0 1 appropriate consider cantor topology 1 instead dene order structure 0 1 alphabet consider scott topology f0 consider product topology f0 subspace topology 1 let p denote set fx j p xg set f base f0 base f 1 note p corresponds states output tapes im2machines nite time execution 1 set possible outputs im2machine outputs 2 p thus q 2 open set 1 output q im2machine fact available nite time execution machine sense observation open sets nitely observable properties smy92 holds im2machine prove following fundamental theorem way type2 computability cantor topology f0 1g theorem 7 im2computable function f 1 continuous img set f0 1g f0 1g 1 also consider subspace topology img base f g consider inverse image base g 2 f0 1g range open intervals form respectively integers since open intervals form base unit open interval img become homeomorphic function g thus following theorem 8 gray code embedding g topological embedding 1 direct consequence following corollary 9 graycodecomputable function f k continuous application representation give simple proof theorem 426 says eective enumeration computable real numbers dene computable sequence im2machine outputs gx binary name given theorem computable sequence computable number x x exists im2machine computes binary name proposition 1 assume deterministic means selecting one machine order output tape lled xed since either 2i 2i 1 written nite time 2i written rst put rst put dened resulting sequence computable img equal 2 therefore g 1 equal x injectivity representation 7 conversion signed digit representation example im2machine consider conversions gray code restricted signed digit representation recall sdr name x 2 given sequence 1 xs xs innite sequence f0 1 1g section consider xs sdr name x since intervals represented nite prexes representation coincide conversions become simple automatonlike algorithms use work tapes example 1 conversion signed digit representation gray code type simply write head input tape four states initial state 12 rules order express simply use notation functional language haskell follows ds ds produces bindings c ds head tail stog0 xs01 respectively clear behavior im2machine expressed using notation state contents work tapes head positions passed additional arguments program stog0 states used invert output result stog0xs 1 0 stog0xs 0 0 rst character inverted result stog0xs 0 1 stog stog0 0 input tape output tape fig 3 behavior stog im2machine reads 0 stog0xs 0 0 second character inverted therefore simplify program follows ds c ds stog xs nh function invert rst element innite list sds behavior stog input 0xs given figure 1 small circle output head means invert output head lling tape program stog correct haskell program works haskell system however evaluate stog00 output tries calculate rst digit course tailstog00 produces answer 1000 next consider inverse conversion example gray code input example 2 conversion gray code signed digit representation show haskell program type f0 1g case indeterminism occurs yields many dierent valid results results actually signed digit representations number also correct haskell program however fails calculate example gtosstog00 program gtos rst two rules tries pattern match head argument starts nonterminating calculation therefore fails use third rule limitation use existing functional language discuss implement im2machine program section 9 programs based recursive structure gray code dicult write program one might imagine one see figure 2 following three recursive equations 1 p rst equation corresponds fact interval rst bit 0 ie left half figure 2 remaining bits form 1 2 reduction figure 2 second equation corresponds fact interval rst bit 1 ie right half figure 2 remaining bits rst bit inverted form 1 2 reduction figure 2 use equation parenthesis also state remaining bits form reversal figure 2 two equations characterize figure 2 one interesting fact representation also third equation says interval second bit 1 ie middle half figure 2 remaining bits second bit inverted form 1 2 reduction figure 2 equations 1 following recursive scheme g 1 function calculate fx f2x 0 x function calculate fx f2x 1 3 function calculate fx derived immediately scheme hand equations 1 rewritten follows stog uses scheme calculate gray code output recursive schemes used derive algorithm addition next section 8 simple algorithms gray code write algorithms respect gray code example 3 multiplication division 2 simple shifting operations suppose input 0 x 12 example 4 complement x 7 1 x simple operation invert rst digit iethe nh function example 1 note usual binary representation signed digit representation need invert bits calculate 1 x thus operation needs dened recursively also see complement operation x 7 k2 n x respect dyadic number k2 n1 implemented inverting one digit example 5 shifting x 7 x addition dyadic number nothing two continuous complement operations dyadic numbers case rst axis second axis therefore function addoneoftwo operates x 7 x example 6 addition consider addition xy 0 x 1 since result 0 2 consider average function pl 0as pl 1as pl 0as pl 1as pl a1as pl a10as pl a10as pl a10as pl a10as pl 00as pl 10as pl 0a1as pl 1a1as calculate sum respect signed digit representation need look ahead two characters also case gray code representation since redundancy reduce number rules 25 13 compared program written way signed digit representation 9 extension whole real line implementation conclusion dened embedding g f0 1g 1 based gray code introduced indeterministic multihead type 2 machine machine inputoutput sequences f0 1g 1 since g topological embedding f0 1g 1 im2 machines operating topological space includes subspace hope computational model propose new perspective real number computation paper treated unit open interval 0 1 discuss embedding extended whole real line r first using rst digit sign bit 1 positive 0 negative number zero extend interval 1 1 also extend assuming decimal point kth digit however seems direct extension real numbers without losing injectivity without losing simplicity algorithms section 7 8 one possibility use computable embedding r 1 1 function arctanx known function computable therefore im2machines convert signed digit representation x 2 r gray code fx 1 1 therefore dene new representation g 0 r clear representation embeds r 1 properties shown section 4 6 hold replace r g g 0 particular computability notion r induced g 0 im2machines equivalent one induced signed digit representation type2 machiens however lose symmetricity gray code expansion simplicity algorithms section 7 8 another possibility introduce character indicating decimal point sequence order allow expression starting ie integers need consider expression starting 0 allowed 0 1 afterwards thus lose injectivity expansion 1xs also kind diculty adopt oatingpointlike expression pair number indicating decimal point gray code 1 1 although expansion becomes redundant redundancy introduced preceding zeros limited need one zero beginning representation thus number two names shown bh00 need innitely many names innitely many real numbers use representations equivalent signed binary representation therefore redundancy need extension essentially smaller signed binary representation finally show experimental implementations currently noted though express behavior im2machine using syntax functional language haskell program comes dierent semantics usual lazy evaluation strategy implemented gray code inputoutput mechanism using logic programming languages written gtos stog addition function pl section 8 using kl1 uc90 concurrent logic programming language based guarded horn clauses also implemented using coroutine facility sicstus prolog also interested extending lazy functional languages programs section 7 8 become executable details implementations given tsu00 acknowledgements author thanks andreas knobel many interesting illuminating discus sions also thanks mariko yasugi hiroyasu kamo izumi takeuchi many discussions r data structure based gray code encoding graphics image processing exact real arithmetic case study higher order programming topological properties real number representations recursive computable operations topological structures new turing omnibus new representation exact real numbers real number computability domain theory golden ratio notation real numbers abstract data type real numbers de haskell report takagi function generalization computability analysis physics computation abstract structures serial parallel procedures implementation indeterministic multihead type 2 machines ghc real number computations computable real numbers design kernel language parallel inference machine exact real computer arithmetic continued fractions type 2 recursion theory introduction computable analysis tr exact real computer arithmetic continued fractions design kernel language parallel inference machine topology real number computability domain theory domaintheoretic approach computability real line abstract data type real numbers exact real arithmetic case study higher order programming computable analysis topological properties real number representations golden ratio notation real numbers ctr hideki tsuiki compact metric spaces minimallimit sets domains bottomed sequences mathematical structures computer science v14 n6 p853878 december 2004
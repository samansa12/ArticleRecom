nestedgraph model representation manipulation complex objects three recent trends database research objectoriented deductive databases graphbased user interfaces draw trends together data model call hypernode model single data structure model hypernode graph whose nodes graphs hypernodes typed types nested graphs give theoretical foundations hypernodes types show type checking tractable show also conventional typeforming operators simulated graph types including cyclic types hypernode model comes equipped rulebased query language called hyperlog complete respect computation update define operational semantics hyperlog show evaluation performed efficiently discuss also use hyperlog supporting database browsing essential feature hypertext databases compare work graphbased data modelsunlike previous graphbased models hypernode model provides inherent support data abstraction via nesting graphs finally briefly discuss implementation dbms based hypernode model b introduction recent database research focussed deductive 7 14 26 objectoriented 5 22 databases deductive databases extend relational data model rulebased computation rules enable derivation intentional tuples stored extensional tuples derived tuples used purely querying purposes inserted database conversely objectoriented databases start semantic data model 16 20 31 typically supports object identity inheritance complex objects extend features methods encapsulation objectoriented programming 32 37 thus deductive objectoriented database largely complementary former support extensionally intentionally defined relations fundamental data abstraction concepts classification identification inheritance encapsulation conversely latter support abstraction concepts support relations natur ally hence recent research aimed integrating two paradigms integration generally taken route extending logicbased deductive database languages features object identity sets functions methods inheritance 1 2 3 14 contrast paper report upon graphbased approach integration use graphs two firstly graphs formally defined wellunderstood structures secondly widely accepted graphbased formalisms considerably enhance usability complex systems 19 graphs used conjunction number conventional data models example hierarchical network models 35 entityrelationship model 9 recent extension thereof complex objects 27 various semantic data models 16 20 31 graphs hypergraphs 6 also used recently 12 17 23 25 33 36 data modelling tool right give comparison recent work approach section 4 paper directed graphs also foundation hypertext databases 11 33 databases graphs consisting nodes refer units stored information typically text named links link connects two nodes source destination links traversed either forwards source destination backwards destination source process traversing named links examining text associated nodes called browsing typically simple query facility consisting stringbased search provided used identify initial set nodes prior browsing feature hypertext dynamic creation new nodes links motivated previous research outlined developed graphbased data model called hypernode model supports object identity arbitrarily complex objects wellsuited implementation hypertext databases contrast graphbased models use nested possibly recursively defined graphs termed hypernodes hypernode pair ne nodes directed edges nodes hypernodes thus unlike graphbased models hypernode model provides inherent support nesting information labels hypernodes unique serve object identifiers illustrate hypernode figure 1 represents couple c consisting two people per1 per2 whose children nested within hyper nodes figure 2 show children person per1 would become visible exposed hypernodes labelled per3 per4 observe figures hypernodes differ hypergraphs generalise nodes hypernodes opposed generalising edges hyperedges name bob surname smith child per3 person name mary surname jones child per3 person fig 1 example hypernode name jill surname smith child none person per3 person name jack surname jones child none person fig 2 hypernodes note labels c per1per4 figure 1 superscripted tags couple person respec tively explain sequel tags indicate types associated hypernodes types give us means defining database schemas enforcing constraints structure content hypernodes types represented nested graphs queried updated using formalism hypernodes also note use node none person figure 2 denotes present hypernode model comes equipped computationally powerful declarative language called hyperlog model language share features deductive objectoriented databases common deductive database languages hyperlog rulebased supports derivations database updates common objectoriented databases hypernode model supports arbitrarily complex objects data abstraction concepts classification via types identification via unique labels encapsulation via nesting graphs 25 showed structural inheritance also supported naturally nested graph structures paper used nested hypergraphs treatment equally applicable simpler nested graphs hypernode model 24 also showed methods supported parametrised hyperlog programs hypernode model supports main features hypertext databases strings arbitrary length supported primitive type unstructured text represented text node hypernode encapsulated within number hypernodes hence text shared sets text fragments easily represented nodes hypernode annotated links represented hypernode single incoming edge source node single outgoing edge destination node hypernode encapsulate annotation information example actual link label description semantics link creator link date creation nesting hypernodes abstraction tool greatly facilitates design browsing densely connected database graphs unique model finally hyperlog support database browsing generalpurpose declarative querying latter facility used create contexts browsing first introduced hypernode model 24 present paper expand upon work several directions including expressiveness representation computation efficiency inference support hypertext implementation issues also describe recent work extending model include types extending hyperlog perform deletions well insertions outline paper follows section 2 discuss fundamentals hypernode model namely hypernodes types also discuss representational expressiveness type checking complexity section 3 give syntax semantics hyperlog discuss complexity evaluating hyperlog programs computational update expressiveness also show hyperlog used database browsing section 4 compare work graphbased languages models section 5 briefly describe prototype implementation conclude section 6 summary results 2 hypernode model section discuss fundamentals model namely hypernodes types define hypernodes repositories section 21 define types type repositories section 22 also examine efficiency type checking section 23 illustrate use types via extended example based upon flights bookings database finally section 24 discuss representational expressiveness model 21 hypernodes hypernode repositories section introduce underlying data structure hypernode model namely hypernode define hypernode repository set graphdefining equations define hypernodes values assigned indeterminates set equations solved begin recalling definition directed graph directed graph ordered pair n e n finite set nodes e n n finite set directed edges simplicity use terms graph directed interchangeably similarly terms edge directed edge also use notation n 1 n 2 interchangeably n 1 edges purposes hypernode model need two disjoint sets constants finite set primitive nodes p countably infinite set labels l assume set p includes alphanumeric strings elements p denoted identifiers start lowercase letter elements l denoted identifiers start uppercase letter graphs hypernode model defined equations form e g l ne graph n p l term equations hypernode equations examples following p1 p2 n1 n2 labels name spouse title ms mr b floyd tring primitive nodes hypernode repository simply repository finite set hypernode equations satisfying following two conditions two equations left hand side h2 label appearing right hand side equation exists equation label left hand side given hypernode repository hr denote labelshr set labels appearing equations hr primhr set primitive nodes appearing equations hr example four equations satisfy criteria hypernode repository note condition h1 corresponds entity integrity requirement 10 since equation viewed representing realworld entity similarly condition h2 corresponds referential integrity requirement 10 since requires existing entities referenced hypernode repositories viewed storing set graphs may reference graphs via labels alternatively since hypernode repositories sets equations would like unique solution indeterminates ie labels g l welldefined domain domain cannot universe wellfounded sets since hypernode equations may cyclicly defined example equations defining p1 p2 however appeal aczels theory nonwellfounded sets 4 solve hypernode repositories non wellfounded sets subsume wellfounded sets including circular sets ie sets may contain shown 4 set setdefining equations hypernode repository special case unique solution universe nonwellfounded sets thus hypernode repository hr unique solution universe nonwellfounded sets solution assigns label g left hand side equation nonwellfounded set term set hypernode denote hyp hr g simply hypg hr understood context hypernode hypg ordered pair ne n set primitive nodes hypernodes e n n note ordered pair ab viewed set aab example given hypernode repository consisting four equations p1p2n1 n2 ignoring node sets graphs simplicity spousenametitlemrinitialbsurnametringspouse spousenametitlemsinitialasurnamefloydspouse note sets hypn1 hypn2 wellfounded ones sets hypp1 hypp2 non wellfounded ones since contain 22 types type repositories next two sections extend model incorporate types also graphs define type repositories types analogy hypernode equations hypernode repositories hypernodes define means hypernode particular type show testing hypernode repository welltypedness performed polynomial time respect size repository section 23 illustrate types via extended example based upon flights bookings database purpose defining types assume availability two disjoint sets constants finite set primitive types tp every primitive node n p unique primitive type tp countably infinite set type labels tl every label hypernode repository tagged unique type label cf types object identifiers objectoriented databases analogy primitive nodes labels distinguish primitive types type labels using identifiers start lowercase letter former identifiers start uppercase letter latter assume every type primitive otherwise distinguished primitive node none denoting present see node used model missing incomplete information finally assume set primitive types includes type string types defined means equations form mf graph tp tl call equations type equations type reposi tory tr finite set type equations satisfying conditions h1 h2 hypernode repositories section 21 appeal theory nonwellfounded sets solve type repositories ie assign values universe nonwellfounded sets call values types denote hyp tr hypt tr understood context values take form pair mf set primitive types types f also make reasonable assumption primitive nodes labels distinct primitive types type labels ie p l tp thus overlap data hypernodes meta data types hypernode type repositories merged one repository well uniform storage data meta data means meta data queried updated using formalism data namely hyperlog typings hypernodes defined recursively follows given hypernode ne type mf say ne type mf exists homomorphism f n preserves types satisfies following conditions conditions stipulate hypernode must contain nodes edges conform nodes edges intended type conditions t3 t4 stipulate hypernode must contain least one instance every node edge intended type last two conditions restrictive since primitive nodes none used place missing information typings individual hypernodes generalised typings hypernode repositories follows hypernode reposi tory hr welltyped respect type repository tr every label g labelshr hyp hr g type hyp tr following theorem states testing hypernode repository welltypedness tractable result follows observing order test hypernode repository welltypedness fix homomorphism f map primitive nodes labels types check criteria equation hr equations hr checked maximum n nodes e edges right hand side hypernode type equation test achieved time proportional mn 2 e 2 theorem 1 testing whether hypernode repository hr welltyped respect type repository tr performed time polynomial number equations hr maximum size individual equations 23 flights bookings database example illustrate types consider database stores information bookings flights passengers schema database specified type flightbookingsschema figure 3 use equationbased pictorial representations graphs interchangeably also omit type tags labels understood context fig 3 example schema rf flightbookingsschema airlines airports flightbookingsschema contains six types rf shown figure 4 represents routes flights fly route followed number flights ii pt shown figure 5 represents passengers tickets passenger bought one tickets iii tc shown figure 6 represents tickets coupons ticket consists number coupons notice sharing graph ticket graphs tc pt iv fc shown figure 7 represents flights coupons flight booked number coupons v airlines airports shown figure 8 contain known airlines airports respectively fig 4 routes flights fly rf airport toatt airlineatt flight dateofdepatt timeofdepatt time fig 5 passengers tickets passenger dependentsatt nameatt passenger dateofissueatt fig 6 tickets coupons class statusatt classatt dateofissueatt coupon fig 7 flights coupons timeofdepatt dateofdepatt flight class statusatt classatt coupon fig 8 set types airlines airports airport airlines remaining types needed fully specify flightbookingsschema airline airport shown figure 9 time date fare name shown figure 10 finally nat shown figure 11 fig 9 types airport airline airport nameatt codeatt string nameatt codeatt string fig 10 types date fare time name string string hoursatt initialatt amountatt currencyatt monthatt dayatt make several observations types fig 11 natural numbers type edges types used represent attributes example flightnoattnat route adopt convention primitive types end att represent attribute names one primitive node primitive type node appears instances example primitive nodes flightno airline appearing figure 12 assumed type flightnoatt airlineatt respectively practice user introduce new primitive types set tp time populate types introducing new primitive nodes set p ii edges types also used represent binary relationships example routeflight rf gen eral relationships manytomany due fact instances defined homomorphic type however cardinality constraints enforced within update programs give example section 33 iii possible define recursive types example passenger whose dependents also type passenger nat contains iv type nat used represent natural numbers hypernode model 0 represented hypernode contains primitive node none nat successive natural numbers successive nestings 0 see figure 13 describe calculations performed numbers section 36 v hypernode type flightbookingsschema flight bookings database typical instance one node types rf pt tc fc airlines airports representing routeflights passengertickets ticketcoupons flightcoupons relations also airlines airports note flightbookingsschema schema design using hypernode model comparable entityrelationship er approach 9 however two fundamental differences two modelling approaches stressed firstly types directly model complex objects may hierarchical cyclic cannot modelled directly using er diagrams secondly types encapsulate types example flightbookingsschema encapsulates rf tc fc pt airlines airports ticket encapsulates date fare encapsulation encourages stepwise schema design cases schema large many interconnections renders schema much easier display comprehend illustrate specific instances types figure 12 show four hypernodes r1 two versions r3 note r1 type route first version r3 since conditions t1 t2 t3 t4 section 22 violated r31 amended type route replacing name flightno adding edge airline air2 specifying edges attributes fromatt toatt resulting r32 r31 r32 fig 12 routes r1 paris london air1to airline flightno london athens air2flightno airline air2airline name none airport air2flightno airline figure 13 show first three natural numbers figure 14 show hypernodes air1 air2 type airline note air2 two codes fig 13 first three natural numbers0 none1fig 14 two airlines ba british airways name code code oa olympic olympic airways namename figure 15 show hypernodes european american asian european american type airlines asian violates condition t3 type corrected adding primitive node none airline fig 15 sets airlines european ans american incorrectly typed asian asian american none airline figure show hypernodes pt1 pt2 type pt note dependents nested finite depth finally figure 17 show hypernodes n1 n2 type name f1 type fare d1 type date enforcement meaningful dates either achieved defining appropriate primitive types day fig 16 two instances passengerticket relationship passenger f1 none fare dateofissue name dependents dependents name dateofissue fare month year via update programs fig 17 names n1 n2 fare f1 date d1 smith mr smith mr amount currency title initial surname surname initial titleyearday month 6 24 expressiveness representation types type checking constitute powerful data modelling integrity checking tool since allow database schemas represented enforced also storagelevel optimisations carried based type informa tion hypernode model typecomplete sense allowed typeforming operator graph definition applied arbitrarily many times also cyclic types passenger figure 5 cyclic hypernodes p1 p2 section 21 supported bearing two points mind show conventional typeforming operators simulated using graph definition given type represent set type hypernodes type contain one nodes type empty set type represented hyper node empty types airlines airports figure 8 instances european american figure 15 illustrate set types given types 1 2 n attribute names 1 2 n flightnoatt airlineatt fromatt toatt represent record type types route flight figure 4 time date fare name shown figure 10 illustrate record types note record type bipartite graph also note construction differs usual idea record since attributes multivalued ie may one edge emanating instance type enforcement single values encoded update programs hyperlog given record type represent relation type sett component types record type may record types nested relations 30 also represented types flight figure 4 ticket figure 5 illustrate nested relation types given types 1 2 represent mapping type types rf pt tc fc shown figures 4 5 6 7 illustrate mapping types example type example instances nattonat identity function id maps natural number mapping greater maps natural number smaller natural note partial mappings represented without violating type correctness long least one edge mapping example mapping greater element 0 source edge maximal number maxnum sink edge finally given types record type attribute types 1 2 n contain primitive constants first second nth respectively general given types 1 2 n type defined r1 r instances heterogeneous sets isolated nodes arising participate edge edges arising edges 3 manipulation hypernodes section introduce hyperlog declarative query update language hypernode model hyperlog programs consist sets rules body rule consists number graphs called queries may contain variables act templates matched equations hypernode repository head rule also query indicates updates undertaken match graphs body evaluation program comprises repeated matching set rules hypernode repository updates inferred section 31 describe syntax hyperlog section 32 define matching queries rule bodies hypernode repository section 33 describe inference updates queries heads rules section 34 define operational semantics hyperlog program via fixpoint operator address efficiency expressiveness issues hyperlog sections 35 36 35 address efficiency inference 36 computational update expressiveness conclude section 37 brief discussion database browsing supported hyperlog chosen rulebased language hypernode model two main reasons firstly highlevel declarative nature language blends well graphbased data model secondly language expressive see fact complete respect computation database update consequence programs frequently invoked optimised builtin without compromising semantics language candidates optimisation arithmetic functions database browsing functions 31 syntax hyperlog purposes hyperlog assume countably infinite set variables v available denote elements v uppercase identifiers end alphabet assume set variables v set labels l disjoint also assume variables typed superscripted type tp tl however often omit superscripts understood context hyperlog rule possibly empty set graphs body single graph head call graphs queries query may variable label may variables node set also nodes edges may negated meaning absent intuitively formally query equation form e ne graph ii n disjoint union two sets n n n contains positive nodes n contains negative nodes iii e disjoint union two sets e e e contains positive edges e contains negative edges condition iv restricts edges positive nodes clearly positive edge containing negative ie absent node impossible also since edge contain negative node negative edges containing negative nodes meaningless simplicity denote node n n n edge three examples queries informally finds route flight number routes airline air1 informally checks whether route flight number 301 greater nattonat 10x nat 10 x finds numbers greater equal 10 using greater mapping section 24 hyperlog program finite set rules rule expression form queries example give program ignoring node sets graphs simplicity generates transitive dependents passengers places information mapping transdeps passengers passengers hyperlog program p represented labelled graph follows rule p add node set n two graphs q 0 r body add edge set e edge r body q 0 assume labels p r body drawn set program rule names prog whose members distinct set hypernode labels l set type labels tl example program represented graph shown figure 18 depsprog body1 body2 unique identifiers drawn prog subsequent figures programs often dispense outer program label note figure 18 rule heads shared rules graphical representation programs figure 23 give example rule bodies also shared semantics shared rule head dis junction head inferred bodies true conversely semantics shared rule body conjunction rule heads inferred rule body true finally note graphical representations programs hypernodes typed graphs encapsulated within required unique labels example two graphs label transdeps figure 18 32 queries rule bodies queries bodies rules act templates matched equations hypernode repository defining matching process need concept substitution variables constants appropriate type substitution q set assignments x 1 x distinct variable v c distinct element l p type x application substitution q query e equation eq resulting substitution x left hand side right hand side query c given hypernode repository hr query match query respect repository substitution q variables query constants drawn exists equation extend definition set queries q 1 q 2 q n substitution q match set queries match query q taken separately note definition assuming herbrand universe closed world assumption 29 allows us infer negation node edge absence positive match cf nonmonotonic formalisms 28 example given hypernode repository containing following routes sets possible matches four queries xr1 y605 xr3 y400 xr2 respectively 33 queries rule heads query head rule indicates updates undertaken match queries body rule rule r program p may thus modify equations hypernode repository adding deleting nodes edges right hand side according positive negative nodes edges head r furthermore may variables appearing head r appear body denote set variables new r case head r match exising equation repository set new equations generated one positive variable new r labels left hand sides new equations hitherto unused hypernode repository program p chosen nondeterministically also p consists number rules r 1 r r sets new labels generated sets variables new r 1 new r pairwise disjoint clearly new labels may left dangling references execution program p thus relax condition h2 definition hypernode repositories section 21 assume equation dangling label g null graph nullt defined follows type illustrate hypernode programs program depsprog figure 18 generates transitive dependents passengers places information mapping transdeps passtopass transdeps transdeps fig 18 program generate dependents passenger dependents passenger passenger passenger dependents x z z program figure 19 generates greater relation natural numbers assumes natural numbers contained node set distinguished hypernode label numbers program figure places result hypernode passengers paying fare 200 ticket program figure 21 adds passenger p3 dependents passenger p1 deleting null value might fig 19 program generate greater relation greater numbers greater z z greater numbers nat fig 20 program find passengers paying 200 usdollars passenger amount z nat passenger fare greaterz nat currency passengers result amount z nat passenger fare greaterz nat currency passengers result p3 first recorded dependent p1 note edge p1 none passenger also deleted also note semantics update program passenger number dependents fig 21 program add p3 dependents p1 passenger none passenger dependents passenger program figure 22 replaces old time departure flight fl1 flight new time typecorrectness fl1 must old time fl1 program illustrates cardinality timeofdep attribute limited 1 fig 22 program replace time departure flight fl1 t1 timeofdep flight final program figure 23 restructures information passengers stored number mappings cf functional data modelling 31 rather one hypernode per passenger cf relational data modelling fig 23 program restructure passenger information number mappings passtostring passtostring passtostring passtopass surnames titles string string string z surname initial title passenger name dependents initials conclude section noting possible write hyperlog rule deletes equation thus practice garbage collection achieved outside hyperlog 34 operational semantics hyperlog programs section specify operational semantics hyperlog via 2ary operator inferphr p hyperlog program hr hypernode repository inferphr returns new hypernode repository differs hr insertions deletions inferred hr firing parallel rules p operator fixphr computes fixpoint p respect hr successive application inferphr begin defining two binary operators sets equations given two sets equations hr hr consists every equation hr hr g labelshr labelshr ii every pair equations hr left hand side g equation hr hr consists every equation hr g labelshr ii every pair equations hr left hand side g equation let r rule q 0 q 1 q 2 q n program p head q 0 query q match set queries q 1 q 2 q n given q let q new substitution new r defined follows new ii one matches q 0 q let q new arbitrary one matches new labels superscripted appropriate type denote singleton set qqq new n eq pos r q singleton set qqq new n eq r q note equation neg r q may right hand side graph since may case edge n 1 n 2 e case n 1 n n 2 n finally define main operator inferphr provided set inferred insertions set inferred deletions intersect ie provided wish inferences made presence conflicts since want declarative semantics equality hold define inferphr old hypernode repository hr conclude defining operator fixphr computes fixpoint hypernode program p respect hypernode repository hr fix k1 following proposition states fixphr indeed hypernode repository ie satisfies conditions h1 h2 section 21 proof proposition follows easily definition inferphr proposition 1 fixphr hypernode repository course computation fixpoint might terminate example following program generates successor nat natural number x nat assuming representation natural numbers used assuming 0 already repository clearly program carry generating successors ad infinitum rule contains variable head body way nontermination arise example following program inserts deletes per1 c ad infinitum following proposition states computation fixphr terminate resulting repository unique generation new labels choice substitutions q new proof follows observation nondeterministic steps inferphr proposition 2 fixphr unique drawing new labels l choice q new conclude section noting fixphr defined ignores typecorrectness new repository fact static type checking programs performed fixpoint computed program p typecorrect rule r p typecorrect rule q 0 q 1 q 2 q n typecorrect query q partially typed finally query q partially typed graph n n e e satisfies conditions t1 section 22 respect type make number observations firstly verifying queries body rule partially typed prevents evaluation programs priori typeincorrect secondly queries heads rule partially typed contain insertions hypernode repository fixphr must well typed recall section 33 null graph nullt assumed dangling labels type thirdly deletions rule heads may cause conditions t3 t4 section 22 violated situation allowed occur either signaling runtime error inserting part operator partially typed graphs appropriate nodes edges nullt order simplify program specification adopted latter solution 35 efficiency inference section examine efficiency inferphr operator begin observing inferphr decidable since given repository hr finite number matches q query q respect hr due fact finite number constants drawn hr furthermore rule match q body r q new either chosen arbitrarily finite number existing substitutions obtained finite number new labels consider two aspects efficiency inferphr complexity finding match query respect hypernode repository potential number matches query next theorem states finding match query respect hypernode repository general npcomplete theorem 2 finding substitution q match query q respect repository hr npcomplete proof first show nphardness showing problem contains subgraph isomorphism known npcomplete 15 subproblem let q positive query form g n e elements n variables type let equation hr result follows since q required onetoone mapping ne ne next show problem np given query first guess substitution q query respect hr equation hr left hand side qq done remains show testing whether equation match query performed time polynomial size ne ne result follows since examining definition match given section 32 see testing performed time proportional nn despite negative result finding match less expensive case certain graphs example case graphs repository graphs queries trees problem solved polynomial time size repository 15 practice much data recordbased corresponding graphs repository forests see example graphs previous examples forest equivalent one tree whose root label graph matching queries tractable respect number matches query may exist exponential number matches example given query n elements n variables type equation number matches nn n negated nodes queries also lead complexity consider example matching following rule body string clearly may large number matches string constants database name person per1 problem avoided allowing variables appear negatively body rule without also appearing positively given rule q 0 q 1 q 2 q n variable appearing n also appears n j construct substitutions q q 1 q 2 q n matching positive information first technique commonly known range restriction 2 example range restrict strings rule body names people thus string x negative variables problem negative information negative constant nodes also lead additional complexity occur within query variable label consider example matching following cases hyperlog evaluator least make use type information search matches within hypernodes type person reducing cost finding matches positive information problematic clearly given query variables n greater number possible substitutions variables type tags variables narrow number choices edge information also help addition recordbased data whose attribute values polynomially bounded eg singlevalued attributes number matches query polynomial size repository 36 expressiveness computation clearly hyperlog powerful language respect expressiveness computations updates fact computationally complete update complete first demonstrate computational completeness hyperlog showing simulate counter programs known computationally complete 18 counter programs manipulate natural numbers stored variables called counters four operations allowed counters x counters denotes assignment addition counter programs support sequential composition goto statement conditional upon counter variable 0 simulate counters hyperlog equations distinguished left hand sides ctr nat ctr1 nat ctr2 nat say recall natural numbers represented successive nestings primitive node none nat sequence firing rules counter program using set distinguished labels current step contained node set hypernode label seq steps step start program hypernode assumed example assigning zero counter ctr achieved inserting 0 node set deleting nonzero element already assigning value ctr counter ctr1 achieved following rule adding one ctr achieved following rules may generate new natural number nat subtracting one ctr achieved following rule testing ctr zero achieved using query body rule finally sequential firing rules conditional goto achieved associating steps rules updating seq hypernode current step example assuming program four steps goto statement step2 simulated following rule conclude section examining expressiveness hyperlog respect database updates first define update context define concept update completeness analogy previous work relational databases 1 8 given type repository tr define set insttr contain hypernode repositories welltyped respect tr define update partial recursive mapping insttr insttr cgeneric c genericity introduced 21 intuitively means apart set distinguished constants c may empty set structure database relevant update values constants data base case update u cgeneric following holds given finite set c constants whose types contained primtr labelstr hr insttr isomorphism r maps primitive nodes primitive nodes labels labels invariant c ruhr equal urhr renaming newly generated labels set c may thought constants primitive nodes labels appear explicitly update program thus query language update complete hypernode model precisely defines set updates defined update completeness hyperlog particular follows similar results 1 2 8 21 logicbased languages comparable semantics 37 using hyperlog database browsing considered querying updating database partially specifying contents hypernodes contrast browsing allows user navigate structure database independent actual values case hypernode model navigation follow edges either forwards backwards descend node parent graph ascend parent graph node show navigational operators implemented hyperlog general difficult user predict types hypernodes encountered browsing database order facilitate browsing introduce type supertype every type ie consider hypernode primitive node type first define three types instances type context typically contain two nodes one type currenthyp contains hypernode type currentnode contains specific node within hypernode current context thus recorded hypernode curhyp contains current hypernode navigation curnode contains specific node within current hypernode currently browsed current hypernode updated hypernode old say hypernode new rule similarly current node updated old new rule observe rule verifies new current node indeed node set current hypernode order navigate forwards store hypernode curout currentnode nodes connected current node edges outgoing initialise previous contents curout using rule store next nodes curout using rule similarly order navigate backwards store hypernode curin currentnode nodes connected current node edges incoming initialise previous contents curin curout store previous nodes curin using rule order navigate upwards store hypernode curup currentnode hypernodes containing current hypernode initialise previous contents curup use rule finally order navigate downwards store hypernode curdown currentnode nodes contained node set current node primitive node initialise previous contents curdown use rule browsing using hyperlog investigated 13 particular shown hyperlog support declarative querying content structure hypertext database database constructed associating hypernodes fragments text using hypernodes store named links fragments history hypernode records users navigation database number alternative trails set stored navigational functions supported include display hypernode associated text four operators described 4 comparison related work section compare hypernode model hyperlog related languages models begin logicbased database language iql 2 semantics hyperlog partly derived next consider three recent graphbased data models 12 17 23 finally consider recent work hypergraphbased models 25 33 36 iql incorporates objectidentities typed rulebased query language update complete fixpoint semantics hyperlog similar discussed 2 3 label generation semantics differ iqls invention object identities generate new labels necessary consequence new graphs inferred whereas iql generation object identity assignment value independent events also iqls types constructed using tuple set union intersection constructors hyperlog one generalpurpose graph constructor simulate next compare hypernode model three recent graphbased data models logical data model ldm 23 good 17 graphlog 12 ldm database schemas directed graphs instances consist 2 column tables associates entities particular type values also ldms schema graphs use three types node basic primitive data types composition tuple types collection set types whereas represent tuple types set types one generalpurpose graph constructor graphlog 12 query language operating database comprises directed labelled graph semantic net edges graph represent predicates unlike hyperlog graphlog queries formulated graphs whose edges annotated predicates transitive closures thereof generally regular expressions query graphs matched database graph return subgraphs thereof good 17 graphicallyrepresented functional data model 31 associated transformation language good embeds semantics nodes edges graph nodes printable nonprintable edges singlevalued multivalued queries goods transformation language graphs called patterns match subgraphs total instance graph cf matching queries hypernode repository contrast hyperlogs rulebased updates goods instance graph updated five graphicallyrepresented primitive operations add delete node edge operation called abstraction incorporated patterns summary feature common models database consists single flat graph drawback practice complex objects consisting many interconnected nodes hard present user clear way contrast hypernode database consists set nested graphs unique feature model provides inherent support data abstraction ability represent realworld object separate database entity good allow abstraction operation generates nonprintable entity connects related entities level cf nesting set graphs within graph unlike good graphlog label edges hypernode model however attain data modelling expressiveness encapsulating edges would label good graphlog within one hypernode similar label example represent set good edges hypernode conclude section review recent work hypergraphbased data models 25 33 36 comparison work model first observe hypergraphs modelled hypernodes encapsulating contents hyperedge within hypernode contrast multilevel nesting provided hypernodes cannot easily captured hypergraphs 33 hypergraphs used model pageoriented hypertext databases nodes hypergraph associated pages information hyperedge consists related set labelled directed edges nodes directed edges shared hyperedges querying hypergraph navigational uses number predefined browsing forwards backwards along directed edges set marked nodes marking new set nodes reading set pages associated current marked nodes querying current state saving resetting current states views created database hypergraph updated number primitive operators unlike hypernode model hypergraphs typed updates semantically con strained also unlike hyperlog querying database content supported 36 hypergraphbased model data access presented aims integrate browsing querying model entities represented nodes relationships hyperedges resulting hypergraph transient lasting duration query session starts consisting one hyperedge containing database entities hyperedges added response user queries stage hypergraph traversed moving within hyperedges hyperedge hyperedge via common node number differences work firstly database entities assumed type stored tuples single flat relation secondly attributes entities represented graphically within hypergraph exist underlying relation thirdly although browsing graphbased querying consists specifying booleanvalued expressions values attributes hence hybrid model browsing querying obtained 25 described data model called groovy graphicallyrepresented objectoriented data model values groovy realworld entities represented means instances object schemas showed representation object schemas means hypergraphs leads natural formalisation notions subobject sharing structural inheritance also showed instances object schemas represented hypergraphs labelled object identifiers groovy conceptual data model influenced development hypernode model superseded recent work types hyperlog implementation 5 system architecture implementation currently coming end twoyear project whose goal implement prototype dbms based hypernode model tailor needs hypertext databases architecture system shown figure graphbased user interface hyperlog evaluator transient hypernode store storage manager figure 24 hypernode database system architecture architecture storage manager stores hypernodes types programs index manager supports efficiently three operations given label g return unique graph ne ii given primitive node n return set labels g 1 g r equation g iii given label g return set labels g 1 g r equation g detailed description storage manager appears 34 briefly storage manager supports number object stores object store containing graphs one type two object stores reserved storage types programs associated object store label table maps labels physical addresses graphs define thereby implementing operation operation ii implemented using simple prefix btree operation iii implemented extendible hashing scheme operations invoked hyperlog evaluator matching queries evaluator computes fixpoint program respect repository verifying program correctly typed updated hypernodes amassed transient hypernode store inference step evaluator currently uses bottom 9up naive 35 evaluation hyperlog programs although looking optimising fixpoint computation drawing existing optimisation techniques logic database languages seminaive evaluation 35 6 presented hypernode model graphbased data model stores nested graphs form equations manipulates via rulebased language key innovations model formal foundation graphs set theory use graphs throughout levels user interface physical level inherent support data modelling concepts object identity complex objects encapsulation provision types type checking associated query language hyperlog support querying browsing allows derivations database updates uniform storage data hypernodes meta data types procedural data hyperlog programs examined efficiency type checking shown performed polynomial time also examined expressiveness representation computation update model shown hyper log computationally update complete although evaluation hyperlog programs intractable general case discussed cases evaluation becomes tractable compared model graphbased models comparison highlighted advantages nested graphs type instance lev els finally briefly discussed prototype dbms architecture implementation current research effort directed towards tailoring hypernode dbms needs hypertext includes optimisation hyperlog support versioning provision specialpurpose access methods implement efficiently browsing text retrieval operations acknowledgements hypernode project supported financially uk science engineering research council grant number grg26662 r procedural declarative database update languages object identity query language primitive fixpoint extensions firstorder logic dataloglike languages formal models object oriented databases logic programming databases ps entityrelationship model towards unified view data extending database relational model capture meaning introduction survey mendelzon hypertext database implemented using hypernode model johnson three principles representation semantic networks graphoriented object database model visual formalisms database modelling hypernode model associated query language objectoriented data model formalised hypergraphs logical language data knowledge bases complex object modelling semantic issues deductive databases logic programs closed world databases relational model relationvalued attributes functional data model data language daplex research directions objectoriented programming data model flexible hypertext database systems storage manager hypernode model principles database knowledgebase systems transient hypergraphbased model data access tr relational model relationvalued attributes hypertext introduction survey algorithmics spirit computing visual formalisms principles database knowledgebase systems vol database modeling survey applications research issues logical language data knowledge bases data model flexible hypertext database systems object identity query language primitive untyped sets invention computable queries fixpoint extensions firstorder logic dataloglike languages logic programming databases complex objects modeling entityrelationship approach transient hypergraphbased model data access hypernode model associated query language objectoriented data model formalised hypergraphs graphlog graphoriented object database model procedural declarative database update languages functional data model data languages daplex three principles representation semantic networks extending database relational model capture meaning entityrelationship modelmyampersandmdashtoward unified view data computers intractability new approach database logic objectoriented databases storage manager hypernode model ctr stefan g hild alexandra poulovassilis hyperlog system database querying browsing proceedings workshop advanced visual interfaces may 2729 1996 gubbio italy sankhayan choudhury nabendu chaki swapan bhattacharya gdm new graph based data model using functional abstractionx journal computer science technology v21 n3 p430438 may 2006 mark levene alexandra poulovassilis kerima benkerimi sara schwartz eran tuv implementation graphbased data model complex objects acm sigmod record v22 n4 p2631 dec 1993 manoj chavda peter wood towards odmgcompliant visual object query language proceedings 23rd international conference large data bases p456465 august 2529 1997 alexandra poulovassilis stefan g hild hyperlog graphbased system database browsing querying update ieee transactions knowledge data engineering v13 n2 p316333 march 2001 mark levene george loizou graphbased data model ramifications ieee transactions knowledge data engineering v7 n5 p809823 october 1995 giorgio busatto hansjrg kreowski sabine kuske abstract hierarchical graph transformation mathematical structures computer science v15 n4 p773819 august 2005 salvatore march charles wood gove n allen research frontiers object technology information systems frontiers v1 n1 p5174 july 1999
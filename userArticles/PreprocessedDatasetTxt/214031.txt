polynomialtime membership comparable sets paper studies notion called polynomialtime membership comparable sets function g set polynomialtime gmembership comparable polynomialtime computable function f x1 cdots xm geq gmax x1 cdots xm outputs b 01m ax1 cdots axm neq b following list major results proven paper 1 polynomialtime membership comparable sets construct proper hierarchy according bound number arguments 2 polynomialtime membership comparable sets polynomialsize circuits 3 function f constant c0 set leqpfnttreducible pselective set set polynomialtime 1clog fnmembership comparable 4 cal c chosen rm pspace fewp np cp pp mod2p mod3 cdots cal c subseteq rm pmcclog n c1 cal corollary last two results shown constant c1 cal c polynomialtime nctruthtable reducible pselective sets cal resolves question left open long time b introduction given two strings x tell likely set jockusch joc68 defined set semirecursive recursive function f x call function f selector selman sel79 considered polynomialtime analogue semirecursive sets defined set pselective polynomialtime computable selector pselective sets widely studied sel82b sel79 sel82a ah92 ko83 tod91 ls93 bvht93 recently remarkable results pselective sets buhrman van helden torenvliet bvht93 shown set p p selfreducible pselective previously known characterization 2 p p ptt selfreducible pselective sel82b naik et al nos93 hnos93 proven constructing pselective sets certain properties np search problems reducible corresponding decision problems unless implausible collapses exponentialtime complexity classes occur hemachan dra et al hho studied internal structure class sets p reducible pselective sets introduced notion fcselectivity various function classes fc hemas paandra naik ogiwara selman hnos94 studied sets nondeterministically polynomialtime computable selectors proven npfunction computes satisfying assignments uniquely polynomialtime hierarchy ms72 sto77 collapses second level sigma p set let us identify characteristic function x four possible values ax ay mapping pair x selector declares x 2 2 equivalently ax ay 6 1 0 thus one view selector function f maps x b 2 f0 1g 2 ax ay 6 b b always either 01 10 interesting fundamental question arising observation strong restriction b 2 f01 10g allow f map 00 11 largely complexity increase let us consider generalized setting define notion polynomialtime membership comparable sets let n denote set nonnegative positive integers call polynomially bounded polynomial p every polynomialtime computable polynomialtime bounded machine input x outputs 1 gjxj monotone nondecreasing polynomialtime com putable polynomially bounded 1 function f called gmembership comparing function gmcfunction short every x 2 set polynomialtime gmembership comparable exists polynomialtime computable gmcfunction 3 pmcg denotes class polynomialtime gmembership comparable sets crucial property mcfunctions exclude one value 2 possible values notionexcluding possible values ax 1 already appeared literature fixed k 1 function input x called f notions related f k introduced studied see ag88 abg90 bei91 bggo88 one always reduce 2 k possible values f k k said computable set polynomialtime functions abg90 said menumerable ch89 set nonpsuperterse bei91 k 1 polynomialtime algorithm computes f using adaptive queries set x nonpsuperterse set f k 2 kgamma1 enumerable k 1 polynomialtime membership comparable sets general notions sense k increased according length input ii one value required excluded purely convention function g set real numbers range used identifying g nmaxf1 bgncg use pmcconst pmclog pmcpoly respectively denote polynomialg log base 2 possible many different indeed even uncountable number sets pmcpoly via function g see proposition 41 example actually happens section 2 study basic properties polynomialtime membership comparable sets easily observed smallest pmcclass namely pmc1 equal p noting psel class pselective sets subclass pmc2 p ae psel sel79 pmc1 ae pmc2 show inequality holds arbitrary k 1 generally prove f g fn gn finitely many n pmcg contains set pmcf therefore pmcclasses construct proper hierarchy according bound number arguments pmc2sets viewed less restrictive pselective sets one might expect pmcsets go far beyond psel section 3 consider question related seek prove inclusions reducibility classes psel pmcclasses reducibility p r class c let r r c denote class sets p r reducible set c basically pmc2 properly includes psel tally set pmc2 gamma psel furthermore prove function f c log fn constant c 0 yields r btt psel pmcconst r tt psel pmclog also study question direction namely whether pmcsets polynomialtime reducible pselective sets show pmcpoly ppoly ppoly class sets polynomialsize circuits since r ppoly ko83 pmcpoly r psel p reducibility inclusion optimal show r tt psel ae pmcpoly hand converse statement ppoly pmcpoly appear hold show least question subtle ppoly 6 pmcpoly implies p 6 np thus proving pmcpoly ae ppoly least hard proving p 6 np conjecture converse inclusion hold wellknown ppoly r tt denotes class sparse tally sets holds pmcpoly ppoly every pmcset p tt reducible tally set section 4 attempt find close relationships pmcsets sparse sets well tally sets prove r 1tt sparse pmcpoly thus r tt ppoly interestingly contrasts r tt psel ae ppoly hho 93 order study relationships pmcsets tally sets binary real numbers useful since characteristic sequence tally set viewed binary real number 0 1 see sel79 show binary real number r 2 0 1 prefix r set prefixes r pmc2 binary real number r prefix r 62 psel add words relationships pmcpoly tally noting ppoly tally pmcpoly show every 2 pmcpoly tally set pmcpoly delta p p tt hand tally set p equivalent pmc2set thus every set pmcpoly p reducible set 3 consequence ppoly pmc2 p reducibility sparse sets pmc2 completely characterizes ppoly selman sel79 showed sat pselective sat p prove similar result pmcsets consider question section 5 noting ppoly np ppoly implies kl80 one easily observe sat 2 pmcpoly stronger collapse pmcclass prove np pmcc log n c 1 proof technique develop enables us resolve open questions first bonus get following result constant c 1 np r n c tt psel np one important questions whether np r r psel np holds reducibility p r sel82b tod91 hho extended first result p ptt reducibility observing r ptt non positive truthtable reducibilities appeared observations toda tod91 proved np r tt psel implies al hho noticed np r 1tt psel implies ttw94 proved np r btt psel np deterministic subexponential time nonetheless open long time whether np r tt psel implies even whether np r btt psel implies np give affirmative answer latter improves upper bound number queries n c constant c 1 note result independently proven beigel kummer stephan bks94 agrawal arvind aa94 another bonus get complexity functions polynomialtime computable access sets np krentel kre88 showed function fn 1log n fp sat fngamma1t asked whether statement holds larger function f krentels proof directly applies case fn c log n constant c 1 related beigel bei88 asked question whether fngamma1t case fn c log n c 1 beigel bei88 showed p 1tt hard set np fp fngamma1t x regarding general olog n case amir beigel gasarch abg90 showed function olog n fp sat fngamma1t x sigma p 3 paper prove conclusion beigels result strengthen proof techniques develop applied complexity classes np prove class c chosen fup fewp cp pp pspacemod 2 c pmcc log n c 1 basic properties polynomialtime membership comparable sets section prove fundamental properties polynomialtime membership comparable sets reducibility notions use due lls75 first state rather trivial properties proposition 21 1 2 f g fn gn finitely many n 3 p pmcfn 2 pmcfpn polynomial p especially k 1 pmck closed p reductions proof 1 statement holds set p c p polynomialtime computable function f x g hypothesis let n 0 n n 0 fn gn let 2 pmcf let set strings length n 0 let x n maxfjx 1 gn every jx therefore pmcg via machine b 2 pmcf via h let p polynomial bounding runtime x let qx denote unique query x set x x rejects accepts matter answer oracle let r 0 r 1 set x x accepts qx oracle qx oracle note w 0 maxfjx 1 case smallest x case subcase 2a l smallest pair define h 0 subcase 2b every easy observe h 0 behaves correctly 2 proposition 21 2 states pmcf pmcg finitely many n gn interestingly shall show pmcf differs pmcg infinitely many n note proof develop flavor similar ag88 theorem 2 theorem 22 let f g monotone nondecreasing polynomialtime computable polynomially bounded functions map n n suppose infinitely many n holds gn fn set 2 pmcg n pmcf proof let f g hypothesis theorem since f polynomially bounded n 0 every n n 0 define sequence fl g i1 follows hypothesis fl g i1 sequence integers g larger f let h enumeration polynomialtime computable functions h computable time construct stages stage diagonalize h putting fl string length l note fl strings length l construction stage proceeds follows ith smallest string length l let already fmc function proceed next stage adding new elements b 2 f0 1g fls put w ith bit b 1 yields h w cannot fmc function clearly construction establishes 62 pmcf next define gmc function fl let loss generality may assume jy 1 let largest l jy j following four possible cases jy clearly 62 define fly b holds j 2 let smallest appears c jy distinct definition holds l fl elements define distinct simulate construction stage compute c 1 define case holds fly gmc function remains show fl polynomialtime computable since f g polynomialtime computable fl g i1 strictly increasing sequence l computable time polynomial jy j one easily compute value fl cases b c suppose case holds since holds jy 1 j log log jy j since h computable time polynomially bounded fixed constant k construction stage simulated time tested therefore fl polynomialtime computable proves theorem 2 corollary 23 fn gn infinitely many n gn fn infinitely many n theorem pmcf pmcg incomparable corollary 24 pmcclasses construct proper hierarchy according bound number arguments namely 3 relationships pselective sets section study relationships polynomialtime membership comparable sets pselective sets first definition psel subclass pmc2 proposition 31 psel pmc2 inclusion proper theorem 32 tally set 2 proof enumeration polynomialtime computable arity2 functions let f computable time define 4n 1 let set constructed stages stage following otherwise put u 2i clearly either f selector function exist x 2 2 c either f x 62 psel need show construction stage simulated time 1 define function g follows let tally strings case 1 6 k k define gx case case subcase simulate construction stage bk2c test whether x 2 define gx subcase b bk2c bl2c simulate construction stage bl2c test whether subcase c easy see g witnesses 2 pmc2 proves theorem 2 reducibility classes psel included pmcpoly following theorem answers question theorem 33 monotone nondecreasing function let l p reducible pselective set l c log fn constant c 0 proof theorem based lemma 34 due toda stating given pselective set finite set q one compute linear order q q initial segment order originally jockusch joc68 attributed appel mclaughlin proved semirecursive equivalent initial segment recursive linear ordering regarding pselective sets defined polynomialtime analogue semirecursive sets selman sel82b showed initial segment polynomialtime linear order pselective set ko ko83 showed pselective equivalent union initial segments polynomialtime preorder lemma 34 tod91 let pselective polynomialtime algorithm given finite set q sigma outputs enumeration elements q exists fy prove theorem proof theorem 33 let f l hypothesis let l p fntt via machine let pselective let c 0 define c log fnc let jg denote set queries x let nondecreasing k q k fn sufficiently large n holds 2 lemma 34 compute time polynomial p y2r jyj thus time polynomial jxj enumeration elements r fy mg fy accepts otherwise clearly every v 2 f0 1g hn v 6 b m1 delta delta delta b mhn let v 0 smallest v define rx easy see r witnesses 2 pmch proves theorem 2 corollary 35 p btt psel pmcconst p tt psel pmclog function h said polynomially lengthbounded polynomial p every x jhxj pjxj definition 36 kl80 set l ppoly exist polynomially lengthbounded function h set 2 p every x holds ko ko83 showed pselective sets polynomialsize circuits noting p selective set finite set w string x w partitioned two sets x 2 w 1 x 2 c w 2 c ko developed divideandconquer method find polynomially lengthbounded advice method however hard find pmc2sets set w partitioned four sets w 4 c nonetheless surprisingly pmcpolysets polynomialsize circuits stated theorem 37 pmcpoly ppoly proof theorem essentially abg90 theorem omit proof matter fact abg90 amir beigel gasarch showed k 1 pmck ppoly developing algorithm construct advice string length okn 2 sigma n thus even k function n polynomially bounded construction still works wellknown ppoly r tt tally r psel sel79 every set pmcpoly p reducible pselective set corollary 38 pmcpoly r psel since r tt psel pmclog pmclog 6 pmcpoly inclusion optimal corollary 39 pmcpoly 6 r tt psel converse theorem 37 appear hold question whether converse holds subtle proving pmcpoly 6 ppoly least hard proving p 6 np theorem 310 ppoly pmcpoly proof suppose tally set polynomial timebounded deterministic oracle turing machine every x x 2 l x accepts let p polynomial bounding runtime without loss generality may assume every x oracle x query x x f0 delta delta g let x strings length enumeration subsets f0 note evert represented string length pn every accepts accepts accepts 0 otherwise c 2 f0 1g c 6 c let c smallest c define supposition representation ranges strings length pn c computed time polynomial n g polynomialtime computable therefore l 2 pmcp 1 hence ppoly pmcpoly 2 conjecture pmcpoly proper subclass ppoly 4 relationships sparse tally sets section study relationships polynomialtime membership comparable sets sparse sets well tally sets since ppoly theorem 37 holds pmcpoly r tt sparse pmcpoly r tt tally ppoly r psel psel pmc2 sparse r pmcpoly fact holds sparse pmcpoly proposition 41 sparse pmcpoly proof let sparse set polynomial p every n sigma n k pn define g function given x function g polynomialtime computable every cannot happen x thus possible uncountable number sets pmcpoly via function g proposition 21 3 following theorem theorem 42 r 1tt sparse pmcpoly tally set let rt delta string rt viewed binary real number binary real number rt 2 0 1 define leftcut r set binary strings w smaller equal rt dictionary order prefix r set initial bits rt selman sel79 showed following theorem 43 binary real number rt 1 following properties hold 1 leftcut r pselective 2 leftcut r p ptt p 3 prefix r pselective 2 p 4 prefix r p complex prefix r show prefix r polynomialtime 2 membership comparable theorem 44 r 2 0 1 prefixr pmc2 proof let r 2 0 1 let x distinct two strings following properties hold ffl x prefix ffl prefix x x ffl x prefix prefix x one x first condition satisfied 10 second condition satisfied 11 otherwise clearly g witnesses prefixr 2 pmc2 2 corollary 45 tally set sparse set 2 pmc2 p since tally set p following corollary corollary 46 tally set prefix rt wellknown every set 2 ppoly tally set tt see example sch86 proposition 41 tally pmcpoly following corollary corollary 47 every 2 pmcpoly tally set p moreover corollary 45 every tally set sparse set 2 pmc2 p equivalent therefore following corollary corollary 48 every 2 pmcpoly sparse set p sparse pmcpoly following corollary 49 every sparse set sparse set 0 3 therefore ppoly 5 polynomialtime membership comparable hard sets section show complexity classes c c 1 c pmcc log n p note author recently informed results section independently proven agrawal arvind aa94 beigel kummer stephan bks94 start considering np theorem 51 np pmcc log n c 1 proof suppose np pmcc log n c 1 take natural number consider npcomplete set sat without loss generality may assume ffl every formula truth assignment encoded string length jj 12a let formula set prefixes truth assignments call good contains prefix satisfying assignment assumption encoding k k good g obviously 2 np 2 pmcc log n let f membership comparing function witnessing property let formula set r many prefixes truth assignments suppose sets truth assignments represented prefixes disjoint j 1 prefix j j prefix set ith bit js binary representation f0 1g 1 js representation form b 1 1 note c log jy must exclude one possibility ay 1 ay 1 suppose least one thus least one good therefore hand suppose b 2 f0 1g gamma f0 g let number whose binary representation show z good z gamma fy g good assume way contradiction z good z gamma fy g good every 2 2 hand every ith bit b 1 therefore every 2 b implies ay 1 contradicts f declaration fy g good moreover z gamma fy g good since subset z z good therefore case holds z good z gamma fy g good define prune procedure given z computes outputs yes b 0 outputs z gamma fy g otherwise clearly prune polynomialtime procedure every z holds ffl prune outputs yes 2 sat ffl prune outputs set z 0 z 0 good z good moreover z consists truth assignments whether z good tested time polynomial jj consider decision procedure given formula behaves follows 0 initially set z fg 1 according k z k following z smallest 2 z canonical lexicographic order replace z z0 z1 outputs yes accept otherwise replace z output prune 2 2 z truth assignments goto 1 otherwise accept z good hard see procedure polynomialtime bounded accepts satisfiable therefore sat 2 p proves theorem 2 remark 1 note proof seem work case c 1 even wish prove consequence weaker length 2 suppose wish preserve k z k 2 hd gamma 1 function h note wish develop polynomialtime algorithm order eliminate one prefix z construct subsets z consisting 2 prefixes let average length prefixes z must encode least 2 average thus holds jy ff constant depending size encoding alphabet number arguments must give f least c log maxfjy 1 cannot bounded constant may assume log2 dgammah 1 need chd c arguments c 1 impossible hd arguments arguments apply proof theorem 55 next consider subclasses np namely fewp defined valiant val76 allender all85 respectively polynomial timebounded nondeterministic turing machine let accm denote function maps x number accepting computation paths input x set l respectively fewp polynomial timebounded nondeterministic turing machine witnessing l 2 np every x accm x 1 respectively every x accm x pjxj polynomial depending cooks reduction coo71 padding arguments see example bh77 npacceptor 2 n one construct polynomialtime computable function f following conditions satisfied set formulas ffl every x accm x equals number satisfying assignments fx ffl every x truth assignments fx length jfxj 12a define proof theorem 51 place sat thus use technique prove results similar theorem 51 fewp theorem 52 pmcc log n c 1 theorem 53 fewp pmcc log n c 1 next consider counting complexity classes cp pp pspace set pp gil77 sim75 cp wag86 sim75 exist machines n every x x 2 accm x accn x accm theorem 54 let c fpp cp pspaceg c pmcc log n c 1 proof note np subset either c coc since c coc contained pmcc log n theorem 51 2 since c p pp pspace one worddecreasing selfreducible p complete sets ol93 word decreasing selfreducible set ppoly sigma p establishes 2 set mod k p ch90 machine every accm x 6j 0 modulo k argument cp pp pspace cannot applied mod k p known whether np conp included mod k p need develop direct proof theorem 55 let k 2 mod k p pmcc log n c 1 mod k proof let k 2 suppose mod k p pmcc log n c 1 let natural number c loss generality may assume formula propositional logic truth assignment formula k fyz yz satisfying assignment g k modulo k note every lg wellknown l 0 p complete mod k p clear l 0 p reducible l 1 show l 1 p let formula let set pairs 1g call good every assumption length formulas truth assignments encoding k k jj2 jy set good since mod k p closed p reductions her90 thus comod k p closed p ctt reductions symmetry 2 comod k p supposition c pmcc log n let f function witnessing property show l 1 2 let formula 1g every 1g moreover suppose every prefix j j prefix l set lth bit binary representation f0 1g 1 representation form b 1 1 easy see l contains exactly r2 pairs thus jy l must length differ suppose b 2 0 l l 2 c l good thus z good l subset z hand suppose b 2 f0 1g gamma f0 g let b denote ith bit b let number whose binary representation b show z good way contradiction z gamma fy z good definition every l l good hand every l lth bit ts binary representation b l 1 every l l good b l 0 thus contradicts f declaration therefore z good z gamma fy z good obviously nonempty subset z good hence z good z gamma fy define prune procedure given x z computes outputs value 0 outputs z otherwise following properties hold ffl prune polynomialtime procedure ffl prune outputs z good ffl prune outputs z 0 z good z 0 good moreover z consists pairs form truth assignment whether z good easily tested z good every 2 z holds satisfying assignment x define nondeterministic turing machine input l behaves follows 0 initially set z f lg 1 according k z k one following outputs reject halt otherwise set z output prune l smallest fy canonical lexicographic order nondeterministically guess replace two elements 2 z truth assignment goto 1 otherwise accept z good suppose input l start step 1 z suppose w good enter 1a z replaced good one enter 1b clearly uniquely exists guess n z substituted good one hand suppose z good enter 1a either rejects substitutes z one good enter 1b every guess n substitutes z one good l l 1 exists unique path leading step 2 good z l 62 l 1 path therefore l 2 l 1 uniquely exists path leading acceptance l 62 l 1 exist paths implies l 1 2 mod k p since mod k p theorem 52 theorem 2 proof techniques developed enable us resolve open questions selman sel79 showed np rm psel np studied whether similar statement holds flexible reducibilities open long time whether np r btt psel implies theorems 33 51 give affirmative answer question corollary 56 np r btt psel implies fact np r n c tt psel implies theorem 51 yields another consequence set function f let fp fnt fntt denote class functions polynomialtime computable fjxj adaptive nonadaptive queries krentel kre88 showed log n fp sat fnt fp sat fngamma1t asked whether similar result holds larger function f beigel bei88 strengthened bound c log n constant c 1 asked similar question fp sat fntt place fnt showed p 1tt hard set np constant c 1 f fn c log n fp fngamma1t x prove conclusion beigels result strengthened theorem 57 let fn c log n constant c 1 let b p 1tt hard np set x holds fp b fngamma1t proof proof quite similar theorem 51 let f c b x hypothesis without loss generality may assume log nc natural number define notion good sets encoding xz set proof theorem 51 every set z jj gamma 1 prefixes truth assignments log n n let h function given set z jj gamma 1 prefixes truth assignments subsets z defined proof theorem 51 since fntt thus h 2 fp b fntt supposition h 2 fp x fngamma1t let machine witnessing h 2 fp x fngamma1t every z 2 possible outputs since gn log n values computed time polynomial jj moreover since 2 gjj possible values ay 1 compute time polynomial jj value equal ay 1 function given z maps v0 log jjgammagjj clearly h 0 polynomialtime computable therefore proof theorem 51 define polynomialtime decision procedure sat proves theorem 2 two results applied complexity classes corollary 58 let c class chosen f pspace fewp c p pp mod 2 p deltag 1 c r n c tt psel c 1 2 let h p 1tt hard fn c log n c 1 fp h fngamma1t x acknowledgment author would like thank lane hemaspaandra useful comments r truthtable reductions p selective sets connections bounded query classes nonuniform complexity polynomial terse sets lower bounds low hierarchy invertible functions bounded queries sat boolean hierarchy isomorphisms density np complete sets approximable sets enumerative counting hard power parity polynomial time complexity theorem proving procedures computational complexity probabilistic turing machines relations among modclasses computing solutions uniquely collapses polynomial hierarchy semirecursive sets positive reducibility connections nonuniform uniform complexity classes selfreducibility weak pselectivity complexity optimization problems tr ctr till tantau query complexity membership comparable sets theoretical computer science v302 n13 p467474 13 june richard beigel lane hemaspaandra harald hempel jrg vogel optimal seriesparallel tradeoffs reducing function graph information computation v173 n2 p123131 march 15 2002 alina beygelzimer mitsunori ogihara enumerability p collapses p nc theoretical computer science v345 n23 p248259 22 november 2005 sebastian bab arfst nickelsen one query reducibilities partial information classes theoretical computer science v345 n23 p173189 22 november 2005 arfst nickelsen till tantau partial information classes acm sigact news v34 n1 march mitsunori ogihara till tantau reducibility sets inside np sets low information content journal computer system sciences v69 n4 p499524 december 2004 piotr faliszewski lane hemaspaandra open questions theory semifeasible computation acm sigact news v37 n1 march 2006 amihood amir richard beigel william gasarch connections bounded query classes nonuniform complexity information computation v186 n1 p104139 10 october
xortrees efficient anonymous multicast reception examine problem efficient anonymous multicast reception general communication networks present algorithms achieve anonymous communication protected traffic analysis require o1 amortized communication complexity link low computational comlexity algorithms support sender anonymity receivers anonymity senderreceiver anonymity b introduction one primary objectives adversary locate destroy commandandcontrol centers sites send commands data various stationsagents hence one crucial ingredients almost network command centers conceal confuse adversary regarding stations issue commands paper shows use standard offtheshelf cryptographic tools novel way order conceal commandandcontrol centers still assuring easy communication centers recipients specifically show efficient solutions hide sender receiver messagedirective variety threat models proposed solutions efficient terms communication overhead ie much additional information must transmitted order confuse adversary terms computation efficiency ie much computation must performed concealment moreover establish rigorous guarantees proposed solutions 11 problem considered modern cryptographic techniques extremely good hiding contents data means encrypting messages however hiding contents message hide fact message sent received particular site thus location network node sending andor receiving lot messages adversary monitor fact even adversary understand messages fact lot outgoing incoming messages reveals site network node sufficiently active make likely target objective paper address problem problem hide efficient manner site ie commandandcontrol center transmits receives lot data respectively sites network question addressed previously literature ch81 rs93 price polynomial communication overhead bit transmission per edge show amortized solution fixed preprocessing stage transmit arbitrary polynomialsize message anonymous fashion using bits link spanning tree every data bit transmission across link 12 general setting threat model consider network processorsstations processorstation list stations communicate restrict means communication ie could computer networks radiosatellite connections etc moreover restrict topology network general methodology work arbitrary network topology one several network nodes commandandcontrol center wishes send commands ie messages nodes network reiterate question addressing paper hide site broadcasting multicasting data subset processors network explore question must specify kind attack defending simple attack defend restricted adversary called outside adversary allowed monitor communication channels allowed infiltratemonitor internal contents processor network side remark weak attack easy defend processors simply transmit either noise encrypted messages communication channel noise indistinguishable encrypted traffic completely hides communication pattern course realistic adversary one considering paper internal adversary monitor communication stations addition also trying infiltrate internal nodes network consider adversary may mount sophisticated attack manages compromise security one several internal nodes network whereby capable monitoring external traffic pattern also capable examining every message data passes stored infiltrated node thus define internal klistening adversary adversary monitor communication lines sites also manages monitor internal contents k sites network similar definitions considered literature see example rs93 ckor97 references therein remark though paper restrict attention listening adversary monitors traffic try sabotage similar fgy93 kmo94 different objectives 13 comparison previous work one first works first one consider problem hiding communication pattern network work chaum ch81 introduced concept mix single processor network called mix serves relay processor p wants send message processor q encrypts using qs public key obtain 0 p encrypts pair using public key mix double encrypted message sent mix mix decrypts message get pair 0 q forwards 0 q work direction appear pf85 ppw91 sgr97 single mix processor secure single processor cooperating outside adversary processor serves mix compromised inform adversary messages forwarded hence chaum pointed sequence mixes must employed price additional communication computation moreover single mix scheme operates statistic assumption pattern communication case single message sent mix adversary monitors communication channels observe sender receiver particular message extension mix scheme presented rackoff simon rs93 embedded nelement sorting network depth polynomial logn mixes incoming messages requires polynomially many logn synchronous steps step every message sent one site network another site network thus message delay may proportional logn times diameter network statistic assumptions pattern communication somewhat relaxed rs93 introducing dummy communication every processor sends message simultaneously however number real dummy messages arriving destination available traffic analyzer rackoff simon also presented rs93 scheme copes passive internal adversaries use randomly chosen committees multiparty computation eg gmw87 bgw88 ccd88 cfgn96 ckor97 generally secure multiparty computation used hide communication pattern network see example gmw87 ch88 wp90 bgw88 ccd88 cfgn96 ckor97 via secure function valuation however anonymous communication restricted form hiding participants input hence may benefit less sophisticated efficient algorithms particular chaum suggested ch88 use dcnet approach order achieve anonymous communication approach similar dining cryptographers solution ch88 graph characterization random bits distribution given present specific choice efficient instance satisfies chaums graph characterization selecting small number keys processor procedure securely distribute keys use o1 amortized communication complexity link algorithm proven correct new argument proving bit communicated equal probability 0 1 particular adversary ch88 case anonymous sender considered work suggest schemes also cases receiver receivers respectively anonymous sender receiver anonymous ch88 assumed underlying communication networks ring backoff mechanism repeatedly used send data work consider problem anonymous communication spanning tree general graph communication network note solutions star tree networks briefly mentioned pf85 pw87 details way communication starts terminates specific networks contributions detailed design spanning tree communication network details include new scheme seeds selection ensures anonymity presence outside adversary klistening internal dynamic adversary schemes anonymous receiver well anonymous sender receiver specify initialization including seed distribution communication termination procedures preserve anonymity case spanning tree communication network addition use extra random sequence produced pseudo random generator shared sender receivers encrypt decrypt respectively message avoiding use additional different scheme encryption decryption transmission long messages new approach fits transmission long sequence bits video information several recipient thus used anonymous multicast multicast cable tv initialization scheme designed cope problem information revealed backoff mechanism see bb89 using predefined ordered transmission note work concern active adversary corrupt program forge messages links assumed wa89 extensions suggested wa89 design failstop broadcast instead assuming reliable broadcast network n processors algorithm preprocessing stage sends o1 bits tree link order transmit cleartext bit data processor computes pseudorandom bits transmission cleartext bit multiple anonymous transmission possible executing parallel several instances algorithm instance uses part bandwidth communication links algorithm secure outside adversary klistening internal dynamic adversary remark though considering eavesdropping listening adversary similar fgy93 kmo94 consider byzantine adversary tries actively disrupt communication gmw87 14 simple example subsection examine simple special case order illustrate issues considered solution special case stress though develop general framework works general case eg case general communication graph unknown receiver etc well suppose dealing network 9 nodes p1 gamma p2 gamma p3 gamma p4 gamma p5 gamma p6 gamma p7 gamma p8 gamma r r receiver node one p commandandcontrol center must broadcast commands r p j j 6 decoys used transmission purposes p r also used hide particular p real command control center simplified example wish hide adversary p real command control center sends messages r explain solution examine several inefficient natural consider simple strategies explain drawbacks communicationinefficient solution one simple inefficient way hide p commandandcontrol center every p broadcast encrypted stream messages r thus r receives 8 different streams messages ignores messages except real commandandcontrol center decrypts one every processor p forwards messages smallernumbered processors addition sends message clearly adversary monitoring communication channels also monitor internal memory one p actual commandandcontrol center know p j broadcasting actual message drawback notice instead one incoming message r must receive 8 messages thus throughput much information real commandandcontrol center send r 1of total capacity network becomes larger solution becomes even costly note solution enables receiver identify sender computationinefficient solution previous example drawback messages decoy commandandcontrol nodes taking bandwidth channel following solution show difficulty avoided order explain solution shall use pseudorandom generators 1 bm84 ha90 ill89 first pick 8 seeds pseudorandom generator give processor p seed processor p 1 stretches seed 1 long pseudorandom sequence sends time step next bit sequence processor p 2 processor p 2 takes bit got processor p 1 xors next bit pseudorandom sequence gs 2 sends p 3 forth processor p j real commandandcontrol center additionally xors bit sends bit actual message processor r given 8 seeds take incoming message message commandand control center xored 8 different pseudorandom sequences hence r compute 8 pseudorandom sequences subtract ie xor incoming message 8 pseudorandom sequences get original commandandcontrol message advantage solution p j commandandcontrol center r clearly deduce processor real center moreover entire bandwidth channel commandandcontrol processor receiver used send messages center receiver drawback receiver must compute 8 different pseudorandom sequences order recover actual message network size grows becomes prohibitively expensive terms computation receiver needs perform order compute actual message solution simple example present solution computation efficient communicationefficient secure adversary monitor communication lines additionally learn internal memory contents one intermediate processors seed distribution particular communication session follows pick 9 random seeds pseudorandom generator ffl give real commandandcontrol processor seed 0 ffl additionally give processor p 1 seed fs processor p 3 two seeds fs 3 4 g give processor p seeds fs g initial seed truly random bits deterministically expands long sequence pseudorandom bits many commercially available pseudorandom generators offtheshelf generator sufficiently secure efficient suffice ffl give receiver r one seed 0 suppose processor p 4 real commandandcontrol center distribution seeds follows transmission message performed fashion previous solution processor receives bitstream predecessor xors single bit pseudorandom sequence sends next processor commandandcontrol center xors bits message bit sends notice adjacent processors cancel one pseudorandom sequences xoring twice introduce new sequence example processor p 2 cancels 2 introduces 3 moreover processor must compute output three seeds yet easily verified adversary monitors communication lines addition learn seeds single processor p command control center gain information p real command control center even learning two seeds belong processor p course simplified example presented works provided adversary cannot monitor actual commandandcontrol center monitor memory contents receiver note restrictions resolved address paper moreover stressed restricted solution presented work adversary allowed monitor one decoy processor note solution requires commandandcontrol receiver special common seed 0 one obvious extension ensure every two processors distinct additional seed used communication point rest paper show scheme extended one robust adversaries monitor upto k stations solution every processor required compute number different pseudorandom sequences proportional k particular 2k 1 moreover also show generalize method arbitrarytopology networksinfrastructures additionally show initial distribution seeds done without revealing commandandcontrol center actual location commandandcontrol center hidden recipients messages well last show communication stations back commandandcontrol center could achieved without stations knowing node network center located totally anonymous communication achieved solutions vs publickey solutions simple solution privatekey solution assume protocol begins set seeds pseudorandom function must distributed private anonymous manner thus combine solution preprocessing stage distribute seeds using publickey solution solution assume usersnodes corresponding public private keys share information apriori thus overall solution publickey solution communication begins assume users share private data usual many cryptographic setting overall efficiency comes fact switch publickey private key solution show 1 make efficient privatekey implement 2 set private keys preprocessing stage using public keys anonymous private manner rest paper organized follows problem statement appears section 2 anonymous communication xortree algorithm heart scheme appears 3 section 4 5 sketch anonymous seeds transmission initialization termination schemes respectively extensions concluding remarks appear section 6 problem statement communication network described communication graph e nodes processors network edges graph represent bidirectional communication channels processors let us first define assumptions requirements used starting adversary models adversary passive listening adversary intervene computation particular neither forge messages links corrupt program processors ffl outside adversary adversary monitor communication links contents processors memory ffl internal dynamic klistening adversary inside adversary short adversary choose bug ie listen memory k processors targeted processors called corrupted compromised colluding processors corrupted processors reveal information know adversary however still behave according protocol adversary choose k faulty processors advance adversary corrupts less k processors adversary choose next processor corrupted using information adversary gained far processors already corrupted following assumptions used first phase algorithm responsible seeds distribution n processors publickeyprivatekey pair public key processor p known processors private key p known p anonymity communicating parties categorized four cases ffl anonymous non participating processors processor p wishes send message processor q without revealing rest processors inside outside adversary fact p communicating q ffl anonymous sender non participating processors p wishes receive message q without revealing identity processor including q well inside outside adversary ffl anonymous receivers non participating processors p wishes send multicast message without revealing identity processor well inside outside adversary ffl anonymous sender receiver non participating processors processor p wishes communicate processor without knowing identity processor without revealing identity processor including one communicating well inside outside adversary similar chatroom worldwideweb applications two processors wish communicate one another totally anonymously without revealing anybody else identity efficiency solution measured communication overhead number bits sent link order send bit cleartext data efficiency also measured computation overhead maximal number computation steps performed processor order transfer bit cleartext data algorithm combination anonymous seeds transmission initialization communication termination anonymous seeds transmission phase processors would like transmit anonymously send seeds pseudorandom sequence generators rest processors anonymous seeds transmission phase also resolves conflicts multiple requests transmission anonymous backoff mechanism seeds distributed communication started careful communication initialization termination procedure hide identity sender must performed first describe core algorithm communication phase communication phase seeds used production pseudorandom sequences anonymous seeds distribution presented following description anonymous communication phase 3 anonymous communication 31 computationinefficient solution communication algorithm designed spanning tree general communication graph relation parent child naturally defined election root start simple inefficient algorithm requires computation steps processor algorithm similar computationinefficient solution presented section 1 generaltopology graph show make computationefficient well computationinefficient solution sender chose distinct seed processor sender encrypt bit information using seeds processors including seeds seed used producing pseudorandom sequence details algorithm appear figure 1 symbol phi used denote binary xor operation note ith bit produced root result xoring twice every ith bits pseudorandom sequences except senders sequence sender communication upwards encrypted bit data xored receivers using senders seed reveal cleartext note scheme resilient number colluding processors long sender receivers nonfaulty simple scheme requires single node sender compute pseudorandom bits bit data remark contrast xortree algorithm requires computation ok pseudorandom bits cope outside adversary internal dynamic k listening adversary next lemma state communication computation complexities algorithm presented figure 1 lemma 31 next two assertions hold every bit data transmitted edge spanning tree ffl communication overhead algorithm o1 per edge ffl computation overhead algorithm pseudorandom bits computed processor per bit data proof time unit two bits sent link one upwards downwards since bit data sent every time unit possibly except first last h time units depth tree number bits sent link transmit bit data o1 second assertion follows fact sender computes greatest number pseudo random bits every time unit namely pseudorandom bits every time units seeds distribution ffl assign anonymously distinct seed processor p ffl assign sender seeds processors additional seed 0 ffl assign receivers additional seed seed 0 upwards communication p sender ffl let ith bit data l ith bits received children p 0 ith bit pseudo random sequence obtained additional seed 0 p j n ith bits pseudo random sequence obtained seeds ffl ith bit p j sends parent phi b 0 n p sender l ith bits received children p j j ith bit pseudo random sequence obtained seed ffl ith bit p communicants parent downwards communication ffl root processor calculates output parent sends result every children every processor root sends children every bit received parent ffl receivers decrypts downward communication xoring ith bit arrives parent ith bit pseudo random sequence obtained 0 figure 1 computation steps algorithm processor p j 32 towards ok solution choice seeds realization communication phase ok solution use nk seeds k less bn2 gamma 1c processor receives seeds describe seeds distribution decisions sender use k consists two layers seeds order processors arbitrary assigned indices use relation follows straight forward manner first level let l n seeds sender randomly chooses first level sender uses sequence seeds l 1 first layer first level l 1 1 second layer note l 1 2 obtained rotating seeds 1 1 lth level similarly lth level 1 l distinct seeds level l n seeds lth level uses two sequences l l l l l l l l lis obtained rotating l l l times receives seeds l il p receives seeds l thus end procedure every processor assigned 2k2 distinct seeds figure 2 choice seeds seeds distribution procedure appears figure 2 example choice seeds processors appears figure 3 seeds 9 00 figure 3 example distribution seeds 2 choice seeds made sender following properties ffl seed shared exactly two processors ffl every processor p p shares distinct seed every k1 processors immediately follow p least k1 processors rest processors including p n otherwise 33 xortree algorithm present main algorithm xortree algorithm xortree algorithm appears figure 4 34 abstract game subsection describe abstract game serve us analyzing proving correctness xortree algorithm presented previous subsection adversary get see outputs players adversary pick k players see seeds claim later prove adversary pick sender every one remaining n gamma processors picked adversary equally likely sender polybounded adversary 2 proceed showing assignment seeds yields special seed ds p processor p choose ds p seeds assigned nonfaulty processor p order processors index cyclic fashion processor follows ith processor 6 n processor index processor follows nth processor first processor assign new index processor sender index one processor follows sender index two forth new indices used interpretation next follows prior last description choice special seeds appears figure 6 recall overwhelming probability every two processors share one seed note special seeds selection described figure 6 special seeds known k faulty processors theorem 32 abstract game n gamma nonfaulty processors equally likely sender polybounded internal klistening adversary proof prove ith bit produced nonfaulty processors equally likely 0 1 polybounded adversary let p first nonfaulty processor follows sender p among first k processors follow sender let ds p 1 special seed sender shared nonfaulty processor p ith bit sender outputs result xor operation ith bit pseudorandom 2 adversary predict sender use adversary break pseudorandom generator seeds distribution ffl assign seeds processors described figure 2 ffl assign sender one additional seed 0 ffl assign receivers additional seed seed f sender 0 upwards communication sender ffl let ith bit data l ith bits received children p j 2k2 ith bits pseudorandom sequences obtained seeds p j ith bit pseudorandom sequence obtained additional seed 0 p j ffl ith bit p j sends parent 2k3 sender ffl ith bit p j communicants parent downwards communication ffl root processor calculates output parent sends result every children ffl every non root processor send children every bit received parent ffl receivers decrypts downward communication xoring ith bit arrives parent ith bit pseudo random sequence obtained 0 figure 4 xortree algorithm processor p j seeds assignment assign seeds processors described figure 2 assign sender one additional seed computation processor p uses seeds compute pseudorandom sequences ith time unit sender computes ith bit every pseudorandom sequences xors bits ith bit data outputs result time unit every processor p computes ith bit every pseudorandom sequences xors bits outputs result figure 5 abstract game sender p 1 k1 processors immediately follows sender shares exactly one seed sender since k colluding processors one k1 processors must nonfaulty pick p first nonfaulty processor assign ds p 1 special seed sender seed sender shares processors p among k last processors p among last processors p assigned 2k seeds seeds first layers k1 seed levels k1 seeds new appear processor prior p since k colluding processors one next k processors nonfaulty let q first nonfaulty processor assign ds p seed p shares q repeat procedure reach nonfaulty processor among last k processors processors q among k last processors note q new seeds since seeds assigned first processors least one k 1th level fortunately q shares single new seed every last processors fact allows us continue special seed selection procedure choosing seed shared next nonfaulty processor figure choice special seeds sequence among pseudorandom sequences obtained ds p 1 since p nonfaulty processor shares ds p 1 sender holds ith bit output sender equally likely 0 1 polybounded internal klistening adversary similar argument hold output p since exists special seed shared next nonfaulty processor q general holds output every nonfaulty processor argument holds nonfaulty processors sender thus polynomiallybounded kinternal external adversary distribution output indistinguishable identity sender fact adversary dynamic adversary implied corollary 33 proof corollary similar proof theorem 32 corollary 33 k 0 k adversary chooses k 0 faulty processors processors equally likely sender polybounded internal klistening adversary 35 reduction abstract game subsection prove algorithm reveals information identity sender tree exists algorithm reveals information identity sender abstract game reduction together theorem 32 yields proof correctness xortree algorithm assume adversary reveals information sender tree n processors abstract game n nodes mapped tree follows 1 processor abstract game assigned node tree 2 output every processor parent computed follows let hight processor p number edges longest path p p leaf p traverse root start processors hight ie leaves output processors assigned leaves tree changed ie identical output abstract game computed output processors hight h use computed outputs compute outputs processors hight h 1 let q processor hight h 1 l ith computed bits output children q let b q original ith output bit q abstract game computed output q b 1 phi b 2 phi figure 7 reduction theorem 34 xortree algorithm n gamma nonfaulty processors equally likely sender polybounded internal klistening adversary proof exists adversary reveals information identity sender tree exists abstract game number processors seeds distribution application reduction figure 7 yields communication pattern reveals information sender identity abstract game contradicts theorem 32 thus contradicts existence next lemma states communication computation overheads anonymous communication algorithm lemma 35 next two assertions hold every bit data transmitted edge spanning tree ffl communication overhead algorithm o1 per edge ffl computation overhead algorithm ok pseudorandom bits computed processor per bit data proof time unit two bits sent link one upwards downwards since bit data sent every time unit possibly except first last h time units depth tree number bits send link transmit bit data o1 second assertion follows fact time unit processor generates 2k anonymous seeds transmission first outline main ideas seeds transmission scheme give full details every processor publickey encryption known processors virtual ring defined euler tour tree used seeds transmission note indices processor used description related location virtual ring first processors send messages p 1 virtual ring processors wish broadcast send collection seeds processors wish broadcast send dummy messages equal length anonymous fashion p 1 know message processor k 1 chaums mixes ch81 used k real processors p 1 euler tour used mixes hence p 1 identify number nondummy arriving messages origin case one nondummy message reaches p 1 standard backoff algorithm initiated p 1 exactly one message containing collection seeds arrives p 1 seed distribution procedure described sending collection seeds p 1 used send seeds p 2 point processors know one processor wishes broadcast procedure repeated n times order allow anonymous sender transmit collection seeds every processor notice process quadratic size ring number colluding processors k length security parameter ie let g security parameter k send ogkn 2 bits per edge thus long message size p broadcasted greater ogkn 2 achieve o1 overall amortized cost per edge otherwise get ogkn 2 p amortized cost details follow seeds transmission procedure uses virtual ring r defined euler tour tree note edge appears exactly twice r therefore number edges nodes r 2 seeds transmission procedure starts transmission seeds first processor p 1 let l list processors r clockwise order starting p 1 indices 2 2n gamma 2 implied euler tour indices processors note single processor may appear l 1 use term instance appearance define reduced list rl 1 list processors obtained l 1 removing first instance processor thus rl 1 every processor appears exactly communication seeds uses anticlockwise direction define last l real processors first l processors rl 1 transmitting seeds p l rl last l processors defined analogously first stage every processor wants communicate another processor sends encrypted message seeds used p 1 note p 1 faulty processor thus careful transmission must carried let l list processors r anticlockwise order ie l 1 reversed order l 1 includes one instance processor p define active instance processor p l 1 last appearance p l 1 define active message message arrives active instance processor details anonymous seeds transmission p 1 appears figure 8 prove sequel information concerning identity requesting processors revealed anonymous seeds transmission p 1 except information concluded value n number processors would like transmit processors starts sending messages p 2 fashion similar one used send seeds p 1 processors sends seeds p 3 forth till processors send messages p n note n exactly one sender next communication session end seeds distribution procedure every processor holds seeds distributed sender lemma 41 coalition k colluding processors cannot reveal identity seeds distributors proof prove lemma transmission seeds sender p 1 note one last k1 real processors must nonfaulty p 1 nonfaulty information starts first processor send message n p 1 p n p n wants transmit data n contains seeds used p 1 otherwise n empty message ie message identified p 1 null message p n uses public last k processors n nested fashion first encrypting n pu 1 encrypting resulting message pu 2 p n sends k 1nested encrypted message k1 n processor next active instance p n l 1 non active message processor p receives non active message forwards message next processor according l 1 active message proceed describing actions taken processor upon arrival active message ffl first describe action taken processor p among last k1 real processors active message fm k1 arrives active instance p k 1encrypted message containing seeds used p 1 null message message received sends message next processor according l 1 ffl turn consider processor p among last k processors active message fm arrives using private key obtain fm g message p 1 public keys last processors p randomly orders set fm sends reordered set processor next according l 1 note following first reordering jth index j necessarily index sender arrival receives active message fm 1 every message finds number n processors would like transmit n 6 1 p 1 sends message value n traverses virtual ring upon receiving message processor wants transmit randomly chooses waiting time range say 1 2n procedure sending seeds p 1 repeated n figure 8 anonymous seeds transmission p 1 concerning identity seeds distributors revealed adversary otherwise p 1 faulty let p non faulty processor last reorder set fm upon arrival fm g since every arriving encrypted p public key set kfaulty processors decrypt originated faulty processor p randomly order set fm holds coalition k processors cannot reveal identity sender igamma1 fm g 5 initialization termination seed distribution procedure transmission data may start p n broadcasts signal tree notifies leaves start transmitting data leaves start sending data way ensures every nonleaf processor receives ith bit children simultaneously thus delay starting transmission particular leaf l proportional difference longest path leaf root distance l root non leaf processor waits receiving ith bit children uses bits seeds compute ith bit sends output parent note buffers used case processors completely synchronized sender terminate session sending termination message encrypted additional seed message decrypted root broadcast rest processors notify beginning new anonymous seeds transmission 6 extensions concluding remarks treatment far considered anonymous sender case also anonymous non participating processors simple modification algorithm support anonymous receiver case receiver plays role sender previous solution order communicate anonymous fashion additional seed sender sender uses scheme anonymous sender case seed sender got receiver achieve anonymous communication sender receiver anony mous following two participants p q would like communicate send anonymously distinct seeds p possible two participants send anonymously distinct seeds p 1 case p 1 broadcast processors two processors tried anonymously chat backoff mechanism used exactly two participants p q send seeds p 1 p 1 encrypt broadcast two seeds got seed encrypted using distinct intervals pseudorandom expansions two seeds seed hence two processors use seed reveal seed processor stage p q continue anonymously send seeds p procedure continues p set k seeds used encryption messages sent q used encryption messages sent p act senders using bit resulting xoring bits produced set k seeds bit special seed known receiver anonymous sender scheme backoff mechanism ensures one p q starts communication replay first allows ie stops transmitting data remark possible two participants similar scheme security algorithm derived fact must nonfaulty processor among processor therefore adversary know least one key used encrypt decrypt messages sender receiver acknowledgment thank oded goldreich ron rivest anonymous referees helpful remarks r detection disrupters dc protocol efficient probabilistic publickey encryption scheme hides partial information generate cryptographically strong sequences pseudorandom bits completeness theorems noncryptographic faulttolerant distributed computation adaptively secure multiparty computation randomness vs fault tolerance untraceable electronic mail return addresses digital pseudonyms multiparty unconditionally secure pro tocols dining cryptographers problem unconditional sender recipient untraceability achieving electronic privacy eavesdropping games graphtheoretic approach privacy distributed systems play mental game pseudorandom generators uniform assumptions pseudorandom generation oneway functions reducibility completeness multiparty private computations implement isdns without user observability marks network without user observability isdnmixes untraceable communication small bandwidth overhead anonymous connections onion routing unconditional sender recipient untraceability spite active attacks cryptographic defense traffic analysis tr generate cryptographically strong sequences pseudorandom bits networks without user observability play mental game dining cryptographers problem italicunconditional sender recipient untraceability completeness theorems noncryptographic faulttolerant distributed computation multiparty unconditionally secure protocols unconditional sender recipient untraceability spite active attacks detection disrupters dc protocol dining cryptographers disco cryptographic defense traffic analysis adaptively secure multiparty computation randomness vs faulttolerance art computer programming volume 1 3rd ed pseudorandom generator oneway function untraceable electronic mail return addresses digital pseudonyms isdnmixes anonymous connections onion routing ctr chinchen chang chiyien chung efficient protocol anonymous multicast reception information processing letters v85 n2 p99103 31 january nicholas hopper eugene vasserman effectiveness kanonymity traffic analysis surveillance proceedings 5th acm workshop privacy electronic society october 3030 2006 alexandria virginia usa steven seiden peter p chen r f lax j chen guoli ding new bounds randomized busing theoretical computer science v332 n13 p6381 28 february 2005 jiejun kong dapeng wu xiaoyan hong mario gerla mobile traffic sensor network versus motionmix tracing protecting mobile wireless nodes proceedings 3rd acm workshop security ad hoc sensor networks november 0707 2005 alexandria va usa
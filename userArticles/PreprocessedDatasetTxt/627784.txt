computation stable models integration logical query processing abstractthe wellfounded semantics stable model semantics capture intuitions skeptical credulous semantics nonmonotonic reasoning respectively represent two dominant proposals declarative semantics deductive databases logic programs however neither semantics seems suitable applications developed efficient implementation goaloriented effective query evaluation wellfounded semantics produces residual program subgoals relevant query contains facts true instances clauses body literals undefined instances paper presents simple method stable model computation applied residual program query derive answers respect stable models method incorporates forward backward chaining propagate assumed truth values ground atoms derives multiple stable models backtracking users able request stable models satisfying certain conditions computed prototype developed provides integrated query evaluation wellfounded semantics stable models ordinary prolog execution describe user interface prototype present experimental results b introduction significant progress made understanding declarative semantics deductive databases logic programs negation two dominant proposals wellfounded semantics 31 stable model semantics 13 normal logic program body rule conjunction literals wellfounded semantics characterized unique supported part national science foundation grant iri9212074 supported part national science foundation grant ccr9102159 threevalued model called wellfounded partial model well defined normal logic programs however wellfounded semantics inadequate dealing reasoning cases multiple alternative situations example 11 consider following program coveredcourse teachfaculty course wellfounded partial model every ground atom undefined thus providing useful information scenario described 2 wellfounded semantics normal logic programs extended van gelder 30 general logic programs body rule may arbitrary firstorder formula resulting semantics called alternating fixpoint logic 30 notion stable models 13 originated work autoepistemic logic 12 stable model represents set beliefs derived example 11 two stable models one john teaches cse 5381 mary teaches cse 5381 either case cse 5381 covered unlike wellfounded partial model stable models may exist given program eg p p even exist may unique recent research shows wellfounded partial model twovalued stable models two extreme cases threevalued stable models 9 22 26 wellfounded partial model coincides smallest threevalued stable model corresponds skeptical semantics includes beliefs true possible situations hand notion stable models captures credulous semantics concludes many beliefs possible normal logic program separate techniques developed query evaluation wellfounded semantics computing stable models wellfounded semantics constructive definition based upon least fixpoint construction functionfree programs polynomial time data complexity 31 addition direct extensions sldnf resolution 21 24 various mechanisms positive negative loop handling incorporated effective query evaluation wellfounded semantics 2 3 6 7 23 28 however extended directly stable model computation definition stable models requires guessing interpretation verifying stable model fact problem existence stable model logic program npcomplete 17 several proposals stable model computation 10 19 20 26 two aspects common one twovalued stable models computed surprising twovalued stable models represent credulous semantics allow incomplete information smaller search space computational point view common aspect ground programs processed however severe restriction practice since almost rules variables developed prototype system called slg logical query answering slg supports goaloriented query evaluation wellfounded semantics normal logic programs generally alternating fixpoint logic general logic programs latter important extension since standard translation general logic programs normal logic programs always preserve semantics either case slg polynomial time data complexity functionfree programs query undefined instances slg produces residual program besides true false instances query residual program processed compute twovalued stable models slg available anonymous ftp seassmuedu cssunysbedu applying stable model computation residual program query slg two advantages first answers query true wellfounded semantics always derived within polynomial time size database computed even efficiently program satisfies certain properties stratification importantly nonground programs queries handled second residual program query often much smaller original program approach slg restricts potentially expensive twovalued stable model computation small portion entire program furthermore threevalued stable models partially supported since original program may twovalued stable model even though portion program relevant query twovalued stable models main contributions paper threefold first describe simple assumeand reduce algorithm computing twovalued stable models finite ground program assumes truth values ground atoms whose negative counterparts occur program search space stable models reduced forward backward propagation assumed truth values ground atoms reduction program second show integrate query evaluation wellfounded semantics computation stable models two aspects noteworthy one handling negative loops delaying avoids redundant derivations also leads residual program needed stable model computation later forward chaining network set simplifying delayed literals derivation wellfounded semantics directly useful stable model computation finally due multitude stable models clear answers computed query introduce versatile user interface query evaluation respect stable models section 2 describes method stable model computation section 3 presents integration query evaluation wellfounded semantics section 4 contains examples performance analysis section 5 compares related work 2 computation stable models section reviews terminologies logic programs 16 notion twovalued stable models gelfond lifschitz 13 assumeandreduce algorithm described computing twovalued stable models finite ground programs 21 definition stable models atom form pt 1 nary predicate symbol 1 terms atom positive literal negative literal complements clause form head clause atom body clause literals definite clause clause negative literals body definite program set definite clauses ground atom literal clause program one variablefree herbrand universe program p set ground terms may constructed constants function symbols appearing p arbitrary constant added constant occurs p herbrand base p denoted b p set ground atoms predicates occurring p whose arguments herbrand universe p herbrand instantiation p possibly infinite set ground clauses obtained substituting terms herbrand universe variables clauses p set ground literals consistent ground atom denote p osi set positive literals negi set ground atoms whose complements partial interpretation interpretation consistent set ground literals total interpretation interpretation ground literal l true interpretation l 2 definition 21 13 let p program interpretation gelfondlifschitz transformation p respect denoted p program obtained herbrand instantiation p deleting ffl clause negative literal b body b 2 ffl negative literals b bodies remaining clauses b 2 total interpretation resulting program p definite program according 1 every definite program p unique minimal model denote mp definition 22 13 let total interpretation p logic program two valued stable model p coincides mp 22 derivation stable models derivation stable models consider finite ground programs application goaloriented query evaluation nonground logic programs discussed section 3 let p finite ground program restrict interpretations ground atoms occur p every ground atom occur p definitely false according definition 22 stable models p computed enumerating every possible total interpretation checking coincides unique minimal model mp p number possible total interpretations obviously exponential size herbrand base fortunately often mutual dependencies among ground atoms program used reduce search space speed computation stable models substantially 221 assuming negative literals first observation guess truth values ground atoms occurs p example 21 consider following ground program two negative literals teachmarycse5381 teachjohncse5381 occur program soon truth values determined truth value coveredcse5381 derived need make assumptions truth value coveredcse5381 reduces search space stable models 2 let n p denote set ground atoms occurs p lemma 21 let p ground logic program total interpretation stable model p interpretation j coincides mp j proof let total interpretation let j restriction n p lemma follows definition stable models 2 222 propagation assumed truth values truth values ground atoms n p independent either example 21 assume teachmarycse5381 true clause teachjohncse5381 deleted since body false according assumption hence teachjohncse5381 must false similarly teachmarycse5381 assumed false teachjohncse5381 derived true therefore necessary enumerate four possible truth assignments teachjohncse5381 teachmarycse5381 second observation assumed truth value ground atom used simplify program considered order reduce search space truth assignments ground atoms n p lead stable models let p finite ground program ground literal occurs p two possible choices either true true derive two programs p namely pa p simplified based upon assumption true pa p simplified based upon assumption true objective derive stable models p pa pa simplification program p based upon assumed truth value literal done way avoids generation models supported stable example 22 let p following program stable model p also perfect model case q true p false suppose p assumed true based upon assumption p true delete clause q since p false according assumption however assumption p true cannot used simplify away positive occurrence p body clause p otherwise would derive model fp qg stable model therefore simplified program p p contain one clause p p particular case assuming p true lead stable model since p false stable model p p inconsistent assumption hand suppose p assumed true simplified program pp contain one fact q assumption p true used delete clause p since body false according assumption 2 example 22 indicates assumed truth value ground atom used delete every clause whose body false every negative body literal true according assumption cannot used delete positive body literal assumed true definition 23 let p ground program l ground literal pl program obtained p deleting ffl every clause p whose body contains complement l ffl every occurrence l p l negative literal lemma 22 let p ground program ground atom total interpretation stable model p either true stable model pa true stable model pa proof suppose true p therefore stable model p stable model pa assume true compared gelfondlifschitz transformation simplification p pa also deletes clauses positive literal body therefore p identical pa except p may contains additional clauses positive literal body definition stable model p coincides mp since true must false mp therefore mp stable model p stable model pa 2 223 reduction program third observation simplification carried construction pl may determine truth values ground atoms propagated much possible reduce program stable models sought propagation allows us avoid choice points guessing truth values ground atoms whose values already determined previous assumptions example 23 let p following program left q q q u q r r suppose u assumed true program pu obtained p shown right propagation known truth values ground atoms leads partial interpretation namely fp q u vg much simpler program r case derived truth value u consistent assumption u true 2 propagation previously known assumed truth values essentially process forward chaining result partial interpretation reduced program definition 24 let p ground program u set ground atoms contains occurring p define ffl nonempty interpretation p osi set ground atoms contains fact negi set ground atoms u clause p head obtained p deleting every clause literal l body false every literal l bodies remaining clauses l true every clause head 2 p osi reduced exists interpretation p u u 0 notice p u reduced exists unique nonempty interpretation unique reduced u must exactly set atoms occurring p example 23 let u 0 fp q fp q vg contains following two clauses r u 1 fr ug another step reduction reduction possible since reduced definition 25 let p ground program set ground atoms occurring p p reduced interpretation program p 0 n 0 gamma gamma notice every finite ground program reduced interpretation possibly simpler program following lemma shows reduction preserves stable models lemma 23 let p finite ground program p reduced interpretation program p every stable model p equal j stable model j p vice versa furthermore p definite program p osi proof show every step reduction preserves stable models lemma follows simple induction suppose p k u k k1 consists ground atoms fact p k negi k1 consists ground atoms 2 u clause p k head let interpretation p osi interpretation j interpretation p osi stable model p k stable model p k1 2 reduction program respect partial interpretation differs simplification program according assumed truth value ground atom recall ground atom assumed true assumption cannot used delete occurrence program clause body literal hand reduction program p respect partial interpretation similar bottomup computation embodied transformation p 1 reduction however attempt compute wellfounded semantics derives literals true false respect clarks completion program instance following program cannot reduced framework reduction used stable model computation carried query evaluated wellfounded semantics interleaving computations stable models wellfounded semantics sense algorithm stable model computation call general procedure computing wellfounded semantics 23 assumeandreduce algorithm figure 1 shows assumeandreduce algorithm computing stable models finite ground program algorithm nondeterministic sense certain choices made point however stable models enumerated backtracking input finite ground program p output stable model failure begin let p reduced interpretation 0 program p 3 ai n npgm 4 n 6 begin 5 delete arbitrary element n 62 di 62 di begin choice point l either ai ai flg let pgml reduced interpretation program p inconsistent ai 62 di ground atom else begin 18 every occurs pgm add di return ai di stable model p figure 1 assumeandreduce algorithm computing stable models theorem 24 let p finite ground program interpretation stable model p returned execution assumeandreduce algorithm proof algorithm di represents set ground literals derived true possibly previous assumptions ai represents set ground literals assumed true algorithm explores tree search space stable models nondeterministic backtracking manner node represented triple ai dip gm terminates finite ground programs prove search space explored assumeandreduce algorithm complete initially root node search tree ai dip reduced 0 p 0 lemma 23 stable model p 0 j j stable model p 0 ie ai di j j stable model p gm given node v represented ai dip gm let ground atom n p ie occurs p neither ai di still p gm two choices either true true lemma 22 interpretation j stable model either true j j stable model p gma true j j stable model p gma let p gma p gma reduced interpretation program p p lemma 23 j stable model p gml l either j stable model p v two child nodes one ai ai fagdi arguments interpretation ai di j stable model j p gm l either l 2 j l stable model l p l stable model j l p l leaf node v represented ai dip gm search tree stable models either ai di inconsistent every 2 n p ai di latter case p gm contain negative literals furthermore p gm facts since reduced otherwise therefore stable model p gm also unique minimal model mp gm every ground atom occurring p gm false 2 ai 62 di ground atom must true either di mp gm inconsistent assumption ai true 2 24 backward propagation assumed truth values according definition stable models assumed truth values ground atoms coincide derived truth values assumeandreduce algorithm uses forward chaining propagate assumed truth values ground atoms propagation may derive truth values ground atoms need lay choice point guessing truth values incorporates backward propagation assumed truth values ground atoms certain conditions unlike forward propagation computes derived truth values ground atoms backward propagation assumptions may lead assumptions thus reducing search space stable models example 24 one application stable models provide semantics programs choice constructs 26 suppose three students taking ai class takesean ai takeirene ai takechris ai following ground program chooses exactly one student taking ai class chooseseanai diffseanai diffseanai chooseireneai diffseanai choosechrisai chooseireneai diffireneai diffireneai choosesean ai diffireneai choosechrisai choosechrisai diffchrisai diffchrisai chooseseanai diffchrisai chooseireneai three ground negative literals program suppose diffseanai assumed false backward propagation infer chooseireneai choosechrisai must assumed false three assumptions used simplify program following chooseseanai diffireneai chooseseanai diffchrisai chooseseanai reduction program derives diffireneai diffchrisai true 2 let p finite ground program slg supports backward propagation two situations ffl ground atom assumed true p contains exactly one clause head form every l 1 n assumed true ffl ground atom assumed false every clause p head single literal l body l assumed false backward propagation may repeated several times correctness backward propagation obvious according definition stable models assumeandreduce algorithm modified include backward propagation details omitted 3 integration computation wellfounded assumeandreduce algorithm deals finite ground programs computes two valued stable models section shows integrate computations wellfounded semantics stable models provide query evaluation nonground programs practical applications known logic programs without loops negation eg modularly stratified programs 25 wellfounded partial model total coincides unique stable model program case computation wellfounded semantics sufficient programs literals involved loops negation wellfounded partial model general threevalued discuss negative loops handled order facilitate computation stable models ensure polynomial time data complexity query evaluation wellfounded semantics time 31 handling negative loops negative loops occur due recursion negation two main issues namely detect negative loops treat literals involved negative loops query evaluation proceed example 31 consider following program 31 moveab moveba movebc movecd figure 2 shows portion sldnf tree query wina contains infinite branch negation 2 wina moveax winx winb winb moveby winy wina winc wina fail figure 2 sldnf tree wina simple mechanism negative loop detection associate call negative context approach adopted well 2 xoldtnf resolution 6 consider branch negation sldnf tree negative context call branch set ground negative literals encountered along path root call figure 2 initial call wina empty negative context negative context winb fwinbg negative context second call wina fwinb winag tree second call wina winb selected negative context wina indicating negative loop approach xoldtnf resolution 6 treat selected ground negative literal winb undefined general answer consists instance query atom also truth value indicating whether answer true undefined figure 3 shows portion xoldtnf forest query wina node labeled pseudoclause head captures bindings relevant variables accumulated truth value body contains literals yet solved call winbwinc winc winct winc winct movecz winz winct wind winct winat wina winat moveax winx call wina winat winb winbt winb winbt moveby winy call winb winb winbt wina winau winbt winc fail winbu call winbwina wina winat wina winat moveax winx winat winb winau figure 3 xoldtnf forest wina detection negative loops using negative contexts easy implement goaloriented query evaluation however associating call negative context prevents full sharing answers call across different negative contexts examples constructed subgoal may evaluated exponential number negative contexts 7 even though wellfounded semantics known polynomial time data complexity treating negative literals involved negative loops undefined appropriate query evaluation wellfounded semantics destroys mutual dependencies among negative literals query turns undefined wellfounded semantics little information used computation stable models 7 developed framework called slg resolution detects potential negative loops maintaining dependency information among calls incrementally call renaming variable evaluated allowing full sharing answers potential negative loop detected negative literals involved delayed literals body clause evaluated delayed literals may simplified later become known true false may returned part conditional answer otherwise figure 4 shows portion slg forest query wina vertical bar j separates delayed literals left remaining literals right body clause notice wina wina wina moveax winx wina winb wina winb fail figure 4 slg forest wina conditional answer wina namely wina winb similarly winb winb wina conditional answers constitute residual program assumeandreduce algorithm applied derive stable models answers original query stable model 32 simplification delayed literals given arbitrary fixed computation rule programs ground negative literals must delayed truth falsity known example 32 assume leftmost computation rule used solved respect following program p q r q p r r q p first negative loop involves p processed delaying p clause next body literal q selected leads second negative loop involving q delaying applied query evaluation proceed computation rule selects next body literal namely r clause whose evaluation results third negative loop involving r literal r clause literal clause r delayed point clause body literals delayed thus derive conditional answer namely p q r evaluation p q r continues leading negative loop involving p q r corresponding negative literals delayed computation continues positive loop detected among p q r become completely evaluated without answers false falsity p q r propagated derive true answer 2 facilitate simplification delayed literals slg sets forward chaining links among calls conditional answer derived truth value ground atom becomes known conditional answers delayed literals simplified delayed literals simplified wellfounded semantics general three valued query undefined instances wellfounded semantics evaluation produces residual program consisting relevant conditional answers well forward chaining links simplification delayed literals program query wina example 31 figure 5 shows residual program wina consists two conditional answers corresponding forward chaining links link winb wina indicates winb true false conditional answer wina simplified forward chaining links used directly slg computation stable models propagation assumed truth values ground atoms reduction residual program figure 5 residual program forward chaining links wina 33 general logic programs van gelder generalized wellfounded semantics normal logic programs alternating fixpoint logic general logic programs 30 slg resolution developed 7 extended goaloriented query evaluation general logic programs 4 similarly produces residual program corresponding forward chaining links queries undefined instances alternating fixpoint logic example 33 following program describes coloring nodes graph way two adjacent nodes cannot colored edgeab edgeba edgebc edgecd consider query colora resolving colora colora program clause obtain new clause colora literal edgeay selected corresponding positive subgoal edgeay evaluated completely one answer namely edgeab hence edgeay true distinct b return answer edgeay clause colora resolving universal disjunction 8 edgeay colory answer edgeab derive unit clause colorb clause colora replaced following clause colora colorb literal colorb selected new subgoal colorb created evaluated figure 6 shows slg forest resulted evaluation colora 8 represented disjunction represented notice colord derived true colorc derived false colora colorb undefined residual program consisting colora colorb processed stable model computation 2 colora colorb colorc colorc colorc allyedgecy colory colorc colord fail colord colord colord allyedgedy colory figure forest colora 34 stable models twovalued versus threevalued let p program q query slg first evaluates q respect wellfounded semantics p result includes set true false instances q general residual program p undq undefined instances q twovalued stable models residual program p undq derived using assumeandreduce algorithm however twovalued stable model p undq may may extended twovalued stable model p example 34 consider following simple program b b query b residual program b contains two clauses b b two stable models residual program one b true true however one b true cannot extended stable model original program even though threevalued stable model original program b true 2 general answers query computed slg answers respect threevalued stable models given program p slg enumerate possible threevalued stable models p compute twovalued stable models program p slg one may define new predicate calls predicates p distinct variables arguments evaluating new predicate distinct variables arguments slg derives residual program p und undefined atoms original program twovalued stable models p derived applying assumeandreduce algorithm p und 4 integration prolog normal logic programs obviously syntactically correct prolog programs even though execution prologs strategy may terminate one objectives slg system integrate query evaluation ordinary prolog execution existing prolog environments readily used knowledgebased applications section describes interface slg users point view 41 syntax syntax prolog used input programs additional directives predicate declara tions predicates declared tabled prolog tabled predicates evaluated using slg resolution prolog predicates solved calling prolog directly calls tabled predicates remembered table corresponding answers future calls tabled predicates renaming variants previous calls reevaluated satisfied using answers computed result previous calls actually legal tabled predicate call prolog predicate turn calls tabled predicate however two invocations tabled predicates share table prologs infinite loops terminated also certain constraints form clauses used define tabled predicates particular body clause tabled predicate conjunction literals cuts allowed body occurrence tabled predicate common uses cuts selection clauses according certain guard conditions supported tabled predicates clauses universal disjunction literals body allowed indicated operator gamma program example 33 written follows variables occur body universally quantified body disjunction indicated standard safety conditions assumed 32 determine body clause safe evaluate convert universal quantification existential quantification notion safety requires free variables body must bound negation body evaluated conjunction inside existential quantification variables negative literal must also occur positive literal accordingly require clause universal disjunction literals body head must ground clause used variables occur positive literals body also occur head negative literals body 42 query interface tabled predicates evaluated respect wellfounded semantics default true conditional answers returned example 41 following winning program prolog syntax tabling directive slg tabled win1 moveaa moveab moveba movebc initial default predicates prolog predicates unless declared otherwise default changed tabled users needed prolog interface also used queries following first query asks true answers wellfounded semantics second returns also conditional answers condition list delayed literals noby applying assumeandreduce algorithm residual program produced computation wellfounded semantics slg derives answers queries twovalued stable models residual program threevalued stable models original program see section 34 discussions general may multiple stable models residual program answers queries qualified corresponding stable model slg provides versatile interface query evaluation stable models residual program includes following predicates ffl stcallpsm stnotcallpsm succeeds call ground atom stable model psm call true false ffl stallcallansspsm computes stable model psm collects answers call list anss ffl stselectcallpsm0ansspsm similar stall3 except computes stable models ground literals psm0 true allows user select stable models satisfy certain conditions alternative stable models residual program corresponding answers call returned upon backtracking example 42 following program selects exactly one student course 26 tabled choose2 diff2 takeseanai takeireneai takechrisai takebraddb takeirenedb takejennydb samexx query selects stable models chooseseanaiand chooseirenedb true stselectchoosechooseseanaichooseirenedbansspsm no5 related work experimental results slg seems first work provides integrated query evaluation various semantics including wellfounded semantics stable models normal logic program alternating fixpoint logic general logic programs sldnf resolution prolog execution combination prologs programming environment slgs query processing capabilities makes easier develop knowledgebased applications delaying mechanism handling negative loops slg two important implications first avoids redundant derivations computation wellfounded semantics delayed literals simplified away needed using forward chaining links second allows slg produce residual program undefined instances query used directly stable model computation existing techniques query evaluation wellfounded semantics replace looping negative literals undefined truth value 2 3 6 use alternating fixpoint method compute possibly true false facts 28 either case little information saved later computation stable models goaloriented query evaluation respect stable models studied dung abductive framework 9 refinement eshghi kowalskis abductive procedure 11 ground negative literal assumed true lead inconsistency clear specialize abductive procedure compute answers valid wellfounded semantics pereira et al 19 developed derivation procedures goaloriented evaluation ground programs wellfounded semantics stable models bottomup procedure called backtracking fixpoint developed sacca zaniolo 26 nondeterministically constructs stable model one exists 15 stable models characterized transformation normal logic programs semantically equivalent positive disjunctive programs integrity constraints denial form atom b new atom negation b stable models constructed using model generation theorem prover mgtp bottomup forward chaining system starting set containing empty interpretation mgtp either expands interpretation according disjunctive clause discards interpretation violates integrity constraints methods construct stable models simultaneously include 10 20 29 work closely related branchandbound method subrahmanian et al 29 approach first computes fittings kripkekleene semantics time compacts program deleting parts program program processed compacted alternating fixpoint procedure computes wellfounded semantics resulting program used computation stable models using branchand bound method branchandbound method slg similar sense assume truth values atoms compact simplify program computation proceeds however several major differences first branchandbound method 29 computes stores stable models simultaneously number stable models exponential storing stable models time may require substantial amount memory slg hand computes alternative stable models backtracking second branch andbound method interleaves assumption truth value atom computation wellfounded semantics truth value atom assumed resulting program processed respect wellfounded semantics slg attempts reduce program way ground atoms true false clarks completion derived simpler fullfledged computation wellfounded semantics third branchandbound method intelligent choosing atom make assumption truth value selects atom leaf strongly connected component according dependency graph slg uses simple criterion namely atoms whose complements occur program assumed finally slg integrates query evaluation ordinary prolog execution accepts programs variables method 29 assumes finite ground program get rough idea slg performs took two benchmark programs reported 29 together timing information ran using slg pointed systematic study benchmark programs conducted clear picture relative performance various systems obtained prototype compiler 29 written c running unix environment decstation 2100 slg written prolog running sicstus prolog unix environment decstation 2100 timing information slg obtained prolog builtin predicate statistics timing data milliseconds first program consists following rules additional unary predicate used introduce constants program test program slg added following rules query mx evaluated calling stallmxansspsm failure loop used get answers call table 7 shows timing slg intelligent branchandbound 29 relative rate increase execution time slg seems closer rate increase number stable models execution time slg falls intelligent number constants 1 2 3 4 5 number stable models 4 branch bound 43 262 1413 9431 95766 figure 7 slg branchandbound enumerating stable models branch bound number constants reaches 5 probably due large number stable models stored latter second program also taken 29 follows augmented unary predicate whose sole purpose introduce constant symbols program slg added yx beginning body rule sx query sx evaluated calling stallsxansspsm failure loop used check possibilities table 8 shows timing information slg versus intelligent branch bound 29 case stable model program detected soon truth value px qx rx x assumed thus time spent computation wellfounded semantics number branch bound 54 117 198 303 431 586 755 972 1203 1475 figure 8 slg branchandbound checking nonexistence stable models notion stable models provides declarative semantics choice construct ldl 18 shown greco et al 14 certain classes programs choice data complexity computing stable model polynomial time choice construct used model variety applications one stable model needed 14 tested slg classical choice program 14 choosexy basexy choicexy translated normal logic program choosexy basexy diffchoicexy diffchoicexy choosexz sameyz samexx base relation contains set facts form baseia basei b basei c basei ranges 1 n n used parameter query choosex evaluated calling stallchoosexyansspsm measured time decstation 2100 computing first solution programs different sizes varying n 2 10 table 9 shows timing slg different values n execution time slg seems polynomial size base relation figure 9 slg computing first stable model slg currently implemented prolog meta interpreter 8 therefore carries significant overhead compiler implementation slg extending warren abstract machine carried xsb project led second author 27 xsb currently handles modularly stratified programs preliminary performance analysis shows xsb order magnitude faster slg 5 6 conclusion presented assumeandreduce algorithm computing stable models integration slg goaloriented query evaluation wellfounded semantics generally alternating fixpoint logic general logic programs synergism exemplified slg prolog one hand deductive query processing nonmonotonic reasoning offers ideal environment developing knowledgebased applications r contributions theory logic programming tabulated resolution well founded semantics query evaluation alternating fixpoint logic efficient topdown computation queries wellfounded semantics query evaluation well founded semantics slg system negation hypotheses abductive foundation logic programming computing stable models using atms abduction compared negation failure stratified autoepistemic theories stable model semantics logic programming greedy choice transforming abductive logic programs disjunctive programs foundations logic programming autoepistemic logic logical language data knowledge bases derivation procedures extended stable models truth maintenance system based stable models every logic program natural stratification iterated least fixed point model wellfounded semantics coincides threevalued stable se mantics controlling search bottomup evaluation procedural semantics wellfounded negation logic programs semantics deductive databases stable models nondeterminism logic programs nega tion xsb programmers manual alternating fixpoint logic programs negation wellfounded semantics general logic programs safety translation relational calculus queries tr ctr chris giannella john schlipf empirical study 4valued kripkekleene 4valued wellfounded semantics random propositional logic programs annals mathematics artificial intelligence v25 n34 p275309 1999 patrik simons ilkka niemel timo soininen extending implementing stable model semantics artificial intelligence v138 n12 p181234 june 2002 ilkka niemel logic programs stable model semantics constraint programming paradigm annals mathematics artificial intelligence v25 n34 p241273 1999 thomas eiter wolfgang faber nicola leone gerald pfeifer declarative problemsolving using dlv system logicbased artificial intelligence kluwer academic publishers norwell 2000 p bonatti resolution skeptical stable model semantics journal automated reasoning v27 n4 p391421 november 2001 francesco calimeri wolfgang faber gerald pfeifer nicola leone pruning operators disjunctive logic programming systems fundamenta informaticae v71 n23 p183214 august 2006 weidong chen david warren tabled evaluation delaying general logic programs journal acm jacm v43 n1 p2074 jan 1996 francesco calimeri giovambattista ianni template programs disjunctive logic programming operational semantics ai communications v19 n3 p193206 august 2006 marcello balduccini enrico pontelli omar elkhatib hung le issues parallel execution nonmonotonic reasoning systems parallel computing v31 n6 p608647 june 2005 franois bry adnan yahya positive unit hyperresolution tableaux application minimal model generation journal automated reasoning v25 n1 p3582 july 2000 v subrahmanian nonmonotonic logic programming ieee transactions knowledge data engineering v11 n1 p143152 january 1999 nicola leone gerald pfeifer wolfgang faber thomas eiter georg gottlob simona perri francesco scarcello dlv system knowledge representation reasoning acm transactions computational logic tocl v7 n3 p499562 july 2006 jrgen dix ulrich furbach ilkka niemel nonmonotonic reasoning towards efficient calculi implementations handbook automated reasoning elsevier science publishers b v amsterdam netherlands 2001
translating xslt programs efficient sql queries present algorithm translating xslt programs sql context virtual xml publishing single xml view defined relational database subsequently queried xslt programs xslt program translated single sql query run entirely database engine translation works large fragment xslt define includes descendantancestor axis recursive templates modes parameters aggregates put considerable effort generating correct efficient sql queries describe several optimization techniques achieve efficiency tested system 22 sql queries tpch database benchmark represented xslt translated back sql using translator b introduction xslt increasingly popular language processing xml data based recursive paradigm relatively easy use programmers accustomed functional recursive style pro gramming originally designed serve stylesheet map xml html increasingly used applications querying transforming xml data today xml data used enterprise applications originates relational databases rather stored na tively strong reasons change near future relational database systems offer transactional guar antees make irreplaceable enterprise applications come equipped highperformance query processors optimizers exists considerable investment todays relational database systems well applications implemented top language systems understand sql techniques mapping relational data xml well understood research systems xml publishing 2 8 10 15 shown specify mapping relational model xml translate xml queries expressed xmlql 7 xquery 3 sql paper present algorithm translating xslt programs efficient sql queries identify certain subset xslt translation possible rich enough express databaseslike queries xml data includes recursive templates modes parameters restrictions copyright held authorowners www2002 may 711 2002 honolulu hawaii usa acm 1581134495020005 aggregates conditionals large fragment xpath one important contribution paper identify new class optimizations need done either translator relational engine order optimize kind sql queries result translation argue xslt fragment described sufficient expressing databaselike queries xslt part experimental evaluation expressed 22 sql queries tpch benchmark 6 fragment translated sql using system cases could express queries fragment cases query generated xslt program turned significantly complex original tpch counterpart translations xml languages sql considered xml query languages like xmlql xquery distinction significant since xslt query language translation sql significantly complex reason huge paradigm gap xslts functional recursive paradigm sqls declarative paradigm easy translation possible fact easy construct programs xslt sql equivalent alternative translation always possible interpret xslt program outside relational engine use rdbms object repository example xslt interpreter could construct xml elements demand issuing one sql query every xml element needs assume formulate sql query retrieve xml element given id implementation would end reading materializing entire xml document time also approach would need issue multiple sql queries single xslt program slows interpretation considerably odbc jdbc connection overhead contrast approach generates single sql query entire xslt program thus pushing entire computation inside relational engine preferred solution makes single connection database server enables relational engine choose best execution strategy particular program example consider xslt program xsltemplate match xslapplytemplate xsltemplate xsltemplate matchpersonnamesmith xslvalueof selectphonetext xsltemplate program makes recursive traversal xml tree looking person called smith returning phone interpret program outside relational engine need beers name price drinkers name age astrosign drinkers sign frequents drinker bar bars name serves bar beer likes drinker beer figure 1 relational schema beersdrinkersbars doc drinkers astrosign beers price barname name beername name bars name age figure 2 xml view beersdrinkersbars sue sql query retrieve root element one sql query child find person element etc naive approach xslt interpretation ends materializing entire document approach convert entire xslt program one sql query query depends particular mapping relational data xml assuming mapping resulting sql query select personphone person order magnitudes faster naive ap proach addition exists index name database relational engine improve performance organization paper follows section 2 provide examples xslt sql translation illustrate main issues section 3 describes architecture translator section 4 describes various components detail discuss optimizations done produce efficient sql queries section 5 section 6 presents results experiments tpch benchmark queries sections 7 8 discuss related work conclusions 2 examples xslt sql translation illustrate example xslt sql translations highlighting main issues go along fragment xslt translated us become clear throughout section illustrate queries wellknown beersdrinkers bars database schema adapted 17 shown figure 1 assume exported xml shown figure 2 notice redundancy exported xml data example bars accessible either directly drinkers beers assume xml document unordered support xslt expressions check order input example beers drinkers form unordered collection possible extend techniques ordered xml views q2 select beersname beers q2 select beername drinkers likes beers drinkersnamelikesdrinker likesbeerbeersname figure 3 find beers liked drinker beyond scope furthermore consider ele ment attribute text nodes xml tree omit discussion kinds nodes comments processing instructions 21 xpath xpath 5 component xslt translation sql must handle example xpath docdrinkersname returns drinkers equivalent sql select drinkersname drinkers less obvious example consider query figure 3 two sql queries q2 q2 0 q2 correct translation p2 returns beers p2 returns beers liked drinker indeed p2 q2 0 semantics particular q2 0 preserves multiplicities beers way p2 q2 0 much expensive q2 since performs two joins q2 simple projection cases optimize q2 0 replace q2 namely following conditions satisfied every beer liked least one drinker user specifies duplicates answer moved case p2 q2 semantics system optimize translation construct q2 instead q2 0 one optimizations consider section 5 xpath fragment supported system includes entire language except constructs dealing order reference traver sals example navigation axis like ancestororself supported followingsibling 22 xslt templates modes basic xslt program collection template rules template rule specifies matching pattern mode presence modes allows different templates chosen computation arrives node figure 4 shows xslt program returns every drinker age less 25 pairs drinker name beers price 10 likes program 3 modes first mode default mode drinkers age less 25 selected second mode mode 1 drinkers beers priced less 10 selected third mode result elements created general templates modes also used modularize program corresponding sql query also shown 23 recursion xslt xslt xpath traverse xml tree recursively consider xpath expression barname retrieves bar names absence xml schema information impossible express query sql need navigate arbitrarily deep xml document 1 however case xml data 1 sql implementations support recursive queries xsltemplate matchdrinkersage 25 xsltemplate matchbeersprice result xslapplytemplate select name mode2 xsltemplate matchname mode2 select drinkersname likesname drinkers likes beers drinkersage 25 likesdrinker likesbeer figure 4 xslt program using modes every drinker age less 25 return pairs drinker name beers price less 10 likes xsltemplate matchdrinkersname brian xslapplytemplate selectdrinkers mode1 xslparam namesign selectastrosign xsltemplate matchdrinkers mode1 xslparam namesign xslvariable namecurrsign selectastrosign xslif testsign currsign result xslvalueof selectname drinkers drinkers1 drinkers drinkers2 astrosign astrosign1 astrosign astrosign2 figure 5 drinkers astrosign brian generated relational databases resulting xml document nonrecursive schema unfold recursive programs nonrecursive ones using schema fig 2 unfolded xpath expression drinkersbeersbarname recursion also expressed xslt templates given nonrecursive xml schema recursion also eliminated introducing additional xslt templates modes describe general technique section 41 24 variables parameters xslt xslt one bind value parameter one part tree use part sql becomes join operation correlating two tables example consider query figure 5 finds drinkers astrosign brian parameter used pass value brians trosign matched every drinkers astrosign example value stored variable parameters single node general store nodesets specified us express xslt programs generate recursive sql queries work xsltemplate matchdrinkers result xslvalueof selectminbeersprice select drinkers2name minbeers4price drinkers drinkers2 likes likes3 beers beers4 likes3drinker likes3beer group drinkers2name figure every drinker find minimum price beer likes ing xpath instance also results another template call analogous temporary tables sql translation xslt sql supports possible values taken variables 25 aggregation xslt sql support aggregates significant difference xslt aggregate operator applied subtree input sql applied group using group clause consider query figure 6 finds every drinker minimum price beers likes xslt simply apply min subtree sql group drinkersname glimpse difficulties involved translating aggre gates consider query figure 7 every age returns cheapest price beers liked people age xslt first find ages age apply min node set case subtree correct sql translation xslt program shown next followed incorrect translation difference subtle xslt collect ages multiplicities three persons 29 years old three results 29 wrong sql query contains single entry correct sql query additional groupby attribute name ensuring age occurs correct number times output see also discussion section 6 26 xslt constructs apart already mentioned translation also supports ifelse foreach case constructs foreach construct equivalent iteration using separate template rules case construct equivalent multiple statements 27 challenges translation xslt fragment sql poses major challenges first need map functional programming style declarative style templates correspond functions call graph needs converted sql state ments second need cope general recursion xpath level xslt templates possible gen eral always possible xml document generated relational database case third parameters add another source complexities typically need converted joins values different parts xml tree finally xsltstyle aggregation needs converted sqlstyle aggregation often involves introducing group clauses sometimes complex conditions clause figure 8 illustrates complex example aggregation xsltemplate matchage xslvariable namecurrage result xslvalueof selectmindocdrinkersage currage beersprice correct sql select drinkers2age minbeersprice drinkers likes beers drinkers2 likesbeer group drinkers2age drinkers2name incorrect sql select drinkersage minbeersprice drinkers likes beers likesbeer group drinkersage figure 7 every age find minimum price beer liked drinker age xsltemplate matchdrinkers xslapplytemplate selectbeersprice mode1 xslwithparam namepriceset selectbeersprice xslwithparam namedrinkername selectname xsltemplate matchprice mode1 xslparam namepriceset selectdefault1 xslparam namedrinkername selectdefault2 xslvariable namecurrprice xslvariable namecurrbeer xslvalueof select xslif testcurrpriceminpriceset result xslvalueof selectdrinkername xslvalueof selectcurrbeer xslvalueof selectcurrprice select drinkersname likes3beer beers4price drinkers beers beers6 likes likes5 beers beers4 likes likes3 likes3name likes3beer likes5name likes5beer group beers4name drinkers2name likes3beer beers4price likes3name figure 8 cheapest beer price every drinker parameters query finds every drinker cheapest beer likes price notice major stylistic difference xslt sql xslt compute minimum price bind parameter search beer price retrieve name sql use clause orthogonal translation challenge per se address quality generated sql queries automatically generated sql queries tend redundant unneces querier tagger rdb schema view tree query sql tuples sql generator optimizer qtree generator parser view output tree figure 9 architecture translator sary joins typically selfjoins 16 optimizer eliminating redundant joins difficult implement since general prob lem called query minimization npcomplete 4 commercial databases systems query minimization expensive users write sql queries require minimization case automatically generated sql queries however easy overshoot create many joins part challenge system avoid generating redundant joins 3 architecture figure 9 shows architecture translator xml view defined relational database using view tree 10 xml view typically consists entire database also subset export subset view relational database also include redundant information view never computed instead kept virtual view tree defined system accepts xslt programs virtual xml view translates sql several steps first parser translates xslt program intermediate representation ir ir dag directed acyclic graph templates unique root template default mode template matches leaf node contributes programs result path root leaf node corresponds sql query final sql query union queries path translated first query tree qtree qtree generator qtree represents multiple possible overlapping navigations xml document together selection join aggregate conditions various nodes explained section 42 sql generator plus optimizer takes qtree input generates equivalent sql query using xml schema rdb schema view tree sql generator described section 44 optimizations discussed section 5 querier easy task takes generated sql query gets resulting tuples rdb result tuples passed onto tagger similar 15 produces output user format dictated original query functionality querier tagger straightforward focus hence discussed xsltemplate matchdrinkers xslvariable namenamevar xslvalueof selectname xslif testnamevarbrian xslapplytemplate selectdrinkers mode1 xslparam namebeerset selectbeers xsltemplate matchdrinkers mode1 xslparam namebeerset selectdefaultbeerset result xslvalueof selectname xslvalueof selectcountbeersname beerset figure 10 find drinker n pairs n number beers brian drinker likes 4 translation use running example program figure 10 retrieves number beers every drinker likes common brian begin describing xslt program parsed internal representation ir reflects semantics program functional style proceed describe qtree abstract representation paths traversed program view tree qtree represents single path traversal useful intermediate representation purposes translating xml tree traversals sql describe representation xml view relational data view tree finally show combine information qtree view tree generate equivalent sql query 41 parser output parser intermediate representation ir xslt query besides strictly syntactic parsing module also performs sequence transformations generate ir first converts xslt program functional representation template mode expressed function figure 11 shows running example add extra functions represent builtin xslt template rules figure 11b match resulting program xml schema extracted view tree match wildcards stantiated navigations parentchild expanded simple parentchild navigation steps valid navigations retained shown sequence figures 11 c e cases may multiple matches figure 12 illustrates example expansion figure 12 b end result running example ir shown figure 13 case result single call graph cases template calls one template conditionally ifthenelse case constructs unconditionally shown figure 14 semantics queries union possible paths lead start template return node shown figure 14 end procedure one inde pendent straightline call graphs follows demonstrate convert straightline call graph sql query sql query whole xslt program union individual sql queries 42 qtree qtree simulation xml schema succinctly describes computation done query qtree abstraction captures three components xml query f1drinkers beers countbeersname beerset simplified functional form f1drinkers beers countbeersname beerset b extended builtin templates f1drinkers beers countbeersname beerset c function duplication f1drinkers beers countbeersname beerset xpath expansion f1 drinkersdrinkers beers countbeersname beerset function call matching figure 11 various stages leading ir generation query figure 10 path taken query xml document b conditions placed nodes data values along path c parameters passed function calls corresponding three elements xml query qtree following components query fragment fn beersdefaultbeers b xpath expansion figure 12 query fragment complex xpath expansion f0root f0drinkers f1drinkers return select drinkers condition name brian select drinkers params beers arguments param1 select name params figure 13 ir query figure 10 figure 14 complex call graph decoupling 1 tree tree representing traversal select xpath expressions applytemplate used nodes tree labeled tag xpath component hence node tree associated node xml schema entities part output marked 2 condition set collection conditions query includes conditions specified explicitly using xslif construct also includes predicates xpath expressions 3 mapping parameters parameter result another xslt query nodeset given xpath expres sion scalar value natural way representing using nested qtrees approach take note conditions inside nested qtree might refer entities nodes parameters outer qtree figure shows qtree call graph figure 10 three qtrees figure q1 main qtree corresponding xslt program pointers two qtrees q2 q3 correspond two nodeset parameters passed program logic encapsulated xslt program follows 1 start root node 2 traverse drinkers named brian beersbeername passed parameter point 3 starting root traverse drinkers 4 traverse one level name perform aggregation nodeset beers steps correspond main qtree query q1 note step 3 query starts root go drinkers separate drinker node instantiated since query could referring drinker different current one root multiple instances drinker child nodes qtrees also created every nodeset example second parameter return call countbeername represented qtree q3 predicate condition xpath parameter represented qtree refers p1 defined q1 abstraction qtree general enough also used xml query languages like xquery xmlql qtree powerful succinct representation query computation independent language query expressed moreover conversion qtree sql also independent query language 43 view tree view tree defines mapping xml schema relational tables choice view tree representation borrowed silkroute 10 view tree defines sql query node xml schema figure 16 shows view tree beersdrinkersbars schema right hand side rule interpreted sql query rule heads eg drinkers denote table name arguments denote column name argument two tables represents join value query xml schema node depends ances tors example figure 16 sql beername depends drinkers bars correspondingly sql query child node always superset sql query parent put another way given sql query parent node one construct query child node adding appropriate tables constraints discussed later representation crucial avoid redundant joins hence generate efficient sql queries 44 sql generation section explains generate sql qtree using view tree explained qtree represents traversal nodes original query constraints placed query nodes idea generate sql query clauses corresponding traversals constraints three step process first nodes qtree bound instances relational tables second appropriate constraints generated using binding first step intuitively first step generates part sql query join constraints due tree traversal second step generates explicitly specified constraints finally bindings return nodes used generate select part next describe steps name drinkers drinkers beers name q3 beers name root name condition q1 select drinkersname countq2 drinkers drinkers2 q2 likesbeer likes likesbeer q3 q3 likesbeer likes condition figure 15 qtree example query left mappings sql right 1 drinkersname age astrosignnameastrosign 2 beersbeername price beersbeername price 3 barsbarname barsbarname frequentsdrinkername barname 4 beersbeername drinkername 5 beernamebeername barname frequentsdrinkername barname barsbeername drinkername figure view tree beersdrinkersbars schema figure 441 binding qtree nodes binding associates relational table column pair qtree node table column pair treated value binding step updates list tables required clause implicit tree traversal constraints clause carry binding top manner avoid redundant joins node bound ancestors bound bind node instantiate new versions table present view tree sql query child tables constraints presented sql parent repeated node bound appropriate table name using table renamings required field using sql information view tree end result binding node n bindings nodes lie path root n value association n form tablenamefieldname list tables included clause implicit constraints due traversal 442 generating clause recall explicit conditions encountered query traversal stored qtree step conditions anded select drinkersname count likesbeer likes likesbeer likesbeer likes drinkers drinkers2 figure 17 sql qtree q1 figure 15 together along constraints generated binding step condition represented qtree boolean tree expressions leaves expressions converted constraints recursively traversing expression step 1 constant expression used verbatim 2 pointer qtree node replaced binding 3 pointer qtree ie expression node set replaced nested sql query generated calling conversion process recursively pointed qtree 443 generating select clause values columns table bound return nodes form select part sql query return node pointer qtree handled mentioned query generated used subquery figure 15 shows mapping three qtrees example sql steps figure 17 shows sql generated algorithm q1 steps 45 eliminating join conditions intersecting briefly explain choice view tree representation helps eliminating join conditions two paths qtree nodes lie paths must value one simple approach would two bind two paths independently common node add equality conditions represent fact values paths example consider simple query retrieves drinkers younger 25 figure shows qtree query take approach binding nodes independently adding sql constraints following sql drinkers age name condition age 25 figure 18 qtree drinkers age less 25 query select drinkers3name drinkers2 drinkers3 drinkers2age 25 approach however first iterate common node drinkers node add conditions leads better sql query shown select drinkersname drinkers drinkersage 25 redundant join elimination becomes important complex queries many nodes lie multiple paths root leaves 5 optimizations automated query generation susceptible generating inefficient queries redundant joins nested queries optimizations unnest subqueries eliminate joins nec essary optimizations described generalpurpose sql query rewritings could done op timizer three reasons address first optimizations specific kind sql queries result translations therefore may missed general purpose optimizer second experience one popular commercial database system showed indeed optimizer perform finally optimizations described preserve semantics general semantics preserved special context xslt sql translation hence cannot done generalpurpose optimizer 51 nested queries optimization applies predicate expressions form b b nodeset subquery applied expression present conjunction conditions default sql generation algorithm section 44 generate sql query nodeset b optimization would unnest subquery whether query unnested depends properties nodeset b three possibilities 1 b singleton set simplest case one safely unnest query change multiplicity whole query figure 19 illustrates case note astrosign xpath expression nodeset determine nodeset singleton set use following test view tree information regarding whether node multiple values relative parent specifying node qtree nodeset xml schema must singleton set query find name drinkers leo unoptimized drinkers leo select astrosignsign astrosign optimized drinkers astrosign figure 19 unnesting subquery representing singleton set query subquery q2 figure 15 unoptimized likesbeer likes likesbeer select likesbeer likes likesdrinker drinkers2name optimized likesbeer likes likes2 likes2beer figure 20 unnesting subquery duplicates 2 b duplicates subquery duplicates query evaluate true values set b hence one unnest query without changing multiplicity figure 20 illustrates case example query used previous section determine nodeset duplicates use following test qtree nodeset node except leaf node distinct set intuition siblings nodes parent document unique edge leaf edge uniqueness leaves returned query guaranteed 3 b duplicates nodeset duplicates example beers discussed section 21 unnesting query might change semantics multiplicity resultant query change condition b evaluates true unnest query 52 unnesting aggregate operators using groupby optimization unnests subquery uses aggregation using groupby outer level optimization applied expressions form op b b nodeset op aggregate operator like sum min max count avg observation nested query evaluated every iteration outer query get semantics unnest query groupby iterations outer query groupby iterations outer query add keys tables query q1 figure 15 q2 used optimized version shown figure 20 unoptimized sql q1 select drinkersname countq2 drinkers drinkers2 optimized sql q1 select drinkersname countlikes2drinker drinkers drinkers2 likes likes2 likes2beer group drinkersname drinkers2name figure 21 illustrating groupby optimization clause outer query groupby clause aggregate condition moved clause sql groupby clause must fields selected query hence fields select clause also added groupby clause outer query already uses groupby optimization applied also implies qtree optimization used implementation take simple choice applying optimization first time figure 21 illustrates case example query used previous section 53 qtree reductions optimization transform qtree long paths unreferenced intermediate nodes shortened shown figure 22 helps eliminating redundant joins optimization done binding phase binding node checked see shortcut path root node exists shortcut path possible intermediate node path referred part qtree except immediate child parent node path condition referring intermediate node intermediate node one child incorrect create shortcut path also view tree must specify shortcut possible rules use bind node shortcut taken edge shortened nodes bound rest algorithm proceeds observed optimization also helps making final sql query less sensitive input schema example beersdrinkersbars schema beers top level node instead child node drinkers query would obtained without reduction optimization 6 experiments section try understand well algorithm translates xslt queries sql queries implemented algorithm java using javacc parser 11 evaluation done using tpch benchmark 6 queries manually translate benchmark sql queries xslt generating sql queries xslt queries using algorithm process try gauge strengths limitations algorithm study impact optimizations described section 5 observe effects semantic differences xslt sql tpch benchmark established transaction processing council tpc industrystandard decision support qtree qtree reduction root beers drinkers name root beers name figure 22 qtree reduction query beersname test designed measure systems capability examine large volumes data execute queries high degree complex ity consists 22 business oriented adhoc queries queries heavily use aggregation sophisticated features sql tpch specification points queries complex typical queries 22 queries 5 require creation intermediate table followed aggregation fields equivalent xslt translation would require writing two xslt programs second one using results first possible framework described section 4 current implementation supports parameters bound fragments input tree computed atomic values support parameters bound constructed tree queries translated sql query intermediate table cases major part overall query xslt another modification made aggregates multiple fields like sumab taken aggregate single new field sumc algorithm generated efficient sql queries cases quite complex detailed table describing result translation individual queries presented appendix present summary results queries single aggregation level nonleaf groupby converted tpch like nesting structure number joins queries 2 3 queries reason inefficiency extra joins groupby semantic mismatch xslt sql discussed 3 1 query inefficient groupby semantic mismatch presence nested query 4 1 query used case statement sql select generated union two independent sql queries 5 2 queries required aggregation xslt output trans lation fully supported current implementation hand generation led similar sql queries 6 5 queries required temporary tables mentioned observed able convert xslt temporary tables efficient sql many queries translated efficiently original sql version required grouping intermediate output artifact translation algorithm due languagelevel mismatch xslt sql xslt query identical result cannot written queries appropriate extensions xslt support groupby one generate queries identical results coincidence issue mentioned future requirements draft xslt 12 61 utility optimizations section describe utility three opti mizations mentioned section 5 obtaining efficient queries 1 unnesting subqueries section 51 4 queries benefitted optimization case nodeset multiple distinct values 2 unnesting aggregations section 52 21 queries form aggregation optimization useful 3 qtree reduction section 53 13 queries qtree reduction useful optimization frequent many queries would related node deep schema without placing condition parent nodes qtree reduction efficient queries generated independent xml schema 7 related work silkroute 10 8 xml publishing system defines xml view relational database accepts xmlql 7 queries view translates sql xml view defined view tree abstraction borrowed translation xmlql sql declarative languages makes translation somewhat simpler xslt translation xquery sql described 14 uses different approach based intermediate representation sql generic technique processing structurally recursive queries bulk mode described 1 instead using generic tech nique leveraged information present xml schema elimination related query pruning described 9 sql query block unnesting intermediate language discussed 13 context starburst system 8 conclusions described algorithm translates xslt sql necessity system applies fragment xslt translation possible full language express programs sql equivalent cases program needs split smaller pieces translated sql translation based representation xslt program query tree encodes possible navigations program xml tree described number optimization techniques greatly improve quality generated sql queries also validated system experimentally tpch benchmark acknowledgments thankful jayant madhavan pradeep shenoy helpful discussions feedback paper dan suciu partially supported nsf career grant 0092955 gift microsoft alfred p sloan research fellowship 9 r unql query language algebra semistructured data based structural recursion xperanto publishing objectrelational data xml xquery 10 xml query languagexml path language xpath optimal implementation conjunctive queries relational data bases xml path language xpath query language xml efficient evaluation xml middleware queries optimizing regular path expressions using graph schemas silkroute trading relations xml requirements extensible rulebased query rewrite optimization starburst efficiently publishing relational data xml documents database theory xml first course database systems tr extensiblerule based query rewrite optimization starburst first course database systems query language xml silkroute efficient evaluation xml middleware queries database theory xml optimizing regular path expressions using graph schemas efficiently publishing relational data xml documents querying xml views relational data unql query language algebra semistructured data based structural recursion optimal implementation conjunctive queries relational data bases ctr zhen hua liu agnuel novoselsky efficient xslt processing relational database system proceedings 32nd international conference large data bases september 1215 2006 seoul korea chengkai li philip bohannon p p narayan composing xsl transformations xml publishing views proceedings acm sigmod international conference management data june 0912 2003 san diego california ce dong james bailey static analysis xslt programs proceedings fifteenth australasian database conference p151160 january 01 2004 dunedin new zealand rajasekar krishnamurthy raghav kaushik jeffrey f naughton unraveling duplicateelimination problem xmltosql query translation proceedings 7th international workshop web databases colocated acm sigmodpods 2004 june 1718 2004 paris france rajasekar krishnamurthy raghav kaushik jeffrey f naughton efficient xmltosql query translation add intelligence proceedings thirtieth international conference large data bases p144155 august 31september 03 2004 toronto canada wenfei fan jeffrey xu yu hongjun lu jianhua lu rajeev rastogi query translation xpath sql presence recursive dtds proceedings 31st international conference large data bases august 30september 02 2005 trondheim norway mustafa atay artem chebotko dapeng liu shiyong lu farshad fotouhi efficient schemabased xmltorelational data mapping information systems v32 n3 p458476 may 2007 jixue liu millist vincent querying relational databases xslt data knowledge engineering v48 n1 p103128 january 2004 artem chebotko mustafa atay shiyong lu farshad fotouhi xml subtree reconstruction relational storage xml documents data knowledge engineering v62 n2 p199218 august 2007 sven groppe stefan bttcher georg birkenheuer andr hing reformulating xpath queries xslt queries xslt views data knowledge engineering v57 n1 p64110 april 2006 james bailey transformation reaction rules data web proceedings sixteenth australasian database conference p1723 january 01 2005 newcastle australia
survey combinatorial gray codes term combinatorial gray code introduced 1980 refer method generating combinatorial objects successive objects differ prespecified small way notion generalizes classical binary reflected gray code scheme listing nbit binary numbers successive numbers differ exactly one bit position well work 1960s 1970s minimal change listings combinatorial families including permutations combinationsthe area combinatorial gray codes popularized herbert wilf invited address siam conference discrete mathematics 1988 subsequent siam monograph combinatorial algorithms update 1989 posed open problems variations theme resulted much recent activity area problems posed wilf solvedin paper survey area combinatorial gray codes describe recent results variations trends highlight open problems b introduction one earliest problems addressed area combinatorial algorithms efficiently generating items particular combinatorial class way item generated exactly many practical problems require solution sampling random object combinatorial class worse exhaustive search objects class whereas early work combinatorics focused counting 1960 clear aid computer would feasible list objects combinatorial classes leh64 however order listing possible even objects moderate size combinatorial generation methods must extremely efficient common approach try generate objects list successive elements differ small way classic example binary reflected gray code gil58 gra53 scheme listing nbit binary numbers successive numbers differ exactly one bit advantage anticipated approach twofold first generation successive objects might faster although many combinatorial families straightforward lexicographic listing algorithm requires constant average time per element families linear extensions performance achieved gray code approach pr94 secondly application hand likely combinatorial objects differ small way associated feasible solutions differ small computation example nw78 nijenhuis show use binary gray code speed computation permanent aside computational considerations open questions several areas mathematics posed gray code problems finally perhaps one main attractions area gray codes typically involve elegant recursive constructions provide new insights structure combinatorial families term combinatorial gray code first appeared jww80 used refer method generating combinatorial objects successive objects differ prespecified usually small way however origins minimal change listings found early work gray gra53 wells wel61 trotter tro62 johnson joh63 lehmer leh65 chase cha70 ehrlich ehr73 nijenhuis wilf nw78 work campanologists whi83 article origins binary gray code heath describes telegraph invented emile baudot 1878 used binary reflected gray code hea72 according heath baudot received gold medal telegraph universal exposition paris 1978 thomas edison alexander graham bell examples combinatorial gray codes include 1 listing permutations consecutive permutations differ swap one pair adjacent elements joh63 tro62 2 listing kelement subsets nelement set way consecutive sets differ exactly one element ber76 bw84 ehr84 em84 nw78 rus88a 3 listing binary trees consecutive trees differ rotation single node luc87 lrr93 4 listing spanning trees graph successive trees differ single edge hh72 cum66 5 listing partitions integer n successive partitions one part increased one one part decreased one sav89 6 listing linear extensions certain posets successive elements differ transposition rus92 pr91 sta92 wes93 7 listing elements coxeter group successive elements differ reflection csw89 gray codes found applications diverse areas circuit testing rc81 signal encoding lud81 ordering documents shelves los92 data compression ric86 statistics dh94 graphics image processing asd90 processor allocation hypercube hashing fal88 computing permanent nw78 information storage retrieval ccc92 puzzles chinese rings towers hanoi gar72 recent variations combinatorial gray codes generation problems considered difference successive objects although fixed required small example problem listing permutations consecutive permutations differ every location wil89 problem generating objects combinatorial class exactly successive objects differ prespecified way formulated hamilton pathcycle problem vertices graph objects two vertices joined edge differ prespecified way graph hamilton path required listing combinatorial objects exists hamilton cycle corresponds cyclic listing first last items also differ prespecified way since problem determining whether given graph hamilton path cycle npcomplete gj79 efficient general algorithm discovering combinatorial gray codes frequently gray code problems however associated graph possesses great deal symmetry specifically may belong class vertex transitive graphs graph g vertex transitive pair vertices u v g automorphism oe g v example permutations differing adjacent transpositions give rise vertex transitive graph ksubsets nset differing one element wellknown open problem due lovasz whether every undirected connected vertex transitive graph hamilton path lov70 thus schemes generating combinatorial gray codes many cases provide new examples vertex transitive graphs hamilton paths cycles hope gain insight general open questions also unknown whether connected cayley graphs subclass vertex transitive graphs hamiltonian many gray code problems especially involving permutations associated graph cayley graph although many gray code schemes seem require strategies tailored problem hand general techniques unifying structures emerged paper jww80 considers families combinatorial objects whose size defined recurrence particular form general results obtained constructing gray codes families ruskey shows rus92 certain gray code listing problems viewed special cases problem listing linear extensions associated poset successive extensions differ transposition direction discovery gray code frequently gives new insight structure combinatorial class involved area combinatorial gray codes includes many questions interest com binatorics graph theory group theory computing including wellknown open problems although steady progress area past fifteen years recent spurt activity traced invited address herbert wilf siam conference discrete mathematics san francisco june 1988 generalized gray codes wilf described results open problems also reported siam monograph wil89 open problems gray codes posed wilf wil89 solved well several related problems intention follow work paper give brief survey area combinatorial gray codes describe recent results variations trends highlight new old open problems paper organized sections follows 1 introduction 2 binary numbers variations 3 permutations 4 subsets combinations compositions 5 integer partitions 6 set partitions restricted growth functions 7 catalan families 8 necklaces variations 9 linear extension posets 10 acyclic orientations 11 cayley graphs permutation gray codes 12 generalizations de bruijn sequences 13 concluding remarks remainder section discuss notation terminology used throughout paper gray code listing class combinatorial objects called maxmin first element list lexicographically largest class last element lexicographically smallest gray code cyclic first last elements list differ way prescribed successive elements list adjacency criterion many situations graph associated particular adjacency criterion bipar tite sizes two partite sets differ one graph cannot hamilton cycle thus gray code listing objects corresponding vertices least given adjacency criterion case say parity problem exists algorithm exhaustively list elements class c called loopfree worst case time delay listing successive elements constant algorithm called listing first element total time required algorithm list elements n total number elements class c term cat coined binary reflected b balanced c maximum gap noncomposite 00000 11000 00000 10111 00000 00101 00000 01001 01000 10000 00111 00100 00111 00010 01011 00010 figure 1 examples 5bit binary gray codes frank ruskey stand constant amortized time per element finally note gray code combinatorial class intrinsically bound representation objects class sets b two alternative representations class c bijections ff b closeness ffx ffy need imply closeness fix fiy gray codes necessarily preserved bijection examples seen several families including integer partitions set partitions catalan families binary numbers variations gray code binary numbers listing nbit numbers successive numbers including first last differ exactly one bit position best known example binary reflected gray code gil58 gra53 described follows l n denotes listing nbit numbers l 1 list 0 1 n 1 l n formed taking list l ngamma1 prepending bit 0 every number following list reverse l ngamma1 bit 1 prepended every number example shown figure 1a since first last elements l n also differ one bit position code fact cycle implemented efficiently loopfree algorithm ber76 note binary gray code viewed hamilton cycle ncube practice gray codes certain additional properties may desirable see gln88 survey example note elements l n scanned lowest order times whereas highest order bit changes twice counting return first element certain applications necessary number bit changes uniformly distributed among bit positions ie balanced gray code required see figure 1b example vs80 uniformly balanced gray codes shown exist n power two wagner west ww91 general suggested proved ls81 vs80 rc81 recently shown using robinsoncohn construction rc81 balanced gray codes exist n following sense let b2 n nc b2 n nc gamma 1 even n 1 cyclic nbit gray code bit position changes either applications requirement maximize gap gray code defined gln88 shortest maximal consecutive sequence 0s 1s among bit positions see figure 1c example gln88 gap 4 best possible report construction gapnn goes 1 n goes infinity gg another variation noncomposite nbit gray codes requires contiguous subsequence correspond path kcube noncomposite gray codes constructed n ram90 see figure 1d example ram90 new constraint considered sw95 define density binary string number 1s string clearly gray code binary strings list nondecreasing order density however suppose requirement relaxed somewhat call gray code monotone runs density levels two time consecutive pairs strings densities densities figure 2 monotone gray code n shown sw95 monotone gray codes constructed n example shown figure 2 boolean lattice subsets set inclusion let h n denote hasse diagram b n correspondence ng bijection nbit binary numbers subsets n bijection binary gray code corresponds hamilton path h n vertices h n partitioned level sets contains ielement subsets n monotone gray code hamilton path h n edges levels must precede edges levels j figure 3 monotone gray codes applications theory interconnection networks providing embedding hypercube linear array minimizes dilation directions sw95 section 4 discuss relationship middle two levels problem fix binary string ff let bn ff set clean words ff ie nbit strings contain ff contiguous substring subgraph ncube induced bn ff hamilton path ie gray code bn ff squire shown answer yes ff written string property nontrivial prefix fi also suffix fi otherwise parity phi phi phi phi phi phi phi phi gammaphi phi phi phi phi phi phi phi delta figure 3 hamilton path h 5 corresponding monotone gray code figure 2 problems infinitely many n squ96 natural consider extension binary gray codes mary gray codes shown jww80 using generalization binary reflected gray code scheme always possible list cartesian product finite sets successive elements differ one coordinate similar result obtained ric86 coordinate allowed assume values fixed range results clean words mary gray codes squ96 leaves open case odd another listing problem binary numbers posed doug west involves change underlying graph view nbit string subset ng natural bijection g call two sets adjacent differ one element increases 1 one element decreases 1 element 1 deleted problem determine whether hamilton path corresponding graph called augmentation graph nn gamma 12 even parity argument shows hamilton path otherwise question open n 7 consider another criterion two binary strings adjacent differ either 1 rotation one position left right 2 negation last bit underlying graph shuffleexchange network hamilton path would gray code binary strings respecting adjacency criterion existence hamilton path shuffleexchange graph longstanding open problem recently established feldman mysliwietz fm93 fre79 fredman considers complexity issues involved generating arbitrary subsets set nbit strings successive strings differ one bit calls quasigray codes establishes bounds tradeoffs resources required generate successors using decision assignment tree model computation permutations algorithms generating permutations surveyed sedgewick sed77 efficiency considerations provided motivation several early attempts generate permutations way successive permutations figure 4 johnsontrotter scheme generating permutations adjacent transpositions figure 5 generating permutations derangements due lynn yarbrough differ exchange two elements gray code permutations shown possible several papers including boo65 boo67 hea63 wel61 described sed77 one disadvantage algorithms elements exchanged necessarily adjacent positions shown independently johnson joh63 trotter tro62 possible generate permutations transpositions even two elements exchanged required adjacent positions recursive scheme illustrated figure 4 inserts permutation list element n n possible positions moving alternately right left left right contrary approach problem require permutations listed one differs predecessor every position derangement problem posed independently rab84 wil89 existence list n 6 3 established met85 using jacksons theorem jac80 constructive solution presented ew85 simpler construction ascribed lynn yarbrough discussed rs87 yarbroughs solution illustrated figure 5 works follows take permutation johnsontrotter list append n rotate resulting permutation one position time n possible cyclic shifts final twist swap last two cyclic shifts straightforward argue successive permutations differ every position using property johnsontrotter list successive permutations differ adjacent transpositions generalize problems generating permutations one extreme adjacent transpositions extreme derangements consider following given n k satisfying n k 2 possible list permutations successive permutations differ exactly k positions shown possible unless put89 sav90 listing cyclic shown rs94a positions successive permutations differ could required contiguous putnam claims put90 k even odd permutations even permutations generated kcycles elements contiguous positions putnams kcycles need form interesting question arose connection problem hamilton cycles cayley graphs see section 11 possible generate permutations doubly adjacent transpositions ie successive transpositions neighboring pairs pair considered neighbor johnsontrotter scheme satisfies requirement n 3 listing shown possible chris compton phd thesis com90 might hoped could result efficient permutation generation algorithm would become unnecessary decide adjacent pairs transpose whether next transposition left right current one however current form comptons algorithm practical quite complex even simplifications cw93 problem generating permutations multiset adjacent interchanges introduced lehmer motel problem leh65 shows parity problems always possible becomes possible however interchanged elements required adjacent ko ruskey give cat algorithm generate multiset permutations according criterion kr92 4 subsets combinations compositions since bijection subsets nelement set nset nbit binary numbers binary gray code defines gray code subsets two binary numbers differing one bit correspond two subsets differing addition deletion one element subclass combinations ksubsets nset fixed k several gray codes surveyed wil89 observed ber76 gray code combinations extracted binary reflected gray code nbit numbers delete binary reflected gray code list elements corresponding subsets exactly k elements remains list ksubsets successive sets differ exactly one element see figure 6a compare figure 1a list generated revolving door algorithm nw78 described revolving door b strong minimal change c adjacent interchange figure examples gray codes combinations simple recursive expression stringent requirement list ksets strong minimal change property em84 kset represented sorted ktuple elements successive ksets differ one position see figure 6b eades mckay shown listing always possible earlier solution reported chase cha70 perhaps restrictive gray code proposed combinations generate ksubsets nset successive sets differ exactly one element element either increased decreased one called adjacent interchange property since sets represented binary ntuples successive ntuples may differ interchange 1 0 adjacent positions see figure 6c however always possible shown ksubsets nset generated adjacent interchanges k0 1 n even k odd cases parity problems prevent adjacent interchange generation bw84 ehr84 hr88 rus88a shown chase cha89 simpler construction rus93 combinations generated successive elements differ either adjacent transposition transposition two bits single 0 bit several open problems paths levels hasse diagram boolean lattice b n notorious middle two levels problem attributed kt88 dejter erdos trotter others havel kelley middle two levels b 2k1 number elements induce bipartite vertex transitive graph k k 1 element subsets 2k 1 question whether hamilton cycle middle two levels b 2k1 first glance would appear one could take gray code listing ksubsets successive elements differ one element taking unions successive elements create list 1subsets alternating lists would give walk middle two levels graph unfortunately hamilton path least known gray code ksubsets graph formed middle two levels connected undirected vertextransitive graph thus either hamilton path provides counterexample lovasz conjecture one approach problem considered try form hamilton cycle union two edgedisjoint matchings dsw88 shown hamilton cycle middle two levels cannot union two lexicographic matchings however matchings may work new matchings middle two levels defined kt88 dks94 largest value k hamilton cycle known exist figure 7 example 3 unpublished work done moews reid using computer search mr speed search used necklacebased approach gambling would hamilton path necklaces could lifted hamilton cycle original graph feel focus middle two levels necklace poset described section 8 promising approach middle two levels problem least good lower bound length longest cycle middle two levels boolean lattice since graph vertextransitive result babai bab79 shows cycle length least 3nk 12 nk total number vertices middle two levels b 2k1 result dejter quintana gives cycle length improved sav93 figure 7 hamilton cycle middle two levels b 7 welcome breakthrough felsner trotter showed existence cycles length least 025nk ft95 monotone gray code described section 1 contains subpath path middle two levels length least 05nk sw95 sw95 strengthened get nearly hamilton cycles following sense every ffl 0 h 1 hamilton cycle exists middle two levels b 2k1 h cycle length least 1 gamma ffln k midlevels b 2k1 k 1 since hamilton cycles known 1 k 11 construction guarantees cycle length least 0839nk middle two levels b 2k1 k 1 variation problem antipodal layers problem values k hamilton path among ksets sets ng n two sets joined edge one subset results limited values k n given hur94 sim composition n k parts sequence nonnegative integers whose sum n traditionally viewed placement n balls k boxes nijenhuis asked first edition nw78 p 292 problem 34 whether possible p 7 figure 8 gray codes various families integer partitions generate kcompositions n obtained predecessor moving one ball box another knuth solved 1974 reading galleys book kli82 klingsberg gives cat implementation knuths gray code combinations compositions simultaneously generalized follows let denote set ordered ttuples set scombinations telement set x multiset consisting copies element collection selement submultisets combinations x ehr73 ehrlich provides loopless algorithm generate multiset combinations successive elements differ two positions necessarily sigma1 positions shown rs95 gray code still exists two position change sigma1 thereby generalizing gray code results combinations compositions 5 integer partitions partition integer n sequence positive integers x 1 satisfying algorithms generating integer partitions standard orders lexicographic antilexicographic presented fl80 nw78 performance algorithms fl80 analyzed fl81 integer partition standard representation also written list pairs distinct integers appearing sequence number times appears ruskey notes rus95 lexicographic listing partitions ordered pairs representation property successive elements list differ last three ordered pairs asked following question regarding gray code integer partitions standard representation way list partitions integer n way consecutive partitions list differ one part increased 1 one part decreased 1 may decrease 0 part size 0 may increase 1 yoshimura demonstrated possible integers sav89 shown constructively possible n result bit general n k 1 way list set p n k partitions n integers size k gray code order unless n gray code maxmin consequence following also listed gray code order n partitions n whose largest part k 2 partitions n k fewer parts 3 partitions n exactly k parts see figure 8a gray code listing p7 6 exponents figure indicate number multiple copies approach sav89 decompose partitions problem p n k subproblems two forms p form form original problem new form shown p forms could recursively defined terms smaller versions forms thereby yielding doubly recursive construction partitions gray code algorithm implemented bee90 modified run time ojp n kj strategy applied yield gray codes families integer partitions set partitions n parts size k parts required congruent 1 modulo ffi p n k 2 elements p ffi n partitions n odd parts size k shown rsw95 p ffi n listed successive partitions one part increases ffi ffi ones may appear another part decreases ffi ffi ones may disappear see figure 8b gray code maxmin unless n maxmin gray code impossible case dn k set partitions n odd parts size k strategy applied construction becomes complex surprisingly still possible list dn gray code order successive partitions one part increases two one part decreases two rsw95 see figure 8c gray code maxmin unless n 12 6 cases maxmin gray code impossible one observation follows work although bijections sets partitions n odd parts partitions n distinct parts bijection preserve gray codes techniques used investigate gray codes families integer partitions family quirks small number cases must handled specially subsets needed linking recursively listed pieces become empty never theless conjecture following families gray code enumeration arbitrary values parameters n partitions n distinct odd parts b distinct parts congruent 1 modulo ffi c copies part parts congruent 1 modulo ffi copies part e exactly distinct parts 6 set partitions restricted growth functions set partition decomposition ng disjoint union nonempty subsets called blocks let sn denote set partitions ng example s4 shown figure 9a restricted growth functions rg functions length n denoted rn strings nonnegative integers satisfying wellknown bijection sn rn 2 sn order blocks according smallest element example blocks would ordered f1 2 7g f3 5 6 8g f4 10 11g f9g label blocks order 0 bijection assigns string as4 bl4 c knuths modified eehrlichs lexicographic gray code knuth algorithm order figure 9 listings s4 r4 label block containing associated string 2 4 bijection illustrated first two columns figure 9 kay76 kaye gives cat implementation gray code sn attributed knuth wil89 another problem posed nijenhuis wilf book nw78 p 292 problem 25 solved knuth reading galleys gray code successive set partitions differ one element moved adjacent block figure 9c however associated rg functions may differ many positions ruskey rus95 describes modification knuths algorithm one element moves block two away successive partitions associated rg functions differ one position two figure 9d call gray code rg functions strict successive elements differ one position position sigma1 strict gray codes rn considered early paper ehrlich shown infinitely many values n exist ehr73 nevertheless ehrlich able find efficient listing algorithm rn loop free following interesting property successive elements differ one position element position change 1 largest element string change 0 conversely 0 change largest value v string v 1 example conversely associated list set partitions change corresponds moving one element adjacent block partition first last blocks considered adjacent figure 9e ehrlichs results generalized rs94b set restricted growth tails n k strings nonnegative integers satisfying 1 k 1maxfa 1g variation n used wil85 ranking unranking set partitions note n rn parity problems k infinitely many values n n strict gray code one one position changes 1 however gray codes satisfying ehrlichs relaxed criterion constructed made cyclic maxmin properties possessed earlier gray codes consider set partitions fixed number blocks n set partitions ng exactly b blocks bijection sn rn restricts bijection b n ehrlich paper presents loopfree algorithm generating b n successive partitions differ two elements moved different blocks ehr73 ruskey describes gray code r b n cat implementation successive elements differ one position possibly 1 position rus93 shown rs94b general r b n strict gray code even relaxed criterion ehlich remains open whether strict gray codes rn n parity difference 0 7 catalan families several families combinatorial objects size counted catalan numbers defined n 0 include binary trees n vertices sw86 wellformed sequences 2n parentheses sw86 triangulations labeled convex polygon bijections known members catalan family gray code one member family gives implicitly listing scheme every member family however resulting lists may look like gray codes since bijections need preserve minimal changes elements problem generating binary trees given number nodes considered several early papers including rh77 zak80 zer85 however gray codes catalan family first considered pr85 binary trees represented strings balanced parentheses shown pr85 strings balanced parentheses could listed consecutive strings differ interchange one left one right parenthesis example could follow problem considered rp90 additional restriction adjacent left right parentheses could interchanged example could follow could follow result rp90 balanced strings n pairs parentheses generated adjacent interchanges n even n 5 cases cat algorithm given different minimal change criterion focusing binary trees considered luc87 lrr93 list binary trees n nodes consecutive trees differ left right rotation single node rotation operation common data structures used restructure binary search trees preserving ordering properties shown gray code always possible generated efficiently lrr93 intricate construction lucas able show associated graph hamiltonian luc87 giving cyclic gray code happens particular bijection binary trees n nodes set triangulations labeled convex polygon vertices rotation binary tree corresponds flip diagonal triangulation stt88 results luc87 lrr93 also give listing triangulations polygon successive triangulations differ flip single diagonal 8 necklaces variations nbead kcolor necklace equivalence class kary ntuples rotation figure lists lexicographically smallest representatives nbead kcolor necklaces n asked possible generate necklaces effi ciently possibly constant time per necklace proposed solution fkm algorithm fredricksen kessler maiorana proven upper bound better onk n fk86 fm78 ws90 new algorithm presented time complexity onn n n n k number nbead necklaces k colors subsequently tight analysis original fkm algorithm showed could fact implemented run time n giving optimal solution rsw92 neither algorithms gives gray code necklaces representatives binary nbead necklaces listed successive strings differ one bit position figure 10 parity argument shows impossible even n odd n question remains open however case necklaces fixed number 1s wang showed intricate construction construct gray code successive necklace representatives differ swap 0 1 wan94 ws94 figure 11 remains open whether necklaces fixed number 1s generated constant amortized time either modification fkm algorithm gray code method gray code adjacency criterion generalized necklaces k 2 beads requiring successive necklaces differ exactly one position position 1 conjecture done nk odd parity problems 5bead binary b 7bead binary c 3bead ternary figure 10 examples gray codes necklaces prevent gray code nk even necklaces fixed weight possible list nbead kcolor necklaces weight w successive necklaces differ exactly two positions one increased one decreased one know counterexamples construct slightly different set objects call two kary strings equivalent one rotation reversal equivalence classes relation called bracelets lisonek lis93 shows modify necklace algorithm ws90 generate bracelets know gray code bracelets open whether possible generate bracelets constant amortized time beads distinct colors bracelets rosary permutations har71 rea72 define new relation r nbead binary necklaces xry member x becomes member changing 0 1 one bit position reflexive transitive closure r partial order resulting poset necklace poset k 0 middle two levels poset consisting necklaces density k k number elements bipartite subgraph induced middle two levels hamilton path graph vertextransitive may encapsulate hard part middle two levels problem described section 4 necktie n bands k colors equivalence class kary ntuples reversal 7 beads 4 ones 9 beads 3 ones 8 beads 4 ones figure 11 examples gray codes binary necklaces fixed number ones necktie identified lexicographically smallest element equivalence class wang wan93 shows n 3 gray code exists either n k odd result two neckties adjacent differ one position position sigma1 modulo k results neckties appear rw94 9 linear extension posets partially ordered set set together binary relation reflexive transitive antisymmetric linear extension poset permutation elements poset consistent partial order x x j partial order j problem efficiently generating linear extensions poset order studied kv83 ks74 vr81 area gray codes linear extensions poset introduced frank ruskey rus88b pr91 setting generalize study gray codes combinatorial objects example hasse diagram poset consists two disjoint chains one length length n onetoone correspondence linear extensions poset combinations objects chosen poset consists collection disjoint chains linear extensions correspond multiset permutations examples described rus92 study existence gray codes ruskey constructs transposition graph corresponding given poset vertices linear extensions poset two vertices joined edge differ transposition resulting graph bipartite rus88b ruskey makes conjecture whenever parity difference one graph poset hamilton path conjecture shown true special cases rus92 including posets whose hasse diagram consists disjoint chains series parallel posets pr93 techniques successful far involve cutting linking together listings various subposets rather intricate ways many cases known list linear extensions transpositions also possible require adjacent transpositions although possibly complicated construction pr91 rs93 sta92 wes93 shown linear extensions poset q jqj even listed adjacent transpositions linear extensions qjp poset p sta92 qjp represents union posets p q additional relations fp qg however problems area remain open example even hasse diagram poset consists single tree parity difference may greater one makes inductive approach difficult hasse diagram consists two trees odd number vertices parity difference one unknown whether linear extensions listed case problem also open posets whose hasse diagram grid tableau tilted ninety degrees rus calculating parity difference difficult ruskey rus several examples posets parity difference unknown parity differences calculated kr88 recently stachowiak shown computing parity difference pcomplete sta even counting number linear extensions poset open problem specific posets example boolean lattice sk87 brightwell winkler recently shown problem counting number linear extensions given poset p complete bw92 brighter side pruesse ruskey pr94 found cat algorithm listing linear extensions successive extensions differ one two adjacent transpositions canfield williamson cw95 shown make loopfree pr93 pruesse ruskey consider antimatroids posets special case analogous case linear extensions poset show sets antimatroid listed successive sets differ two elements particular gives listing ideals poset successive ideals differ one two elements orientations undirected graph g acyclic orientation g function edges g assigns direction u v v u edge uv g way resulting digraph directed cycles consider problem listing acyclic orientations g successive list elements differ orientation single edge hard see g tree n edges listing corresponds n bit binary gray code g k n acyclic orientation corresponds permutation vertices johnsontrotter gray code permutations provides required listing acyclic orientations denote aog graph whose vertices acyclic orientations g two vertices adjacent corresponding orientations differ orientation single edge graph aog bipartite connected long g simple edelman asked whenever partite sets size whether aog hamiltonian shown ssw93 answer yes several classes graphs including trees odd length cycles complete graphs odd ladder graphs chordal graphs hand parity difference shown one several cases including cycles even length complete bipartite graphs k mn n 1 n even problem appears difficult even open whether aok mn hamiltonian mn odd however square aog hamiltonian g pr95 sz95 squ94c means acyclic orientations listed successive elements differ orientations two edges problem counting acyclic orientations pcomplete lin86 open question whether cat algorithm generate fastest listing algorithm known due squire squ94b requires average time per orientation n number vertices graph linear extensions acyclic orientations problems simultaneously generalized follows simple undirected graph g subset r edges g fix acyclic orientation oe r edges r let aor g subgraph aog induced acyclic orientations g agree oe r r bipartite graph hamiltonian whenever parity difference allows acyclic orientations graph g aor g becomes linear extensions adjacency graph n element poset p oe r defined covering relations p contrast situation linear extensions acyclic orientations square aor g necessarily hamiltonian counterexamples appear squ94c pr95 cayley graphs permutation gray codes many gray code problems permutations best discussed setting cayley graphs given finite group g set x elements g cayley graph g cg x undirected graph whose vertices elements g edge joining u v equivalently uv edge g u gamma1 v v gamma1 u x cg x always vertex transitive connected x x gamma1 generates g open question whether every cayley graph hamiltonian generating sets cayley digraph hamiltonian ran48 special case general conjecture lovasz every connected undirected vertextransitive graph hamilton path lov70 results hamilton cycles surveyed als81 vertex transitive graphs gou91 general graphs survey hamilton cycles cayley graphs found wg84 recent update curran gallian cg96 focus recent questions arose context gray codes suppose group g n symmetric group permutations n symbols let x generating set n hamilton cycle cayley graph cg x regarded gray code permutations successive permutations differ generator x even special case g n still open whether every cayley graph n hamilton cycle one general results hamiltonicity cayley graphs permutations discovered kompelmakher liskovets 1975 first note n generated basis ng johnson trotter algorithm section 3 generating permutations adjacent transpositions gives hamilton cycle cg x kompelmakher liskovets generalized result show x set transpositions generating n cs kl75 independently much simpler argument slater showed graphs hamilton paths sla78 tchuente tch82 extended results kl75 sla78 show cayley graph n generating set x transpositions hamiltonian hamiltonlaceable two vertices u v different parity hamilton path starts u ends v unknown whether results generalize case x generating set involutions elements order 2 n involution need transposition example product disjoint transpositions involution perhaps simplest nontrivial case n generated three involutions easy show two generators commute cayley graph hamiltonian cayley graphs arising change ringing frequently property ran48 whi83 however two three involutions commute open whether cayley graph hamiltonian specific example able determine whether gray code permutations successive permutations may differ one three operations exchange positions 1 2 ii reverse sequence iii reverse positions 2 n sequence conway sloane wilks related result gray codes reflection groups g irreducible coxeter group group generated geometric reflections x canonical basis reflections group cg x hamiltonian csw89 result makes use fact set three generators basis always pair generators commute coxeter diagram basis tree straightforward show groups g h generating sets x respectively cg x ch hamiltonian least one g h even order cg theta h x theta hamiltonian noted csw89 since reflection group r direct product irreducible coxeter groups g 1 theta g 2 theta canonical basis g cayley graph r respect basis hamiltonian result interesting geometric interpretation associate finite reflection group tessellation surface nspace spherical n gamma 1simplex spherical simplices tesselation correspond group elements boundary shared two simplices corresponds reflection bounding hyperplane thus hamilton cycle cayley graph corresponds traversal surface visiting simplex exactly seems likely exist nonhamiltonian cayley graphs n examples vertices small degree n generated three involutions described candidate counterexample wilf suggested group permutations generated two cycles 1 2 1 williamson able find hamilton cycle graph using gray code generating permutations doubly adjacent transpositions described section 3 cw93 results kl75 sla78 generalized different way rs93 shown n 5 generating set x transpositions n transposition permutations n listed successive permutations differ transposition x every transposition perfect matching cs defined contained hamilton cycle one application result cayley graphs alternating group n consisting even permutations n example letting n result rs93 implies cayley graph n respect generating set hamiltonian result obtained earlier direct argument gould roth gr87 12 generalizations de bruijn sequences de bruijn sequence order n circular binary sequence length 2 n every nbit number appears contiguous subsequence provides gray code listing binary sequences successive elements differ rotation one position left followed change last element known sequences exist n standard proof shows de bruijn sequence order n corresponds euler tour de bruijn digraph whose vertices binary ntuples one edge binary ntuple x result generalized kary ntuples fre82 higher dimensions de bruijn tori coc88 ffms85 kary tori hi95 known also satisfying cyclic binary sequence length ntuple appears yoe62 de bruijn graph contains cycles lengths n results de bruijn cycles applied random number generation information theory gol64 computer architecture de bruijn graph recognized bounded degree derivative shuffleexchange network abr90 chung diaconis graham generalized notion de bruijn sequence binary numbers universal cycles families combinatorial objects cdg92 universal cycles combinations studied hurlbert hur90 interesting problems remain open universal cycle order n permutations circular sequence x length symbols mg every permutation order isomorphic contiguous subsequence x means 1 example sequence 123415342154213541352435 universal cycle order 4 5 cdg92 goal choose small possible guarantee existence universal cycle clear must satisfy 2 conjectured cdg92 although best upper bound able obtain sufficient another approach relax constraint length sequence requiring shortest circular sequence symbols ng contains every permutation contiguous subsequence least jacobson west simple construction sequence length 2n jw concluding remarks paper included sampling gray code results several areas particularly appeared since survey wilf wil89 many problems posed good references early work gray codes ehr73 nw78 comprehensive treatment gray codes topics combinatorial generation look forward book preparation ruskey rus95 additional information gray codes also appears survey squire squ94a gol93 goldberg considers generating combinatorial structures achieving even polynomial delay hard surveys related material see als81 long cycles vertex transitive graphs gou91 hamiltonian cycles wg84 recent update cg96 cayley graphs sed77 permutations acknowledgements grateful herb wilf collecting sharing intriguing array gray code problems work well enthusiasm inspiring would also like thank frank ruskey frequent coauthor many provoking dis cussions constant supply interesting problems provided helpful comments earlier versions manuscript additional comments suggestions grateful donald knuth anonymous referee r group action graphs parallel architectures search long paths cycles vertextransitive graphs digraphs data structure based gray code encoding graphics image processing long cycles vertextransitive graphs implementation algorithm list gray code sequences partitions efficient generation binary reflected gray code algorithm 6 permutation elements vector algorithm 29 fast permutation elements vector algorithm 30 balanced gray codes gray codes restricted density counting linear extensions symbolic gray codes data allocation scheme two disc systems universal cycles combinatorial structures hamiltonian cycles paths cayley graphs digraphs survey algorithm 382 combinations n objects combination generation graylex ordering toroidal tilings de bruijngood cyclic sequences hamilton cycles cayley graph sn doubly adjacent gray code subcube allocation task migration hypercube machines gray codes reflection groups hamilton circuits tree graphs doubly adjacent gray codes symmetric group braid n strands combinatorial problem gray codes randomization procedures explicit 1factorization middle boolean lattice long cycles revolving door graphs lexicographic matchings cannot form hamiltonian cycles loopless algorithms generating permutations hamilton paths minimal change algorithm algorithm generating subsets fixed size strong minimal change property problem 1186 solution gray codes partial match range queries de bruijn arrays algorithm generating necklaces beads two colors binary tree representation related algorithms generating integer partitions analysis two related loopfree algorithms generating integer partitions necklaces beads k colors kary de bruijn sequences shuffleexchange network hamiltonian path observations complexity generating quasigray codes survey full length nonlinear shift register cycle algorithms colorings diagrams interval orders ffsequences curious properties gray code used solve puzzles personal communication gray codes paths ncube computers intractability gray codes optimized run lengths digital communications space applications efficient algorithms listing combinatorial structures updating hamiltonian problem survey cayley digraphs 1 pulse code communications generation rosary permutations expressed hamiltonian circuits permutations interchanges origins binary code tree graph matroid de bruijn torus problem efficient implementation eades universal cycles beyond de bruijn antipodal layers problem hamilton cycles regular 2connected graphs generation permutations adjacent transpositions personal communication combinatorial gray codes gray code set partitions sequential generation arrangements means basis transpositions gray code compositions solution multidimensional lattice path parity difference recurrence relations generating permutations bag interchanges structured program generate topological sorting arrangements explicit matchings middle levels boolean lattice generation topological sortings machine tools combinatorics permutation adjacent interchanges hard enumeration problems geometry combinatorics generating bracelets gray code based ordering documents shelves classificaton browsing retrieval problem 11 technique generating gray codes rotation graph binary trees hamiltonian gray code generation mpsk signals problem arrangements problem 1186 electronic mail communication via j combinatorial algorithms computers calculators binary tree gray codes generating linear extensions certain posets adjacent transpositions gray codes antimatroids generating linear extensions fast prism acyclic orientation graph hamiltonian gray code variant sequencing permutations via fixed points combinatorial gray code generalization johnson trotter algorithm contiguous kcycles problem 1186 new method generating hamilton cycles ncube campanological problem group theory counting sequences note generation rosary permutations generating binary trees lexicographically data compression graycode sorting generating binary trees transpositions generating permutations graphical derangements hamilton cycles extend transposition matchings cayley graphs sn gray codes set partitions restricted growth tails gray code combinations multiset generating necklaces gray code enumeration families integer partitions private communication adjacent interchange generation combinations research problem 90 generating linear extensions posets transpositions simple combinatorial gray codes constructed reversing sublists combinatorial generation generating neckties algorithms gray code sequences partitions generating permutations kdifferences long cycles middle two levels boolean lattice permutation generation methods hamiltonian bipartite graphs number linear extensions subset ordering generating permutations graphical transpositions combinatorial gray codes efficient generation generating acyclic orientations graph two new gray codes acyclic orientations gray codes afree strings gray code results acyclic orientations finding parity difference involutions hamilton paths graphs linear extensions unions posets rotation distance constructive combinatorics monotone gray codes middle two levels problem note connectivity acyclic orientations graphs generation permutations graphical exchanges algorithm generate topological sorting arrangements technique generating specialized gray codes note gray codes neckties gray code necklaces fixed density generation permutations transposition generating linear extensions adjacent transpositions survey hamiltonian cycles cayley graphs ringing changes combinatorics computer science generalized gray codes combinatorial algorithms update new algorithm generating necklaces gray codes necklaces fixed density construction uniform gray codes binary ring sequences ranking unranking algorithms trees combinatorial ob jects lexicographic generation ordered trees generating binary trees using rotations tr ctr elizabeth l wilmer michael ernst graphs induced gray codes discrete mathematics v257 n23 p585598 28 november colin murray carsten friedrich visualisation satisfiability using logic engine proceedings 2005 asiapacific symposium information visualisation p147152 january 01 2005 sydney australia khaled abdelghaffar maximum number edges joining vertices cube information processing letters v87 n2 p9599 31 july tadao takaoka stephen violich combinatorial generation fusing loopless algorithms proceedings 12th computing australasian theroy symposium p6977 january 1619 2006 hobart australia v v kuliamin test sequence construction using minimum information tested system programming computing software v31 n6 p301309 november 2005 vincent vajnovszki loopless algorithm generating permutations multiset theoretical computer science v307 n2 p415431 7 october james korsh paul lafollette loopless gray code rooted trees acm transactions algorithms talg v2 n2 p135152 april 2006 gerard j chang senpeng eu chungheng yeh ntantipodal gray codes theoretical computer science v374 n13 p8290 april 2007 kenneth ross selection conditions main memory acm transactions database systems tods v29 n1 p132161 march 2004 jean pallo generating binary trees glivenko classes tamari lattices information processing letters v85 n5 p235238 march
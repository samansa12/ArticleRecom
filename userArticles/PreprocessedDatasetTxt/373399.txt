hierarchical gui test case generation using automated planning abstractthe widespread use guis interacting software leading construction complex guis growing complexity come challenges testing correctness gui underlying software present new technique automatically generate test cases guis exploits planning welldeveloped used technique artificial intelligence given set operators initial state goal state planner produces sequence operators transform initial state goal state test case generation technique enables efficient application planning first creating hierarchical model gui based structure gui model consists hierarchical planning operators representing possible events gui test designer defines preconditions effects hierarchical operators input plangeneration system test designer also creates scenarios represent typical initial goal states gui user planner generates plans representing sequences gui interactions user might employ reach goal state initial state implemented test case generation system called planning assisted tester graphical user interface systems paths experimentally evaluated practicality effectiveness describe prototype implementation paths report results controlled experiments generate test cases microsofts wordpad b introduction g raphical user interfaces guis become important accepted way interacting days software although make software easy use users perspective complicate software development process 1 2 particular testing guis complex testing conventional software underlying software tested gui must exercised tested check whether confirms guis specifications even tools used generate guis automatically 3 4 5 tools may contain errors may manifest generated gui leading software failures hence testing guis continues remain important aspect software testing testing correctness gui difficult number reasons first space possible interactions gui enormous sequence gui commands result different state gui command may need evaluated states large number possible states results large number input authors department computer science university pittsburgh pittsburgh pa 15260 usa second author also intelligent systems program email fatif pollack soffagcspittedu permutations 6 requiring extensive testing eg microsoft released almost 400000 beta copies windows95 targeted finding program failures 7 another problem relates determining coverage set test cases conventional software coverage measured using amount type underlying code exercised measures work well gui testing matters much code tested many different possible states software piece code tested important aspect gui testing verification state step test case execution incorrect gui state lead unexpected screen making execution test case useless since events test case may match corresponding gui components screen thus execution test case must terminated soon error detected also verification checks inserted step may become difficult identify actual cause error finally regression testing presents special challenges guis inputoutput mapping remain constant across successive versions software 1 regression testing especially important guis since gui development typically uses rapid prototyping model 8 9 10 11 important component testing generation test cases manual creation test cases mainte nance evaluation conformance coverage criteria time consuming thus automation necessary testing guis paper present new technique automatically generate test cases gui systems approach exploits planning techniques developed used extensively artificial intelligence ai key idea test designer likely good idea possible goals gui user simpler effective specify goals specify sequences events user might employ achieve test case generation system called planning assisted tester graphical user interface systems paths takes goals input generates sequences events automatically sequences events plans become test cases gui paths first performs automated analysis hierarchical structure gui create hierarchical operators used plan generation test designer describes preconditions effects planning operators subsequently input planner hierarchical operators enable use efficient form planning specifically generate test cases set initial goal states input planning system performs restricted form hierarchical plan generation produce multiple hierarchical plans implemented paths demonstrate effectiveness efficiency set experiments important contributions method presented paper include following ffl make innovative use well known used technique ai shown capable solving problems large state spaces 12 combining unique properties guis planning able demonstrate practicality automatically generating test cases using planning ffl technique exploits structural features present guis reduce model size complexity improve efficiency test case generation ffl exploiting structure gui using hierarchical planning makes regression testing easier changes made one part gui affect entire test suite generated test cases updated making local changes ffl platform specific details incorporated end test case generation process increasing portability test suite portability important gui testing 13 assures test cases written gui systems one platform also work platforms ffl technique allows reuse operator definitions commonly appear across guis definitions maintained library reused generate test cases subsequent guis next section gives brief overview paths using example gui section iii briefly reviews fundamentals ai plan generation section iv describes planning applied gui test case generation problem section v describe prototype system paths give timing results generating test cases discuss related work automated test case generation guis section vi conclude section vii ii overview section present overview paths example goal provide reader highlevel overview operation paths highlight role test designer overall test case generation process details algorithms used paths given section iv guis typically consist components labels tons menus popup lists gui user interacts components turn generate events ex ample pushing button preferences generates event called preferences event opens window addition visible components screen user also generates events using devices mouse keyboard purpose model guis two types windows gui windows object windows gui windows contain gui components whereas object windows contain gui components object windows used display manipulate objects eg window used display text ms wordpad select fig 1 example gui figure presents small part mswordpads gui gui used loading text files manipulating text cutting pasting saving text another file highest level gui pulldown menu two options file edit generate events make components available example file event opens menu new open save saveas options edit event opens menu cut copy paste options used cut copy paste objects respectively main screen open saveas events open windows several components open window shown saveas window similar components used traverse directory hierarchy select file moves one level directory hierarchy select used either enter subdirectories select files window closed selecting either open cancel central feature paths plan generation sys tem automated plan generation widely investigated used within field artificial intelligence input planner initial state goal state set operators applied set objects operators model events usually described terms preconditions effects conditions must true action performed conditions true action performed solution given planning problem sequence instantiated operators guaranteed result goal state executed initial state 1 example gui operators relate gui events consider figure 2a shows collection files stored directory hierarchy contents files described simplest case ai planning literature includes many techniques extensions planning uncertainty 14 consider techniques paper text must modified text must modified needs modified needs modified text text b text must modified text must modified needs modified needs modified text text final text final text newdoc fig 2 task planning system initial state b goal state shown boxes directory structure shown exploring window assume initial state contains description directory structure location files contents file using files wordpads gui define goal creating new document shown figure 2b storing file newdoc rootpublic directory figure 2b shows goal state contains addition old files new file stored rootpublic directory note newdoc obtained numerous ways eg loading file documentdoc deleting extra text typing word final loading file doc2doc inserting text creating document scratch typing text test case generation process partitioned two phases setup phase plangeneration phase first step setup phase paths creates hierarchical model gui returns list operators model test designer using knowledge gui test designer defines preconditions effects operators simple language provided planning system second plangeneration phase test designer describes scenarios tasks defining set initial goal states test case generation fi nally paths generates test suite scenarios test designer iterate plangeneration phase number times defining scenarios generat roles test designer paths test case generation phase step test designer paths hierarchical gui operators preconditions effects operators plan generation 3 4 generate test cases iterate 3 4 multiple scenarios ing test cases table summarizes tasks assigned test designer automatically performed paths example gui simplest approach step 1 would paths identify one operator gui event eg open file cut paste naming conven tion disambiguate meaningful prefixes whenever names test designer would define preconditions effects events shown figure 3a although conceptually simple approach inefficient generating test cases guis results large number operators many events eg file edit merely make events pos sible interact underlying software alternative modeling scheme one used work models domain hierarchically highlevel operators decompose sequences lower level ones although highlevel operators could principle developed manually test designer paths avoids inconvenience automatically performing abstraction specifically paths begins modeling process partitioning gui events several classes details partitioning scheme discussed later section iv event classes used paths create two types planning operators systeminteraction operators abstract operators systeminteraction operators derived gui events generate interactions underlying software example paths defines system interaction operator edit cut cuts text example guis window examples system interaction operators edit paste file save second set operators generated paths set abstract operators discussed detail section iv basic idea abstract operator represents sequence gui events invoke window monopolizes gui interaction restricting focus user specific range events window abstract operators encapsulate events restrictedfocus window treating interaction within window separate planning problem abstract operators need decomposed lower level operators explicit call planner example gui new open save saveas cut copy paste openup openselect opencancel openopen planning operators filenew fileopen filesave filesaveas editcut editcopy editpaste b fig 3 example gui original gui events b planning operators derived paths ii operatorevent mappings example gui operator name operator type gui events file new sys interaction file new file open abstract file open file save sys interaction file save file saveas abstract file saveas edit cut sys interaction edit cut edit copy sys interaction edit copy sys interaction edit paste abstract operators include file open file saveas result first step setup phase systeminteraction abstract operators determined returned planning operators test designer planning operators returned example shown figure 3b order keep correspondence original gui events highlevel operators paths also stores mappings called operatorevent mappings shown table ii operator name column 1 lists operators example gui operator type column classifies operator either abstract system interaction associated operator corresponding sequence gui events column 3 test designer specifies preconditions effects planning operator example planning operator edit cut shown figure 4 edit cut systeminteraction operator operator definition contains two parts preconditions effects conditions preconditions must hold gui operator applied eg user generate cut event least one object screen selected highlighted effects cut event selected objects moved clipboard removed screen language used define operator provided planner interface planning system defining preconditions effects difficult knowledge already built gui structure example gui structure requires cut made active visible object selected precisely precondition defined example operator edit cut figure 4 definitions operators pfrh 9duf8vu 9g tprrpiw 9g tryrprqpiw hr file edit cut fig 4 example gui planning operator representing events commonly appear across guis cut maintained library reused subsequent similar applications test designer begins generation particular test cases inputing defined operators paths identifying task one shown figure 2 defined terms initial state goal state paths automatically generates set test cases achieve goal example plan shown figure 5 note typeintext operator representing keyboard event plan highlevel plan must translated primitive gui events translation process makes use operatorevent mappings stored modeling process one translation shown figure 6 figure shows abstract operators contained highlevel plan decomposed 1 inserting expansion operatorevent mappings 2 making additional call planner since maximum time spent generating highlevel plan desirable generate family test cases single plan goal achieved generating alternative subplans lower levels subplans generated much faster generating highlevel plan substituted highlevel plan obtain alternative test cases one alternative lowlevel test case generated task shown figure 7 note use nested invocations planner abstractoperator decomposition hierarchical mechanism aids regression testing since changes made one component necessarily invalidate test cases higher level plans still fig 5 plan consisting abstract operators gui event lowlevel test case fig 6 expanding higher level plan tained local changes made subplans specific changed component gui also steps test cases platform independent additional level translation required generate platformdependent test cases using highlevel model gui advantage obtaining platformindependent test cases iii plan generation provide details plan generation given initial state goal state set operators set objects planner returns set steps instantiated op erators achieve goal many different algorithms plan generation proposed developed weld presents introduction leastcommitment planning 15 survey recent advances planning technology 16 formally planning problem 4tuple set operators finite set objects initial state g goal state note operator definition may contain variables parameters typically operator correspond single executable action rather family actions one different instantiation variables solution lowlevel test case fig 7 alternative expansion leads new test case planning problem plan tuple set plan steps instances operators typically defined sets preconditions effects set ordering constraints elements l set causal links representing causal structure plan b set binding constraints variables operator instances ordering constraint form meaning step must occur sometime step j necessarily immediately typically ordering constraints induce partial ordering steps causal links triples elements c effect precondition j 2 note corresponding causal link ordering constraint ie reason tracking causal link ensure step threatens required link ie step k results c temporally intervene steps mentioned ai planners produce partiallyordered plans steps ordered respect one another totalorder plan derived partialorder plan adding ordering constraints totalorder plan obtained way called linearization partialorder plan partialorder plan solution planning problem every consistent linearization partialorder plan meets solution conditions figure 8a shows partialorder plan obtained realize goal shown figure 2 using example gui generally c represents proposition unification effect precondition j deletetext needs modified typeintext final text fileopen samples reportdoc filesaveas public newdoc c deletetext needs modified typeintext final text fileopen samples reportdoc filesaveas public newdoc deletetext needs modified typeintext final text fileopen samples reportdoc filesaveas public newdoc l ordering constraints b fig 8 partialorder plan b ordering constraints plan c two linearizations figure nodes labeled l plan steps instantiated operators edges represent causal links bindings shown parameters operators figure 8b lists ordering constraints directly induced causal links example general plans may include additional ordering constraints ordering constraints specify deletetext typeintext actions performed either order must precede file saveas action must performed file open action obtain two legal orders shown figure 8c thus two highlevel test cases produced may decomposed yield number lowlevel test cases work employ recently developed planning technology increases efficiency plan generation specifically generate singlelevel plans using interference progression planner ipp 17 system extends ideas graphplan system 18 plan generation graphplan introduced idea performing plan generation converting representation planning problem propositional encoding plans found means search graph planners graphplan family including ipp shown increases planning speeds several orders magnitude wide range problems compared earlier planning systems rely firstorder logic representation graph search requiring unification unbound variables 18 ipp uses standard representation actions preconditions effects parameterized subsequent processing performs conversion propositional form 3 common planning ipp produces partialorder plans ipp forms plans single level abstraction techniques developed ai planning generate plans multiple levels abstraction called hierarchical task network htn planning 19 htn planning domain actions modeled different levels abstraction operator level n one specifies one methods level n gamma 1 method singlelevel partial plan say action decomposes methods htn planning focuses resolving conflicts among alternative methods decomposition level gui test case generation problem unusual experience least modeled hierarchical plans require conflict resolution decom position thus able make use restricted form hierarchical planning assumes decompositions compatible hierarchical planning valuable gui test case generation guis typically large number components events use hierarchy allows us conceptually decompose gui different levels abstraction resulting greater planning efficiency result conceptual shift plans maintained different abstraction levels subsequent modifications made gui toplevel plans usually need regenerated scratch stead subplans lower level abstraction af fected subplans regenerated reinserted larger plans aiding regression testing iv planning gui test cases described ai planning techniques general present details use planning paths generate test cases guis developing representation gui operation developing planning system testing guis first step construct operator set planning problem discussed section ii simplest approach defining one operator gui event inefficient resulting large number operators exploit certain structural properties guis construct operators different levels abstraction operator derivation process begins partitioning gui events several classes using certain structural properties guis note classification based structural properties guis thus done automatically paths using simple depthfirst traversal algorithm gui traversed opening menus windows clicking buttons convenience names operator taken label buttonmenuitem repre sents note several commercially available tools also 3 fact ipp generalizes graphplan precisely increasing expressive power representation language allowing conditional universally quantified effects perform traversal gui eg winrunner mercury interactive corporation classification gui events employ follows menuopen events open menus ie expand set gui events available user definition menuopen events interact underlying software common example menuopen events generated buttons open pulldown menus eg file edit unrestrictedfocus events open gui windows restrict users focus merely expand set gui events available user exam ple ms powerpoint software basic shapes displayed unrestrictedfocus window purpose test case generation events treated exactly manner menuopen events used expand set gui events available user restrictedfocus events open gui windows special property invoked monopolize gui interaction restricting focus user specific range events within window window explicitly terminated preference setting example restrictedfocus events many gui systems user clicks edit preferences window opens user spends time modifying preferences finally explicitly terminates interaction either clicking ok cancel systeminteraction events interact underlying software perform action common examples include cutting pasting text opening object windows classification events used create two classes planning operators systeminteraction operators represent sequences zero menuopen unrestrictedfocus events followed systeminteraction event consider small part example gui one pulldown menu one option edit opened give options ie cut paste events available user edit cut paste edit menuopen event cut paste system interaction events using information following two systeminteraction operators obtained example operatorevent mapping relates systeminteraction operators gui events operatorevent mappings fold menu open unrestricted focus events system interaction operator thereby reducing total number operators made available planner resulting greater planning efficiency mappings used replace systeminteraction operators corresponding gui events generating final test case example events edit cut paste hidden planner systeminteraction operators namely edit cut edit paste made available abstraction prevents generation test cases edit used isolation ie model forces use edit either cut paste thereby restricting attention meaningful interactions underlying software 4 abstract operators created restrictedfocus events abstract operators encapsulate events underlying restrictedfocus window creating new planning problem solution represents events user might generate focused interaction abstract operators implicitly divide gui several layers abstraction test cases generated gui level thereby resulting greater efficiency abstract operator complex structure since contains necessary components planning problem including initial goal states set objects set operators prefix abstract operator sequence menuopen unrestricted focus events lead restrictedfocus event sequence events stored operatorevent mappings suffix abstract operator represents restrictedfocus user interaction abstract operator decomposed two steps 1 using operatorevents mappings obtain abstract operator prefix 2 explicitly calling planner obtain abstract operator suffix prefix suffix substituted back highlevel plan example figure 6 abstract operator file open decomposed substituting prefix using mapping suffix chdir select open invoking planner figure 9a shows small part example gui file menu two options namely open saveas either events generated results another gui window components made available components windows quite similar open user exit pressing open cancel saveas user exit pressing save cancel complete set events available open saveas openselect openup opencancel openopen saveasselect saveasup saveascancel saveassave user selects open focus restricted openselect openup opencancel openopen similarly user selects saveas focus restricted saveasselect saveasup saveascancel saveassave properties lead following two abstract operators file file addition two operatorevent map 4 test cases edit stands isolation created 1 testing edit separately 2 inserting edit random places generated test cases saveas save file fileopen filesaveas abstraction abstraction c abstract operator template operator name fileopen initial state determined run time goal state determined run time operator list abstract operator template operator name filesaveas initial state determined run time goal state determined run time operator list b fig 9 open saveas windows abstract operators b abstract operator templates c decomposition abstract operator using operatorevent mappings making separate call planner yield subplan pings abstract operator definition template created operator shown figure 9b template contains essential components planning problem ie set operators available restrictedfocused user inter action initial goal states determined dynamically point call since higherlevel planning problem already solved invoking planner abstract opera tor preconditions effects highlevel abstract operator used determine initial goal states subplan highest level abstraction planner use highlevel oper ators ie file open file saveas construct plans example figure 9c highlevel plan contains file open decomposing file open requires 1 retrieving corresponding gui events stored operatorevent mappings file open 2 invoking planner returns subplan select open file open replaced sequence abstract systeminteraction operators given input planner operator set returned running example shown figure 3b initial state containsroot private containsprivate figures containsprivate latex containslatex containsprivate courses containsprivate thesis containsroot public containspublic html containshtml gif containsfilegif doc2doc containsfileprivate documentdoc containsfilesamples reportdoc currentfonttimes normal indoc2doc indoc2doc indoc2doc indoc2doc text afterthis afteris afterthe text fontthis times normal 12pt fontis times normal 12pt fontthe times normal 12pt fonttext times normal similar descriptions documentdoc reportdoc goal state containsfilepublic newdoc innewdoc innewdoc innewdoc innewdoc final innewdoc text afterthis afteris afterthe final afterfinal text fontthis times normal 12pt fontis times normal 12pt fontthe times normal 12pt fontfinal times normal fonttext times normal fig 10 initial state changes needed reach goal state b modeling initial goal state generating test cases test designer begins generation particular test cases identifying task consisting initial goal states see figure 2 test designer codes initial goal states uses tool automatically produces code 5 code initial state changes needed achieve goal states shown figure 10 task specified system automatically generates set test cases achieve goal algorithm generate test cases discussed next c algorithm generating test cases test case generation algorithm shown figure 11 operators assumed available making call algorithm ie steps 13 test case generation process shown table must completed making call algorithm parameters lines include components planning problem threshold controls looping algorithm loop lines 812 contains explicit call planner phi returned plan p recorded operator set planner return alternative plan next iteration line 11 end loop plan list contains partialorder plans partialorder plan linearized lines 1316 leading multiple linear plans initially test cases highlevel linear plans 5 tool would developed enables user visually describe guis initial goal states tool would translate visual representation code eg code shown figure 10 lines algorithm gentestcases operator set fig 11 complete algorithm generating test cases line 17 decomposition process leads lower level test cases highlevel operators plan need expandeddecomposed get lower level test cases step systeminteraction operator operator event mappings used expand lines 2022 ever step abstract operator decomposed lower level test case 1 obtaining gui events operatorevent mappings 2 calling planner obtain subplan 3 substituting results higher level plan extraction functions used access planning problems components lines 2427 lowest level test cases consisting gui events returned result algorithm line 33 noted earlier one main advantages using planner application automatically generate alternative plans goal generating alternative plans important model various ways different users might interact gui even trying achieve goal ai planning systems typically generate single plan assumption made heuristic search control rules ensure first plan found high quality plan paths generate alternative plans following two ways 1 generating multiple linearizations partialorder plans recall earlier discussion ordering constraints induce partial ordering set solutions linearizations plan steps consistent free choose linear order consistent partial order possible linear orders partialorder plan result family test cases multiple linearizations partialorder plan shown earlier figure 8 2 repeating planning process forcing planner generate different test case iteration v experiments prototype paths developed several sets experiments conducted ensure paths practical useful experiments executed pentium based computer 200mb ram running linux os summary results experiments given following sections generating test cases multiple tasks paths used generate test cases microsofts wordpad examples generated highlevel test cases shown table iii total number gui events wordpad determined approximately 325 analysis paths reduced set 32 systeminteraction abstract operators ie roughly ratio reduction number operators impressive helps speed plan generation process shown section vb defining preconditions effects 32 operators fairly straightforward average operator definition required 5 preconditions effects complex operator requiring 10 preconditions effects since mouse keyboard events part gui three additional operators mouse keyboard events defined table iv presents cpu time taken generate test cases ms wordpad row table represents different planning task first column shows task second column shows time needed generate highestlevel plan third column shows average time spent decompose subplans fourth column shows total time needed generate test case ie sum two previous columns results show maximum time spent generating highlevel plan column 2 highlevel plan used generate family test cases substituting alternative lowlevel subplans subplans generated relatively faster average shown column 3 amortizing cost plan generation multiple test cases plan 9 took longest time generate linearized obtain 2 highlevel plans decomposed give several lowlevel test cases shortest consisted 25 gui events plans shown table iii high level ab straction many changes made gui effect plans making regression testing easier less expensive example none plans table iii wordpad plans generated task figure 2 plan plan plan step action contain lowlevel physical details gui changes made fonts colors etc affect test suite way changes modify functionality gui also readily incorporated example wordpad gui modified introduce additional file opening feature highlevel plans remain changes needed subplans generated abstract operator fileopen hence cost initial plans amortized large number test cases also implemented automated test execution sys tem test cases could automatically executed without human intervention automatically executing test cases involved generating physical mousekeyboard events since test cases represented high level abstraction translate highlevel actions physical events actual screen coordinates buttons menus etc derived layout information b hierarchical vs singlelevel test case generation second experiment compared singlelevel test case generation hierarchical test case generation technique recall singlelevel test case iv time taken generate test cases wordpad task plan sub total time plan time sec time sec 3 317 000 317 9 4047 004 4051 generation technique planning done single level abstraction operators onetoone correspondence gui events hand hierarchical test case generation approach hierarchical modeling operators used results experiment summarized table v shown cpu times 6 different tasks column 1 shows task shows length test case generated using singlelevel approach column 3 shows corresponding cpu time task used generate another test case time using hierarchical operators column 4 shows length highlevel plans column 5 shows time needed generate highlevel plan decompose plan 1 obtained hierarchical algorithm expands give plan length 18 ie exactly plan obtained running corresponding singlelevel algorithm timing results show hierarchical approach efficient singlelevel approach results smaller number operators used planning problem experiment demonstrates importance hierarchical modeling process key efficient test case generation small number planning operators level planning guis become com plex modeling algorithm able obtain increasing number levels abstraction performed exploratory analysis much larger gui microsoft word automatic modeling process reduced number operators ratio 20 1 vi related work current tools aid test designer testing process include recordplayback tools 20 21 tools record user events gui screens interactive session recorded sessions later played back whenever necessary recreate gui states several attempts made automate test case generation guis one popular technique programming test case generator 22 comprehensive test ing programming requires test designer code comparing single level hierarchical approach indicates plan found 1 hour single level hierarchical task plan time plan time length sec length sec 4 26 331272 6 718 possible decision points gui however approach time consuming susceptible missing important gui decisions number research efforts addressed automation test case generation guis several finitestate machine models proposed generate test cases 23 24 25 26 approach softwares behavior modeled fsm input triggers transition fsm path fsm represents test case fsms states used verify soft wares state test case execution approach used extensively test generation testing hardware circuits 27 advantage approach fsm built test case generation process automatic relatively easy model gui fsm user action leads new state transition models user action however major limitation approach especially important limitation gui testing fsm models scaling problems 28 aid scalability technique variations variable finite state machine vfsm models proposed shehady et al 28 test cases also generated mimic novice users 7 approach relies expert manually generate initial sequence gui events uses genetic algorithm techniques modify extend sequence assumption experts take direct path solving problem using guis whereas novice users often take longer paths although useful generating multiple test cases technique relies expert generate initial sequence final test suite depends largely paths taken expert user ai planning found useful generating focused test cases 29 robot tape library command language main idea test cases command language systems similar plans given initial state tape library desired goal state planner generate plan executed software test case note although technique similarities approach several differences exist major difference 29 command language modeled distinct operator approach works well systems relatively small command language however guis typically large number possible user actions hierarchical approach needed vii conclusions paper presented new technique testing gui software showed potential value test designers toolbox technique employs gui tasks consisting initial goal states generate test cases key idea using tasks guide test case generation test designer likely good idea possible goals gui user simpler effective specify goals specify sequences events achieve technique unique use automatic planning system generate test cases gui events interactions use description gui automatically generate alternative sequences events pairs initial goal states iteratively invoking planner demonstrated technique practical useful generating test cases popular ms wordpad softwares gui experiments showed planning approach successful generating test cases different scenarios developed technique decomposing gui multiple levels abstraction technique makes test case generation intu itive also helps scale test generation algorithms larger guis experimentally showed hierarchical modeling approach necessary efficiently generate test cases hierarchical test case generation also aids performing regression testing changes made one part gui invalidate test cases changes made lower level test cases retaining highlevel test cases representing test cases high level abstraction makes possible finetune test cases implementation platform making test suite portable mapping used translate lowlevel test cases sequences physical actions platformdependent mappings maintained libraries customize generated test cases lowlevel platformspecific test cases note current limitations approach first test case generator largely driven choice tasks given planner currently paths tasks chosen manually test designer poorly chosen set tasks yield test suite provide adequate coverage currently exploring development coverage measures guis second depend heavily hierarchical structure gui efficient test case generation paths given poorly structured gui abstract operators obtained planning depend entirely primitive opera tors making system inefficient third approach must used conjunction test case generation techniques adequately test software generally case test case generators one tasks currently performed test designer definition preconditions effects op erators definitions commonly used operators maintained libraries making task easier also currently investigating automatically generate preconditions effects operators guis specifications viii acknowledgments research partially supported air force office scientific research f496209810436 national science foundation iri9619579 atif memon partially supported andrew mellon predoctoral fellowship thank anonymous reviewers article comments brian malloy valuable sugges tions preliminary version paper appeared proceedings 21st international conference software engineering los angeles may 1999 30 r humancomputer interfaces difficult design implement integrating mvc paradigm objectoriented framework accelerate gui application development user interface software tools addi tool automating design visual interfaces regression testing gui event interactions toward automatic generation novice user test scripts user interface design trenches tips shooting hip iterative userinterface design interactive scenarios development user interface prototype user interface design evaluation application rapid prototyping tool emsig role domainspecific knowledge planning satisfiability framework java gui testing conditional nonlinear planning introduction least commitment planning recent advances ai planning ex tending planning graphs adl subset fast planning planning graph analysis htn planning complexity expressivity stress tests gui programs inte grated data capture analysis tools research testing graphical user interfaces black art gui testing automated test generation behavioral model testing software design modeled finitestate machines automated test generation execution reporting reduced test suite protocol conformance testing redundancy identifi cationremoval test generation sequential circuits using implicit state enumeration method automate user interface testing using variable finite state machines test case generation ai planning problem using goaldriven approach generate test cases guis tr ctr yanhong sun edward l jones specificationdriven automated testing guibased java programs proceedings 42nd annual southeast regional conference april 0203 2004 huntsville alabama christoph csallner yannis smaragdakis jcrasher automatic robustness tester java softwarepractice experience v34 n11 p10251050 september 2004 atif memon mary lou soffa martha e pollack coverage criteria gui testing acm sigsoft software engineering notes v26 n5 sept 2001 fevzi belli christof j budnik test minimization humancomputer interaction applied intelligence v26 n2 p161174 april 2007 atif memon mary lou soffa regression testing guis acm sigsoft software engineering notes v28 n5 september jessica chen suganthan subramaniam specificationbased testing guibased applications software quality control v10 n3 p205224 november 2002 avik sinha carol smidts experimental evaluation higherorderedtypedfunctional specificationbased testgeneration technique empirical software engineering v11 n2 p173202 june 2006 anneliese k amschler andrews chunhui zhu michael scheetz eric dahlman adele e howe ai planner assisted test generation software quality control v10 n3 p225259 november 2002 modelbased test design technique enhanced testing domainspecific applications acm transactions software engineering methodology tosem v15 n3 p242278 july 2006 qing xie atif memon designing comparing automated test oracles guibased software applications acm transactions software engineering methodology tosem v16 n1 p4es february 2007 manish gupta jicheng fu farokh b bastani latifur r khan ling yen rapid goaloriented automated software testing using meagraph planning software quality control v15 n3 p241263 september 2007 atif memon adithya nagarajan qing xie automating regression testing evolving gui software research articles journal software maintenance evolution research practice v17 n1 p2764 january 2005 atif memon adithya nagarajan qing xie automating regression testing evolving gui software journal software maintenance research practice v17 n1 p2764 january 2005
optimizing queries object updates objectoriented databases oodbs provide powerful data abstractions modeling facilities usually lack suitable framework query processing optimization even though increasing number recent proposals oodb query optimization actually focused query optimization presence object identity destructive updates features often supported realistic oodb languages paper presents formal framework optimizing objectoriented queries presence side effects queries may contain object updates place form present language extension monoid comprehension calculus express objectoriented features give formal meaning extensions method based denotational semantics often used give formal meaning imperative programming languages semantics language extensions expressed terms monoid calculus without need fundamental change basic framework method maintains referential transparency allows us meaningful query optimization also practical optimizing oodb queries since allows optimization techniques applied regular queries used minimal changes oodb queries updates b introduction one key factors oodb systems successfully compete relational systems well meet performance requirements many nontraditional applications development effective query optimizer even though many aspects oodb query optimization problem benefit already successful relational query optimization research many key features oodb languages make problem unique hard solve features include object identity methods encapsulation userdefined type constructors large multimedia objects multiple collection types arbitrary nesting collections nesting query expressions increasing number recent proposals oodb query optimization focused handling nested collections ow92 col89 others converting path expressions joins km90 cd92 others unnesting nested queries cm95b cm95a others focused handling encapsulation methods dgk 91 however proposals query optimization presence object identity destructive updates features often supported realistic oodb languages earlier work fm98 fm95b fm95a proposed effective framework solid theoretical basis optimizing oodb query languages calculus called monoid comprehension calculus already shown capture features odmg oql cat94 good basis expressing various optimization algorithms concisely including query unnesting feg98 translation path expressions joins feg97 paper extend framework handle object identity object updates 11 object complicates query optimization objectoriented programming based sideeffects modification object store even though modern oodbs provide declarative query languages associative access data queries languages allowed invoke method including perform side effects object creation common oodb queries side effect since inserts new object class extent consider example following oql query select personenameeaddress e employees creates new person employee even though query seems free side effects first glance modifies extent class person inserting new person query part another query query scanning extent class person extent would modified accordingly used outer query therefore semantics query must reflect fact person extent modified execution query failure may result incorrect optimizations may lead invalid execution plans problem assigning semantics objectoriented queries becomes even worse allow object state modifications arbitrary places query like oodb languages example oql query select esalary esalary108 e employees esalary50000 gives 8 raise employees earning 50000 semantics query reflect fact salary modified iteration situation queries mixed freely updates occurs frequently oodb languages ag89 support set iteration embedded computational complete programming language even though languages beginning disappear favor declarative languages oql surge interest provide computational power existing declarative query languages without sacrificing performance consider example following query taken ld92 divisions e employees suchthat edivisiond f totpay types queries allow kind c code inside forloop including code modifies database earlier research query optimization ld92 shown queries form hard optimize another problem consider sets bags combined side effects results may unpredictable due commutativity example following query e employees value x end execution program would depend way employees scanned understand extent problem consider function fn contains assignment xn body returns n value x execution ff1 f2g 1 2 since fx ff1 f2g equal ff2 f1g given side effects may appear place program proving equivalences oodb expressions becomes hard makes task expressing verifying optimization rules difficult accomplish example well known transformation x x terms x valid since x may queries perform side effects order execution side effects would changed transformation applied thus changing semantics program one way patch error attach guard transformation rule prevent execution terms x contain side effects unfortunately approach conservative may miss optimizations eg side effects x interfere furthermore fundamental problem algebraic operations side effects example x cannot appear valid translation declarative query since declarative query define execution order consequently optimizing realistic oodb query language need address problem object identity properly handle implicit explicit side effects due use object identity also highly desirable use existing optimization techniques minimal changes possible necessary capture handle object identity framework regular queries side effects unfortunately extensions difficult incorporate existing optimization framework understand level difficulty consider following equality predicate personsmithpark predicate must evaluated false since left object different identity right one hand given function gx computes predicate xx function call gpersonsmithpark av return true unfold call g get previous false expression consequently substituting body function definition function call valid transformation goal give formal meaning oodb queries side effects importantly provide equational theory allows us meaningful query optimization highly desirable theory seamlessly incorporated monoid comprehension calculus possibly discovering new monoid captures meaning object identity another goal whenever object updates query would like query treated way currently treated basic optimizer without object extensions 12 approach paper presents framework incorporates impure features namely object identity monoid comprehension calculus according earlier discussion important give semantics extensions preserve referential transparency referential transparency able substitute equal subexpressions context larger expression give equal results rea89 query language lacks property transformation rules query optimizer would depend context expression apply researchers programming languages often use formal methods denotational semantics solve problems denotational semantics approach impure features language captured passing state object store operations program piece program update state state propagated otherwise modified reflect updates say state modified mean new copy state created approach may become quite inefficient destructive update matter small new object store ie entire database must created obviously technique unacceptable database applications solution problem allow state manipulated small number primitives preserve referential transparency efficient implementation well specifically even though primitives defined purely functional way implementations perform destructive updates state way derive efficient programs importantly maintain referential transparency allows us meaningful query optimization catch solution works state singlethreaded sch85 roughly speaking state singlethreaded program program undo state modification point strict sequencing state updates program case state replaced access rights single global variable state operations made cause side effects preserving operational properties following example non singlethreaded program assume x2 x1 statement assume s1 s2 executes statement s1 locally state modifications s1 used s2 exclusively discarded thus value x completion program 1 3 respectively since binding x2 discarded used yx1 statement requires local copy state execution probably form stack states handle nested assume statements since needs backtrack previous state completion execution rollback database transaction another example non singlethreaded operation two common ways guarantee singlethreadedness first allow state manipulation language detect violation singlethreadedness performing semantic analysis ie kind abstract interpretation sch85 using linear type system ss95 detect violations typechecking second approach adopt framework restrict syntax language way state guaranteed always singlethreaded another serious problem mentioned denotational semantics approach pass state operations program need sequentialize operations restriction good idea commutative operations since may miss optimization opportunities example ranging r assignment x r evaluated scanning r two ways one set x 1 end 2 depending way r scanned solutions valid considered optimizer address problem generating possible solutions generated alternatives first stage optimizer select best one end performing cost analysis even though approach may generate exponential number solutions applied constant data practice provided query contain large number union operations alternative solution corresponds typically different final database state end one solution chosen optimizer collection semantics queries query collection possible correct answers decided consider solutions instead reporting error one solution exists useful programs fall category considering alternatives query optimization necessary proving program equivalences proving ff1 f2g equal ff2 f1g plan generation phase ie optimization completed select alternative framework inspired ohoris work representing object identity using monads oho90 contribution mix state transformation sets bags apply theory database query language satisfies strong normalization properties normalization removes unnecessary state transformation thus making approach practical optimizing programs objectoriented calculus important contribution work development method map programs state transformation cannot removed normalization imperative loops much way one could express programs using regular imperative language c resulting programs efficient written hand rest paper organized follows section 2 describes earlier results monoid comprehension calculus section 3 describes object extensions monoid calculus section 4 proposes new monoid captures object identity side effects section 5 describes framework handling object identity using denotational semantics section 6 addresses practical considerations building optimizer based framework section 7 presents prototype implementation framework finally section 8 extends framework capture database updates discusses theory applied solve view maintenance problem background monoid comprehension calculus section summarizes earlier work monoid calculus formal treatment presented elsewhere fm98 fm95b fm95a monoid calculus based concept monoids abstract algebra monoid type pair phi z phi phi associative function type theta ie binary function takes two values returns value called accumulator merge function monoid z phi type called zero element monoid left right identity phi zero element satisfies z phi phi every x since accumulator function uniquely identifies monoid often use accumulator name monoid name examples monoids include f g sets ffgg bags lists 0 1 max 0 integers false true booleans monoids integers booleans called primitive monoids construct values primitive type set bag list monoids called collection monoids collection monoid phi z phi requires additional definition unit function u phi along merge zero allows us construction possible values type example unit function set monoid x fxg takes value x input constructs singleton set fxg output list monoid commutative ie satisfy x phi addition max idempotent ie satisfy x phi monoid comprehension monoid phi takes form phif e j r g expression e called head comprehension term r term sequence called qualifier either generator form v e 0 v range variable e 0 expression generator domain constructs collection filter p p predicate use shorthand f e j r g denote set comprehension f e j r g monoid comprehension defined following reduction rules omega collection monoid possibly different phi ae u phi e phi collection monoid e otherwise d1 rules d2 d3 reduce comprehension leftmost qualifier filter rules d4 d6 reduce comprehension leftmost qualifier generator letstatement d5 binds v e 0 uses binding every free occurrence v phif e j r g calculus semantic wellformedness requirement comprehension idempotent commutative monoid generators idempotent commutative monoids example valid monoid comprehension since maps set monoid commutative idempotent list monoid neither commutative idempotent fx j x ff1 2gg g valid since commutative requirement easily checked compile time restricted sets monoid comprehensions equivalent set monad comprehensions bls capture precisely nested relational algebra fm95b oql expressions direct translation monoid calculus example oql query select distinct hotelprice hotel select h c cities h chotels exists r hotelrooms rbed hotelname select tname states sattractions translated following comprehension f hotelprice hotel f h c cities h chotels cnamearlington g f rbed num3 r hotelrooms g use shorthand x j u represent binding variable x value u meaning construct given following reduction eux expression e u substituted free occurrences x ie eux equivalent let addition syntactic sugar allow irrefutable patterns place lambda variables range variables variables bindings patterns like compiled away using standard pattern decomposition techniques pj87 example equivalent f afst asndfst retrieves firstsecond element pair another example x function takes three parameters returns sum equivalent afst asndfst monoid calculus put canonical form efficient rewrite algorithm called normalization algorithm evaluation canonical forms generally produces fewer intermediate data structures initial unnormalized programs moreover normalization algorithm improves program performance many cases generalizes many optimization techniques already used relational algebra fusing two selections one selection following important rules normalization algorithm reduction n2 pred j r idempotent phi n4 soundness normalization rules proved using definition monoid comprehension fm98 rule n3 flattens comprehension contains generator whose domain another comprehension may require variable renaming avoid name conflicts rule n4 unnests existential quantification example previous oql query normalized cnamearlington rbed num3 snametexas tnamehname g applying rule n3 unnest two inner set comprehensions rule n4 unnest two existential quantifications 3 object monoid calculus section monoid calculus extended capture object identity extended calculus called object monoid calculus example one valid objectoriented comprehension first creates list containing two new objects new1 new2 variable x ranges list state x incremented one x x1 x reference object x x returns state object x result computation list 2 3 objectoriented comprehension translated state transformer propagates object heap contains bindings object identities object states operations expression changes operation creates new object modifies state object translation captures precisely semantics object identity without need extending base model also provides equational theory allows us valid optimizations objectoriented queries introduce new type constructor objt captures objects states represented values type addition extend monoid calculus following polymorphic operations oho90 style sml pau91 ffl new type objt operation news creates new object state ffl type objt operation e dereferences object e returns state e ffl type objt bool operation e changes state object e returns true many objectoriented languages different ways constructing manipulating objects exam ple oql uses object constructors create objects require explicit object dereferencing operator language features easily expressed terms primitives mentioned giving formal semantics primitives better choice since deal details object classes inheritance etc optimizing real objectoriented language though details addressed properly objectoriented operators may appear place monoid comprehension following examples comprehensions object operations called object comprehensions recall v j e defines new variable name v synonym value e e1 e2 changes state object whose oid equal value e1 result e2 true first example indicates different objects distinct second example indicates objects may equal states ninth example computes cardinality set f1 2 2 indicates duplicates set count last example interesting one since order set f1 2 2 3g many results permutations set namely f1 3 6g f1 4 6g f2 3 6g f2 5 6g f3 4 6g f3 5 6g consider results valid optimizer construct plan end generates one result practical example query edepartment emanagerdepartment g sets department employee department employees manager 4 state transformation monoid one way handling side effects denotational semantics map terms compute values type functions type theta type state side effects take place term type mapped function takes initial state s0 type input generates value type new state s1 denotational semantics functions type theta called state transformers wad92 wad90 term performs side effects state transformer maps s0 different state s1 reflect changes otherwise state remains unchanged example constant integer 3 mapped state transformer s3 propagates state note new state computed value well may depend input state way side effects captured pure functions map states new states unfortunately add side effects calculus programs may multiple interpretations mainly due commutativity monoids results nondeterminacy highly desirable capture interpretations let optimizer select best one end handle type nondeterminism functional way given input state state transformer must able return multiple values multiple states words must able return multiple valuestates pairs consequently state transformer type sett theta capture possible interpretations program transformer state transformer phit type state type show shortly given monoid phi type always define primitive monoid phi state transformer phit contrast monoids described earlier monoid must higherorder monoid ie instances monoid functions definition phi described important proving correctness various transformation rules safely skipped reader interested proofs first present simple definition works well noncommutative nonidempotent monoids extent capture monoids transformation monoid state transformation monoid monoid phi z phi primitive monoid phi z phi defined follows z phi function applied state type constructs value fz phi sg merge function phi propagates state first state transformer second merges resulting values using phi easy prove n 0 state monoid comprehensions simply monoid comprehensions state transformation monoid example f fv sg j v 1 2 3 g s0 f3 sg s0 state type suppose state integer counts list elements following state comprehension increments element list 1 2 3 uses state count list elements f fv state transformer monoid phi effective must properties monoid phi otherwise may introduce semantic inconsistencies phi commutative idempotent must phi capture property redefine phi behave way phi f g defined follows ae phi commutative f g otherwise ae g phi commutative oe 1 phi oe 2 two interpretations one propagates state oe 1 oe 2 oe 2 oe 1 contribution factor g phi idempotent elements x removed x phi evaluated example integer state counts set elements fz phi s1g else g propagates state right left equal ff1g 1g counter counts list element 1 even though appears twice prove appendix theorem 1 extensions phi valid monoid also compatible phi monoid ie phi commutative andor idempotent phi capturing object far discussed state type indeed type wished capture database updates example state would entire database though interested capturing object identity state state transformer captures object identity viewed pair l n oho90 value l called object store maps objects type ie instances type objt values type maps oids object states integer n counter used computing next available oid four primitives manipulate state following types lookup ref n maps integer n oid references object type emptystore initial object store value without objects ext l v extends object store l binding oid state value v lookup l accesses object store l retrieve state object oid example lookup int ext int l ref int 100 1 ref int 100 returns 1 state object type objint oid 100 abover primitives satisfy following equivalences ext ext lookup lookup figure 1 presents denotational semantics important constructs monoid calculus without object extensions ie without new without object extensions state figure 1 denotational semantics monoid calculus using state transformers propagated changed semantics object extensions form nonstandard interpretation given later equations semantic brackets give meaning syntax enclosed brackets terms pure monoid comprehension calculus type domain typecorrect terms object monoid calculus monotype nonfunction type general e type type e denoted defined follows recall also state type pair l n convenience use notation l n whenever either components l n needs accessed rule s7 figure 1 handles functional terms example translated fvs 0 fv 0 g sg applied state rule s8 assumes callbyvalue interpretation rea89 e2 e1e2 evaluated e1 applied rules s13 s14 translate monoid comprehensions rule s14 uses monoid comprehension monoid phi propagate state every element collection u notice comprehension head state transformer state transformers merged using phi comprehension valid type collection u since monoid phi compatible monoid phi higherorder comprehension necessary since term u may modify object store time new object constructed cases though state propagated changed changed following rule applied eliminate state propagation correctness rule straightforward omitted following rules give denotational semantics object extensions operation newe takes available oid n uses oid new object state e addition object store extended binding ref n state value rule s16 instead destructively changing object store extends store new binding oid left part value right part rule s17 simply looks object store requested oid appendix provides proof theorem theorem 2 indicates state modification operations calculus output state input state canonical form derive normalization similar canonical form get pure monoid calculus theorem basically guarantees even though state transformation sequentializes operations program perform state modification normalization algorithm remove unnecessary state transformations following examples translation normalization terms object monoid calculus state l n interesting example incrementing elements set integers type setobjint set cardinality expressed help counter x support bags sets objects without inconsistencies example ffnew1 new2gg valid expression equal ffnew2 new1gg similarly assignments freely moved inside set constructions 6 translating object comprehensions efficient program seen previous section objectoriented comprehensions expressed term basic monoid comprehension calculus using denotational semantics rules figure 1 resulting programs usually inefficient since manipulate state even state used inefficiencies reduced help normalization algorithm algebraic equalities object primitives rules o1 o5 fact parts resulting programs normalized firstorder programs look similar programs one might write using four object primitives directly section focused efficient execution programs cannot reduced firstorder programs normalization algorithm translating object monoid calculus basic calculus consider possible alternatives due commutativity operations absolutely necessary proving program equalities normalization completed algebraic equalities used check program equivalences optimizer safely discard one alternative following function choose selects random alternative practice choice made help cost function given program p object calculus initial state s0 system evaluates choosenormalizep p first translated normalized finally alternative selected pair value state choose function defined follows rules figure 1 guarantee always least one choice case missing rules choosing alternative state monoid comprehension state monoid comprehensions cannot removed normalization algorithm efficient implementation comprehensions crucial considering system performance default implementation state monoid comprehension loop creates state transformer ie function iteration composes state transformers using merge function state transformation monoid approach obviously inefficient would like find better algorithms evaluate state comprehensions faster one possible solution actually compile comprehensions loops updates like ones found imperative languages particular choose phif e j v r g s0 translated following loop pascallike syntax initialize state res z phi initialize result value v r retrieve one possible valuestate pairs res res phi xfst update result xsnd update state return example previously shown set cardinality translated following state monoid comprehension mapped following loop res 0 r f res maxres lookupl refn return res l n even though loop right functionality still inefficient since manipulates object store l every step loop resulting programs implemented efficiently store global array object primitives programs directly manipulate global array rules s15 s16 singlethreaded since object creation undone point rule s17 enforce single array pointer fetching state first using lookup returning pointer l consequently always one pointer store therefore store implemented global store updates inplace destructive updates primitive operation object store done destructively specifically let store global array mentioned whose domain elements type eg store defined void c object primitives implemented follows lookup 0 implementation s1 evaluates statements order returns e example lookup ext ext x implementation resulting programs state transformation evaluated efficiently real objectoriented programs example previous loop corresponds set cardinality becomes res 0 r f res maxresstoren1 return use global array implementation object primitives 7 implementation already built prototype implementation framework translations oodb queries shown paper generated program source code available httpwwwcseutaedufegarasoid following examples illustrate translation five object queries system notation used examples little bit different used theoretical framework executes statements sequence returns value v loopiteratex executes statements value x x accessn returns value storen updaten v evaluates storen v every object query type translated expression type theta void theta int value returned value void value corresponds state ignored int value new oid counter assume value oid counter execution query equal n example object query e contain object operation translation would pairepairnulln pair constructs pair two values null type void assignres0 loopiterateee assignresmaxresplusaccessne assignspairblockupdatenplusaccessnenullsnds assignestructbindnameprojectderefename assignres0 loopiterateeemployees assignresplusresifgtprojectaccessesalary5000010 assignsifgtprojectaccessesalary50000 bindsalarytimesprojectaccessesalary108 snds figure 2 denotational semantics database updates first query new1 assigns 1 storen store next available oid sets n n 1 returns old value n second query executes storex storex third query corresponds f x generates block contains storen 1 old value storen 2 new value executed sequence fourth query generates state monoid comprehension turn translated loop returns sum elements e last query gives 8 raise employees earning 50000 returns number employees got raise simplicity assume employee name salary 8 database updates view maintenance monoid state transformer also used expressing destructive database updates terms basic algebra way database updates queries optimized single framework let db current database state let db type typically db aggregation persistent objects application following analysis previous section want translate updates monoid algebra way propagated state ie entire database singlethreaded database updates captured using state transformer propagates occasionally changes entire database updates captured pure functions map existing database new database make approach practical define set update primitives express updates similar ones object updates primitives even though pure interpretation efficient implementation approach require significant extension formal framework normalization query optimization used improve performance database updates expressed using following comprehension qualifiers feg qualifier path u destructively replaces value stored path u qualifier path u merges singleton u path qualifier path u deletes elements path equal u qualifier fundamental construct since two defined follows path u j path u phi u phi path path u j path phif j apath 6 ug example comprehension chotel num 1 g inserts new hotel arlington increases total number hotels denotational semantics expression e may contain updates ae binding list binds range variables current database state rules s1 s13 figure 1 need slightly modified include binding list ae every mapped example rule s13 figure 1 mapped rule s13 figure 2 rule s14 figure 1 though mapped rule s14 figure 2 changes ae include binding v range variable v1 generator domain binding list ae used rule s15 gives semantics update qualifier expression reconstructs database state copying components except one reached path replaced v defined follows aev type phi type path possibly empty path sequence projections expression sdbaev replaces occurrences db aev second rule applies state collection type third rule applies state record second rule uses condition force comprehension reconstructs collection value replace element v bound update new value e example point update chotels previous example binding list ae binds c dbcities case predicate guarantees hotels city c ie arlington changed one implementation ppath ae v path v destructively modifies part database reached path v better explained introduction motivation using denotational semantics simply give formal meaning destructive constructs use semantics actual translation constructs importantly use translation query optimization need define inverse function ppath ppath function needed translate updates programs optimized inverse function needed generate destructive updates optimization given reconstruction state say 0 copy except number places new values v used instead 0 generates list destructive updates form path v composition ppath constructs state 0 function ie defined follows list concatenation example returns chotels e original update approach first semantics program given terms state transformers ppath state reconstructions expanded normalization query optimization take place eliminate unnecessary updates finally reconstructed state transformed number destructive updates database using ie leave future work demonstrate framework effective framework handling object updates optimization framework destructive updates also used handle view maintenance problem gm95 ckl97 general form view function f database state db value domain materialized view v fdb stores view f database component v recognizing cases v used directly instead computing possibly expensive view f query becomes easier query normalized unnested since unnesting flattens query database updated new database becomes udb u functional interpretation update thus view maintenance problem equivalent expressing fudb terms materialized view v view recognition problem mentioned transforming update primitives fudb apply v instead db easily attainable expressing state transformations terms update primitives normalizing resulting forms way fudb compute new materialized view terms old one v apply techniques used database updates new materialized view fudb generated efficiently using destructive updates v planning show future research framework requires minimal extensions basic framework practical effective well 9 conclusion presented formal framework handling object updates oodb query optimization even though framework applied monoid comprehension calculus adapted work optimization framework many types object manipulation constructs expressed terms basic language constructs using denotational semantics consequently query optimization applicable basic language constructs used minimal changes remove inefficiencies due compositional way translating programs denotational semantics addition implement object store primitives using side effects resulting programs evaluated efficiently programs written hand acknowledgements author grateful david maier helpful comments paper work supported part national science foundation grants iri9509955 iis9811525 r rationale design persistence query processing facilities database programming language comprehension syntax object database standard odmg93 general framework optimization objectoriented queries efficient evaluation aggregates bulk types nested queries object bases recursive algebra query optimization nested relations supporting multiple view maintenance policies query optimization revelation uniform calculus collection types experimental optimizer oql query unnesting objectoriented databases algebraic framework physical oodb design towards effective calculus object query languages optimizing object queries using effective calculus maintenance materialized views problems advanced query processing object bases using access support relations transformationbased approach optimizing loops database programming languages representing object identity pure functional language keying method nested relational database management system ml working programmer peyton jones elements functional programming detecting global variables denotational specifications extending functional database languages update completeness comprehending monads essence functional programming tr detecting global variables denotational specifications recursive algebra query optimization nested relations comprehending monads advanced query processing object bases using access support relations rationale design persistence query processing facilities database programming language query optimization revelation overview representing object identity pure functional language ml working programmer elements functional programming transformationbased approach optimizing loops database programming languages general framework optimization objectoriented queries essence functional programming comprehension syntax towards effective calculus object query languages supporting multiple view maintenance policies query unnesting objectoriented databases optimizing object queries using effective calculus keying method nested relational database management system extending functional database languages update completeness algebraic framework physical oodb design ctr hiroaki nakamura incremental computation complex object queries acm sigplan notices v36 n11 p156165 11012001 g bierman formal semantics analysis object queries proceedings acm sigmod international conference management data june 0912 2003 san diego california leonidas fegaras david maier optimizing object queries using effective calculus acm transactions database systems tods v25 n4 p457516 dec 2000
stochastic scheduling variable profile precedence constraints paper consider stochastic profile scheduling problem partially ordered set tasks uniform processors set available processors varies time running times tasks independent random variables exponential distributions obtain sufficient condition list policy stochastically minimizes makespan within class preemptive policies result allows us obtain simple optimal policy partial order interval order inforest outforest b introduction consider following scheduling problem given set tasks run system consisting uniform processors ie processors different speeds executions tasks must satisfy precedence constraints described directed acyclic graph referred task graph processing requirements tasks independent random variables common exponential distribution set processors available tasks varies time availability processors referred profile arbitrary goal find preemptive schedules stochastically minimize makespan study scheduling variable profile motivated situations processors subject failures repairs failure repair times arbitrary another motivation scheduling multiprogrammed systems system execution tasks program may preempted tasks higherpriority programs task graph inforest profile constant set two processors chandy reynolds 2 proved highest level first hlf policy minimizes expected makespan level task simply distance root tree appears bruno 1 subsequently showed hlf stochastically minimizes makespan system two identical parallel processors pinedo weiss 14 extended last result case tasks different levels may different expected task running times frostig 7 generalized result pinedo weiss include increasing likelihood ratio distributions task running times recently kulkari chimento 9 extended result 1 case variable profile two identical parallel processors number identical parallel processors system arbitrarily fixed task running times common exponential distribution papadimitriou tsitsiklis 12 proved hlf asymptotically optimal number tasks tends infinity coffman liu 3 investigated stochastic scheduling outforest identical parallel processors constant profile uniform outforest subtrees ordered embedding relation see definition section 43 showed intuitive priority scheduling policy induced embedding relation referred successors ms policy paper stochastically minimizes makespan two processors addition outforest satisfies uniform rootembedding constraint greedy policy stochastically minimizes makespan arbitrary number processors papadimitriou yannakakis 13 studied deterministic scheduling intervalordered tasks assumptions unitexecutiontime constant profile showed arbitrary number identical processors simple list scheduling induced interval order still referred ms policy paper minimizes makespan notion profile scheduling first introduced ullman 16 later garey et al 8 complexity analysis deterministic scheduling algorithms dolev warmuth 4 5 6 carried various studies deterministic nonpreemptive profile scheduling parallel identical processors case profile simply number available processors time tasks unitexecutiontime dolev warmuth obtained polynomial algorithms specific profiles eg zigzag profile bounded profile etc specific task graphs eg inforest outforest opposing forest flat graph etc results extended deterministic preemptive profile scheduling liu sanlaville 11 paper investigate profile scheduling stochastic setting uniform processors scheduling allowed preemptive profile arbitrary may unknown priori obtain sufficient condition list scheduling policy optimal among preemptive policies makespan stochastically minimized result allows us prove optimality ms policy task graph interval order structure inforest structure uniform outforest structure results concerning intervalordered tasks new even constant profile parallel identical processors optimality ms policy extends result 9 inforests uniform processors result 3 outforests variable profile uniform processors paper organized follows section 2 scheduling problem described detail preliminaries presented section 3 sufficient condition list scheduling policy stochastically minimize makespan established section 4 result applied ms policies stochastic minimization makespan intervalorder task graphs forests uniform outforests concluding remarks provided section 5 problem description preliminaries task graph e directed acyclic graph set vertices representing tasks set edges representing precedence constraints implies task must complete execution task j start denote pi si sets immediate predecessors successors task without predecessors called initial task let si set necessarily immediate successors necessary notation sg used indicate si defined respect graph g particular attention paid following three classes c io c c task graphs interval order g 2 c io vertex corresponds interval b real line inforest vertex one immediate successor jsij 1 vertex called leaf inforest g called root inforest g outforest vertex one immediate predecessor jpij 1 vertex called leaf outforest g called root outforest g four graphs belonging classes illustrated figure 1 graph 1 interval order graph associated collection real intervals beside graph 2 inforest graphs 3 4 outforests note classes graphs following closure property c 2 fc fvg graph obtained deleting vertex v adjacent edges closure property deletion used establishing results processing requirements tasks independent identically distributed iid random variables common exponential distribution constant parameter say 1 running time task processing requirement task divided speed processor task running k 1 uniform processors indexed k speed processor k denoted ff k running times tasks processor k thus iid random variables exponential distribution parameter ff k assume convention ff 1 ff 2 delta delta delta ff k figure 1 examples task graphs set processors available tasks varies time due eg failures processors executions higherpriority tasks availability processors referred profile specified sequence fa random variables time epochs profile changed n 1 random set whose elements indices processors available time interval n n1 profile fa n1 assumed independent running times tasks without loss generality assume n 1 n 6 also assume profile changed infinitely often finite time interval finite n 1 n x profile said bounded scheduling policies decide enabled task ie unfinished task whose predecessors finished assigned available processor time task assigned one processor processor execute one task throughout paper assume scheduling policies preemptive assume scheduler information samples remaining processing requirements tasks let psi denote class policies 2 psi denote g makespan partially ordered set tasks g ie maximum completion times tasks g goal paper find policies psi stochastically minimize makespan g policy said optimal within class c policy 2 psi st g g 2 c symbol st refers standard stochastic inequality random variable stochastically smaller random variable 2 ir denoted x st increasing function f ir inequality efx efy holds provided expectations exist proofs main results use coupling argument based following wellknown result due strassen st denotes equality distribution lemma 21 strassen two random variables xy 2 ir satisfy x st exist two random variables defined common probability space st x st almost surely order simplify proofs main results paper make restrictions class policies psi observe first due memoryless property exponential distributions time distribution remaining running time task assigned processor k still exponential parameter ff k 1 k k represent state system set available processors remaining task graph distributions remaining running times tasks state change instants task completions profile modifications therefore without loss generality confine class policies preemptions new task assignments occur instants task completions profile modifications instants referred decision epochs hence assume policies psi make scheduling decisions time instants policy idling allows processor remain idle initial task waiting execution easy see optimal policy never idling since distributions task running times infinite support preemptions allowed furthermore optimal policy always use fastest available processors see 10 complete proof basic properties throughout paper assume policies psi nonidling use fastest available processors decision epochs 3 optimal list scheduling policies pay particular attention class simple scheduling policies referred list schedules policy called list schedule task graph list defined set tasks means task v higher priority v j list decision time epoch policy assigns enabled tasks highest priorities fastest available processors clearly list schedules class psi satisfy properties mentioned end last section note priority list changed dynamically ie given policy relative priority order two tasks changed task removed graph let c class graphs closed deletion class c said pmonotonic list schedule p 2 g 2 c initial tasks implies profile bounded p st recall g denotes makespan g schedule observe according definition c pmonotonic p gamma 1monotonic trivially class graphs 1monotonic list schedule however seen next section classes 2monotonic list schedule theorem 31 let c class graphs closed deletion pmonotonic list schedule p 2 g 2 c policy stochastically minimizes makespan g profile fa n1 bounded p st g 1 proof theorem needs following lemma lemma 31 let c class graphs closed deletion pmonotonic list schedule p 2 let g 2 c task graph ae 2 psi two policies g follow priority list time except first decision epoch first decision epoch policy assigns tasks k available processors q respectively assumption whereas policy ae assigns tasks k processors q 1 q 2 respectively permutation st g proof identical assertion trivially holds assume integers 1 q q j let 1 permutation defined follows policy follows priority list time except first decision epoch first decision epoch policy ae 1 assigns tasks k processors respectively show st g 2 couple running times processors q way policies ae 1 running time processor q n starting time 0 n 1 n k coupled model second decision epoch occurs time policies let time epoch fixed referred 2 decision epoch corresponds profile modification ie st g assume second decision epoch corresponds task completion easy see increasing function f c pmonotonic st thus fact q q j ff q implies hence increasing function f implies st unconditioning 2 relation yields 2 consider policy ae 1 done otherwise integers 1 permutation f1 2 defined follows policy follows priority list time except first decision epoch first decision epoch policy ae 2 assigns tasks k processors respectively show st ae 1 g repeating procedure kk gamma 12 times yields finally policy ae st st ae 2 g st ae 1 g st g proof theorem 31 prove induction n g v e 2 c st g 5 holds profile g singleton ie jv 5 trivial policies assign task fastest available processor assume n 1 relation 5 holds g jv j n consider task graphs g 2 c jv fix task graph g 2 c profile fa n1 policy 2 psi denote n1 sequence decision epochs finishing tasks g loss generality assume 2 corresponds task completion case analyzed similarly since policies psi nonidling use fastest available processors numbers tasks assigned execution first decision epoch policies first decision epoch policy assigns initial tasks k available processors respectively whereas policy assigns initial tasks processors q 1 q 2 respectively permutation f1 2 construct intermediate policy ae follows priority list time except first decision epoch first decision epoch policy ae assigns tasks processors q according lemma 31 g st aeg show st g 6 complete proof assumption 2 corresponds task completion increasing definition list schedule implies understood antisymmetric therefore pmonotonicity g implies st together inductive assumption imply st st therefore cf 7 8 e f readily implies 6 4 optimality mostsuccessor policies class intuitively good list schedules mostsuccessor ms policies priority task defined number necessarily immediate successors ie jsuj jsvj implies u oe ms v difference ms policies way ties broken ways assigning priorities tasks number successors section show policies optimal special classes task graphs ie intervalorder graphs inforests uniform outforests order prove optimality properties need compare task graphs done using following majorization let g two task graphs vertices ordered according number successors say g 1 majorized g 2 denoted g 1 oe g 2 proofs following equivalent definition also used let v 1 v 2 partitioned sets 1 2 words j k set vertices k successors graph g j example intervalorder graph figure 1 6g graph inforest k set vertices level k equivalent definition given follows graph g 1 majorized g 2 41 stochastic profile scheduling intervalorder graphs e 2 c io intervalorder graph note except possible set isolated vertices ie vertices without predecessors without successors intervalorder graph connected equivalent definition interval order graphs cf 13 immediate consequence definition jsij jsjj si sj consequently subset contains vertices whose sets successors identical cardinality k theorem 41 profile fa n1 set intervalordered tasks g 2 c io st g proof view theorem 31 need show c io mspmonotonic positive integer p ie two initial tasks u v g jsuj jsvj st fvg show common probability space applying strassens theorem cf lemma 21 yields 10 owing memoryless property exponential distributions consider coupled processing model processors available continually executing tasks completion occurs task assigned processor corresponds completion fictitious task task assigned processor assigned running time equal remainder running time already underway processor thus tasks u assigned processor time remaining running time denote fc n g 1 n1 increasing sequence completion times tasks g 1 g 2 available processors ms policy let fd n g 1 n1 superposition sequences decision epochs ms g 1 g 2 probability space specifically n1 superposition sequences profile modification times fa n g 1 n1 task completion times fc n g 1 n1 clearly remaining graph g j time n ms coupled model let g n 1 show n 1 immediately implies 11 relation 12 proved induction n trivial assume 12 holds n 1 let available processors time without loss generality assume processors available recall convention processors ordered speed ff 1 ff 2 ms policy initial tasks largest sets successors assigned fastest processors let u tasks g 1 n assigned processors respectively ms policy similarly let m2 tasks g 2 n assigned processors respectively ms policy definition g 1 n empty 12 trivially holds n 1 time epoch n1 corresponds profile modification relation 12 holds n 1 assume g 1 n empty n1 corresponds completion processor say processor h 1 h maxm belong 1 n v h belong 2 b n tasks u h andor v h finish time n1 three cases investigated case task u h finished easy see relation 12 holds case 2 h minm case tasks u h v h finished two subcases case 21 b simple therefore relation 12 holds case 22 b observe first examine case integers defined follows note 1 2 uniquely defined inductive assumption one note 1 according definitions n k j number noninitial tasks j k n g j n g h gamma 1 initial tasks n thus hand v implies h initial tasks 2 hence two inequalities together fact n k 1 imply therefore completes proof 12 case 22 case 3 case task v h finishes clear b tasks g 1 n assigned available processors obtain b hand v implies h initial tasks 2 hence b inequalities 13 14 imply therefore b 12 holds case 3 therefore induction relation 12 holds n 1 consequently msg 1 probability space 42 stochastic profile scheduling inforest e 2 c inforest task inforest g initial task leaf g task number successors equal level inforest ie distance root tree appears level roots zero convention thus ms policy coincides hlf policy theorem 42 profile fa n1 bounded 2 inforest g 2 c st g 15 proof theorem similar theorem 41 using fact c ms2 monotonic omitted reader referred 10 detailed proof note theorem generalizes result kulkari chimento 9 uniform processors different scheme proof note also result holds 2 simple counterexamples found three processors see 2 43 stochastic profile scheduling outforest e 2 c outforest task outforest g initial task root g vertex v 2 v successors subtree g denoted tg v simply v ambiguity general ms policies optimal within class outforests c counterexamples provided 3 however show within classes uniform runiform outforests introduced coffman liu 3 policy optimal ms two outtrees outtree 2 said embed outtree 1 1 embedded isomorphic subgraph exists injective function f 1 2 sfu function f called embedding function let r 1 r 2 roots outtrees 1 2 respectively 2 e 1 embedding function f fr 1 rootembedding function outforest g 2 c said uniform respectively runiform subtrees ordered embedding respectively rootembedding relation class uniform respectively runiform outforests denoted c uof respectively c rof clear c rof ae c uof ae c figure 1 graph 3 uniform outforest rootuniform outforest graph 4 rootuniform outforest embedding relation extended uniform outforests follows let g two uniform outforests denote tg v subtree outforest g composed v successors v g assume vertices g 1 g 2 indexed way outforest g 1 embedded g 2 referred g 1 oe e g 2 similarly g 1 oe r g 2 show ms policies optimal uniform outforests profiles bounded 2 well runiform outforests arbitrary profiles order establish optimality properties first prove c uof resp c rof ms2monotonic resp mspmonotonic positive integer p observe two roots u v uniform outforest g 2 c uof resp runiform forest jsuj jsvj thus two subgraphs g 1 g 2 g obtained deleting initial tasks g g 1 oe e g 2 g 1 oe g 2 last property allows us use arguments coffman liu 3 establishment following msmonotonicities lemma 41 let g 2 c rof arbitrary runiform forest u v two roots g jsuj jsvj profile fa n1 bounded 2 st msg gamma fvg proof lemma analogous proof theorem 1 coffman liu 3 although proof theorem 1 3 given constant profile parallel identical processors fact graphs g gamma fug g gamma fvg scheduled ms policy allows us use argument detailed proof left interested reader lemma 42 let g 2 c rof arbitrary runiform forest u v two roots g jsuj jsvj profile fa st msg gamma fvg assertion lemma shown mimicking proof theorem 2 coffman liu 3 detailed proof omitted applying theorem 31 yields theorem 43 profile fa n1 bounded 2 uniform outforest g 2 st g 16 theorem 44 profile fa runiform outforest g 2 c rof st g 17 concluding remaks considered scheduling problem stochastic minimization makespan task graphs variable profile assumption task running times independent random variables exponential distributions established general condition list scheduling policy stochastically minimize makespan result allowed us show optimality ms policies partial order interval order inforest outforest show except degenerate case single available processor time ms optimal policy stochastic minimization makespan reader referred 10 details results paper hold speed processors well availability allowed vary task assignment change whenever speed ratio two processors reversed extension allows one analyze systems processor sharing among different jobs ie sets tasks acknowledgements would like thank referees various constructive comments helped improve contents presentation paper r scheduling tasks exponential service times intree precedence constraints scheduling partially ordered tasks probabilistic execution times optimal stochastic scheduling outforests scheduling precedence graphs bounded height scheduling flat graphs profile scheduling opposing forests level orders stochastic scheduling problem intree precedence constraints scheduling opposite forests optimal scheduling exponential tasks intree precedence constraints two parallel processors subject failure repair stochastic scheduling variable profile precedence con straints stochastic scheduling intree precedence constraints scheduling intervalordered tasks scheduling jobs exponentially distributed processing times intree precedence constraints two parallel machines existence probability measures given marginals npcomplete scheduling problems tr
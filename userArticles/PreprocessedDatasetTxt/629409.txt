globally consistent event ordering onedirectional distributed environments abstractwe consider communication structures event ordering algorithms distributed environments information flows one direction example applications multilevel security hierarchically decomposed databases although general onedirectional communication structure partial order partial orders enjoy property consistently ordered formalization notion local ordering decisions ensured globally consistent main result crownfree property necessary sufficient communication structure consistently ordered discuss computational complexity detecting crowns sketch typical applications b introduction consider ordering events distributed environment purposes distributed environment one set events compose computation events occur network sites sites communicate passing messages applications impose restrictions communication structure restrictions exploited make efficient ordering decisions paper consider restrictions force communication occur one direction particular focus determine largest class communication structures capable guaranteeing consistent ordering decisions without resort global synchronization common task distributed environment decide ordering pair events standard approach problem lamports timestamp algorithm lam78 used impose partial order events basic idea behind lamports algorithm event site marked unique local timestamp timestamps drawn monotonically increasing sequence integer counter site sends message site b includes recent timestamp message upon receipt message b increases current timestamp timestamp value message necessary ordering pair events determined part consulting corresponding timestamps part consulting record message receipts given events e 1 e 2 lamports algorithm yields three possible comes namely e 1 precedes e 2 e 2 precedes e 1 e 1 e 2 concurrent interpretation last possibility unknown perhaps unimportant e 1 e 2 really happened first events must ordered concurrent events forced partial order according corresponding timestamps resolving case two identical timestamp values static precedence order sites yields total order motivation paper observation ordering decisions made obtain total order inherently artificial unsurprisingly single algorithm suits applications example transaction processing application suppose site receives message transaction timestamping algorithm determines far past receiving site site accept message site may obliged unwind later transactions incorporate effect remote transaction redo unwound transactions perspective receiving site would efficient ordering event determined least part clock site receives message rather clock site event occurred allowing event ordering determined upon receipt corresponding message given site lead inconsistencies example suppose event e 1 occurs site concurrently event e 2 occurs site b let send message e 1 b b send message e 2 ordering choices involve least rework order e 1 prior e 2 b order e 2 prior e 1 local order consistent global consistent order simple example shows ordering otherwise concurrent events done site receiving message structure sites communicate must antisymmetric otherwise absence global synchronization mechanism type inconsistency exhibited arise difficult extend example show transitive closure communication structure must also tisymmetric hence acyclic communication structure necessary general although restriction acyclic communication structures might seem strong useful applications multilevel security bl76 den82 hierarchical databases hc86 mandate restrictions information flow example multilevel security environment suppose site encapsulates database secret level site b encapsulates database unclassified level communication b prohibited prevent leakage classified information satisfactory make ordering decision event b upon receipt corresponding message since b opportunity make conflicting decision indeed existence events well information depends events must hidden b satisfy security requirements general acyclic structure partial order known partial orders lead global consistent orderings reviewed example later paper cf fig 1 multilevel security main restriction partial orders lattices common bl76 den82 lattice partial order pair sites unique least upper bound unique greatest lower bound unfortunately lattices also lead consistent orderings aj93b shown variety concurrency control algorithms multilevel replicated secure databases jk90 cos92 kk92 lattices permit inconsistent order ings ie unserializable execution histories serializability major concern database concurrency control conditions lead serialization problems correspondingly important restriction planar lattices sufficient avoid identified serializability problem cited concurrency control algorithms planarity necessary condition related paper shown componentbased timestamp generation aj93a planar lattice sufficient unnecessary consistent ordering paper develop formal notion called consistentlyordered property describe communication structures ensure globally consistent ordering decisions without resort global synchronization main result showing consistentlyordered property equivalent standard characterization partial orders known crownfree prop erty terms previous paragraph show crownfreedom necessary sufficient condition guarantee consistentlyordered property absence crowns partial orders useful applica tions example drw82 exploit crownfree partial orders develop efficient scheduling algorithm structure paper follows section 2 supply model event ordering distributed environment oneway communication structure model yields formal definition consistently ordered property section 3 introduce crownfree property show equivalent consistentlyordered property section 4 discuss computational complexity deciding whether communication structure crownfree section 5 make observations results sketch applications multilevel security hierarchical databases reader unfamiliar applications may wish read section 52 first section 6 conclude paper begin remark notation chosen present formalisms conventions z notation part z notation follows typical set theory different give explanatory note let classes set element refer class example multilevel security application classes might correspond possible security classifications confidential secretnato let finite subset classes let relation p antisymmetric transitive extend multilevel security example p corresponds security classifications actually employed dominance relation security classifications partial order say also write p allow case denote p p j incomparable finally assume greatest element discuss relaxing assumption later paper let events set element refer event example database application events might correspond set possible transactions let finite subset events extend database example e typically corresponds set committed transactions associate every event e class p partial function mapping combining prior examples might associate transaction particular security classification eg le 1 means transaction e 1 classified secret event e said local p event e visible class p exists p j p e local p j define e p set events local p pg informally definition reads e p set e type events le p require local events given class totally ordered first might appear would desirable require partial order local events however approach allows remote sites extend partial order inconsistently example transaction processing context model requires local site produce total serialization order local transactions even though pairs transactions might conflict reason two remote sites might induce different serialization orders scheduling transactions thus precluding global consistent order model total order local events let p sequence events e p p total injective respect e p local event e p appears exactly p model ordering decisions class p constrained ordering decisions dominated classes ie classes e 1 e 2 events visible p e 1 e 2 ordered class p j class p must respect ordering hand ordered class p j class p free choose either ordering two events also reason site must totally order local events site must also totally order visible events introduce machinery formally express idea define subsequence predicate whose signature follows let b two sequences events v b true iff obtained b discarding events b define globalp injective sequence events visible p 1 p v globalp 2 first condition globalp states globalp must respect local order p second condition globalp states globalp must respect total orders chosen dominated classes p j second constraint reads p j type classes p j dominated p case globalp j subsequence globalp note p free variable constraints given partial order set events e may many possible values globalp ie global relation function however choices globalp j may exist possibility exhibited table 1 figure 1 suppose class e class class globalp class exist table 1 event ordering assignments figure 1 example partial order consistentlyordered consider event ordering assignments given table 1 given events orderings globalp max exist provide concrete interpretation difficulty exhibited table 1 suppose e 1 e 2 transactions classes p 1 p 2 spectively suppose globalp represents equivalent serial order execution history transactions visible p example shown value globalp 3 indicates p 3 serializes e 1 perhaps scheduling unshown local transaction simi larly value globalp 4 indicates p 4 serializes e 2 e 1 since communicate unable detect global serialization anomaly arisen however inconsistent serialization apparent p max reflected fact globalp max exist purpose paper find largest class partial orders still guarantees existence globalp class p matter choices made constructing globalp j dominated classes informally class conforming structure make arbitrary ordering decisions otherwise unordered events still guaranteed resultant global ordering consistent formalize notion consistent global ordering follows definition partial order consistentlyordered p iff classes possible sequences events globalp j exists least one globalp extend notion consistently ordered entire partial order say consistentlyordered iff consistentlyordered greatest element example partial order figure 1 consistentlyordered p 4 p max shown choices exhibited table 1 hence partial order figure 1 consistentlyordered 3 crownfree property induced subgraph vq vd tail e belong vqg infor mally induced subgraph retains many edges possible parent graph crown subset fx p x j mod n1 crown exhibited figure 2 imagination crown envisioned three dimensions crownfree iff crown definition crown variation one bou85 similar riv85 page 531 crowns directed graphs defined analogously crowns partial orders note directed acyclic graph contains crown iff exists induced subgraph q 1 q bipartite 2 undirected version q cyclic example directed graph shown figure 1 crown since desired q obtained discarding p max continue example let partial order whose hasse diagram shown figure 1 directed graph whose nodes p whose edges note definition transitively closed even though corresponding hasse diagram eg figure 1 show transitive edges purposes clarity crown since discard p max obtain q give main result paper theorem 1 consistentlyordered iff crownfree proof suppose consistentlyordered crownfree sake contradiction consider least one crown let q crown label minimal n nodes q label maximal n nodes q p loss generality relabel 2n nodes q necessary p dominates figure 2 let globalp igamma1 mod n1 e mod n1 let p max denote maximal element p globalp exist since requiring sequence accommodate orderings impossible hence consistentlyordered contra diction therefore crownfree suppose crownfree consistentlyordered au au au au figure 2 crown sake contradiction consider partial order consistentlyordered consider p minimal element p globalp necessarily exist consider instance p unable form globalp must case p faced inconsistent set event ordering requirements event ordering form x e requirement order events imposed globalp j suppose minimal sized set inconsistent event orderings let size n relabel events needed may listed make several observations since assumed minimal size event list appears exactly twice also event e since minimal le see suppose le ordering e e j done exactly done namely le j hence substituting occurrences e j e could reduce size contradiction similar arguments apply le thus n incomparable classes n events giving rise local collect n classes set b low note b low antichain e mod n1 consider least upper bound class claim exactly n distinct least upper bound classes pairs classes see suppose n least upper bound classes pair classes would least two least upper bounds figure 1 clear crown contradiction suppose fewer n least upper bound classes least two pairs must share least upper bound denoted p j two pairs must comprise least 3 distinct events globalp j totally orders events minimal size contradiction collect n least upper bound classes set b high classes b high incomparable else could argue minimal note b high also antichain let q directed graph whose nodes b low b high whose edges defined q bipartite undirected version cyclic cycle exhibited structure therefore crown namely q contradiction figure 2 provides illustration 2 computational complexity use results section 3 give polynomialtime algorithm determining whether communication structure ensures globally consistent event orderings theorem 1 suffices show crownfree naive algorithm explicit checking subset bipartite property existence cycle obviously exponential bouchitte bou85 gives polynomialtime algorithm summarize crown detection problem crown detection algorithm based deriving bipartite graph partial order using elimination scheme examine bipartite graph split graph partial order p bipartite graph e x 2 p associated one vertex vertex edge v w 0 e x v associated x w 0 associated bouchitte bou85 trotter tro81 establish crowns p give rise crowns split graph crown split graph 4 nodes comes crown p thus suffices check p crowns size exactly four check split graph bipartite existence crowns note bipartite graph crown size greater 4 chordless cycle length greater 4 bipartite graph every cycle length greater 4 chord called chordal bouchitte shows bipartite graph g chordal following iterative procedure results graph edges done 1 g contains vertex one neighbor remove vertex incident edge 2 else g contains edge xy every neighbor x adjacent neighbor viceversa remove edge ie remove two vertices incident edges 3 else done true g edges return chordal else return chordal let g g 0 denote graph beginning end respectively iteration correctness algorithm follows facts every chordal graph edge type described condition 2 g chordal iff g 0 chordal bou85 edge eliminated chordless cycle length greater let n number nodes number edges graph arising p checking crowns size 4 done brute force time 4 split graph 2n nodes edges constructed time om elimination algorithm 2n iterations worst case iteration involves time search vertex eliminated plus om checks whether edge eliminated takes time 2 thus total running time practice possible substantially improve running time precomputing list candidates elimination updating list iteration loop remark result major importance complexity crown detection partial orders polynomial rather npcomplete address complexity crown detection arbitrary directed graphs since issue directly relevant paper however given variance complexity results standard graph problems dependent whether graph question corresponds partial order moh possible crown detection arbitrary directed graphs npcomplete section make observations results discuss results applied problems two areas namely multilevel security hierarchical databases 51 observations analysis given far assumed partial order greatest element recall partial order greatest element iff partial order unique maximal element reason assumption follows suppose greatest element least one crown every crown q least one node q maximal element scenario clearly still possibility globally inconsistent event ordering node position observe inconsistency lack observer complicates discussion analysis assumed greatest element practical purposes important whether greatest element either case crown globally inconsistent ordering decisions possible necessarily observable second set observations relates crownfree property typical classifications partial orders often employed special case partial order lattice lattice pair classes unique least upper bound unique greatest lower bound lattices necessarily crownfree seen considering subset lattice set three elements see aj93a aj93b elaboration example another intuitively appealing special case partial order planar partial order partial order planar hasse diagram planar edge hasse diagram monotone ie edges prohibited looping around outside diagram see riv85 diagram fuller explanation consulting results riv85 types structures nonplanar partial orders must contain enumerated note structure q figure 2 proscribed list riv85 figure page 121 thus sure planar partial orders crown free one also see directly structure figure 2 nonplanar existence structures list riv85 demonstrates although restriction planarity sufficient condition partial order consistentlyordered necessary condition 52 applications primary concern multilevel security information leakage information secret database leaking process executing unclassified level leakage occur two ways directly overt operation reading data item indirectly covert signaling channel direct leakage accounted following socalled mandatory access control policies belllapadula model bl76 den82 indirect leakage troublesome covert signaling channel information leaks means contention resource bl76 den82 lam73 example channel provided read write locks conventional database database locking protocol concurrency control read write data item must preceded acquisition read write lock request write lock potentially made transaction unclassified level delayed read lock already granted perhaps transaction secret level delay experienced unclassified transaction used infer activity secret level hence secret information leaks unclassified level secret transactions obtain standard read locks unclassified data items problem covert signaling channels extensively studied one general approach physically separate components one security level components another thus simplifying argument indirect channels arise natural outgrowth trend distributed implementation type onedirectional communication structure subject paper particular multilevel replicated secure databases first identified com83 lend distributed implementations candidate concurrency control algorithms multilevel replicated secure databases appear jk90 cos92 kk92 part algorithms assume communication structure different security classes lattice reasons outlined den82 however noted lattices crowns hence without additional synchronization information distributed implementations multilevel replicated databases cannot guarantee serializable execution transaction histories lattices recognition problem published concurrency control algorithms fact beginning present paper given interest constructing multilevel systems precise demarcation problematic structures clearly required solutions dilemma ensure communication structure crownfree modify structure crownfree add additional synchronization measures global clock communication structures similar multilevel security appear hierarchical databases hc86 hierarchical databases partition global database access characteristic transactions typical hierarchical database might main database containing raw information derivative databases transactions read write raw data reader referred hc86 aj93a explanation hierarchical databases hierarchical databases information leakage requirements ever still undesirable derivative database interfere concurrency control main database interference could take form holding read locks raw data items forcing transactions main database abort preserve serializability timestampordering protocol results paper applied hierarchical databases follows communication structure hierarchical database restricted crownfree distributed implementation guarantees globally serializable transaction histories possible without introduction additional synchronization information 6 conclusion networks information flow restricted one direction distributed network figure prominently applications multilevel security hierarchical databases networks requirements event ordering differ substantially unrestricted networks indeed improvements ordering decisions possible paper defined consistentlyordered property describe communication structures local ordering decisions guaranteed globally consistent without introduction additional synchro nization centralized clock main result employed crownfree property partial orders prove crownfree partial order equivalent consistentlyordered one fortunately crown detection carried polynomial time results paper applied application onedirectional communication structures multilevel security hierarchical databases ensure distributed applications enjoy desirable properties serializable execution histories future work aj93a componentbased timestamping algorithm developed planar lattices results paper indicate timestamping algorithm applies crownfree partial orders hc86 proof technique called partitioned synchronization rule presented demonstrating correctness database concurrency control algorithms proof technique proven communication structures restricted semitrees results paper indicate partitionedsynchronization rule applies crownfree partial orders items future work verify two conjectures acknowledgements pleasure acknowledge ivan rival sharing expertise partial orders john mcdermott discussing problem consistent ordering jeff salowe considering computational aspects crown detection r distributed timestamp generation planar lattice networks planar lattice security structures multilevel replicated databases secure computer systems unified exposition multics interpretation chordal bipartite graphs crowns committee multilevel data management security transaction processing using untrusted scheduler multilevel database replicated architecture cryptography data security minimizing setups cyclefree ordered sets perfect elimination chordal bipartite graphs partitioned twophase locking transaction processing multilevelsecure databases using replicated architecture transaction processing multilevel secure replicated databases note confinement problem algorithmic aspects comparability graphs interval graphs graphs order role graphs theory ordered sets tr ctr transaction processing multilevel secure databases kernelized architecture challenges solutions ieee transactions knowledge data engineering v9 n5 p697708 september 1997
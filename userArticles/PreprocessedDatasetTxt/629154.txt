efficient heuristic permutation packet routing meshes low buffer requirements even though exact algorithms exist permutation routine nsup 2 messages ann mesh processors require constant size queues constants largeand algorithms complicated implement novel simple heuristic problem presented uses constant small size queues size2 simulations run randomly generated data number routing steps required algorithm almost equal maximum distance packet travel pathological case demonstrated routing takes optimal itis proved upper bound number required steps onsup 2furthermore shown heuristic routes optimal time inversion transpositionand rotations three special routing problems appear often design ofparallel algorithms b introduction important task design parallel computers development efficient parallel data transfer algorithms 1 9 two fundamental performance measurements number parallel steps required complete message packet transfer additional buffer queue size needed queueing processor study packet routing problem ie problem given interconnection network processors route right data packets right processor fast routing efficient processors must able communicate fast size queues buffers created processor must constant small requirement small constant buffer area processor important makes parallel architecture scalable paper present novel technique packet routing mesh n theta n array processors technique builts well known oddeven transposition method 2 main contribution technique uses small queues buffer area exactly 2 packets needed algorithm simple require complex operations maintenance buffers good candidate hardware implementation furthermore experimental results show number steps required complete routing almost equal maximum distance packet travel since data experiments obtained random number generators suggest algorithm performs optimally high probability chosen mesh parallel architecture simple regular interconnection pattern makes especially suited vlsi implementation addition since euclidean distance neighboring processing elements constant mesh time needed communication pair connected elements also constant furthermore although mesh large diameter 2n gamma 2 n theta n mesh topology well matched many problems previous work packet routing includes deterministic 4 5 6 probabilistic 3 9 approaches trivial greedy algorithm routes packets correct column correct row 2n gamma 2 steps size queues however bad nontrivial solutions given problem based parallel sorting algorithms 7 8 kunde 4 5 first use parallel sorting obtain deterministic algorithm completes routing 2n onfn steps queues size ofn later leighton makedon tollis 6 derived deterministic algorithm completes routing 2n gamma 2 steps using constant size queues first probabilistic algorithm derived valiant brebner 9 completed routing 3n using olog n size queues later krizanc rajasekaran tsantilas 3 derived probabilistic algorithm routes packets 2n olog n steps using constant size queues probabilistic algorithms route packets correctly high probability important note although two already known algorithms use constantsize queues size constant large authors admit constant bound resulting queuesize practical even moderate values n say n 100 thus efficient heuristics needed one propose practical applications design parallel computers preliminaries nthetan mesh processors defined graph edge belongs e 1 n theta n mesh illustrated figure 1 one step processor communicate neighbors use bidirectional links called channels define distance two processors p 2 neighbors convenient description algorithms talk east west north south neighbors given processor formally processor define east neighbor processor 1 west neighbor processor 1 north neighbor processor p figure 1 2dimensional mesh south neighbor processor p processors said boundary mesh 1 processors boundary mesh four neighbors defined processors assumed work synchronous mimd model permutation problem processor one packet transmit another processor end processor receives exactly one packet 11 routing problem route packets destinations fast without use large additional storage area buffers processor originally oddeven transposition method used sorting elements linear array method works follows odd time instances processors odd array positions compare contents contents east neighbors decision made whether exchange contents occur even time instances comparison possible exchange occurs processors even positions array east neighbors figure 2 shows comparisons performed time array 8 elements figure 2 comparisons performed oddeven transposition method time instances t0 t1 array 8 elements 3 routing algorithm routing algorithm always tries reduce summation distances packets travel let dt dt respectively total distance packets travel time instances 1 dt trivially true equality holds time instance 1 guarantees eventually packets reach destinations time let processors p p i1 contain packets p p i1 let distance packets travel i1 respectively say distribution packets processors p p i1 time normalized exchange contents processors reduce total distance dt also maxd distances packets travel exchange example normalization distances shown figure 3 call packets whose contents compared compared packets figure 3 examples normalization algorithm route high level description ffl assume processors row mesh form linear array oddeven transposition takes place ffl perform oddeven transpositions rows mesh described section 2 distances compared packets travel always normalized packets moving horizontally ffl packet reaches processor lies column destination packet processor wants move vertically direction south north starts vertical movement figure 4 otherwise packet go column moves vertically packet participates oddeven transposition taking place row figure 5 figure 4 uninterrupted vertical movement packets figure 5 interrupted vertical movement packets theorem 1 algorithm route needs buffering area exactly 2 packets proof consider situation queue created two packets enter given node one moving vertically moving horizontally must change direction movement reached column destination want move vertically direction one must wait thus queue created routing algorithm happen algorithm property two packets moving horizontally opposite directions cannot enter processor time property comes application oddeven transposition two packets want travel vertical direction one go chosen instead placed queue participates oddeven transposition far used buffer area one packet area packet initially processor remains show communication neighboring processors implemented remember step processor communicates horizontal direction neighbor east west consider two neighboring processors communicate current step algorithm one transmit contents time keep copy original packet packets received processor computes distance two packets still travel exchange distances normalized exchange previous contents packets discarded distances exchange normalized exchange ignored observe neighboring processors exactly computations data thus reach compatible results also observe using described scheme buffer area one extra packet needed completes proof performance section present simulation results algorithm based random routing problems 100 theta 100 mesh connected array present case algorithm takes table 1 experimental results random routing problems 2n steps prove algorithm completes routing within 2 steps 41 experimental results simulated algorithm using random routing input data 100 theta 100 50 theta 50 20 theta 20 mesh connected array data generated help random number generator function drand48 sun workstation experiment set start different point random sequence generated function run hundreds experiments got near optimal performance 1 routing step table shows results simulations 100 theta 100 mesh connected array second column table contains maximum distance packet travel specific experiment distance always less equal 198 since working 100 theta 100 mesh fact entries column mean data corresponding experiments identical destinations 10000 packets experiment totally different third column table 1 contains number routing steps needed completion routing note number figure permutation packets results nonoptimal routing time almost 1 maximum distance corresponding experiment implies performance heuristic near optimal 42 low performance packet routing problem spite good experimental behavior algorithm route exist permutations packets result routing time optimal section present initial setting packets assume destinations packets n theta n mesh shown figure 6 ffl packets first row columns 0 trough destined southeast p n theta n corner mesh initially position 0 destined processor position observe packets initially located west packet p travel p oddeven transposition first row packet p moves west since always try normalize distances packets travel reaches table 2 experimental results number delayed packets random routing problems nonoptimal solutions forced occur processor position 00 starts moving east reaches column moves vertically arrives destination total movement packet p takes n routing steps mention although exists case required routing time optimal case produced random number generator indicated table 2 required number steps problem bad situation forced occur depends distance bad packet p travel furthermore indicated table 3 small portion packets received optimal time delayed packets specifically experiments 3840 packets initial load 10000 packets delayed packets traced packets back origins found originated first row mesh obvious conclusion experiments performance routing algorithm bad situation occurs seems depend packets constitute bad situation remind reader tables 2 3 contain entries small portion simulations table 3 experimental results random routing problems nonoptimal solutions forced occur 43 upper bound given low performance routing problem described previous section natural ask upper bound number routing steps required algorithm route order solve permutation routing problem trivial see algorithm route cannot take 3 routing steps route permutation routing problem routing step least one packet approach destination total distance packets travel reduced least 1 maximum total distance packets travel 3 implies 3 routing steps packets reach destinations however prove algorithm route completes routing within 2 steps proceed proof need following definitions lemmata definition packet given time instant participates oddeven transposition said row mesh said empty time time instant packet typeh row assume row mesh n packets typeh also assume packet cross row order reach destination 2n steps row empty proof observe packet wants cross row north south packets participate oddeven transposition ones originally row another obvious observation impossible two packets switched previous time instant compared switched implies packet move n steps away destination n steps every packet reach column destination leave row assume row mesh n packets typeh also assume k packets want cross row order reach destination 2n steps row empty proof similar lemma 1 theorem 2 algorithm route complete routing permutation problem 2 routing steps proof prove theorem showing every row mesh empty 2 steps n steps packets reach destinations since moving vertically collisions happen lemma 1 implies rows 0 empty 2n steps use lemma 2 obtain general statement consider row k 1 packets want cross row k order reach destinations lemma 2 know row k empty routing steps expression gets maximum value proves theorem theorem provides upper bound number routing steps required algorithm route however able construct routing problem takes 2 steps completion algorithm route conjecture algorithm route solve permutation routing problem within 4n routing steps true analysis tight since constructed complicated routing problem needs 4n steps completion also first routing algorithm mesh requires routing steps based sorting submeshes existence algorithm open problem 44 interesting property section prove property algorithm route concerning way total distance packets travel reduced course algorithm exploring similar properties might key tool effort prove nonsorting based algorithm terminates steps theorem 3 let denote set packets row time ds l denote total distance packets set still travel time l l 0 every row proof consider packets row time constitute set packets divided two categories packets participate oddeven transposition already defined typeh packets move vertically north south call typev consider two cases case 1 contains packet type v first assume two compared packets want travel opposite directions exchanged ds next step packets may continue horizontal movement start moving vertically move case total distance decreased thus 2 assume compared packets want move direction even exchange takes place total distance packets travel remains two possibilities pairs compared packets direction two pairs want travel opposite directions pairs travel direction must less n packets row n packets say moving left leftmost one must correct column must type v assumed packet exists less n packets row implies exist gap packet must adjacent next step packet adjacent gap occupy thus get ds 1 second possible case two pairs packets want move opposite directions next step adjacent packets compared exchange occur thus ds 2 adjacent must gap case ds case 2 least one packet type v let p packet p moves vertically time t1 ds 1 consider happen next step packet p stays correct column next step ds assume next step forced move away destination might ds row k k show ds kt 2 fact packet p forced move away destination implies two things first another packet row k destined column packet p addition go packet forces p participate oddeven transposition secondly another packet forces p move column destination thus two packets set kt reduces distance one step ds kt 2 routing problems solved optimally section consider special forms permutation routing problems algorithm performs optimally prove permutation problem rotation inversion transposition 2n steps required procced examine problems prove two useful lemmas concern permutation routing chain processors 51 permutation routing chain processors lemma 3 permutation routing problem chain n processors solved n steps using oddeven transposition method proof way solve permutation routing problem sorting packets according destination addresses since oddeven transposition method used sorting linear arrays time required sorting also enough routing know order n elements linear array size n need exactly n steps oddeven transposition method used 2 lemma 4 permutation routing problem chain processors solved r routing steps r maximum distance packet travel proof achieve number steps stated lemma packets start motion time always travel towards destinations nothing delay packet since step every packet approaches destination packet travel distance r r routing steps 52 rotations permutation packet routing problem n theta n mesh called l mrotation packet initially position j destined position horizontal rotation vertical rotation diagonal rotation next theorem shows kinds rotations algorithm route optimal theorem 4 given n theta n mesh processors algorithm route needs nmaxln gamma steps order complete routing permutation problem l mrotation proof moment assume algorithm route routes packets two consecutive time disjoint phases first phase routes packets horizontally reach column destination second routing phase starts packets reach column destination packets routed final destination along columns array observe second phase starts processor column exactly one packet route vertically beginning routing packets row destined different columns thus phase algorithm permutation problem solve since use oddeven transposition method order route packets first phase know lemma 3 n steps enough second phase routing done described lemma 4 need exactly steps order complete routing thus total steps required analysis assumed packets routed two time disjoint phases assumption true however analysis still valid see observe packets destined column reach column step thus packets destined column start column routing time synchonization permits us treat movement packets two separate phases horizontal vertical one completes proof 53 inversion permutation packet routing problem n theta n mesh called inversion packet initially position j destined position n theorem 5 shows algorithm route performs optimally routing problem inversion theorem 5 given n theta n mesh processors algorithm route needs exactly order complete routing inversion packet routing problem proof packets destined column initially located column j since movement packets columns similar packets destined column reach column step proof theorem 4 assume analysis routing done two time disjoint phases lemma 3 know first phase needs exactly n routing steps maximum distance packet travel second phase n gamma 1 packets initially located first row mesh destinations last row mesh applying lemma 4 conclude second phase takes exactly steps thus algorithm route solves inversion packet routing problem exactly 2n gamma 1 steps 54 transposition permutation packet routing problem n theta n mesh called transposition packet initially position j destined position j 0 theorem 6 given n theta n mesh processors algorithm route needs exactly routing steps order solve transposition routing problem proof without loss generality consider packet p initially located position j j case j treated similarly packet p destined location j observe packets left also destined column travel greater distance specifically packet k positions left travel 2k step p p trapped packets left result moves left hits left boundary mesh moves uninterrupted right reaches column destination finally moves vertically destination figure 7 illustrates motion packet p note interaction packets occurs vertical routing packets left column want move upwards right want move downwards travel packet p initially position takes total routing steps implies packets reach destinations steps since maximum value take n gamma 1 6 conclusion work presented efficient heuristic routing messages packets mesh connected parallel computers main advantage algorithm uses buffer area exactly 2 packets per processorfurthermore algorithm simple experimental behavior indicates performs optimally random routing problems first time according knowledge heuristic reported surprisingly good experimental results make important interesting problem would prove algorithm works figure 7 motion packet p routing transposition optimally high probability however fact movement packet depends destinations neighboring packets time instance makes problem difficult challenging one another interesting problem provide tighter analysis algorithm route gap upper bound 2 routing steps 4n performance worst case routing problem able construct r torus routing chip art computer programming optimal routing algorithms meshconnected processor arrays routing sorting meshconnected arrays packet routing grids processors routing n theta n array constant size queues optimal sorting algorithm mesh connected computers sorting meshconnected parallel computer scheme fast parallel communication tr optimal sorting algorithm mesh connected computers optimal routing algorithms meshconnected processor arrays extended abstract routing sorting meshconnected arrays extended abstract 2ini2 step algorithm routing inxni array constant size queues art computer programming volume 3 sorting meshconnected parallel computer ctr antonios symvonis jonathon tidswell empirical study offline permutation packet routing twodimensional meshes based multistage routing method ieee transactions computers v45 n5 p619625 may 1996
efficient algorithm finding csg representation simple polygon consider problem converting boundary representations polyhedral objects constructivesolidgeometry csg representations csg representations polyhedron p based halfspaces supporting faces p certain kinds polyhedra problem equivalent corresponding problem simple polygons plane give new proof interior simple polygon represented monotone boolean formula based halfplanes supporting sides polygon using halfplane main contribution efficient practical log n algorithm boundarytocsg conversion simple polygon n sides also prove nice formulaelig always exist general polyhedra three dimensions b desirable representations compact support efficient simulation realworld operations objects years two different styles representation emerged used nearly geometric modeling systems currently existence first style representation describes object collection surface elements forming boundary boundary representation effect boundary representations reduce problem representing solid object one representing surface elements somewhat simpler problem since set one dimension less second style representation describes solid object constructed regularized boolean operations simple primitive solids boxes spheres cylinders etc description referred constructive solid geometry representation csg rep resentation short style representation advantages disadvantages depending operations wish perform objects reader referred one standard texts solid modeling 13 16 review article 23 details representations relative merits one looks modelers either camp example romulus 16 geomod 25 medusa 17 modelers boundary persuasion padl1 27 padl2 2 gmsolid 1 modelers csg persuasion one nearly always finds provisions converting representation important indispensable step poses challenging computational problems 1 paper deal certain cases boundarytocsg conversion problem present efficient computational techniques conversion approach based peterson 21 peterson considered problem obtaining csg representation simple polyhedral solids prisms pyramids necessarily convex based halfspaces supporting faces solid solids effect twodimensional objects think base prism pyramid third dimension added simple manner thus peterson considered problem finding csg representations simple polygons plane related problem finding convex decompositions simple polygons 4 18 20 26 28 complicated argument peterson proved every simple polygon plane admits representation boolean formula based halfplanes supporting sides formula especially nice supporting halfplanes appears formula exactly hence formula monotone complementation needed reason focus attention formulae call petersonstyle formulae monotone formula polygon polyhedron desirable makes possible predict small perturbations defining halfspaces affect overall volume important property various applications solid modeling machine tooling machining peg fit hole example important know errors position defining halfspaces result making peg smaller halfspace negation enter formula perturbation defining plane make volume smaller one part object simultaneously quote requicha 23 relative paucity known conversion algorithms poses significant constraints geometric modeling systems build today larger another part paper first give short new proof every polygon petersonstyle formula section 3 peterson explicitly consider algorithms deriving csg representation polygon naive implementation based proof would require conversion n size number sides vertices polygon provide paper efficient thetan log n algorithm boundarytocsg conversion section 4 regard algorithm major contribution paper algorithm uses many interesting techniques growing field computational geometry 5 22 nevertheless simple codeits subtlety lies analysis performance implementation finally section 5 show peterson style formulae always possible general polyhedra three dimensions discuss number related issues believe work presented paper illustrates several concepts techniques computational geometry used solve problems clear importance solid modeling computer graphics solution obtain mathematically interesting practical implement expect see applications computational geometry areas future hope paper motivate researchers graphics area study computational geometry techniques closely formulation history problem let p simple polygon plane context simple means nonselfintersecting jordan curve theorem polygon subdivides plane two regions interior exterior general identify polygon interior let us orient edges p interior p lies locally right edge give oriented edge name call names literals literal also give second meaning literal also represents halfplane bounded infinite line supporting edge extending right line speak figure 1 simple polygon p halfplane supporting side halfplane supporting polygon even though p might lie halfplane see figure 1 illustration concepts notice point x plane know whether x lies inside outside halfplanes supporting know fact x inside p fol lows regions plane subdivided infinite extensions sides p lies either wholly inside p wholly outside result must exist boolean formula whose atoms literals p expresses interior p example p convex formula simply literals since ands ors somewhat cumbersome write switch point algebraic notation use multiplication conventions addition conventions consider two simple polygons shown figure 2 formulae two polygons uvwx polygon uvwx b associated boolean expression trees also shown figure 2 notice petersonstyle formulae monotone use literal exactly reader invited point make sure formulae indeed correct b x z x z x z z x figure 2 formulae two polygons complex formula simple polygon given guibas ramshaw stolfi 9 kineticframework paper style formula two polygons figure 2 uv phi vw phi wx phi xy phi yz phi zu phi denotes logical xor overbar denotes complementation explained 9 type formula purely local depends convexconcave property successive angles polygon rule obvious example go around complement second literal corresponding vertex convex angle first literal concave angle thus formula example polygons although formula style trivial write desirable solid modeling petersonstyle formula use complementation xor operator peterson formula difficult derive captures sense polygon nests within thus global character viewed naively inclusionexclusion style formula reflects global structure polygon caution reader however view peterson formula naive led us couple flawed approaches problem general many boolean formulae express simple polygon terms literals proving equivalence two boolean formulae polygon nontrivial exercise reason 2 n primitive terms one form literals complementation allowed thetan 2 nonzero sense denote nonempty regions plane thus numerous identities hold must used proving formula equivalence decomposition simple polygon convex pieces 4 18 20 26 28 gives another kind boolean formula polygon one literals halfplanes convex polygons depending type decomposition desired convex polygons may may overlap overlapping case formula may may contain negations expand literals convex decomposition ands halfplanes result need petersonstyle formula negations repeated literals halfplanes support polygon possible leave boolean domain allow algebraic formulae describing characteristic function simple polygon formulae purely local sense xor formula given paper franklin 6 franklin describes algebraic local formulae polyhedra well discuss goes beyond csg representations concerned 3 existence monotone formulae section prove interior every simple polygon p plane expressed petersonstyle formula monotone boolean formula literal corresponding side p appears exactly turns natural work simple biinfinite polygonal chains chains short simple polygons example simple biinfinite chain c shown figure 3 chain c terminated two semiinfinite rays contains arbitrary number finite sides simple biinfinite subdivides plane two regions general orient c consistent manner speak region plane lying left c right c respectively abuse language refer regions halfspaces left halfspace semiinfinite rays right halfspace c e f l figure 3 simple biinfinite chain interior simple polygon p always viewed intersection two chain halfspaces let r denote respectively leftmost rightmost vertex p figure 4 extend sides p incident infinitely far left sides incident r infinitely far right clear thus obtain two simple biinfinite chains interior p intersection halfspace upper chain halfspace lower chain notice also literals used upper lower chains two halfspaces form partition literals p thus suffices prove chain halfspace admits monotone formula using literals exactly l r upper chain lower chain figure 4 interior simple polygon p chain consists single line claim trivial formula single literal defines line chain c one edge prove claim showing always exists vertex v c extend edges incident v infinitely far side v extensions cross c anywhere particular extensions create two new simple biinfinite chains c 1 c 2 partition literals used c see figure 5 example easy see halfspace right say c either intersection union halfspaces right c 1 c 2 intersection angle c v selected halfspace convex situation figure 5 union angle concave existence desired vertex v relatively easy establish two halfspaces defined c one bounded two semiinfinite rays convex fashion mean look halfspace great distance xyplane discern semiinfinite rays bounding appears convex angle example figure 5 right halfspace r c convex one consider convex hull hr intersection halfplanes containing r hull unbounded polygonal region whose vertices vertices c clearly least one vertex c lies hr vertex good vertex break c serve vertex v previous argument reason clear figure 6 vertex extensions sides incident upon cannot cross c worth remarking determination splitting vertex v manner influenced whether trying obtain boolean formula right halfspace c left halfspace c choice halfspace take convex hull determined solely behavior semiinfinite rays c indeed choose wrong concave halfspace convex hull would whole plane would contain vertices summarize situation saying always r c chainc chain figure 5 splitting vertex v chain c r c figure convex hull hr split vertex convex hull polygonal chain c definition automatically selects correct halfspace recursively applying decomposition procedure subchain becomes single biinfinite straight line derive following theorem theorem 31 every halfspace bounded simple biinfinite polygonal chain monotone boolean formula using literals chain exactly holds interior finite simple polygon given polygonal chain c one figure 3 certain aspects boolean formula say right halfspace r c immediately deduced inspection example follows arguments exists boolean formula r uses literal exactly fact contains literals order appear along c omit boolean operators parentheses formula would get string literals c order furthermore boolean operators literals easy deduce previous discussion makes clear two literals define convex angle r corresponding operator two literals define concave angle corresponding operator thus parentheses omitted boolean formula chain c figure 3 look like c e f figure 7 methods cannot obtain valid formulae polygon preceding paragraph shows crux difficulty computing boolean formula obtain parenthesization equivalently sequence appropriate splitting vertices call recursive chain splitting problem simple biinfinite chain solution problem topic next section chain figure 3 valid solution conclude noticing procedure solving problem may nondeterministic since general choice several splitting vertices fact simultaneously split subset still valid petersonstyle formulae simple polygon obtained fashion formulae property literals appear formula order polygon figure 7 shows example petersonstyle formula true valid formula polygon shown 4 conversion algorithm seen section 3 find monotone boolean formula simple polygon solve following recursive chainsplitting problem given simple biinfinite polygonal chain least two edges find vertex z convex hull split chain two z extend infinity two edges incident z forming two new chains z convex hull chains simple recursively solve problem chain least two edges present log n algorithm solve chainsplitting problem n number vertices polygon p algorithm uses simple data structures straightforward implement describe algorithm let us consider naive alternative many algorithms published find convex hull simple polygon linear time 7 15 11 14 24 slight modifications algorithms used find vertex hull simple biinfinite polygonal chain use algorithm solve chainsplitting problem running time plus time needed solve two subproblems recursively worstcase running time tn given recurrence 0kn solution b figure 8 two paths worstcase bestcase splitting behavior quadratic behavior occurs worst case shown figure 8a recursive step spends linear time splitting single edge end path best case hand split divides current path roughly half algorithm runs log n time asymptotic behavior obtained path shown figure 8b splitting vertices chosen wisely best case naive algorithm like standard divideand conquer approach step algorithm splits current path roughly half general however difficult guarantee even division since vertices convex hull might extremely close two ends path thus avoid quadratic behavior must instead split path using less linear time researchers solved similar problems making splitting cost depend size smaller fragment 8 10 running time tn obeys recurrence 0kn log n method uses similar idea splitting cost olog n plus term linear size one two fragments fragment necessarily smaller two bound size ensure log n running time overall details argument appear section 45 present algorithm several steps first give definitions give overview approach follow informal overview pseudocode description algorithm section 43 gives detail one pseudocode operations section 44 describes data structure used algorithm section 45 concludes presentation algorithm analyzing running time 41 definitions shown section 3 find boolean formula p splitting polygon leftmost rightmost vertices get two paths working two paths separately denote current path either upper lower u v vertices use notation u v refer subpath u v inclusive convex hull set points denoted ha use hu v shorthand hu v path u v ju vj edges similarly jhu vj number edges hu v use path u v specify biinfinite chain extending first last edges let e u edge u v incident u let e u ray obtained extending e u beyond u let e v e v defined similarly u v specifies biinfinite polygonal chain obtained replacing e u e u e v e v general arbitrary u v biinfinite chain need simple algorithm however guarantee simplicity biinfinite chain considers assume follows e u e v parallel guarantees convex hull biinfinite chain least one vertex slight modification algorithm needed rays parallel 42 algorithm section presents algorithm recursively splits polygonal chain first outline algorithm present pseudocode format subsequent sections give details operations sketched section outline algorithm given polygonal path u v least two edges partition vertex x get two pieces u x x v roughly number edges vertex x necessarily vertex hu v partitioning merely preparatory splitting u v hull vertex oju vj time compute convex hulls u x x v way vertex z u v easily find hx z data structure lets us account cost finding hx z part cost building hu x hx v details accounting appear section 45 next step algorithm locates vertex z convex hull biinfinite chain u v e u e v split u v z vertex z path u x path x v without loss generality let us assume z vertex u x u vertex convex hull z 6 u recursively split u z partitioning midpoint building convex hulls however key observation much work z v z 6 x already hull hx v easily find hz x data structure hu x thus recursively split z v without recomputing convex hulls intuitively speaking full recursion including convex hull computation pieces whose length less half length piece last computed convex hulls key algorithms efficiency avoiding recomputation convex hulls naive algorithm builds hulls whose average size much n2 algorithm also builds hulls average size olog n algorithm locates n splitting vertices olog n time apiece contributes another log n term running time two terms dominate time cost algorithm section 45 shows present algorithm formally pseudocode pseudocode represents convex hull hx v using data structure called path hull denoted ph x v path hull stores vertices hx v linear array algorithm uses path hull ph x v produce ph x z efficiently splitting vertex z x v algorithm consists two mutually recursive subroutines f p whose names stand full partial routine fu v partitions u v x get two equal parts builds path hull structure calls pu x v subroutine pu x v uses ph x u ph x v find splitting vertex z section 43 gives details operation routine splits u v z recurses fragment ensures required path hulls built whenever p called start algorithm invoking f entire path begin 1 u v single edge return else begin 2 let x middle vertex u v 3 build ph x u ph x v 4 pu x v pu x v x vertex u v equal u v path hulls ph x v ph x u computed begin 5 find vertex z hu v e u e v output z part sequence splitting vertices else begin 7 z 2 u x build ph x z ph x u else build ph x z ph x v z vertex u x 8 begin fu z pz x v end else 9 begin pu x z fz v end chainsplitting algorithm 43 finding splitting vertex section shows use path hull data structure find splitting vertex z method exploits fact ph x v represents hx v linear array convex hull vertices perform binary search array find splitting vertex given path u v want find vertex convex hull biinfinite chain u v specifies vertex belongs finite convex hull hu v solve problem finding vertex hu v guaranteed belong infinite hull edges infinite hull hu v e u e v slopes range bounded slopes e u e v vertices hull tangent slopes range simply find vertex hu v tangent slope range let u v direction vectors rays e u e v e u e v parallel u v define angular range less 180 degrees define negative bisector angular range extreme vertex hu v direction guaranteed vertex infinite hull 2 see figure 9 example figure 9 find extremal vertex direction use binary search two path hulls ph u x ph x v find extreme vertex direction compare two vertices pick extreme two break ties consistently binary searches comparison two extreme vertices say preferring left vertex tied pairs vertex find guaranteed vertex infinite hull 44 implementing path hulls section describe path hull data structure used previous two sections path hull ph x v represents convex hull x v symmetric ar guments implicitly represents hx v 0 vertices v 0 x v represent equal x structure ph x v three essential properties 1 ph x v represents hx v linear array vertices let v vertex hx v closest v x v array lists vertices hx v clockwise order starting ending v 2 given ph x v transform ph x v 0 vertex v 0 x v destroying ph x v process let vertices v x numbered successively transform ph x v ph x v v sequence v time proportional jx vj 3 ph x v built x v ojx vj time get properties adapting melkmans algorithm finding convex hull polygonal path 15 satisfy requirement 2 recording actions melkmans algorithm constructs hx v playing tape backwards avoid computing square roots practice compute bisector angle defined du dv instead find normals du dv point away infinite hull add two get direction strictly normals many lineartime algorithms proposed find convex hull simple polygon 7 15 11 14 24 algorithms need find vertex hull get started use melkmans algorithm requirement constructs hull polygonal path incrementally processes path vertices order step builds hull vertices seen far algorithm keeps vertices current convex hull doubleended queue deque deque lists hull vertices clockwise order recently added hull vertex ends deque let vertices deque algorithm operates deque push pop operations specify end queue bottom top operate algorithm appears assumes three points tests collinear though restriction easy lift get first three vertices path function nextvertex put deque correct order v nextvertex returns new vertex v outside angle begin v left gammagammagamma v b v b1 popv b bottom v left gammagammagamma v melkmans convex hull algorithm figure lies shaded sector sketch proof correctness melkman gives full proof 15 first consider case vertex v discarded happens v inside angle see figure 10 know v b1 connected v tgamma1 polygonal path v connected v b polygonal path two paths intersect v must lie inside current hull v discarded lies outside current hull algorithm pops hull vertices gets endpoints tangents v current hull algorithm linear operates path n vertices 2n pushes pops use algorithm build array representation hull algorithm n pushes either end deque implement deque middle part array size 2n pushes pops increment decrement array indices ends queue pushes write new element pops read one resulting deque contains vertices convex hull contiguous chunk array described far array data structure path hull properties 1 3 obtain property 2 algorithm builds hx v starting x working toward v intermediate steps produces hx v 0 every vertex v 0 x v need able reconstruct intermediate results add code algorithm create transcript operations performed recording vertices pushed popped step structure ph x v stores deque represents hx v also transcript operations needed create deque scratch reconstruct ph x v 0 ph x v read transcript reverse order performing inverse recorded operation pushing popped vice versa deque represents hx v 0 throw away part transcript read ph x v 0 stores transcript operations needed create discard every step read look step transcript playback therefore reconstructing intermediate results takes time proportional original cost finding ph x v completes proof path hull data structure three required properties 45 analyzing running time section analyze running time chainsplitting algorithm given page 10 analysis uses credit scheme call f p given number credits pay time used body recursive calls give log n credits first call f show calls enough credits pay work recursive calls begin analysis proving f p called times every call pu x v splits u v two nontrivial subpaths every call fu v u v one edge passes u v p initial path split times recursion must calls altogether much work done call fu v exclusive recursive calls assume vertices stored array therefore line 2 f takes constant time line 3 step f takes nonconstant time shown section 44 line 3 takes oju vj time define value credit saying call fu v needs ju vj creditsone credit per edge u vto pay work exclusive call p constanttime steps f take time altogether hence dominated rest running time call pu x v accountable work lines 5 7 cost line 5 dominated two binary searches take olog n time line 5 therefore takes log n time whole course algorithm section 44 shows cost building ph x z line 7 accounted part construction cost path hull ph x z derived thus ignore work done line 7 p cost dominated line 3 f complete analysis running time must bound cost executions line 3 f single call fu v line 3 uses ju vj credits sum credits used line 3 proportional time spent executing line give ndlog 2 ne credits first call f show enough pay executions line 3 use following two invariants proof 1 call fu v given least mdlog 2 credits pay recursive calls 2 call pu x v given least l pay recursive calls lemma 41 call f p given credits accordance invariants 1 2 pay executions line 3 explicitly recursive calls proof let l r defined proof induction call fu v credits needs none since reach line 3 calls p call fu v 1 gets least mdlog 2 credits spends executing line 3 mdlog 2 m2e pass call pu x v larger l r dm2e dlog 2 dm2ee call gets least mdlog 2 credits required invariant 2 call pu x v splits u v two paths u z z v b edges respectively call pu x v divides credits recursive calls evenly according subpath size z x two calls f get least ldlog 2 maxl ldlog 2 le rdlog 2 maxl rdlog 2 credits satisfying invariant 1 z 6 x without loss generality assume z belongs u x line 8 executed case symmetric call fu z gets least adlog 2 maxl adlog 2 ae required call pz x v gets least bdlog 2 maxl bdlog 2 maxb gamma required invariant 2 completes proof altogether calls f p take log n time plus time spent building path hulls line 3 preceding lemma shows executions line 3 take log n time hence entire algorithm runs log n time 46 implementation algorithm described section implemented implementation general algorithm far described correctly handles cases collinear vertices convex hulls parallel rays biinfinite chains improvements difficult handling collinear vertices requires two changes program detects merges consecutive collinear polygon edges reporting user loop tests melkmans algorithm changed v left v left line supporting chain parallel infinite rays convex hull may bounded two infinite lines even though hull vertices chain nevertheless valid splitting vertices hull program finds splitting vertex searching extreme vertex direction perpendicular infinite rays using special case avoid selecting u v input program takes list polygon vertices order either clockwise counterclockwise specified xy coordinate pairs output program produces figure displayed polygon list splitting vertices order computed also produces correctly parenthesized boolean formula input polygon program applied polygon shown figure 11 produces following slightly abbreviated output main calling f 817 p splitting vertex 16 15 9 10 13 11 main calling f 1725 08 p splitting vertex 18 19 20 0 25 24 boolean formula formula number refers edge joining vertex vertex n 26 program produces graphical well textual output marc h brown created graphical displays using algorithm animation system developing dec systems research center browns thesis 3 provides information algorithm animation animation shows multiple color views state computation updated program runs one view shows input polygon highlights chains convex hulls splitting vertices algorithm operates another view pictorially displays formula subchain boolean combination halfplanes views show incremental construction boolean formula parse tree view emphasizes different aspect algorithm together illuminate many important features title page report shows blackandwhite snapshot animated algorithm running small example snapshot features three views algorithm geometry view shows polygon snapshot view highlights initial splitting vertices formula view shows development boolean formula time csg parse tree view shows parse tree corresponding formula node tree displays region corresponds subtree rooted node 5 formulae polyhedra shown interior simple polygon represented petersonstyle formula monotone boolean formula uses literal would like find formula polyhedron p 3space literals halfspaces bounded planes supporting faces section prove polyhedra petersonstyle formula figure 12 illustrates simplicial polyhedron face triangle eight vertices twelve faces six faces labeled six unlabeled faces lie convex hull p edge c c 0 convex angle halfspaces defined faces b intersect faces 0 b 0 similarly halfspaces defined 0 b 0 intersect faces b establish couple lemmas prove p petersonstyle formula assuming one deriving contradiction begin observing collection planes divides space several convex regions mathematical literature division usually called arrangement 5 polyhedron p csg representation terms halfspaces specify subset planes bounding halfspaces derive representation portion p inside convex region determined subset precisely let f boolean formula whose literals halfspaces p think f expression tree tree f nodes b denote lowest common ancestor b f lca f b let h hm subset halfspaces defined faces p point space assigned string ff 2 f0 1g ith character ff 1 point halfspace h points assigned string ff said region r ff use f j ff denote formula obtained setting h simplifying result using algebraic rules expression tree f j ff inherits several important properties expression tree f lemma 51 let f formula uses halfspaces h others let ff string f0 1g derived formula f j ff following three properties 1 f monotone f j ff similarly f petersonstyle f j ff 2 expression tree f j ff nodes b c b tree f c figure 12 two views simplicial polyhedron petersonstyle formula 3 expression tree f j ff contains node c depth k tree f contains node c depth k proof three properties maintained rules form expression tree f j ff simplifying expression tree f next lemma shows interaction region r ff boolean formulae f j ff lemma 52 polyhedron p formula f uses halfspaces h others string ff 2 f0 1g portion p inside region r ff described formula f j ff proof statement simply says formulae f f j ff agree inside region r ff follows definition f j ff fact simplification rules change value formula two corollaries lemma 52 give us constraints formula polyhedron based edges faces corollaries discussion follows add argument formula f j ff emphasize halfspaces fixed string ff corollary 53 let p polyhedron petersonstyle formula f faces b p meet edge p operator f lowest common ancestor b lca f b b meet convex angle hm halfspaces p except two defined b choose interior point edge formed faces b let ff string twovariable formula f j ff ab must describe polyhedron vicinity edge lemma 512 lca f b b meet convex angle corollary 54 let p polyhedron petersonstyle formula f using halfspaces b halfspace defined face b intersects face point string ff f j ff proof twovariable formula f j ff ab must describe face inside outside halfspace b b cannot appear formula ready look polyhedron p figure 12 suppose p peterson style formula f formula f j 111111 abca describes region inside unlabeled faces look constraints formula derive contradiction consider three faces b c corollary 53 know lca f b lca f 54 applied faces c implies formula describing three faces string ff 1 appropriately fixes halfspaces except b c similarly formula describing 0 b 0 c 0 consider region inside unlabeled halfspaces outside c c 0 portion p within region described karnaugh map 12 appears four planes cut space fifteen regions since want monotone forces us make 1 examining petersonstyle formulae b 0 b 0 reveals formula map order combine formulae 1 2 3 single formula six variables must determine operators repeated three formulae knew formulae 1 2 operators lca f b lca f andsnow know distinct ands lca f lca f b lca f ors first two formulae distinct descendents distinct ands finally lemma 513 formula 3 different ors nested deeply ands thus five operators formula six labeled halfspaces appear 3 using nesting depth operators know formula looks like 22 filling halfspace names gives formula portion p inside unlabeled faces notice however formula lca c c 0 thus lca f c c contradicts corollary 53 formula cannot represent portion p inside convex hull p contradiction proves p petersonstyle formula 6 closing observations though previous section proves polyhedra petersonstyle formulae may still case interior polyhedron n faces represented formula using literals trivial upper bound size formula 3 fact interiors set cells formed collection n planes described formula represents convex cell bounding planes ors cell representations together size formula worst total number sides cells formed n planes known 3 5 recent work paterson yao improves upper bound size formula method like trivial one slices polyhedron convex polyhedra cutting along planes supporting faces cutting along planes particular order cutting subpolyhedron plane defining face lies subpolyhedron boundary algorithm produces convex pieces whose total number sides 2 formula corresponding decomposition size 2 neither formulae described monotone every polyhedron monotone formula however formula cell trivial decomposition halfspaces contain cell cell representations formula uses negationsto see defines polyhedron notice first every point polyhedron cell second move cell polyhedron point outside polyhedron must cross halfspace first leave polyhedron thus representation interior cell contains points outside polygon implies formula evaluates false exterior points shows monotone formula size 4 would interesting characterize polyhedra represented peterson style formulae peterson 21 showed representations polygons give formulae extrusions pyramids would like extend class also consider looking formulae polygons curved edges edge polygon piece biinfinite curve intersect edge defines halfspace curved boundaryperhaps represent polygon formula halfspaces suppose restrict curves two intersect one point pseudoline condition proved always polygon vertex v extensions infinity v two edges adjacent v never intersect boundary polygon since vertex v used splitting vertex polygons petersonstyle formulae curves allowed intersect one point may impossible formula represent polygon without representing areas plane example two ovals intersect four points region inside first oval outside second disconnected boolean formula represent one connected component without including unless allowed introduce auxiliary curves acknowledgments thank p peterson jorge stolfi helpful discussions polyhedra also thank cynthia hibbard martin abadi careful reading manuscript r interactive modeling design analysis solids algorithm animation computational geometry convexity algorithms combinatorial geometry polygon properties calculated vertex neighborhoods finding convex hull simple polygon time algorithms visibility shortest path problems inside triangulated simple polygons kinetic framework computational geometry sorting jordan sequences linear time finding convex hull simple polygon digital logic computer design introduction solid modeling linear algorithm finding convex hull simple polygon geometric modeling solid modelling parametric design medusa system art gallery theorems algorithms binary partitions applications hiddensurface removal solid modelling analysis set patterns halfspace representation extrusions computational geometry representations rigid solids theory convex hulls piecewisesmooth jordan curves rational bsplines curve surface representation convex decomposition simple polygons padl102 system defining displaying solid objects graphical input boolean solid modeller tr geometric modeling computational geometry introduction algorithms combinatorial geometry online construction convex hull simple polyline convex hulls piecewisesmooth jordan curves introduction solid modeling art gallery theorems algorithms polygon properties calculated vertex neighborhoods sorting jordan sequences linear time representations rigid solids theory methods systems convex decomposition simple polygons digital logic computer design ctr michael paterson f frances yao optimal binary space partitions orthogonal objects proceedings first annual acmsiam symposium discrete algorithms p100106 january 2224 1990 san francisco california united states marc h brown john hershberger color sound algorithm animation computer v25 n12 p5263 december 1992 paterson f f yao binary partitions applications hidden surface removal solid modelling proceedings fifth annual symposium computational geometry p2332 june 0507 1989 saarbruchen west germany j friedman j hershberger j snoeyink compliant motion simple polygon proceedings fifth annual symposium computational geometry p175186 june 0507 1989 saarbruchen west germany tamal k dey triangulation csg representation polyhedra arbitrary genus proceedings seventh annual symposium computational geometry p364371 june 1012 1991 north conway new hampshire united states j snoeyink j hershberger sweeping arrangements curves proceedings fifth annual symposium computational geometry p354363 june 0507 1989 saarbruchen west germany michael goodrich applying parallel processing techniques classification problems constructive solid geometry proceedings first annual acmsiam symposium discrete algorithms p118128 january 2224 1990 san francisco california united states
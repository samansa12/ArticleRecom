positive acknowledgment protocol causal broadcasting abstractcausal broadcasting introduced reduce asynchrony communication channels inside groups processes states two broadcast messages causally related happenedbefore relation messages delivered sending order process group even though protocols implementing causal broadcasting add control messages suffer typical pitfall timestamping technique ensure causal ordering application messages piggyback vector time counters whose range variation unbounded paper investigate range define concept causal window process counters vector time arrived message process fall prove using causal broadcasting onetoall protocol follows positive acknowledgment method width causal window process limited allows modulo k implementation vector times considering k greater width causal window process protocol applicable data link transport layers using acknowledge messages ensure reliable transfer data paper also proposes two variants protocol based causal windows increase concurrency protocol expense wider causal windows b introduction asynchrony communication channels one major causes nondeterminism distributed systems concept causal ordering messages introduced context broadcasting communication birman joseph 8 order reduce asynchrony causal ordering means two broadcast messages causally related 14 delivered sending order process light message delivered process messages causally precede already delivered process master asynchrony communication modes defined fifo rendezvous logical instantaneous ordering 20 user viewpoint causal ordering increases control distributed application compared simple fifo ordering cost reduction potential concurrency distributed application compared logically instantaneous communication causal ordering provides concurrency simplicity implementation moreover causal ordering prone deadlock rendezvous asynchronous paradigm communication actually causal ordering extends concept fifo channels connecting one sender one receiver systems connecting several senders one receiver causal ordering proved useful taking snapshots distributed applications controlling distributed applications managing replicated data allowing consistent observations distributed computations 10 18 recently extensions causal ordering proposed cope mobile computing environments 16 unreliable networks distributed applications whose messages limited time validity 5 6 moreover concept causal ordering limited messagepassing environments context sharedmemory systems causal memory introduced ahamad et al 1 consistency criterion criterion introduce latencies executing read write operations even though several interesting protocols implementing causal ordering appeared literature 8 9 18 21 communication mode yet widely used commercial platforms protocols suffer typical pitfall timestamping logical physical technique ensure causal ordering context broadcasting application messages piggyback vector time unbounded integers counters whose size given number processes 15 vector represents actually control information protocol however datalink transport layers communication systems use messages called acknowledgments acks short indicate successful reception data ack messages produced layers actually source information causal relations among application messages could used reduce amount control information causal ordering pro tocols paper introduce notion causal window propose causal broadcasting protocol exploits implicit information provided ack messages 1 causal window process represents range variation counters vector time arrived message process fall prove using causal broadcasting protocol follows positive acknowledgment pak method 17 23 width causal window process bounded allows modulo k implementation vector times considering k greater width causal window process first propose pak causal broadcasting protocol process send message acks previous message sent process received analyze general case credit ct 1 associated sending process case process send ct consecutive messages receiving corresponding acks finally investigate case process employs positivenegative paknak scheme ie process send sequence ct messages without acknowledged ack message required processes receipt ctth message sent process credits use paknak scheme allow increase concurrency protocol decreasing number internal protocol synchronizations enlarge dimension causal window protocol propose could employed part flow control transport layer 2 providing causal communication layer example current group communication systems eg isis 10 implement causal protocols top fifo flow control piggybacking application message vector unbounded integer remainder paper organized follows section 2 general model distributed computation concept causal relation among events vector times causal ordering communication mode introduced section 3 presents causal window notion section 4 shows causal broadcasting protocol based causal windows considering credit sender equal one end section positive acknowledgment method modulo k implementation vector times introduced section 5 proposes two variations protocol section 4 based credit paknak scheme respectively 1 interesting algorithms exploit implicit information provided ack messages guarantee fifo reliable channels found 7 11 22 2 examples transport layers use ack messages data transferring among others tcp ositp4 vtmp deltat 13 2 model distributed computations 21 distributed system distributed system finite set p n processes fp communicate broadcasting messages 3 underlying system processes execute composed n processors simplicitys sake assume one process per processor exchange messages assume pair processes connected reliable 4 asynchronous fifo logical channel transmission delays unpredictable processors shared memory bound relative speeds 22 distributed executions execution process p produces sequence events classified broadcast bcast events deliver dlv events internal events internal event may change local variables broadcast delivery events involve communication particular broadcast event produces delivery events one process let b two events occurred process p precedes b p denoted aoe b iff produced b let message b two events precedes b denoted oe b iff bcastm event b dlvm event distributed computation represented partial order events b e set events happenedbefore relation 14 relation transitive closure union oe n oe denoted ie hereafter call b e set messages exchanged b e consider internal events affect interprocess ordering events let us finally introduce notion immediate predecessor message definition 21 message 1 immediate predecessor message paper consider message atomic unit data movement system results following sections apply even though consider packets byte streams atomic data unit 4 detailed description protocol proposed section 4 case unreliable channel aims paper interested reader refer 3 description e noted message n immediate predecessors one process example message 1 depicted figure 4 immediate predecessor 2 due message x 23 vector times capture causality relation relevant events distributed computation vector times introduced simultaneously independently fidge 12 mattern 15 vector time process p denoted v vector counters whose dimension equal number knowledge number relevant events produced p j relevant event associated vector time v process p updates vector time according following rules 1 p starts execution component v initialized zero 2 relevant event produced 3 message sent copy v piggybacked message denoted v tm 4 message sent p j arrives p updates vector time following way let b two relevant events v v b vector times associated according properties vector times 12 15 considering v interested broadcast environment following assume broadcast events relevant events actually p knowledge number messages broadcast p j particular setting considering causal communication protocol simplified shown next section 24 causal ordering causal ordering states order messages delivered application cannot violate happenedbefore relation corresponding broadcast events 8 formally definition 22 distributed computation b respects causal ordering two broadcast messages e ng dlvm 1 first implementation abstraction embedded isis system 8 10 consists adding protocol reliable underlying system events distributed computation causally ordered process level 5 end deliveries done delaying means delivery condition messages arrived early underlying system simple broadcast protocol similar one presented birman et al 9 shown figure 1 shows behavior process p sending upon arrival message algorithm includes vector time management rules line s1s2s3 r2 plus delivery condition dcm line r1 associated message message delivered process p soon vector time carries v tm contain knowledge messages sent delivered process p 6 formally ng 3 causal window section investigate range variation values stored counters vector times evaluation delivery condition generic destination process upon arrival message process p value vector time counters v tm v involved delivery condition dcm generate three cases 1 v tm 1 consecutive messages sent process p j causally precede arrived p shown figure 2a message delivered violates causal ordering 5 interesting pointtopoint implementations causal ordering found 18 21this fact makes part rule 3 section 23 ie 8h 6 useless causal broadcasting protocol init h 2 procedure bcastm message p sender begin h 2 ng send v tm p h od event bcastm s2 end mv tm arrives p begin ng event dlvm r3 end figure 1 simple causal broadcasting protocol 2 1 co j consecutive messages sent process p j delivered p concurrent message shown figure 2b message delivered p without violating causal ordering 3 sent p j delivered p immediate predecessor shown figure 2c message delivered p without violating causal ordering b co j messages messages c figure 2 values vector times delivery condition figure 3 causal window cw j counters v tm fall either case 3 case 2 message delivered hence upon arrival message process p counters v tm fall range variation spans v causal window cw composed set windows cw j one process p j number represents width window cw j figure 3 implement causal broadcasting protocol employing modulo k vector times show boundedness width causal windows general setting one described previous section transmission times unpredictable width cw nonlimited 4 pak protocol based causal windows 41 positive acknowledgement method get limited causal window assume processes follow stopandwait approach process broadcasts message bcastm event waits acks n aackm events executing broadcast event acks arrived broadcast message said fully acknowledged fackm event side time process receives broadcast message arrm dlvm events sends ack sackm hence underlying system level six types events occur bcast dlv events visible application processing broadcast message sent p produces following poset events denoted pom oem arrm oe1 dlvm oe1 sackm oem oem arrm oen dlvm oen sackm oem stopandwait approach implies send condition sc 1 two successive messages sent process p formally synchronization local easily implemented boolean variable processing broadcast initialised false process value true indicates process broadcast message waiting fackm event soon event occurs processing broadcast toggles enabling broadcast messages remark group communication group communication system eg isis 10 transis 2 etc occurrence event fullyack message corresponds notion stability message 4 9 ie sender learns members group delivered fact use ack messages one methods diffuse stability information group processes methods employ gossiping piggybacking notion stability key point many group communication problems security 19 large scale settings 4 name informally condition sc 1 restated follows process cannot broadcast message group till previous one sent declared stable condition conservative implies strong synchronization pair successive messages sent process section 5 present two variations weaken synchronization 42 causal windows limited width subsection prove causal window pak causal broadcasting protocol based send condition sc 1 limited lemma 41 let b e distributed computation 1 e messages protocol based sc 1 ensures causal ordering violation 1 2 proof contradiction shown figure 4 suppose causal ordering violation two messages 1 2 sent p p j 6 respectively ie bcastm 1 exists message x sent p pom 1 pom x send condition sc 1 dlvm x due sc 1 due assumption bcastm x mx figure 4 proof lemma 31 previous lemma definition width causal window given section 3 theorem 42 pak causal broadcasting protocol based sc 1 cw j equal 1 p p j proof represents number consecutive messages sent process p j ie bcastm x arrived process causally precede message arrived p ie bcastm x would violate causal ordering message sequence lemma 41 causal ordering violation 0 number consecutive messages sent p j may violate causal ordering one hence claim follows 2 considering fifo property channels following lemma lemma 43 let b e distributed computation 2 b e message sent process p one message x 2 b e concurrent process p j 6 j proof x concurrent follows bcastm x pom x pom channel fifo property following sequence events occurs p j p shown figure 5a suppose another message x 0 sent p j concurrent send condition definition concurrent messages given bcastm x 0 b ackm ackm mx ackmx ackmx figure 5 proof lemma 33 shown figure 5b fifo property pom x 0 process process p j dlvm oe j aackm x 0 follows bcastm x contradicts send condition sc 1 x one message sent distinct process concurrent 2 previous lemma definition width causal window given section 3 theorem 44 pak causal broadcasting protocol based sc 1 co j equal 1 p p j proof co 2 represents number consecutive messages sent process p j delivered p concurrent message arrived p lemma 43 one message x concurrent process p j 6 j equal one claim follows 2 hence range variation causal windows limited step vector time counter increases 1 due fifo property channels following invariant allows modulo k implementation counters vector times choosing k greater maximum difference two counters ie k 3 example window shown figure 6 k equal 4 remark sliding windows figure 6 devised causal window particular type sliding window sliding window technique widely used flowcontrol pointtopoint data transfer protocols avoid loss messages ensure fifo deliveries message delivered message delayed figure asynchronous unreliable communication systems eg tcp 11 17 23 technique induces closed loop sender receiver allows overload buffer spaces receiver avoid network congestion controlling transmission rate sender interest causal window lies also fact could used part flowcontrol layer group communication system provide causal communication layer 43 protocol behavior process p executing pak protocol described figure 7 requesting broadcast message process p first waits till previous broadcast message fully acknowledged line s1 sets variable processing broadcast true stores current vector time v v tm sends attached v tm atomic action lines s2s3 afterwards waits till message fully acknowledged ie ack message arrives member p local timestamp v increased one module k line s5 finally successive broadcast messages enabled resetting processing broadcast line s6 upon arrival process p message delivery determined delivery condition ng particular case cp h equal one message delivered soon predicate dcm true line r1 broadcast message sent p j delivered line r2 p vector time v j updated line r3 ack message sent p j line r4 lines r4 executed atomically 7 note gammah mod definition causal window k h init processing broadcast false h 2 procedure bcastm message p sender begin wait processing broadcast s1 processing broadcast true v tm h 2 ng send v tm p h od event bcastm s3 wait h 2 ng ack arrives p h od s4 processing broadcast false event fackm s6 end mv tm arrives p event arrm begin ng event sackm r4 end figure 7 pak broadcasting protocol based causal windows 44 correctness proof theorem 45 delivery events respect causal ordering safety proof let us consider two messages 1 2 sent processes p p j respectively delivered p h causal order ie bcastm 1 lemma 41 line protocol get v tm2 upon delivery 2 p h delivery condition dcm 2 line r1 requires one following conditions true 1 v tm 1 2 v tm2 k v tm1 definition line r2 v h contains number messages sent p delivered p h successive messages sent p delivered fifo order assumption fifo channels send condition sc 1 1 delivered hypothesis either v tm1 mod k cases considering conditions 1 2 1 already delivered contradicts hypothesis 1 delivered 2 2 theorem 46 message eventually delivered liveness proof let x xth message sent p arrived p j never delivered given delivery condition dcm x line r1 follows two cases considered send condition scm upon arrival message x process p j messages sent p delivered p j line r2 delivery equal x gamma 1 contradicts p1 must least one message causally preceding x sent p k either arrived process p j arrived delayed delivery x would violate causal ordering lemma 41 considering reliable broadcast nature channels messages respectively sooner later arrives p j two cases possible 8 part proof similar one 9 1 delivered causes line r2 delivery x 2 delayed argument applied message x 0 sent pw h x 0 due finite number processes messages sooner later fall either case 1 case contradiction5 variants protocol section shows two variants previous protocol first one allows process certain number outstanding unacknowledged messages time credit second assumes subset messages acknowledged positivenegative acknowledgement approach aim variants reduce number local synchronizations protocol due send condition 51 pak broadcast protocol using credits suppose processes credit ct 1 ie process p send ct 1 consecutive broadcast messages receiving corresponding acks send condition sc 1 extended follows ct credits potentially reduce number synchronization send condition increase width causal window 9 indeed shown figure 8a upon arrival message sent p j could ct consecutive messages sent p k causally precede bcastm x ct gamma 1g dlvm oe dlvm x ct gamma 1g let us assume ct message sent p k causally precedes message dlvm oe dlvm ct follows dlvm ct bcastm ct dlvm oe dlvm 0 bcastm ct ct absurdity upon arrival message process p v tm ct figure 8a claritys sake ack messages produce fullyack events depicted 9 local synchronization sc ct weakens sc1 fact number local synchronizations ever credit appropriately chosen function network latency broadcast messages prohibited acks received credit exhausted number real synchronizations actually reduced ct ct b ct ct figure 8 example message scheduling protocol credits hand shown figure 8b upon arrival message sent p j ct consecutive messages sent p k bcastm ct gamma 1g indeed due fifo property message delivered p k arrival p j ack message related 0 bcastm bcastm ct hence upon arrival message process p hence concerning width causal windows following invariant modulo k implementation vector times k 2ct allowed size vectors ndlog bits manage credits protocol figure 7 needs modification particular implement send condition sc ct boolean variable processing broadcast becomes integer one initialized zero lines s1 s2 replaced following lines wait processing broadcast ct processing broadcast processing broadcast lines s6 becomes processing broadcast processing broadcast gamma finally delivery condition line r1 replaced ng ct ct figure 9 impossibility causal violation ct consecutive messages remark memory requirements considered causal window width function credit sender thus protocol delays messages arrived early process maximum number pending messages ctn gamma 1 buffer receiver enough space overflows dropping incoming messages situation mastered associating credit receiver let us define process p width causal window ct wt credit receiver 1 wr ct arriving message whose v tm j fall interval v stored delayed delivered acknowledged p v tm j falls interval v discarded p without sending ack message managing credit associated receiver requires receiver mechanisms remove message duplication sender timer triggers retransmission messages ack received within deadline discussion use previous mechanisms support causal windows found 3 52 paknak broadcast protocol protocol section 43 easily adapted solution using paknak acknowledgment reducing number synchronization among messages due send condition compared pak one assume process p send sequence ct messages without acknowledged ack message required processes receipt ctth message sent p process allowed send ct 1st message ctst message fully acknowledged case send condition becomes ct protocol using credits width causal windows 2ct violation causal ordering always current range causal window since message sent p create causality violation process p k ct consecutive messages sent p j acks required mod ct ct gamma 1st messages avoid causality violation including ct consecutive messages particular figure 9 shows message sent p j creates causality violation process p k ct consecutive messages sent p absurdity follows depicted thick arrows using argument section 51 ct messages concurrent message computation due fifo property channels implement paknak protocol delivery condition one protocol section 51 protocol figure 7 needs following modifications lines s1 s2 replaced following ones processing broadcast ct processing broadcast true line s6 becomes processing broadcast false 6 conclusion paper pak causal broadcasting protocol based causal windows proposed causal window actually represents range variation vector time counters delivery condition causal ordering protocol protocol allow modulo k implementation vector times considering k greater width causal window achieved exploiting causal information implicitly carried ack messages compared protocols use control messages 5 9 18 cost pay little computational overhead presence local synchronizations messages sent process due send condition reduces potential concurrency protocol reduce number local synchronizations discussed two variations pro tocol variations reduction number local synchronizations payed wider causal windows first variation allows process transmit certain number successive messages receiving corresponding acknowledgements credit solution potentially reduces number local synchronizations however credit appropriately chosen broadcast messages prohibited acks received credit exhausted time credit high difference sending n integer vector clok ndlog ke bits vector clock significant proper choice credit value lead overhead reduction insignificant loss concurrency second variation employs positivenegative method ie requires local synchronizations message x succesive message sent process x multiple predefined parameter solution reduces number local synchronization message traffic generated protocol compared first variation seems well suited high latencies networks paper also showed notion causal window related one sliding windows used fifo flow control local synchronization due send condition strictly connected concept stability message group processes protocol adapted avoid buffer overflow interested reader find causal broadcasting protocol based causal window well suited unreliable network 3 description includes additional data structures mechanisms process endow order avoid lost messages message duplications acknowledgments author would like thank ken birman bruno ciciani roy friedman achour mostefaoui michel raynal ravi prakash mukesh singhal robbert van renesse comments many useful conversations work described herein author also thanks anonymous referees detailed comments suggestions improved content paper r causal memory definitions implementation programming transis communication subsystem high availability positive acknowledgement protocol causal broadcasting hierarchical daisy architecture causal delivery causal deliveries messages realtime data unreliable networks efficient deltacausal broadcasting note reliable fullduplex transmission halfduplex links reliable communication presence failures lightweight causal order atomic group multicast reliable distributed computing isis toolkit protocol packet network interconnection logical time distributed computing systems survey lightweight protocols highspeed networks time clocks ordering events distributed system virtual time global states distributed systems anadaptive causal ordering algorithm suited mobile computing environments networks distributed computation causal ordering abstraction simple way implement securing causal relationship distributed systems logically instantaneous messagepassing asynchronous distributed systems new algorithm implementing causal ordering data transfer protocol computer networks tr ctr roberto baldoni response comment positive acknowledgment protocol causal broadcasting ieee transactions computers v53 n10 p1358 october 2004 giuseppe anastasi alberto bartoli giacomo giannini causal broadcasting positive acknowledgments boundedlength counters ieee transactions computers v53 n10 p13551358 october 2004
explaining type errors polymorphic languages stronglytyped languages present programmers compiletime feedback type correctness programs errors polymorphic type checking take form unification failure two types finding source type error code often difficult error may occur far spot inconsistency detected functional languages use complex type systems difficulty interpreting locating errors increase locate source type errors programmer must unravel long chain deductions type instantiations made type reconstruction paper describes approach maintains deductive steps type inference reasons type instantiations approach could used interactive system guide programmer source type error explain compiler assigned particular type expression b introduction one annoying aspect stronglytyped languages parametric polymorphism sometimes unclear expression cannot typed many programmers experienced feeling incredulity sometimes arises expression rejected compiler reason compiler cannot forthcoming typechecking analysis paper describe way type analysis explained programmer may led source type errors particular consider case type reconstruction essential constructs programming language ml programming language ml 5 stronglytyped functional language polymorphism interesting type system property types identifiers deduced use 4 made popular model type systems languages focus language object study also implemented approach language using standard ml new jersey 1 inspired paper 7 concerning british nationality act paper authors described capturing legal requirements establishing british citizenship prolog program requirements british citizenship complex useful system explains appeared acm letters programming languages systems volume 2 numbers 14 marchdecember 1994 pages 1730 steps taken reach conclusion idea seems appropriate deductions made type reconstruction want ask type system arrived particular type expression answer question useful type analysis led unexpected type expression particularly useful case type errors case type analysis arrived two inconsistent types programmer may find difficult understand programmer assumes probably erroneously expressions constructed correctly intended type place inconsistency found may part program mistake made nature type system widely separated parts program affect types expressions part program might mistake point view programmer inconsistency found depends arbitrary order traversal syntax tree type analysis interesting information may obtained examining contextual evidence approach johnson walz 3 usage minority candidate mistake clear often minority isolated since many errors form one correct usage one incorrect usage also ways introducing errors minority usage may correct type despite preponderance majority usages one way error program copied many locations program using text editor another trickier situation would expression bound variable let statement used incorrectly typed many locations one location causes welltyped correct usage approach take entirely different try find wrong context instead want ability explain context right wrong two approaches might used together future heuristic system explains deductions suggests error may found 1986 popl paper wand 9 suggested aiding programmers search source type errors presenting list expression fragments cause binding type variables type reconstruction approach called collection application subexpressions unification step type analysis type error detected list application sites issued one cause error improve wands work finer analysis maintain deductions made reconstruction algorithm along location source fragments leading individual bindings unification process forms explanation space traversed explain individual deduction steps flow information one part program another addition also consider effects milner letstatement greatly complicates deductive process type reconstruction interested simple functional language sake concreteness use mllike syntax syntax language shown figure 1 besides function definition function application language constructs pairing conditional expressions let expressions consistent practice standard ml nj replace subexpressions language character space show top part particular expression expressions language consider meaningful type collection described grammar figure 2 type variables written b etc type reconstruction process deducing type expression context type checker language like pascal identifiers must explicitly given type checked consistent usage throughout program type reconstruction algorithm merely check whether declared types combined consistently finds consistent type one identifiers initially given type variable type type variable stands type thus represents totally unconstrained type typechecking requirements constrain types expressions completely type variables left unspecified polymorphic type achieved 4 proved theorem prover complete set typing rules language call algorithm typeof modified version original algorithm basis explanation system function typeof takes expression type assignment substitution input hboolean valuei boolean constants application definition figure 1 syntax simple functional language int type integers type boolean values product figure 2 syntax types produces type substitution typeof postorder traversal syntax tree enforces typing rules construct essentially building proof tree typing judgments details algorithm found elsewhere 2 6 crucial insight designing theorem prover lies recognizing unification used insure two types example typing rule function application requires domain function type actual argument algorithm find substitution one exists makes two types equal called unification substitution used specialize proof tree making type conclusion instance original type thus long two types unifiable appropriate proof trees found result appropriate types syntactically identical many ways represent substitution particular one could represent substitution function one could use list pairs normally issue great consequence however purposes modifying unification function keep extra information must substitution represented list reasons efficiency common list represent substitution ng substitution list representation one specialize substitution simply adding atomic binding v need update previous bindings purposes crucial value representation atomic binding explained one particular unification otherwise possibly several unifications would contribute value single type variable case one would keep list reasons binding like wand 9 would impossible explain instantiation type step step approach approach take following elements annotations parse tree augmented substitutions augmented type assignments explanation functions use information information add syntax tree often types subexpressions captured node analyzed syntactic construct requires individualized set information basic constructs integers truthvalues need store extra information simple structures conditionals pairs need store types subexpressions let statement let b end stores type body b type e data structure representing function definition fn e stores type body original type variable assigned formal parameter original type variable starting point atomic bindings account instantiation domain function application must keep two pieces information two types unified type analysis information possible report unification took place application construct identifier must also keep two pieces information reason case function definition identifier keeps type variable originally assigned type assignment identifier construct must also keep list type variable renamings renamings generic type variables type identifier generic type variables introduced let statement implement special effect let statement polymorphic types another part information kept substitution data structure used substitution list atomic bindings types type variables made unification process analysis functions use atomic bindings trace evolution types original form final form bindings augmented pointer annotated expression tree tag expression referenced pointer one responsible unification call bound type variable atomic binding tag adds information analysis distinguish two unification calls typing conditional statement one unify type test expression boolean ensure branches conditional type typeof calls unification passes current location syntax tree stored atomic binding resulting invocation normally running function typeof produces type expression typeof recursive traversal syntax tree encounters type inconsistency stops reports error occur one calls unification modified typeof decorates parse tree recursive traversal syntax tree calls unification system keep pointers appropriate places tree inconsistency detected program reports problem since problem caused types two expressions failing unify ask following sort question twice expression e type written function answers question given decorated parse tree augmented substitution point analysis stopped programs main purpose explain typing rules specifically used expression interest example expression fn fn bif b b else true 3 type ml error detected body outermost function 3 plus function applied two arguments point type analysis detects domain plus intint match type actual argument error report standard ml nj standard ml new jersey version 75 november 11 1991 fn fn bif b b else true3 stdin110145 operator operand dont agree tycon mismatch operator domain int int operand bool int expression case programmer may find clear operator plus right domain argument operand wrong may clear system thinks type actual argument boolint hence interested question kind question function answers one another explains typing rules constructs example constructs listed table function application fn b true function definition fn b conditional b b else actual output explanation system example shown fully figure 3 finally turns explanation types identifiers b conditional structurally identifiers alike get types environment variable b originally assigned type b completely answer question b come assigned type bool question function answers function different sort task explains flow information one point program another case previous example must explain b came bound bool information substitution know b bound bool meet requirement conditional test type bool jump node syntax tree point structural information might asked structural explanations given follow structure proof tree typing judgements built typeof functionsee section 2 using typing rules fortunately structure proof tree corresponds closely parse tree expression explanations may require explain flow information around expression explanations break two levels function first explains instantiation types progress type reconstruction following trail atomic bindings substitution secondly atomic binding maps node annotated syntax tree constructs nodes ones analysis required call unification two nodes language function application makes one call unification conditional expression makes two function explains circumstances required unification explanation circumstances structural question important note never leap part syntax tree annotated pointers syntax tree places unification called typeof function always annotates node first calls unification function recursive annotation subtrees already completed implemented print depthfirst explanation every piece deduction loops detected broken ad hoc manner output shown figures 3 5 6 clearly fulllength explanation suitable error message envision sort programmer interaction system navigate explanation space interaction may go like system explains one step deduction deduction may depend zero one deductions programmer may find one deductions dubious choose investigate deduction instance prior example function plus programmer probably satisfied type concentrated type actual argument welldesigned interface programmer could quickly focus part program contrary programmers understanding program actual output explanation system questions explored marked elaboration indented type errors require process explanation continue structural analysis program following binding another part program next example designed illustrate consequence explanation may jump back part expression already explained explanation end potentially infinite explanation space appears major shortcoming necessary justify approach would seem explanations could unraveled primitive pieces type reconstruction process goes certain finite steps reach conclusion detected application 3 2 domain function unifiable 3 type argument true3 4 domain function intint 5 argument type boolint 6 function 7 identifier 8 part initial environment 9 argument true3 type boolint type pair true3 determined type element first element fn b true type bool 12 type application range function 13 function fn b type boolbool 14 function fn b type boolbool 15 type function definition determined type inferred formal parameter b type function body b b else formal parameter b type bool 19 type formal parameter inferred use 20 variable b initially assigned type variable b come bound type bool 22 binding arose analysis b b else since expression b must type bool 24 type variable b type type variable b must stand bool 26 expression b type bool 28 functions body b b else type bool 29 type conditional determined types branches must unify branch b type bool else branch type bool 34 elided second element 3 type int 36 integer constants type int figure 3 explanation space fn fn bif b b else true 3 fn fn b error fn c boolii b error true else b booli b true bool 3 bool intintint 2 4 error 3 int fn x boolintbool true bool 2 int x bool fn yx intbool int x bool figure 4 syntax tree fn fn b b keeping thencurrent substitution point program possible trace back steps one one piece explanation would begin time unification types substitution would used explain specifics explanation would depend order type analysis programmer want know implementation type analysis intermediate steps analysis explanation coherent perspective final substitution fact type error may comprehensible global point view local step perfectly consistent chosen explain piece process perspective final substitution consider following expression fn fn b true else b fn c b c b fn x fn 3 true 2 4 rather long expression containing pair pairs 4tuples simple language best comprehended examining syntax tree figure 4 expression cannot typed explanation space figure given figure 5 elements pairs contributes binding type formal parameter third binding c bool one assume suspicious appropriate question asked line figure 5 expression introduces type bool understood analysis crucial question asked line 40 x type bool actually system answer question point detects answered question context explaining binding type variable part analysis omitted figure 5 lack space interesting part goes like formal parameter x type bool type formal parameter inferred use variable x initially assigned type variable e type variable e come bound type bool binding arose analysis application fn x true type efe time analysis type function fn x fn x type argument true determined bool therefore function fn x applied argument true result function returns boolean value thus seen lines 1926 figure 5 b must function domain bool since type b line 10 applying integer type error 4 milner let construct let construct complicates explanation identifiers type gets instantiated without let identifiers initial type variable assigned analysis function definition describes instantiation type variable gathering list atomic bindings affect let expression let b identifier initially assigned type variable type type e type may contain generic variables occurrences body b get initial types renaming generic variables new unused type variables distinct distinct occurrences explain type letbound identifier necessary know type variables generic variables bound information kept syntax tree every identifier checks list see generics instantiated apprises user name changes proceeds explain instantiation type consider following example detected application 2 2 domain function unifiable type argument 2 3 domain function bool 4 argument type int 5 function type booli 6 type bound identifier inferred use 7 variable introduced function fn afn b 8 variable initially assigned type variable 9 type booli obtained via following 4 bindings type variable bound type b type variable b bound type cd 12 type variable c bound type bool type variable bound type 14 type variable come bound type b come bound type cd come bound type bool 19 binding arose analysis application b 3 20 type cd time analysis type 21 function b 22 type argument true determined bool 24 domain function must equal type argument 25 binding arose unification type cd 26 type booli type variable introduced stand range function 28 function b type booli 29 elided argument true 31 type application range function function fn x true type intbool fn x true type intbool 34 type application range function 35 function fn xfn yx type boolintbool 36 fn xfn yx type boolintbool 37 type function definition determined type 38 inferred formal parameter x type function body fn yx formal parameter x type bool 42 function body fn yx type intbool 43 elided 44 type variable come bound type argument 2 type int integer constants type int figure 5 explanation space fn afn bif fn cb 1 type let expression type body body f 3f true type intbool 3 type pair f 3f true determined type element 4 first element f 5 type application range function 6 function f type intint 7 function f type intint 8 identifier f introduced 9 letbinding let 10 analysis expression fn x x determined type aa stands expression initially received type renaming generic type variable new variable 14 get type bb type intint obtained bb via following binding type variable b bound type int 17 type variable b come bound type int binding arose analysis application f 19 type bb time analysis type 20 function f 21 type argument 3 determined int 22 domain function must equal type argument 23 binding arose unification type bb 24 type intc type variable c introduced stand range function 26 function f type intint 28 argument 3 type int 29 integer constants type int expression fn x x type aa 31 type function definition determined type inferred formal parameter x type function body x 34 formal parameter x type type formal parameter x remained unconstrained 36 initial assignment type variable 37 function definitions body x type 38 type bound identifier x remained unchanged initial assignment type variable 40 function definition fn x x second element f true type bool 42 type application range function 43 function f type boolbool 44 function f type boolbool figure explanation space let ffn xx f 3f true end expression welltyped use welltyped example time emphasize explanations produced useful explaining type errors also useful understanding type expression ask expression type intbool output given figure 6 explanation begins statement explaining type let construct type body case pair f 3f true explanation describes first element type int describes type f must describe generic nature type aa note states generic type variable renamed b proceeds explain type bb unified type intc 5 conclusion goal develop approach maintaining deductive steps type inference order provide programmer meaningful explanations circumstances type errors approach taken explain reasoning type reconstruction process relation program many cases lead programmer insight necessary repair program also useful explaining type system finds welltyped expression useful programmers unfamiliar polymorphic type reconstruction even programming errors type system finds unexpected way deduce type expression described modifications traditional type analysis algorithm milner letstyle polymor phism modifications store critical parts analysis process keep track atomic bindings comprising substitution permits refined explanation deductions wand 9 described two functions make use information explain steps inference type expressions useful understanding type errors understanding type obtained particular expression chose present explanation programmer perspective reached point type inconsistency detected seemed choice made explanations understandable explanations using bindings current different times type analysis fact consistently using final bindings inconsistency could carried part expression programmer considered error insight kinds errors made improved explanations could guide novice expert programmers relevant parts program easily several opportunities synthesize special cases higherlevel explanations would meaningful programmer experience navigation explanation space could improved acknowledgements anonymous referees aided considerably improving paper one particular devoted extraordinary effort analyzing paper making suggestions improvements referee also brought attention masters thesis topic 8 r standard ml new jersey basic polymorphic type checking maximumflow approach anomaly isolation unificationbased incremental type inference theory type polymorphism definition standard ml elements functional programming british nationality act explanation based polymorphic type check standard ml finding source type errors tr british nationality act logic program basic polymorphic typechecking definition standard ml elements functional programming finding source type errors maximumflow approach anomaly isolation unificationbased incremental type inference ctr olaf chitil compositional explanation types algorithmic debugging type errors acm sigplan notices v36 n10 october 2001 bruce mcadam repair type errors automatically trends functional programming intellect books exeter uk 2002 oukseh lee kwangkeun yi proofs folklore letpolymorphic type inference algorithm acm transactions programming languages systems toplas v20 n4 p707723 july 1998 benjamin lerner matthew flower dan grossman craig chambers searching typeerror messages acm sigplan notices v42 n6 june 2007 yang jung greg michaelson visualisation polymorphic type checking journal functional programming v10 n1 p5775 january 2000 peter j stuckey martin sulzmann jeremy wazny interactive type debugging haskell proceedings acm sigplan workshop haskell p7283 august 2828 2003 uppsala sweden bastiaan heeren jurriaan hage doaitse swierstra scripting type inference process acm sigplan notices v38 n9 p313 september christian haack j b wells type error slicing implicitly typed higherorder languages science computer programming v50 n13 p189224 march 2004 boniface hicks dave king patrick mcdaniel jifclipse development tools securitytyped languages proceedings 2007 workshop programming languages analysis security june 1414 2007 san diego california usa benjamin lerner dan grossman craig chambers seminal searching ml typeerror messages proceedings 2006 workshop ml september 1616 2006 portland oregon usa thomas ball mayur naik sriram k rajamani symptom cause localizing errors counterexample traces acm sigplan notices v38 n1 p97105 january yasuhiro ajiro kazunori ueda kima automated error correction system concurrent logic programs automated software engineering v9 n1 p6794 january 2002 venkatesh choppella christopher haynes sourcetracking unification information computation v201 n2 p121159 september 15 2005 matthias neubauer peter thiemann discriminative sum types locate source type errors acm sigplan notices v38 n9 p1526 september
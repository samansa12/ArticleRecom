using tickets enforce serializability multidatabase transactions enforce global serializability multidatabase environment multidatabase transaction manager must take account indirect transitive conflicts multidatabase transactions caused local transactions conflicts difficult resolve behavior even existence local transactions known multidatabase system overcome difficulties propose incorporate additional data manipulation operations subtransactions multidatabase transaction show operations create direct conflicts subtransactions participating local database system indirect conflicts resolved even multidatabase system aware existence based approach introduce optimistic conservative multidatabase transaction management methods require local database systems ensure local serializability proposed methods violate autonomy local database systems guarantee global serializability preventing multidatabase transactions serialized different ways participating database systems refinements methods also proposed multidatabase environments participating database systems allow schedules cascadeless transactions analogous execution serialization orders particular show forced local conflicts eliminated rigorous local systems local cascadelessness simplifies design global scheduler local strictness offers significant advantages cascadelessness b introduction ultidatabase system mdbs 1 2 facility supports global applications accessing data stored multiple databases assumed access databases controlled autonomous possibly heterogeneous local database systems ldbss mdbs architecture figure 1 allows local transactions global transactions coexist local transactions submitted directly single ldbs multidatabase global transactions channeled mdbs interface objectives multidatabase transaction management avoid inconsistent retrievals preserve global consistency presence multidatabase updates objectives difficult achieve mdbss homogeneous distributed database systems addition problems caused data distribution distributed database georgakopoulos distributed object computing de partment gte laboratories incorporated 40 sylvan road ms62 waltham 02254 rusinkiewicz department computer science university houston houston sheth bellcore 444 hoes lane piscataway nj 08854 g global transaction base data data base base data local transaction local transaction fig 1 multidatabase system architecture systems solve transaction management mechanisms mdbss must also cope heterogeneity autonomy participating ldbss important heterogeneities perspective transaction management dissimilarities transaction management primitives related error detection facilities available ldbs interfaces ii concurrency control commitment recovery schemes used ldbss local autonomy fundamental assumption mdbs concept autonomy specifies degree independence control ldbss data since total autonomy means lack cooperation com munication hence total isolation less extreme notions ldbs autonomy proposed literature 3 4 2 5 garciamolina kogan 4 explored concept node site autonomy context distributed system veijalainen 3 classifies ldbs autonomy requirement design autonomy execution autonomy communication autonomy addition notions autonomy sheth larson 2 identify additional ldbs properties preserve association au tonomy paper consider ldbs autonomy violated following two conditions satisfied 1 ldbs modified way 2 local transactions submitted ldbs need modified way eg take account ldbs participates mdbs multidatabase environment serializability local schedules sufficient maintain multidatabase consistency ensure global serializability ieee transactions knowledge violated local schedules must validated mdbs however local serialization orders neither reported local database systems determined controlling submission global subtransactions observing execution order determine serialization order global transactions ldbs mdbs must deal direct conflicts may exist subtransactions multidatabase transactions also indirect conflicts may caused local transactions since mdbs information existence behavior local transactions determining execution global local transactions globally serializable difficult example illustrating problem presented next section several solutions proposed literature deal problem however satisfactory main problem majority proposed solutions provide way assuring operation execution order global trans actions controlled mdbs reflected local serialization order global transactions produced ldbss example possible global transaction g executed committed ldbs another global transaction g j local serialization order reversed paper address problem introducing technique disallows local schedules enables mdbs determine serialization order global transactions participating ldbs method violate local autonomy applicable ldbss ensure local serializ ability unlike solutions proposed literature technique applied ldbss provide interfaces level setoriented queries updates eg sql quel established method determine local serialization order global transactions ldbss introduce optimistic conservative methods enforce global serializability addition propose efficient refinements methods multidatabase environments participating database systems use cas cadeless rigorous schedulers 6 7 show multidatabase scheduling simplified multidatabase environments local systems cascadeless simplifications possible ldbss use one many common schedulers ensure transaction serialization orders analogous commitment order show multidatabase environments local serialization order global transactions determined controlling commitment order participating ldbss although address problem enforcing global serializability context multidatabase sys tem solutions described paper applied distributed object management system 8 paper organized follows section ii identify difficulties maintaining global serializability mdbss review related work multidatabase model assumptions requirements towards local database management systems discussed section iii section iv introduce concept ticket propose optimistic ticket method otm multidatabase transaction management guarantee global serializability otm requires ldbss ensure local serializability section v introduce conservative ticket method ctm also requires global transactions take tickets free global restarts variations otm ctm use simpler global schedulers work multidatabase systems local systems cascadeless presented section vi section vii introduce concept implicit tickets propose implicit ticket method itm require subtransaction tickets works multidatabase environments participating ldbss rigorous integrating methods mixed multidatabase schedulers discussed section viii finally section ix summarize results ii problems maintaining global serializability related work many algorithms proposed transaction management distributed systems directly applicable mdbss possibility indirect conflicts caused local transactions illustrate point consider figure 2 depicts execution two multidatabase transactions g 1 g 2 local transaction transaction g reads data object draw arc g arc g denotes g writes example global transactions subtransactions ldbss ldbs 1 g 1 reads g 2 later writes therefore g 1 g 2 directly conflict ldbs 1 serialization order transactions ldbs 2 g 1 g 2 access different data items g 1 writes c later g 2 reads b hence direct conflict g 1 g 2 ldbs 2 ever since local transaction 1 writes b reads conflict indirectly ldbs 2 indirect conflict caused presence local transaction case serialization order transactions ldbs 2 becomes g multidatabase environment mdbs control execution global transactions operations issue therefore mdbs detect direct conflicts involving global transactions conflict g 1 g 2 ldbs 1 figure 2 however mdbs information local transactions indirect conflicts may cause example since mdbs information local transaction 1 cannot detect indirect conflict g 1 g 2 ldbs 2 although local schedules serializable global schedule nonserializable ie global order involving g 1 g 2 1 compatible local schedules early work area problems caused indirect conflicts fully recognized 9 gligor popescuzeletin stated schedule multidatabase transactions correct multidatabase transactions georgakopoulos rusinkiewicz sheth enforcing serializability multidatabase transactions 3 co ae ae ae ae ae ae ae ae fig 2 serial execution multidatabase transactions may violate serializability relative serialization order ldbs di rectly conflict breitbart silberschatz shown 10 correctness criterion insufficient guarantee global serializability presence local transac tions proved sufficient condition global consistency requires multidatabase transactions relative serialization order sites execute solutions problem concurrency control mdbss proposed literature divided several groups observing execution global transactions ldbs 11 execution order global transactions determine relative serialization order ldbs example ldbs 2 figure 2 global transaction g 1 executed g 2 g 2 precedes g 1 local serialization order determine local conflicts transactions logar sheth 12 proposed using commands local operating system dbms snoop ldbs approach may always possible without violating autonomy ldbs controlling submission execution order global transactions alonso et al proposed use site locking altruistic locking protocol 13 prevent undesirable conflicts multidatabase transactions given pair multidatabase transactions g 1 g 2 simplest altruistic locking protocol allows concurrent execution g 1 g 2 access different ldbss ldbs g 1 g 2 need access g 2 cannot access g 1 finished execution du et al 14 shown global serializability may violated even multidatabase transactions submitted serially ie one completion corresponding ldbs scenario figure 2 illustrates problem g 1 submitted sites executed completely committed g 2 submitted execution nevertheless global consistency may violated limiting multidatabase membership ldbss use strict schedulers disallowing local executions serializable strict approach places additional restrictions execution global local transactions participating ldbs solution category called 2pc agent method proposed 15 2pc agent method assumes participating ldbss use twophase locking 2pl 16 schedulers produce strict 17 schedules basic idea method strict ldbss permit local executions violate global serializability however even local strictness sufficient illustrate problem consider ldbss figure 2 following local schedules schedule ldbs 1 serial ldbs 2 g 1 g 2 able obtain readlocks read b next g 2 releases read lock b acquire locks g 1 able obtain write lock update b g 2 commits execution allowed 2pl strictness 2pl satisfied transaction holds writelocks end therefore schedules strict allowed 2pl however global serializability violated assume conflicts among global transactions whenever execute site idea used logar sheth 12 context distributed deadlocks mdbss breitbart et al 18 concurrency control amoco distributed database system adds approaches based notion site graph adds method global transaction issues subtransaction ldbs undirected edges added connect nodes ldbss participate execution global transaction addition edges global transaction create cycle graph multidatabase consistency preserved global transaction allowed proceed otherwise inconsistencies possible global transaction aborted site graph method violate local autonomy correctly detects possible conflicts multidatabase transactions however used concurrency control significant drawbacks first degree concurrency allowed rather low multidatabase transactions cannot executed ldbs concurrently second since site graph method uses undirected graph represent conflicts cycles graph correspond globally nonserializable schedules third importantly mdbs using site graphs way determine safe remove edges committed global transaction edge removal policy used serialization graph testing algorithm 17 applicable case since site graph undirected illustrate problem consider ldbss figure 2 following local schedules perform operations ldbss site graph corresponds schedules contains cycle g 1 g 2 resolve cycle site graph method aborts g 2 suppose edges corresponding g 1 removed site graph immediately following commitment g 1 g 2 restarted commitment g 1 allowed commit since cycle site graph suppose g 2 commits local transaction 1 issues w commits execution operations results schedules shown figure 2 schedules locally serializable globally nonserializable therefore edges corresponding global transaction removed site graph immediately following commitment global serializability may violated site graph method may work correctly removal edges corresponding committing transaction delayed however concurrency sacrificed scenario represented figure 2 edge corresponding g 1 removed commitment local transaction 1 however mdbs way determining time commitment even existence local transaction 1 problem recognized 6 7 modifying local database systems andor ap plications pu 19 shown global serializability ensured ldbss present local serialization orders mdbs since traditional dbmss usually provide serialization order pu suggests modifying ldbss provide pons vilarem 20 proposed modifying existing applications transactions cluding local ones channeled multidatabase interfaces methods mentioned preserve multidatabase consistency expense partially violating local autonomy rejecting serializability correctness crite rion concept sagas 21 22 proposed deal longlived transactions relaxing transaction atomicity isolation quasiserializability 23 assumes value dependencies exist among databases indirect conflicts ignored stransactions 24 flexible transactions 25 use transaction semantics allow nonserializable executions global transactions solutions violate ldbs autonomy used whenever correctness guarantees offer ap plicable paper assume global schedules must serializable iii multidatabase system model global transactions consist transaction begin oper ation partially ordered collection read write op erations commit abort rollback operation following discussion refer collection read write operations performed transaction database operations use term transaction management operations refer nondatabase operation performed mdbs processes global transaction g fol lows first mdbs decomposes g subtransactions decomposition g based location data objects g accesses example g data objects ldbs mdbs issues subtransaction carry operations g ldbs assume subtransactions generated mdbs satisfy following requirements 1 one subtransaction per ldbs global transaction 2 like global transactions subtransactions consists database operations transaction management op erations subtransaction operations executed locally ldbs subtransaction may perform preparetocommit operation issuing commit ldbs provides operation interface 3 subtransactions visible preparedtocommit state say transaction enters preparedtocommit state 26 completes execution database operations leaves state committed aborted time updates reside private workspace become permanent database transaction committed preparedtocommit state visible application program case mdbs decide whether transaction commit abort process g mdbs submits subtransactions g corresponding ldbss ensure logically indivisible action commit abort g consistently carried participating sites mdbs uses twophase commit 2pc 26 protocol since ldbss may reside remote sites mdbs agent process associated ldbs submit gs operations ldbs handle exchange synchronization messages mdbs local database management systems assumptions assume ldbs provides following features without requiring modification 1 permits serializable recoverable 17 schedules 2 ensures failure atomicity durability transac tions subtransaction fails aborted dbms automatically restores database state produced last locally committed transaction 3 supports begin commit abort rollback transaction management operations subtransaction either issue commit install updates database issue abort roll back effects 4 notifies transaction programs action takes unilaterally particular assumed dbms interface provided inform subtransaction programs unilaterally aborted ldbs example resolve deadlock dbms may roll back one eg youngest transactions involved notify killed transaction rollback eg setting flag program georgakopoulos rusinkiewicz sheth enforcing serializability multidatabase transactions 5 communication area features supported majority commercial dbmss including 1 db2 ingres oracle sybase furthermore features described comply sql 27 rda 28 standards dbmss use high level languages eg sql support setoriented queries updates discussion model global transactions subtransactions local transactions collections read write operations chosen readwrite transaction model simplify discussion problems enforcing global serializability multidatabase environment use model describe corresponding solutions however use readwrite model neither limits generality solution proposed paper makes difficult apply ldbs supports interfaces level setoriented queries updates illustrate included appendix discusses implementationrelated issues ldbs using sql interfaces b preparedtocommit state multidatabase envi ronment earlier section iii listed assumption subtransactions visible preparedtocommit state many database management systems designed using clientserver architecture eg sybase provide visible preparedtocommit state directly participate multidatabase system hand ldbs explicitly provide state mdbs simulate 29 30 simulate preparedtocommit state subtrans action mdbs must determine whether database operations issued subtransaction successfully completed one way accomplish force handshake operation ie mdbs must submit operations subtransaction one time wait completion previous database operation submitting next one alternatively rda standard 28 allows asynchronous submission several database operations provides mechanism inquire status consider state subtransaction successfully finished operations neither committed aborted distinguish state prepared tocommit state refer simulated preparedto commit state basic difference prepared tocommit state simulated preparedtocommit state transaction simulated state firm assurance dbms unilaterally aborted however database management systems mention product vendors paper done background information provide example technology illustrative purposes construed either positive negative commentary product vendor neither inclusion product vendor paper omission product vendor interpreted indicating position opinion product vendor part authors bellcore reader encouraged make independent determination products marketplace whether particular features meet individual needs unilaterally abort transaction entered simulated preparedtocommit state 2 transactions state cannot involved deadlocks successfully performed operations acquired locks true ldbss use aborts restarts resolve conflicts example timestamp ordering 17 aborts transaction issues operation conflicts operation performed earlier younger transaction therefore timestamp ordering schedulers never abort transactions successfully issued operations entered simulated preparedtocommit state behavior optimistic concurrency control protocols 32 similar transaction ever aborted passes validation dbmss abort transactions state concurrency control recovery reasons possible argue dbmss must set timeouts avoid idle transactions holding resources forever however due difficulties determining whether subtransaction idle long timeouts set dbmss outstanding operations eg sybase oracle therefore last read write operation subtransaction completed mdbs certain subtransaction entered state practice different prepared tocommit state required 2pc rest paper distinguish whether visible preparedtocommit state simulated provided local systems additional issues related problem effectively providing preparedtocommit state discussed 33 iv optimistic ticket method otm section describe method multidatabase transaction management called otm violate ldbs autonomy guarantees global serializability participating ldbss ensure local serializability proposed method addresses two complementary issues 1 mdbs obtain information relative serialization order subtransactions global transactions ldbs 2 mdbs guarantee subtransactions multidatabase transaction relative serialization order participating ldbss following discussion consider site failures commitment recovery multidatabase transactions discussed among others 34 35 30 33 determining local serialization order otm uses tickets determine relative serialization order subtransactions global transactions ldbs ticket logical timestamp whose value stored regular data object ldbs avoidance technique 31 may abort transaction holding lock transaction requests lock policy aware may abort transaction simulated preparedtocommit state since use limited commercial dbmss consider paper assume transaction simulated preparedtocommit state aborted ldbs 6 ieee transactions knowledge subtransaction global transaction required issue takeaticket operation consist reading value ticket ie rticket incrementing ie wticket regular data manipulation opera tions value ticket operations tickets issued ldbs subject local concurrency control database constraints single ticket value per ldbs needed takeaticket operation violate local autonomy modification local systems required subtransactions global transactions take tickets 3 local transactions affected theta theta z z z z z z z z bn phi theta theta theta theta theta c flfig 3 effects takeaticket approach figure 3 illustrates effects takeaticket process example figure 2 ticket data objects denoted 1 2 respectively ldbs 1 1 values obtained subtransactions g 1 g 2 reflect relative serialization order schedule permitted local concurrency controller ldbs 1 ldbs 2 local transaction 1 causes indirect conflict g requiring subtransactions take tickets force additional conflict g 1 g 2 additional ticket conflict causes execution ldbs 2 become locally nonserializable therefore local schedule r r g2 b wt1 b allowed local concurrency control ie subtransaction g 1 subtransaction g 2 1 blocked aborted hand local schedule ldbs 2 example 3 may create hot spot ldbss however since subtransactions multidatabase transactions local ldbs transactions compete tickets consider major problem affecting performance method r g2 b wt1 b tickets obtained g 1 g 2 would reflect relative serialization order case local schedule would permitted local concurrency control ldbs 2 although transactions example take tickets beginning execution transactions may take tickets time lifetime without affecting correctness takeaticket approach theorem 1 formally proves tickets obtained subtransactions ldbs guaranteed reflect relative serialization order theorem 1 tickets obtained subtransactions multidatabase transactions determine relative serialization order proof let g g j subtransactions global transactions g g j respectively ldbs without loss generality assume g takes ticket precedes r g j ticket local execution order since subtransaction takes ticket first increments ticket value following execution orders possible however among executions e 3 serializable allowed ldbs concurrency control therefore increments ticket value g j reads g j obtains larger ticket g show g serialized g j sufficient point operations take increment ticket issued first g g j create direct conflict direct conflict forces g g j serialized according order take tickets specifically another direct conflict g g j indirect conflict caused local transactions resulting schedule serializable g g j allowed commit case g serialized g j reflected order tickets however direct conflict indirect conflict ure 4 ticket conflict creates cycle local serialization graph hence execution becomes nonserializable allowed ldbs concurrency control therefore indirect conflicts resolved use tickets local concurrency control even mdbs cannot detect existence 2 implementation tickets takeaticket operation ldbss using sql described appendix b enforcing global serializability maintain global serializability otm must ensure subtransactions global transaction relative serialization order corresponding ldbss 10 since relative serialization order subtransactions ldbs reflected values tickets basic idea otm allow sub georgakopoulos rusinkiewicz sheth enforcing serializability multidatabase transactions 7 oe oe oe oe oe oe oe oe au delta oe oe oe theta theta theta c b transaction conflicts ticket conflicts fig 4 effects ticket conflicts otm transactions global transaction proceed commit ticket values relative order participating ldbss requires subtransactions global transactions visible prepared tocommit state otm processes multidatabase transaction g follows initially sets timeout g submits subtransactions corresponding ldbss subtransactions allowed interleave control ldbss enter preparedtocommit state enter preparedtocommit states wait otm validate g validation performed using global serialization graph gsg test 4 nodes gsg correspond recently committed global trans actions pair recently committed global transactions g c contains directed edge g c least one subtransaction g c serialized obtained smaller ticket subtransaction g c ldbs strategy node edge removal gsg presented lemma 1 initially gsg contains cycles validation global transaction g otm first creates node g gsg attempts insert edges gs node nodes corresponding every recently committed multidatabase transaction g c ticket obtained 4 validation tests certification scheme proposed 19 also used validate global transactions subtransaction g ldbs smaller larger ticket subtransaction g c edge g added gsg edges added without creating cycle gsg g validated otherwise g pass validation node together incident edges removed graph g restarted validation test enclosed single critical section 5 g also restarted least one ldbs forces subtransaction g abort local concurrency control reasons eg local deadlock timeout expires eg global deadlock one participating ldbss uses blocking mechanism concurrency con trol timeouts mentioned necessary resolve global deadlocks timeout assigned global transaction g based conservative estimate expected execution time g difficult estimate expected duration global transaction g alternative solution set different timeout subtransaction g latter timeout strategy combined waitfor graph wfg wfg maintained mdbs ldbss nodes cycle found wfg cycle involves ldbss use blocking scheme synchronize conflicting transactions deadlock possible mdbss maintain wfg resolve global deadlocks setting timeouts operations issued ldbss involved wfg cycle addition use blocking enforce local serializability recoverability paper discuss timeout strategies choice timeout strategy effect correctness otm decentralized deadlockfree refinement optimistic ticket method described 38 mentioned serialization graph must contain nodes corresponding recently committed global transactions provide condition safe removal transaction nodes serialization graph lemma 1 node corresponding committed transaction g c safely removed serialization graph incoming edges transactions active time g c committed either committed aborted node removed graph edges incident node also removed proof transaction node participate serialization cycle must least one incoming edge transaction started commitment g c take tickets g c cannot add incoming edges node g c since assume g c incoming edges transactions active time g c 5 including validation test critical section originally proposed kung robinson 32 several schemes proposed literature eg parallel validation schemes 32 36 deal possibility bottlenecks caused critical sections although could adopted schemes evidence allow throughput performing transaction validation serially ie within critical section otm commercial implementations optimistic concurrency control protocols chosen serial validation parallel validation similar reasons eg datacycle 37 committed finished node corresponding g c never involved serialization cycle therefore safely removed serialization graph 2 following theorem proves correctness otm theorem 2 otm guarantees global serializability following conditions hold 1 concurrency control mechanisms ldbss ensure local serializability 2 multidatabase transaction one subtransaction ldbs 3 subtransaction visible preparedtocommit state proof already shown order subtransactions take tickets reflects relative serialization order theorem 1 tickets obtained global transaction sites executes otm performs global serialization test described earlier section global transactions pass validation allowed commit relative serialization order participating ldbss lemma 1 shows serialization test involving recently committed transactions sufficient guarantee global serializabilityc effect ticketing time performance otm otm process number multidatabase transactions concurrently even conflict multiple ldbs however since otm forces subtransactions multidatabase transactions directly conflict ticket may cause subtransactions get aborted blocked ticket conflicts figure 4 b since subtransactions may take tickets time lifetime without affecting correctness otm optimization based characteristics subtransaction eg number time type data manipulation operations issued semantics possible ex ample global transactions conflict directly ldbs need take tickets determine relative serialization order sufficient observe order issue conflicting operations choosing right time take ticket lifetime subtransaction minimize synchronization conflicts among subtransactions example ldbs uses 2pl appropriate take ticket immediately subtransaction enters prepared tocommit state show effect convention consider ldbs uses 2pl local concurrency control figure 5 2pl requires subtransaction sets write lock ticket increments value given four concurrent subtransactions 1 interfere g 2 take ticket commit g 1 takes ticket similarly g 1 interfere g 3 g 1 take ticket commit 3 takes ticket however g 4 attempts take ticket g 1 taken ticket g 1 commits releases ticket lock gets blocked g 1 com qk ae z lock abort validation parallel serial abort abort abort c preferred ticketing ldbs using occ b preferred ticketing ldbs using preferred ticketing ldbs using 2pl fig 5 preferred ticketing ldbss mitted ticket values always reflect serialization order subtransactions multidatabase transactions ticket conflicts minimized g 1 takes ticket close possible commitment time ldbs uses timestamp ordering 17 figure 5 b better obtain ticket subtransaction begins execution assigns timestamp tsg 1 subtransaction g 1 begins execution let g 2 another subtransaction tsg 1 ticket obtained g 1 larger value ticket 2 g 1 aborted clearly g 2 increments ticket value g 1 since g 2 younger g 1 either r g1 ticket w g1 ticket conflicts w g2 ticket 1 aborted hence g 1 allowed increment ticket value g 2 similarly g 2 reads ticket georgakopoulos rusinkiewicz sheth enforcing serializability multidatabase transactions 9 fore increments g 1 issues w g1 ticket conflicts r g2 ticket operation issued 1 aborted therefore given tsg 1 1 takes ticket g 2 g 1 aborted hence better subtransactions take tickets close possible point assigned timestamps ie beginning execution another significant optimization used completely eliminate tickets ldbss use schedulers let g 1 g 2 pair subtransactions take tickets since transactions control scheduler assigned timestamp time submission time complete first database operation global scheduler ensure g 1 obtains local timestamp smaller timestamp g 2 delaying submission g 2 g 1 completes first database operation using technique global scheduler ensure submission order subtransactions determines local serialization order g 1 serialized g 2 local system finally ldbs uses optimistic concurrency control best time subtransactions take tickets figure 5 c transactions control occ read phase followed validation phase occ uses transaction readsets writesets validate transactions transactions pass validation enter write phase thus subtransaction 1 reads ticket value starts serial parallel validation increments end phase another transaction g 2 able increment ticket meantime g 1 pass validation restarted basic advantages otm requires local systems ensure local serializability optimistic global scheduler imposes restrictions local execution global transactions main disadvantages following ffl optimistic scheduling global restarts possible ffl global scheduler must maintain gsg ffl tickets introduce additional conflicts global transactions may conflict otherwise following three sections describe solutions address issues respectively v conservative ticket method ctm otm affect way ldbss handle execution global transactions point subtransactions enter preparedtocommit state optimistic global schedulers based uncontrolled local execution global subtransactions otm easier implement cases allow concurrency conservative schedulers however since optimistic global schedulers allow global transactions take tickets order suffer global restarts caused outoforder ticket operations explain problem global restarts consider situation global transaction g obtains ticket another global transaction g j ldbs another ldbs g j able obtain ticket g mdbs scheduler aborts restarts either g g j disallow globally nonserializable execution ticket opera tions specifically multidatabase systems participating ldbss use blocking local concurrency control incompatible orders g g j take tickets different ldbss causes global deadlock resolve global deadlock otm scheduler aborts restarts global transaction whose timeout expires first ldbss use blocking local concurrency control incompatible execution orders ticket operations cause cycle gsg case global transaction enters global validation last rejected otm scheduler aborts section describe ctm method multidatabase transaction management eliminates global restarts like otm ctm requires subtransactions global transactions take tickets corresponding ldbss however unlike otm ctm controls order subtransactions take tickets avoid global restarts ctm ensures relative order global transaction take tickets participating ldbs ctm requires subtransactions global transactions visible preparedtotakeaticket state addition visible preparedtocommit state subtransaction enters preparedtotakeaticket state successfully completes execution database operations precede takeaticket operations leaves state reads ticket value visible preparedtotakeaticket state provided multidatabase system employing techniques simulate preparedtocommit state exam ple one way make preparedtotakeaticket state subtransaction visible force handshake database operation precedes takeaticket operations operations precede takeaticket operations completed successfully mdbs certain subtransaction entered preparedtotakeaticket state say global transaction becomes prepared take tickets subtransactions enter preparedtotakeaticket state ctm processes set g global transactions follows initially ctm sets timeout global transaction g submits subtransactions corresponding ldbss subtransactions global transactions allowed interleave control ldbss enter preparedtotakea ticket state without loss generality suppose subtransactions global transactions g 1 g g become prepared take tickets timeout expires furthermore suppose subtransaction g 2 enters preparedtotakeaticket state subtransactions g 1 become prepared take tickets ie g 1 becomes prepared take tickets subtransaction g 3 becomes prepared take ticket subtransactions g 2 enter prepared totakeaticket state ie g 2 becomes prepared take tickets g 3 subtransaction g k enters preparedtotakeaticket state subtransactions g become prepared take tickets ie g becomes prepared take tickets g k ctm allows subtransactions global transactions g 1 take tickets following order subtransactions g 1 take tickets subtransactions g 2 subtransactions g 2 take tickets subtransactions g 3 subtransactions g kgamma1 take tickets subtransactions g k global transactions allowed commit subtransactions successfully take tickets report preparedtocommit state hand mdbs aborts restarts multidatabase transaction subtransaction report preparedtocommit state timeout expired local optimizations discussed section ivc also applied ctm theorem 3 ctm guarantees global serializability free global restarts following conditions 1 concurrency control mechanisms ldbss ensure local serializability 2 multidatabase transaction one subtransaction ldbs 3 subtransaction visible preparedtotakea ticket visible preparedtocommit state proof without loss generality suppose global transactions set g become prepared take tickets following control ctm g 1 takes tickets g 2 takes tickets g 2 takes tickets g 3 takes tickets g k since ctm ensures relative order subtransactions global transaction take tickets participating ldbs proven order subtransactions take tickets reflects relative serialization order theorem 1 ctm guarantees global serializability avoids global restarts due ticket conflicts 2 another important property ctm require gsg hence global ctm scheduler simpler global otm scheduler optimistic scheduler require gsg described next vi cascadeless tickets methods ensure correctness presence failures simplify recovery concurrency control transaction management mechanisms used database management systems often ensure serializability recoverability 17 also one properties defined ffl transaction management mechanism cascadeless 17 transaction may read data objects written committed transactions ffl transaction management mechanism strict 17 data object may read written transactions previously wrote commit abort many commercial dbmss allow strict schedules eliminate cascading aborts also able ensure database consistency images used database recovery perspective multidatabase scheduler cascadelessness ldbss important used eliminate gsg global serialization graph test required otm take advantage cascadeless ldbss introduce refinement otm called cas cadeless otm like otm cascadeless otm ensures global serializability preventing subtransactions multidatabase transaction serialized different ways corresponding ldbss unlike otm cascadeless otm takes advantage fact ldbss permit cascadeless schedules global transactions cannot take tickets commit unless tickets relative order ldbss cascadeless otm processes global transaction g follows initially mdbs sets timeout g submits subtransactions appropriate ldbss subtransactions allowed interleave control ldbss enter preparedtocommit state subtransactions g take tickets report preparedtocommit state cascadeless otm allows g commit otherwise mdbs aborts restarts global transaction subtransaction report preparedtocommit state timeout g expired local optimizations mentioned section ivc also applied cascadeless otm theorem 4 cascadeless otm guarantees global serializability following conditions satisfied 1 concurrency control mechanisms ldbss ensure local serializability cascadelessness 2 multidatabase transaction one subtransaction ldbs 3 subtransaction visible preparedtocommit state proof already shown order subtransactions take tickets reflects relative serialization order theorem 1 prove global serializability enforced without gsg test consider pair global transactions g g j set g subtransactions multiple ldbss including ldbs k ldbs l without loss generality assume ldbs k subtransaction g takes ticket subtransaction g j ldbs l subtransaction g j takes ticket subtransaction g since ldbss cascadeless g j cannot write ticket value ldbs k g commits g cannot write ticket ldbs l g j commits therefore two possible outcomes execution global transaction cascadeless otm either tickets subtransactions relative order ldbss global serializability ensured least one subtransaction cannot commit 2 like otm cascadeless otm free global restarts cascadeless ctm similar ctm used deal global restarts georgakopoulos rusinkiewicz sheth enforcing serializability multidatabase transactions 11 local cascadelessness used simplify global optimistic scheduler ie need maintain gsg strictness offers additional advantages cascadelessness following section show schedulers local systems meet additional conditions ticket conflicts totaly eliminated vii implicit tickets implicit ticket method itm argued basic problem multidatabase concurrency control local serialization orders necessarily reflect order global transactions submitted perform operations commit ldbss deal problem introduced concept ticket proposed several methods must take tickets ensure global serializability however tickets introduce additional conflicts global transactions may conflict otherwise thus desirable eliminate tickets whenever possible following sections identify classes schedules include events used determine local serialization order transactions without forcing conflicts global transactions refer events implicit tickets determining local serialization order section ivc discussed eliminate tickets ldbss use local concurrency con trol approach applied ldbss allow transactions commit respective local serialization order reflect local submission order class ldbss allow schedules transaction submission order determines serialization order order transactions issue begin operations constitutes implicit tickets another important class local systems global transactions take tickets includes ldbss allow schedules local commitment order transactions determines local serialization der ie order transactions perform commit operations constitutes implicit tickets 6 7 defined class schedules transactions analogous execution commitment serialization order follows 1 let serializable schedule say transactions analogous execution serialization order pair transactions j committed j also serialized j property analogous execution serialization orders applies view serializable conflict serializable schedules difficult enforce directly class schedules conflict serializable analogous executions serialization order characterized terms strong recoverability 7 defined definition 2 let schedule say strongly recoverable pair committed transactions whenever operation op precedes operation op j j operations conflict least one operations write precedes committ j transaction management mechanism strongly recoverable produces strongly recoverable schedules 7 shown transaction management mechanism strongly recoverable produces conflict serializable schedules transaction execution serialization orders analogous significance strong recoverability simplifying enforcement global serializability multidatabase systems recognized literature example notion commitment ordering proposed 39 40 solution enforce global serializability without taking tickets identical strong recoverability although strongly recoverable schedulers realized real dbmss real transaction management mechanisms produce schedules satisfy stronger properties easier enforce notion rigorous schedules 6 7 defined next effectively eliminates conflicts uncommitted trans actions thus provides even simpler way ensure transaction execution serialization orders analogous definition 3 schedule rigorous following two conditions hold strict ii data object written transactions previously read commit abort say transaction management mechanism rigorous produces rigorous schedules use rigorous ldbs refer ldbs uses rigorous scheduler 6 shown transaction management mechanism ensures rigorousness produces serializable schedules transaction execution serialization orders analogous 7 proved set rigorous schedules subset strongly recoverable schedules class rigorous transaction management mechanisms includes several common conservative schedulers 6 7 conservative 17 rigorous twophase locking 2pl ie variant strict 2pl transaction must hold read write locks terminates rigorous variations optimistic concurrency control 32 protocols introduced 6 however many conservative schedulers rigor ous enforcing rigorousness restrictive optimistic schedulers ie rigorous optimistic schedulers behave like conservative schedulers following class schedules permits optimistic synchronization operations definition 4 schedule semirigorous committed projection rigorous semirigorousness permits validation transactions finished operations therefore simplifies design optimistic schedulers real optimistic schedulers including schedulers described 32 allow semirigorous schedules semi rigorousness simplifies optimistic concurrency control ensure recoverability defined 17 view serializability conflict serializability analogous execution serialization orders strong recoverability semirigorousness rigorousness fig 6 relationship among analogous execution serialization orders strong recoverability semirigorousness rigorousness fore optimistic schedulers ensure cascadelessness strictness addition semirigorousness example schedulers use optimistic protocol serial validation permit schedules addition semi rigorous also strict set semirigorous schedules includes rigorous schedules subset set strongly recoverable schedules relationship among analogous execution serialization orders strong recoverability semi rigorousness rigorousness depicted figure 6 finally note strictness sufficient ensure transaction execution order analogous transaction serialization order example assume transactions commit immediately complete last operation schedule ldbs 2 figure 2 strict execution order transactions analogous serialization order b enforcing global serializability take advantage ldbss allow analogous execution serialization orders introduce implicit ticket method itm like otm ctm itm ensures global serializability preventing subtransactions multidatabase transaction serialized different ways corresponding ldbss unlike otm ctm itm need maintain tickets subtransactions global transactions need take increment tickets explicitly ldbss allow analogous execution serialization ders implicit ticket subtransaction executed determined commitment order order commit subtransactions ldbs determines relative values implicit tickets achieve global serializability itm controls commitment order thus serialization order multidatabase subtransactions follows assuming rigorous ldbss itm guarantees pair multidatabase transactions g g j either subtransactions g committed subtransactions g j subtransactions g j committed prior subtransactions g easily enforced distributed agreement protocol 2pc protocol itm processes set g global transactions follows initially itm sets timeout global transaction g submits subtransactions corresponding ldbss subtransactions global transactions allowed interleave control ldbss enter preparedtocommit state without loss generality suppose subtransactions global transactions g 1 g become prepared commit timeout expires furthermore suppose subtransaction g 2 enters preparedtocommit state subtransactions g 1 become prepared commit subtransaction g 3 becomes prepared commit subtransactions g 2 enter preparedtocommit state subtransaction g k enters preparedtocommit state subtransactions g become prepared commit itm allows subtransactions global transactions commit following order subtransactions subtransactions g 2 subtransactions g 2 subtransactions g 3 subtransactions g kgamma1 subtransactions g k global transactions one subtransactions report preparedtocommit state timeout expires aborted restarted mdbs theorem 5 itm ensures global serializability following conditions hold 1 concurrency control mechanisms ldbss ensure analogous executions serialization orders 2 multidatabase transaction one subtransaction ldbs 3 subtransaction visible preparedtocommit state proof without loss generality suppose global transactions set g enter prepared commit state following control itm subtransaction g 1 commit subtransactions g 2 subtransaction g 2 commit subtransaction g 3 subtransactions g subtransactions g k since itm ensures relative order subtransactions global transaction commit participating ldbss ldbss ensure subtransaction commitment order reflects relative serialization order itm guarantees global serializability 2 viii mixed methods multidatabase environment rigorous cascade less noncascadeless ldbss participate mixed ticket methods combine two methods de georgakopoulos rusinkiewicz sheth enforcing serializability multidatabase transactions 13 scribed previous sections paper used ensure global serializability section describe mixed ticket method combines otm ctm cascadeless variations itm mixed method processes multidatabase transaction g follows 1 sets timeout g submits subtransactions corresponding ldbss 2 subtransactions controlled itm otm cascadeless variation otm allowed interleave enter preparedtocommit state subtransactions controlled ctm cascadeless ctm allowed proceed enter preparedtotakeaticket state 3 subtransactions g control otm take tickets report preparedtocommit state global validation applied ensure subtransactions serialized way g pass global validation aborted 4 subtransactions control ctm cascadeless ctm allowed take tickets according serialization order g determined earlier validation process ensure mixed method delays takeaticket operations subtransactions g execute control ctm cascadeless ctm uncommitted global transaction g 0 g 0 subtransactions taken tick ets ffl least one ldbs subtransaction g 0 taken ticket subtransaction g global transaction satisfies conditions mixed method allows subtransactions g take tickets control ctm 5 subtransactions g enter preparedto commit states mixed method commits g global transactions allowed commit either first subtransaction g commits commitment subtransactions g 6 timeout expires steps mdbss aborts restarts g simpler mixed methods eg combining optimistic conservative ticket methods developed similarly ix summary conclusion enforcing serializability global transactions mdbs environment much harder distributed databases systems additional difficulties environment caused autonomy heterogeneity participating ldbss enforce global serializability introduced otm optimistic multidatabase transaction management mechanism permits commitment multidatabase transactions relative serialization order participating ldbss otm requires ldbss guarantee local serializability basic idea otm create direct conflicts multidatabase transactions ldbs allow us determine relative serialization order subtransactions also introduced conservative ticket method ctm ctm global transactions must take tickets ctm require global serialization testing eliminates global restarts due failed validation refinements otm ctm multidatabase environments participating ldbss cascadeless may use simpler global schedulers unless subtransactions multidatabase transactions take tickets approximately time eg subtransactions global transaction take tickets end execution duration approximately conservative ticket methods may allow higher throughput corresponding optimistic ticket methods take advantage additional properties ldbss proposed implicit ticket method itm eliminates ticket conflicts works participating ldbss disallow schedules transaction execution serialization orders analogous itm uses local commitment order subtransaction determine implicit ticket value achieves global serializability controlling commitment execution order thus serialization order multidatabase transactions compared adds approach altruistic locking itm process number multidatabase transactions concurrently even concurrent conflicting subtransactions multiple sites methods proposed paper violate autonomy ldbss combined single comprehensive mechanism analogous transaction execution serialization orders useful property mdbs example shown adds scheme 10 18 altruistic locking 13 2pc agent method 15 produce globally serializable schedules participating ldbss disallow schedules transaction execution serialization orders analogous similarly quasiserializable schedules 23 become serializable ldbss permit analogous transaction execution serialization orders hand local systems allow schedules transaction execution serialization orders anal ogous methods may lead schedules globally serializable another important finding local strictness multidatabase environment offers advantage cas cadelessness simplifying enforcement global serializability research prototyping currently performed gte laboratories bellcore university houston activities include performance evaluation proposed ticket methods benchmarking prototype implementation current research conducted gte laboratories includes adaptation ticket methods provide consistency distributed object management system doms 8 global transactions access homogeneous objects encapsulate autonomous 14 ieee transactions knowledge concurrency control mechanisms andor attached objects represent data functionality autonomous heterogeneous ldbss takeaticket operation viewed function returns serialization order transaction ldbs function provided interfaces future dbmss multidatabase transaction management methods use tickets enforce global serializability substitute ticket operations calls dbmsprovided serialization order functions continue enforce global serializability without modification acknowledgments idea use tickets multidatabase transaction management emerged discussion gomer thomas thank yuri breitbart pointing error one definitions earlier version paper piotr krychniak implemented ticket methods real dbmss contributed discussion implementation issues appendix also thank mark hornick ole anfindsen useful comments r database systems multidatabase systems federated databases architectures integration transaction concepts autonomous database environments node autonomy distributed systems effects local autonomy heterogeneous distributed database systems rigorous scheduling multidatabase systems rigorous transaction scheduling distributed object management concurrency control issues distributed heterogeneous database management systems multidatabase update sues supporting updates heterogeneous distributed database systems concurrency control issues heterogeneous distributed database management systems concurrency control recovery global procedures federated database systems effects autonomy maintaining global serializability heterogeneous distributed database systems 2pc agent method achieving serializability presence failures heterogeneous multi database notions consistency predicate locks database system concurrency control recovery database systems update mechanism multidatabase systems superdatabases composition heterogeneous databases mixed concurrency control dealing heterogeneity distributed database systems transaction concept virtues limitations sagas qsr correctness criterion global concurrency control interbase transaction model ex tending transaction model capture meaning operating systems advanced course guide sql standard transaction management multidatabase systems multidatabase recoverability recov ery system level concurrency control distributed database systems optimistic methods concurrency control prepare commit certification decentralized transaction management rigorous heterogeneous multidatabases transaction management multidatabase systems reliable transaction management multidatabase system performance analysis optimistic basic timestampordering concurrency control algorithms centralized database systems datacycletm archi tecture decentralized deadlockfree concurrency control method mul georgakopoulos rusinkiewicz sheth enforcing serializability multidatabase transactions 15 tidatabase transactions extended commitment ordering guaranteeing global serializability applying commitment order selectively global transactions commitment order coordinator coco resource manager architecture distributed commitment ordering based concurrency control tr concurrency control recovery database systems guide sql standard sagas multidatabase update issues node autonomy distributed systems quasi serializability correctness criterion global concurrency control interbase rigorous transaction scheduling transaction management multidatabase systems stransaction model datacycle architecture optimistic methods concurrency control system level concurrency control distributed database systems notions consistency predicate locks database system extending transaction model capture meaning superdatabases composition heterogeneous databases supporting updates heterogeneous distributed database systems performance analysis optimistic basic timestampordering concurrency control algorithm centralized database systems prepare commit certification decentralized transaction management rigorous heterogeneous multidatabases mixed concurrency control ctr chihping wei olivia r liu sheng paul jenhwa hu fuzzy statistics estimation supporting multidatabase query optimization electronic commerce research v2 n3 p287316 july 2002 dogac c dengi e kilic g ozhan f ozcan nural c evrendilek u halici b arpinar p koksal n kesim mancuhan metu interoperable database system acm sigmod record v24 n3 p5661 sept 1995 parvathi chundi daniel j rosenkrantz ravi multisite distributed database transactions utilizing deferred update proceedings 1997 acm symposium applied computing p118122 april 1997 san jose california united states sangkeun lee chongsun hwang wongye lee uniform approach global concurrency control recovery multidatabase environment proceedings sixth international conference information knowledge management p5158 november 1014 1997 las vegas nevada united states stefan bttcher concurrent checking global crossdatabase integrity constraints integrity internal control information systems v kluwer academic publishers norwell dexter p bradshaw perke larson jacob slonim transaction scheduling dynamic composite multidatabase systems proceedings 1995 conference centre advanced studies collaborative research p9 november 0709 1995 toronto ontario canada j b lim r hurson transaction processing mobile multidatabase environment multimedia tools applications v15 n2 p161185 november 2001 thomas tesch jrgen wsch global nested transaction management odmgcompliant multidatabase systems proceedings sixth international conference information knowledge management p6774 november 1014 1997 las vegas nevada united states junlin lin margaret h dunham survey distributed database checkpointing distributed parallel databases v5 n3 p289319 july 1997 sangkeun lee chongsun hwang heonchang yu revisiting transaction management multidatabase systems distributed parallel databases v9 n1 p3965 january 1 2001 dimitrios georgakopoulos george karabatis sridhar gantimahapatruni specification management interdependent data operationalsystems data warehouses distributed parallel databases v5 n2 p121166 april 1997 dimitrios georgakopoulos mark f hornick frank manola customizing transaction models mechanisms programmable environment supporting reliable workflow automation ieee transactions knowledge data engineering v8 n4 p630649 august 1996 james b lim r hurson transaction processing mobile heterogeneous database systems ieee transactions knowledge data engineering v14 n6 p13301346 november 2002 patricia serranoalvarado claudia roncancio michel adiba survey mobile transactions distributed parallel databases v16 n2 p193230 september 2004 smalcem budak arpinar uur halici sena arpinar asuman doa formalization workflows correctness issues presence concurrency distributed parallel databases v7 n2 p199248 april 1999
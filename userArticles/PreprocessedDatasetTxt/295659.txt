finitary fairness fairness mathematical abstraction multiprogramming environment fairness abstracts details admissible fair schedulers distributed environment fairness abstracts relative speeds processors argue standard definition fairness often unnecessarily weak replaced stronger yet still abstract notion finitary fairness standard weak fairness requires enabled transition postponed forever finitary weak fairness requires every computation system unknown bound k enabled transition postponed k consecutive times general finitary restriction finf given fairness requirement fis union ohgrregular safety properties contained f adequacy proposed abstraction shown two ways suppose prove program property assumption finitary fairness multiprogramming environment program satisfies property fair finitestate schedulers distributed environment program satisfies property choices lower upper bounds speeds timings processors benefits finitary fairness twofold first proof rules verifying liveness properties concurrent programs simplified wellfounded induction natural numbers adequate prove termination finitary fairness second fundamental problem consensus faulty asynchronous distributed environment solved assuming finitary fairness b introduction interleaving semantics provides elegant abstract way modeling concurrent computation approach computation concurrent system obtained letting step one enabled processes execute atomic instruction interleaving computations system satisfy property property holds implementations program independent whether tasks multiprogrammed processor scheduling policy used whether system distributed speeds different processors furthermore interleaving model simple reduces concurrency nondeterminism preliminary version paper appears proceedings ninth ieee symposium logic computer science pp 5261 1994 leave bell laboratories lucent technologies z supported part onr yip award n000149510520 nsf career award ccr9501708 nsf grant ccr9504469 afosr contract f496209310056 arpa grant nag2892 contract 95dc324a interleaving abstraction adequate proving safety properties systems safety property form something bad never happens example mutual exclusion however usually suitable prove guarantee properties guarantee property form something good eventually happen example termination general liveness properties traditional approach establishing guarantee properties require fair computations instead computations satisfy property intuitively fairness means individual process ignored forever since reasonable implementations system whether multiprogramming multiprocessing expected fair prove program satisfies property assumption fairness follows property holds possible implementations program theory specification verification using different forms fairness well understood see example lps82 fra86 mp91 fairness two major drawbacks first mathematical treatment fairness verification semantics complicated requires higher ordinals second fairness weak yield suitable model faulttolerant distributed computing illustrated celebrated result fischer lynch paterson standard fairness assumption processes cannot reach agreement asynchronous distributed system even one process fails quote paper flp85 results show problems distributed consensus cannot solved practice rather point need refined models distributed computing better reflect realistic assumptions processor communication timings propose one refined model introducing notion finitary fairness argue finitary fairness 1 sufficiently abstract capture possible implementations context multiprogramming context distributed computing 2 suffer either two aforementioned disadvantages associated standard notion fairness justification finitary fairness fairness requirement specified subset f set possible ways scheduling different processes program let us first consider multiprogramming environment tasks scheduled single processor scheduler meets given fairness requirement f program whose language ie set computations contained f language program safety property ie closed limits furthermore scheduler finitestate language regular thus capture finitestate schedulers implement f suffices consider countable union regular safety properties contained f several popular definitions f strong fairness weak fairness etc lps82 fra86 every choice f obtain finitary version finf union regular safety properties contained f case weak fairness f show finitary version finf particularly intuitive f prohibits schedule postpones task forever finf also prohibits schedule bound many consecutive times task postponed general fairness requirement f regular liveness property afk88 show finitary version finf still live regular let us consider distributed environment tasks executed concurrently different processors finitary fairness corresponds assumption execution speeds processors stay within certain unknown fixed bounds formally distributed system modeled transition system imposes lower upper time bounds transitions hmp94 show timed transition system satisfies property choices lower upper time bounds iff underlying untimed transition system satisfies property finitary weak fairness correspondence theorem establishes adequacy finitary fairness distributed systems addition provides method proving properties timed systems whose timing known priori summarize finitary fairness abstracts details fair finitestate schedulers details independent speeds timings processors bounded drift parametric definition finitary fairness also lends generalizations computable fairness computable version comf fairness assumption f countable union recursive safety properties contained f multiprogramming environment computable fairness abstracts details fair computable schedulers distributed environment computable fairness abstracts independent speeds processors whose drift bounded recursive function benefits finitary fairness verification address problem verifying program satisfies property finitary fairness assumption finf since finf regular specifiable temporal logic however obstacle verification finitestate programs show program satisfies temporallogic specification finf iff satisfies specification f means finitestate programs move finitary fairness call change verification algorithm general programs proof rules verifying liveness properties simplified use finitary fairness suppose wish prove program terminates prove computations program terminate one typically identifies ranking variant function states program natural numbers rank decreases every transition program method complete proving termination fair computations first may ranking function decreases every step standard complete verification rule rather relies ranking function never increases guaranteed decrease eventually lps82 fra86 purpose one needs identify socalled helpful transitions cause ranking function decrease second induction natural numbers complete proving fair termination one may resort induction ordinals higher show proving termination program finitary weak fairness reduced proving termination computations transformed program transformed program uses new integer variable unspecified initial value represent bound many consecutive times enabled transition may postponed since termination computations transformed program proved using strictly decreasing ranking function natural numbers reasoning finitary fairness conceptually simpler reasoning standard fairness distributed consensus central problem faulttolerant distributed computing consensus problem requires nonfaulty processes distributed system agree common output value psl80 although consensus cannot reached asynchronous model one process fails flp85 practice consensus achieved distributed applications using constructs like timeouts suggests asynchronous model standard fairness assumption useful abstraction studying faulttolerance one proposed solution problem considers unknowndelay model also called partially synchronous model fixed upper bound relative speeds different components bound known priori dls88 aat97 rw92 asynchronous model finitary fairness assumption abstract formulation unknowndelay model particular prove asynchronous model finitary fairness assumption admits waitfree solution consensus tolerates arbitrary number process failures showing finitary fairness substitute timing assumptions solution aat97 informal motivation bounded fairness introducing general definition finitary fairness section 3 applications sec tions 4 5 begin motivating finitary version weak fairness intuitive concept bounded fairness consider following simple program p 0 boolean variable x integer variable initially repeat x x forever k repeat program p 0 consists two processes one transition transition l complements value boolean variable x transition r increments value integer variable computation p 0 infinite sequence states starting initial state every state obtained predecessor applying one two transitions purpose example schedule infinite word alphabet fl rg computation p 0 corresponds schedule specifies order transitions taken computation two processes p 0 executed either multiprogramming distributed environment multiprogramming multiprogramming environment two processes p 0 scheduled single processor scheduler set possible schedules one typically requires scheduler fair shut one two processes forever formally schedule fair iff contains infinitely many l transitions infinitely many r transitions scheduler fair iff contains fair schedules set fair schedules restrict set computations program p 0 correspond fair schedules p 0 satisfies property oe iff every computation p 0 whose schedule f1 satisfies oe instance fairness assumption f1 program p 0 satisfies property fair computation value x true infinitely many states value even infinitely many states note computations p 0 correspond unfair schedules satisfy formula oe 1 thus fairness assumption necessary establish program p 0 satisfies property oe 1 fairness requirement f1 abstraction admissible reallife schedulers namely schedule transition eventually nonprobabilistic reallife scheduler however finitestate therefore must put bound eventuality consider instance roundrobin scheduler schedules transitions l r alternately roundrobin schedulers replace fairness assumption f1 much stronger assumption f 1 contains two schedules lr rl f 1 program p 0 satisfies property implies property oe 1 call f 1 1bounded scheduler general positive integer k kbounded scheduler never schedules one transition k times row formally schedule kbounded k 1 iff contains neither subsequence l k1 r k1 scheduler kbounded iff contains kbounded schedules similar definition considered jay88 let f k set kbounded schedules assumption f k kboundedness course sufficiently abstract k easy build fair finitestate scheduler kbounded let us say schedule bounded iff kbounded positive integer k scheduler bounded iff contains bounded schedules clearly every fair finitestate scheduler bounded order prove property program implementations suffices prove property bounded schedulers set bounded schedules restrict set computations program p 0 correspond bounded schedules p 0 satisfies property oe iff every computation p 0 whose schedule f satisfies oe call f finitary restriction fairness assumption f1 three observations f immediate first finitary version f proper subset f1 particular schedule fair unbounded therefore belongs second set f finitestate scheduler countable union fair finitestate schedulers third f liveness property sense stepwise scheduler cannot paint corner afk88 every finite word fl rg extended bounded schedule 1 since finitary fairness assumption f stronger fairness assumption f1 program may satisfy properties f consider example property state predicate powerof2 true state iff value power 2 computation p 0 satisfy oe must case transition l scheduled powerof2 holds follows every positive integer k subsequence length greater k contains r transitions schedule belong f hence program p 0 satisfies property oe f hand easy construct fair schedule satisfy oe shows p 0 satisfy oe f1 multiprocessing distributed environment two processes p 0 executed simultaneously two processors speeds two processors may different one typically requires nonfaulty processor transition consumes finite amount time fairness requirement f1 abstraction admissible reallife processors namely complete transition eventually fairness assumption f1 unnecessarily weak assume transition l executed processor requires least time l time u l two unknown rational numbers l u l u l l 0 similarly transition r also noted set f capture randomized schedulers given randomized scheduler chooses every step one two transitions equal probability probability resulting schedule f 0 hand probability resulting schedule f1 1 executed processor ii requires least time r 0 time u r r irrespective size four time bounds integer k 1 k delta l u r k delta r u l computation corresponds kbounded schedule follows finitary fairness adequate abstraction speedindependent processors noted finitary fairness adequate speeds different processors drift apart without bound case later generalize notion finitary fairness finitary fairness 31 sets infinite words language alphabet sigma subset set sigma infinite words sigma instance set computations program language alphabet program states regularity language regular iff recognized buchi automaton nondeterministic finitestate machine whose acceptance condition modified suitably accept infinite words buc62 class regular languages robust many alternative characterizations see tho90 overview theory regular languages particular set models formula propositional linear temporal logic ptl regular language gpss80 set computations finitestate program regular language set f1 section 2 fair schedules alphabet fl rg regular language 23 l 23 r set f k kbounded schedules every k 1 safety liveness language pi sigma let pref pi sigma set finite prefixes words pi language pi safety property limitclosed iff infinite words w finite prefixes w pref pi w 2 pi ads86 every safety property pi fully characterized pref pi since program executed step step set computations program safe language alphabet program states safety property regular iff recognized buchi automaton without acceptance conditions properties defined temporallogic formulas form 2 p p past formula ptl safe regular every k 1 set f k section 2 kbounded schedules regular safety property language pi liveness property iff pref every finite word extended word pi set f1 section 2 fair schedules regular liveness property topological characterization consider cantor topology infinite words distance two distinct infinite words w w 0 12 largest nonnegative integer w closed sets cantor topology safety properties dense sets liveness properties regular languages lie first twoandahalf levels borel hierarchy every regular language f oeffi g ffioe 2 also temporal characterization first twoandahalf levels borel hierarchy mp90 let p past formula ptl every formula form 2 p defines fset every formula form 3 p gset every formula form 23 p g ffi set every formula form 32 p f oe set example set f1 fair schedules g ffi set 32 finitary restriction language ready define operator fin finitary restriction finpi language pi countable union regular safety languages contained pi definition finitary restriction every language f oe also definition finpi pi following theorem states properties operator fin theorem 1 let pi pi 0 languages 1 2 fin monotonic pi ae pi 0 finpi ae finpi 0 3 fin distributes intersection finpi proof first two follow immediately definition fin since pi pi 0 contained pi well pi 0 monotonicity prove inclusion definition fin exist regular safety properties 1 class safety properties closed intersection class regular languages hence 1 regular safety property since w following proposition formalizes claims made example section 2 also shows finitary restriction regular language necessarily regular proposition 2 let f1 set fair schedules section 2 let f set bounded schedules f finitary restriction f1 neither regular safe proof recall f union regular safety properties contained f1 f k regular safety property f k ae f1 hence consider regular safety property g contained f1 suppose g accepted buchi automaton mg alphabet fl rg without loss generality assume every state mg reachable initial state every state accepting state since g safety property wish prove mg k states g f k suppose word w mg accepts w w contains consecutive symbols type say l thus since mg k states follows 2 first level borel hierarchy consists class f closed sets class g open sets second level class g ffi countable intersections open sets class f oe countable unions closed sets third level class f oeffi countable intersections f oe sets class g ffioe countable unions g ffi sets state mg path initial state labeled w 0 l 0 k cycle contains whose edges labeled l implies mg accepts word w fair schedule contradiction inclusion g f1 observe k 1 schedule l k extended word f k hence implying f closed limits f safety property prove f regular suppose f regular closure properties regular languages set unbounded fair schedules also regular know g nonempty contains schedule properties regular languages follows g contains word w two finite words contains least one l one r symbol means contradiction assumption w 62 f words although f countable union safety properties definable ptl f neither safety property definable ptl define f temporal logic one would need infinitary disjunction general operator fin preserve liveness also may happen pref however applied regular properties liveness preserved theorem 3 pi regular language pref proof since finpi pi pref monotonic pref finpi pref pi prove inclusion pref pi pref finpi suppose pi regular language sigma consider w 2 pref pi regularity pi follows word w 0 2 pi w 2 finite words language containing single word w 0 regular safe contained pi hence immediately leads following corollary corollary 4 pi regular liveness property finpi live observe language f1 regular live hence f also live pref means executing program fairness requirement f like original requirement f1 satisfied finite number steps operator fin illustrated typical languages 9k every subsequence length k pg 9k every subsequence k ps qg 33 transition systems standard fairness finitary fairness concurrent programs including sharedmemory messagepassing programs modeled transition systems mp91 transition system p triple q set states finite set transitions q 0 q set initial states state q 2 q assignment values program variables transition 2 binary relation states q 2 state q transition let set successors q computation q transition system p infinite sequence states q 0 2 q 0 0 transition 2 q set computations p set pip safe language q q finite pip regular transition enabled ith step computation q iff q nonempty taken ith step q iff q loss generality assume set program variables contains every transition 2 boolean variable enabled boolean variable taken let scheduling alphabet sigma finite set interpretations boolean variables sigma power set set fenabled taken j 2 tg given computation q p schedule oeq q projection q scheduling alphabet set schedules p safety property sigma fairness requirement f transition system p language finite scheduling alphabet sigma fairness requirement restricts set allowed computations program general f regular liveness property afk88 requirement liveness ensures executing program fairness requirement satisfied finite number steps particular requirement weak fairness wf p set infinite words w every transition 2 infinitely many integers 0 taken 2 w transition enabled forever without taken specified following requirement wf regular live requirement strong fairness sf p set infinite words w every transition 2 infinitely many steps infinitely many steps transition enabled infinitely often without taken stronger requirement weak fairness sf ae wf specified formula weakfairness requirement wf g ffi set strongfairness requirement sf neither g ffi f oe lies f oeffi g ffioe since sets regular finitary restrictions finwf finsf belong f oe live corollary 4 next theorem generalization proposition 2 shows finitary restriction weak strong fairness coincide appropriate notions bounded fairness define schedule weaklykbounded nonnegative integer k iff transitions p cannot enabled k consecutive steps without taken integers 0 integer j enabled 62 w j schedule weaklybounded weaklykbounded k 0 similarly schedule w stronglykbounded iff transitions subsequence w contains k distinct positions enabled contains position taken integers schedule stronglybounded stronglykbounded k 0 theorem 5 let p transition system transition set weak strong fairness requirements wf sf infinite words w sigma w w 2 finsf iff w stronglybounded proof consider weak fairness set weaklykbounded schedules fixed k defined formula wf stands disjunction takenenabled follows set weaklyk bounded schedules safe regular k 0 thus every weaklybounded schedule consider regular safety property g contained wf suppose g accepted buchi automaton mg alphabet sigma without loss generality assume every state mg reachable initial state every path mg accepting path suffices prove mg k states every schedule g weaklykbounded suppose let us say symbol sigma weaklyunfair transition contains enabled contain taken assumption word w accepted mg transition w contains k consecutive symbols weaklyunfair since mg states follows cycle mg whose edges labeled symbols weaklyunfair implies mg accepts schedule weaklyfair contradiction inclusion g wf observe example program p 0 section 2 rg propositions enabledl true every state fairness requirement f1 equals wf sf implies corollary 6 p transition system least two transitions finwf finsf neither regular safe computation q transition system p fair respect fairness requirement f write pi f p set fair computations p specification phi transition system p set infinite words alphabet q transition system p satisfies specification phi fairness requirement f iff pi f p phi prove p satisfies phi fairness assumption f p satisfies phi implementations f prove p satisfies phi finitary restriction finf p satisfies phi finitestate implementations f section 4 show proving latter conceptually simpler proving former 34 timed transition systems timing finitary fairness standard models realtime systems place lower upper time bounds duration delays hmp94 mmt91 since exact values time bounds often known priori desirable design programs work possible choices time bounds long realized timingbased model unknown delays different often appropriate asynchronous model standard fairness dls88 aat97 rw92 show unknowndelay model equivalent asynchronous model finitary fairness realtime programs modeled timed transition systems hmp94 timed transition system p u consists transition system two functions u set transitions set q0 positive rational numbers function associates transition lower bound 0 function u associates upper bound u interleaving semantics transition systems extended timed transition systems labeling every state computation realvalued time stamp time sequence infinite nondecreasing unbounded sequence real numbers consistent given computation q underlying transition system p require transition enabled continuously least time taken must stay enabled continuously longer time u without taken note transition enabled states q n n j taken states q n continuously enabled time sequence consistent computation q iff every transition 2 lower bound taken 2 q j steps taken 62 q upper bound enabled 2 q k steps k k j taken 62 q k steps k timed computation q timed transition system p u consists computation q p together consistent time sequence first component timed computation p u untimed computation p u write pi u p set untimed computations p u general pi u p strict subset pip timing information u plays role fairness namely role restricting admissible interleavings enabled transitions q finite like pip pi u p also regular ad94 necessarily safe timed computations required checking system satisfies specification refers time untimed computations suffice checking system satisfies untimed specification phi timed transition system p u satisfies specification phi iff pi u p unknowndelay model know bound functions u rather wish prove transition system p satisfies specification phi possible choices bound functions wish prove union u pi u p contained phi following theorem shows order verify system unknowndelay model suffices verify system finitary weak fairness union u pi u p set pi finwf p theorem 7 let p transition system set transitions let wf weak fairness requirement p let q computation p q 2 pi finwf p iff function u q0 q 2 pi u p proof consider weaklybounded computation q 2 pi finwf p theorem 5 nonnegative integer k schedule corresponding q weaklykbounded let bound functions defined consider time sequence increases 1 every step clear lower bound requirement trivially satisfied since q weaklykbounded transition enabled k consecutive steps hence k taken thus consistency requirements satisfied q timed computation p u implying prove converse suppose q 2 pi u p choice u let time sequence q timed computation p u let nonzero minimum lower bounds u finite maximum upper bounds u let number transitions n let k integer k nu claim schedule corresponding q weaklykbounded suppose transition 0 enabled taken states q every step q taken 0 holds transition 0 since k nu follows transition 0 taken 0 holds u distinct states q q ik since 0 assumption satisfies lower bound requirement implies violates upper bound requirement consistency contradiction conclusion q weaklykbounded hence q 2 pi finwf p point lower bounds although arbitrarily small nonzero upper bounds finite necessary justified universally quantify choices bound functions also point reasoning timingbased model specific bound functions ie reasoning timed computationscan significantly complicated untimed reasoning hmp94 analysis shows therefore verification specifications refer time conceptually simpler unknowndelay model knowndelay model 35 gap finitary standard fairness definition finitary fairness replaces given language pi union regular safety properties contained pi definition seems satisfactory practice obvious mathematical generalizations first observe uncountable union safety properties contained pi pi safety properties however definable programs obtain computable restriction compi pi taking countable union recursive safety properties contained pi language recursive iff language turing machine clearly compi captures possible implementations pi finitestate typically falls strictly finpi pi computable fairness however two advantages finitary fairness namely simpler verification rules solvable consensus problem also alternatives finpi compi capture implementations pi limited computing power recall sample program p 0 section 2 every schedule finpi bound unknown fixed long transition postponed suppose let bound vary call schedule linearly bounded iff bound allowed increase linearly time every bounded schedule linearly bounded schedule linearly bounded bounded general given function fn natural numbers schedule w ofbounded iff exists constant k two transitions l r appears least subsequence w n w finitary fairness o1fairness moreover fairness requirement f obtain strict hierarchy stronger fairness requirements ff ff union ofbounded schedulers contained f algorithm presented section 5 modified solves distributed consensus fairness requirement ff fixed computable choice f 4 application program verification consider problem verifying program satisfies specification finitary fairness assumption 41 model checking program variables range finite domains set program states finite problem verifying finitestate program satisfies temporallogic specification called model checking automated tools model checking successfully used check correctness digital hardware communication protocols ck96 examine effects finitary fairness algorithms underlie tools untimed systems consider finitestate transition system p state set q set pip computations p regular safety property since q finite choose scheduling alphabet q let f q regular fairness requirement let phi q regular specification given say ptl formula buchi automaton verification question problem language inclusion p satisfies phi f iff pip problem solved algorithmically involved languages regular assuming finitary fairness need check language inclusion pip however obvious check finf necessarily regular corollary 6 following theorem shows finitestate verification finitary fairness reduced verification standard fairness theorem 8 regular languages pi 1 pi 2 proof finpi suppose pi 1 pi 2 nonempty since pi 1 pi 2 regular contains word w language containing single word w safe regular contained pi 1 hence w 2 finpi 1 also finpi 1 implying finpi 1 nonempty corollary obtain model checking finitary fairness continue use algorithms developed deal standard fairness corollary 9 finitestate program p set q states regular fairness requirement regular specification phi fairness assumption f iff satisfies phi fairness assumption finf proof want show let g language pip assumption p finitestate pip regular since phi also regular g pip empty theorem timed systems consider finitestate timed transition system p u set q states suppose specification refer time given regular specification phi q verify p u satisfies phi want check inclusion pi u p problem solved constructing buchi automaton recognizes language pi u p ad94 method applicable bound functions u fully specified parametric verification problem bound maps fully specified ahv93 bounds viewed parameters values parameters known required satisfy certain linear constraints 1 parametric verification problem specified 1 finitestate transition system 2 regular specification phi 3 set lu consisting pairs u functions q0 verification problem check every choice u 2 lu resulting timed transition system p u satisfies specification phi define u2lu pi u p want check pi lu p theorem 8 together theorem 7 implies parametric verification problem decidable set lu consists function pairs p finitestate transition system phi regular parametric verification problem checking inclusion pi lu p phi decidable parametric verification problem general undecidable class lu constrains allowed choices bound maps ahv93 instance lu requires parametric verification problem undecidable 42 proof rules termination turn verification programs finitestate since safety specifications proved independent fairness assumptions need concerned liveness specifications limit proving termination programs equivalently proving specifications form 3 p state predicate p finitary weak fairness straightforward extend proposed method verification arbitrary temporallogic specifications finitary versions weak strong fairness total termination versus termination system standard method proving termination sequential deterministic programs adopted prove computations nondeter ministic transition system p terminate called total termination p essentially need identify wellfounded domain w oe ranking variant function program states w rank decreases every program transition example consider rule lps82 rule proving total termination find ranking function ae q wellfounded domain w oe state predicate t2 states q q figure rule complete proving total termination computations transition system p terminate iff rule applicable lps82 furthermore always sufficient choose set n natural numbers wellfounded domain w consider requirement weaklyfair computations p terminate called termination p rule obviously sound proving termination complete problem may ranking function decreases every program transition standard solution identify ranking function never increases guaranteed decrease eventually decrease caused socalled helpful transitions whose occurrence ensured weakfairness requirement example consider rule j lps82 rule j proving termination find ranking function ae q wellfounded domain w oe set r state predicates one transition 2 let r union r 2 show states q q 0 2 q transitions transition enabled q enabled q rule j complete proving termination weaklyfair computations transition system p terminate iff rule j applicable completeness however longer holds require wellfounded domain set n natural numbers transition systems transfinite induction ordinals higher needed prove termination example present method proving termination finitary fair computations let us consider example consider transition system p 1 figure 1 state program p 1 given values two variables location variable ranges f0 1g data variable x nonnegative integer initially four transitions e 1 shown figure want prove weaklyfair computations p 1 terminate initially transitions e 1 e 2 continuously enabled fairness e 2 ensures eventually e 4 enabled long x positive decrements x time fairness e 4 ensures figure 2 transformed program finp 1 eventually resulting termination prove termination formally apply rule j wellfounded domain choose set nfg natural numbers together ordinal choose r e 1 r e 3 empty sets state x belongs r e 2 belongs r e 4 1 ranking function defined ae0 x transitions e 1 e 3 leave rank unchanged e 2 e 4 cause decrease reader check five premises j1j5 rule j indeed satisfied notice bound number steps p 1 terminates unbounded nondeterminism makes mathematical treatment fairness difficult proving termination p 1 finitary weak fairnessthat proving finitary termination p 1 conceptually simpler recall every computation finwf integer k transition cannot enabled continuously k steps without taken theorem 5 follows finitary weak fairness p 1 must terminate within bounded number steps bound depends unknown constant k capture intuition transform program p 1 introducing two auxiliary variables b c initial value variable b unspecified nonnegative integer program transitions change value integer variable c used ensure transition enabled b steps without taken thus obtain new program finp 1 figure 2 original program p 1 terminates finitary weak fairness assumption finwf iff computations transformed program finp 1 terminate thus reduced problem proving finitary termination p 1 problem proving total termination simple rule induction natural numbers sufficient prove finitary termination state finp 1 tuple x c b apply rule choose set r set reachable states 0 x c b 2 r iff b ranking function mapping r natural numbers defined ae0 c reader check every transition applied state r causes ranking function decrease notice transformed program finp 1 infinitely many initial states given initial state terminates within bounded number steps consequently finp 1 suffer problems caused unbounded nondeterminism tradeoff proving termination p 1 total termination finp 1 clear rule j used former complex rule used latter program finp 1 complex finitary transformation program let us consider general transformation given transition system consist transitions finitary transformation finp transition system p obtained introducing new integer variable b transition new integer variable c thus state space finp q theta n m1 initial value b arbitrary initial value c 0 thus set initial states finp q 0 theta n theta f0g every transition 2 transition system finp contains transition fin 1 2 3 1 following theorem establishes transformation fin together simple rule sound complete proof method finitary termination theorem 11 transition system p terminates finitary weak fairness iff computations transition system finp terminate proof suppose program finp nonterminating computation q consider projection q 0 q statespace p transition rules finp clear q 0 also computation p value bound variable b stays unchanged throughout q let k furthermore c k invariant computation q 1 since transition c incremented time enabled taken follows computation q 0 weaklykbounded hence p weaklyfair nonterminating computation conversely consider weaklyfair nonterminating computation q p theorem 5 q weaklykbounded k define sequence q 0 statespace finp follows 0 q 0 j maximum nonnegative integer n transition j enabled taken states q n 0 easy check since q weaklykbounded transition j enabled taken state q c consequently q 0 nonterminating computation finp thus language pi finwf p finitary weakfair computations transition system p projection language pifinp transformed program finp known given transition system p fairness requirement f exists transition system p 0 requires uncountably many states transformed program p 0 one initial state every fair computation f yield proof principle wellfounded induction n adequate 5 application distributed consensus consider consensus problem sharedmemory model atomic operations allowed shared register read write formally consensus problem defined follows n processes boolean input value 2 f0 1g process decides value v 2 f0 1g executing statement decidev model failures introduce special transition fail process transition fail enabled shared registers initially 1 2 xr 3 yr 4 xr 5 else skip od 7 r r 8 fi 9 od 10 decideout figure 3 consensus assuming finitary weakfairness program process p input process p yet decided value p takes transition fail transitions disabled p stops participating solution consensus problem must satisfy agreementthat two processes decide conflicting valuesand validitythat process decides value v v equal input value process apart two safety requirements want nonfailing processes decide eventually waitfreedom asserts process p eventually either decides value fails thus process must prevent another process reaching decision algorithm must tolerate number process failures implicit fairness assumption asynchronous model weakfairness requirement wf program transitions except newly introduced fail transitions known even program satisfies three consensus requirements weakfairness assumption wf flp85 la87 hand consensus solved unknowndelay model assumed upper bound delta memoryaccess time bound unknown processes priori solution required work values delta aat97 show consensus algorithm aat97 unknowndelay model solves fact consensus finitary weakfairness requirement finwf algorithm shown figure 3 algorithm proceeds rounds uses following shared data structures infinite twodimensional array x 2 bits infinite array whose elements value 0 1 decision value ie value processes decide written shared bit initially value addition process p local register v contains current preference decision value local register r contains current round number processes round r preference v bit xr v never set 1 consequently processes decide value v round r furthermore process decides value v round r yr never set conflicting value v every process reaches round preference v round ensures agreement see aat97 details proofs easy check processes initial input v process ever decide v implying requirement validity possible two processes conflicting preferences round r cannot resolve conflict round r proceed round r conflicting preferences happens find yr first line 3 one proceeds chooses preference next round line 7 one finishes assignment yr finitary fairness requirement ensures behavior cannot repeated every round every finitarily fair computation bound k every process neither failed terminated takes step least every k steps round number exceeds unknown bound k process executing loop processes forced take least one step suffices ensure termination theorem 12 program figure 3 satisfies requirements agreement validity wait freedom finitary fairness assumption finwf contrast program satisfy waitfreedom standard fairness assumption wf also observe algorithm uses potentially unbounded space therefore finitestate program results section 4 imply algorithm uses fixed number bounded registers solves consensus finitary fairness theorem 13 two processes algorithm uses finite memory satisfies requirements agreement validity waitfreedom finitary fairness assumption finwf equivalently unknowndelay model unknowndelay model dls88 consists distributed processes communicating via messages delivery time message bounded known priori establish bounds number processfailures tolerated consensus protocol various fault models bounds established using finitary weakfairness similar observation applies results session problem unknowndelay model rw92 acknowledgments notions similar kbounded fairness fixed k defined several places jay88 notion bounded fairness seems part folklore know published account thank leslie lamport amir pnueli fred schneider gadi taubenfeld sam toueg pointers literature helpful discussions r theory timed automata safety without stuttering appraising fairness languages distributed programming parametric realtime reasoning defining liveness decision method restricted secondorder arithmetic consensus presence partial synchrony impossibility distributed consensus one faulty process temporal analysis fairness temporal proof methodologies timed transition systems communication synchronization parallel computation memory requirements agreement among unreliable asynchronous processes time constrained automata hierarchy temporal properties temporal logic reactive concurrent systems reaching agreement presence faults impact time session problem automata infinite objects verification concurrent programs automatatheoretic framework tr fairness safety without stuttering consensus presence partial synchrony hierarchy temporal properties invited paper 1989 automata infinite objects temporal logic reactive concurrent systems impact time session problem parametric realtime reasoning theory timed automata temporal proof methodologies timed transition systems impossibility distributed consensus one faulty process computeraided verification formal methods timeadaptive algorithms synchronization reaching agreement presence faults temporal analysis fairness impartiality justice fairness timeconstrained automata extended abstract design synthesis synchronization skeletons using branchingtime temporal logic communication synchronization parallel computation
tight bounds testing bipartiteness general graphs paper consider problem testing bipartiteness general graphs problem previously studied two models one suitable dense graphs one suitable boundeddegree graphs roughly speaking dense graphs tested bipartiteness constant complexity complexity testing boundeddegree graphs tildethetasqrtn n number vertices graph tildethetafn means thetafncdotrm polylogfn thus large gap complexity testing two casesin work bridge gap described particular study problem testing bipartiteness model suitable densities present algorithm whose complexity tildeominsqrtnn2m number edges graph match almost tight lower bound b introduction property testing algorithms 16 8 algorithms perform approximate decisions namely predetermined property p decide whether given object property p far property p order perform approximate decision given query access object property testing problems hence defined type objects question property tested type queries allowed notion distance property much focus property testing testing properties graphs context several models considered models fixed graph property p algorithm required accept graphs p reject graphs far p given distance parameter cases algorithm allowed constant probability failure models differ type queries allow notion distance use underlies definition far property complexity algorithm measured number queries object q performs 11 models testing graph properties first model introduced 8 adjacencymatrix model model algorithm may perform queries form edge vertices u v work part authors phd thesis prepared tel aviv university supervision prof noga alon prof michael krivelevich email krivelevposttauacil research supported israel science foundation grant number graph algorithm may probe adjacency matrix representing graph refer queries vertexpair queries notion distance also linked representation graph said far property p modifications performed graph obtains property n number vertices graph words measures fraction entries adjacency matrix graph modified model suitable dense graphs number edges n 2 model studied 8 3 2 1 4 11 7 second model introduced 9 boundeddegree incidencelists model model algorithm may perform queries form ith neighbor vertex v graph algorithm may probe incidence lists vertices graph assumed vertices degree fixed degreebound refer queries neighbor queries notion distance linked representation graph said far property p dn edge modifications performed graph obtains property case measures fraction entries incidence lists representation among dn entries modified model suitable graphs whose maximum degree order average degree particular true sparse graphs constant degree model studied 10 9 6 15 suggested decouple questions representation type queries allowed definition distance property specifically suggested measure distance simply respect number edges denoted graph namely graph said far property modifications performed obtains property 15 algorithm allowed type queries boundeddegree incidencelists model fixed upperbound assumed degrees algorithm could query degree vertex main advantage model boundeddegree incidencelists model suitable graphs whose degrees may vary significantly model studied paper work interested model may useful testing types graphs dense sparse graphs lie inbetween two extremes discussed detail next subsection two extremes sometimes exhibit different behavior terms complexity testing property interested understanding transformation testing sparse particular boundeddegree graphs testing dense graphs recall model testing graph properties defined distance measure used queries allowed model 15 indeed suitable graphs terms distance measure used since distance measured respect actual number edges graph 1 thus notion distance adapts density graph shall use work assume simplicity number vertices n number edges given testing algorithm known exactly algorithm work using upper bounds values tightness bounds naturally affect performance algorithm focus 15 testing properties interest sparse necessarily boundeddegree graphs hence allowed neighbor queries however consider case graph sparse necessarily dense particular suppose graph n 15 edges seeking algorithm performs n queries case sparse graphs use asking vertexpair queries ie edge particular pair vertices queries may become helpful number edges sufficiently large hence allow algorithms perform neighbor queries vertexpair queries 12 testing bipartiteness one properties received quite bit attention context property testing bipartiteness recall graph bipartite possible partition vertices two parts edges endpoints part property first studied 8 shown bipartiteness testing simple algorithm using queries improved 3 queries best lower bound known model 1 15 due 7 thus complexity problem independent number vertices n polynomial 1 complexity testing bipartiteness changes significantly considering boundeddegree incidencelists model 10 lower bound n established model constant degree bound almost matching upper bound poly1 shown 9 thus case bipartiteness large gap results obtained dense graphs constantdegree graphs venture land graphs neither necessarily sparse necessarily dense study complexity testing bipartiteness graph properties exhibit similar sometimes even larger gaps hence believe understanding transformation sparse dense graphs general interest 13 results work present two complementary results nvertex graphs edges describe analyze algorithm testing bipartiteness general graphs whose query complexity running time omin algorithm onesided error ie always accepts bipartite graphs whenever rejects graph provides evidence graph bipartite form oddlength cycle length polylog n present almost matching lower bound constant bound holds testing algorithms allowed twosided error adaptive furthermore bound holds regular graphs seen expressions long average degree n complexity testing n number edges goes 15 start seeing decrease query complexity case 2 polylog n terms algorithm exactly point algorithm starts exploiting access vertexpair queries lower bound shows behavior query complexity artifact algorithm inherent problem note even graph sparse obtain new result follow 9 namely algorithm complexity graphs varying degrees 14 techniques present algorithm two stages first describe algorithm works almostregular graphs graphs maximum degree order average degree algorithm analysis closely follow algorithm analysis 9 indeed long degree graph p n execute 9 algorithm place depart 9 usage vertexpair queries n refer first algorithm testbipartitereg second stage show reduce problem testing bipartiteness general graphs bipartiteness almostregular graphs namely show every given graph g possible define graph g 0 1 g 0 roughly number vertices edges g maximum degree order average degree roughly average degree g 2 g bipartite g 0 g far bipartite g 0 show emulate execution algorithm testbipartitereg g 0 given query access g may accept g accepts g 0 reject g rejects g 0 course emulation confronted following interesting problem would like sample vertices g according degrees aids us sampling vertices uniformly g 0 basic operation required test bipartitereg former equivalent sampling edges uniformly g order harm performance testing algorithm required perform task omin queries sufficiently large n 15 performed simply sampling sufficiently many pairs vertices g however know perform task exactly efficient manner number edges significantly smaller n 15 nonetheless provide sampling procedure selects edges according distribution approximates desired uniform distribution edges sufficient purposes approximation small fraction edges probability selecting edge 1m procedure may independent interest also conjecture variants construction g 0 particular probabilistic construction suggest long version paper 12 may useful transforming results hold graphs whose maximum degree similar average degree results hold graphs varying degrees establish lower bound describing every pair n n even 64 two distributions dregular graphs one distribution graphs bipartite construction distribution prove almost graphs far bipartite show every testing algorithm distinguish graph chosen randomly first distribution accept probability least 23 graph chosen randomly second distribution reject probability least 23 must perform queries lower bound proof show necessity neigbhor queries vertexpair queries specifically using one type queries lower bound increases research noted previously problems exhibit significant gap query complexity testing dense graphs adjacencymatrix model complexity testing sparse boundeddegree graphs boundeddegree incidence lists model particular true testing kcolorability possible test dense graphs kcolorability using polyk queries 8 3 testing sparse graphs requires queries 6 stress bounds query complexity put time complexity aside would like understand transformation essentially constant complexity constant k linear complexity would like know whether intermediate results obtained graphs neither sparse dense problems interest testing whether graph relatively large clique 8 testing acyclicity directed graphs 5 testing graph contain certain subgraph 1 preliminaries e undirected graph n vertices labeled jegj total number edges g unless stated otherwise assume g contains multiple edges vertex set neighbors let degree edges incident v endpoints neighbors v labelled 1 degv note edge two possibly different labels one respect endpoints hence view edges quadruples edge v u ith edge incident v jth edge incident u edge denoted want distinguish quadruple u v pair u v refer latter edgepair let denote maximum degree graph g avg avg g denote average degree graph avg distance property consider fixed graph property p given graph g let e p g minimum number edges added g removed g obtain property p distance g property p defined e p gmg particular say graph g far property p given distance parameter 0 1 e p g mg otherwise close property p cases may define distance property respect upper bound mmax mg number edges graph distance property p defined e p gmmax example graph dense mg set alternatively graph bounded degree set latter case could set simplicity set slightly higher upper bound e p gmmax shall say graph far property p respect mmax testing algorithms testing algorithm graph property p required accept probability least 23 every graph property p reject probability least 23 every graph far property p given distance parameter algorithm always accepts graphs property onesided error algorithm testing algorithm given number vertices graph number edges graph upper bound number provided query access graph specifically allow algorithm following types queries first type queries degree queries vertex u choice algorithm obtain degu assume degree query cost one fact easily implemented using neighbor queries cost olog dmax olog n second type queries neighbor queries namely every vertex u index 1 degu algorithm may obtain ith neighbor vertex u third type queries vertexpair queries namely pair vertices u v algorithm query whether edge u v g bipartiteness work focus property bipartiteness let partition v say edge u v 2 e violating edge respect belong subset v b b 2 f1 2g graph bipartite exists partition vertices respect violating edges definition graph far bipartite every partition vertices number violating edges respect partition greater recall graph bipartite contains oddlength cycles 3 algorithm almostregular case section describe algorithm accepts every bipartite graph rejects probability least 23 every graph far bipartite respect upper bound number edges namely algorithm rejects probability least 23 graphs number edges need removed become bipartite greater query complexity running time algorithm omin polylog n case graph almostregular maximum degree graph dmax order average degree avg essentially obtain tester desired since case max om however general dmax may much larger avg example possible 1 deal general case show next section section 4 reduce problem general case special case high level description algorithm throughout section let algorithm builds testing algorithm bipartiteness described 9 whose query complexity n polylog n works respect dn well fact long algorithm equivalent algorithm 9 particular 9 algorithm selects 1 starting vertices performs several random walks using neighbor queries walk length polylog n n number walks npolylog n algorithm simply checks whether oddlength cycle detected course random walks possibly relying information one random walk find odd cycle n two important modifications 1 number random walks performed vertex reduced ndpolylog n 2 pair end vertices reached walks parity algorithm performs vertexpair query similarly n case graph rejected oddlength cycle found subgraph induced queries performed pseudocode algorithm shown figure 1 random walks paths graph random walks performed defined follows step degree current vertex v 0 walk remains v probability 1 0 2 u 2 v walk traverses 2d important property random walk stationary distribution induces vertices uniform every walk generally sequence steps corresponds path graph path determined steps edge traversed ignoring steps walk stays vertex path necessarily simple contain self loops note referring length walk mean total number steps taken including steps walk remains current vertex length corresponding path include steps times 1 uniformly select v 2 oddcycles returns found output reject case call oddcycle returned found output accept 1 n let k log 12 n nd l log 6 n 2 perform k random walks starting length l 3 let a0 a1 set vertices appear ends k walks whose paths even odd length 4 check whether a0 a1 6 intersection nonempty return found otherwise return notfound 5 else n perform vertexpair queries every pair vertices edge detected return found otherwise return notfound fig 1 algorithm testbipartitereg testing bipartiteness respect upper bound number edges procedure oddcycle detecting oddlength cycles graph g theorem 1 algorithm testbipartitereg accepts every graph bipartite rejects probability least 23 every graph far bipartite respect furthermore whenever algorithm rejects graph outputs certificate nonbipartiteness graph form oddlength cycle length polylog n query complexity running time algorithm min note algorithm work g contains selfloops multipleedges latter importance next section corollary become useful next section well corollary 2 g far bipartite respect fraction vertices oddcycles returns found probability least 2since proof theorem 1 similar structure proof given 9 omit extended abstract details proof well proofs found full version paper 12 4 algorithm general case section build testing algorithm presented previous section show onesided error bipartite testing algorithm works respect actual number edges mg hence algorithm suitable general graphs dmax may vary significantly avg query complexity running time algorithm order magnitude testbipartitereg omin note graph becomes dense c approximately 4 preferable use adjacencymatrix model algorithm 8 3 distance parameter n 2 high level description algorithm basic idea reduce problem testing respect actual number edges problem testing respect upper bound specifically graph g show define graph g 0 n vertices following useful properties first maximum degree g 0 roughly average degree furthermore degree roughly average degree g particular implies two graphs roughly number edges second g 0 approximately preserves distance g bipartiteness precisely g bipartite g 0 g far bipartite respect mg g 0 far bipartite respect viewed kind regularized degree version g direct access g 0 would done running algorithm testbipartitereg g 0 could decide whether g bipartite far bipartite however access g nonetheless given query access g efficiently emulate queries g 0 would almost suffice running test bipartitereg g 0 one issue uniform selection starting vertices g 0 required testbipartitereg shall see selecting vertex uniformly g 0 roughly equivalent uniformly selecting edge g shall approximate latter process follows assume n 0 multiple edges actually deal case multiple edges constitute constant fraction total number edges main theorem subsection follows theorem 3 every graph g n vertices n edges define graph g 0 n 0 vertices 0 edges following holds 1 2 g bipartite g 0 bipartite g far bipartite respect g 0 0 far bipartite respect mmax g 3 given starting vertices g 0 possible emulate random walks g 0 starting performing queries g amortized cost random walk step olog 2 n degree neighbor queries g emulating random walks possible execute slight variant oddcycles g 0 denote oddcycles variant proddcyclesfound proddcyclesfound oddcycles returns found obtain oddlength cycle length polylog n original graph g 4 exists procedure sampleverticesalmostuniformlying given parameter 0 1 performs omin queries g returns vertex g 0 following holds n 0 vertices x g 0 probability x selected procedure note every graph g actually family graphs g 0 properties defined set vertices run algorithm test bipartitegen construct one arbitrary graph g 0 family go along corollary theorem 3 corollary 2 obtain corollary 4 algorithm testbipartitegen see figure 2 accepts every graph g bipartite rejects probability least 23 every graph g far bipartite respect mg furthermore whenever algorithm rejects graph outputs certificate nonbipartiteness graph g form oddlength cycle length polylog n query complexity running time algorithm min times 1 set 2 select vertex g 0 calling procedure sampleverticesalmostuniformlyin g c sufficiently large constant 3 apply oddcycles 4 oddcycles returns found output reject case call oddcycle returned found output accept fig 2 algorithm testbipartitegen testing bipartiteness respect actual number edges graph g 41 defining g 0 proving first item theorem 3 follows let shall assume sufficiently large constant avg g sufficiently large still set construction sufficiently large run algorithm set dd avg g construction g 0 vertex v g degv single vertex g 0 vertex v g degv g 0 subgraph denoted hv bipartite graph two subsets vertices one denoted xv external part one denoted iv internal part parts consist ddegvde vertices every vertex xv represents specific neighbors v according fixed arbitrary partition neighbors v refer vertices two subsets fx vg ddegvde fi vg ddegvde respectively edges hv determined follows case degvd dd 2 degve multiple edges every internal vertex every external vertex hv case degvd denote let hv bipartite expander sides vertices vertex hv degree eigenvalues adjacency matrix h largest one smallest one equal respectively d4 absolute values explicit constructions expanders found eg 14 13 furthermore constructions allow determination ith neighbor given vertex constant time described vertices g transformed vertices g 0 remains describe relevant transformation edges g consider edge ith neighbor u u jth neighbor v let x k u x v external vertices representing ith neighbor u jth neighbor v respectively edge x k u x v g 0 directly follows every vertex g 0 degree 2d long version paper 12 suggest following alternative probabilistic construction g 0 establishes theorem 3 every vertex g transformed ddegvde vertices denote xv vertices g 0 related vertex g vertices xv denoted x v 1 ddegvde thus v2g degv e 2n edges g 0 determined follows edge u v 2 eg chooses independently uniformly random vertex xv vertex xu g 0 edge two randomly chosen vertices clearly probabilistic construction simpler robust deterministic one may applicable problems well however construction need 1 42 establishing items 2 3 theorem 3 proofs two items ommitted extended abstract found 12 note item 2 builds expander graphs defined construction g 0 43 establishing item 4 theorem 3 subsection provide sketch proof last item theorem 3 consider construction g 0 sampling vertex uniformly random g 0 equivalent sampling vertex v g probability proportional degree taking randomly uniformly one vertices belong hv latter equivalent sampling randomly uniformly edge g taking one endpoints random thus proof item based presentation procedure sampling edges almost uniformly g consider two cases n n recall avg g average degree g goal use omin queries g first case easy since g contains sufficiently many edges simply sample vertices order obtain edge second case g contains fewer edges n algorithm selects edge uniformly g using relatively queries however show following lemma item 4 theorem 3 derived proof lemma found 12 exists procedure sampleedgesalmostuniformlying uses n degree neighbor queries g following holds 4m edges e g probability procedure outputs e least 164m furthermore exists subset u 0 v g ju 0 j n2 edges output probability less 164m 5 lower bound section present lower bound number queries necessary testing bipartiteness similarly lower bound presented 9 lower bound holds testing algorithms allowed twosided error graphs used lower bound construction regular graphs however lower bound n constant established 9 holds graphs constant degree eg degree 3 algorithm allowed neighbor queries lower bound general allows algorithm perform neighbor queries vertexpair queries applicable graphs theorem 5 every algorithm testing bipartiteness distance parameter 2 4 must perform queries highlevel structure proof similar lowerbound proofs test ing traced back 17 present two distributions graphs graphs generated one distribution bipratite hence accepted high probability graph generated according distribution far bipartite show algorithm query complexity lower bound cannot distinguish two distributions hence must large failure probability specifically distributions denoted gn gn2 n2 dregular graphs n vertices assume simplicity n even graph generated according gn obtained selecting uniformly indepen dently perfect matchings n vertices graph generated according gn2 n2 obtained first randomly partitioning n vertices two equal parts selecting uniformly independently perfect matchings two parts definition graphs support gn2 n2 bipartite prove graphs generated according gn far bipartite high probability 116 64 show following two claims hold graph generated either according gn according gn2 n2 1 algorithm asks queries detect edge vertexpair query high probability 2 algorithm asks n queries receive answer neighbor query vertex already observed previous query high probability well conclude algorithm asks omin queries cannot distinguish two distributions desired lower bound proof show necessity neigbhor queries vertexpair queries specifically using one type queries lower bound increases r testing subgraphs large graphs efficient testing large graphs testing kcolorability testing subgraph directed graphs testing properties directed graphs acyclicity connectivity lower bound testing 3colorability boundeddegree graphs lower bounds testing bipartiteness dense graphs property testing connection learning approximation sublinear bipartite tester bounded degree graphs property testing bounded degree graphs three theorems regarding testing graph properties tight bounds testing bipartiteness general graphs explicit expanders ramanujan conjectures explicit constructions expanders testing diameter graphs robust characterization polynomials applications program testing probabilistic computation tr ctr alon tali kaufman michael krivelevich dana ron testing trianglefreeness general graphs proceedings seventeenth annual acmsiam symposium discrete algorithm p279288 january 2226 2006 miami florida
greedy local search heuristics unconstrained binary quadratic programming paper greedy heuristic two local search algorithms 1opt local search kopt local search proposed unconstrained binary quadratic programming problem bqp heuristics well suited incorporation metaheuristics evolutionary algorithms performance compared 115 problem instances methods capable producing high quality solutions short time particular greedy heuristic able find near optimum solutions percent bestknown solutions local search procedures sufficient find bestknown solutions problem instances n 100 kopt local searches even find bestknown solutions problems size n 250 11 15 instances size n equals 500 runs larger problems n equals 500 1000 2500 heuristics appear capable finding near optimum solutions quickly therefore proposed heuristicsespecially kopt local searchoffer great potential incorporation sophisticated metaheuristics b given binary vector length n searched quantity maximized problem also known unconstrained quadratic bivalent programming problem unconstrained quadratic zeroone programming problem uncon strained quadratic pseudo boolean programming problem beasley 1998 bqp known nphard garey johnson 1979 large number applications example capital budgeting nancial analysis problems laughunn 1970 mcbride yormark 1980 cad problems krarup pruzan 1978 trac message management problems gallo et al 1980 machine scheduling alidaee et al 1994 molecular conformation phillips rosen 1994 furthermore several combinatorial optimization problems formulated bqp maximum cut problem maximum clique problem maximum vertex packing problem maximum independent set problem ivanescu 1965 pardalos rodgers 1992 pardalos xue 1994 several exact methods developed solve bqp pardalos rodgers 1990 barahona et al 1989 billionnet sutter 1994 helmberg rendl 1998 due computational complexity problem heuristics proposed recently nd solutions large problem instances including tabu search beasley 1998 glover et al 1998b glover et al 1998a scatter search amini et al 1999 simulated annealing beasley 1998 katayama narihisa 1999 evolutionary algorithms lodi et al 1998 merz freisleben 1999b paper greedy heuristic two local search algorithms unconstrained binary quadratic programming problem bqp presented greedy heuristic constructs feasible solution n steps n denotes problem size ie number elements solution step greedy heuristic selects element value making favorable choice additionally randomized greedy heuristic described random components added deterministic greedy heuristic local search heuristics iteratively search better solution neighborhood current solution better solution exists thus local optimum reached neighborhood rst local search algorithm 1opt local search dened solutions reached changing single element current solution second local search kopt local search k elements solution changed simultaneously due computational complexity small fraction kopt neighborhood searched local search procedure algorithms tested set 115 problem instances bqp experiments show local search heuristics able nd optimum bestknown solutions instances problem size 100 easily multistart kopt local search capable nding bestknown solutions runs problem instances studied problem size less equal 250 11 15 instances size 500 larger instances algorithms shown nd near optimum solutions 10 60 seconds stateoftheart workstation cases multistart randomized greedy heuristic multistart 1opt local search multistart kopt local search nd solutions within 1 05 01 bestknown solution respectively paper organized follows section 1 bqp described detail section 2 describes greedy local search heuristics bqp results obtained various experiments conducted algorithms discussed section 3 section 4 concludes paper outlines areas future research 1 binary quadratic programming problem throughout paper solution vector x bqp boolean vector length n thus solution space x bqp size 2 n grows exponentially n density matrix q sometimes used characterize bqp instance density densq dened number nonzero entries divided number total entries matrix q thus density varies 0 1 demonstrate relevance various scenarios special cases generalization bqp described following 11 special cases bqp bqp shown generalization combinatorial optimization problems example maximum clique problem maximum independent set problem special cases bqp let e undirected graph e complement graph g eg furthermore let adjacency matrix g denote identity matrix g maximum clique problem min x solves equation 2 maximum clique g dened similarly maximum independent set problem min x solves equation 3 maximum independent set g dened maximum cut problem objective function maximized w ij denotes weight edge graph maximum cut desired maximum cut problem formulated 01 quadratic programming problem assigning maximum cut size cx equal objective fx corresponding bqp cut 1g another application bqp arises condensed matter physics calculation ground states ising spin glasses combinatorial optimization problem conguration spins minimum energy searched energy ising spin glass spins lie two dimensional grid given hamiltonian denotes interaction site j grid setting solution bqp yields conguration minimum energy 12 generalization bqp close relation binary quadratic programming nklandscapes dened kauman kauman levin 1987 model gene interaction genetic evolution relation shown following objective function bqp decomposed functions tness bqp solution thus rewritten sum functions site called tness contributions f component bit vector similar nklandscapes dened kauman levin 1987 tness contribution f site depends gene value x ki genes x nklandscapes constant bqp ki dened number nonzero entries ith column matrix q mean k ki given densq bqp viewed special class nklandscapes special tness contribution function f alternatively nk landscapes seen family general binary programming problems heuristics bqp heuristics divided construction heuristics improvement heuristics former construct feasible solutions given optimization problem scratch latter take feasible solution input try nd better solutions stepwise transformations types heuristics implemented eciently often capable producing near optimum solutions combinatorial optimization problems however results obtained sucient algorithms combined incorporated metaheuristics memetic algorithms moscato 1989 example shown merz freisleben 2000 graph bipartitioning problem dierential greedy heuristic battiti bertossi 1998 combined kernighanlin local search kernighan lin 1972 shown sucient structured problems small medium sizes larger problems solved problems unstructured memetic algorithm genetic algorithm incorporating local search greedy heuristic shown eective since greedy local search heuristics important components algorithms combinatorial optimization problems corresponding approaches bqp desired thus greedy local search algorithms bqp described following best knowledge proposals rst algorithms kind bqp 21 greedy heuristics greedy algorithms intuitive heuristics greedy choices made achieve certain goal combinatorial optimization solution given problem searched maximizes minimizes objective function greedy heuristics constructive heuristics since construct feasible solutions optimization problems scratch making favorable choice step construction adding element partial solution promises deliver highest gain heuristic acts greedy constructor 211 simple greedy algorithm bqp solution constructed assigning binary value element solution vector x zero one general outline greedy algorithm provided figure 1 step heuristic searches element k solution vector value l procedure greedyx 2 x x begin repeat nd k l g l return x figure 1 greedy heuristic bqp assign gain function g l k maximized afterwards value l assigned vector component x k nd appropriate gain function modify problem adding third state let vector component three values 0 1 1 starting vector greedy heuristic viewed transformation algorithm transforms vector x x 2 f0 1g thus x 2 x objective solution let vector equal 2 except component k hence gain changing k 05 0 denoted g 0 k dened using formula greedy heuristic displayed figure 1 runtime complexity 3 since calculation g takes 2 done n times algorithm terminates thus greedy heuristic expected running time equal algorithm calculates objective function fx n solutions however greedy algorithm implemented eciently matrix q stored two dimensional array instead ng list js q ij 6 0 maintained running time reduced considerably instances low density reduce running time nding choice highest gain following formula used calculate new gain g k set 0 1 1q ik q ik otherwise g 0 1q ik thus gains g calculated eciently updated component k set since gains g change q ik 6 0 running time updating gains complexity gure 2 pseudo code fast greedy heuristic provided running time improved heuristic 2 since running time nding maximum gain g 0 k g 1 k performed n times construct feasible solution thus greedy heuristic computational complexity algorithm calculating fx single solution running time behavior greedy heuristic improved even additional data structures used nd maximum gain shorter time however uence computational complexity algorithm since time initial calculation gains dominates times greedy choices procedure greedyx 2 x x begin n x calculate gains g repeat nd k 0 g 0 nd else endif update gains g 2 c return x figure 2 greedy heuristic bqp 212 randomized greedy algorithm greedy heuristic described deterministic since always produces solution given problem instance often desired construction heuristic produces many dierent solutions example hybrid algorithms procedure randomized follows making rst choice randomly ie selecting k l randomly setting x rst step random component incorporated furthermore deterministic choice among x k 0 x k 1 replaced random choice proportional gains g 0 set 0 probability g 0 x k 1 set 1 probability pseudo code randomized greedy heuristic provided figure 3 22 local search local search ls algorithms improvement heuristics search neighborhood current solution better one improvement made ie better solution neighborhood current solution local search algorithms categorized neighborhoods consider example neighborhood solution represented binary vector dened solutions obtained ipping single multiple components binary vector simultaneously procedure begin n x calculate gains g select k l randomly set x k l repeat nd k 0 g 0 nd set randomnumber01 p else endif update gains g 2 c return x figure 3 randomized greedy heuristic bqp 221 1opt local search simplest form local search bqp 1opt local search step new solution higher tness neighborhood current solution searched neighborhood current solution dened set solutions reached ipping single bit hence 1opt neighborhood contains solutions hamming distance 1 current solution implementation search solution highest tness ie search ip highest associated gain tness new f old gain g k ipping bit k current solution calculated linear time using local search algorithm given pseudo code fig 4 straightforward implementation 1opt local search displayed gure running time 2 per iteration procedure begin repeat nd k return x figure 4 1opt local search analogous greedy heuristic eciency algorithm increased considerably gains g recalculated time instead sucient calculate dierence gains g assuming g bqp solution calculated bit k ipped new gains g 0 calculated eciently formula thus update gains performed linear time property also used glover et al 1998a speed tabu search bqp furthermore gains updated fast 1opt local search displayed figure 5 procedure begin calculate gains g repeat nd k update gains endif return x figure 5 fast 1opt local search bqp running time algorithm per iteration initialization gains 2 222 kopt local search kopt neighborhood n k opt binary vector length n dened binary vectors reached ipping one k bits vectors simultaneously hence neighborhood n k opt denotes hamming distance bit vectors grows exponentially k jn k opt since computationally expensive search complete kopt neighborhood lin kernighan proposed heuristics traveling salesman problem tsp graph partitioning problem eciently search small fraction kopt neighborhood algorithms known linkernighan algorithm tsp lin kernighan 1973 kernighanlin algorithm graph partitioning kernighan lin 1972 belong best available heuristics two combinatorial optimization problems following local search algorithm bqp presented based ideas lin kernighan basic idea heuristic nd solution ipping variable number k bits solution vector per iteration step sequence n solutions generated ipping bit highest associated gain analogous 1opt local search procedure vector gains maintained updated according equation 15 ip furthermore candidate set used assure bit ipped exactly best solution sequence accepted new solution next iteration thus iteration algorithm variable number bits ipped nd new solution neighborhood current solution pseudo code kopt local search presented figure 6 runtime complexity initialization 2 running time per iteration also complexity 2 reduce running time termination condition inner repeatloop modied loop terminated new x best iterations thus resulting fast kopt procedure shorter running time n kopt procedure described performance evaluation evaluate performance algorithms conducted several experiments 105 problem instances contained orlib beasley 1990 sets glova glovb glovc glovd contain instances type described glover et al 1998b set glov200 glov500 consists problem instances size denoted type e f glover et al 1998b six sets described beasley 1998 density procedure begin calculate gains g repeat repeat nd j g x best x endif update gains g x x best else endif return x figure bqp densq 01 n 2 f50 100 250 500 1000 2500g consist 10 instances denoted beashni experiments instances type g used glover et al 1998b amini et al 1999 01 1 also considered denoted kbg nd good parameter value kopt procedure experiments performed beas1000 beas2500 appeared good tradeo running time solution quality larger values running time increased considerably small changes solution quality therefore chosen subsequent kopt local search experiments experiments performance randomized greedy algorithm 1opt local search applied randomly generated solutions fast kopt local search applied randomly generated solutions combination randomized greedy heuristic fast kopt local search investigated enable fair comparison algorithms implemented c run conditions pentium ii pc 300 mhz operating system solaris 262060100140180 time ms density q greedy 1opt kopt time ms problem size n greedy 1opt kopt greedykopt figure 7 average running times greedy local search heuristics bqp rst experiment average running times four algorithms average solution quality studied figure 7 average running times milliseconds 10000 runs algorithms provided left plot running times provided instances set glov500 density densq contained 01 1 expected running time algorithms grows linearly density matrix q running times combination randomized greedy heuristic kopt local search slightly lower running times kopt local search applied randomly generated solutions since number iterations local search reduced applied solutions produced greedy heuristic right plot running times provided six sets beas50 beas2500 algorithms running times grow quadratically n kopt algorithms appear 25 times slower 1opt algorithm large n greedy heuristic slower 1opt thus number iterations 1opt procedure grows linearly problem size instances studied average solution quality approaches displayed table 1 solution quality measured average percentage excess avg 100 10 fxf best bestknown solution set 10 instances standard deviation sdev also provided algorithm greedy heuristic shows better average performance six sets 1opt local search latter performs better remaining six kopt heuristic performs considerably better greedy 1opt heuristic one exception average percentage excess 1 however combination greedy kopt local table 1 average solution quality greedy local search heuristics bqp instances greedy 1opt kopt greedykopt avg sdev avg sdev avg sdev avg sdev glovd 281 042 271 073 071 035 042 027 search performs best one instance respect average quality solutions table 2 time reach optimum instances 1opt kopt greedykopt glovd 5211 beas250 2000 009 077 1030 second experiment heuristics repeatedly applied multistart show ability reach optimum bestknown solution heuristics started multiple times best solution found returned instance runs performed algorithm times reach bestknown solutions recorded table 2 times algorithms capable nding optimum 30 runs instances set displayed average number repetitions needed rep average time seconds avg reach bestknown solution well maximum time seconds max reach bestknown solution provided problems size 200 1opt local search capable nding optimum less 2 seconds set glov200 average number local searches 217 kopt heuristic needs 13 local searches average nd bestknown solutions instances set kopt algorithms perform better instances need less 023 seconds nd bestknown solutions able nd bestknown solutions instances set beas250 set greedy kopt combination performs slightly better kopt random solutions less 053 seconds needed table 3 comparison greedy 1opt kopt greedykopt large bqp instances instances greedy 1opt kopt greedykopt time rep avg rep avg rep avg rep avg sec results show small instances simple local search sucient nd bestknown solutions quickly challenging problems size higher third experiment concentrated instances enable fair comparison four algorithms repeatedly applied predened time limit reached runs performed instance results summarized table 3 instance algorithm average number repetitions rep average percentage excess avg given time limit seconds time used provided last column table greedy heuristic shows inferior 1opt local search average percentage excess set beas1000 beas2500 0727 1170 case greedy heuristic 1opt local search results 0216 0543 algorithms based kopt considerably better worst performance lies 0128 optimum beas instances kbg instances appear harder within time limit average solution quality lies 0012 0489 preference one kopt based algorithms given since performance dier signicantly able nd bestknown solution problems glov5001 glov5002 problems density densq greater 025 indicates problems high densities slightly harder kopt local search however results kbg instances show average solution quality simple function density average percentage access problem density 08 kbg08 better problems density 04 07 kbg04 kbg07 comparison tabu search simulated annealing bqp proposed beasley 1998 best found solutions obtained greedy heuristic kopt local search 10 problems size 2500 7 10 cases better best found solutions reported beasley 1998 tabu search simulated annealing running times silicon graphics indigo workstation r4000 100mhz 12721 51873 seconds compared 60 seconds local search pentium ii 300 mhz pc thus results produced kopt local search appear superior least competitive approaches solution quality per time however comparison methods conditions computing hardware operating system programming language coding required support claim sophisticated algorithms however expected produce better solutions tabu search utilizing critical event memory glover et al 1998a found bestknown solution 7 10 instances set kbg cpu time four minutes pentium 200 pc scatter search approach proposed amini et al 1999 found bestknown solutions problems set cpu times reported heuristics proposed paper intended competitive approaches instead developed idea building powerful metaheuristics called memetic algorithms moscato 1999 evolutionary algorithms incoporating greedy heuristics local search conclusions paper randomized greedy heuristic two local search algorithms based 1opt kopt neighborhood bqp proposed runtime behavior average performance heuristics investigated experiments 115 problem instances furthermore four algorithms based heuristics studied multistart randomized greedy algorithm multistart 1opt local search randomly generated solutions multistart kopt local search randomly generated solutions multistart kopt local search solutions generated randomized greedy heuristic results indicate multistart 1opt local search able nd bestknown solutions studied instances size n 100 runs multistart kopt local search capable nding bestknown solutions runs studied instances furthermore 11 15 problem instances size bestknown solution found runs multistart kopt ls applied larger instances n 500 multistart randomized greedy heuristic produces solutions less 1 bestknown solutions cases multistart 1opt local search solutions 05 cases multistart kopt algorithms solutions less 05 bestknown solution cases cpu time limit 10 seconds minute stateoftheart workstation thus proposed kopt local search appears highly eective additional coding eort required comparison 1opt heuristic denitely justied greedy local search heuristics well suited components metaheuristics since average running time 700 milliseconds even large problems size bestknown solutions desired large problems incorporation heuristics genetic algorithms appears promising approach merz freisleben 1999b studies shown combination evolutionary algorithms kopt local highly eective applied large problem instances n 500 katayama narihisa 2000 merz 2000 several areas future research first implementation specic parameter kopt local search studied detail interesting question whether instance independent optimum value parameter whether parameter tuned instance separately second may instances greedy heuristic performs better local search shown graph bipartitioning problem merz freisleben 2000 additional experiments necessary support claim third comparison kopt local search recently proposed tabu search algorithms bqp beasley 1998 another interesting study finally heuristics described paper may extended nk landscapes generalized unconstrained binary programming problem fact currently working greedy kopt heuristic nk landscapes initial experiments indicate heuristics highly ecient r scatter search approach unconstrained quadratic binary programs heuristic algorithms unconstrained binary quadratic programming problem minimization quadratic pseudoboolean function european journal operational research quadratic knapsack problems computers intractability guide theory npcompleteness solving quadratic 0 performance simulated annealingbased heuristic unconstrained binary quadratic programming problem solving large binary quadratic programming problems e quadratic binary programming evolutionary heuristic quadratic 01 programming implicit enumeration algorithm quadratic integer programming memetic algorithms combinatorial optimization problems fitness landscapes e fitness landscapes evolution memetic algorithms short introduction computational aspects branch bound algorithm unconstrained quadratic zeroone programming branch bound algorithm maximum clique problem quadratic assignment formulation molecular conformation problem tr ctr kengo katayama akihiro hamamoto hiroyuki narihisa solving maximum clique problem kopt local search proceedings 2004 acm symposium applied computing march 1417 2004 nicosia cyprus patrick e meyer kevin kontos frederic lafitte gianluca bontempi informationtheoretic inference large transcriptional regulatory networks eurasip journal bioinformatics systems biology v2007 n1 p88 january 2007 kengo katayama akihiro hamamoto hiroyuki narihisa effective local search maximum clique problem information processing letters v95 n5 p503511 15 september 2005 peter merz advanced fitness landscape analysis performance memetic algorithms evolutionary computation v12 n3 p303325 september 2004
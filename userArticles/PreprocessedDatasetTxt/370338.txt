partial evaluation views many database applications environments mediation heterogeneous database sources data warehousing decision support lead complex queries queries often nested defined previously defined views may involve unions good reasons one might want remove pieces subqueries subviews queries subviews query may effectively cached previous queries may materialized viewssemi may known evaluate empty reasoning integrity constraintssemi may match protected queries security cannot evaluated usersin paper present new evaluation strategy respect queries defined views call tupletagging allows efficient removal subviews query approaches rewrite query subviews removed effectively gone evaluate rewritten query tuple tagging evaluation rewrite original query necessarywe describe formally discounted query query subviews marked considered removed present tuple tagging algorithm evaluating discounted queries provide analysis algorithms performance present experimental results results strongly support tupletagging algorithm efficient means effectively remove subviews view query evaluation viable optimization strategy certain applications experiments also suggest rewrite techniques may perform worse evaluation original query much worse tuple tagging approach b introduction 11 motivation objectives many current database applications environments mediation heterogeneous database sources data warehousing decision support incur complex queries queries often nested defined previously defined views may involve unions special type queries called fusion queries selfjoins views defined unions discussed 25 necessity mediation views metaschema defined combine data disparate sources environments view definition maintenance paramount importance many reasons one might want remove pieces subqueries given query let us call subquery unfolding query unfolded via view definition specific subqueries reasons include following 1 unfoldings query may effectively cached previous queries 5 9 may materialized views 16 2 unfoldings may known evaluate empty reasoning integrity constraints 1 3 3 unfoldings may match protected queries security cannot evaluated users 22 4 unfoldings may subsumed previously asked queries interest 5 unfolding shared two queries except difference operation removed queries operation carried e figure 1 andor tree representation original query mean remove unfoldings query modified query subsumeand thus evaluated never evaluatethe removed unfoldings subsume everything else original query case 1 one might want separate certain unfoldings evaluated much less expensively networked distributed environment evaluated locally remainder query evaluated independently find remaining answers 5 remainder query less expensive evaluate original optimization case 2 unfoldings free evaluate since known advance must evaluate empty case 3 unfoldings protected mean rest query cannot safely evaluated case 4 user asking series queries may interested stream answers returned previously seen answers longer interest case 5 except queries might optimized technique consider following example example 1 let six relations defined database db departmentsdid address insti tutesdid address facultyeid rank staffeid position health inseid premium provider life inseid premium provider also three views defined terms relations create view create view create view academic units employees benefits select address select eid select eid premium provider departments faculty life ins union union union select address select eid select eid premium provider institutes staff health ins define following query q q select eeid academic units employees e benefits b adidedid eeidbeid bproviderblue cross query q represented parse tree relational algebra representation andor tree shown figure 1 ignore brevity explicit representation project select operations evaluating queryin order operations specified relational algebra representationis equivalent materializing nodes query tree type evaluation representation referred bottomup assume following query f asked result stored cache select eeid departments faculty f life ins l ddidfdid feidleid lproviderblue cross figure 2 andor tree representation modified query equivalently assume formula represents materialized view matches protected query whose answers displayed f protected query join expression computes evaluated thus eliminated query otherwise f cached query materialized view may still beneficial remove query call result discounted query one way achieve rewrite q union joins base tables remove join represented f explicitly present finally evaluate remaining join expressions may inefficient however number join expressions remain evaluated may exponential size collection view definitions furthermore shown 11 evaluation plan often called topdown may require evaluating joins many times incur expense given tuple may computed many times whenever projected parts base tables overlap significantly topdown evaluation q figure 1 union eight following join expressions departments 1 faculty 1 life ins departments 1 faculty 1 health ins departments 1 staff 1 life ins departments 1 staff 1 health ins institutes 1 faculty 1 life ins institutes 1 faculty 1 health ins institutes 1 staff 1 life ins institutes 1 staff 1 health ins seemingly efficient evaluation plan discounted query devised rewriting query number operations unions joins minimized see figure 2 side effect approach redundancy join evaluation well redundancy answer computation reduced however redundancy entirely eliminated example join institutes 1 faculty computed twice implicitly left subtree explicitly right subtree one verify rewrite query tree removes join departments 1 faculty ins yet guarantees time redundancy computation joins thus optimized query sometimes cost evaluate original query experimental results show see section 4 indeed case example paper present new strategy partial evaluation queries defined views call tupletagging offers many advantages explicit query rewrites ffl tupletagging easily implemented logical level accomplished rewriting sql expression query ffl technique modular implemented independently optimization stages particular traditional relational database query optimization work conjunction stages ffl tupletagging algebraic rewrite query preserves query tree thus scales complex queries ffl tupletagging interleaved query evaluation thus reliable heuristics devised employed decide stepwise whether given optimization step applied paper organized follows section 2 presents formal framework discounted queries section skipped first reading section 3 presents tupletagging technique evaluating discounted queries performance analysis technique experimental results tpcd benchmark database db2 presented section 4 section 5 concludes issues future work 12 related work substantial body research rewrite based query optimization 4 6 7 19 however techniques discussed literature considered rewriting query logically equivalent form different goal one consider interested generating efficiently evaluating query view unfolding removed thus resulting query equivalent original query problem address also different problem answering queries using materialized views 2 14 16 20 latter problem goal replace subqueries query views queries generate query equivalent contained original query goal remove precisely avoid evaluating parts query optimization security reasons work closely related work 15 authors consider queries involve nested union operations propose technique rewriting queries known joins evaluated part query empty technique applies however simple class queries complexity issues addressed another research area related problem multiple query optimization 21 goal optimize evaluation set queries rather single query since queries set arbitrary may related structured way allow use techniques propose developed techniques multiple query optimization focused towards finding reusing common subexpressions across collections queries heuristicsbased problem query tree rewrites purpose optimization also considered context deductive databases recursion 12 problem detecting eliminating redundant subgoal occurrences proof trees generated programs presence functional dependencies discussed 13 residue method 1 extended recursive queries investigated computational complexity query rewrites 10 showed optimal rewrite query nphard also identified special class queries unfoldings rewrites result simpler query thus always providing optimization discounted queries section formally define notion unfolding discounted query preciseness use notation datalog 24 write query set atoms interpreted conjunction atoms instance fa e bg represents query example 1 1 atoms may intensional written view predicates defined base table predicates perhaps views definition 2 given query sets q u call u 1step unfolding query set q respect database db iff given q 2 q rule ha b defining view q j general unifier 17 present propositional examples simplicitys sake extended obvious way queries variables made explicit e l h 1 2 1 2 1 2 figure 3 andor tree example 1 two unfoldings marked denote u 1 q call u 1 simply unfolding q written u 1 q iff finite collection query sets u unfolding u called extensional iff every q 2 u atom q refers base table call unfolding intensional otherwise words atoms refer views example 3 views example 1 represented simplified datalog letters represent atoms e f b l e b h since b query q unfolded l using single rule hb li fa e lg one 1step unfoldings q since atoms unfolding f q f l extensional extensional unfolding q easy see unfoldings andor tree inscribed querys andor tree atoms unfolding marked querys tree shown figure 3 unfoldings say bg query considered equivalent union extensional unfoldings define unfolds q set extensional unfoldings q define concept discounted query represent query unfoldings removed discounted definition 4 given query set q unfoldings u q expression qnfu discounted query define meaning unfolds unfolds u call u unfoldingstodiscount tuples answer sets unfoldings tuplestodiscount example 5 consider query q example 1 since fd f lg fd f hg fd lg fd hg fi f lg fi f hg fi lg fi hg fd f lg fd f hg fd lg fd hg fi f lg fi f hg fi lg fi hg similarly unfolding g fi bg figure 3 fd f hg fd f lg fd lg fd hg fi f lg fi f hg lastly fd f hg fd lg fd hg fi f lg fi f hg discuss formally semantics discounted queries 8 3 tupletagging evaluation strategy 31 overview strategy bottomup materialization strategy query tree union join operations modified account discounted unfoldings strategy ensures two things ffl tuples resulting unfoldingtodiscount contribute answer set discounted query ffl join represented unfoldingtodiscount never fully evaluated tuples resulting unfoldingtodiscount removed either actual query evaluation ensure second property thus gain optimization need somehow avoid evaluating unfoldingstodiscount prevent tuples materialized query evaluation proposed method tupletagging keep extra information temporary tables created materialization query tree essence table extra column unfoldingto discount domain tag columns boolean value tag column given tuple true tuple derived corresponding unfoldingtodiscount false otherwise union join operation creates new temporary table tag columns values must maintained properly example 6 consider query q example 1 query f represents unfoldingtodiscount join departments faculty life ins tables new column cf added values initialized true similarly tables institutes staff health ins unioned tables column added values initialized false keeping derivation information tuple evaluation easily ensure first property evaluation query select tuples false values tag columns also project away tag columns shall able use tag columnsand ultimately satisfy second propertyto determine join operation tuples joined resulting tuple would unfoldingtodiscount computation saved primarily depend size true section table present evaluation strategy two versions simpler version ensures first property final answer set contains tuples arise solely unfoldingstodiscount strategy useful case unfoldings removed security reasons little however optimize query evaluation gross savings equal difference cost writing back results original query versus cost writing back results discounted query sometimes new tag columns needby basis u 2 u add column cu instantiate values cu true u cu belongs tb add column cu instantiate values cu tb false union two tables union tln trn create tn algorithm 1 modified union operation significantly smaller savings substantial query results sent network second version removes tuplestodiscount query evaluation soon possible strategy reduce cost query evaluation versions algorithm require modifying union join operations define next 32 modified union operation assume query tree contains union join nodes operations implicit furthermore without loss generality assume tree binary refer one child branch nonleaf node n binary query tree ln left child rn right child assume leaf n query tree corresponding table database answer set n derivable table perhaps temporary database via selects projections call n table selects projections implicit tn handle discounted queries modify traditional algorithm bottomup query evaluation involves replacing union join operations specialized versions handle exploit tag columns unfoldingstodiscount discussed given discounted query qnfu introduce new columns cu tag columns corresponding unfoldingsto discount described example 6 assume wellformed query tree tables unioned union step union compatible addition tag columns could violated two tables unioned may unioncompatible tag columns thus need modify union step first make tables unioncompatible adding tag columns needed algorithm 1 shows way need modify union step note algorithm 1 efficiently implemented sql adding tag columns initializing values execution union operator show section 4 adds little overhead cost query execution 33 modified join operation must assign correct values tag columns joined tables tuple results join one tuple derived given unfoldingtodiscount u hence value cu true second tuple hence value cu false resulting tuple answer set u cu resulting tuple value false tuples joined derived u resulting tuples column cu set true thus tags conjunctively combined let n join node query tree children ln rn let u unfoldingsto discount tag column cu tables tln trn modified join operation executed node n modified adding following assignment statement 2 unfoldingtodiscount u example 7 consider final join query example 1 three joined tables academic units employees benefits contain extra column cf storing values unfolding todiscount f column introduced execution union operations described algorithm 1 query modified join operation follows select eeid acf ecf bcf cf academic units employees e benefits b adidedid eeidbeid bproviderblue cross modified union join operations influence except adding extra columns final answer set query purpose keep trace information unfoldingstodiscount via tag columns last step tupletagging algorithm first version consists using information select tuples known derivable unfolding unfoldingtodiscount ensure sufficient select tuples value false tag columns show tupletagging algorithm modified union join operations correct prove need show tuples tuples value true tag column given unfoldingtodiscount final answer set query tuples answer set unfolding theorem 8 let qnfu discounted query let denote answer set table representing result evaluating qnfu using tupletagging algorithm tuple proof assume without loss generality unfoldingstodiscount extensional intensional unfolding always represented union extensional unfoldings let unfolding u join consider tuple marked true column unfolding u cu true assume 62 cannot initial value set modified union operator cu true r thus least one false value cu changed false remain sometime evaluation joins contradicts assumption hence 2 2 statement per sql92 standards 18 perform requisite logical ands tag columns introduces tag columns back new table f benefits academic units employees institutes figure 4 final join query example 9 assume initialized true r since modified join operator assigns conjunction values cu join tables cu remain true duration evaluation process note modified union operator never changes values tag columns hence cu 34 optimization stated section 31 removing tuplestodiscount final query answer set according optimization described general improve efficiency query evaluation complex queries however removal executed query evaluation final answer set produced words push selects false tag columns query tree constitutes tupletagging algorithm second version consider following example example 9 let query example 1 unfoldingtodiscount marked 2 figure 3 thus tuples join intitutes 1 staff 1 benefits removed querys answer set let us assume final join query academic units 1 employees 1 benefits executed specified query tree left right consider result evaluating academic units 1 employees tuples result join value true column c g see figure 4 tuples table benefits value true column table part unfoldingtodiscount g thus tuples marked true result join academic units 1 employees remain true join benefits hence removed final query answer set 3 eliminated soon academic units 1 employees evaluated note provides optimization size one tables input final join decreases gross savings achieved optimization estimated cost join result institutes 1 staff benefits marked dotted lines figure 4 introduce notion closing unfoldingtodiscount node query tree definition 10 unfoldingtodiscount u closed node n respect binary query tree qt tuple marked true tn contribute tuples u 3 final tupletagging query plan would even need add tag column cg benefits reason thus node representing join academic units 1 employees closing node unfoldingto discount g example 9 course root query tree closing node unfoldingstodiscount next prove theorem specifies method identifying closing nodes query tree theorem 11 unfolding u closed node n respect binary query tree qt every node u cannot reached root qt join nodes subtree rooted n proof consider nodes u lie n none nodes contain column u since none tables used union join nodes nodes query tree root columns never created tuples tables hence tuple table represented node n could contribute change value column cu joined evaluation tables represented nodes u thus tuples value true unfoldings closed n removed immediately table tn materialized 2 since may several closing nodes given unfolding useful identify first one sequence operations specified query tree order eliminate tuplestodiscount soon possible condition property simple n closing node u u closing node subtree rooted n n first closing nodes u tupletagging algorithm utilize described example 9 existence closing nodes eliminate unfoldingstodiscount also provide optimization experimental results confirm indeed case performance analysis 41 experiments purpose experiments threefold 1 evaluate overhead query evaluation time introduced tupletagging algorithm modification union join operations 2 compare performance tupletagging versus query rewrite techniques eliminating unfoldings todiscount 3 evaluate optimization query execution tupletagging used tpcd benchmark database size 100mb experiments details benchmark see 23 installed db2 windowsnt order able define views unions modified slightly tpcd schema thus three tables supplier partsupp lineitem base tables tpcd schema partitioned horizontally half new base tables representing subtables supplier1 supplier2 forth created views supplier v partsuppv lineitemv defined unions supplier1 supplier2 partsupp1 partsupp2 lineitem1 lineitem2 respectively thus views exactly content original tables tpcd benchmark database tested several versions following three queries select supplierv partsuppv p supplierv partsuppv p ssuppkeypsuppkey ssuppkeypsuppkey select 1 1 1 3 2 2 2 figure 5 query tree q 2 marked unfoldingstodiscount supplierv partsuppv p ssuppkeypsuppkey ppartkeylpartkey 1 defined one unfoldingtodiscount ffl u 0 join supplier1 partsupp1 defined following three unfoldingstodiscount marked query tree figure 5 1 u 1 join supplier1 lineitem1 partsupp1 2 u 2 join supplier2 lineitem2 partsuppv 3 u 3 join supplier2 lineitem2 partsupp2 following discounted queries tested g note q 2 q exactly structure respectively q qnffg example 1 similarly structure qnfgg example 9 since db2 support boolean data types used integers 0 1 tags used multiplication instead logical manipulation example query q evaluated tupletagging strategy following form select supplierv partsuppv p lineitemv l ssuppkeypsuppkey ppartkeylpartkey psuppkeylsuppkey stag1 ptag1 tag1 tag2 stand tags u 1 u 3 respectively values set definitions views supplierv partsuppv lineitemv table 1 presents results tests measuring evaluation cost several queries used tuple tagging explicit rewrites evaluating discounted queries thus suffixes tag rew top mean discounted query evaluated using respectively tupletagging explicit rewrite query tree minimize number operations described example 1 topdown approach evaluating joins base tables particular query tree rew structure query tree figure 2 similarly q rew following form 4 allattributes supplier1 4 express relational algebra brevity query total execution time number retrieved rows tag 3495 1 tag 175 7242 tag 36438 rew 58282 65219 tag 35618 rew 48265 55537 tag 29888 56002 table 1 experimental results one easily verify compact representation q g recall q 2 nfu 1 g top evaluated union extensional unfoldingsthat union joins base tablesand similarly top 42 discussion purpose testing q 1 q 1 nfu 0 g measure overhead adding manipulating tags query designed way optimization query execution time possibly achieved using tags done making root closing node u 0 q 1 nfu 0 g joined tables identical sizes q minimizing size answer set thus making sure benefit writing less data back disk indeed query execution time 3495 seconds larger q 1 3485 seconds good news difference negligible 029 case q g size answer becomes substantial tupletagging begins optimize queries q 0 project attributes two joined tables reducing size answer set q 0 provides optimization query execution time q 0 vs 256 seconds q 0 1 purpose queries compare tupletagging two techniques removing unfolding query topdown query evaluation explicit rewrite query tree minimize algebraic form tupletagging outperforms two techniques respectable margin fact topdown approach explicit query rewrite approach add substantial overhead cost evaluating discounted queries see table 2 conjectured section 1 due introduction redundancy join evaluation techniques hand evaluated tupletagging strategy provide modest optimization q 2 see figure 6 still achieved reduction size answer set reduction sizes joined tables last query q 2 nfu 2 g provides crucial test technique temporary table created join supplierv 1 lineitemv closing node unfolding u 2 means tuples marked true table eliminated next join partsuppv executed thus reducing query evaluation strategy tupletagging topdown explicit rewrite table 2 evaluation time seconds discounted queries different evaluation strategies cost last join indeed reduction execution cost q 2 nfu 2 g original query q 2 257 43 heuristics stated section 1 one advantages tupletagging explicit query tree rewrites reliable heuristics devised decide stepwise whether given optimization step applied decision depend reduction size table representing closing node unfolding set unfoldings query tree example query q half tuples supplierv half tuples lineitemv marked true hence proportion tuples marked true join supplierv 1 lineitemv assuming uniform distribution values estimated 25 tuples eliminated cost join partsuppv roughly estimated reduced 25 well show formally reduction estimated general thus providing main component heuristics used tupletagging algorithm proportion tuplestodiscount versus tuples p table representing closing node n depends three factors proportion tuples tagged true unfoldingtodiscount closed n number unfoldingstodiscount closed n size join many tables participate state dependence formally follows assume uniform distribution tuplesto discount among tuples table theorem 12 let table 0 created join tables 1 n different tag columns proportion tuples table j value true column proportion tuples 0 tag columns value true proof induction n 1 one unfoldingtodiscount tuple discounted created joining tables participating join tuple value true column cu probability pi value formula 2 assume formula holds n unfoldingstodiscount show holds tuple discounted considered one following cases would discounted n unfoldingstodiscount considered b discounted answer set n 1st unfoldingtodiscount probability 2a given induction hypothesis q2 q2nfu1g q2nfu2g figure comparison execution times original query queries evaluated tupletagging probability 2b conditional probability tuple discounted n unfoldingstodiscount considered discounted 1st unfoldingto discount considered probability expressed pi n thus probability tuple discounted n 1 unfoldingstodiscount considered equal sum probabilitues cases 2a 2b special case proportion tuples marked true tables tag columns identical equal value p reduces show application result predict size tables closing nodes experiments example 13 queries g root query tree closing node proportion tuples marked true u 1 u 3 05 three tables supplierv partsupp v lineitemv thus query q 2 nfu 3 g formula 1 form since size answer original query q 73943 rows reducing 125 would produce table size 64700 close actual size 65219 rows observed g similarly query q form 0234 predicted size final query answer set thus 56566 close actual size 55537 g values formula 1 p function n plotted figure 7 2way 5way joins several values pt surprisingly number discounted tuples grows number unfoldingsto discount well proportion tuplestodiscount tables participating join also however strong inverse relationship number joins involved multiway join number discounted tuples even tables participating join 30 tuplestodiscount different unfolding removed number discounted tuples small 5way join conclusions paper introduced new framework query represented collection selected unfoldings query discounted query represents query unfoldings removed pt10 pt30 pt50 pt90 pt70 1006020a 2way join pt30 pt50 pt70 pt902060100 b 5way join figure 7 proportion discounted tuples result join respect number unfoldings todiscount selected unfoldings may removed security reasons answers readily available caching materialized views presented efficient evaluation strategy discounted queries called tupletagging showed experiments discounted query general evaluated efficiently query experiments also suggested rewrite techniques seem intuitive approach removing unfoldings query may perform worse evaluation original query much worse tuple tagging approach thus discounting framework tupletagging algorithm offer viable approach optimization queries employ views numerous issues explore respect optimization queries views type optimization orthogonal optimization techniques directly used conjunction existing optimizers would beneficial identify types interaction traditional query optimizer could increase overall optimization currently tupletagging done prior stage optimization applied resulting queries also need understand better various cost tradeoffs tupletagging best balance r optimizing queries materialized views implementation two semantic query optimization techniques db2 universal database rule languages internal algebras rule based optimizers data caching replacement rule specification framework query optimizers framework intensional query optimization answering queries semantic caches view disassembly query optimization bottomup evaluation structural query optimization uniform framework semantic query optimization deductive databases pushing semantics inside recursion general framework semantic optimization recursive queries computing queries derived relations query reformulation deductive databases answering queries using views foundations logic programming understanding new sql complete guide extensiblerule based query rewrite optimization starburst query folding multiplequery optimization problem constraint processing multilevel secure distributed database management system transaction processing performance council principles database knowledgebase systems fusion queries internet databases tr rulebased view query optimization foundations logic programming 2nd extended ed principles database knowledgebase systems vol logicbased approach semantic query optimization structural query optimizationmyampersandmdasha uniform framework semantic query optimization deductive databases extensiblerule based query rewrite optimization starburst understanding new sql answering queries using views extended abstract rule languages internal algebras rulebased optimizers multiplequery optimization problem constraint processing multilevel secure distributed database management system fusion queries internet databases query reformulation deductive databases praire pushing semantics inside recursion optimizing queries materialized views query folding view disassembly implementation two semantic query optimization techniques db2 universal database semantic data caching replacement query optimization bottomup evaluation answering queries semantic caches ctr parke godfrey jarek gryz view disassembly rewrite extracts portions views journal computer system sciences v73 n6 p941961 september 2007
predictability data values predictability data values studied fundamental level two basic predictor models defined computational predictors perform operation previous values yield predicted next values examples study stride value prediction adds delta previous value last value prediction performs trivial identity operation previous value context based predictors match recent value history context previous value history predict values based entirely previously observed patterns understand potential value prediction perform simulations unbounded prediction tables immediately updated using correct data values simulations integer spec95 benchmarks show data values highly predictable best performance obtained context based predictors overall prediction accuracies 56 91 context based predictor typically accuracy 20 better computational predictors last value stride comparison context based prediction stride prediction shows higher accuracy context based prediction due relatively static instructions giving large improvements suggests usefulness hybrid predictors among different instruction types predictability varies significantly general load shift instructions difficult predict correctly whereas add instructions predictable b introduction clear trend high performance processors toward performing operations speculatively based predic tions predictions correct speculatively executed instructions usually translate improved performance although program execution contains variety information predicted conditional branches received attention predicting conditional branches provides way avoiding control dependences offers clear performance advantage even prevalent control dependences however data dependences virtually every instruction depends result preceding instruction data dependences often thought present fundamental performance barrier however data values may also predicted operations performed speculatively based data predictions important difference conditional branch prediction data value prediction data taken much larger range values would appear severely limit chances successful prediction ever demonstrated recently 1 data values exhibit locality values computed instructions tend repeat large fraction time argue establishing predictability limits program values important determining performance potential processors use value prediction believe first requires understanding design space value predictors models consequently goals paper twofold firstly discuss major issues affecting data value prediction lay framework studying data value prediction secondly important classes predictors use benchmark programs establish levels value predictability study somewhat idealized example predictor costs ignored order clearly understand limits data predictability furthermore ways data prediction used processor microarchitecture within scope paper concentrate greater depth prediction process 11 classification value sequences predictability sequence values function sequence predictor used predict sequence although beyond scope paper study actual sources predictability useful discussion provide informal classification data sequences classification useful understanding behavior predictors later discussions following classification contains simple value sequences also composed form complex sequences best defined giving examples 28 13 99 107 23 456 constant sequences simplest result instructions repeatedly produce result lipasti shen show occurs surprisingly often forms basis work reported 1 stride sequence elements differ constant delta example stride one probably common case programs strides pos sible including negative strides constant sequences considered stride sequences zero delta stride sequence might appear data structure array accessed regular fashion loop induction variables also stride characteristic nonstride category intended include sequences belong constant stride cat egory classification could divided choose nonstrides may occur sequence numbers computed computation complex simply adding constant traversing linked list would often produce address values nonstride pattern also important sequences formed composing stride nonstride sequences repeating sequences would typically occur nested loops inner loop produces either stride nonstride sequence outer loop causes sequence repeated repeated repeated 7 examination sequences leads naturally two types prediction models subject discussion throughout remainder paper computational predictors make prediction computing function previous values example computational predictor stride predictor predictor adds stride previous value context based predictors learn values follow particular context finite ordered sequence values predict one values context repeats enables prediction repeated sequence stride nonstride 12 related work 1 reported data values produced instructions exhibit locality result pre dicted potential value predictability reported terms history depth many times value produced instruction repeats checked recent n values pronounced difference observed locality history depth 1 history depth 16 mechanism proposed prediction ever exploits locality history depth 1 based predicting recent value also next 1 last value prediction used predict load values subsequent work predict values produced instructions written registers 2 address prediction used mainly data prefetching tolerate long memory latency 3 4 5 proposed speculative execution load store instructions 6 7 stride prediction values proposed 8 prediction performance potential compared last value prediction value prediction draw wealth work prediction control dependences 9 10 11 majority improvements performance control flow predictors obtained using correlation correlation information proposed includes local global branch history 10 path address history 11 12 13 path register contents 14 interesting theoretical observation resemblance predictors used control dependence prediction prediction models text compression 15 important observation reenforces approach used control flow prediction also suggests compressionlike methods also used data value prediction number interesting studies report importance predicting eliminating data dependences moshovos 16 proposes mechanisms reduce misspeculation predicting dependences exist store load instructions potential data dependence elimination using prediction speculation combination collapsing examined 17 elimination redundant computation theme number softwarehardware proposals 18 19 20 schemes similar store cache input output parameters function inputs detected output used without performing function virtually proposed schemes perform predictions based previous architected state values notable exceptions schemes proposed 6 predicted fetched load instruction dependence instruction executed early without dependence checking 21 predicted operation required calculate effective address using two operands logical instead binary addition theoretical work hammerstrom 22 used information theory study information content en tropy programs study information content address instruction streams revealed high degree redundancy high degree redundancy immediately suggests predictability 13 paper overview paper organized follows section 2 different data value predictors described section 3 discusses methodology used data prediction simulations results obtained presented analyzed section 4 conclude suggestions future research section 5 2 data value prediction models typical data value predictor takes microarchitecture state information input accesses table produces prediction subsequently table updated state information help make future predictions state information could consist register values pc values instruction fields control bits various pipeline stages etc variety combinations state information almost limitless therefore study restrict predictors use program counter value instruction predicted access prediction tables tables updated using data values produced instruction possibly modified combined information already table restrictions define relatively fundamental class data value predic tors nevertheless predictors using state information deserve study could provide higher level predictability reported remainder paper classify data value predictors two types computational contextbased describe detail next two subsections 21 computational predictors computational predictors make predictions performing operation previous values instruction generated focus two important members class last value predictors perform trivial computational operation identity function simplest form recent value produced instruction v prediction next value also v however number variants modify replacement policies based hysteresis example hysteresis mechanism saturating counter associated table entry counter incrementeddecremented prediction successfailure value held table replaced count threshold another hysteresis mechanism change prediction new value new value occurs specific number times succession subtle difference two forms hysteresis former changes new prediction following incorrect behavior even though behavior may inconsistent whereas latter changes new prediction consistently observed stride predictors simplest form predict next value adding sum recent value difference two recent values produced instruction vngamma1 vngamma2 two recent values predictor computes last value predictors important variations use hysteresis 7 stride changed saturating counter incre menteddecremented successfailure predictions certain threshold reduces number mispredictions repeated stride sequences two per repeated sequence one another policy twodelta method proposed 6 twodelta method two strides maintained one stride s1 always updated difference two recent val ues whereas s2 stride used computing predictions stride s1 occurs twice row used update prediction stride s2 twodelta strategy also reduces mispredictions one per iteration repeated stride sequences addition changes stride stride occurs twice instead changing stride following mispredictions computational predictors using complex organizations conceived example one could use two different strides inner one outer one typically corresponding loop nests eliminate mispredictions occur beginning repeating stride sequences thought process illustrates significant limitation computational prediction designer must anticipate computation used one could carry ridiculous extremes example one could envision fibonacci series predictor given program happens compute fibonacci series predictor would well going path would lead large hybrid predictors combine many specialcase computational predictors chooser proposed conditional branches 23 24 hybrid prediction data values general good idea potential pitfall may yield everescalating collection computational predictors predicts diminishing number additional values caught others study focus last value stride methods primary examples computational predictors also consider hybrid predictors involving predictors context based predictors discussed next section 22 context based predictors context based predictors attempt learn values follow particular context finite ordered sequence previous values predict one values context repeats important type context based predictors derived finite context methods used text compression 25 finite context method predictors fcm rely mechanisms predict next value based finite number preceding values order k fcm predictor uses k preceding values fcms constructed counters count occurrences particular value immediately following certain context pattern thus context must general many counters values found follow context predicted value one maximum count figure 1 shows fcm models different orders predictions example sequence actual implementation may infeasible maintain exact value counts smaller counters may used use small counters comes area text compression small counters one counter reaches maximum count counters context reset half small counters provide advantage heavier weighting given recent history instead entire history general n different fcm predictors orders 0 n 1 used predicting next value sequence highest order predictor context match used make prediction combination one prediction model known blending 25 number variations blending algorithms depending information updated full blending updates contexts lazy exclusion selects prediction longer context match updates counts predictions longer match higher variations fcm predictors devised reducing number values maintained given context example one value per context might maintained along update policy policies based hysteresistype update policies discussed last value stride prediction correlation predictors used control dependence prediction strongly resemble context based prediction far know context based prediction considered value prediction though last value predictor viewed 0th order fcm one prediction maintained per context 23 initial analysis point briefly analyze compare proposed predictors using simple pattern sequences shown section 11 analysis highlights important issues ca b c b c b c c ca b c b c0 0 b b c b c ac 0th order model b c context next symbol frequencysequencea b c b c 1st order model 2nd order model 3rd order model prediction prediction prediction figure 1 finite context models well advantages disadvantages predictors studied provide basis analyzing quantitative results given following sections informally define two characteristics important understanding prediction behavior one learning time lt number values observed first correct prediction second learning degree ld percentage correct predictions following first correct prediction quantify two characteristics classes sequences given earlier section 11 repeating sequences associate period p number values repetitions frequency number times sequence repeated assume repeating sequences p fixed frequency measure captures finiteness repeating sequence context predictors order predictor influences learning time table summarizes different predictors perform basic value sequences note stride predictor uses hysteresis updates gets one incorrect prediction per iteration sequence row table indicates given predictor suitable given sequence ie performance low sequence illustrated table last value prediction useful constant sequences obvious stride prediction well last value prediction constant sequences constant sequence essentially zero stride fcm predictors also well constant sequences order predictor must see length sequence gets matches table unless form blending used nonrepeating stride sequences stride prediction model sequence last value stride fcm table 1 behavior various prediction models different value sequences predictor well short learning time achieves 100 prediction rate fcm predictors cannot predict nonrepeating sequences rely repeating patterns repeating stride sequences stride fcm predictors well stride predictor shorter learning time learns gets misprediction time sequence begins repeat hand fcm predictor requires longer learning time must see entire sequence starts predict correctly sequence starts repeat gets 100 accuracy figure 2 example points important tradeoff computational context based predic tors computational predictor often learns faster context predictor tends learn better repeating sequences occur finally repeating nonstride sequences fcm predictor well flexibility provides clearly strong point fcm predictors returning fibonacci series example sequence containing repeating portion fibonacci series fcm predictor naturally begin predicting correctly following first pass sequence course reality value sequences complex combinations simple sequences section 11 given program produce many different sequences instructions predicted consequently remainder paper use simulations get realistic idea predictor performance programs 3 simulation methodology adopt implementationindependent approach studying predictability data dependence values reason choice remove microarchitecture implementation idiosyncrasies effort develop basic understanding predictability hence results best viewed bounds performance take additional engineering research develop realistic implementations steady state repeats mistake repeated steady state misspredictions period learn prediction context based figure 2 computational vs context based prediction study predictability instructions write results general purpose registers ie memory addresses stores jumps branches considered prediction done table aliasing static instruction given table entry hence table sizes effectively unbounded finally prediction tables updated immediately prediction made unlike situation practice may take many cycles actual data value known available prediction table updates simulate three types predictors last value prediction l alwaysupdate policy hysteresis stride prediction using 2delta method s2 finite context method fcm maintains exact counts value follows particular context uses blending algorithm lazy exclusion described section 2 fcm predictors studied orders 1 2 3 form context fcm predictor use full concatenation history values aliasing matching contexts trace driven simulation conducted using simplescalar toolset 26 integer spec95 benchmarks shown table 2 1 benchmarks compiled using simplescalar compiler o3 optimization integer benchmarks selected tend less data parallelism may therefore benefit data predictions collecting prediction results instruction types grouped categories shown table 3 ab 1 ijpeg simulations used reference flags following changes compressionquality 45 compressionsmoothing factor 45 benchmark input dynamic instructions flags instr mil predicted mil compress 30000 e 82 58 71 gcc gcci 203 137 68 ijpeg specmunppm 129 108 84 m88k ctlraw 493 345 70 xlisp 7 queens 202 125 62 table 2 benchmarks characteristics instruction types code addition subtraction addsub loads loads xor logic shifts shift compare set set multiply divide multdiv load immediate lui floating jump table 3 instruction categories breviations shown group used subsequently results presented percentage predicted instructions different benchmarks ranged 6284 recall instructions like stores branches jumps predicted breakdown static count dynamic percentages predicted instruction types shown tables 45 majority predicted values results addition load instructions collected results instruction type however discuss results multdiv lui instruction types due space limitations benchmarks studied multdiv instructions significant contributor dynamic instruction count lui instructions rarely generate one unique value 95 predictable predictors note effect three types instructions included calculations overall results averaging used arithmetic mean benchmark effectively contributes number total predictions 4 simulation results 41 predictability figure 3 shows overall predictability selected benchmarks figures 47 show results important instruction types figures draw number type com gcc go ijpe m88k perl xlis loads 686 29138 9929 3645 2215 3855 1432 logic 149 2600 215 278 674 460 157 multdi 19 313 196 222 77 26 25 108 5848 1403 517 482 778 455 table 4 predicted instructions static count type com gcc go ijpe m88k perl xlis loads 205 386 262 214 248 431 486 logic 31 31 05 19 50 31 34 shift 174 77 133 164 32 82 32 set 74 54 49 42 152 56 32 lui 33 37 114 02 69 24 08 57 21 13 03 21 33 48 table 5 predicted instructions dynamic conclusions overall last value prediction less accurate stride prediction stride prediction less accurate fcm prediction last value prediction varies accuracy 23 61 average 40 agreement results obtained 2 stride prediction provides accuracy 38 80 average 56 fcm predictors orders 1 2 3 perform better stride prediction higher order higher accuracy order 3 predictor best gives accuracies 56 90 average 78 three fcm predictors studied improvements diminish order increased particular observe every additional value context performance gain halved effect predictability increasing order examined detail section 44 performance stride last value predictors varies significantly across different instruction types benchmark performance fcm predictors varies less significantly across different instruction types benchmark reflects flexibility fcm predictors perform well repeating sequence strides general stride fcm prediction appear higher predictability addsubtracts loads logical instructions also appear predictable especially fcm predictors shift instructions appear difficult predict stride prediction particularly well addsubtract compress cc1 go ijpeg m88k perl xlisp predictions figure 3 prediction success instructions instructions nonaddsubtract instructions performance stride predictor close last value pre diction indicates operation computational predictor matches operation instruction eg addition higher predictability expected suggests new computational predictors better capture functionality nonaddsubtract instructions could useful example shifts computational predictor might shift last value according last shift distance arrive prediction approach would tend lead hybrid predictors however separate component predictor instruction type 42 correlation correctly predicted sets effect results previous section essentially compare sizes sets correctly predicted values also interesting consider relationships among specific sets correctly predicted values primarily relationships suggest ways hybrid predictors might constructed although actual construction hybrid predictors beyond scope paper predicted set relationships shown figure 8 three predictors used last value stride delta2 fcm order 3 subsets predictors represented specifically l fraction predictions last value predictor correct f similarly defined stride fcm predictors respectively ls fraction predictions last value stride predictors correct fcm predictor lf sf similarly defined lsf fraction predictions predictors correct np fraction none predictors correct figure results averaged benchmarks qualitative conclusions similar the1030507090compress cc1 go ijpeg m88k perl xlisp predictions figure 4 prediction success addsubtract instructions1030507090compress cc1 go ijpeg m88k perl xlisp predictions figure 5 prediction success loads instructions1030507090compress cc1 go ijpeg m88k perl xlisp predictions logic figure prediction success logic instructions1030507090compress cc1 go ijpeg m88k perl xlisp predictions figure 7 prediction success shift instructions addsu loads logic shift set predictions ls lf sf lsf figure 8 contribution different predictors individual benchmarks overall figure 8 briefly summarized small number close 18 values predicted correctly model ffl large portion around 40 correct predictions captured predictors ffl significant fraction 20 correct predictions captured fcm ffl stride last value prediction capture less 5 correct predictions fcm misses confirms data values pre dictable appears context based prediction necessary achieving highest levels predictabil ity however almost 60 correct predictions also captured stride predictor assuming context based prediction expensive approach suggest hybrid scheme might useful enabling high prediction accuracies lower cost one try use stride predictor predictions use fcm prediction get remaining 20 another conclusion last value prediction adds little predictors achieve either stride fcm prediction implemented point adding last value prediction hybrid predictor important classes load add instructions yield results similar overall average finally note nonaddsubtract instructions contribution stride prediction smaller likely due earlier observation stride prediction match func20406080100 static instructions fcm better stride normalized addsub loads logic figure 9 cumulative improvement fcm stride tionality instruction types suggests hybrid predictor based instruction types proceeding along path hybrid fcmstride pre dictor one reasonable approach would choose among two component predictors via pc address instruction predicted would appear work well performance advantage fcm predictor due relatively small number static instructions determine true first constructed list static instructions fcm predictor gives better performance static instructions determined difference prediction accuracy fcm stride sorted static instructions descending order improvement figure 9 graph cumulative fraction total improvement versus accumulated percentage static instructions graph shows overall 20 static instructions account 97 total improvement fcm stride prediction individual instruction types result similar shifts showing slightly worse performance results suggest improvements due context based prediction mainly due relatively small fraction static instructions hence hybrid fcmstride predictor choosing seems good approach 43 value characteristics point clear context based predictors perform well may require large tables store history values assume unbounded tables study real implementations considered course possible get handle issue study value characteristics instructions particu predicted instructions 65536163841024644 figure 10 values instruction behavior lar report number unique values generated predicted instructions overall numbers different values could give rough indication numbers values might stored table left half figure 10 show number different values produced percentages static instructions prefix right half determine fractions dynamic instructions prefix correspond static categories figure observe ffl large number 50 static instructions generate one value ffl majority static instructions 90 generate fewer 64 values ffl majority 50 dynamic instructions correspond static instructions generate fewer values ffl 90 dynamic instructions due static instructions generate 4096 unique values ffl number values generated varies among instruction types general addsubtract load instructions generate values compared logic shift operations ffl frequently instruction executes values generates suggest relatively small number values would required predict correctly majority dynamic instructions using context based prediction positive result looking individual benchmark results shown appears positive correlation programs difficult predict programs produce values example highly predictable m88ksim many instructions produce values compared less predictable gcc go would appear intuitive result may cases hold example values generated fashion predictable computational predictors small number values occur many different sequences 44 sensitivity experiments context based prediction section discuss results experiments illustrate sensitivity fcm predictors input data predictor order experiments focus gcc benchmark report average correct predictions among instruction types sensitivity input data studied effects different input files flags correct prediction fcm predictor used experiments order 2 prediction accuracy number predicted instructions different input files shown table 6 fraction correct predictions shows small variations across different input files note results unbounded tables aliasing affects caused different data set sizes appear may case fixed table sizes table 7 show predictability gcc input file different compilation flags using order 2 fcm predictor results indicate variations small sensitivity order experiments performed increasing order input file gcci flags results different orders shown figure 11 experiment suggests higher order means better performance returns diminishing increasing order also indicate previous values required predict well conclusions considered representatives two classes prediction models computational ii context based simulations demonstrate values potentially highly predictable results indicate context based prediction outperforms previously proposed computational prediction stride last value high prediction correctness desired context methods probably need used either alone hybrid scheme obtained results also indicate performance computational prediction varies instruction types indicating file predictions mil correct recogi 192 786 stmti 372 778 table 126gcc different input files flags predictions mil correct none ref flags 137 771 table 7 sensitivity 126gcc input flags input file gcci72768084 order prediction accuracy figure 11 sensitivity 126gcc order input file gcci performance improved prediction function matches functionality predicted instruc tion analysis improvements context prediction computational prediction suggest 20 instructions generate relatively values responsible majority improvement respect value characteristics instructions observe majority instructions generate many unique values number values generated instructions varies among instructions types result suggests different instruction types need studied separately due distinct predictability value behavior believe value prediction significant potential performance improvement however lot innovative research needed value prediction become effective performance approach 6 acknowledgements work supported part nsf grants mip 9505853 mip9307830 us army intelligence center fort huachuca contract dabt63 95c0127 arpa order d346 views conclusions contained herein authors interpreted necessarily representing official policies endorsements either expressed im plied u army intelligence center fort huachuca us government authors would like thank stamatis vassiliadis helpful suggestions constructive critique work progress r value locality data speculation exceeding dataflow limit via value prediction effective hardwarebased data prefetching high performance processors examination memory access classification scheme pointer intensive numeric programs prefetching using markov pre dictors load instruction unit pipelined processors speculative execution via address prediction data prefetching speculative execution based value prediction study branch prediction strategies alternative implementations twolevel adaptive branch prediction target prediction indirect jumps improving accuracy static branch prediction using branch correlation dynamic pathbased branch correlation compiler synthesized dynamic branch prediction analysis branch prediction via data compression dynamic speculation synchronization data depen dences performance potential data dependence speculation collaps ing architectural alternative optimizing compilers caching function results faster arithmetic avoiding unnecessary computation dynamic instruction reuse zerocycle loads microarchitecture support reducing load latency information content cpu memory referencing behavior combining branch predictors using hybrid branch predictors improve branch prediciton presence context switches evaluating future microprocessors simplescalar tool set tr text compression alternative implementations twolevel adaptive branch prediction improving accuracy static branch prediction using branch correlation dynamic pathbased branch correlation zerocycle loads using hybrid branch predictors improve branch prediction accuracy presence context switches analysis branch prediction via data compression value locality load value prediction examination memory access classification scheme pointerintensive numeric programs compiler synthesized dynamic branch prediction exceeding dataflow limit via value prediction performance potential data dependence speculation myampersandamp collapsing speculative execution via address prediction data prefetching dynamic speculation synchronization data dependences dynamic instruction reuse prefetching using markov predictors target prediction indirect jumps effective hardwarebased data prefetching highperformance processors architectural alternative optimizing compilers study branch prediction strategies information content cpu memory referencing behavior ctr g surendra banerjee k nandy effectiveness flow aggregation improving instruction reuse network processing applications international journal parallel programming v31 n6 p469487 december ehsan atoofian amirali baniasadi speculative trivialization point advancing highperformance processors journal systems architecture euromicro journal v53 n9 p587601 september 2007 chaoying fu matthew jennings sergei larin thomas conte value speculation scheduling high performance processors acm sigops operating systems review v32 n5 p262271 dec 1998 martin burtscher improved index function dfcm predictors acm sigarch computer architecture news v30 n3 june 2002 pojen chuang youngtzong hsiao yushian chiu efficient value predictor dynamically using loop locality properties journal supercomputing v30 n1 p1936 october 2004 avinash sodani gurindar sohi understanding differences value prediction instruction reuse proceedings 31st annual acmieee international symposium microarchitecture p205215 november 1998 dallas texas united states sangjeong lee penchung yew table bandwidth update delay value prediction wideissue ilp processors ieee transactions computers v50 n8 p847852 august 2001 chaoying fu jill bodine thomas conte modeling value speculation optimal edge selection problem ieee transactions computers v52 n3 p277292 march michael bekerman stephan jourdan ronny ronen gilad kirshenboim lihu rappoport adi yoaz uri weiser correlated loadaddress predictors acm sigarch computer architecture news v27 n2 p5463 may 1999 avinash sodani gurindar sohi empirical analysis instruction repetition acm sigops operating systems review v32 n5 p3545 dec 1998 jinsuo zhang predictability load address acm sigarch computer architecture news v29 n4 september 2001 yuan chou brian fahs santosh abraham microarchitecture optimizations exploiting memorylevel parallelism acm sigarch computer architecture news v32 n2 p76 march 2004 jian huang david j lilja extending value reuse basic blocks compiler support ieee transactions computers v49 n4 p331347 april 2000 mark oskin frederic chong matthew farrens hls combining statistical symbolic simulation guide microprocessor designs acm sigarch computer architecture news v28 n2 p7182 may 2000 dean tullsen john seng storageless value prediction using prior register values acm sigarch computer architecture news v27 n2 p270279 may 1999 tarun nakra rajiv gupta mary lou soffa value prediction vliw machines acm sigarch computer architecture news v27 n2 p258269 may 1999 yiannakis sazeides james e smith modeling program predictability acm sigarch computer architecture news v26 n3 p7384 june 1998 daniel connors wenmei w hwu compilerdirected dynamic computation reuse rationale initial results proceedings 32nd annual acmieee international symposium microarchitecture p158169 november 1618 1999 haifa israel daniel connors hillery c hunter benchung cheng wenmei w hwu hardware support dynamic activation compilerdirected computation reuse acm sigplan notices v35 n11 p222233 nov 2000 characterization value locality java programs workload characterization emerging computer applications kluwer academic publishers norwell 2001 burrows u erlingson st leung vandevoorde c waldspurger k walker w e weihl efficient flexible value sampling acm sigplan notices v35 n11 p160167 nov 2000 jos gonzlez antonio gonzlez potential data value speculation boost ilp proceedings 12th international conference supercomputing p2128 july 1998 melbourne australia burrows u erlingson st leung vandevoorde c waldspurger k walker w e weihl efficient flexible value sampling acm sigops operating systems review v34 n5 p160167 dec 2000 daniel connors hillery c hunter benchung cheng wenmei w hwu hardware support dynamic activation compilerdirected computation reuse acm sigops operating systems review v34 n5 p222233 dec 2000 martin burtscher tcgen 20 tool automatically generate lossless trace compressors acm sigarch computer architecture news v34 n3 p18 june 2006 juan cebrian juan l aragon jose garcia stefanos kaxiras adaptive vp decay making value predictors leakageefficient designs high performance processors proceedings 4th international conference computing frontiers may 0709 2007 ischia italy robert chappell francis tseng adi yoaz yale n patt difficultpath branch prediction using subordinate microthreads acm sigarch computer architecture news v30 n2 may 2002 chiahung liao jongjiann shieh exploiting speculative value reuse using value prediction australian computer science communications v24 n3 p101108 januaryfebruary 2002 g surendra subhasis banerjee k nandy effectiveness prefetching reuse reducing l1 data cache traffic case study snort proceedings 3rd workshop memory performance issues conjunction 31st international symposium computer architecture p8895 june 2020 2004 munich germany glenn reinman brad calder dean tullsen gary tyson todd austin classifying load store instructions memory renaming proceedings 13th international conference supercomputing p399407 june 2025 1999 rhodes greece andreas moshovos gurindar sohi readafterread memory dependence prediction proceedings 32nd annual acmieee international symposium microarchitecture p177185 november 1618 1999 haifa israel compiler controlled value prediction using branch predictor based confidence proceedings 33rd annual acmieee international symposium microarchitecture p327336 december 2000 monterey california united states zhang rajiv gupta whole execution traces proceedings 37th annual ieeeacm international symposium microarchitecture p105116 december 0408 2004 portland oregon jeremy singer chris kirkham dynamic analysis program concepts java proceedings 4th international symposium principles practice programming java august 30september 01 2006 mannheim germany trace processors proceedings 30th annual acmieee international symposium microarchitecture p138148 december 0103 1997 research triangle park north carolina united states bryan black brian mueller stephanie postal ryan rakvic noppanunt utamaphethai john paul shen load execution latency reduction proceedings 12th international conference supercomputing p2936 july 1998 melbourne australia ilya ganusov martin burtscher efficient emulation hardware prefetchers via eventdriven helper threading proceedings 15th international conference parallel architectures compilation techniques september 1620 2006 seattle washington usa pedro marcuello antonio gonzlez jordi tubella speculative multithreaded processors proceedings 12th international conference supercomputing p7784 july 1998 melbourne australia nana b sam martin burtscher energyefficiency speculative hardware proceedings 2nd conference computing frontiers may 0406 2005 ischia italy byungkwon chung jinsuo zhang jihkwon peir shihchang lai konrad lai direct load dependencelinked dataflow resolution load address cache coordinate proceedings 34th annual acmieee international symposium microarchitecture december 0105 2001 austin texas timothy h heil zak smith j e smith improving branch predictors correlating data values proceedings 32nd annual acmieee international symposium microarchitecture p2837 november 1618 1999 haifa israel youfeng wu dongyuan chen jesse fang better exploration regionlevel value locality integrated computation reuse value prediction acm sigarch computer architecture news v29 n2 p98108 may 2001 freddy gabbay avi mendelson effect instruction fetch bandwidth value prediction acm sigarch computer architecture news v26 n3 p272281 june 1998 parthasarathy ranganathan sarita adve norman p jouppi reconfigurable caches application media processing acm sigarch computer architecture news v28 n2 p214224 may 2000 huiyang zhou thomas conte enhancing memory level parallelism via recoveryfree value prediction proceedings 17th annual international conference supercomputing june 2326 2003 san francisco ca usa peng jihkwon peir qianrong konrad lai addressfree memory access based program syntax correlation loads stores ieee transactions large scale integration vlsi systems v11 n3 p314324 june matthew c chidester alan george matthew radlinski multiplepath execution chip multiprocessors journal systems architecture euromicro journal v49 n12 p3352 july chihung chi junli yuan chinming cheung cyclic dependence based data reference prediction proceedings 13th international conference supercomputing p127134 june 2025 1999 rhodes greece nana b sam martin burtscher improving memory system performance energyefficient value speculation acm sigarch computer architecture news v33 n4 november 2005 madhu mutyam vijaykrishnan narayanan working process variation aware caches proceedings conference design automation test europe april 1620 2007 nice france tanaus ramrez alex pajuelo oliverio j santana mateo valero kiloinstruction processors runahead prefetching proceedings 3rd conference computing frontiers may 0305 2006 ischia italy luis ceze karin strauss james tuck josep torrellas jose renau cava using checkpointassisted value prediction hide l2 misses acm transactions architecture code optimization taco v3 n2 p182208 june 2006 glenn reinman brad calder predictive techniques aggressive load speculation proceedings 31st annual acmieee international symposium microarchitecture p127137 november 1998 dallas texas united states sangyeun cho penchung yew gyungho lee access region locality highbandwidth processor memory system design proceedings 32nd annual acmieee international symposium microarchitecture p136146 november 1618 1999 haifa israel ravi bhargava lizy k john latency energy aware value prediction highfrequency processors proceedings 16th international conference supercomputing june 2226 2002 new york new york usa onur mutlu hyesoon kim yale n patt addressvalue delta avd prediction increasing effectiveness runahead execution exploiting regular memory allocation patterns proceedings 38th annual ieeeacm international symposium microarchitecture p233244 november 1216 2005 barcelona spain huiyang zhou thomas conte enhancing memorylevel parallelism via recoveryfree value prediction ieee transactions computers v54 n7 p897912 july 2005 j gonzlez gonzlez controlflow speculation value prediction ieee transactions computers v50 n12 p13621376 december 2001 martin burtscher benjamin g zorn hybrid loadvalue predictors ieee transactions computers v51 n7 p759774 july 2002 huiyang zhou jill flanagan thomas conte detecting global stride locality value streams acm sigarch computer architecture news v31 n2 may ilya ganusov martin burtscher future execution prefetching mechanism uses multiple cores speed single threads acm transactions architecture code optimization taco v3 n4 p424449 december 2006 afrin naz krishna kavi junghwan oh pierfrancesco foglia reconfigurable split data caches novel scheme embedded systems proceedings 2007 acm symposium applied computing march 1115 2007 seoul korea brad calder glenn reinman dean tullsen selective value prediction acm sigarch computer architecture news v27 n2 p6474 may 1999 pedro marcuello antonio gonzlez clustered speculative multithreaded processors proceedings 13th international conference supercomputing p365372 june 2025 1999 rhodes greece andreas moshovos gurindar sohi reducing memory latency via readafterread memory dependence prediction ieee transactions computers v51 n3 p313326 march 2002 martin burtscher amer diwan matthias hauswirth static load classification improving value predictability datacache misses acm sigplan notices v37 n5 may 2002 jian huang david j lilja balancing reuse opportunities performance gains subblock value reuse ieee transactions computers v52 n8 p10321050 august smruti r sarangi wei liu josep torrellas yuanyuan zhou reslice selective reexecution longretired misspeculated instructions using forward slicing proceedings 38th annual ieeeacm international symposium microarchitecture p257270 november 1216 2005 barcelona spain timothy sherwood suleyman sair brad calder predictordirected stream buffers proceedings 33rd annual acmieee international symposium microarchitecture p4253 december 2000 monterey california united states daehyun kim mainak chaudhuri mark heinrich leveraging cache coherence active memory systems proceedings 16th international conference supercomputing june 2226 2002 new york new york usa zhang rajiv gupta whole execution traces applications acm transactions architecture code optimization taco v2 n3 p301334 september 2005 sangyeun cho penchung yew gyungho lee highbandwidth memory pipeline wide issue processors ieee transactions computers v50 n7 p709723 july 2001 sangjeong lee penchung yew augmenting trace cache highbandwidth value prediction ieee transactions computers v51 n9 p10741088 september 2002 lucian codrescu scott wills james meindl architecture atlas chipmultiprocessor dynamically parallelizing irregular applications ieee transactions computers v50 n1 p6782 january 2001 martin burtscher vpc3 fast effective tracecompression algorithm acm sigmetrics performance evaluation review v32 n1 june 2004 glenn reinman brad calder todd austin optimizations enabled decoupled frontend architecture ieee transactions computers v50 n4 p338355 april 2001 yiannakis sazeides james e smith limits data value predictability international journal parallel programming v27 n4 p229256 aug 1999 martin burtscher nana b sam automatic generation highperformance trace compressors proceedings international symposium code generation optimization p229240 march 2023 2005 suleyman sair timothy sherwood brad calder decoupled predictordirected stream prefetching architecture ieee transactions computers v52 n3 p260276 march subramanya sastry rastislav bodk james e smith rapid profiling via stratified sampling acm sigarch computer architecture news v29 n2 p278289 may 2001 martin burtscher ilya ganusov sandra j jackson jian ke paruj ratanaworabhan nana b sam vpc tracecompression algorithms ieee transactions computers v54 n11 p13291344 november 2005
optimal register assignment loops embedded code generation abstract one challenging tasks code generation embedded systems register assignment live variables registers exist variables necessarily accessed data memory loops typically executed many times often timecritical good register assignment loops exceedingly important since accessing data memory degrade performance issue finding optimal register assignment loops one minimizes number spills registers memory open time paper address issue present optimal exponential algorithm assigns registers loop bodies resulting spill code minimal also show heuristic modification performs well exponential approach typical loops scientific code b introduction typically embedded system consists embedded programmable processor interconnected memory specialized accelerators work supported part onr grant k000042879921 preliminary version paper appears proceedings 8th international symposium system synthesis isss95 authors addresses dj kolson nicolau n dutt department information computer science university california irvine irvine ca 927173425 k kennedy department computer science rice university houston permission make digital hard copy part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copyright notice title publication date appear notice given copying permission acm inc copy otherwise republish post servers redistribute lists requires prior specific permission fee acm transactions design automation electronic systems vol 1 2 april 1996 pages 251279 applicationspecific components embedded processor realized either processor core applicationspecific instructionset processor asip architecture embedded processor may resemble generalpurpose processor datapath regularity may degree irregularity datapath efficient implementation applicationspecific instructions andor features either case proces sors memory may consolidated one memory module may distributed various modules size one corresponding single register examples embedded processors consolidated memory mips rc4000 microsparcii whereas texas instruments tms series motorolas 56000 examples distributed memories currently much research focused code generation embedded systems 1 one challenging tasks generating code embedded processor register assignment assignment process program values mapped architectures registers values available appropriate registers computation number simultaneously live variables larger number registers available values reside data memory ie spilled memory requiring data transfers memory registers values updated necessary computation typically embedded processors small number registers perhaps registers restricted specialized uses limitations register assignment exceedingly critical especially innermost loops executed many times often timecritical thus mapping variables registers contains poor choices variable spills adversely affect performance compiler domain optimal register assignment solutions extensively studied horwitz et al 1966 hsu et al 1989 kennedy 1972 although approaches effective straightline code address issue optimal assignment registers loopsinnermost loops probably place extreme methods practical thus adaptation extension work problem assigning embedded processors registers program values requires overcome fundamental difficulty previous techniques address satisfactorilythat matching register usage entry exit loop iterations loop code correct mapping variables registers beginning iteration end iteration must equivalent ie right values must right places correct iterate loop code article demonstrate algorithms register assignment basic blocks given hsu et al 1989 kennedy 1972 extended assign registers loops incorporating loop unrolling tech 1 see lanneer et al 1994 liem et al 1994 marwedel 1993 marwedel goossens 1995 strik et al 1995 252 j kolson et al niques algorithm also present heuristic derived algorithm practice seems perform well exponential counterpart section 2 discuss related work section 3 describe problem addressing section 4 discusses optimal assignment registers basic blocks architectures consolidated register files section 5 extends technique loops section 6 discusses convergence optimality loop algorithm section 7 extends loop algorithm assign registers architectures multiple register files special purpose registers section 8 gives experimentation observed results section 9 concludes article 2 related work register assignment problem important issue become pervasive many areas compiler design typically number registers fixed uniform access registers available highlevel synthesis number interconnection registers synthesized code generation embedded systems embedded processors limited number registers perhaps partitioned register files specialpurpose registers compiler domain popular approach register assignment heuristic graph coloring approach briggs 1992 chaitin et al 1991 assigning registers graph coloring graph constructed node represents variable edges nodes represent overlapping respective variables lifetimes task color graph number colors equal number physical registers coloring found variable spilled memory process repeated key good register assignment scheme selection particular variable spill heuristics selection received attention briggs et al 1989 along methods coloring graph chow hennessy 1990 also loops addressed hendren et al 1992 without regard number registerto register transfers potentially required technique end iteration many researchers felt particularly critical code segments innermost loops timesensitive applications optimal assignment necessary horwitz et al 1966 present method obtaining optimal register assignment index registers minimizes number loads stores work either improves upon efficiency horwitz algorithm luccio 1967 extends basic algorithm deal simple loops kennedy 1972 loses optimality degrades performance recent research hsu et al 1989 extends basic idea horwitzs algorithm include register assignment general purpose registers highlevel synthesis problem register assignment traditionally refers determining number registers necessary save values optimal register assignment 253 timesteps kurdahi parker 1987 paulin knight 1989 order reduce interconnect multiplexor cost scattered registers researchers focused grouping registers memory mod ules 2 research addressed assignment registers loop variables whose lifetimes cyclic nature park et al 1993 stok 1990 approaches arbitrarily break cyclic variables lifetime loop boundaries creating two coupled variables assignment process tries assign register coupled variables assigned register register transfers necessarily inserted end loop correctly set next iteration techniques developed register allocation consider cases variables stored within various levels memory hierarchy work code generation embedded systems extended leftedge algorithm incorporated register classes register assignment liem et al 1994 formulated problem register assignment ilp formulation wilson et al 1994 however techniques introduce registertoregister moves loop boundaries lanneer 1994 complex searching scheme used navigate large search space many tradeoffs one register assignment work done minimizing number spills accumulatorbased architecture liao et al 1995 however none previous work addressed issue finding optimal assignment registers loops ie assignment variables registers requires registertoregister transfers minimizes cost due added spill code 3 target architecture problem description example architectural organization targeting found figure 1 architecture embedded processor interconnected program memory typically readonly memory data memory one asics embedded processor realized either processor core asip previously mentioned embedded processor may offer functionality datapath regularity generalpurpose processor gpp comparing gpp following narrower datapath bitwidth smaller instruction set fewer number registers embedded processor may offer applicationspecific instruction set degree irregularity datapath either case available register set may consolidated one register file may distributed multiple register files examples former mips rc4000 sun microsystems microsparcii examples latter texas instruments tms series motorolas 56000 thus task register assignment embedded processor corresponds ahmed chen 1991 balakrishnan et al 1988 kim liu 1993 marwedel 1984 254 j kolson et al either determining mapping program variables registers contained within one register file determining mapping program variables registers distributed register files cases honoring access ie port restrictions register files addi tion model target instruction set noperand instructions also called naddress instructions aho et al 1986 approach task register assignment follows code selection scheduling operations time steps resource shortages occur register assignment phase ie live variables registers exist thus requiring multiple variables share registers spill code explicit data transfer operations registers data memory becomes necessary given application containing loops goal minimize number transfer operations due spills registers data memory repeatedly executed within loop 3 register assignment begins analysis intermediate representation algorithm determine variable accesses execution thus deriving variable access stream intermediate representation sequence finegrain noperand instructions efficiently mapped target architecture instance risc processor target intermediate representation algorithm might sequence 3operand instructions whereas accumulatorbased pro cessor intermediate instructions might composed 1 2oper instructions example 3operand operation 5 b 1 1 variable access stream b reads variables writes denotes write variable denote concurrent accesses parentheses bracket reads writes performed parallel example operations 3 case nested loops operate innermost loop fig 1 target architecture organization optimal register assignment 255 executed concurrently variable access stream bdeac variables b e read concurrently variables c written concurrently variable access stream derived input assignment algorithm 4 optimally assigning registers basic blocks using variant algorithm presented hsu et al 1989 derive optimal ie spill minimizing algorithm assigns variables registers basic blocks algorithm call optassignbb found figure 2 optassignbb takes input variable access stream code segment mapping variables registers immediately precede segment could null signifying registers initially free algorithm builds assignment tree nodes tree correspond variable mapping configuration representing contents register found particular point execution root tree given initial mapping variables registers path tree root leaf unique mapping variables registers assignment tree built successive level tree derived examining variable stream current configurations determine contain variable consideration fig 2 register assignment algorithm 256 j kolson et al variable contained within configuration node duplicated next level tree zerocost edge connects two variable contained within node variable access miss occurs spill code might necessary configuration causing access miss variable currently configuration replaced turn access faulting variable edge joining access miss node newly created nodes represents cost spill code going first mapping second cost composed cost possibly storing replaced register live dirty 4 store algorithm andor cost possibly loading faulting variable loadcostv algorithm variable read setting load store costs one gives total cost equal number memory operations 5 thus r registers faulting configuration current level generate r configurations next level resulting optimal exponential method heuristics used prune search space horwitz et al 1966 hsu et al 1989 kennedy 1972 last variable access considered leaves assignment tree examined lowest cost node tracing path root lowest cost node yield assignment registers variables results minimal cost terms memory loads stores due spill code exhaustively generated every possible assignment figure 3a example code segment appears figure 3b contains variable access stream segment example two registers r1 r2 initially assigned b respectively optassignbb algorithm begins initial mapping constructs assignment tree figure 3c first two variable accesses variables b variables contained current configuration therefore spill code necessary however next access c causes variable access miss spill code becomes necessary two configurations generated next level corresponding assigning c r1 r2 left child assigns c r1 displacing variable need stored value consistent memory spill code generated load c cost one possibility assigning c r2 represented right child displaces variable b b dirty previously written b must stored c loaded cost two process examining next variable accesses checking whether contained within current configurations continues remainder variable access stream full tree figure 3c every variable assumed unique memory location may kept spill variable necessary dirty refers case value register inconsistent value stored memory location 5 priorities given loads stores simply changing costs optimal register assignment 257 fig 3 building assignment tree 258 j kolson et al generated figure 3c nodes dashed outlines nodes pruned tree identical nodes level generate identical subtrees within group identical nodes one lowest cost need kept breaking ties arbitrarily 5 extending basic block algorithm loops applying optassignbb algorithm body loop get optimal assignment single execution code code contained within looping construct necessary register mappings beginning end code segment match order correctly iterate segment general assignment produced optassignbb satisfy criteria ie lowest cost configuration leaf assignment tree necessarily match root thus basic algorithm adequate optimally assign registers loop code remedy one might try simply add registertoregister moves andor spill code loads andor stores enforce match however cost additional spill code may vary greatly conceivable mapping another would vary unrolling loop number times optassignbbs results ignore effect cannot guaranteed optimal another suboptimal approach force match loop top bottom choose exponential tree derived optassignbb least cost leaf node identical initial configuration leaf configurations match root configuration necessarily guaranteed lowest cost 51 algorithm immediately obvious many iterations suffice produce assignment results minimal amount spill code fact problem open issue process unwinding loop applying optassignbb continued cost may decreased iteratively unrolling one loop iteration applying optassignbb resulting code find new loop body potentially spanning several iterations original loop cost spills per iteration loop body minimal b entry exit configurations new loop match algorithm assigning registers loop code refer optassignloop found figure 4 general structure algorithm iteratively unroll loop one iteration apply optassignbb new iteration possible previous iteration exit mapping algorithm analyzes resulting exit mapping new iteration determine matches nodes iteration ancestors ie node assignment tree lies path root node also lies iteration boundary legal register assignment unrolled loop optimal register assignment 259 found exit mapping becomes one mappings used initial configuration next iteration time match found algorithm computes average cost per iteration assignment assignment may span multiple iterations loop fully unrolled assignment lowest average cost per iteration would optimal assignment loop full unrolling loop necessarily practical parameterized algorithm k number unrollings loop body perform lowest cost mapping found cutoff scheme local minimum global number iterations unrolled far k note algorithm must always get average cost less equal optassignbb would get deal strictly costs calculated optassignbb add nothing morebeyond unrolling 52 heuristic pruning although algorithm may computationally prohibitive even moderately long loops provide strong starting point determining fig 4 loop register assignment algorithm 260 j kolson et al good heuristics computational complexity algorithm arises replacement register current configuration variable read write miss occurs heuristic modification simplistic pruning strategy best configurations kept future expansion mappings particular level generated node current level access miss occurs possibilities spills considered newly generated nodes lowest cost nodes retained consideration 6 convergence optimality loop algorithm previously known whether optimal register assignment loop could accomplished regardless efficiency algorithm difficulty ensuring optimality overall loop requires matching registers top bottom loop body impose additional spills optimally minimize spills loop unwinding different register assignments unwound iteration may needed known whether finite unwinding guaranteed converge result optimal assignment answer questions introduce notion configuration graph node configuration graph corresponds specific mapping variables registers found iteration boundary directed edge configuration graph corresponds cost spill code using source node initial mapping iteration applying loop algorithm sink node one resultant nodes thus edge represents cost spill code source node initial register assignment sink node resulting iteration loop figure 5 illustrates method building configuration graph use assignment tree figure 3 labeled leaf nodes partial configuration graph shown b constructed assignment tree traversing path root configuration labeled p leaf configuration gives directed edge configuration graph p respective node weight equal cost path instance path root first leaf node left labeled q cost three thus edge configuration graph p q added edge weight three similarly edges added configuration graph traversing various paths partial configuration graph b results construct complete graph requires build assignment trees possible exit configuration 61 convergence order guarantee algorithm converges must shown unrolling new exit configurations ie mappings variables regis ters previously exist generated algorithm exhaustively replaces registers time variable access miss occurs optimal register assignment 261 conceivable mappings generated stated another way unrolling loop body assignment iteration performed costs associated going initial derived exit mappings become known thus edges configuration graph connect initial configuration possible exit configurations generated assignment algorithm applied nodes eg unroll loop body another iteration directed edges exit configurations one another obtained convergence algorithm therefore equivalent finding cycle configuration graph thus algorithm converges number variables number registers finite therefore number permutations variables registers finite although exponential 62 optimality optimal assignment one memory traffic minimized loop body unrolled optimal assignment assignment minimal memory traffic spill cost iterations fig 5 building configuration graph assignment trees 262 j kolson et al contained within unrolled loop thus optimal assignment ratio spill cost new unrolled loop body number iterations contains minimized configuration graph corresponds ratio total cost cycle number nodes cycle therefore optimal assignment found examining average costs possible cycles possible lengths configuration graph taking minimum note necessarily correspond minimal cycle length one graph 6 worstcase possible optimal cycle must make complete tour graph 7 extending model distributed memories algorithm presented earlier register assignment loops underlying assumption access available registers equivalent found instance generalpurpose processors embedded processors registers consolidated one register file variable mapped register uniformly available operation using variable however case architecture available registers partitioned disjoint register files available registers specialized purposes assumption must modified generate feasible register assignments previously assumption enough ports register file exist support reading writing variables accessed particular step however possible restrictions present number registers concurrently accessible ie number readwrite ports register file constrains number readswrites register file section discuss extension algorithm loop register assignment target embedded processor architecture contains distributed register files andor specialpurpose registers specific restrictions register accessing exist start discussing addition register classes model consider separate modifications necessary algorithms handle specialpurpose registers distributed register files 71 adding register classes model extend algorithms introduce notion register classes register classes used compilers aho et al 1986 stallman 1992 microcode synthesis feuerhahn 1988 liem et al 1994 denote functional equivalences registers however combining registers potential usages one class precise enough register assignment target architecture class see consider simple case two register files composed general purpose registers register file connected different alu clearly 6 cycle length one would imply assignment loop body minimal initial configuration naturally ie without spills moves matches exit configuration optimal register assignment 263 operation scheduled either alu must operands present respective register file however collective registers grouped one register class called generalpurpose possible necessary operands assigned way honor register classes invalid execution thus making register assignment invalid main cause problem due registers grouped equivalency rather equivalency established approach two types register classes defined connectivity register classes operation register classes connectivity register class connrc defines equivalency registers function architectures connectivity whereas operation register class operrc defines equivalency registers function operations semantics motivation deriving classes connectivity architecture defines registers may read written functional unit whereas semantics particular operation executing particular functional unit may preclude use connected registers load operation instance may require memory address reside specific register functional unit executes load operation may connected many registers serve purpose figure 6 contains algorithm derive register classes given architecture connectivity register class derived inputs outputs functional unit architecture based upon registers may accessed input output operation register classes derived examining operations functional unit execute selecting readable writable registers imposed operations semantics large number cases connrc operrc equivalent fig 6 algorithm derive register classes 264 j kolson et al 72 extension specialpurpose registers algorithm optassignbb exhaustively generates variable mappings placing variable register either read miss occurs requiring load variable variable written access registers uniform strategy correct however registers specialized usages strategy generates mappings invalid variables assigned registers cannot perform required specialized function thus necessary restrict placement variables registers variables reside registers perform necessary functionality notion register classes extend optassignbb algorithm handle registers specialized usages variable causes access miss registers perform necessary functionality considered found intersecting operation register class accessing operation connectivity register class functional unit executing operation recall perform register assignment scheduled dataflow graph thus performing register assignment operations types access variables well functional units operations execute knownretrieving information simple matter figure 7 contains extended version optassignbb algorithm register assignment specialized register usages function opof returns operation currently accesses variable v type operation functional unit executes operation found via calls functions operationtype functionalunit respec tively appropriate operation register class connectivity register class found intersected rcintersect intersection classes defines feasible registers variable v may reside variable one registers spill code necessary registers contained rcintersect candidates replacement spill code generated 73 extension multiple register files extend algorithms assign registers multiple register files requires notion node assignment tree altered assigning registers architecture consolidated register file semantics node registers uniformly available instance eight registers filled variables h mapping variables registers represented abcdefgh signifying mapped register one b mapped register two model multiple register files change information contained node reflect grouping registers register file node assignment tree composed number register sets equal number register files optimal register assignment 265 731 assigning variables figure 8 contains extended version optassignbb algorithm assigns registers multiple register files main modification required multiple register files exist registers respective register file examined determine variable resident variable contained within necessary register file rather loading memory check first made see variable contained within one register files move operation used transfer value necessary register file necessary connections exist transfer likely lower latency load slower memory otherwise variable loaded memory spill considered 7 access restrictions present register files number registers simultaneously accessed considered restrictions satisfied assignment valid maintained future assignment otherwise mapping represents assignment causes access conflict exist node removed future consideration 7 assign different costs spilling memory fetching memory fetching another register file fig 7 extending optassignbb specialpurpose registers 266 j kolson et al 732 note optimality addition register classes extension special purpose registers algorithm derives optimal ie spill minimizing results however multiple register files version algorithm presented may possible suboptimal results obtained previously variable assigned register registers viewed candidates replacement extending cases registers special purposes merely removes number registers candidates thus serves restrict growth assignment tree however case multiple register files algorithm may longer derive optimal solution one variable displaced another register file displaced variable may need stored data memory requiring load needed future however free register exists register file might possible store displaced value temporarily future use even free register remote file still possible remote variable spilled without loss performance thus freeing register general effect cascading effects become quite complex variable hopping register file register file future use extending algorithms handle would straightforward impractical fig 8 extending optassignbb multiple register files optimal register assignment 267 8 experiments results examine benefits technique conducted two sets experiments first targeted architectures consolidated register files second targeted architectures partitioned register files special use registers experiments benchmark suite consisted six numerical codes written c compiled risclike code typical code executed embedded core processors asips codes variable access streams derived used input algorithms experiment derived register assignments optimal basic block algorithm optassignbb optimal loop algorithm optassignloop heuristic version loop optimal algorithm heuristic optassignloop counted number spills ie loads stores assignments generating assignments optassignbb algorithm registers assumed empty upon initial assignment loop optassignbb guaranteed produce assignment initial exit mappings match noted point registers became full ie point live variables registers exist introduce spill code andor moves match usage minimal leaf node previously noted initial node also order create opportunity optassignbb well used enlarged loop bodies constructed unwinding loops three times thus results optassignbb whole numbers represent averages single iteration original loop 81 experimentation consolidated register file use microsparcii target code generation architecture consolidated register file microsparcii risc instruction set similar found many embedded core processors using variable access streams register assignments produced optassignbb optassignloop heuristic optassignloop algorithms register assignments number spill code operations counted section 811 compare optassignbb optassignloop results next compare heuristic version optassignloop graph coloring approach implemented gnu compiler 8 section 812 section 813 compares optimal heuristic loop versions section 814 compares number iterations spanned optimal heuristic loop assignments 811 comparison optassignbb optassignloop table contains observed results contains number spills per iteration optassignbb optassignloop well absolute percentage improvement optassignloop optassignbb 8 code produced compiler generally accepted high quality granlund kenner 1992 268 j kolson et al measured spills bb 2 spills loop spills loop general trend percentage improvement increase number registers increases ie disparity loop assignments basic block assignments increases number registers increases attributed fundamental difference optassignbb optassignloop optassignbb assigns registers without regard effect iterating register usages whereas optassignloop examines iterating effects register usages naturally discovering minimal assignment loop minimal assignments produced optassignbb guaranteed match loop entry exit points therefore spill code becomes necessary match register usage two points however optassignloop explores possibilities keeping variables registers found loop end assigns registers next iteration discovers better register usages places inserting spill code essentially optassignloop table basic block optimal vs loop optimal microsparcii optimal register assignment 269 produces superior results naturally ie without additional loads stores andor register moves finds match loop entry exit configurations assignment process 812 comparison heuristic optassignloop graph coloring gcc configured produce sparc code register assignment module modified gcc would produce code used four six eight registers 9 heuristic version optassignloop used pruning factor parameter 5 2 best configurations 10 table ii summarizes results spill code produced gcc well heuristic algorithm percentage improvement measured spills gcc 2 spills heur spills heur cases heuristic produced assignments superior gcc graph coloring approach variables assigned registers entire lifetime segments code variable assigned register currently accessed keeping variable register causes high register pressure loads stores 9 gcc produced internal compiler error real register count set two recall pruning strategy keeps best configurations considering possibilities time variable miss occurs table ii graph coloring vs heuristic microsparcii 270 j kolson et al variables currently accessed generated necessary unaccessed variable previously spilled memory segment another interesting result heuristic produces assignments better optassignbb optimal assignment basic blocks number cases comparing tables ii shows heuristic results better optimal basic block assignment average 8 although heuristic version loop algorithm able derive better results optassignbb ability find matching register assignments loop execution optassignbb algorithm 813 comparison optassignloop heuristic optassign loop table iii contains number spills per iteration optassignloop heuristic optassignloop algorithms columns table iii comparison loop assignments microsparcii optimal register assignment 271 three four respectively column five contains heuristic results percentage within optimal measured spills heur 2 spills opt spills opt measure lower numbers better ie lower number closer heuristic approximating optimal half cases 12 24 heuristic produced results equal optimal also 71 cases 17 24 within 10 optimal 92 22 24 within 20 optimal results demonstrate although optimal may computationally prohibitive simple heuristic version executes matter seconds produces results acceptably close enough optimal 814 code size loop register assignments one concern technique increase code size results loop unrolling method typically produces register assignments span multiple itera tions especially concern context embedded code generation program code resides rom thus directly affects table iv comparison loop code sizes microsparcii 272 j kolson et al rom size table iv noted number iterations spanned assignments produced optassignloop heuristic optassign loop 11 columns three four respectively column five table iv indicates whether heuristic version derived assignments amount spill code optimal majority cases 18 24 number iterations spanned versions cases heuristic version derived assignments amount spill code optimal nine cases 50 cases 5 24 heuristic spanned iterations optimal amount spill code produced three cases one case heuristic version spanned fewer number iterations optimal due nature heuristic however case heuristic version produced spill code overall number iterations spanned loop assignments ranges two five feel within acceptable limits performance gain resulting fewer memory accesses 815 runtime algorithms methods proposed exponential nature execution time techniques concern table v noted minimum average maximum execution times cpu seconds optassignbb optassignloop heuristic optassignloop algorithms well register allocation phase gcc executing sun 430 system running unix although runtimes exponential methods optassignbb optas signloop order several cpu minutes reasonable context embedded code generation longer compile times tolerated obtain highquality code also included table v average number spills per iteration register configurations previously studied results demonstrate tradeoff runtime quality produced register assignment runtimes optassignbb optassignloop order several cpu minutes quality assignments produced compared graph coloring approach least 40 better measured heuristic 2 optimaloptimal increases number registers increases also 11 results tworegister case heuristic version appear table appear table ii mentioned earlier available gcc table v comparison running times microsparcii optimal register assignment 273 heuristic version loop algorithm derives results close optimal whereas runtime comparable gccs register allocation phase 82 experimentation distributed register files use tmx320c44 example architecture distributed register files figure 9 shows simplified view architecture section 821 give brief overview purposes code generation use scaleddown versions tmx320c44 parameterize number registers register banks tables registers column denotes number ie 2 means bank contained two registerstwo extended precision two generalpurpose two auxiliary registersfor total six generated assignments optassignbb optassignloop heuristic version optassignloop section 822 compare results basic block optimal loop optimal access commercially available compiler tmx320c44 comparison heuristic another heuristic unavailable however section 823 compare results optassignloop heuristic optassignloop section 824 compares code size loop assignments 821 tmx320c44 overview figure 9 shows simplified view tmx320c44 architecture three register files extended precision registers 40bits wide used floatingpoint long integer arithmetic auxiliary registers 32bits wide used address pointers dedicated address generation hardware autoincrement autodecrement address values generalpurpose registers 32bits wide register files connected reg1 reg2 buses available multiplier alu multiplier alu may write extended precision registers fig 9 simplified view tmx320c44 274 j kolson et al one may write either auxiliary registers general purpose registers addition operand may supplied multiplier alu memory 822 comparison optassignbb optassignloop table vi contains observed results contains number spills per iteration optassignbb optassignloop well absolute percentage improvement optassignloop optassignbb measured spills bb 2 spills loop spills loop general trend percentage improvement increase number registers increases due optassignloops ability naturally match register usages loop top bottom upon inspection assignments produced noted cases assignments produced basic block scheme assigned address variable general purpose register near end iteration variable heavily used top loop spill code spills address variables currently within auxiliary registers necessary generated accommodate variable 823 comparison optassignloop heuristic optassign loop table vii presents results spill code produced optimal heuristic algorithms columns three four respectively column five contains heuristic results percentage within optimal measured spills heur 2 spills opt spills opt measure lower numbers better ie lower number closer heuristic approximating optimal cases 3 12 heuristic produced results equal optimal 58 cases 7 12 results produced within 15 optimal rest cases 5 table vi basic block optimal vs loop optimal tmx320c44 optimal register assignment 275 12 percentage within optimal higher however actual difference spill code produced one instruction 824 code size loop register assignments code size directly affects size program rom study number iterations produced loop assignments table viii contains number iterations spanned loop methods given table viii comparison loop code sizes tmx320c44 table vii comparison loop assignments tmx320c44 276 j kolson et al number registers well indication whether heuristic method produced equal amount spill code optimal majority cases 9 12 heuristic derived assignments spanned number iterations optimal generated amount spill code three cases 33 cases 3 12 heuristic assignments spanned one iteration producing amount spill code one case 33 overall range number iterations spanned assignments two four believe within acceptable limits 825 runtime algorithms note runtime algorithms case tmx320c44 results table ix contains minimum average maximum execution times cpu seconds optassignbb optassignloop heuristic optassignloop algorithms executing sun 430 system running unix included table ix average number spills per iteration register configurations previously examined tmx320c44 although another heuristic unavailable comparison heuristic loop algorithm derives results close optimal runtime efficient enough practical 826 using full register set previously experimentation used scaleddown model tmx320c44 number registers register file reduced section present results register allocation one benchmark number registers used allocation actual number tmx320c44 architecture8 auxiliary registers 12 extended precision registers 14 generalpurpose registers benchmark selected partial differential integration excerpt results experiment may found table x columns two three give number spills basic block loop methods respectively column four gives percentage improvement loop method basic block method results demonstrate presence realistic resource constraints technique derives assignment variables registers naturally match loop boundary points definite advantage optimal basic block method arbitrarily forces register usages table ix comparison running times tmx320c44 optimal register assignment 277 9 conclusion article motivated presented algorithm optimally assigns registers loops case optimal assignment one memory traffic resulting spill code minimized work answers longstanding question whether possible principle achieve optimal minimal spill code loops demonstrated feasibility using technique task register assignment embedded code generation conducting experiments risclike code typical embedded core processors also extended algorithm assign registers irregular datapaths found many asips registers specialized uses andor registers partitioned multiple register files experimentation methods demonstrated heuristic methods obtain suitable performance outperforming graph coloringbased approach used gnu c compiler gcc r compilers principles allocation multiport memories data path synthesis ieee trans register coloring via graph coloring coloring heuristics register allocation register allocation via coloring prioritybased coloring approach register alloca tion eliminating branches using superoptimizer gnu c compiler register allocation framework based hierarchical cyclic interval graphs index register allocation minimization loadsstores local register allocation spill code results using registers tmx320c44 utilization multiport memories data path synthesis real program register allocation data routing paradigm efficient datapath synthesis code generation instruction selection using binate covering code size optimization register assignment resource classification asip microcode generation comment index register allocation mimola design system tools design digital processors code generation embedded processors register allocation data flow graphs conditional branches loops using porting gnu cc interconnect optimisation data path allocation efficient code generation inhouse dspcores integrated approach retargetable code generation revised january tr real program register allocation coloring heuristics register allocation minimization loadsstores local register allocation prioritybased coloring approach register allocation utilization multiport memories data path synthesis register allocation via graph coloring register assignment resource classification asip microcode generation data routing integrated approach retargetable code generation treebased mapping algorithms predefined structures index register allocation register allocation framework based hierarchical cyclic interval graphs interconnect optimisation data path allocation ctr catherine h gebotys low energy memory register allocation using network flow proceedings 34th annual conference design automation p435440 june 0913 1997 anaheim california united states weikai cheng younlong lin code generation nested loops dsp processors heterogeneous registers structural pipelining acm transactions design automation electronic systems todaes v4 n3 p231256 july 1999
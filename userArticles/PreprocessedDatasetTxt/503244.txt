coverage criteria gui testing widespread recognition usefulness graphical user interfaces guis established importance critical components todays software guis characteristics different traditional software conventional testing techniques directly apply guis papers focus coverage critieria guis important rules provide objective measure test quality present new coverage criteria help determine whether gui adequately tested coverage criteria use events event sequences specify measure test adequacy since total number permutations event sequences nontrivial gui extremely large guis hierarchical structure exploited identify important event sequences tested gui decomposed gui components used basic unit testing representation gui component called eventflow graph identifies interaction events within component intracomponent criteria used evaluate adequacy tests events hierarchical relationship among components represented integration tree intercomponent coverage criteria used evaluate adequacy test sequences cross components algorithms given construct eventflow graphs integration tree given gui evaluate coverage given test suite respect new coverage criteria case study illustrates usefulness coverage report guide testing important correlation eventbased coverage gui statement coverage softwares underlying code b introduction importance graphical user interfaces guis critical components todays software increasing recognition usefulness widespread use guis led construction complex guis although use guis continues grow gui testing recently remained neglected research area guis characteristics different conventional software techniques developed test conventional software cannot directly applied gui testing recent advances gui testing focused development test case generators 8 11 12 14 18 6 test oracles 9 guis however development coverage criteria guis addressed coverage criteria sets rules used help determine whether test suite adequately tested program guide testing process wellknown coverage criteria statement coverage branch coverage path coverage require every statement branch path programs code executed test suite respectively however criteria address adequacy gui test cases number reasons first guis typically developed using instances precompiled elements stored library source code elements may always available used coverage evalu ation second input gui consists sequence events number possible permutations events may lead large number gui states adequate testing gui event may need tested large number states moreover event sequences gui must tested conceptually much higher level abstraction code hence cannot obtained code reason code cannot used determine whether adequate number sequences tested gui challenges suggest need develop coverage criteria based events gui development coverage criteria certain requirements first since large number possible permutations gui events gui must decomposed manageable parts guis nature hierarchical hierarchy may exploited identify groups gui events tested isolation hence group forms unit test ing decomposition also allows coverage criteria developed events within unit intuitively unit testing welldefined interface parts software may invoked units needed terminated example performing codebased testing unit testing may basic block procedure object class consisting statements branches etc next interactions among units must identified coverage developed determine adequacy tested interac tions second possible satisfy coverage criterion finitesized test suite finite applicability 20 requirement holds coverage criterion always satisfied finitesized test suite finally test designer recognize whether coverage criterion ever fully satisfied 16 17 example may always possible satisfy path coverage presence infeasible paths executable context instructions detecting infeasible paths general np complete problem test case execute along infeasible path perhaps resulting loss coverage infeasibility also occur guis similar infeasible paths code static analysis gui may reveal infeasible sequences events example performing static analysis menu structure ms word pad one may construct test case paste first event however experience using software shows test case execute since paste highlighted cut copy 1 paper define new class coverage criteria called eventbased coverage criteria determine adequacy tested event sequences focusing guis key idea define coverage test suite terms gui events interactions since total number permutations event sequences nontrivial gui extremely large guis hierarchical structure exploited identify important event sequences tested gui decomposed gui components 2 unit testing events within component interleave events components without explicit invocation termination events welldefined behavior component may tested isolation two kinds coverage criteria developed decomposition intracomponent coverage criteria events within component intercomponent coverage criteria events among components intracomponent criteria include event eventselection lengthn eventsequence coverage intercomponent criteria include invocation invocationtermination lengthn eventsequence coverage gui component represented new structure called eventflow graph identifies events within component interactions among gui components captured representation called integration tree present algorithms automatically construct eventflow graphs integra 1 note paste available clipboard empty perhaps external software external software ignored simplified example components confused gui elements used building blocks gui develop ment later provide formal definition gui component tion tree given gui evaluate intra intercomponent coverage given test suite present case study demonstrate correlation eventbased coverage version wordpads gui statement coverage underlying code test suite important contributions coverage method presented paper include 1 class coverage criteria gui testing terms gui events 2 identification gui component useful gui testing 3 representation gui component called event flow graph captures flow events within component representation called integration tree identify interactions components 4 automated technique decompose gui interacting components coverage criteria intracomponent intercomponent testing 5 technique compute coverage given test suite 6 case study demonstrating correlation coverage terms events code next section present classification gui events use classification identify gui components section 3 present coverage criteria event interactions within component components section 4 presents algorithms construct eventflow graphs integration tree given gui evaluate intra intercomponent coverage gui given test suite section 5 present details case study conducted version wordpad software lastly section 6 presents related work section 7 conclude discussion ongoing future work 2 structure guis gui uses one metaphors objects familiar real life buttons menus desktop view window software user performs events interact gui manipulating gui objects one would real objects events may cause deterministic changes state software may reflected change appearance one gui objects moreover guis nature hierarchical hierarchy reflected grouping events windows dialogs hierarchical menus example options ms internet explorer set interacting events one window softwares gui important characteristics guis include graphical orientation eventdriven input hierarchical structure objects contain properties attributes objects formally gui may defined follows graphical user interface gui hierar chical graphical frontend software accepts usergenerated systemgenerated events fixed set events input produces deterministic graphical output gui contains graphical objects object fixed set properties time execution gui properties discrete values set constitutes state gui 2 definition specifies class guis fixed set events deterministic outcome performed objects discrete valued properties paper develops coverage criteria class guis defined section new unit testing called gui component defined consists number events selections invocations terminations restrict focus gui user user interacts component explicitly invoking performing events terminating component note since events within component cannot interleaved events components interaction among events within component may tested independently components classification gui events used identify gui components gui events may classified menuopen events open menus ie expand set gui events available user definition menuopen events interact underlying software common example menuopen events generated buttons open pulldown menus eg file edit restrictedfocus events open modal windows ie windows special property invoked monopolize gui interaction restricting focus user specific range events within window window explicitly terminated termination event preference setting example restrictedfocus events many gui systems user clicks edit preferences window opens user spends time modifying prefer ences finally explicitly terminates interaction either clicking ok cancel unrestrictedfocus events open modeless windows restrict users focus merely expand set gui events available user note difference menuopen events unrestrictedfocus events latter open windows explicitly terminated exam ple ms powerpoint software basic shapes displayed unrestrictedfocus window systeminteraction events interact underlying software perform action common examples include cutting pasting text opening object windows termination events close modal windows common examples include ok cancel times interaction gui user interacts events within limited focus limited focus consists restrictedfocus window x set unrestrictedfocus windows invoked either directly indirectly x limited focus remains place x explicitly terminated using termination event ok cancel close intuitively events within limited focus form gui component component c ordered pair rf uf rf represents modal window terms file edit help open save cut copy paste help figure 1 eventflow graph part ms wordpad events uf set whose elements represent modeless windows also terms events element uf invoked either event uf common example gui component fileopen modal window associated modeless windows found todays software user interacts events within component selects file terminates component performing open event sometimes cancel event formally gui component represented flow graph eventflow graph gui component c 4tuple v e b 1 v set vertices representing events component v 2v represents event c 2 set directed edges vertices say event e follows e j iff e j may performed immediately e edge event represented vy follows event represented vx 3 set vertices representing events c available user component first invoked 4 v set restrictedfocus events componentan example eventflow graph part maincomponent ms wordpad shown figure 1 top three vertices file edit help represent part pulldown menu ms wordpad menuopen events available main component first invoked hence form set b file performed wordpad edit help open save may performed hence edges eventflow graph file events note open shown dashed oval use representation restrictedfocus events ie events invoke components similarly contents also 3 assume guis main component ie component presented user gui first invoked main filenew fileopen print formatfont properties filesave pagesetup viewoptions figure 2 integration tree part ms wordpad restrictedfocus events ie component fopen contentsg events ie save cut copy paste systeminteraction events performed ms wordpad user may perform file edit help shown edges eventflow graph components gui represented eventflow graphs remaining step identify interactions testing interactions among components also area research objectoriented software testing 5 interprocedural dataflow testing 4 identification interactions among objects procedures aided structures functiondecomposition trees callgraphs 4 similarly develop structure identify interactions among components call structure integration tree shows gui components integrated form gui formally integration tree defined integration tree 3tuple n set components gui r 2 n designated component called main component say component cx invokes component cy cx contains restrictedfocus event ex invokes cy b set directed edges showing invokes relation components ie cx cy invokes cy 2 figure 2 shows example integration tree representing part ms wordpads gui nodes represent components ms wordpad gui edges represent invokes relationship components main toplevel component available word pad invoked components names indicate functionality example fileopen component wordpad used open files tree figure 2 edge main fileopen showing main contains event namely open see figure 1 invokes fileopen 3 coverage criteria created representations gui components events among components ready define coverage criteria first define coverage criteria events within component ie intracomponent coverage criteria events among components ie intercomponent criteria 31 intracomponent coverage section define several coverage criteria events interactions within component first formally define event sequence eventsequence en new coverage criteria define next based eventsequences 311 event coverage intuitively event coverage requires event component performed least requirement necessary check whether event executes expected set p eventsequences satisfies event coverage criterion events v 2 v least one eventsequence event v p 2 312 eventselection coverage another important aspect gui testing check interactions among possible pairs events com ponent however want restrict checks pairs events may performed sequence focus possible implicit selection events user may encounter interaction gui definition eventselections event e set criterion require event e performed eventselections e executed least note requirement equivalent requiring element e covered least one test case set p eventsequences satisfies event selection coverage criterion elements least one eventsequence contains 313 lengthn eventsequence coverage certain cases behavior events may change performed different contexts cases event coverage eventselection coverage weak requirements sufficient testing define criterion captures contextual impact first formally define context definition context event en eventsequence intuitively context event e sequence events performed e event may performed infinite number contexts finite applicability define limit length eventsequence hence define lengthn eventsequence criterion set p eventsequences satisfies lengthn eventsequence coverage criterion p contains eventsequences length equal n 2 note similarity criterion lengthn path coverage criterion defined gourlay conventional software 2 requires coverage subpaths programs flowgraph length less equal n length eventsequence increases number possible contexts also increases 32 subsumption coverage criterion c1 subsumes criterion c2 every test suite satisfies c1 also satisfies c2 13 since event coverage eventselection coverage special cases lengthn eventsequence coverage ie length 1 eventsequence length 2 eventsequence coverage respectively follows lengthn eventsequence coverage subsumes event eventselection coverage moreover test suite satisfies eventselection coverage must also satisfy event coverage hence eventselection subsumes event coverage 33 intercomponent criteria goal intercomponent coverage criteria ensure interactions among components tested guis interactions take form invocation components termination components eventsequences start event one component end event another component 331 invocation coverage intuitively invocation coverage requires restricted focus event gui performed least requirement necessary check whether component invoked set p eventsequences satisfies invocation coverage criterion restricted focus events 2 set restricted focus events gui least one event sequence event p 2 note event coverage subsumes invocation coverage since requires events performed least including restrictedfocus events 332 invocationtermination coverage important check whether component invoked terminated definition invocationtermination set gui set possible length 2 event sequences component cx e j terminates component cx components cx 2 n intuitively invocationtermination coverage requires length 2 event sequences consisting restrictedfocus event followed invoked components termination events tested set p eventsequences satisfies invocation termination coverage criterion 2 least one eventsequence p 2 satisfying invocationtermination coverage criterion assures component invoked least terminated immediately allowed guis specifica tions example wordpad component fileopen invoked event open terminated either open cancel note wordpads specification allow open terminate component unless file se lected hand cancel always used terminate component v vertex eventf 1 systeminteraction 7 returnb invoking invoked component 12 returnb invoked component 14 figure 3 computing follow setv vertex v 333 intercomponent lengthn eventsequence cov erage finally intercomponent lengthn eventsequence coverage criterion requires testing eventsequences start event one component end event another component note eventsequence may use events number components criterion defined cover interactions set p eventsequences satisfies intercomponent lengthn eventsequence coverage criterion components c1 c2 p contains lengthn eventsequences may belong c1 c2 component c 2 note intercomponent lengthn eventsequence coverage subsumes invocationtermination coverage since lengthn event sequences also include length 2 sequences 4 evaluating coverage formally presented intra intercomponent coverage criteria present algorithms evaluate coverage test suite using criteria section present algorithms evaluate coverage gui given test suite show construct event flow graph use evaluate intracomponent coverage show construct integration tree use evaluate intercomponent coverage 41 construction eventflow graphs construction eventflow graphs based structure gui classification events previous section aids automated construction eventflow graphs describe next v 2 v define follow setv set events vx vx follows v note follow setv set outgoing edges eventflow graph determine follow setv using algorithm figure 3 vertex v recursive algorithm contains switch structure assigns follow setv according type event type event v menuopen event line represents events available component invoked user may either perform v submenu choices event b line 4 however v 62 b user may either perform submenu choices v v events follow setparentv line 6 define parentv event makes v available v systeminteraction event performing v gui reverts back events b line 8 v exit event ie event terminates component follow setv consists toplevel events invoking component line 10 event type v unrestrictedfocus event available events toplevel events invoked component available well events invoking component line 12 lastly v restrictedfocus event events invoked component available 42 evaluating intracomponent coverage constructed eventflow graph ready evaluate intracomponent coverage given test suite using elements graph figure 4 shows dynamic programming algorithm compute percentage lengthn eventsequences tested final result algorithm matrix matrix ij percentage lengthj eventsequences tested component main algorithm computepercentagetested algorithm two matrices computed line 67 count ij number lengthj eventsequences component covered test suite line 6 total ij total number possible lengthj eventsequences component line 7 subroutine computecounts calculates elements count matrix test case computecounts finds possible eventsequences different lengths line 1921 number event sequences length counted lines 22 23 tuitively computetotals subroutine starts singlelength eventsequences ie individual events gui lines 3133 using follow set line 38 event sequences lengthened one event step counter keeps track number eventsequences created line 39 note since computecounts takes union event sequences danger counting event sequence twice result algorithm matrix entries interpreted follows event coverage requires individual events gui exercised individual events correspond length 1 eventsequences gui matrix j1 j 2 represents percentage individual events covered component eventselection coverage requires edges eventflow graph covered least one test case edge effectively captured length2 eventsequence matrix j2 j 2 represents percentage branches covered component j lengthn eventsequence coverage available directly matrix column matrix represents number lengthi eventsequences gui set components 2 test maximum eventsequence length 4 fcount gamma computecountst 56 count ij tested number lengthj eventsequences component total total ij total number lengthj eventsequences component matrix ij gamma count ij total ij theta 100 10 returnmatrixg 11 test maximum eventsequence length 14 gamma fg empty set 17 count number sets length j count ij gamma numberofsetsoflengths j 23 returncountg set components 26 maximum eventsequence length 27 28 x total jk gamma total jk newfreq gamma 0 44 returntotalg figure 4 computing percentage tested lengthn eventsequences components 43 evaluating intercomponent coverage components gui identified integration tree may constructed adding restrictedfocus event ex element cx cy b cx component contains ex cy component invokes integration tree may used several ways identify interactions among components example figure 2 subset possible pairs components interact would f main filenew main fileopen main print main formatfont print g identify sequences ones main properties traverse integration tree bottomup manner identifying interactions among print properties merge print properties form supercomponent called printproperties check interactions among main printproperties process continues components merged single supercomponent evaluating intercomponent coverage given test suite requires computing 1 invocation coverage 2 invocation termination coverage 3 lengthn event sequence cover age total number length 1 event sequences required satisfy invocation coverage criterion equal number restrictedfocus events available gui percentage restrictedfocus events actually covered test cases xi theta 100 x number restricted focus events test cases total number restrictedfocus events available gui similarly total number length 2 event sequences required satisfy invocationtermination criterion number restrictedfocus termination events invoke terminate component c respectively percentage invocationtermination pairs actually covered test cases x x number invocationtermination pairs test cases computing percentage lengthn event sequences slightly involved algorithm shown figure 5 computes percentage lengthn event sequences tested among gui components intuitively algorithm obtains number event sequences end certain restricted focus event counts number event sequences extended sequences invoked component main algorithm called integrate recursive performs bottomup traversal integration tree line 2 recursive call line 8 integrate makes call computetotalinteractions takes two components parameters lines 1314 initializes vector total path lengths 1 line 1617 assume freq matrix stored component freq matrix similar freq vector already computed algorithm figure 4 freq ij number eventsequences start event end event j obtaining frequency matrices c1 c2 path lengths lines 2126 new vector total obtained adding frequency entries f1 f2 lines 2830 new frequency matrix computed supercomponent new frequency matrix utilized algorithm integrate c1c2 components results algorithm summarized trix matrix ij percentage lengthj eventsequences tested supercomponent represented label 5 case study performed case study version wordpad determine 1 total number event sequences required integration tree 2 computetotalinteractionsnewt c 9 matrixnewtc component component total x get freq table c1 eventseq length 20 add values column x 22 get freq table c2 eventseq length j 25 28 total ij gamma total ij computefreqmatrixc1 c2 31 figure 5 computing percentage tested lengthn eventsequences components test gui hence enable test designer compute percentage event sequences tested 2 correlation eventbased coverage gui statement coverage underlying code 3 time taken evaluate coverage given test suite usefulness coverage report guide testing case study employed specifications implementation wordpad software software consists 36 modal windows 362 events counting shortcuts implementation wordpad similar microsofts wordpad except help menu model 51 computingtotalnumber eventsequences wordpad case study wanted determine total number event sequences new criteria specify test parts wordpad performed following steps components events individual word pad components events within component identified table 1 shows components wordpad used case study row represents component column shows component name open system interaction restricted focus unrestricted focus termination sum main 7 fileopen filesave properties sum 7 78 event type table 1 types events components ms wordpad different types events available within component creating eventflow graphs next step construct eventflow graph component figure 1 showed part eventflow graph important component ie main recall node eventflow graph represents event computing eventsequences eventflow graphs available computed total number possible eventsequences different lengths component using computetotals subroutine figure 4 note eventsequences may also include infeasible eventsequences total number eventsequences shown table 2 rows represent components shaded rows represent intercomponent interactions columns represent different eventsequence lengths recall eventsequence length 1 represents event coverage whereas eventsequence length 2 represents eventselection coverage columns 1 2 represent invocation invocationtermination coverage respectively results case study show total number event sequences grows increasing length note longer sequences subsume shorter sequences eg event sequences length 5 tested sequences lengthi 4 difficult determine maximum length event sequences needed test gui large number event sequences show impractical test gui possible event sequences rather depending resources subset important event sequences identified generated executed identifying important sequences requires ordered assigning priority event sequence example event sequences performed main component may given higher priority since used frequently users start interacting gui using main component components deepest integration tree may used least observation leads heuristic ordering testing event sequences within components gui structure integration tree may used assign priorities components main highest priority decreasing components second level deepest components lowest priority large number component name 1 main 56 791 14354 255720 4490626 78385288 fileopen filesave print 12 108 972 8748 78732 708588 properties 13 143 1573 17303 190333 2093663 pagesetup 11 88 704 5632 45056 360448 formatfont 9 63 441 3087 21609 151263 printproperties mainfilesave mainformatfont mainprintproperties 12 145 1930 28987 466578 eventsequence length table 2 total number eventsequences selected components wordpad shaded rows show number interactions among components event sequences high priority components may tested first number decrease low priority components 52 correlation eventbased coverage statement coverage case study wanted determine exactly percentage underlying code executed event sequences increasing length executed gui wanted see whether testing longer sequences adds coverage underlying code performed following steps code instrumentation instrumented underlying code wordpad produce statement trace ie sequence statements order executed examining trace allowed us determine statements executed test case eventsequence generation wanted generate eventsequences specific length modified computetotals figure 4 resulting event sequence generation algorithm constructs event sequences increasing length dynamic programming algorithm constructs event sequences length 1 uses follow set extend event sequence one event hence creating length 2 event sequences generated eventsequences length 3 obtained 21659 eventsequences controlling guis state bringing software state test case may executed traditionally known controllability problem 1 problem also occurs guis test case appropriate events may need performed gui bring state call sequence events prefix p test case although generating prefix general may require development expensive solutions used heuristic study executed test case fixed state s0 wordpad contains text part text highlighted clipboard contains text object file system contains two text files traversed eventflow graphs integration tree produce prefix test case however note using heuristic may render eventsequence length percentage statements executed figure correlation eventbased coverage statement coverage wordpad event sequences nonexecutable infeasibility later see sequences exist consequence results study modified wordpad statement trace produced p testcase execution eventsequences length 3 obtained executed gui using automated test executor 10 obtained execution traces test case executor executed without intervention hours note 193 test cases could executed infeasibility analysis analyzing traces study determined new statements executed eventsequences length 1 ie individual events graph figure 6 shows almost 92 statements executed individual events length event sequences increases new statements executed 5 hence high statement coverage underlying code may obtained executing short event sequences results case study explained terms design wordpad gui since gui eventdriven software method called event handler implemented event executing event caused execution corresponding event handler code inspection wordpad implementation revealed branch statements code event han dler consequently event performed statements eventhandler executed hence high statement coverage obtained performing individual events whether guis exhibit similar behavior requires detailed analysis number guis underlying code result shows statement coverage underlying code misleading coverage criterion gui test ing test designer relies statement coverage underlying code gui testing may test short event sequences however testing short sequences enough longer event sequences lead different states gui testing sequences may help detect larger number faults short event sequences component name 1 main fileopen 9 filesave 9 33 132 print 11 37 313 787 3085 1314 properties 12 printproperties mainfilesave mainprintproperties 6 56 123 189 423 eventsequence length table 3 number eventsequences selected components wordpad covered test cases example wordpad event find next obtained clicking edit menu executed least 6 events performed shortest sequence events needed execute find next edit find typeintext findnext2 ok edit find next 7 events short sequences executed gui bug find next may detected extensive studies faultdetection capabilities executing short long event sequences gui testing needed targeted future work another possible extension experiment determine correlation eventbased coverage codebased coverage eg branch coverage 53 evaluating coverage test suite wanted determine time taken evaluate coverage given test suite resulting coverage report could guide testing used earlier developed planningbased test case generation system called planning assisted tester graphical user interface systemspaths generate test cases 8 performed following steps tasks paths commonly used tasks identified task activity performed using events gui paths test designer inputs tasks pairs g initial gui state task performed g final gui state task performed carefully identified 72 different tasks making sure task exercised least one unique feature wordpad example one task modified font text another printed document size paper generating test cases multiple test cases generated using plan generation system achieve tasks manner generated 500 test cases multiple cases task coverage evaluation test cases available executed algorithms figures 4 5 algorithms implemented using perl mathematica 19 executed sun ultrasparc workstation sparc ultra running sunos 551 even component name 1 main fileopen 90 56 1750 072 006 filesave 90 41 2063 127 047 002 print properties pagesetup 91 formatfont printproperties 100 0 46 5115 818 387 mainfileopen mainfilesave 100 0 20 1300 864 126 028 mainformatfont 100 0 33 2840 517 097 010 mainprintproperties 50 3862 637 065 009 eventsequence length table 4 percentage total eventsequences selected components wordpad covered test cases inefficiencies inherent perl mathematica implementation could process 500 test cases 47 minutes clock time results applying algorithms summarized coverage reports tables 4 table 3 shows actual number eventsequences test cases covered table 4 presents data percentage total number eventsequences column 1 table 4 shows close 90 event coverage remaining 10 events cancel never used planner since contribute goal column 2 shows eventselection coverage test cases achieved 4055 coverage note since components invoked least 100 invocation coverage column 1 obtained however none components terminated immediately invoked hence invocationtermination coverage column 2 obtained result shows coverage large test suite obtained reasonable amount time looking columns 4 5 6 table 4 note small percentage length 4 5 6 event sequences tested test designer evaluate importance testing longer sequences perform additional testing also twodimensional structure table 4 helps target specific components componentinteractions example 60 length 2 interactions among main pagesetup tested whereas 11 interactions among main fileopen tested depending relative importance components interactions test designer focus testing specific parts gui 6 related work little research reported developing coverage criteria gui exception work ostrand et al briefly indicate modelbased method may useful improving coverage test suite 12 however deferred detailed study coverage generated test cases using type gui model future work close relationship testcase generation techniques underlying coverage criteria used much literature gui test case generation focuses describing algorithms used generate test cases 14 6 little discussion underlying coverage criteria presented next paragraphs present discussion methods used develop test cases guis underlying coverage criteria also present discussion automated test case generation techniques offer unique perspective gui coverage commonly available tools aid test designer gui testing process include recordplayback tools 15 3 tools record user events gui screens interactive session recorded sessions later played back whenever necessary generate gui events recordplayback tools provide functionality evaluate coverage test suite primary reason coverage support tools lack global view gui test cases constructed individually local perspective several attempts made provide sophisticated tools gui testing one popular technique programming test case generator 7 test designer develops programs generate test cases gui use loops conditionals data selection switches test case generation program gives test designer broader view generated test cases coverage several finitestate machine fsm models also proposed generate test cases 14 fsm built coverage test suite evaluated number states visited test case method evaluating coverage test suite needs studied accurate representation guis navigation results infinite number states white et al presents new test case generation technique guis 18 test designerexpert manually identifies responsibility ie gui activity responsibility machine model called complete interaction sequence cis identified manually reduce size test suite cis reduced using constructspatterns cis example presented therein showed testing could performed using 8 test cases instead 48 ever discussion loss coverage occur reduction moreover loss coverage may occur identifying responsibilities creating cis merit technique perhaps clearer interactions cis investigated 7 conclusion paper presented new coverage criteria gui testing based gui events interactions unit testing called gui component defined identified events within component represented eventflow graph three new coverage criteria de fined event eventselection lengthn eventsequence coverage defined integration tree identify events among components defined three intercomponent coverage criteria invocation invocationtermination intercomponent lengthn eventsequence coverage future plan examine effects guis structure testability guis become struc tured integration tree becomes complex intercomponent testing becomes important also plan explore possibility using eventbased coverage criteria software guis foresee use criteria 1 objectoriented soft ware use messagesevents communication among objects 2 networking software use messages communication 3 broader class reactive soft ware responds events 8 r framework testing database applications mathematical framework investigation testing integrated data capture analysis tools research testing graphical user interfaces interprocedual data flow testing toward automatic generation novice user test scripts black art gui testing using goaldriven approach generate test cases guis automated test oracles guis planningbased approach gui testing hierarchical gui test case generation using automated planning visual test development environment gui systems selecting software test data using data flow information method automate user interface testing using variable finite state machines applicability program schema results programs translatability decidability questions restricted classes program schemas generating test cases gui responsibilities using complete interaction sequences system mathematics computer test data adequacy measurements tr selecting software test data using data flow information mathematica system mathematics computer integrated data capture analysis tools research testing graphical user interfaces test data adequacy measurement objectoriented integration testing toward automatic generation novice user test scripts visual test development environment gui systems using goaldriven approach generate test cases guis framework testing database applications automated test oracles guis hierarchical gui test case generation using automated planning method automate user interface testing using variable finite state machines generating test cases gui responsibilities using complete interaction sequences ctr yanhong sun edward l jones specificationdriven automated testing guibased java programs proceedings 42nd annual southeast regional conference april 0203 2004 huntsville alabama aine mitchell james f power approach quantifying runtime behaviour java gui applications proceedings winter international synposium information communication technologies january 0508 2004 cancun mexico philippe palanque regina bernhaupt ronald boring chris johnson testing interactive software challenge usability reliability chi 06 extended abstracts human factors computing systems april 2227 2006 montral qubec canada ping li toan huynh marek reformat james miller practical approach testing gui systems empirical software engineering v12 n4 p331357 august 2007 christopher j howell gregory kapfhammer robert roos examination runtime performance gui creation frameworks proceedings 2nd international conference principles practice programming java june 1618 2003 kilkenny city ireland geoffrey r gray colin higgins introspective approach marking graphical user interfaces acm sigcse bulletin v38 n3 september 2006 atif memon mary lou soffa regression testing guis acm sigsoft software engineering notes v28 n5 september mikael lindvall ioana rus paolo donzelli atif memon marvin zelkowitz aysu betincan tevfik bultan chris ackermann bettina anders sima asgari victor basili lorin hochstein jrg fellmann forrest shull roseanne tvedt daniel pech daniel hirschbach experimenting software testbeds evaluating new technologies empirical software engineering v12 n4 p417444 august 2007 qing xie atif memon designing comparing automated test oracles guibased software applications acm transactions software engineering methodology tosem v16 n1 p4es february 2007 atif memon adithya nagarajan qing xie automating regression testing evolving gui software research articles journal software maintenance evolution research practice v17 n1 p2764 january 2005 atif memon adithya nagarajan qing xie automating regression testing evolving gui software journal software maintenance research practice v17 n1 p2764 january 2005
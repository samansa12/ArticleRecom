recognizing design decisions programs authors present characterization design decisions based analysis programming constructs characterization underlies framework documenting manipulating design information facilitate maintenance reuse activities identify describe following categories design decisions composition decomposition encapsulation interleaving generalization specialization representation data procedures function relation authors discuss recognize represent design decisions b express solutions problems concerns target machine characteristics intrude middle ground specifications code nebulous webster 1 surveys variety notations graphical representations used design process whole described repeatedly taking description intended behavior whether specification intermediate representation code refining refinement reflects explicit design decision limits solution class implementations within universe possibilities design involves making choices among alternatives often however alternatives considered rationale final choice lost one reason design information lost design representations currently use expressive enough adequate describing cumulative results set decisions particularly regard structure components interact attempt represent incremental changes come individual design decisions also fail describe process decisions reached including relevant problem requirements relative merits alternative choices well known tendency system structure deteriorate time accelerated original structure intent design retained code design decisions made isolation often solution idea best expressed several interrelated decisions unless interdependencies explicitly documented unwary maintenance programmer fail notice implications proposed change design ideas expressed via interrelated decisions called delocalized information balzer 2 delocalized plans soloway 3 design decisions rationale captured initial program development suitable notational mechanism existed describe interdependencies several aspects software engineering would profit first initial development would benefit increased discipline facilitated communication provided notation opportunities software reuse would multiplied availability design information could reused transformed meet new requirements finally software maintenance would vastly improved explicit recognition dependencies availability rationale studying various areas computer science reveals several categories design decisions abstraction mechanisms programming languages provide evidence need express design ideas code semantic relationships data base theory support modeling information structures variety fields finally examination tools used reverse engineering software maintenance indicate decisions found useful understanding existing programs 21 composition decomposition probably common design decision made developing program split pieces done example breaking computation steps defining data structure terms fields introducing construct later decomposing supports abstraction allowing decisions deferred details hidden complexity managed using appropriate name stand collection lower level details topdown approach taken design program decomposed pieces bottomup approach used program composed available subcomponents regardless approach result relationship established abstract element several detailed components data control structures programming language features support decisions exam ple loop mechanism breaking complex operation series simpler steps likewise arrays record structures ways collecting related data elements single item course building expression variables constants operators example composition building system library components 22 encapsulation interleaving structuring program involves drawing boundaries around related constructs welldefined boundaries interfaces serve limit access implementation details providing controlled access functionality clients terms encapsulation abstract data types information hiding related concept encapsulation decision gather selected parts program component variously called package cluster module components behavior restricted protocol interface parts system interact component limited ways parnas 4 introduced term information hiding describe approach structuring system encapsulation useful aid program comprehension maintenance decision encapsulate implementation program component reflects belief encapsulated construct thought whole behavior described specification much smaller total amount code contained within component component hides details major design decision decision altered later maintenance sideeffects change limited alternative encapsulation interleaving sometimes useful usually reasons efficiency intertwine two computations example often useful compute maximum element vector well position vector could computed separately natural save effort single loop interleaving way makes resulting code harder understand modify number useful interleaving transformations collected feather 5 23 generalization specialization one powerful features programming languages ability describe whole class computations using subprogram parameterized arguments although procedures functions usually thought abstractions expressions ability pass arguments really example generalization decision concerning aspects computation parameterize one architectural decisions made software design generalization design decision program specification satisfied relaxing constraints example program might required compute logarithm limited set numbers requirement could satisfied providing access general purpose library function computing logarithms library function would capable computing logarithms set required numbers well many others decision use library function generalization decision abstractions numerical computations may also parameterized ada programming language provides generic facility allows data types functions parameterize packages subprograms many languages provide macro capabilities parameterize textual substitutions variant records pascal ada type unions c examples use single general construct express set special cases depending value discriminant field another example generalization concerns interpreters virtual machines often useful designer introduce layer functionality controlled welldefined protocol protocol thought programming language virtual machine implemented layer decision introduce protocol reflects desire provide generality set disparate procedures would offer specialization design decision related generalization specialization involves replacing program specification restricted one often algorithm optimized based restrictions problem domain facilities programming language although optimizations dramatically improve performance cost lengthening program text making harder understand another manifestation seen early stages design process often specifications expressed terms idealized objects infinite sets real numbers actual programs space precision limitations thus program necessarily special case general computational entity objectoriented programming languages smalltalk c designer provided collection existing class definitions class provides implementation objects belong knowledgable developers quickly implement new classes specializing existing classes new class said inherit common functionality general predecessor generalization specialization decisions longterm implications program developed easier reuse adapt generalized component restricted one generality cost however generalized components may less efficient specially tuned versions moreover often effort required test component intended wide application specific counterpart 24 representation representation powerful comprehensive design decision representation used one abstraction concept better able express problem solution another may arise target abstraction ably captures sense solution efficiently implemented target machine example programmer may choose linked list implement pushdown stack bit vectors used represent finite sets representation decision use one construct place another functionally equivalent one representation must carefully distinguished specialization possibly infinite pushdown stack implemented fixed length array two decisions made first decision purposes program bounded length stack serve specialization decision bounded stack readily implemented fixed length array index variable representation choice distinction specialization representation kept mind representation seen flexible symmetric decision one context may appropriate represent one construct another different situation inverse representation might used example operations vectors usually implemented loop presence vector processing hardware however compiling system may invert representation reconstruct vector operation another example representation comes early stages design formal program specifications often couched terms universal existential quantification eg employees make 50000 per year programming languages typically use loops recursion represent specifications 25 data procedure variables necessary order write programs values always explicitly recomputed program variables cost terms amount effort required comprehend modify program hand serve improve efficiency program judicious choice names serve clarify intent programmers must aware invariants relating program variables inserting statements program example suppose maintenance programmer investigating loop reads records file keeps count number records read programmer asked make loop disregard invalid records counter used satisfy design dependencies loop parts program programmer must modify semantics counter programmer must choose among three alternatives counting total number records counting number valid records make correct choice programmer must determine counter used later program case programmer replace references variables computations produced recent values resulting statements rearranged order reconstruct highlevel operations applied file done programmer confront semantic problems raised distinction valid invalid records semantic problems solved components delocalized assignment statements reintroduced introduction variables constrains sequence computations may made increases possibility errors modifications made maintenance accidently violate implicit ordering constraint variables computed wrong order alternative introducing variable recompute values needed sometimes used make program readable reader search program declaration assignments variable directly use local information optimizing compilers often reduce cost associated recomputation particularly constant expressions involved decision repeat computation save result computation variable reflects deeper concept duality data procedure implementation finite state machine example dataprocedure decision apparent dataoriented approach possibilities machines next state recorded two dimensional array often called nextstate table alternatively nextstate information computed directly code states although may seem unusual exactly technique used speed lexical analyzers token classes first represented regular expressions states state machine states compiled directly caseswitch statements target programming language reason efficiency procedural version cost indexing array avoided 26 function relation logic programming languages allow programs expressed relations sets data example sorting described relationship two sets contain members one ordered prolog might described following rule s1 given input sorted version s2 produced instead ordered version s2 provided unordered permutations produced s1 decision variable input output left user runtime instead developer design time formal functional specifications often nondeterministic regard preferred di rection designer may use function instead relation express may reflect implementation bias rather requirement course traditional programming languages support nondeterministic relationships even prolog may impossible given problem write set rules works equally well directions thus designer usually responsible selecting preferred direction causality variables input output alternative approach provide separate functions support directions example student grading system may useful provide function given numeric grade indicates percentage students making grade higher may also value provide inverse function given percentage returns numeric grade would separate proportion students software maintenance reuse activities require detection design decisions existing code part reverse engineering reverse engineering process constructing higher level description program lower level one typically means constructing representation design program source code process bottomup incremental low level constructs detected replaced highlevel counterparts process repeated gradually overall architecture program emerges programming languagedependent details program taken paper basili mills 6 use flow analysis techniques program proving guide comprehension process document results used realistic example production software design decisions recognized program shown figure 1 022 c 043 absxm le tol1 go 90 048 abse lt tol1 go 70 053 078 p ge abs05eq go 70 100 90 figure zeroin finds root function f successively shrinking interval must oc cur using one several approaches bisection linear interpolation inverse quadratic interpolation interleaving approaches complicates program 31 interleaving program fragments casual examination program indicates contains two write statements provide diagnostic information program run fact statements display progress program makes narrowing interval containing root execution write statements controlled variable ip ip one programs input parameters examination program indicates altered program used purpose leads conclusion overall program decomposed two pieces root finder debugging printout make analysis rest program simpler diagnostic portion removed text considered involves removing statements numbered 016 017 029 030 modifying line 001 remove reference ip lines removed analyzable fact job producing debugging printout decomposed two tasks first produces header line second prints description interval upon every iteration loop 32 representation structured control flow fortran basili mills begin analysis examining control flow program fact version fortran used program limited set control structures forces programmers use goto statements simulate full range structured programming constructs zeroin example lines 010012 implement repeatuntil loop lines 031037 serve ifthen statement lines 050068 ifthenelse lines result representation decisions original developer detected straightforward analysis typically performed flow analysis phase compiler another technique expressing control flow illustrated program several cases lines 043044 048049 077078 elaborate branch condition broken two consecutive statements branching place pair could easily replaced single multiple conditions thus simplifying control flow structure program expense complicating condition tested 33 interleaving code sharing analysis control flow program indicates lines 085 086 comprise else part ifthenelse statement moreover lines branched lines 048 049 two assignment statements really shared two parts program two execution streams interleaved share common code although makes program somewhat shorter assures parts updated either makes understanding program structure difficult order express control flow cleanly necessary construct structured version requires shared code duplicated sharing segments version common statements elaborate subroutine could introduced called sites simple matter duplicate two lines producing two properly formed conditional constructs 34 data interleaving reusing variable names unfortunately common practice programs use variable name two unrelated purposes naturally leads confusion trying understand program thought kind interleaving instead two separable segments code intertwined one location program two aspects program state share use identifier occurs twice zeroin identifiers tol1 lines 011012 remainder program q line 064 right hand side line 068 remainder program including left hand side line 068 instances practice detected data flow analysis 35 generalization interpolation schemes zeroin exhibits situation two sections code use alternative approaches compute values set variables lines 057059 064068 responsible computing values variables p q determination approach use based test made line 053 example specialization computations test replaced conceptually general expression responsible computing p q based current values variables b c fa fb fc xm benefit localizing uses variables r inside new expression really several design issues involved first code segments result decomposition problem pieces expressed series assignment statements realization segments specializations general one allows details individual cases hidden away turn makes code shorter easier understand 36 variable introduction common programming practice save result computation order avoid recompute value later time computation involved practice result significant savings run time modest cost zeroin practice used extensively particular concerted effort save results calls usersupplied function f variables fa fb fc f may arbitrarily complex practice may important determinant ultimate efficiency zeroin examination program reveals fa fb fc always contain results applying f points b c respectively point view understanding algorithm three additional variables provide significant abstraction contrary require nontrivial effort understand manipulate replacing definitions makes resulting program easier understand readability goal two factors weighed deciding whether write program using variable name replacing value one hand new variable places burden person trying understand program variable must read purpose understood confirmed positive side variables serve valuable abbreviations computation replace easier understand variable carefully chosen mnemonic name complex expression represents case zeroin variables fa fb fc provide little way abstraction p q hand abbreviate significant computations albeit without benefits mnemonic names xm lies somewhere middle 37 generalization interval computation recognition intermediate decisions clarified structure program sort observation made lines 048086 function assigning values variable e based values variables b c e f tol1 xm fact list variables long indicates segment highly interleaved rest program nevertheless value indicate explicit effect lines code set two variables also noted section 35 several instances specialization lines 079080 085086 selected based tests lines 077078 likewise lines 082 086 lines 050 081 special cases selected basis tests lines 048 049 38 program architecture analysis described performed possible appreciate overall structure program based test made line 044 program seen use variable b hold approximations root function b modified lines 092 093 either xm sections lines 025028 lines 031037 act adjustments made special situations another conclusion apparent gets value b c gets value thus c b serve successively better approximations root fact except special circumstances c identical values likewise e normally value resulting architecture program shown figure 2 028 initialization loop conditional adjustment 1 043 close enough final answer 092 compute new value b conditional adjustment 2 figure sufficient simply recognize design decisions code recognized decisions must organized way effectively used maintenance programmers reuse engineers organization chosen serves representation design information numerous methods designing software numerous representations intermediate results typically several used design program architectural stages others lowlevel design still others may used maintenance stage original developers given way separate maintenance staff may consequently difficult recreate reuse original representation usable representation design information must easy construct development easy reconstruct reverse engineering constructed must facilitate queries report generation order support software maintenance activities must provide mechanism attaching available documentation also must support automation particular representation must formal enough components automatically manipulated example desirable able determine previously developed partial description software component reusable new situation representation design information must allow types design information attached includes highlevel specifications architectural overviews detailed interfaces resulting source code also desirable representation support requirements tracing informal annotations versioning information several approaches organizing design information proposed biggerstaff 7 concerned relating code fragments information problem domain software reuse facilitated new problems requirements easily matched description existing software building desire system explore approach blackburn 8 also concerned reuse proposes network design information fragments connected one two relationships either isdecomposed decomposition isa specialization coleman gallimore report fpd framework program development 9 arcs network model correspond refinements steps taken design refinement engenders proof obligation guarantee correctness step taken 5 conclusion software maintenance reuse require practitioners deep understanding software manipulated understanding facilitated presence design documentation effective documentation include description structure software together details decisions lead structure design decisions occur abstract models theories application domain confront realities limited machines imperfect programming languages design decisions recon structed greater hope able maintain reuse mountains undocumented software confronting us r mapping design representation terrain survey 15 year perspective automatic programming designing documentation compensate delocalized plans criteria used decomposing systems modules survey classification program transformation approaches techniques understanding documenting programs design recovery maintenance reuse toward theory software reuse based formal methods framework program development tr survey classification program transformation approaches techniques designing documentation compensate delocalized plans design recovery maintenance reuse computer methods mathematical computations ctr jorge l diazherrera importance static structures software construction ieee software v10 n3 p7587 may 1993 erich buss john henshaw software reverse engineering experience proceedings 1991 conference centre advanced studies collaborative research october 2830 1991 toronto ontario canada erich buss john henshaw experiences program understanding proceedings 1992 conference centre advanced studies collaborative research november 0912 1992 toronto ontario canada kamalakar karlapalem qing li chungdak shum hodfa architectural framework homogenizing heterogeneous legacy databases acm sigmod record v24 n1 p1520 march 1995 stephen b ornburn richard j leblanc jr building modifying using component generators proceedings 15th international conference software engineering p391402 may 1721 1993 baltimore maryland united states joel troster john henshaw erich buss filtering quality proceedings 1993 conference centre advanced studies collaborative research software engineering october 2428 1993 toronto ontario canada julio cesar sampaio prado leite working results software reengineering acm sigsoft software engineering notes v21 n2 p3944 march 1996 nenad marovac guidelines embedded software documentation acm sigsoft software engineering notes v19 n2 p2228 april 1994 spencer rugaber cataloging design abstractions proceedings 2006 international workshop role abstraction software engineering may 2121 2006 shanghai china forrest shull filippo lanubile victor r basili investigating reading techniques objectoriented framework learning ieee transactions software engineering v26 n11 p11011118 november 2000 carmen zannier frank maurer qualitative empirical evaluation design decisions acm sigsoft software engineering notes v30 n4 july 2005 carmen zannier mike chiasson frank maurer model design decision making based empirical results interviews software designers information software technology v49 n6 p637653 june 2007 spencer rugaber use domain knowledge program understanding annals software engineering v9 n14 p143192 2000 hausi mller jens h jahnke dennis b smith margaretanne storey scott r tilley kenny wong reverse engineering roadmap proceedings conference future software engineering p4760 june 0411 2000 limerick ireland g j van den brand p klint c verhoef reverse engineering system renovationan annotated bibliography acm sigsoft software engineering notes v22 n1 p5768 jan 1997
automated test data generation using iterative relaxation method important problem arises path oriented testing generation test data causes program follow given path paper present novel program execution based approach using iterative relaxation method address problem method test data generation initiated arbitrarily chosen input given domain input iteratively refined obtain input branch predicates given path evaluate desired outcome iteration program statements relevant evaluation branch predicate path executed set linear constraints derived constraints solved obtain increments input increments added current input obtain input next iteration relaxation technique used deriving constraints provides feedback amount input variable adjusted branches path evaluate desired outcomewhen branch conditions path linear functions input variables technique either finds solution paths one iteration guarantees path infeasible contrast existing execution based approaches may require unacceptably large number iterations relatively long paths consider one input variable one branch predicate time use backtracking branch conditions path nonlinear functions input variables though may take one iteration derive desired input set constraints solved iteration linear solved using gaussian elimination makes technique practical suitable automation b introduction software testing important stage software develop ment provides method establish confidence reliability software time consuming process accounts 50 cost software development 10 given program testing criteria generation test data satisfies selected testing criteria difficult problem test data given testing criteria program generated automatically relieve software testing team tedious difficult task reducing cost software testing significantly several approaches automated test data generation proposed literature including random 2 syntax based 5 program specification based 1 9 12 13 symbolic evaluation 4 6 program execution based 7 8 10 11 14 test data generation particular type testing criteria path coverage requires generating test data causes program execution follow given path generating test data given program path difficult task posing many complex problems 4 symbolic evaluation 4 6 program execution based approaches 7 10 14 proposed generating test data given path general symbolic evaluation statements along path requires complex algebraic manipulations difficulty handling arrays pointer references program execution based approaches handle arrays pointer references efficiently array indexes pointer addresses known step program execution one major challenges methods impact infeasible paths since concept inconsistent constraints methods large number iterations performed search input abandoned infeasible path existing program execution based methods 7 10 use function minimization search algorithms locate values input variables selected path traversed consider one branch predicate one input variable time use backtracking therefore even branch conditions path linear functions input may require large number iterations long paths paper present new program execution based approach generate test data given path novel approach based relaxation technique iteratively refining arbitrarily chosen input relaxation technique used numerical analysis improve upon approximate solution equation representing roots function 15 technique function evaluated approximate solution resulting value used provide feedback amount values approximate solution adjusted becomes exact solution equation function lin technique derives exact solution equation approximate solution one iteration nonlinear functions may take one iteration derive exact solution approximate solution method test data generation given path program initiated arbitrarily chosen input given domain path traversed program executed input input iteratively refined using relaxation technique obtain new input results traversal path apply relaxation technique test data generation problem view branch condition given path function input variables derive two representations function one representation form subset input assignment statements along given path must executed order evaluate function representation computed slicing operation data dependency graph program statements path starting predicate consideration therefore refer predicate slice note predicate slice always provides exact representation function computed branch condition using exact representation form program statements derive linear arithmetic representation function computed branch condition terms input variables arithmetic representation function terms input variables necessary enable application numerical analysis techniques since program representation function suitable purpose function computed branch condition linear function input linear arithmetic representation exact function computed branch condition nonlinear function input linear arithmetic representation approximates function neighborhood current input two representations used refine arbitrarily chosen input obtain desired input follows let us assume executing predicate slice using arbitrarily chosen input determine branch condition evaluate desired outcome case evaluation branch condition also provides us value called predicate residual amount function value must change order achieve desired branch outcome using linear arithmetic representation predicate residual derive linear constraint increments current input one constraint derived branch condition path linear constraints solved simultaneously using gaussian elimination compute increments current input new input obtained adding increments current input since constraints corresponding branch conditions path solved simultaneously method attempts change current input branch predicates path evaluate desired outcomes predicate slices executed new input branch conditions path linear functions input ie linear arithmetic representations predicate functions exact method either derives desired input one iteration guarantees path infeasible result immense practical importance accordance studies reported 6 case study 3600 test case constraints generated group fortran programs shown constraints almost always linear large class paths method able detect infeasibility even though problem detecting infeasible paths unsolvable general path feasible method extremely efficient finds solution exactly one iteration least one branch condition path nonlinear function input increments current input computed solving linear constraints increments may immediately yield desired input set linear constraints increments derived linear arithmetic representations case approximate corresponding branch conditions therefore may take one iteration obtain desired input even branch predicates path nonlinear functions input set equations solved obtain new input current input linear solved gaussian elim ination gauss elimination algorithm widely implemented established method solving system linear equations makes technique practical suitable automation important contributions novel method presented paper ffl innovative use traditional relaxation technique test data generation ffl conditionals path linear functions input either generates test data one iteration guarantees path infeasible fore efficient finding solution well powerful detecting infeasibility large class paths ffl general technique generate test data even conditionals given path nonlinear functions input case also number iterations inconsistent constraints used indication potential infeasible path ffl set constraints solved method always linear even though path may involve conditionals nonlinear functions input set linear constraints automatically solved using gaussian elimination whereas direct method exits solve set arbitrary nonlinear constraints gaussian elimination widely implemented experimented algorithm makes method practical suitable automation ffl scalable large programs number program executions required iteration independent path length bounded number input variables size system linear equations solved using gaussian elimination increases number branch predicates path increase cost significantly less existing techniques organization paper follows overview method presented next section algorithm test data generation described section 3 illustrated examples involving linear nonlinear paths loops arrays related work discussed section 4 important features method summarized future work outlined section 5 overview define program module directed graph e n set nodes e set edges unique entry node e unique exit node node n represents single statement conditional expression possible transfer control node n node n j mapped edge n g sequence nodes n variable k input variable module either appears input statement input parameter domain dk input variable k set possible values hold input vector number inputs called program input paper may refer program input input use terms interchangeably conditional expression multiway decision statement called branch predicate without loss gen erality assume branch predicates simple relational expressions inequalities equalities form e1 op e2 e1 e2 arithmetic expressions op one f 6g branch predicate contains boolean variables represent true value boolean variable numeric value zero greater false value negative numeric value branch predicate path conjunction two boolean variables predicate considered multiple branch predicates must simultaneously satisfied traversal path branch predicate path disjunction two boolean variables b time one branch predicates 0 b 0 considered along branch predicates path solution found one branch predicate one tried branch predicate e1 op e2 transformed equivalent branch predicate form f op 0 f arithmetic expression e1 gamma e2 along given path f represents real valued function called predicate function f may direct indirect function input variables illustrate let us consider branch predicate conditional statement p2 example program figure 1 predicate function f2 corresponding branch predicate bp2 along path g predicate function f2 indirectly represents function input variables xy z state problem addressed paper problem statement given program path p traversed certain evaluations true false branch predicates bp1 program input causes branch predicates evaluate p traversed present new method generating program input given path program traversed program executed using input method test data generation initiated arbitrarily chosen input given domain given path traversed input set linear constraints increments input derived using relaxation method increments obtained solving constraints added input obtain new input path traversed new input method terminates otherwise steps refining input carried iteratively obtain desired input briefly review relaxation technique used numerical analysis refining approximation solution linear equation relaxation technique approximation solution linear equation general substituting x0 y0 lhs equation would result non zero value r0 called residual ie increments deltax deltay x0 y0 computed satisfy linear constraint given therefore solution equation 1 order formulate test data generation problem relaxation technique problem view predicate function corresponding branch predicate path function program input apply relaxation technique linear arithmetic representation terms relevant input variables required predicate function first derive exact program representation called predicate slice function computed predicate function use derive linear arithmetic representation two representations used innovative way refine program input predicate slice exact program representation predicate function predicate slice defined follows definition predicate slice sbpp branch predicate bp path p set statements compute values upon value bp may directly indirectly data dependent execution follows path p words sbpp slice data dependencies branch predicate bp using program consisting 0 readxyz 1 2 3 else 5 7 8 writenonlinear quadratic endif 9 endif 0 readxyz statements predicate slice sbp1 p 0 readxyz 1 2 statements predicate slice sbp2 p 0 readxyz 1 statements predicate slice sbp4 p figure 1 example program predicate slices path pf01p12p2456p49g input assignment statements preceding bp path p illustrate definition using example program figure 1 consider path p let bp denote th branch predicate along path p predicate slices corresponding branch predicates bp 1 bp2 bp4 along path p illustrated examples predicate slices include input assignment statements value predicate function input computed executing corresponding predicate slice input note predicate slice conventional static slice since computed statements along path also dynamic slice computed statically using input assignment statements along path precise dynamic slice illustrate latter consider code segment given figure 2 inputi j figure 2 code segment path using array 6 j evaluation bp aj 0 data dependent assignment statement whereas j evaluation bp data dependent assignment state ment therefore predicate slice branch predicate bp consist input statement well assignment statement words predicate slice path oriented static slice concept predicate slice enables us evaluate outcome branch predicate path irrespective outcome branch predicates predicate slices branch predicates path executed using arbitrary input even though path may traversed input possible conditionals predicate slice execution predicate slice input value corresponding predicate function computed branch outcome evaluated correspondence outcomes execution predicate slices input traversal path input branch predicates path evaluate desired outcomes executing respective predicate slices input computing respective predicate functions path traversed program executed using input branch predicates path evaluate desired outcome predicate slice executed input path traversed program executed using input conceptually predicate slice enables us view predicate function path independent function input variables therefore method simultaneously force branch predicates along path evaluate desired outcomes contrast existing program execution based methods 7 10 test data generation attempt satisfy one branch predicate time use backtracking fix predicate satisfied earlier trying satisfy predicate appears later path cannot consider branch predicates path simultaneously path may traversed intermediate input predicate slice also useful identifying relevant subset input variables value predicate function depends subset input variables required linear arithmetic representation predicate function terms input variables derived subset input variables value computed predicate function depends determined dynamically illustrated example figure 2 therefore given input branch predicate path corresponding predicate slice executed using input dynamic data dependence graph based upon execution constructed relevant input variables corresponding predicate function determined taking dynamic slice dependence graph note scalars referenced predicate slice corresponding predicate function subset input variables predicate function depends determined statically predicate slice execution predicate slice input data followed dynamic slice determine relevant input variables necessary handle arrays define subset input variables input dependency set definition input dependency set idbpip branch predicate bp input along path p subset input variables bp directly indirectly data dependent input variables identified executing statements predicate slice sbpp input taking dynamic slice dynamic data dependence graph example executing sbp2p input note evaluation bp2 depends input variables xy z therefore zg explain use input dependency set derive linear arithmetic representation terms input variables predicate function given input deriving linear arithmetic representation predicate function given predicate function input dependency set id input write general linear function input variables id compute values coefficients general linear function represents tangent plane predicate function gives us linear arithmetic representation predicate function example predicate function f2 input linear function inputs id b c slopes f respect input variables xy z respectively constant term slopes b c computed evaluating corresponding derivatives predicate function input i0 constant term computed linear function f evaluates value i0 computed executing corresponding predicate slice i0 evaluating predicate function represents tangent plane predicate function input i0 gives us linear arithmetic representation predicate function i0 predicate function computes linear function input tangent plane exact representation predicate function whereas predicate function computes nonlinear function input tangent plane fxy approximate predicate function neighborhood input i0 illustrate deriving linear arithmetic representation predicate function f2 input approximate derivatives predicate function divided differences compute i0 execute sbp2p i0 chosen increment input variable x compute divided difference 2 gives value 2 compute value b executing predicate slice sbp2p i0 computing divided difference f2 two points respect gives b equal gamma2 similarly get c equal 1 compute value solving equation substituting values b c f2i0 equation solving get equal gamma100 therefore obtain linear arithmetic representation f2 i0 example f2 computes linear function input therefore linear arithmetic representation i0 computed exact representation function inputs computed f 2 also input variables influence predicate function f2 appear representation paper approximated derivatives predicate function divided differences tools developed compute derivative program respect input variable 3 tools get exact derivative values rather using divided differences therefore technique deriving linear arithmetic representation predicate function accurately implemented automated testing using method explained derive linear arithmetic representation current input predicate function given path order derive set linear constraints increments current input linear arithmetic representations execute predicate slices branch predicates current input compute values corresponding predicate functions use values predicate functions provide feedback computing desired increments current input predicate residuals values predicate functions input defined predicate residuals essentially place constraints changes values input variables satisfied provide us new input desired path followed definition predicate residual branch predicate input value corresponding predicate function computed executing predicate slice input branch predicate relational operator non zero predicate residual gives exact amount value predicate function change modifying input branch evaluates desired outcome otherwise predicate residual gives least maximum value predicate functions value must changed allowed change modifying program input branch predicate evaluates continues evaluate desired outcome explain examples given branch predicate evaluates desired outcome given input continue evaluate desired outcome case predicate residual gives maximum value predicate functions value allowed change modifying program input branch predicate continues evaluate desired outcome illustrate let us consider path p example program figure 1 using input branch predicate bp2 evaluates desired branch path p traversed value predicate function f2 1 2 110 hence predicate residual input 8 therefore value predicate function allowed decrease 8 due change program input predicate function continues evaluate evaluate positive value hand predicate evaluate desired outcome predicate residual gives least value predicate functions value must changed modifying program input branch predicate evaluates desired outcome example using input branch predicate bp2 evaluate desired branch path p tra versed value predicate function hence predicate residual gamma99 therefore input modified value predicate function increases least 99 branch predicate bp2 evaluate desired outcome predicate residuals essentially guide search program input cause branch predicate given path p evaluate desired outcome compute predicate residual current input branch predicate given path predicate residual linear arithmetic representation current input predicate function apply relaxation technique refine input refining input linear arithmetic representation predicate residual predicate function input essentially allow us map change value predicate function changes program input predicate function path p derive linear constraint increments program input using linear representation predicate function value corresponding predicate residual set linear constraints solved simultaneously using gaussian elimination compute increments input increments added input obtain new input illustrate derivation linear constraint corresponding predicate function f 2 branch predicate bp2 evaluates false sbp2 p executed arbitrarily chosen input evaluate true path p traversed residual value gamma99 linear function used derive linear constraint note constant term appear con straint intuitively means increments input i0 value predicate function f2 changes 99 force f2 evaluate positive value therefore force corresponding branch predicate bp2 evaluate desired outcome ie true new input instance one solutions constraint see bp2 evaluates true sbp2p executed linear constraint derived predicate residual compute increments current input important step method constraint value predicate function current input provides feedback increments computed derive new input since method computes new program input previous input residuals relaxation method iteratively refines program input obtain desired solution would like point relational operator branch predicate path method reduces newtons method iterative refinement approximation root system nonlinear functions several variables illustrate let us consider linear constraint equation 2 let us assume relational operator corresponding branch predicate bp2 simplicity let f2 function single variable x linear constraint equation 2 reduces 99which form general branch predicates path equalities well inequalities case method different newtons method computing root system nonlinear functions several variables since increments input computed stepping along tangent plane function current input expect method convergence properties similar newtons method discussion far assumed conditionals source predicate functions however practice additional predicates also considered test data generation first constraints inputs may exist may require introduction additional predicates eg input variable required positive value predicate 0 introduced second must introduce predicates constrain input variables values avoid execution errors eg array bound checks division zero considering predicates together predicates conditionals path desired input found simplicity examples considered paper consider predicates conditionals 3 description algorithm section present algorithm generate test data programs numeric input arrays assignments conditionals loops technique extended nonnumeric input characters strings providing mappings numeric nonnumeric values main steps algorithm outlined figure 3 describe steps algorithm detail time illustrate step algorithm generating test data path along predicate functions linear functions input examples nonlinear predicate functions given next section method begins given path p arbitrarily chosen input i0 input domain program program executed i0 p traversed using i0 i0 desired program input algorithm ter minates otherwise steps iterative refinement using relaxation technique executed illustrate algorithm using example section 2 path program figure 1 initial program input considered path p traversed program executed using i0 thus iterative relaxation method discussed employed refine input step 1 computation predicate slices node n p represents branch predicate compute predicate slice sn backward pass static data dependency graph input assignment statements along path p n predicate slices branch predicates path p step 2 identifying input dependency sets every node n p represents branch predicate identify input dependency set idn variables n data dependent executing predicate slice sn current input ik taking dynamic slice dynamic data dependence graph input dependency sets branch predicates path p computed executing respective predicate slices p using input note input assignment statements along path p need executed compute input dependency sets branch predicates along path step 3 derivation linear arithmetic representations predicate functions step construct linear arithmetic representation predicate function corresponding branch predicate p branch predicate n p first formulate general linear function input variables set idn example linear formulations predicate functions corresponding branch predicates path p coefficients b c input variables linear functions represent slopes th predicate function respect input variables xy z respectively approximate slopes respective divided differences compute slope coefficient respect variable execute predicate slice sn evaluate predicate function f current input ik divided difference gives value coefficient j linear function predicate function f corresponding node p similarly compute slope coefficients linear function example considered evaluating f1 executing computing divided difference respect x get larly f2 f 4 get 2 computing divided differences respect using 1 2 computing divided difference respect z using 1 2 1 2 4 get compute constant term execute corresponding predicate slice ik evaluate value predicate function values input variables ik slope coefficients found substituted linear function equated value predicate function ik computed gives linear equation one unknown solved value constant term example considered substitute slope coefficients b c computed general linear formulations predicate functions f 1 f2 f 4 equate general linear formulations respective values obtain following equations solving constant terms get therefore linear arithmetic representations three predicate functions p given predicate function linear function input variables slopes computed exact method results exact representation predicate function input path initial program input i0 output program input p traversed procedure testgenpi0 p traversed i0 step 1 branch predicate n p compute done branch predicate n p step 2 execute sn input ik compute input dependency set idn step 3 compute linear representation lidn predicate function n step 4 compute step 5 construct linear constraint using rn computation increment ik endfor step inequalities constraint set equalities step 7 solve system equations compute increments current program input compute new program input ik1 adding computed increments ik execution program input ik1 follows path p else k endif endwhile endprocedure figure 3 algorithm generate test data using iterative relaxation method predicate function computes nonlinear function linear function computed represents tangent plane predicate function ik neighborhood ik inequality derived tangent plane closely approximates branch predicate therefore predicate function evaluates positive value program input neighborhood ik linear function vice versa linear representations predicate residuals computed subsequent step used derive set linear constraints used refine ik obtain ik1 step 4 computation predicate residuals execute predicate slice corresponding branch predicate p current program input ik evaluate value predicate function value predicate function predicate residual value rn current program input ik branch predicate n predicate residuals i0 branch predicates p step 5 construction system linear constraints solved obtain increments current input step construct linear constraints computing increments deltai k current input ik using linear representations computed step 3 predicate residual values computed step 4 first convert linear arithmetic representations predicate functions set inequalities equal ities branch predicate evaluate true given path traversed corresponding predicate function converted inequalityequality relational operator branch predicate hand branch predicate evaluate false given path corresponding predicate function converted inequality reversal relational operator used branch predicate branch predicate relational operator evaluate false given path traversed convert two inequalities one relational operator relational operator corresponding predicate function evaluates positive value ik consider inequality operator else consider one operator discussion also holds branch predicate 6 relational operator evaluate true given path traversed set inequalitiesequalities gives linear representations branch predicates p evaluate given path traversed converting linear arithmetic representations predicate functions path p inequalities get using linear arithmetic representations ik branch predicates evaluate traversal path p using predicate residuals computed ik apply relaxation technique described previous section derive set linear constraints increments input applying relaxation technique linear arithmetic representations computed predicate residuals computed previous step set linear constraints increments i0 derived given note constant terms linear arithmetic representations appear constraints step conversion inequalities equalities general set linear constraints increments derived previous step may mix inequalities equalities automating method computing solution set inequalities convert system equalities solve using gaussian elimination convert inequalities equalities addition new variables simultaneous solution system equations gives us increments ik obtain next program input ik1 converting inequalities equalities constraint set example considered introducing three new variables u v w get require u v w 0 step 7 solution system linear equations simultaneously solve system linear equations obtained previous step using gaussian elimination number branch predicates path equal number unknowns input variables new variables consistent nonsingular system equations straightforward application gaussian elimination gives solution system equations number branch predicates path number unknowns system equations overdetermined may may exist solution depending whether system equations consistent system equations consistent solution found applying gaussian elimination subsystem number constraints equal number vari ables verifying solution satisfies remaining constraints system equations consistent possible path infeasible case consistent subsystem set linear constraints solved using gaussian elimination used program input next iteration repeated occurrence inconsistent systems equations subsequent iterations strengthens possibility path infeasible testing tool may choose terminate algorithm certain number occurrences inconsistent systems conclusion path likely infeasible number branch predicates path less number unknowns system equations underdetermined infinite number solutions system consistent case n branch predicates select n unknowns formulate system n equations expressed n unknowns unknowns free variables n unknowns selected resulting system equations set n linearly independent equations system n equations n unknowns solved terms free variables using gaussian elimination values free variables chosen values n dependent variables com puted solution obtained step gives values current program input ik incremented obtain next approximation ik1 program input execute predicate slices evaluate predicate functions new program input ik1 branch predicates evaluate desired branches ik1 solution test data generation problem otherwise algorithm goes back step 2 ik1 current program input k th iteration explained previous section input dependency sets linear representations depend current input data therefore computed next iteration using ik1 example considered three linear constraints six unknowns therefore underdetermined system equations considered system three equations three unknowns three unknowns free variables considered system three equations three variables deltax deltay deltaz gaussian elimination used triangularize coefficient matrix find third equation dependent first equation third row reduces row zeros resulting singular matrix therefore consider system equations deltax deltaz w4 deltax deltaz values free variables chosen arbitrarily u v w 0 choosing free variables u v deltay equal 1 solving deltax deltaz w get 2 adding increments i0 get executing predicate slices path p using input i1 evaluating corresponding predicate functions see three branch predicates evaluate desired branch leading traversal p therefore algorithm terminates successfully one iteration method new approximation program input obtained previous approximation residuals therefore falls class relaxation meth ods relaxation technique used iteratively obtain new program input branch predicates evaluate desired outcomes executing corresponding predicate slices found method terminate given time possible either time allotted test data generation insufficient accumulation round errors gauss elimination method due finite precision arithmetic used gaussian elimination well established method solving system linear equations implementations several pivoting strategies available avoid accumulation round errors due finite precision arithmetic besides two possibilities reason method terminating given time path infeasible clear construction linear representations step 3 function input computed predicate function linear corresponding linear representation constructed method exact representation function computed predicate function prove case desired program input obtained one iteration theorem 1 functions input computed predicate functions path p linear either desired program input traversal path p obtained one iteration path guaranteed infeasible proof let us assume input variables program containing given path p n branch predicates bp1bp2 bpn path p n1 use use relational linear representations predicate functions corresponding predicates p computed method described step 3 algorithm note representations exact functions input computed predicate functions linear write branch predicates path p terms representations follows eq set 1 note coefficients corresponding input variables input dependency set predicate function zero approximation solution set equations eq set 2 r ij residual value obtained executing corresponding predicate slice using i0 evaluating corresponding predicate function let solution eq set 1 executing given program would result traversal path p goal compute solution substituting eq set 1 get eq set 3 subtracting eq set 2 eq set 3 get precisely set constraints increments input must satisfied obtain desired input increment deltax x i0 computed set constraints gives desired solution illustrated requires one iteration indeed set constraints used step 5 method test data generation therefore given arbitrarily chosen input i0 program domain method derives desired input one iteration solving constraints found set inconsistent given path p infeasible therefore method either derives desired solution one iteration guarantees given path infeasible 31 paths nonlinear predicate slices function input computed predicate function nonlinear predicate function locally approximated tangent plane neighborhood current input ik residual value computed ik provides feedback tangent plane ik computation increments ik tangent plane exact representation predicate function predicate function evaluate desired outcome next iteration slope correspondence tangent plane predicate function local current iteration point ik may take one iteration compute program input execution predicate slice results evaluation branch predicate desired branch outcome let us consider path predicate function computing second degree function input example program figure 1 initial program input path p traversed i0 therefore input i0 iteratively refined predicate slices input dependency sets branch predicates bp1bp2 bp4 example path linear predicate slices bp 3 also linear representations predicate functions f1 f2 f4 example previous section f 3 slope f3 respect z computed evaluating divided difference 123 124 linear function represents tangent plane i0 nonlinear function computed predicate function corresponding branch predicate bp 3 converting functions inequality relational operator branch predicate evaluate get note relational operator representation bp2 different example previous section different branch taken predicate residuals i0 predicate slices p set linear constraints used computing increment i0 using results two steps 2 inequalities constraint set converted equalities introducing new variables resulting system equations deltax deltay deltaz v solved using gaussian elimination61 deltax deltay deltaz free variables u arbitrarily chosen equal 1 system solved deltax deltay deltaz v solution system 2 increments added i0 obtain new input i1 executing predicate slices p using program input i1 find four branch predicates evaluate desired branches resulting traversal p fore algorithm terminates successfully one iteration summarize results following table iteration example illustrates tangent plane current input good enough linear approximation predicate function neighborhood current input consider path predicate function computing sine function input let us consider following path p program figure 1 initial program input path p traversed i0 bp2 evaluates undesired branch i0 therefore steps iterative refinement i0 executed summarize results execution test data generation algorithm example table given path p traversed branch predicates bp1 bp4 evaluate false branch predicates bp2 bp5 evaluate true shown table iterations 1 4 algorithm bp 1 bp 2 bp4 continue evaluate desired outcomes values inputs x z incremented f5 moves closer zero iteration finally iteration 4 f5 becomes positive program input i4 therefore bp5 becomes true would like point linear arithmetic representation branch predicate exact branch predicate evaluates desired outcome first iteration continues subsequent erations whereas linear arithmetic representation approximates branch predicate neighborhood current input case bp5 tangent plane although iteration refined input evaluates desired outcome respect tangent plane may take several iterative refinements input corresponding branch predicate evaluate desired outcome example bp5 evaluated trueits desired come i0 evaluated false i1 predicate residual provides feedback linear representation ie tangent plane sine function bp5 input modified stepping along linear arithmetic representation result linear representation evaluates positive value i1 change program input still falls short making predicate function f5 evaluate positive value i1 subsequent iterations input gets refined finally fourth iteration predicate function f5 evaluates positive value illustrated example first iteration branch predicates computing linear functions input continue evaluate desired outcomes input refined satisfy branch predicates computing nonlinear functions input regression test ing branch predicate statement given path may changed generate test data modified path traversed input branch predicates already evaluate desired outcomes good initial input refined method therefore regression testing use existing test data initial input refine generate new test data 32 arrays loops arrays input procedure one problems faced test data generation method size input arrays test data generation method considers array elements referenced predicate slices branch predicates path executed corresponding predicate functions evaluated input dependency set given input identifies input variables relevant predicate function fore test data generation algorithm uses refines array elements relevant makes test data generation independent size input arrays illustrate method handles arrays loops generating test data program 10 given figure 4 take path initial input 10 compare performance two program execution based test data generation methods therefore denotes j th execution predicate p initial program input path p traversed i0 therefore steps iterative refinement i0 executed let l h denote low high step respectively predicate slices input dependency sets branch predicates p linear representations predicate functions corresponding branch predicates p h predicate residuals i0 predicate functions branch predicates p set linear constraints used computing increment i0 using results two steps inequalities converted equalities introducing seven new variables b c e f g f 0 b c e g 0 considering system equations expressed unknowns deltal deltas deltax deltay b e get66 664 deltal deltas deltax deltay unknowns free variables selected obtain nonsingular system equations values free variables chosen arbitrarily constraints f 0 b c e g 0 values free variables f deltaz deltah g chosen 1 value free variable 3 integer arithmetic solving unknown variables using gaussian elimination get 3 new input generated first iteration input values a39 a51 a63 copied a89 a91 a93 respectively increments computed iteration added a89 a91 a93 giving step important increments computed current iteration added input used current iteration resulting values copied array elements used next itera tion elements a89 a91 a93 relevant next iteration executing predicate slices p program input i1 evaluating corresponding predicate func tions see branch predicates evaluate desired branch outcomes resulting traversal p predicate functions corresponding branch predicates p compute linear functions input therefore expected algorithm terminates successfully one itera tion summarize results example table figure 4 korel 10 obtains test data path 21 program executions whereas method finds solution one iteration 8 program exe cutions one program execution used beginning test whether path p traversed i0 six additional program executions required computation slope computations linear representations one program execution required test whether path p traversed i1 choose path set linear constraints obtained step 3 consistent since predicate functions path compute linear functions input theorem 1 conclude path must infeasible easy check p indeed infeasible path var array1100 integer min max iinteger 1 inputlowhighstepa 2 min alow 3 4 low 5 p3 min ai 7 8 outputminmax iteration low high step a39 a51 a63 a89 a91 a93 iteration bp11 bp21 bp31 bp12 bp22 bp32 bp13 figure 4 example using array loop 4 related work popular approach automated test data generation path oriented methods symbolic evaluation actual program execution one earliest systems automatically generate test data using evaluation linear path constraints described 4 detect infeasible paths linear path constraints limited ability handle array references depend program input recent attempt using symbolic evaluation test data generation fault based criteria described 6 work test data generation system based collection heuristics solving system constraints developed constraints derived often imprecise resulting approximate solution path may traversed since test data refined eventually obtain desired input method fails path traversed approximate solution program execution based approach requires partial solution test data generation problem computed hand using values integer input variables described 14 indication automate step requiring computation hand program execution based approaches automated test data generation described 11 8 developed statement branch testing criteria approach automatically generate test data given path using actual execution program presented 10 another program execution based approach uses program instrumentation test data generation given path reported 7 approaches consider one branch predicate one input variable time use backtracking therefore may require large number iterations even branch conditionals along path linear functions input several conditionals selected path depend common input variables lot effort wasted backtracking cannot consider branch predicates path simultaneously path may traversed intermediate input concept predicate slice allows us evaluate branch predicate path independently intermediate input even though path may traversed input makes technique efficient execution based methods method scalable large programs since number program executions iteration independent path length equal number input variables plus one input variables iteration executions input assignment statements given path required compute slope coefficients values predicate functions input ik known previous iteration one execution input assignment statements path required test whether path traversed ik1 method uses gaussian elimination solve system linear equations well established widely implemented technique solve system linear equations therefore method suitable automa tion size system linear equations solved increases increase number branch conditionals path increase cost solving larger system significantly less existing execution based methods conclusions paper presented new program execution based method using well established mathematical tech niques automatically generate test data given path method innovative application traditional relaxation technique used numerical analysis obtain exact solution equation iterative improvement approximate solution results obtained method test data generation promising provides practical solution automated test data generation problem easy implement tools required already available efficient existing program execution based approaches requires fewer program executions branch predicates path considered simultaneously back tracking also detect infeasibility large class paths single iteration execution based handle different programming language features working extending technique strings pointers r test plan generation using formal grammars automatic generation random selfchecking test adic extensible automatic differentiation tool ansic system generate test data symbolically execute programs rule based software test data generator constraintbased automatic test data generation adtest test data generation suite ada software systems automatic test data generation using constraint solving techniques atlas automated software testing system automated software test data generation dynamic approach test data gener ation automatic data generation system data base simulation testing automatic generation testcase datasets automatic generation floatingpoint test numerical analysis tr automatic generation random selfchecking test cases automated software test data generation constraintbased automatic test data generation adtest automatic test data generation using constraint solving techniques rulebased software test data generator test plan generation using formal grammars atlasan automated software testing system ctr jinhui ji wang zhichang qi jianping wu improved method generate pathwise test data journal computer science technology v18 n2 p235240 march nguyen tran sy yves deville consistency techniques interprocedural test data generation acm sigsoft software engineering notes v28 n5 september jon edvardsson mariam kamkar analysis constraint solver una based test data generation acm sigsoft software engineering notes v26 n5 sept 2001 xun yuan atif memon using gui runtime state feedback generate test cases proceedings 29th international conference software engineering p396405 may 2026 2007 stephen thomas laurie williams using automated fix generation secure sql statements proceedings third international workshop software engineering secure systems p9 may 2026 2007 mengluo ji ji wang shuhao li zhichang qi automated wcet analysis based program modes proceedings 2006 international workshop automation software test may 2323 2006 shanghai china hari hampapuram yue yang manuvir das symbolic path simulation pathsensitive dataflow analysis acm sigsoft software engineering notes v31 n1 january 2006 paolo tonella evolutionary testing classes acm sigsoft software engineering notes v29 n4 july 2004 lu pin zhou wei liu yuanyuan zhou josep torrellas pathexpander architectural support increasing path coverage dynamic bug detection proceedings 39th annual ieeeacm international symposium microarchitecture p3852 december 0913 2006 torsten robschink gregor snelting efficient path conditions dependence graphs proceedings 24th international conference software engineering may 1925 2002 orlando florida david chays saikat dan phyllis g frankl filippos vokolos elaine j weber framework testing database applications acm sigsoft software engineering notes v25 n5 p147157 sept 2000 rupak majumdar koushik sen hybrid concolic testing proceedings 29th international conference software engineering p416426 may 2026 2007 wei zhao lu zhang yin liu jiasu sun fuqing yang sniafl towards static noninteractive approach feature location acm transactions software engineering methodology tosem v15 n2 p195226 april 2006 gregor snelting torsten robschink jens krinke efficient path conditions dependence graphs software safety analysis acm transactions software engineering methodology tosem v15 n4 p410457 october 2006 cristian cadar vijay ganesh peter pawlowski david l dill dawson r engler exe automatically generating inputs death proceedings 13th acm conference computer communications security october 30november 03 2006 alexandria virginia usa marc fisher ii gregg rothermel darren brown mingming cao curtis cook margaret burnett integrating automated test generation wysiwyt spreadsheet testing methodology acm transactions software engineering methodology tosem v15 n2 p150194 april 2006
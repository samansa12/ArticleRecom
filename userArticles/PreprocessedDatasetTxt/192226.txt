graphical interval logic specifying concurrent systems article describes graphical interval logic foundation tool set supporting formal specification verification concurrent software systems experience shown software engineers find standard temporal logics difficult understand use objective article enable software engineers specify reason temporal properties concurrent systems easily providing logic intuitive graphical representation tools support use illustrate use graphical logic article provides specifications elevator system proves several properties specifications article also describes tool set implementation b introduction one great challenges facing todays software engineers development correct programs real applications recent advances hardware reliability fault tolerance technology assure extremely low hardware failure rates devices unfortunately technologies digital hardware design software engineering matched advance use computers many critical applications primarily limited reliability system designs implementations research partially supported nsf grant ccr9014382 cooperation darpa early version paper presented 14th inter conf software engineering may 1992 institution engineers australia ieee computer society association computing machinery institution radio electronic engineers australia australian computer society copyright 1995 c acm inc permission copy distribute document hereby granted provided notice retained copies copies altered acm credited material used form copyright policies critical real applications often involve concurrency increases difficulty system development validation modern methods structured programming quite effective sequential programs notoriously inadequate concurrent ones moreover nondeterminism inherent applications involve concurrency reactive character applications makes hard test aggravating problems need explore large spaces possible executions grow exponentially number independent threads control formal methods specifying verifying systems principle offer greater assurance correctness informal designcode checks testing formal verification methods demonstrate highlevel design meets formally specified correctness requirements thereby reducing risk faulty designs used basis system development formal specifications valuable defining interfaces independently developed software modules establishing software interface standards provide succinct unambiguous statement system requirements formal specifications potentially analyzed consistency particularly difficult important problem concurrent systems formal specifications also used selection test data suggest behaviors tested later determine whether execution test case correct erroneous thus system developers use formal specifications throughout system lifecycle guide development maintenance enhancement practice however system developers seldom make significant use formal specification verification methods believe due large part reliance methods mathematical formalisms difficult understand use formal specification analysis methods must made accessible system designers software engineers used development real world systems users must able express properties systems wish reason naturally possible confirm mechanically specifications designs testing criteria sample executions required properties temporal logics 3 20 22 34 wellsuited specifying temporal properties concurrent systems experience shown however specifications even moderatesized systems complex readily understood complexity stems chiefly need establish temporal context within properties bounded liveness invariance must hold interval logics 1233 address problem defining temporal intervals represent contexts example express requirement process releases lock database must signal intends enter database obtaining new lock interval might used represent activity system time process releases lock acquires new one process would required signal intension within restricted context represented interval bounded liveness stylized pictures often show complex timing relationships dependencies clearly linear textual representations information diagrams correspond closely common conceptualizations linear text software engineers often draw timing diagrams like used denote signal levels hardware designs describing reasoning properties systems even logicians fluent temporal logic find timing diagrams helpful explain meanings temporal logic formulas motivate lines reasoning see example 7 however absence formal semantics timing diagrams cannot used rigorous analysis system properties pictorial documentation typically ad hoc liable ambiguous interpretation paper describes visual temporal logic formulas resemble informal timing diagrams familiar designers hardware systems software engineers graphical interval logic gil formal modeltheoretic semantics expressive propositional temporal logic without next 28 thus provides intuitive natural visual notation express system specifications without sacrificing benefits formal notation visual editor allows gil specifications easily constructed stored retrieved files editor also provides visual interface proof checker model generator permit verification temporal inferences paper first provides overview gil section 2 presents sample specifications elevator system section 3 shows section 4 designer uses specifications reason properties system section 5 describes gil toolset section 6 provides overview implementation related work discussed section 7 conclusions future work presented section 8 appendix provides modeltheoretic semantics logic graphical interval logic reasoning temporal properties exhibited concurrent system computation convenient regard system passing sequence states model nonterminating computation state sequence must infinite terminating computation likewise modeled infinite state sequence repeating stuttering final state permits concurrent system identified set infinite state sequences represent potential computations gil specifications system describe properties legal state sequences specifications must hold first state every infinite state sequence represents computation system adopt total order model computation rather partial order model advantages representing causality concurrent systems 27 total orders readily abstracted meaningful intervals represented pictorially appropriately high level gil formula evaluated state infinite sequence states infinite state sequences therefore provide contexts within formulas evaluated formula holds state context describes property states future within context infinite tail sequence begins state extends end context reflexive interpretation future future includes present allows semantics insensitive finite stuttering facilitates use hierarchical abstraction refinement reasoning concurrency 19 intervals permit specification contexts within properties hold denote interval leftclosed rightopen line segment interval thus shows individual states context points line segment horizontal dimension showing progression context time progresses left right suggested representation every interval initial point state however since contexts infinite regard interval final point interval formulas heart graphical interval logic basic interval formula asserts formula holds first state designated context interval derived operators assert formula holds every point context arbitrary point context gil therefore also provides usual temporal eventually henceforth operators logic provides two search primitives use specifying intervals ffl search target formula f represented r f ffl search right end context represented r search target formula locates first future point target holds dot represents point search starts search fails target hold future point inclusive present context search right end context permits specification tail interval searches composed sequentially successive search starting point located previous search example f locates first point f holds beginning point locates next point g holds allow shorthand notation r target f first search state formula involve temporal operators shorthand produces compact formulas use extensively examples 1 search r f equivalent r provided f holds future point however search r f fails r f also fails tail search appears must last search search pattern extent interval specified means pair search patterns designate searches locating left right ends interval searches begin point therefore draw one beneath start points horizontally aligned interval determined searches drawn directly beneath searches left end horizontally aligned point located first search pattern right end horizontally aligned point located second search pattern example f 1 result examples slightly less general might since sequence searches cannot always drawn line however easily converted general examples drawing primitive search new line interval starts point located search left end extends include point located search right end diagram thus represents interval starts first point f holds ends prior first point g holds interval cannot constructed either search fails interval empty ie point specified first search pattern precede specified second search pattern figure conventions simplify representation several common types intervals first abbreviation single search pattern specifies extent interval permitted search intervals left end prefix search right end thus interval first example begins first point f holds extends include next point g holds interval cannot constructed f hold future point g hold point future first point f holds g holds point located search f second example figure 1 special case first target first search true search true succeeds immediately locating point search begins interval second example thus begins point specification evaluated extends next point exclusive f holds interval cannot constructed f hold future point f holds present point intervals used specify finite prefixes larger contexts triangle 4 third example figure 1 called point operator illustrated example point operator appears directly point located final search sequence searches constructs tail interval starts point located point operator used locate point within context point located assert property holds suffix computation starting point point cannot located searches fails final example shows interval line represents full context assert formula h holds initial point interval h drawn left justified left delimiter example f f true f figure 1 examples derived intervals left column definitions right column asserts h holds first point designated interval formula holds vacuously first point interval cannot constructed thus either f g never holds future first future point f holds precede first future point g holds 1 holds default right brace helps visually delimit formula subformulas appear interval formula eg f g h formula may arbitrary graphical interval logic formulas gil provides usual logical operators conjunction disjunction implication composed subformulas contain intervals drawn using vertical layout vertical layout operands binary operator left justified first operand second operator formula negated drawn left justified negation sign f f f f f conjunction default vertical layout operator omitted first example layout precedence rules determine grouping operations gil formulas obey variation landins offside rule 21 requires every token formula lie lower right quadrant determined upper left corner smallest rectangle contains first token first token obey rule called offside token terminates parse formula precedence operators high low negation conjunction disjunction implication equivalence binary operators associate left right right braces delimit interval formulas permit explicit grouping operations weak operator u propositional temporal logic ptl expressed gil follows f 2 formula asserts g holds first point either f hold g hold unless point located latter case f well g holds future points words f holds least g holds gil provides special syntax invariants eventualities assert formula holds every point interval formula drawn indented directly interval assert formula holds point within interval formula drawn left justified directly diamond 3 drawn interval figure 2 shows conventions definitions definition top right invariant notation top left understood follows since false hold point context point formula holds precisely search f fails ie f holds future points similarly formulas bottom row assert f holds future point noted interval formula holds vacuously search performed locating ends interval fails interval empty thus interval formula implicitly predicated locating search targets locating left end interval locating right end therefore refer search operator interval operator described weak operators gil also provides strong versions operators useful specifications expressing negations interval formulas double arrowhead denotes strong search asserts search succeeds unless prior weak search fails double line denotes strong interval asserts point located search intervals left end strictly precedes located search right end unless search fails instance false f f false figure 2 representation invariants top left eventualities bottom left definitions right column holds default search f fails however search succeeds formula requires subsequent searches g h succeed interval empty h hold point located second search k holds first state interval dual interval formula obtained changing senses strong weak weak strong interval modality searches ends interval dual relationship implies negation moved interval formula changing senses interval searches instance negation 3 equivalent appendix gives formal definitions syntax semantics gil 3 example specification present gil specification elevator system illustrate ideas previous section example includes specifications basic safety liveness requirements also complex fairness requirements simplicity consider elevator three floors specification makes use following state predicates 3 predicate atn true elevator floor n false predicate goingup models physical switch whose setting elevator leaves floor determines direction travel goingup true goingup false predicate openn true doors elevator open floor n reqn true outstanding request service floor n finally elevator second floor arriveup indicates whether going arrived specifications read top bottom left right convention begin specification context line represents legal execution system first specification initial requirements remaining specifications describe system invariants associate labels shown bold specifications reference purposes init elevator begins operation first floor doors closed requests service 3 elevator never two different floors simultaneously atn atm upfrom1 elevator goes departs first floor arriving second floor without first visiting floors goingup at3 invariant formula predicated locating point elevator left first floor specification asserts elevator going every point reaches second floor either floors strong search requires elevator eventually arrives second floor strong interval requires arrive immediately upon leaving first floor takes time upfrom2 elevator goes departs second floor precisely goes directly third floor goingup at3 downfrom2 elevator goes departs second floor precisely goes directly first floor downfrom3 elevator goes departs third floor arriving second floor without first visiting floors 3 doors open floor elevator floor openn openn atn 3 elevator departs floor doors floor closed atn atn openn 3 doors open floor response request service floor reqn openn reqn 3 request service floor canceled floor serviced doors open reqn reqn openn 3 doors remain open indefinitely requests service current floor canceled close openn openn reqn arriveup whenever elevator arrives second floor first floor arriveup true remains true least elevator departs second floor arriveup arrivedown whenever elevator arrives second floor third floor arriveup false remains false least elevator departs second floor at3 arriveup continueup elevator going arrives second floor continues going departs second floor precisely someone requires service third floor time elevator departs arriveup goingup continuedown elevator going arrives second floor continues going departs second floor precisely someone requires service first floor one requires service third floor time elevator departs arriveup goingup continueup continuedown require elevator starts traveling given direction changes directions one requires service floor direction disjunction continuedown permits require first floor act home floor elevator return idle 3 passenger requests service floor time elevator reaches floor elevator opens doors departing floor atn atn reqn openn atn 3 passenger needs service floor elevator floor one needs service another floor elevator opens doors departing floor atn reqn reqm reqk openn atn use k remaining specifications denote floors f k 3 elevator floor passenger requires service different floor either doors open current floor elevator departs floor without first opening doors reqm reqk atn openn atn atn openn 3 elevator departs floor without first opening doors whenever passenger requires service floor doors closed someone needs service another floor atn reqn openn reqm reqk atn openn last four specifications ensure elevator makes progress services floors timely fashion passenger requests service floor time elevator arrives appropriate servereqsonarrival specification guarantees elevator stops floor traveling floors similarly servenoconflict specifications ensure elevator services request elevator floor needing service one waiting service another floor however passenger requires elevator floor appropriate noservedepart specification ensures current floor serviced elevator departs floor without servicing additional requests service current floor may made interim serveordepart specifications prevent elevator sitting idlely floor floors require service purposes comparison show upfrom2 arriveup expressed ptl nested operations required limit scope subformulas appropriate contexts upfrom2 arriveup graphical proofs system properties important benefit formal specifications analyzed potential conse quences analysis demonstrate specifications correctly express higherlevel system requirements help designer learn system development analysis reveals specifications admit computations violate requisite properties specifications incomplete error hand desired properties proved specifications designer gains confidence provide complete accurate description system built following examples properties required elevator system first requirement one many safety properties designer might wish establish second minimal fairness requirement 3 elevator must floor doors open openn atn 3 elevator eventually responds request service reqn openn specifications system express temporal constraints legal computations thus system satisfies requirement r conjunction specifications implies r equivalently implication r valid principal gil proof checker check validity inference however practice theorem proving requires human assistance computationally init safeopenn safedepartn safen openn openn openn atn atn atn openn openn atn figure 3 proof safen 3 feasible designer provides assistance proof method breaking complex proof inferences small enough gil proof checker validate major advantage visual logic gil proof represented using pictures show temporal flow argument graphical representation timeline allows one align appropriate points picture alignment helps designer see points invariants instantiated intervals points aligned establish bounded liveness invariance conditions relationships different points intervals visual cues extremely helpful constructing proofs discovering potential fallacies syntactic sugar semantic content proofs although investigating technique permit designer use alignment specify orderings points within specification alignment ordering points timeline uses well instance gil toolset provides model generation facility producing counterexample case inference invalid counterexample displayed sequence states timing diagram aligning states implication appropriately counterexample help illustrate fallacy inference proof safen figure 3 uses alignment highlight underlying correctness argument annotations alongside picture show specifications used proof shown annotations safen proved ffl init asserts doors open floor n system starts ffl safeopenn asserts elevator floor n doors first open floor ffl safedepartn asserts doors closed time elevator departs floor aligning invariant safedepartn point located search openn safeopenn highlights fact invariant evaluated point guarantees atn holds continuously arbitrary point openn becomes true least openn false proof servicen complex accomplished single step figure 4 shows last step proof shown annotations alongside figure final deduction makes use several specifications intermediate result arriven established independently another step proof reasoning illustrated picture understood follows reqn holds point computation becomes false future point waitservicen ensures invariant servicen holds point highlight reasoning align invariants waitservicen servicen align points openn asserted hold remaining premises establish servicen case reqn holds continuously point computation use arriven deduce future atnpoint atnpoint purposely positioned within span search arrow waitservicen remind reader interested case atn true reqn false next three premises represent case split invariant servenoconflictn establishes invariant servicen case reqm reqk false atnpoint invariant serveordepartn establishes servicen case reqm reqk true atn point atn holds throughout future finally invariant servereqsonarrivaln instantiated next atnpoint establishes required invariant case reqm reqk true atnpoint future point atn false figure 5 shows complex proof split manageable steps case analysis represents last step proof arriven style previous example waitservicen safen establish required invariant reqn false future point remaining premises required reqn holds continuously point waitservicen arriven reqn reqn openn reqn atn atn reqn reqm reqk openn atn atn reqm reqk openn atn atn openn atn atn reqn openn atn reqn openn figure 4 final deduction proof servicen waitservicen safen arrivesomefloor arrivenatm arrivenatk arriven reqn reqn openn openn atn atn atm atk atn atm atk atm reqn atn atk reqn atn reqn atn figure 5 final deduction proof arriven computation arrivesomefloor represents progress requirement needed ensure elevator remain transit indefinitely eventually arrives floor permits proof reduced two cases represented arrivenatm arrivenatk assert respectively elevator eventually arrives floor n floor eventually arrives floor n floor k proofs arrivesomefloor arrivenatm arrivenatk required complete proof servicen requirement arrivesomefloor follows directly specifications init upfrom1 upfrom2 downfrom2 downfrom3 highlevel strategy used proofs arrivenatm arrivenatk first show specifications ensure elevator remain floor indefinitely needed different floor departure results upfrom1 ensure arrive2at1 similarly departure results downfrom3 imply arrive2at3 proof arrive1at2 arrive1at3 departure results specifications first used show elevator traveling arrives second floor eventually arrives first floor arrive1at3 follows easily departure results specifications finally use arrive1at3 departure results specifications show elevator eventually arrives first floor traveling reaches second one proofs arrive3at2 arrive3at1 parallel arrive1at2 arrive1at3 departure results established straightforward tedious case analysis full proof given 6 form intermediate lemmas annotated proof trees 2 5 graphical interval logic toolset built prototype gil toolset demonstrate proofofconcept permit experiments logic prototype includes visual editor allows specifications easily constructed stored retrieved files proof checker mechanically checks validity temporal inferences model generator exhibits state sequences formulas hold section provides brief overview gil toolset figure 6 shows appearance interface gil editor giled formulas edited canvas comprises main region display canvas figure 6 contains template creating new specification template consists outer context interval technical report obtained anonymous ftp directory pub ftpcsucsbedu figure box automatically positioned start interval represents formula yet defined designer uses mouse editing select formulas canvas editing operations box selected indicated shading example scroll bars permit canvas scrolled viewing large formulas buttons panel lower left side display correspond gil primitives text button allows box replaced state predicate remaining buttons lower left panel specify gil operators apply appropriate formulas first buttons corresponding four temporal operators interval eventuality 3 invariant 2 point 4 operators 3 last five buttons correspond propositional operators disjunction conjunction negation implication equivalence j buttons upper left panel provide language independent editing operations commands override default layout formulas commands storing retrieving formulas found edit file pulldown menus proof checker invoked models displayed using commands provided 3 noted section 2 eventuality invariant point operators derived interval operator ever correspond common conceptualizations distinguished graphical syntax visualization purposes misc pulldown menu models displayed graphically accompanying window shown figure 6 briefly build formula upfrom1 designer might begin selecting new button 4 produces template shown figure 6 2 buttons used auto matically indent box context line expand implication produces following template invariant implication giled selects box expand next default however designer may override default selection time using mouse selecting second box 4 button converts consequent point formula requirement designer uses mouse position single search arrow giled produces point symbol box represent search target shown designer continue fashion produce template required structure 4 new button current implementation giled automatically generate right parenthesis rectified next version giled interval template created first expanding box appropriate interval template using mouse position interval search arrow button produces search arrows weak intervals default designer clicks mouse appropriate search arrow interval obtain strong counterparts convert template upfrom1 designer selects pending boxes turn clicks text button types state predicates addition editing operations illustrated giled provides capabilities cutting pasting formulas resizing intervals search arrows repositioning invariants eventuali ties formula fit space alloted giled indicates error highlights oversized formula designer correct error resizing contexts searches repositioning formulas editor automatically resizes affected subformulas scale giled interfaces gil proof checker model generator allowing designer work entirely graphical formulas functions access tool components provided misc pulldown menu labels check proof determines formula canvas follows premises designated designer prove checks formula canvas validity construct models determines formula canvas satisfiable check proof keeps track structure proof checks circular reasoning verified requirement need reverified designer modifies premises used either directly indirectly proof designer wishes modify proof structure situations proof fails formula proved valid counterexample displayed separate window alternatively construct models permits model infinite state sequence satisfies formula canvas displayed example verify safe1 follows specifications elevator system designer would first create requirement safe1 created saved earlier giled session load file designer would invoke check proof begin construction proof safe1 verified previously determine proof uptodate learn premises used proof current proof exists designer opt see proof ie implication automatically constructed giled validate inference new proof attempted giled prompts designer premises use proof case designer would designate init safeopen1 safeleave1 premises giled would construct proof similar shown figure 3 check valid designer also prove safe1 directly without invoking check proof building implication representing inference invoking prove determine implication valid attempt verify requirement fails designer request see counterexample consider example proof arriven shown figure 5 designer overlooks premise safen attempts prove arriven follows four premises giled generates counterexample shown figure 7 model consists infinite sequence states state predicates values shown rectangles shaded state infinitely repeated absence state predicate indicates restriction predicates value state giled displays timing diagrams beneath state sequence aid visualization designer also invoke construct models directly generate model satisfies formula canvas reqn atm openn atk openn atk atm atn openn reqn figure 7 countermodel generated safen omitted proof arriven shown figure 5 gil tools accessed anonymous ftp directory pubgil ftpcsucsbedu 6 implementation toolset figure 8 shows organization gil tools rounded rectangles depict tool components functions square rectangles depict data structures manipulated tools designer interacts tools mousedriven interface provided giled described giled helps designer create new graphical formulas retrieve modify existing ones stores formulas unix files abstract syntax trees sufficient representational information recreate layout specified designer creating giled also provides interface proof checker model generator make use intermediate representation formula semantic tableau procedure constructs tableau requires leaner abstract syntax trees productions reflect semantics merely representational variations formula proof checker model generator communicate results back giled displays designer tools run xwindow system written common lisp using garnet graphics toolkit 25 implementations gil tools discussed 4 16 18 7 related work graphical representations computer systems common software engineering practice lacked rigorous formal basis thus tended illustrative documentary rather integral part software development process notable exceptions include statechart visual formalism harel 13 pictorial version milners ccs called idccs 8 8automata manna pnueli 23 environments supporting specification verification concurrent systems built around statecharts 14 idccs languages oriented toward depiction states state transitions whereas gil focuses showing evolution properties time timing diagrams 32 graphical notation expressing precedence causality relationships events computation like gil timing diagrams created using graphical editor checked validity semantics timing diagrams defined translation subset temporal logic decided efficiently allens logic expressing temporal relationships intervals time foundation timelogic temporal reasoning system 15 logic textual graphical represen giled model generator representation level abstract trees semantic level abstract trees procedure proof checker figure 8 gil tools tations used show relationships among intervals clearly moszkowskis interval temporal logic 11 provides intervallike chop operator c infor mally f cg true context exists point partitions context prefix satisfying f suffix subcontext satisfying g intuitive semantics chop appealing decision problem formulas chop nonelementary depth nested alternations chop negation contrast intervals gil operational semantics increase complexity decision problem severely gil express stronger version chop suffices expressing properties interest systems considered gil closest interval logic il 33 largely inspired however several presentational semantic differences two logics discuss briefly il gil provide explicit construction intervals using search operations however differ way construct intervals composition searches il every search restricts context intervals obtained nesting searches yielding increasingly narrower contexts gil start end interval located independently means sequential composition searches searches il intervals rather states formulas hold gil loss gain expressiveness either approach feel statebased semantics gil easier define understand moreover searching intervals requires introduction event intervals representing positive transitions formulas begin end operators used indicate intervals located searching restrict context il permits searches past well future allowing unrestricted searches past makes decision procedure gil nonelementary 28 major difference il presence future past searches appear affect complexity decision procedure plaisted 26 demonstrated decision procedure il obtained translation regular expressionlike language nonelementary decision problem pspacecompleteness il later established aaby narayana 2 give translation il elementary nonlogical fragment nonelementary logic reduction tedious unnatural points need simpler semantics retains advantages able reason within intervals proof checker gil based direct automata theoretic decision procedure textual interval logic described appendix complexity automaton construction 2 k formula size n depth k interval nesting 29 experiment graphical representation il specification alternating bit protocol 24 demonstrated visual representation results intuitive natural spec ifications leaner semantics logic make amenable il clean graphical representation 8 conclusion paper described visual logic specifying concurrent software systems aids formal reasoning temporal properties systems experiments logic produced graphical specifications sliding window protocol 17 readerswriters database system 5 protocol commit transactions shared database 18 fair mutual exclusion algorithm 4 addition elevator system prototype toolset supporting analysis gil specifications developed current research addressing issues relating display gil formulas specification temporal properties particular experimenting vertical spacing scaling size operator symbols improve visual appearance complex formulas make structure visually evident also investigating issues relating alignment formulas reflect known constraints partial ordering points recent extension giled allows designer specify constraints ordering points within specification heuristics recognizing search patterns commonly occur specifications impose ordering points specifications investigated cases giled could aid designer aligning points accordingly methods using counterexample realign points graphical formulas constitute invalid proof also explored would assist designer revising correcting proof specifications gil general certainly admits formulas lack immediate visualization sample specifications presented section 3 example semantics searching formula nested intervals subtle difficult visualize even search represented graphically however found need searches specifications concurrent systems considered experiments indicate temporal properties interest concurrent systems specified natural visually appealing manner using derived operators introduced paper ongoing research attempting identify syntactic restrictions permit inferences checked efficiently still allow natural specifications concurrent systems realtime extension gil 3031 provides primitives bounding duration intervals recently modified gil proof checker validate deductions extended logic currently experimenting use also investigating integration gil decision procedure automated reasoning system provides decision procedures useful theories linear inequalities presburger arithmetic provides better support management proofs gil toolset prototype developed demonstrate proofofconcept facilitate experiments logic graphical representation logic display formulas evolved based experience tools expect process experimentation revision continue refine current toolset working environment specification validation design concurrent software systems robust userfriendly environment permit empirical studies needed determine whether software designers find visual logic gil easier use textual logic acknowledgement authors would like thank ron dolin implementing several last minute modifications giled improve appearance formulas r propositional temporal interval logic pspace complete may compose temporal logic specifications visual specifications temporal reasoning graphical specifications concurrent software systems graphical interval logic specifying concurrent systems declarative past imperative future integrated environments formally wellfounded design simulation concurrent systems parsing twodimensional languages specification visual language syntax hardware semantics based temporal intervals propositional modal logic time intervals statecharts visual formalism complex systems statemate working environment development complex reactive systems timelogic temporal reasoning system tool interactive generation graphical interval logic formulas graphical interval logic toolset verifying concurrent systems good temporal logic temporal logic actions next 700 programming languages verification concurrent programs temporal framework specification verification concurrent programs 8automata graphical representation interval logic comprehensive support graphical highly interactive user interfaces low level language obtaining decision procedures classes temporal logics modeling concurrency partial orders interval logics temporal specification verification automatatheoretic decision procedure future interval logic really visual temporal reasoning specification systemlevel hardware designs using timing diagrams interval logic higherlevel temporal reasoning relation programs computations models temporal logic future tr modeling concurrency partial orders statecharts visual formalism complex systems graphical representation interval logic garnet propositional modal logic time intervals graphical specifications concurrent software systems interval logics temporal specification verification next 700 programming languages integrated environments formally wellfounded design simulation concurrent systems firstorder future interval logic hardware semantics based temporal intervals automatatheoretic decision procedure future interval logic realtime interval logic decision procedure specification verification concurrent programs forallautomata relation programs computations models temporal logic graphical interval logic toolset verifying concurrent systems low level language obtaining decision procedure classes temporal logics propositional temporal interval logic pspace complete declarative past imperative future interval logic higherlevel temporal reasoning may compose temporal logic specifications graphical interval logic specifying concurrent systems ctr kirsten hansen anders p ravn victoria stavridou safety analysis software requirements ieee transactions software engineering v24 n7 p573584 july 1998 george avrunin james c corbett laura k dillon analyzing partiallyimplemented realtime systems ieee transactions software engineering v24 n8 p602614 august 1998 sven jrges tiziana margaria bernhard steffen formulabuilder tool graphbased modelling generation formulae proceeding 28th international conference software engineering may 2028 2006 shanghai china miguel j hornos manuel capel onthefly model checking interval logic specifications acm sigplan notices v37 n12 december 2002 lalita jategaonkar jagadeesan adam porter carlos puchol j christopher ramming lawrence g votta specificationbased testing reactive software tools experiments experience report proceedings 19th international conference software engineering p525535 may 1723 1997 boston massachusetts united states l k dillon ramakrishna generating oracles favorite temporal logic specifications acm sigsoft software engineering notes v21 n6 p106117 nov 1996 laura k dillon qing yu oracles checking temporal properties concurrent systems acm sigsoft software engineering notes v19 n5 p140153 dec 1994 autili p inverardi p pelliccione scenario based notation specifying temporal properties proceedings 2006 international workshop scenarios state machines models algorithms tools may 2727 2006 shanghai china matthew b dwyer vicki carr laura hines model checking graphical user interfaces using abstractions acm sigsoft software engineering notes v22 n6 p244261 nov 1997 matthew b dwyer george avrunin james c corbett patterns property specifications finitestate verification proceedings 21st international conference software engineering p411420 may 1622 1999 los angeles california united states aaron g cass leon j osterweil design guidance controlled application constraints proceedings 10th international workshop software specification design p195 november 0507 2000 george avrunin james c corbett laura k dillon analyzing partiallyimplemented realtime systems proceedings 19th international conference software engineering p228238 may 1723 1997 boston massachusetts united states matthew b dwyer george avrunin james c corbett property specification patterns finitestate verification proceedings second workshop formal methods software practice p715 march 0405 1998 clearwater beach florida united states l e moser ramakrishna g kutty p melliarsmith l k dillon graphical environment design concurrent realtime systems acm transactions software engineering methodology tosem v6 n1 p3179 jan 1997 lori clarke david rosenblum historical perspective runtime assertion checking software development acm sigsoft software engineering notes v31 n3 may 2006 p bellini r mattolini p nesi temporal logics realtime system specification acm computing surveys csur v32 n1 p1242 march 2000 riccardo mattolini paolo nesi interval logic realtime system specification ieee transactions software engineering v27 n3 p208227 march 2001 laura k dillon r e kurt stirewalt inference graphs computational structure supporting generation customizable correct analysis components ieee transactions software engineering v29 n2 p133150 february betty h c cheng joanne atlee research directions requirements engineering 2007 future software engineering p285303 may 2325 2007
formal verification complex coherence protocols using symbolic state models directorybased coherence protocols sharedmemory multiprocessors complex verification techniques based automated procedures required establish correctness state enumeration approaches wellsuited verification cache protocols face problem state space explosion leading unacceptable verification time memory consumption even small system configurations one way manage complexity make verification feasible map system model verify onto symbolic state model ssm since number symbolic states considerably less number system states exhaustive state search becomes possible even largescale sytems complex protocolsin paper develop concepts notations verifiy properties directorybased protocol designed nonfifo interconnection networks compare verification protocol ssm stanford mur 4 verification tool enumerating system states show ssm much efficient terms verification time memory consumption therefore holds promise verifying much complex protocols unique feature ssm verifies protocols system size therefore provides reliable verification results one run tool b introduction caching data close processor dynamically important technique reducing latency memory accesses sharedmemory multiprocessor system multiple copies memory block may exist cache coherence protocol often maintains coherence among data copies 29 largescale systems directorybased protocols 4 5 19 remain solution choice rely efficient broadcast mechanisms moreover optimized adapt various sharing patterns current trend towards complex protocols usually implemented software protocol processor 18 flexibility proposals even exist let users define protocol perapplication basis 28 one major problem prove protocol correct several coherence transactions bearing block initiated time different processors messages may enter race condition protocol behavior often hard predict 2 protocol designer visualize possible temporal interleavings coherence messages automated procedures verifying protocol therefore highly desirable several approaches verify properties cache protocols recent paper surveys approaches 24 one important class verification techniques derives state enumeration methods reachability perturbation analysis explore possible system states 7 15 generally method starts system model finite state machines specify behavior components protocol global state composition states components state expansion process starts given initial state exercises possible transitions leading number new states process applied repeatedly every new state new state generated end global state transition diagram reachability graph showing transition relations among global states reported major drawback state enumeration approaches size system state space increases quickly number complexity components protocol often creating state space explosion problem 15 verifying system increasing numbers caches becomes rapidly impractical terms computation time memory requirement protocols become complex clear whether verifying smallscale system model provide reliable error coverage system sizes 25 recently introduced new approach called ssm symbolic state model address state space explosion problem 23 applied simple snoopy protocols single bus 2 ssm general framework verification systems composed homogeneous communicating finite state machines thus applicable verification cache protocols homogeneous sharedmemory multiprocessors ssm takes advantage equivalences among global states precisely respect properties verify data consistency ssm exploits abstract correspondence relation among global states met 3astate represent large set states 23 based observation behavior caches characterized finite state machine caches state combined class global state composed classes moreover number caches state class abstractly represented set repetition constructors indicating 0 1 multiple instances caches class abstracted global state represents family global states efficiently expanded expanding abstracted state equivalent expanding large set states ssm verifies properties protocol system size therefore verification reliable verification relying state enumeration small system sizes developed tool apply new approach illustrate application concrete case verify paper three important coherence properties protocol designed nonfifo interconnection networks nonfifo network network messages two nodes received different order sent therefore number possible races among coherence messages much larger system fifo net work demonstrate efficiency tool compare murj 8 show ssm much efficient terms verification time memory consumption therefore holds promise verifying much complex protocols paper structured follows section 2 provides outline protocol nonfifo networks verification model correctness issues mechanisms detecting various types errors discussed section 3 develop verification method sections 4 5 results study section 6 section 7 contains conclusion directorybased protocol nonfifo networks protocol inspired censier feautriers writeinvalidate protocol 4 every memory block associated directory entry containing vector presence bits indicates whether cache copy block presence bit set copy first loaded cache reset copy invalidated replaced multiple copies exist different caches must identical memory copy extra dirty bit per block directory entry indicates whether dirty cached copy exists case cannot one cached copy say copy exclusive cache exclusive copy also often called owner line enforce ownership block invalidations must sent caches presence bits set finally replacement shared copy silent sense presence bit reset memory protocol applicable general ccnumas cachecoherent nonuniform memory access machines ccnuma shared memory distributed equally among processor nodes cached private cache processor case directory attached memory partition covers memory blocks allocated thus block home memory directory entry resides implementation conceptually simple protocol requires careful synchronizations caches directory involving many cache states memory states messages caches memory complete specification design found 26 coherence messages exchanged memory caches given table 1 messages basically two types control data control messages include requests acknowledgments messages role selfexplanatory except sack synchronization message whose role become clear later following describe salient features protocol used verifica tion simplify following description refer state block cache state cache convention applies state block directory state machines throughout paper 21 cache states caches three stable states invalid shared clean copy potentially shared caches owner modified cached copyalso called exclu sive however since cache state transitions instantaneous three transient states added keep track requests issued cache yet completed 1 readmisspending rmp state block frame empty pending reception block read miss 2 writemisspending wmp state block frame empty pending reception block ownership write miss 1 coherence messages type message action memory inv request invalidate local copy invo request invalidate local copy write back memory updm request update main memory copy change local copy shared state oship ownership grant data block copy supplied memory controller nack negative acknowledgment indicating request rejected locked directory entry cache reqsc request shared copy reqo request ownership reqoc request ownership block copy dxm block copy supplied owner response updm message memory doxmr block copy supplied owner replacement doxmu block copy supplied owner response invo message memory iack acknowledgment indicating invalidation complete sack synchronization message 3 writehitpending whp state block frame contains shared copy pending reception ownership rights complete write access states sufficient system fifo network nonfifo network possible races exist coherence requests sent time two different caches block requests serialized home node responses generate may enter race reach caches order consider following case assume two processing nodes p 1 p 2 issue request exclusive copy block time request p 1 reaches home node first granted copy request p 2 processed home invalidations sent p 1 nonfifo network possible invalidation reach p 1 exclusive copy similar scenario occur p 1 requests shared copy time p 2 wants exclusive copy p 1 requests exclusive copy p 2 wants shared copy deal three race conditions protocol uses three additional transient cache states synchronize interactions caches memory states transient ownertoinvalid txoi transient sharedtoinvalid txsi transient ownertoshared txos resolve race two processing nodes requesting exclusive copy cache state wmp moves state txoi receives invalidation receives data block executes pending write writes block back memory invalidates copy end state states txsi txos solve two races similar fashion 22 memory states stable memory states indicated presence dirty bits directory shared exclusive uncached memory block stable state free unlocked meaning memory controller may accept new requests block however memory state transitions instantaneous time directory controller starts processing incoming request time considers request completed directory entry transient state locked maintain semicritical section memory block 30 requests reaching locked busy directory entry nacked three corresponding transient memory states xdata xown xownc indicate transaction progress shared copy ownership rights exclusive copy respectively typical systems fifo networks protocol based intervention forwarding processing node requests copy block exclusive remote cache home node first requests copy dirty block updates memory forwards requester owner victimizes modified copy replacement memory state remains exclusive writeback message reaches memory controller transmission reception writeback message memory controller may receive request shared copy issued another cache forward owner memory controller receives block copy sent time replacement believe block copy sent response forwarded request meanwhile forwarded request still pending problem also identified 2 solution suggested 2 counts presumed owner ignore forwarded request ever largescale system unpredictable network delays intractable problems caused forwarded request outpaced messages 25 1 directory state transitions synchronize owner memory solve problem ambiguous writeback messages use different message ids cache write back caused replacement doxmr invalidation doxmu see table 1 moreover add two transient states directory synch1 synch2 memory controller unlocks directory entry received replaced data block synchronization message example memory controller receives request shared copy reqsc request forwarded owner memory state changed xdata presumed owner written back block replies synchronization message receives request forwarded memory memory controller receives block message type doxmr synchronization message sack owner directory enters transient state synch2 waits synchronization message sack writeback message doxmr owner respectively state synch1 takes care similar case original request message reqoc shown figure 1 3 protocol model correctness properties 31 system model first step verification construct system model manageable verification complexity model leave details peculiar implementation retaining features essential properties verify early stage protocol design approach also facilitates rapid design modifications model section describe system model used verification protocol first single block modeled sufficient check properties related cache coherence 20 replacements take place time modeled processor accesses second abstract directorybased ccnuma architecture system model figure 2a appropriate since model single block model consists directory xdata reqoc doxmu sackor sackor sackor sackor reqsc doxmr doxmr doxmr doxmr multiple processorcache pairs processor associated one message sending channel ch one message receiving channel ch model message flow caches main memory message channels preserve execution order memory accesses order model nonfifo interconnections messages never lost may received different order issued cache protocol treat differently messages local processor remote processors model figure 2a equivalent model figure 2b home memory modeled independent active entity use system model figure 2b throughout paper 2 verification model directorybased ccnuma architectures third values data copies tracked abstraction first proposed 22 cache may data block one three status nodata cache valid copy fresh cache uptodate copy obsolete cache outofdate copy ch ch home memory directory fullmap ch ch ch ch base machine ch ch home memory ch ch ch ch home node abstract model ccnuma multiprocessors single block b refined model protocol machine memory copy either fresh obsolete course verification expansion process keeps track status block copies conformance protocol semantics third abstraction necessary discovered verification s3mp protocol 21 25 different protocol used paper consider protocol transactions illustrated figure 3 initially cache dirty copy block replaces performs writeback home node cache keeps valid copy block receives acknowledgment memory order guarantee memory receives block safely meanwhile cache b sends request exclusive copy home subsequently cache processes dataforwardrequest home considers acknowledgment prior writeback request sends block b b executes write replaces block due miss shown figure 3 race condition exists two writeback requests writeback b wins race stale writeback overwrites values updated b note example state transitions permissible overcome problem verification model need maintain global variable remember writeback carries latest value 3 stale writeback error 32 formal protocol model given architectural model figure 2 formally define constituent finite state machines interacting protocol convenient language specify machines csp 14 message transmission represented postfix message reception postfix definition 1 receiving channel receiving channel machine recording messages received memory transit cache structure rchm q r r xm d1 r xc set memorytocache messages table 1 messages memory home 1 writeback 2 exclusiverequest 3 dataforwardrequest 4 exclusiveforward 5 writeback messages cache messages issued memory controller consumed cache respectively definition 2 sending channel sending channel machine recording messages issued cache transit memory controller structure schm q xc d1 xm d2 set cachetomemory messages table 1 messages cache messages memory messages issued cache consumed memory respectively state channel machine made messages transit state expansion step receiving sending channel may record command sent memory cache may propagate command cache memory behavior cache controller given definition 3 definition 3 cache machine state machine characterizing cache behavior structure cm q c r xc d1 c xc d2 c coherence messages defined definitions 1 2 xc xc messages consumed produced cache respectively upon receiving message cache controller may may respond generating response messages according d1 c additionally embed processor machine cache machine processor may issue accesses local cache may cause cache state changes issuance coherence messages specified d2 c finite state machines main memory protocol formalized follows definition 4 memorydirectory main memory machine keeping directory structure messages defined definitions 1 2 xm xm cachestomemory memorytocaches commands respectively memory machine consumes message response messages may may sent caches q bm denotes set possible states base machine defined definition 5 base machine base machine composition cache machine two corresponding channel machines bm definition 6 protocol machine protocol machine defined composition base machines memory machine pm n caches state tables used verification d1 c d2 c found 26 memory controller consumes messages caches responds according block state message type finally state protocol machine also referred global state paper 33 correctness properties protocol paper verify three properties data consistency incomplete protocol specification livelock following definitions 331 data consistency basic condition cache coherence given 4 loads must always return value updated latest store address formulate condition within framework reachability expansion follows definition 7 data consistency respect particular memory location protocol preserves data consistency following condition always true reachability analysis family global states originated g including g consistently return load value written store access writes recent value memory location brings global state g g value written store transitions states reached expanding g allowed access old value defined architectural model figure 2 memory accesses made several consecutive events thus atomic constrain way sequences access generated processors moreover hardware distinguish synchronization instructions regular loadstore instructions paper latency tolerance mechanisms processors caches modeled assume mechanisms correct enforce proper sequencing ordering memory accesses cooperation software based model data values section 31 data inconsistency detected processor allowed read data obsolete values definition 8 detection data inconsistency data copies tagged values set nodata fresh obsolete data transfers emulated expansion data inconsistency detected processor allowed read data obsolete values 332 incomplete protocol specification unforeseen interleavings events protocol specification often incom plete especially early phases development flaw manifests unspecified message reception ie entity protocol receives message unexpected given current state 31 state machine models effective detecting unspecified message reception procedure simple directly tied structure reachability graph unspecified message reception detected system state message received transition state specified protocol description besides detecting error state enumeration shows path leading erroneous state 333 deadlock livelock protocol deadlocked enters global state without possible exit livelock situation processes interacting protocol could theoretically make progress trapped loop states eg processor keeps retrying request always rejected another processor deadlocks easy detect state enumeration since states without exits states difficult detect livelocks level abstraction adopted paper protocol components communicate via messages thus detect deadlocks livelocks derived services functional ity provided cache coherence protocol example protocolintrinsic livelock blocked processor waiting message eg invalidation acknowledgment never sent another processor protocol specification deadlock livelock conditions due particular implementation protocol finite message buffers fairness serving memory requests cannot detected level abstraction definition 9 livelock context coherence protocols livelock condition given block locked processors processor permanently prevented accessing block 20 state expansion process check following conditions order detect livelocks correct protocol conditions livelockfreeness protocol visit every state global state transition diagram infinitely many times global state transition diagram stronglyconnected given global state every state global state transition diagram reachable 2 b processor issues memory access block memory access must eventually satisfied eg value always returned load resume processor execution specifi cally given initial global state cache invalid state must exist reachable global states cache state becomes shared dirty read miss access 20 conditions b sufficient avoid livelocks defined definition 9 assure every processor read modify block arbitrary number times condition stronger necessary assumes cache protocol operates steady state cache protocol machine might start initial state never return later case global state graph would comprise two subgraphs one subgraph consisting initialization state would exits second subgraph corresponding steady state operation protocol vice versa special case identified careful analysis state graph livelock reported 4 verification method models figure 2 order states base machines global state representation irrelevant protocol correctness symmetry size state space reduced factor n given system n processors symbolic state model ssm exploits powerful abstraction relations symmetric relation order reduce size state space reliable new abstraction must equivalent system model respect properties verify 41 equivalence state transition systems general formalize system verify finite state transition system definition 10 finite state transition system respect cache block behavior cache system local cache automata modeled finite state transition system ms 0 0 initial state set state symbols global state space subset set operations causing state transitions represents state transition function consider state transition system 0 respect properties p verify want find abstract state transition system corresponds r smaller error states mapped error states r definition 11 correspondence given two state transition systems 0 r corresponds exists correspondence relation j 1 0r corresponds 0 ie 0r js 0 2 least one state corresponds ie r js 3 state makes transition state enabled operation state r r corresponds state exists state r r moves r r r corresponds figure 4 illustrates correspondence relation 4 correspondence relation definition 12 equivalence two state transition systems r r corresponds equivalent respect property p verify iff following conditions verified step expansion r let r current correct state r let r next state r transition 1 p verified r p holds states r jt 2 p hold r jt p hold r 3 p hold r must exist states r js r jt p hold first condition definition 12 establishes expansion r completes without violating property p expansion would also complete without violating p second third conditions definition 12 ensure error state discovered expansion r iff error state exists error state r corresponds error state following first specify abstract machine r corresponding protocol machine definition 6 prove r equivalent respect cor rectness properties section 33 42 abstract ssm models atomic memory accesses ssm method first introduced 22 assumption atomic memory accesses developed abstraction relation among global states based observation order model cache protocols state must keep track whether exists 0 1 multiple copies exclusive state latest copy data hand number readonly shared data copies affect protocol behavior provided least one cached copy symbolic states represented using repetition constructors definition 13 repetition constructorsatomic memory accesses 1 null 0 specifies zero instance 2 singleton 1 specifies one one instance constructor omitted state representation 3 plus specifies one multiple instances 4 star specifies zero one multiple instances repetition constructors represent example set global states one multiple caches invalid state zero one multiple caches shared state metastate corresponds set explicit states 5 ordering relations among repetition constructors repetition constructors ordered sets states represent thus 1 figure 5 ordering relations extend metastates called composite states 22 example contained set global states represented first composite state subset represented second composite state containment relation among composite states composite states contained composite state kept verification end state expansion state space collectively represented relatively small number essential composite states r 23 43 ssm models nonatomic memory accesses model protocols nonatomic accesses need define elements forming basis repetition abstraction add new repetition constructor called universe constructor model figure 2 base machines naturally form units abstraction repetition henceforth set base machines state represented c cache state p value presence bit directory r number base machines set specified one repetition constructors r state receiving channel state sending channel r specified messages transit channels since channels model nonfifo networks order messages channel irrelevant often confusion part notation may omitted example use notation q combines cache state states two message channels although singleton plus star useful represent unspecified number instances given construct base machines given global state precise enough model intermediate states complex protocol transactions triggered event counting consider abstract state write miss occurs caches shared state must invalidated ultimate state processor state exclusive dirty copy behavioral level 23 state transition done one step memory accesses assumed atomic however accesses longer atomic invalidations sent caches state number shared copies counted onebyone upon receiving invalidation acknowledgments result need distinguish two states contained metastate two states correspond cases either caches state deal problem first define inval idationset definition 14 invalidationset invalidationset invset contains set caches presence bits set must invalidated memory grants exclusive copy request exclusive copy requestforownership reqo requestfor ownercopy reqoc protocol pending memory copies must invalidated state expansion process needs keep track whether invalidationset empty since caches state specified repetition constructors exact number caches particular state unknown using constructor alone represent number copies may prevent expansion possible states consider following composite state invalidationset brack ets q denotes base machines presence bits reset 6 expansion steps null nonnull instances covered constructor memory receives request exclusive copy reqoc cache state c cannot determine whether invalidationset empty definition includes cases null nonnull instances one way solve shortcoming notation explore cases expansion process global state expanded two states corresponding empty nonempty invalidationset generated expansion steps shown figure 6 expansion step q 1 means machines state q 1 change state q 2 others remain q 1 c1 c2 c f reqoc f reqoc data f s3 qc1 f iack f iack s4 qc2 data f f iack caches c1 acknowledge invalidation requests c1 changes c1 memory receives iacks caches c2 caches c2 respond inv c2 changes c2 memory receives iacks caches c2 1 s0 suppose memory receives request exclusive copy cache state c two states corresponding empty nonempty invalidationset generated s2 invalidations sent caches invalidationset whereas s1 requester obtains exclusive copy new owner invalidationset empty 2 expansion s2 caches state c2 receive invalidations respond invalidation acknowledgment change state c2 3 memory receives invalidation acknowledgments caches state c2 s3 two states empty nonempty invalidationsets generated 4 global state s5 assume caches state c1 acknowledge invalidations incorrect design s6 acknowledgment messages caches state c2 received memory expansion may consider invalidationset empty make transition s4 however case invalidationset empty also covered must also expanded either process never stops errors go undetected order solve problem expansion process needs remember expansion path followed figure 6 transitions s0 s1 s0 s2 correspond empty nonempty invalidationset respectively however invalidationset s2 fact cover three cases 1 2 3 unfortu nately splitting states s2 results combinatorial explosion state space efficient solution work state s2 keep track whether invalidationset empty end introduce new constructor called universe constructor u construc tor transition applied nonempty invalidationset form null case generated rather components inside invalidationset expanded one one without considering null case keep track fact expanded component least without considering null case use u constructor component expansion type u constructor similar except transition null case exercised expansion inval idationset invalidationset may considered empty form lets examine expansion steps using u constructor see procedure works figure 7 1 global state s1 expansion process explores path caches respond invalidations global state s2 constructor replaced u class caches x n q 2 q remaining c2 next time expanded expansion process consider null case 7 resolution provided u constructor 2 global state s3 expansion process chooses expand class caches state c1 considering case nonempty set caches state c1 acknowledge invalida tions process moves state s4 according condition emptiness invalidationset pending request exclusive copy state s4 never resumed caches class c1 situation easily detected livelock situation protocol trapped loop s2 qc1 f iack s3 qc1 f iack f iack f iack c2 f iack f iack c2 f iack data f caches c1 dont acknowledge inv caches c1 acknowledge inv c1 changes c1 caches c2 respond inv c2 changes c2 memory receives iacks caches c2 memory receives iacks caches c1 memory receives iacks caches c1 c2 pending request f reqoc never resumed 3 hand caches invalidationset acknowledge memory expansion process takes another path states s4 s5 s6 occurrence event counting writeinvalidate protocols collection acknowledgments invalidations writeupdate protocols updates must acknowledged way equivalent invalidationset could called updateset 44 symbolic state model combining basic framework section 42 refinement section 43 system unspecified number caches group base machines state state classes specify number class one following repetition constructors definition 15 enhanced set repetition constructors 1 null 0 specifies zero instance 2 singleton 1 specifies one one instance constructor omitted state representation 3 plus specifies one multiple instances 4 star specifies zero one multiple instances however case zero instance explored transactions depending event counting expansion 5 universe u specifies zero one multiple instances case zero instance explored transactions depending event counting expansion definition 16 composite state composite state represents state protocol machine system arbitrary number base machines constructed state classes form nq bm number states base machine q q bm r 0 1 u q mm q memory machine state repetition constructors ordered possible states specify namely 1 8 order leads definition state containment 8 ordering relations among repetition constructors enhanced set q n definition 17 containment say composite state 2 contains composite state 1 1 q consequence containment family states represented 2 superset family states represented 1 therefore 1 discarded verification process provided prove expansion process based expansion rules section 441 monotonic operator set composite states memory event applied 1 2 441 rules expansion process set operators applicable composite states state generation process defined follows stands shows state transition 1 aggregation q 0 q r 2 coincident transition q 1 r r 1 u observed transition 3 onestep transition q q 1 b q q 1 machines state q 1 denoted q tuple transition applied base machine state q 1 q 1 q 2 causes base machines q 1 move state q 3 transition machines q may affected shown change q q 4 nsteps transitions rule specifies repetitive application transition n times n arbitrary positive integer q q 1 q mm b q q 1 c q q 1 5 progress transitions provided q 1 q 2 q mm q r 1 q mm states bracket form invalidationset base machines invalida tionset denoted q tuples aggregation rules group base machines state one example coincident transition memory controller sends invalidation signal every cache valid copy onestep transition occurs example memory receives request exclusive copy base machine class q 1 base machine changes state q 2 request message removed sending channel memory normally processes one request exclusive copy time case machines q 1 q may stay state may change state new invalidation messages sent receiving channel rules b c nsteps transition correspond two chains transitions transition q 1 q 2 applied unlimited number times long base machines state q 1 transition effect machines denoted q tuple typical examples 1 processors replacing copy state shared 2 processors receiving type messages 3 processors issuing memory access independently two additional rules similar interpretation nsteps transitions required progress expansion process progress transitions deal protocol transactions involving event counting explained section 43 correspond two chains transitions q mm q mm protocol model processing request exclusive copy memory transition reception invalidation acknowledgment iack table 1 invset set caches presence bits set memory must invalidated memory grants exclusive copy rule applies invalidation process whereas rule b applies successful invalidation copies state expansion process cache transactions possible current state explored state expansion step two phases first new composite state produced applying one transition rules current state second aggregation rule applied lump base machines state see example figure 11 45 monotonicity state expansion general system verify composed finite state machines one machine communicate machines directly composite state ssm form possible states machine r repetition constructors partial order exists among repetition constructors one figure 8 state expansion rules include aggregation rules onestep transition rules compound transition rules corresponding multiple applications onestep transition rule aggregation rules rules used represent symbolic states compactly possible based partial order repetition constructors abstract state representation containment composite states based partial order among constructors context prove expansion rules ssm monotonic operators namely intuitively ssm state 1 contained 2 expansion step done correctly next states states included 1 must also contained 2 expansion containment abstract states ssm independent properties verify properties data consistency see definition 7 formulated users checked reduced state space lemma 1 aggregation process monotonic q possible state state machine r repetition constructors proof proof follows ordering relation among repetition constructors checking possible combinations r 11 r 12 r 21 r 22 subject constraints lemma aggregation rule q lemma 2 immediate successor 1 originated state contained state 2 originated state expansion rule taken memory event q n q r 21 q n q n applied 1 2 proof need consider effect applying machines state q 1 2 simplify notation classes q j j lumped q provided q q k following two states generated onestep transition rule applied 1 2 q means transition may cause state changes machines since includes case single base machine must contain case zero base machine clear 1 containment relation also true compound rules involving multiple onestep transitions nsteps rule progress rule applied 1 2 q lemma 3 claim 1 2 holds proof aggregation process monotonic lemma 1 lemma 3 simply extends results lemma 2 q theorem 1 monotonicity 1 2 every 1 reachable 1 exists 2 reachable 2 1 2 proof immediate result lemma 3 q algorithm state expansion process shown figure 9 two lists keep track nonexpanded visited states step new state produced states contained states pruned final output set essential states definition 18 essential state composite state essential exist composite state readers aware fact generation essential states successful verified system correct system incorrect expanding error states lead unpredictable states practically meaningless assume state expansion process terminates whenever error detected illustrated figure 10 state space reported end errorfree expansion process partitioned several families states may r r overlapping represented essential composite states 23 9 algorithm generating essential states theorem 2 essential composite states generated algorithm figure 9 complete symbolically represent states produced basic state enumeration method state abstraction proof consider states state enumeration method composite ssm states r r r r symbolic form r covers resulting next state r also covers generation composite states transition functions applied information accumulated expansion q 451 uniqueness set essential states set essential states unique provided state graph connecting essential states strongly connected namely exists least one path every essential state essential states algorithm essential states generation w list working composite states h list visited composite statesoutputessential states w empty begin get current state w state class v applicable operations v state p w q h discard else begin remove p w p remove q h q add w discard terminate loops starting new run insert h fully expanded contained end theorem 3 successful run verification starting legal initial state generates set essential states es state transition graph formed essential states es strongly connected set es unique sense state expansion process always produces set essential states es starts legal reachable state proof set essential states defines fixpoint state expansion process terminates theorem 2 states es represents possible configurations system reach therefore must contained least one e es symbolic state expansion monotonic states derived contained states derived e state transition graph es strongly connected must exist least one path e essential states impossible reach essential state e es q 10 representation state space essential states theorem 3 hold state graph strongly connected consider simple case state graph consists two subgraphs g1 g2 g1 g2 individually strongly connected paths exist g1 g2 vice versa state expansion process starts state contained states g2 states g1 subgraph g2 produced order generate entire state graph state expansion must start state g1 however livelock error g2 transition g1 may reported case according conditions section 333 overcome problem isolate subgraphs analyze protocol designers cannot determine whether state graph strongly connected advance however normally safe start state expansion process initial state caches invalid usually state system turned 46 accumulation state information accumulation compaction state information composite states major strength ssm method approaches consider simple state transition caused read misses assumption atomic memory accesses essential state initially processor copy block read miss caches receive shared data copies caches remain invalid state order reach state shared shared invalid covered shared traditional state enumeration method would need model least three caches general difficult predict number caches needed model reach possible states protocol ssm method eliminates uncertainty since verifies protocol model independently number processors 5 correspondence state enumeration ssm models shown ssm expansion monotonic still need prove abstract ssm state transition system r 0r r r equivalent explicit state transition system ms 0 respect properties section 33 correspondence relation j ssm follows definition 19 correspondence relation state corresponds state ie r js one states abstractly represented r state local automaton number local automata state must case covered repetition constructor r j namely always find abstract initial state 0r corresponds initial state 0 explicit model instance normal start verification initial state cached copy exist case caches invalid invalid invalidinvalid theorem 4 consider state transition system ms 0 explicit model arbitrary number local automata abstract state transition model r ssm consider two states state local automaton given r js find r jtthen state violates properties section 33 iff r error state r proof 1 regard data consistency completeness specification proof direct conse r2 q n rn 1 2 i1m q j1n i1m q j i1m q j 1 2 r2 q n rn i1m q j1n quence theorems 1 2 one states represented r ie r js monotonic operation ssm guarantees state characterized r furthermore data consistency completeness specification properties checked current states independent states instance data inconsistency found processor allowed read stale data definition 8 thus r must error state error state vice versa 2 show absence simple deadlocks livelocks defined definition 9 need show processors never trapped able complete reads writes eventually sec tion 33 consider explicit model trapped subset states s1 s2 s3 sn s1 abstract ssm model r must corresponding set states s1 r s2 r s3 r sn r s1 r si r jsi theorem 1 theorem 2 suppose circular loop s1 r s2 r s3 r sn r s1 r broken enabled transition si r r corresponding exit si must exist ti r jt r constituent finite state machines q 6 protocol error detection since unexpected message reception errors easy detect describe model procedure detecting inconsistencies also present subtle livelock error found course verification finally compare performance ssm method murj terms time complexity memory usage verification results reported expansion process starts initial state cached copy empty message channels state ssm method initial state free 61 data inconsistency detection mechanism data inconsistency based model described section 331 status variable added caches channel messages carrying data possible values nodata n fresh f obsolete status memory copy fresh f obsolete movement data copies modeled assigning status one variable another variable figure 11 state class augmented parentheses status associated every data value figure illustrates state transitions triggered read miss request reqsc transition ending owner copy cache accordance definition 7 owner fresh copy whereas copies including memory copy become obsolete data inconsistency detected whenever processor read obsolete data 62 livelock expansion steps leading livelock original protocol described ini tially consider system state owner request progress directory entry free state form free 11 data transfer detection data inconsistency ssm consider following scenario 1 owner replaces copy writes block back memory state indicating writeback message output channel n data f f reqsc wmp n fresh copy cached state fresh copy propagation caches copy directory free accept new requests memory copy fresh n data f data f f reqsc wmp n state transition memory responds reqsc requests n data f f reqsc wmp n load data memory aggregation state transition n data f f reqsc wmp n many intermediate states shown writemiss request loads data memory successfully invalidating cached copies n f reqsc wmp n state transition receiving data executing pending write new owner fresh data memory copy becomes obsolete 2 next cache experiences write miss sends request exclusive copy new state free race exists writeback ownership messages case nonfifo network 12 livelock detection ssm 3 memory receives ownership message writeback message case memory state changed xownc invalidation invo sent cache memory still records cache owner resulting state xownc 4 cache receives invo message changes state txoi system state becomes xownc wmp f doxmr reqoc nack f rmp f reqsc wmp nack f wmp f reqoc wmp f reqo wmpinvo doxmr xownc nack f rmp f reqsc wmp nack f wmp f reqoc wmp f reqo wmpinvo f synch1 nack f rmp f reqsc wmp nack f wmp f reqoc wmp f reqo txoif doxmr xownc nack f rmp f reqsc wmp nack f wmp f reqoc wmp f reqo txoif f synch1 nack f rmp f reqsc wmp nack f wmp f reqoc wmp f reqo wmpf doxmr reqoc initial state loop forever sink state memory receives reqoc read miss miss miss read miss read miss read miss miss miss cache receives nack memory receives aborts reqsc cache receives nack cache receives nack cache receives nack memory receives aborts reqsc memory receives aborts reqsc memory receives aborts reqsc memory receives aborts request memory receives aborts request memory receives aborts request memory receives aborts request cache receives nack cache receives nack cache receives nack cache receives nack memory receives doxmr cache receives invo memory receives doxmr wmp invo doxmr txoi 5 finally memory receives writeback message enters synchronization state synch1 expect synchronization message sack cache figure 1 system state synch1 however synchronization message never sent cache locks directory entry forever ssm method error successfully detected reporting cycle exists four global states without exit state outside loop shown figure 12 global state transition diagram strongly connected error detected present murj system checking connectivity global state diagram overwhelmingly complex size global state diagram large livelock condition originates fact memory check presence bits receives ownership request livelock removed following correction protocol memory receives reqoc message checks whether processor identifier message corresponds current owner memory state changed synchronization state synch1 directly following state diagram figure 1 later writeback message arrives memory updates copy block supplies cache copy block unlocks directory entry 63 comparison murj system murj system developed dill et al 8 based state enumeration two versions murj nonsymmetric murj system murjns symmetric murj system murjs murjns two system states equivalent identical whereas murjs exploits symmetry system using characteristic state represent states permutations 16 example two system states composed three local cache states shared shared invalid invalid shared shared deemed equivalent order cache states global state representation irrelevant correctness protocol time complexity memory usage verification closely related size system state space generally exhaustive search algorithm performs three fundamental operations 1 generate new state left otherwise terminate report final set global states 2 compare new state set previously visited states 3 keep new state future expansion new state visited timeconsuming step comparing new state previously visited states time complexity grows proportion size search space set states generated analyzed procedure memory usage increases size global txoi state space set states saved reported end since search space direct expansion global state space reducing size global state space particularly important murj incorporates state encoding reduce memory usage hash tables speed search comparison operations optimizations implemented ssm table shows performance comparisons murjns murjs ssm running model mbytes memory verification protocol make following observations first smallscale systems less five processors time complexity memory usage murjns murjs tolerable second sizes global state space search space murjs significantly less murjns little difference times taken methods case four processor systems observe murjs takes longer murjns extra overhead due state permutation mappings murjs may explain processors added model verification time memory usage increase drastically cases compared murj ssm efficient verification based ssm runs 09 seconds mbytes memory state space 123 global states comparatively small fact performance classical enumeration techniques acceptable small system sizes raises question whether elaborate approaches ssm really needed since final set essential states reported ssm covers possible states system reach essential states maximum number base machines different states represent complex states system verification using ssm complex essential states consisted 25 base machines different states means system model least 25 processors required obtain 100 error coverage state enumeration method case murjns observe roughly times increase size search space time one process added model trend continues 25 proces sors search space could reach size 10 37 states model 25 processors time 2 comparison ssm murjns murjs method number processors size global state space size search space verification time memory usage mbytes murjns 5 excessive memory usage 200mbytes murjs ssm n 1 123 4205 09 002 memory space needed verification complexity would prohibitive existing machine protocol verified paper number messages floating one message channels time bounded spite fact number processors model arbitrary however ssm method preclude possibility protocol may allow processors send multiple even arbitrary number messages type 25 result model message channels may need adapted using finite variables represent infinite system behavior 13 cases repetition constructors might useful keep track abstractly number messages type ssm method detect protocolintrinsic livelocks section 333 number global states reported relatively small 123 states case time complexity checking connectivity global state transition diagram manageable murj 7 conclusion cache coherence protocols designed systems assuming nonfifo networks required systems adaptive routing faulttolerant interconnection networks paper verified directorybased cache coherence protocol nonfifo networks verification protocol done murj system ssm method generally speak ing study found murj system effective verifying smallscale systems manageable complexity however shown protocol verified paper system model least 25 processors required order reach 100 error cover age many processors complexity state space search would prohibitive murj system whereas performance ssm shows could deal much complex protocols one used paper overall ssm method offers three advantages classic state enumeration methods state abstraction first overcomes state explosion problem second since entire global state space symbolically represented small number essential states time complexity checking connectivity global state transition diagram needed livelock detection manageable third verifies protocol system size recently ip dill integrated variation ssm method murj 17 tool expands explicit states infers abstract states based generated explicit states whereas tool works directly abstract states therefore new murj tool may require multiple runs adding one processor model consecutive run reach complete verification results obtained method experience confirms classical state enumeration approaches sufficient verify protocols systems small numbers processors whereas methods based symbolic state representations ssm critical future design complex protocols largescale multiprocessors architectural model figure 2 memory accesses made several consecutive events thus atomic constrain way sequences access generated processors moreover hardware distinguish synchronization instructions regular loadstore instructions paper latency tolerance mechanisms processors caches modeled assume mechanisms correct enforce proper sequencing ordering memory accesses 9 however methodology ssm preclude verification consistency presence latency tolerance hard ware order include latency tolerance hardware synchronization accesses must modeled sequence accesses generated processors constrained memory consistency model 11 approach applied 26 27 delayed consistency protocol specified 10 whereas state enumeration approaches appropriate verifying coherence properties seem applicable verification memory access orders reason one found way far formulate verification property memory order state enumeration graph thus verification memory access orders must still rely testing procedures 6 manual proofs 1 12 acknowledgments research supported national science foundation grant ccr 9222734 also want acknowledge contributions david l dill c norris ip provided invaluable information murj system r lazy cache algorithm cache coherence problem sharedmemory multiprocessors cache coherence protocols evaluation using multiprocessor simulation model new solution coherence problems multicache sys tems directorybased cache coherence large scale multiprocessors reasoning parallel architectures protocol representation finitestate models protocol verification hardware design aid memory access buffering multiprocessors delayed consistency effects miss rate parallel programs mem ory consistency event ordering sharedmemory multiprocessors proving sequential consistency high performance shared memories verification distributed cache memory using abstractions communicating sequential processes algorithms automated protocol verification better verification symmetry verifying systems replicated components murj stanford flash multiprocessor design directorybased cache coherence protocol dash multiprocessor formal verification gigamax cache consistency protocol s3mp scalable shared memory multiprocessor verification cache coherence protocols new approach verification cache coherence proto cols survey techniques verifying cache coherence proto cols verifying distributed directorybased cache coherence protocols s3mp case study symbolic state model new approach verification cache coherence protocols formal verification delayed consistency protocols tempest typhoon userlevel shared memory survey cache coherence schemes multiprocessors data coherence problem multicache system towards analyzing synthesizing protocols tr cache coherence protocols evaluation using multiprocessor simulation model memory access buffering multiprocessors cache coherence problem sharedmemory multiprocessors lazy cache algorithm survey cache coherence schemes multiprocessors directorybased cache coherence largescale multiprocessors proving sequential consistency highperformance shared memories extended abstract delayed consistency effects miss rate parallel programs reasoning parallel architectures verification cache coherence protocols stanford flash multiprocessor tempest typhoon symbolic state model verification techniques cache coherence protocols communicating sequential processes new approach verification cache coherence protocols protocol verification hardware design aid formal verification delayed consistency protocols verifying distributed directorybased cahce coherence protocols verification distributed cache memory using abstractions verifying systems replicated components murphi better verification symmetry
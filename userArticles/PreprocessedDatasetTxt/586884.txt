separation npcompleteness notions use hypotheses structural complexity theory separate various npcompleteness notions particular introduce hypothesis describe set np mboxleqrm prm tcomplete mboxleqrm pttcomplete provide fairly thorough analyses hypotheses introduce b introduction ladner lynch selman lls75 first compare strength polynomialtime reducibilities showed common polynomialtime reducibilities turing btt manyone means p r properly stronger p b converse hold case verifying sets belong ladner lynch selman raised obvious question whether reducibilities differ np exist sets b np empty set p b immediately mind conjectured p np implies p differ np intervening years many results explained behavior polynomialtime reducibilities within complexity classes led complete understanding completeness notions reducibilities induce example ko moore km81 demonstrated existence p complete sets exp p complete watanabe wat87 extended result significantly showing p btt tt p completeness exp mutually different homer kurtz royer kr93 proved p p 1tt completeness identical department computer science engineering university buffalo buffalo ny 14260 email department computer science engineering university buffalo buffalo ny 14260 email selmancsebuffaloedu however results comparing reducibilities within np known little concerning various notions npcompleteness surprising npcomplete problem discovered requires anything manyone reducibility proving completeness first result distinguish reducibilities within np observation wilson one selmans papers pselective sets sel82 corollary results ne cone e exist sets b belonging np p ptt b b p ptt denotes positive truthtable reducibility regarding completeness longpr e young ly90 proved p complete sets np p reductions sets faster prove completeness notions differ first give technical evidence p completeness np differ lutz mayordomo lm96 proved pmeasure np zero exists p 3tt complete set p complete ambosspies bentzien asb00 extended result significantly used hypothesis resourcebounded category theory weaker lutz mayordomo separate nearly npcompleteness notions bounded truthtable reducibilities remained open question whether separate npcompleteness notions without using hypotheses involve essentially stochastic concepts furthermore comparisons reducibilities within np known date listed report exciting new progress questions main new result introduces strong reasonable hypothesis prove existence p complete set np p tt complete result first provide evidence p tt completeness weaker p completeness let hypothesis h following assertion upmachine accepts 0 polynomial timebounded turing machine correctly computes infinitely many accepting computations ii e 0 2 n e timebounded turing machine correctly computes accepting computations hypothesis h similar seemingly stronger hypotheses considered researchers previously notably fenner fortnow naik rogers ffnr96 hemaspaan dra rothe wechsung hrw97 fortnow pavan selman fps99 result especially interesting measure theory category theory techniques seem successful primarily nonadaptive reducibilities wewill prove elegant characterization genericity hypothesis ambosspies bentzien compare hypothesis h somewhat informally let us say genericity hypothesis asserts existence set l np 2 2n timebounded turing machine correctly predict membership infinitely many x l initial characteristic sequence l almosteverywhere unpredictable within time 2 2n clearly set l 2 2n biimmune contrast show hypothesis h holds set l upcoup l pbiimmune l0 dtime2 n e e 0 thus replace almosteverywhere unpredictable pbiimmunity lower time bound 2 2n 2 n e require l belong coup rather np prove several separations well significantly weaker hy potheses example prove np contains p complete sets p complete np conp contains set 2 n e biimmune e 0 preliminaries use standard notation polynomialtime reductions lls75 assume readers familiar turing p manyone p reducibilities set truthtable reducible set b symbols p tt b exist polynomialtime computable functions g h input x gx set queries q q 1 q 2 q k x hxbq 1 1 function g truthtable generator h truthtable evaluator constant k 0 ktruthtable reducible b ktt b x boundedtruthtable reducible b p constant k 0 p ktt b given polynomialtime reducibility p r recall set p r complete np np every set np p r reducible recall set l pselective exists polynomialtime computable function x f xy xy f xy belongs l either x l l sel79 function f called selector l given finite alphabet let w denote set strings infinite length order type w r w standard left cut r sel79 sel82 set ordinary dictionary ordering strings 0 less 1 obvious every standard left cut pselective selector f xy minxy given pselective set l function f defined f selector l call f minselector l use following simplified version lemma toda tod91 pselective set minselector f finite set q exists string z q z string z called pivot string review various notions related almosteverywhere hardness language l immune complexity class c c immune l infinite infinite subset l belongs c language l biimmune complexity class c c biimmune l infinite infinite subset l belongs c infinite subset l belongs c language dtimet ncomplex l belong dtimet n almost everywhere every turing machine accepts l runs time greater x finitely many words x balc azar sch oning bs85 proved every timeconstructible function l dtimet ncomplex l biimmune dtimet n given time bound n language l nprintable exists n timebounded turing machine input 0 n prints elements ls n hy84 set nprintableimmune infinite infinite subset nprintable order compare hypotheses genericity hypothesis describe timebounded genericity asfh87 purpose follow exposition ambosspies neis terwijn asnt96 given set string x nth string lexicographic order identify initial segment az n characteristic sequence ie az n az condition set c meets c x characteristic sequence ax c c dense along infinitely many strings x exists 01 concatenation axi c set dtimetngeneric meets every condition cdtimetn dense along simplify notation say tngeneric dtimetn generic finally briefly describe kolmogorov complexity finite string later use oracle construction interested reader refer li vit anyi lv97 indepth study fix universal turing machine u given string x finite set kolmogorov complexity x respect defined 0 kxs called kolmogorov complexity x denoted kx use timebounded kolmogorov complexity k x also definition require runs tx steps 3 separation results let hypothesis h following assertion hypothesis h upmachine accepts 0 1 polynomial timebounded turing machine correctly computes infinitely many accepting computations 2 e 0 2 n e timebounded turing machine correctly computes accepting computations theorem 1 hypothesis h true exists p complete language np p tt complete np proof let upmachine satisfies conditions hypothesis h n unique accepting computation 0 n let l define language define infinite string 1 2 define standard leftcut define disjoint union l 1 l 2 prove l complete np p complete np proof clear l belongs np following reduction witnesses sat p given input string x use binary search algorithm queries l 2 find n note x sat xa n belongs l 1 lemma 3 l p tt complete np proof assume l p tt complete np define set ith bit clearly belongs np thus assumption p tt reduction gh l given reduction derive contradiction hypothesis h consider following procedure 1 input 2 compute sets q 3 let q 1 set queries q l 1 let q 2 set queries q 4 q 1 contains query xa n e output unsuccessful print else output successful observe procedure runs polynomial time treat two cases namely either 0 n unsuccessful infinitely many n successful finitely many n procedure 0 n unsuccessful infinitely many n polynomial timebounded turing machine correctly computes infinitely many accepting computations thereby contradicting clause 1 hypothesis h proof 0 n unsuccessful outputs string n e hence 0 n unsuccessful infinitely many n infinitely many exists n outputs following procedure uses observation compute infinitely many accepting computations polynomial time 0 j outputs output halt procedure runs polynomial time procedure 0 j runs polynomial time finitely many n 2 n e timebounded turing machine correctly computes accepting computations thereby contradicting clause 2 hypothesis h proof demonstrate procedure b n 0 n successful b input 0 n outputs accepting computation 0 n 2 n e time 0 n successful member set q 1 form xa n e begin task following procedure c query decides whether q l 1 1 input 2 z z belong l 1 determined polynomial time 3 z n e z belongs l 1 belongs sat since n e step done time 2 n e thus c decides membership l 1 queries q q 1 therefore query q q 2 decide whether q belongs l 2 evaluator h determine whether input 0 n belongs query q q 2 decide whether q belongs l 2 compute n accomplish using standard proof technique pselective sets hnos96 tod91 namely since l 2 standard left cut lemma 1 exists pivot string z q 2 q 2 l 2 set strings q 2 less equal z know string pivot string q 2 choices polynomial number choices thus procedure b input 0 n proceeds follows compute n possible choice pivot output procedure c evaluator h computes possible value jth bit n polynomial number possible choices n polynomial number pivots b verifies choice correct accepting computation 0 n outputs value finally note entire process carried 2 n e steps completes proof claim theorem well let hypothesis h following assertion npmachine accepts 0 0 e 1 timebounded turing machine correctly computes infinitelymany accepting computations theorem 2 hypothesis h true exists turing complete language np p complete np proof let npmachine satisfies conditions hypothesis h n lexicographically maximum accepting computation 0 n let define language accepting computation 0 let 1 2 3 define easy see previous argument l p complete np order prove l p complete define set prefix accepting computation 0 n belongs np assume p reduction f l consider procedure figure 1 first analyze running time treat two cases namely either 0 n successful infinitely many n unsuccessful finitely many n 3 procedure halts ol n 2 n e 2 2 steps proof consider iteration repeat loop expensive step test whether z sat test occurs hence decide whether z belongs sat 2 n e 2 2 steps steps take polynomial time hence time taken procedure ol running time procedure bounded 2 n e infinitely many n 2 n e timebounded turing machine correctly computes infinitely many accepting computations input repeat l n times begin x 0 x 1 queries l 2 x 0 x 1 y0 else y1 else least one x 0 x 1 query l 1 01 least index x b queries l 1 let x u accepting computation thus x b else u accepting computation 0 output unsuccessful print u terminate else n e yb else x b output successful print figure 1 procedure proof demonstrate successful input 0 n string printed accepting computation 0 n order accomplish prove induction prefix accepting computation 0 n every iteration repeat loop ie loop invariant initially l true assume prefix accepting computation beginning iteration least one f 0 n must belong l x 0 x 1 queries l 2 smaller x 0 x 1 belongs l 2 l 2 pselective thus case procedure extends correctly least one x 0 x 1 query l 1 procedure determines whether x b l 1 x b query l 1 least index x b belongs l 0 n yb hence yb prefix accepting computation l x b belongs l least one x b x b belongs l thus case b prefix accepting computation completes induction argument loop repeats l n times therefore final value string prints accepting computation finitely many n 2 n e time bounded turing machine correctly computes infinitely many accepting computations proof proof similar proof claim 1 following procedure computes infinitely many accepting computations input 0 j outputs u u accepting computation 0 n print u terminate running time algorithm bounded follows procedure 0 j runs time l steps total running time n 1e since cases treated claims 4 5 demonstrate turing machines correctly compute infinitely many accepting computations 2 n e time contradiction hypothesis h thus l p complete np following results give fine separations polynomial time reducibilities np significantly weaker hypotheses moreover follow readily results literature theorem 3 tally language upp exist two languages l 1 np l 1 p tt proof let l tally language upp let r polynomialtime computable relation associated language l define ith bit w one clear l 1 p tt reducible l 2 see l 2 p reducible l 1 implement binary search algorithm accesses l 1 determine unique witness w find ith bit observe l 2 sparse set ogihara watanabe ow91 call l 1 left set l homer longpr e hl94 proved every l np left set l btt reducible sparse set l p hence l 1 btt l 2 prove turing truthtable reducibilities also differ np hypothesis theorem 4 tally language upp exist two languages l 1 np l 1 p proof hemaspaandra et al hnos96 proved hypothesis implies existence tally language l upp l p tt reducible pselective set paper also showed given tally language l npp obtain p selective set l p reducible combing two results obtain theorem 4 analysis hypotheses section contains number results help us understand strength hypotheses h h 1 class languages p equivalent l 1 noncollapsing degree 41 comparisons complexitytheoretic assertions begin equivalent formulations hypotheses relate complexitytheoretic assertions question whether p contains pprintable immune set studied allender rubinstein ar88 equivalence items 1 3 following theorem similar results hemaspaandra rothe wechsung hrw97 fortnow pavan selman fps99 second item similar characterization grollmann selman gs88 oneone oneway functions addition attribute almostalways oneway fortnow pavan selman theorem 5 following statements equivalent 1 language l p contains exactly one string every length l pprintableimmune e 0 l 2 n e printable 2 exists polynomialbounded oneone function f almosteverywhere computable polynomial time e 0 f computable time 2 n e graph f belongs p 3 hypothesis h true e 0 proof let l satisfy item one define unique string length n belongs l clearly f us polynomialbounded oneone graph f belongs p l belongs p suppose turing machine computes f runs polynomial time infinitely many inputs inputs prints ls n similarly f computable time 2 n e let f satisfy item two define upmachine accept 0 follows input 0 n guesses string length within polynomialbound f accepts rest proof clear let upmachine satisfies item three ie satisfies conditions hypothesis h let n unique accepting computation 0 n let n r n rank n among strings length n l define l follows given string x belongs l x n n1 l x n l x belongs l rank x among string length x r n1 clear l p exactly one string per length claim l pprintable immune 2 n r printable machine prints infinitely many strings l polynomial time used print infinitely many accepting computations polynomial time thus l pprintableimmune machine prints strings l 2 n r time used print accepting computations 2 n e time thus l 2 n r printable prove following theorem similarly theorem 6 following statements equivalent 1 language l p contains least one string every length e 0 l 2 n e printableimmune 2 polynomialbounded multivalued function every refinement f almosteverywhere computable 2 n e time graph f belongs p 3 hypothesis h holds e 0 next compare hypotheses following complexitytheoretic assertions 1 e 0 pbiimmune language l upcoup l0 dtime2 n e 2 e 0 language l upcoup l dtime2 n e 3 e 0 2 n e biimmune language np conp theorem 7 assertion 1 implies hypothesis h hypothesis h implies assertion 2 proof let l language coup satisfies assertion 1 define upmachine accepts 0 follows input 0 n nondeterministically guess string w either witnesses 0 n l witnesses 0 n l accept 0 n immediate satisfies conditions hypothesis h prove second implication let upmachine satisfies conditions hypothesis h let n denote unique accepting computation 0 n define clear l upcoup l dtime2 n e binary search algorithm correctly compute n every n time 2 n e would contradict hypothesis h hence discrete logarithm problem interesting possible witness assertion 2 best known deterministic algorithm requires time greater 2 3 gor93 thus discrete logarithm problem candidate witness noninclusion coup 3 corollary 1 e 0 coup 2 n e biimmune language p completeness different p tt completeness np theorem 8 assertion 3 implies hypothesis h corollary 2 e 0 np conp 2 n e biimmune language p completeness different p completeness np 42 comparisons genericity genericity hypothesis ambosspies bentzien asb00 used successfully separate npcompleteness notions boundedtruthtable reducibilities states np contains n 2 generic language next result enables us compare hypotheses say deterministic oracle turing machine predictor language l every input word x decides whether x l oracle lx l predictable time tn tn timebounded predictor l define set l almosteverywhere unpredictable time tn every predictor l requires tn time finitely many x concept obviously implies dtimetncomplex almost everywhere converse hold theorem 9 exp contains languages dtime2 n complex almosteverywhere unpredictable time 2 n state characterization tngenericity theorem 10 let tn polynomial decidable language l tngeneric almosteverywhere unpredictable time t2 n 1 proof assume l almosteverywhere unpredictable time t2 n 1 let predictor l infinitely many strings x runs time t2 n 1 define condition c characteristic sequence lxx c oracle lx runs time t2 x 1 input x accepts x c dense along l correctly predicts whether x l infinitely many x easy see c dtimetn however l tngeneric defined c l meet c assume l tngeneric let c dtimetn condition dense along l l meet c let deterministic turing machine halts inputs accepts l define predictor l behave follows input x oracle ax ax1 c rejects x ax0 c accepts x neither holds determines membership l simulating x since l meet c predictor l since c dense along l l meet c infinitely many x either ax1 c ax0 c cases runs t2 2 x steps since tn polynomial function linear speedup theorem hs65 turing machine equivalent runs time t2 x 1 corollary 1 np contains n 2 generic language np contains set almosteverywhere unpredictable time 2 2n theorem 8 hypothesis h holds np conp contains set e 0 biimmune hypothesis h requires biimmunity weaker almosteverywhere unpredictability timebound reduced 2 2n 2 n e hand require language belong np conp instead np similarly consider hypothesis h require language pbiimmune dtime2 n e whereas require language coup moreover conclusion theorem 1 known follow genericity hypothesis time note genericity hypothesis separates several boundedtruthtable completeness notions np seem obtainable hypotheses 43 relativization theorem 11 exists oracle relative polynomial hierarchy infinite hypotheses h h hold proof define kolmogorov random strings r 0 r 1 follows r n first string length n define oracle define oracle turing machine accept 0 oracle follows input guess string length n accept machine accepts contains exactly one string every length show 2 n e oracle turing machine oracle 0 e 1 correctly computes infinitely many accepting computations observe relative implies hypotheses h h suppose otherwise let oracle turing machine gist remainder proof show simulate without using oracle contradict randomness r n suppose 0 n simulate computation without using oracle follows 1 compute iteratively compute r running every program input strings r 0 r 1 r i1 length i2 2 steps r first string length output programs note total time executing step 2 simulate input 0 n except replace oracle queries q following rules q l answer using previous computations otherwise answer simulation correct procedure outputs r n without using oracle running time procedure input 0 n 2 5n e 2 n e less 2 n describe r n string length ologn wit description 0 n contradicts definition r n need show simulation correct simulation incorrect q l first query yields short description r given r 0 r 1 r l1 namely description consists description constant description 0 n logn bits description number j jth query n e thus length description e since length description r less m2 running time given r 0 r 1 r l1 2 n e less 2 reason first step simulation needed therefore simulation correct finally sparse set using results balc azar et al bbs86 oracle relative hypotheses holds polynomial hierarchy infinite hypothesis h fails relative oracle rogers fr94 obtained oracle relative np conp hypothesis h fails know oracle relative p np every p complete set complete 44 extensions extensions section independently observed regan watanabe rw01 hypothesis h replace upmachine npmachine stronger intractability assumption consider following hypothesis npmachine accepts 0 1 probabilistic polynomial timebounded turing machine correctly outputs infinitely many accepting computations nontrivial inverse polynomial probability 2 e 0 2 n e timebounded turing machine correctly computes accepting computations nontrivial probability prove turing completeness different truthtable completeness np hypothesis proof uses randomized reduction valiant isolates accepting computations define l proof theorem 2 let iv v accepting computation ith bit vr denotes inner product gf2 valiant vazirani showed randomly pick r 1 r 2 r k nontrivial probability exists exactly one accepting computation v whose inner product r 0 thus random choice r 1 r k exactly one witness v rest proof similar theorem 1 also note replace upmachine hypothesis h fewp machine r separating npcompleteness strong hypotheses diagonalizations polynomial time computable sets genericity measure exponential time resource bounded randomness weakly complete problems relativizations p completeness notions nondeterministic complexity classes inverting onto functions distributionally hard languages discrete logarithms gfp using number field sieve complexity measures publickey cryptosys tems easy sets hard certificate schemes computational complexity algorithms computation times np sets different densities completeness approximation density comparison polynomial time ducibilities cook versus karplevin separating completeness notions np small polynomial time bounded truthtable reducibility np sets sparse sets personal communication reductions np pselective sets polynomialtime truthtable reducibilities intractable sets pselective sets np easy detecting unique solutions comparison polynomial time completeness notions tr ctr pavan alan l selman biimmunity separates strong npcompleteness notions information computation v188 n1 p116126 10 january 2004 john hitchcock pavan comparing reductions npcomplete sets information computation v205 n5 p694706 may 2007 christian glaer alan l selman samik sengupta reductions disjoint nppairs information computation v200 n2 p247267 1 august 2005 lane hemaspaandra sigact news complexity theory column 40 acm sigact news v34 n2 june christian glaer mitsunori ogihara pavan alan l selman liyu zhang autoreducibility mitoticity immunity journal computer system sciences v73 n5 p735754 august 2007
theory applications inverting functions folds paper devoted proof applications generalisation theorem due bird de moor gave conditions total function expressed relational fold theorem illustrated three problems dealing constructing trees various properties generalised give conditions inverse partial function expressed relational hylomorphism proof makes use doornbos backhouses theory wellfoundedness reductivity possible applications generalised theorem discussed b introduction purpose paper describe one technique inverting functions bother inverse functions reader might ask reason many problems computation specified terms computing inverse easily constructed function indeed compression best specified inverse decompression parsing inverse printing applications inverse sometimes arise unexpected situations illustrate discuss three problems solve instances sinlge technique first problem breadthfirst labelling breadthfirst label tree respect given list augment nodes tree values list breadthfirst order figure 1 shows result breadthfirst labelling tree 13 nodes infinite list 1 everybody knows breadthfirst traversal closely related problem ecient breadthfirst labelling widely understood would one specify problem inverse us call type binary trees tree assume preprint submitted elsevier science 16 may a1 f l fig 1 breadthfirst labelling tree left 1 hand function bft tree list breadthfirst traversal ziptree tree tree b tree zipping together two trees shape perform breadthfirst labelling given tree list x want zip another tree u tree u satisfy firstly must right shape condition enforced ziptree secondly breadthfirst traversal must prefix given list x thus come following specification bft look flow information specification functions bft appear lefthand side meaning wish data go backwards let us denote inverse function f f pronounced converse f briefly f wok formal definition f delayed section 21 let us say f nondeterministically yields x f rewrite specification pipeline right left resulting following equivalent pointfree specification fst cat nondeterministically splits input list two therefore fst cat takes arbitrary prefix input list inverse bft gives us tree whose breadthfirst traversal matches prefix tree zipped input example inverses arise unexpectedly specification concise one derive algorithm answer among two examples presented paper second problem given list trees task combine single tree retaining lefttoright order subtrees make height resulting tree small possible figure illustrates one tree height 11 given subtrees heights fig 2 tree height 11 built trees heights 2 9 8 3 6 9 2 9 8 3 6 9 actual content subtrees isnt important think simply numbers representing heights third problem classical one wellknown given preorder inorder traversals internally labelled binary tree tree reconstructed uniquely contains duplicated elements challenge derive linear time algorithm three problems involve building rebuilding tree kind specified terms converse operation flattening tree list values functional programmers aware flattening structure usually performed fold operation consequently building structure usually performed converse operation unfold however reason converse operation necessarily involve unfold converseofafunction theorem paper devoted gives us conditions inverse function written fold following sections show theorem applied derive solutions problems functional programmers make use handful laws theorems transform specifications optimising code converseofafunction theorem another useful tool worth adding functional programmers arsenal joint use fold fusion theorem turns recurring pattern program derivation finally present prove generalised theorem allowing one write inverse partial function hylomorphism theory converse function relation framework necessity calculus relational programs 46 section present enough notation describe main ideas concepts introduced section 7 21 relations settheoretically speaking relation r b set pairs b type b type b converse relation defined flipping pairs b r b r composition r c defined c r converse contravariant respect composition r type relation id defined id omit subscript clear context relation r b called simple r r id every value mapped one value b words r partial function relation r called entire id r r every value mapped least one value b relation total function simple entire paper write type function b partial function b relation b relation called coreflexive subset id use coreflexives model predicates operator converts booleanvalued function coreflexive p p convenience let p p yields false domain p perform two consecutive tests one stronger stronger one absorb weaker one p q p given relation r b coreflexive dom r determines domain r defined dom r b alternatively dom set intersection follows dom r r r 2 coreflexive ran r determines range relation defined ran writing pointwise style relations introduced choice operator expression x nondeterministically yields either x example following relation prefix maps list one prefixes prefix list list step list list step step fold choose either cons current item prefix sublist return empty sequence prefix every list rigorous semantics reader referred 29 22 folds datatypes come fold functions lists haskell prelude function list b well known slight variation nonempty lists defined tipvalued binary tree following datatype data tree fold function defined folds instances general definition regular datatype defined fixedpoint base functor f say isomorphism datatypes often parameterised case f type fa ta ta example conslists arbitrary fixedpoint fa denoting types write fa x instead fa x thinking f bifunctor example base functor nonempty lists tree fa x given base functor f datatype function f type fa b catamorphism f f unique function satisfying f dierent folds special cases f f instantiated dierent base func tors except haskell usually divide f several functions constants corresponds operation particular operand coproduct base functor functor relations takes functions functions monotonic relational inclusion called relator switching functors relators theory extends relations well catamorphism r f r relation type fa b b type fuller account relator theory relational catamorphisms reader referred 34 3 converseofafunction theorem converseofafunction theorem introduced 629 tells us write inverse function fold reads theorem 1 converse function f base functor r fa b b surjective f r f ff specialisation theorem functions lists reads follows jointly surjective meaning base base aa ran step satisfy f step x similarly invert total function f nonempty lists theorem 1 states base b step b b jointly surjective ran base aa ran step f base postpone proof theorem 1 section 7 fact general result proved let us see applications 4 rebuilding tree traversals well known given inorder preorder traversal binary tree whose labels distinct one reconstruct tree uniquely problem recorded 27 section 231 exercise 7 exercise knuth briefly described done commented would interesting exercise write program task indeed become classical problem tackle study program inversion derive linear time algorithm 836 van de snepscheut noted 36 one class solution attempts invert iterative algorithm class delivers recursive algorithm section see theorem helps derive functional program solve problem inter estingly although start recursive specification theorem 1 delivers algorithm falling first category define following datatype internally labelled binary trees fold function foldtree data tree inorder preorder traversal trees defined terms foldtree inf x pre pre x assume predicate distinct yields true tree whose values nodes distinct aim construct distinctfork preorder inorder fork f g fig 3 adding new node tree try apply theorem 1 construct converse function relational fold however due type fork preorder inorder apparently cannot fold recursive datatype instead define rebuild rebuild relation inorder constructs trees whose inorder traversals meet given list coreflexive x preorder picks one whose preorder traversal list x apparently fork preorder rebuild furthermore predicate distinct enforced constrain x must contain duplicated elements aim thus derive rebuild x derivation proceeds two parts invert inorder fold lists fuse x preorder resulting fold 41 building tree fold according theorem 1 order invert inorder need tree zero relation add tree tree jointly surjective satisfy inorder inorder add x look second equation says tree x whose inorder traversal relation add must able create new tree x order traversal one way illustrated figure 3 divide left spine x two parts move lower part one level attach end facilitate operation introduce alternative spine representation tree represented list values subtrees along left spine type spine list example tree left figure 3 represented list b function roll converts spine back single tree fact isomorphism spine tree roll spine tree join u advantage representation trace spine upward leftmost leaf rather downwards root see end next section necessary ecient algorithm function inorder roll flattens spine tree task invert fold need spine tree zero spine relation add spine spine satisfying inorder roll inorder roll add easy choice zero would add claim following definition satisfies 3 add spine spine add us roll vs ws vs ws us nondeterministic pattern definition add dividing list us two parts indicates add relation example tree right figure 3 results cutting spine middle yielding roll b show add satisfies 3 need following fact whose proof left diligent reader inorder proof 3 goes since concat map distributes concat map cons id inorder ws definition concat map concat map cons id inorder roll vs ws inorder roll roll vs ws also dicult see add jointly surjective nonnull tree result add therefore conclude inorder roll 42 enforcing preorder inverted inorder roll start derivation rebuild x roll isomorphism converse contravariant inverting inorder roll last section let haspreorder except introduction roll derivation far mostly mechanical roll haspreorder x partial function easily implemented haskell however add still relation fuse haspreorder x fold thereby refine add partial function whole expression implementable unfortunately haspreorder x rather strong condition enforce possible maintain invariant within fold application add obviously adding new element tree new tree certainly dierent preorder traversal invent something weaker fused fold define preorderf preorder traversal forests preorder look figure 3 preorder traversal tree lefthand side e c b preorderf u v w go along left spine traverse subtrees upwards general given spine tree us preorder traversal reverse map fst uspreorderf map snd us call part prefix sux traversal look tree righthand side preorder traversal e c b preorderf u v w dicult see add node spine tree us sux preorder traversal change new node always inserted prefix insight split haspreorder two parts haspreorder list spine bool haspreorder x us prefixok x us suxok x us suxok x us preorderf map snd us issuxof x prefixok x us reverse map fst us removes tail x defined expression x issuxof yields true x sux use boldface font indicates infix operator binds looser function application plan fuse suxok x fold leaving prefixok x outside slight problem however invariant suxok x prevent fold generating say leftist tree null along spine since empty list indeed sux list tree may bound rejected later look righthand side figure 3 assume know preorder traversal tree want preorderf u v w tree figure 3 although satisfying suxok x bound wrong next immediate symbol stands way c way change order afterwards thus find proper location insert new node shall aggressive consume much sux x possible following predicate lookahead x ensures constructed tree next immediate symbol x consumed lookahead list spine bool lookahead x us length us 1 map fst us 1 last x apparently lookahead x compatible haspreorder x use suxok x lookahead x invariant define ok x us suxok x us lookhead x us derivation continues rebuild x beginning section since haspreorder x us prefixok x us ok x us fold fusion assume nodup x roll prefixok x foldr add x fold fusion theorem used last step wellknown see example 6 chapter 6 justify fusion step shown x contains duplicated elements following fusion condition holds ok x add add defined tree spine list v v b us words function traces left spine upwards consumes values spine match tail x tries roll much possible adding end spine ready final optimisation avoid computing x preorderf map snd us scratch time apply tupling transformation see example 22 6 chapter 3 fold returning pair haskell implementation shown figure 4 fold rebuild returns pair first component tree second component list representing x preorderf map snd us since list consumed end represent reverse function rollpf implements roll prefixok x data tree null node tree tree deriving showeq rebuild eq tree rebuild add v v buus bx b rollpf eq atree aa tree b fig 4 rebuilding tree traversals via fold b c e f b c e f b e f b e f b e f b c e f fig 5 building tree preorder preorder traversals trees spine printed boldface font figure 5 shows example algorithm action part boldface font indicates preorderf map snd us notice preorder traversals trees spine always form sux given list b c e f actually reinvented algorithm proposed 8 functional style first step 8 transform recursive definition fork preorder inorder iteration introducing stack eect achieved introducing spine representation 43 building trees given preorder hold reader might complain derivation works luck choose correct order started preorder would invert preorder enforce resulting fold constraint tree built must given inorder traversal still work fact result new complicated algorithm therefore going sketch outline development first seek invert preorder problem turns makes sense work forests rather trees abbreviate list tree forest recall preorderf forest list defined preorderf concat map preorder reader easily verify preorderf inverted preorderf step us us us node helper functions tip lbr rbr respectively creates tip tree tree left branch tree right branch defined lbr rbr words step extends forest one four possible ways applica ble adding new tip tree extending leftmost tree forest making leftsubtree rightsubtree combining two leftmost trees next step find rule deciding four operations perform adding new value forest need invent invariant enforce body fold begin reason preorder trivial manipulation b c e f b c e f b c e f b c e f b c e f b c e f fig 6 building tree preorder inorder traversals constructed subtrees printed boldface font skipped subsequences subtrees underlined optimised code figure 7 paired subtrees thus type aforest condition inorder strong maintain luckily turns weaker constraint issubseqof x subsequence x require construction forest inorder traversal tree shall always form segments x correct order figure 6 demonstrates process constructing tree figure 5 time notice inorder traversal constructed forest always forms subsequence given list b c e f pencilandpaper work dicult work rules extend forest maintaining invariant however rules consists totally eight cases relatively complicated comparing simpler algorithms section 42 owing fact four possible operations choose section 42 two either go upwards one node along spine stop attach new node reason present result program implementing algorithm presented figure 7 tree forest annotated extra information avoid recomputing represented type aforest optimisation program runs linear time bigger constant overhead section 42 rbr lbr type aforest tree rebuild eq tree rebuild fst unwrap snd foldr add reverse x add eq aaforest aaforest add xux newtree xu add xux tus isnext x tail x rbr us newtree xu add xuxtbbsus isnext x tail x rbr bbsus newtree xu join join us join tbs us lbr bsus newtree isnext false isnext bbs b locate x locate locate bx locate x fig 7 another way rebuild tree traversals via fold building trees minimum height next consider second problem building tree minimum height lineartime algorithm problem proposed 5 demonstrate similar algorithm derived start giving formal specification problem define tipvalued binary tree following datatype data tree function flatten takes tree returns tips lefttoright order written fold flatten tree list wraps item singleton list foldtree fold function tree defined section 22 given tipvalued binary tree whose tip values represent heights trees function computing height combined tree also defined fold obvious way height tree int int ht returns larger two arguments problem thus find among trees flatten given list one height yields minimal value specification needs consider possible results need power transpose operator also called breadth function power transpose operator converts relation r b function set ra contains values b mapped extract value set need relation min set defined definition use connected preorder meaning ordering reflexive transitive compares everything correct type relation min general function preorder necessarily antisymmetric problem define comparison heights two trees problem specified fig 8 adding new node tipvalued binary tree similar last problem derivation also proceeds two steps invert flatten relational fold fusing something fold eliminate nondeterminism function flatten inverted way similar section 41 also helpful switch spine representation define following type spine tree represented list subtrees along spine together leftmost leaf conversion spine tree ordinary representation performed roll spine tree since range flatten set nonempty lists seek invert foldrn fold nonempty lists theorem 1 says flatten roll foldrn add one relations add one satisfy flatten roll one flatten roll add b figure 8 illustrates idea claim following definition satisfies requirement one add b ys proof similar section 41 left reader exercise inverted flatten get furthermore roll factored xs ys roll xs roll ys ie counterpart defined spine trees since relation add choices given spine tree length n specification generates exponential number trees eliminate nondeterminism add thereby improve eciency make use following greedy theorem presented special case general version proved 6 theorem 2 greedy theorem nonempty lists let base two relations step monotonic connected preorder informally monotonicity condition means worse partial solution stage fold always gives worse result condition holds stage fold need retain one best results computed far thus min gets promoted foldrn add satisfied monotonicity condition 5 respect could apply greedy theorem however true tree smallest height always remain smallest extended add fortunately add monotonic stronger ordering define heights words heights returns list heights along left spine starting root relation add monotonic defined lexicographic ordering sequences choice make sense ensure monotonicity need optimise whole tree also subtrees left spine proof add monotonic however quite involved presented reader referred 7 detailed discussion type bmh int tree int int one minadd int spinei spinei minadd minsplit x minsplit x yxs height height x height bin xa ht b ht roll spinei tree int int roll fig 9 code building trees minimum height applying greedy theorem get since one function min one one analysis optimise min add let b x 1 x 2 x n spine tree insert value shown order construct best tree ordering need actually check n 1 possibilities always break list x x i1 smallest index height x i1 height roll b x 1 x 2 x height x i1 also omit details refer interested readers 7 code shown figure 9 first problem annotate tree height avoid recomputation algorithm also linear number nodes tree 6 breadthfirst labelling breadthfirst label tree respect given list label nodes tree breadthfirst order using values list jones gibbons 17 proposed neat solution problem based clever use cyclic data structures problem recently revisited okasaki 31 going show okasakis algorithm derived using converse ofafunction theorem let us go specification finer detail recall data structure internally externally labelled binary trees data tree queuebased algorithm breadthfirst traversal wellknown list typeforest list tree bftf forest list bftf bin x perform labelling use following partial function ziptree ziptree tree tree b tree ziptree tip tip ziptree bin x bin b u breadthfirst labelling tree x seen zipping x another tree breadthfirst traversal prefix given list bfl equivalently bfl prefix x completes specification relation prefix nondeterministically maps list one finite prefixes prefix passed bft yet nondeterministically mapped tree whose breadthfirst traversal equals chosen prefix important ziptree partial function yields value given two trees exactly shape therefore tree composed bft prefix zipped input tree correct size shape partial function ziptree plays role filter since breadthfirst traversal algorithm naturally defined terms queues trees forests rather single tree reasonable try invert bftf rather bft problem rephrased terms bfl zipforest bftf prefix x zipforest forest forest b forest ab simple extension ziptree forests like ziptree partial function zipforest zipforest zipforest xs ys decision focus bftf made rest mechanical invert bftf find base step bftf step value base derivation step dicult either start general case assume structure xs definition bftf bftf tip xs therefore step xs might contain tip xs one possible values choice alone make step jointly surjective since cannot generate forest nontip tree head therefore consider case xs contains two trees definition bftf bftf bin x xs therefore define step step forest forest step since forest either begins tip tree begins nontip tree empty step jointly surjective converse bftf thus constructed knowing bftf list forest fold fuse zipforest bftf fold zipforest bftf revzip f tip b ts revzip f bin b ys x expression zipforest bftf type list forest b forest ab consider zipforest bftf x x list labels constructors building x replaced revzip stop yielding relation mapping unlabelled forest labelled forest pattern matching error invoked stop x short revzip x long applying fold fusion fuse zipforest bftf prefix eect adds another case revzip revzip f cuts list labels forest consumed earlier list still list labels cannot short resulting code shown figure 10 made linear use implementation deques supporting constanttime addition deletion 930 input output revzip clarity leave nothing adaption okasakis algorithm 31 lists paper okasaki raised question people come algorithm instead appealed complicated approaches answer know converseofafunction theorem 7 generalised converseofafunction theorem aim section prove following generalisation theorem 1 hylomorphisms theorem 3 generalised converseofafunction theorem let b simple relation exists relation r fc b b simple relation fc dom data tree tip bin tree tree deriving show stop revzip f revzip f tip ts revzip f bin b u v last init ys last ys fig 10 code breadthfirst labelling words theorem 3 gives conditions converse simple relation expressed hylomorphism relationship theorem 1 well notions need establish connection given section 71 new ingredient theorem 3 fwellfoundedness notions wellfoundedness admitting induction great importance computing science 13 doornbos gave careful analysis relationship two notions proposed several dierent generalisations notion fwellfoundedness defined 13 page 102 relation r fwellfounded relations equation unique solution x give proof theorem 3 taking converses sides aim prove given conditions know hylomorphism f r f characterised least solution x equation assumption iii r fwellfounded know f r f fact unique solution show also solution proof goes assumption since ran r r r assumption assumption since dom assumption since fs simple theorem 3 thus proved 71 wellfoundedness reductivity proof theorem 3 makes use fwellfoundedness guarantee uniqueness solution practical proposes however stronger property needed reason fwellfoundedness alone guarantee termination view hyloequation lefttoright rewrite rule evaluation nondeterminism demonic counterexample 1 take consider relation f id f recursive program terminate strict second component input pair yet f id fwellfounded shown 13 section 75 however termination guaranteed freductive relations notion freductivity introduced 1415 13 section 63 one ways generalise notion admitting induction arbitrary datatypes said f reductive coreflexives c id monotype factor operator defined galois connection r c 1 due 13 page 104 2 intuition behind monotype factor reader referred 14 relations r coreflexives c property 6 translated pointlevel aid understanding 3 words r freductive used inductive proofs following way may conclude property c universally true show satisfies c given rpredecessor fstructure containing elements satisfying c several properties concerning freductivity handy purpose following facts respectively theorem 625 theorem 619 theorem 622 13 fact 6 freductivity implies fwellfoundedness fact 7 freductive fs simple fact 8 f freductive since freductivity guarantees termination according fact 6 stronger fwellfoundedness fwellfoundedness requirement theorem 3 always strengthened freductivity practice question construct freductive relations discussed depth 1413 yet talked relationship theorem 1 theorem 3 begin note following lemma lemma theorem 1 follows special instance theorem 3 taking entire relation well simple one function entire relation one dom translates requirement r surjective relation condition iii r freductive according lemma 9 fact 7 however fact 8 says f indeed freductive since f obtain conclusion theorem 1 proof lemma 9 simply extracted proof theorem 3 completeness given r since dom r 3 hand 6 written concisely r stands least fixedpoint operator since dom since r fs 8 applications generalised theorem theorem 3 potentially powerful since allows functor f determines pattern recursion independent input output types much wider class algorithms thus covered one application found theorem 3 prove loop implements inverse function loop specified relationally relation initialises loop r serves loop body domain represents terminating condition therefore ought disjoint domain r given relation r reflexive transitive closure r smallest reflexive transitive relation containing r generally defined least fixedpoint key observation closure also written hylomorphism base functor definition closure unfolding phase wraps input value inl wrapping indefinite number inr folding phase replaces inl inr r exact number iterations performed determined termination test given function f let us instantiate theorem 3 discover conditions f since dom instantiates ran r shall jointly surjective condition ii divided two parts shunting functions side get looks familiar enough think f invariant first half says initial values satisfies invariant second half says given inputs satisfying invariant loop body r maintains invariant condition iii requires r fwellfounded intuitively speaking want r decrease loop variables sense assume wish prove r correctly implements specification x shown next two sections occasions x quite naturally factored f f need check three conditions 81 string edit problem string edit problem 10 chapter 15 typical example dynamic programming recently drawn much attention due application dna sequence matching simplest form given two strings one source one target available commands imagine cursor positioned left source string assume following commands ins c insert character c current position del c delete character c current position cpy c skip current character c move cursor one position right task find shortest sequence commands transform source string target string complicated variations might given commands weights may vary represent three commands datatype op data ins char del char cpy char specify problem one might attempt construct relation taking pair strings return arbitrary sequence commands relating strings fact easier construct inverse function exec executes sequence commands starting pair empty strings yields two strings step exec function starts two empty strings tries reconstruct original source target strings ins operation extra character added target string del operation treated statement source string extra character cpy command viewed saying two strings common character current position converse exec hand takes two strings yields sequence commands reducing pair empty strings thus showing commands transform one string another string edit problem thus defined 6 section 92 bird de moor derived specification dynamic programming algorithm using dynamic programming theorem converse folds yet others prefer describe exec iterative process claim exec start move ins last init x del last x init x init cpy last x last x last loop starts two strings empty list commands nondeterministic loop body move try recover last command might trying possible commands iteration repeats strings become empty notice move defined partial relation yields value x empty view taken curtis 11 specification written terms min r loop theories 11 ready transform dynamic programming algorithm certain conditions satisfied go problem solved using developed ories instead bridge gap two views exec words know claim exec discussions opening section 8 mind generalise exec execwith function execwith type stringstringlist op stringstring defined execwith replacing constant definition exec given argument task show execwith one may also think invented proposed execwith loop invariant check whether invariant works invariant says denoting input pair strings x intermediate values point computing move start executing commands ops check conditions one one condition holds start move jointly surjective condition ii requires execwith start id execwith move execwith first one trivially holds second inclusion holds move undoes last step execution thus domain lefthand side restricted triples one two strings empty execution still yields result condition iii move wellfounded always reduces length first two components triple therefore conclude execwith start 82 building trees combining pairs recall following datatype leafvalued binary trees data tree yes introduce yet another approach building trees list majority paper focusing inverting flatten fold yet another alternative way build tree list starting list tips keep combining adjacent trees one left process characterised join aim course show flatten proposed invariant loop iterations forest always flattens given list check flattenf indeed map tip join jointly surjective former covers lists tip trees latter covers rest need verify concat map flatten map tip id concat map flatten join concat map flatten first inclusion obviously holds second holds join restricts domain lefthand side lists least two trees aecting result returned finally join wellfounded reduces length forest follows flattenf consequently flatten one might relate small exercise merge sort two ways implement merge sort one implement hylomorphism unfolding phase expands tree folding phase performs merging node implement loop start map wrap converting input list singleton lists iteratively merge adjacent lists one list left first said topdown second bottomup similar reasoning converts former latter however additional distributivity property list merging needed proof similar problem treated 21 topdown algorithm also transformed bottomup one 9 conclusions related work idea program inversion traced back dijkstra 12 however given importance inversion specification technique relatively papers devoted topic deal program inversion context imperative programs refinement calculus program inverted running backwards challenging part encounter branch loop 37234 classic example construct binary tree given inorder preorder traversal 181983635 inversion functional programs received even less attention published results eg 2820 based compositional approach essentially imperative counterpart h defined f g inverse f g recursively constructed reach primitives whose inverses predefined rather controloriented view complemented dataoriented view 2324 paper generalised functions arrows considered polytypic operations datatypes ensured operation inverse carrying things reverse order map left map right always constructed pairs eorts also made automate process 1 paper also contains detailed bibliography converseofafunction theorem however takes noncompositional approach invert function invert function matters defined properties satisfies applied converse ofafunction theorem three examples inverted function usually nondeterministic fold make useful often composed function acts filter fold fusion theorem applied fuse filter fold remove nondeterminism refining specification implementable function pattern derivation turned useful solving many problems technique new similar techniques adopted exam ple 25 32 however best knowledge de moor 629 first presented technique theorem suggesting wider range application problem dealt 29 precedence parsing leading derivation floyds algorithm therefore coincidence algorithms developed section 4 resemble parsing authors believe possible although tiresome task derive shiftreduce parsing algorithm generalising reasoning section 4 also pointed problem building trees minimum height seen special case knuths generalised shortest path problem 26 problem addressed given contextfree grammar cost function parse trees construct word parse tree whose cost minimum given list numbers construct ambiguous grammar whose word list possible parse trees include binary trees cost parse tree would simply height knuths algorithm thus applied find best parse yielding minimum height would interesting investigate whether linear time algorithm section 5 optimised special case relate one natural question widely theorem applied words determine whether converseofafunction theorem applied particular function part answer given 16 converse function written fold function must unfold necessary sucient conditions function unfold given 16 thus used test applying converseofa function theorem one possible reason inverting imperative programs often talked could theories nondeterminism context refinement calculus established 372 instance dijkstras guarded command language extended include angelic choices well demonic choice shown inverse demonic program angelic corresponding theories relations still developed 33 interesting see would benefit research inverses relations fully exploited generality theorem 3 potentially useful since allows functor f determines pattern recursion independent input output types much wider class algorithms thus covered applied theorem simple cases fa x verify loopbased algorithms authors enthusiastic see examples general theorem necessary acknowledgements thanks due members algebra programming group oxford university computing laboratory oege de moor interest encouragement comments throughout development paper roland backhouse kindly pointed relation henk doorn boss work advantage basing theorem freductivity authors would also like thank anonymous referees detailed useful advices r universal resolving algorithm inverse computation functional language statement inversion strongest postcondition relational catamorphisms elements relational theory datatypes building trees minimum height algebra programming algebraic methods optimization problems program inversion fun introduction algorithms relational approach optimization problems program inversion reductivity arguments program construction reductivity science computer programming function fold unfold science programming inorder traversal binary tree inversion synthesis function inverses constructing tournament representations exercise pointwise relational programming construction list homomorphisms via tupling fusion compact printing parsing data conversion programs relational programming generalization dijkstras algorithm art computer programming volume inversion applicative programs relational programming simple e binary multirelations running programs backwards logical inversion imperative computation inorder traversal binary heap inversion optimal time space inversion recursive tree traversal program inversion refinement calculus tr inorder traversal binary tree inversion program inversion refinement calculus program inversion synthesis function inverses statement inversion strongest postcondition realtime deques multihead turing machines purely functional programming reductivity algebra programming synthesis functions transformations constraints poster art computer programming volume 1 3rd ed breadthfirst numbering science programming introduction algorithms data conversion programs compact printing parsing construction list homomorphisms tupling fusion invited talk elements relational theory datatypes inorder traversal binary heap inversion optimal time space induction recursion datatypes universal resolving algorithm constructing tournament representations algebraic methods optimization problems inversion recursive tree traversal functional pearl ctr kiminori matsuzaki hideya iwasaki kento emoto zhenjiang hu library constructive skeletons sequential style parallel programming proceedings 1st international conference scalable information systems p13es may 30june 01 2006 hong kong
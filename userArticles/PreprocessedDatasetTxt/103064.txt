models software development environments general model software development environments consists structures mechanisms policies presented advantage model distinguishes intuitively aspects environment useful comparing contrasting software development environments four classes environmentsthe individual family city stateare characterized means sociological metaphor based scale utility taxonomy delineates important classes interactions among software developers exposes ways current software development environments inadequately support development large systems generality model demonstrated application previously published taxonomy categorizes environments according relate languagecentered structureoriented toolkit methodbased environments b introduction model useful primarily insight provides particular instances collections instances abstracting away nonessential details often differ trivial ways instance instance generalizing essential details components model derive tool evaluating classifying instances ways thought constructed model purpose mind classification evaluation introduce general model software development environments sdes model consists three components policies mechanisms structures defined general model software development environments various points view might classify environments might example classify sdes according coverage software life cycle classify according kinds tools provide contrasting provide kernel set provide extended set etc classifications yields useful comparisons insights another important point view seen literature classification sdes relative problems scale required software development environments projects different sizes taking account numbers people length project well size complexity system note distinction programminginthesmall programminginthelarge 7 intimations problems scale however distinction basically one singleunit versus multipleunit systems captures small part problem build software systems range small large able build even larger systems hardware gets cheaper powerful sufficiently considered effect scale systems tools needed build thus main focus paper indeed research problem scale introduce classification sdes terms sociological metaphor emphasizes problem scale provides insight environmental requirements projects different sizes metaphor suggests four classes models individual family city state individual family classes current state art inadequate building large systems argue city model adequate little attention given class argue future research development address city model proposed state model section 2 present model software development environments discuss individual components interrelationships illustrate various distinctions make environments literature section 3 classify sdes four classes suggested metaphor characterize classes present basic model class categorize wide variety existing environments individual family city classes know examples state class finally section 4 summarize contributions model classification scheme confine discussion sections primarily environments concerned problems implementing testing maintaining software systems environments concerned technical phases software development process believe environments concentrate full lifecycle project management issues also could described model categorized according classification scheme presented section 3 2 general model software development environments sdes general model software development environments consists three interrelated components policies mechanisms structures example howden 18 considers sdes medium large systems standpoint capitalization richness toolset general policies mechanisms structures policies rules guidelines strategies imposed programmer environment mechanisms visible underlying tools tool fragments structures underlying objects object aggregates mechanisms operate general three components strongly interrelated choosing one component may serious implications two components place severe limitations discuss components model illustrate examples sde literature discuss interdependencies 21 policies policies requirements imposed user environment software development process rules strategies often hardcoded environment mechanisms structures example static linkerloaders generally require externally referenced names defined set object modules linked together requirement together requirement linkedloaded objects may executed induces policy always compiling modules linking different strategy possible execution preparation tools provide dynamic linking hence different policy example multics segmentation scheme 33 allows externally referenced names resolved runtime cases design tools supporting structures define impose policies policies need hardwired architectures allow explicit specification policies example osterweils process programming 3449 provides ability program desired policies respect various mechanisms structures available darwins lawgoverned systems 30 consist declaratively defined rules restricting interactions programmers tools important distinction hardwired policies process programs rule systems latter architectures building environments provide way explicitly imposing policies developers independently mechanisms structures another distinction supporting enforcing policies policy supported mechanisms structures provide means satisfying policy example suppose topdown development supported policy would expect find tools structures enable developer build system topdown fashion implication would also expect find tools structures build systems ways well policy enforced supported possible way within environment call direct enforcement environment explicitly forces developer follow policy slightly different kind enforcement indirect enforcement policy decisions made outside environment either management convention made supported enforced environment example management decides systems generated modules resident within source code control system sccs 42 environment supports configuration management sccs however management decision forces developers control modules within sccs distinction made policies apply mechanisms structures apply policies refer second higherorder policies example projects done ada higherorder policy 22 mechanisms mechanisms languages tools tool fragments operate structures provided environment implement together structures policies supported enforced environment mechanisms visible developers others may hidden user use term programmer generic sense include user environment function lowerlevel support mechanisms example unix tm system 25 tools building systems available user however smile 21 tools hidden beneath facade provides developer higherlevel mechanisms turn invoke individual unix tools policies encoded mechanisms one two ways either explicitly policy makers particular project implicitly toolsmiths tools comprise environment first case mechanisms shell scripts 19 darwins clfs 5 marvels rules 20 process programs enable policy maker define explicitly policies supported system whether also enforced depends well mechanisms restrict developer uses environment second case examples preceding section illustrating hardwired policies exemplify implicit encoding sdes policies implicitly encoded mechanisms good historical reasons situation must work particular instances generalize particular mechanisms structures must first built implicitly encode policies order reach sufficient understanding important issues reached level maturity separate specification policies mechanisms structures 23 structures structures objects object aggregates mechanisms operate simplest chronologically earliest incarnation basic structures objects build systems files unix example trend however towards complex comprehensive objects basic structures one reason complex basic structures found integrated environments particularly centered around syntaxdirected editor 12 50 sdes share complex internal representation abstract syntax tree 9 idl graph 26 gain efficiency tool example tool need reparse textual form uses intermediate shared representation disadvantage approach difficult integrate additional tools environment particularly structure provided support well mechanisms intended policies garlans tool views 14 provide partial solution structure mechanism generating underlying common structure consistent requirements different tools sde another reason trend maintain information software objects support comprehensive mechanisms policies example use project databases topic considerable interest recent past 1 31 basic structure currently generating large amount interest objectbase 20 49 45 hoped approach solve deficiencies files databases basic structures foundation building complex comprehensive higherorder structures example inscape 37 38 maintains complex semantic interconnection structure among system objects provide comprehensive semantic analysis version control mechanisms policies semantic consistency completeness compatibility among system objects smiles experimental database higherorder organization basic structures supports mechanisms policies managing changes existing systems project master data base pmdb 36 provides entityrelationshipattribute model 4 represent example problem reporting evaluation tracking processes cmss modification request tracking system 43 builds structure intertwined sccss configuration management database turn built top unix file system coordinates change requests actual changes system finally apollos domain software engineering environment dsee provides comprehensive set structures coordinating building evolving software systems structures support example configuration control planning developer interactions say partial sense garlans views help environment tools already exist independently garlans mechanisms new tools need added full solution sense one develops entire environment garlans views adding new tool requires one adds view needed tool original set generates newly integrated structure general structures tend impose limitations kinds policies supported enforced sdes simple structures files provide useful communication medium tools limit kinds policies supported complex structures required integrated environments gandalf 32 enable sophisticated policies make harder integrate new mechanisms policies environment higherorder structures infuses hierarchy experimental databases 39 make possible enforce policies govern interactions large groups developers allow policy maker ability define policies one fact clear yet reached level maturity sdes respect structures still feeling exploration kinds structures needed indeed feeling exploration policies supported sde particularly sdes concerned largescale projects 3 four classes models present classification sdes viewpoint scale problems size primarily numbers developers implication size system well affect requirements sde supports development systems classification terms sociological metaphor suggestive distinctions respect problems scale along continuum possible models distinguish following four classes sde models individual family city state four classes follow metaphor family collection individuals city collection families state collection cities basically class incorporates classes left metaphor also suggests may distinctions made right family model example neighborhoods villages etc however relatively little known sdes support city models nothing known sdes support state model make distinctions possible purpose paper draw attention two representative classes city state present two orthogonal characterizations class first emphasizes consider key aspect distinguishes terms scale others aspects construction individual class models coordination family class cooperation city class commonality state class second characterization emphasizes relationships among components historically mechanisms dominate individual class structures dominate family class policies dominate city class higherorder policies dominate state class class models present description class support characterizations example sdes convenience discussion use term model instead class models 31 individual model individual model software development environments represents environments supply minimum set implementation tools needed build software environments often referred programming environments mechanisms provided tools program construction editors compilers linkerloaders debuggers environments typically provide single structure shared among mechanisms example structure may simple file complex decorated tree policies typically laissez faire methodological issues hardwired nanomanagement issues individual toolinduced policies implementation tools single structure environments dominated issues software construction orientation led emphasis tools construction mechanisms policies structures assuming secondary importance policies induced mechanisms hardwired structures dictated requirement making tools work together discuss four groups environments instantiations individual model toolkit environments interpretive environments languageoriented environments transformational environments toolkit environments exemplified unix interpretive environments languageoriented environments cornell program synthesizer 50 transformational environments refine 46 toolkit environments historically archetype individual model mechanisms communicate simple structure file system policies take form conventions organizing structures example unix bin include lib src directories ordering sequence development construction exemplified make 13 policies weak concerned minutiae program construction however shell scripts provide administrator convenient extensive mechanism integrating tools providing support policies beyond encoded tools toolsinduced policies scriptencoded policies editors compilers linkerloaders debuggers file system interpretive environments also early incarnation individual model consist integrated set tools center around interpreter single language lisp smalltalk 15 language environment really separable language interface user interpreter tool user interacts structure shared various tools internal representation program possibly accompanying information exemplified property lists environments noted extreme flexibility virtually policies enforced matter supported thus contrast toolkit approach tools induce certain policies force programmer certain modes operation programmers essentially please construction software use italics general descriptions components normal typeface specific components notation end list indicates additional facilities may available interpretive virtually restrictive policies interpreter underlying support tools intermediate representation languageoriented environments blend toolkit interpretive models provide program construction tools integrated complex structure decorated syntax tree whereas tools toolkit environments batch nature tools interpretive interactive tools languageoriented environments incremental nature languageoriented tools try maintain consistency input output grain editing commands single policy permeates tools model early error detection notification environments might primarily handcoded garden 40 generated formal specification synthesizer generator 41 languageoriented error prevention early error detection notification editor compiler debugger decorated syntax tree transformational environments typically support widespectrum language v 46 denotes range object control structures abstract concrete programs initially written abstract form modified sequence transformations efficient concrete form mechanisms transformations machinery applying structure typically cross intermediate representation interpretive model decorated syntax tree languageoriented model languageoriented environments single policy defines style environment transformational approach constructing programs example ergo 44 pds 3 programmer apprentices kbemacs 53 variation policy programmer switch transformational approach interpretive approach time transformational transformational construction interpreter transformational engine intermediate representationdecorated syntax tree discussed four different groups individual models cited many environments examples different models research environments many commercial environments instances individual models 32 family model family model software development environments represents environments supply addition set program construction tools found individual model facilities support interactions small group programmers say 10 analogy family model members family work autonomously part trust others act reasonable way rules need enforced maintain smooth interactions among members family rules policies distinguish individual family model environments individual model rules needed interaction family model rules needed regulate certain critical interactions among programmers family coordination policies coordination mechanisms specialpurpose databases characteristic distinguishes family model individual model enforced coordination environment provides means orchestrating interactions developers goal information effort neither lost duplicated result simultaneous activities programmers structures individual model provide necessary weak form concurrency control individual models structures rich enough coordinate simultaneous activities complex structures required structures dominate design environment wherein individual model mechanisms dominated mechanisms policies family model adapted structures discuss four groups environments instantiations family model extended toolkit environments integrated environments distributed environments project management environments extended toolkit environments exemplified unix together either sccs rcs 52 integrated environments smile distributed environments cedar 48 project management environments cms extended toolkit model directly extends individual toolkit model adding version control structure configuration control mechanisms see example unix pwb 8 programmer coordination supported structures mechanisms enforced coordination supplied management decision generate systems example sccs rcs databases thus kind family environment provides individual programmers great deal freedom coordination supported points deposit version control database basic mechanisms program construction individual toolkit model retained however tools must adapted family model structure example make must modified work rcs sccs alternatively tools may constructed conjunction database eg ada program support environments apses 2 extended toolkit model support versionconfiguration control versionconfiguration management compressed versions version trees integrated model extends analogy individual languageoriented model consistency policy permeates tools consistency maintained among component modules addition within module individual model mechanisms determine consistency incrementally although grain size ranges syntax tree nodes gandalf prototype gp 16 procedures smile entire modules toolpack 35 r n 6 models structure typically specialpurpose database although clf generated specification structures vary support simple backup versions parallel sequential versions 17 22 notation beginning list indicates include policies mechanisms structures previous level groupings necessarily mutually exclusive particular either distributed project management aspects mixed matched either extended toolkit integrated environments integrated enforced version control enforced consistency version description languages consistency checking tools specialpurpose database distributed model expands integrated model across number machines connected local area network additional structures required support reliability high availability machines network links fail example mercury 23 multipleuser languageoriented environment depends special distributed algorithm simulates small shared memory guarantee consistency among module interfaces dsees database 27 hand simple extension apollos network file system distributed model network mechanisms distributed objects project management model orthogonal progression extended toolkit model distributed model environments provide additional support coordinating changes assigning tasks individual programmers dsee structures mechanisms provided assigning completing tasks may composed subtasks activities 28 cms adds modification request mr tracking system top sccs individual programmers assigned particular change requests changes associated particular sets sccs versions project management model support activity coordination activity coordination mechanisms activity coordination structures family model represents current state art software development environments general individual model extended mechanisms structures provide small degree enforced coordination among programmers policies generally laissez faire respect activities enforcement coordination generally centered around version control configuration management elaborate instance family model respect mechanisms dsee elaborate respect structures clf 33 city model size project grows say 20 people interactions among people increase number complexity although families allow great degree freedom much larger populations cities require many rules regulations attendant restrictions individual freedom freedom appropriate small groups produces anarchy allowed degree larger groups precisely problem scale complexity interactions leads us introduce city model cooperation policies cooperation mechanisms structures cooperation notion enforced coordination family model insufficient applied scale represented city model consider following analogy farm rules needed govern use farm vehicles within confines farm minimal set rules govern uses vehicles used basically farm workers coordinate use vehicles rules determined real time adjusted various needs arise change however set rules mode rule determination inadequate govern interactions cars trucks average city chaos would result without complex set rules mechanisms enforce cooperation people vehicles alteration rules necessity serious consequences affect much larger population consider problem europe changed driving left driving right side road thus enforced cooperation primary characteristic city model contention family model currently used need city model family model appropriate task family model support enforce appropriate set policies handle problems incurred increase scale generally set methodologies management techniques attempt stave anarchy easily occur methodologies management techniques work varying degrees success depending well enforce necessary cooperation among developers little work done environments implement city model enforce cooperation among developers discuss two environments inscapeinfuse 37 39 istar 10 infuse focuses technical management change process large systems whereas istar focuses project management issues cases concern policies enforced cooperation dominate design implementation infuse policy enforced cooperation making concerted set changes many programmers led exploration various structures mechanisms istar contractual model policies embodied model dominate search project management structures mechanisms primary concern infuse technical management evolution large systems kinds policies mechanisms structures needed automate support making changes large systems large numbers programmers infuse generalizes smiles experimental databases hierarchy experimental databases serves encompassing structure enforcing infuses policies programmer interaction policies enforce cooperation among programmers several ways 24 infuse automatically partitions set modules involved concerted set changes hierarchy experimental databases basis strength interconnectivity measure used approximation oracle tells modules affected changes partitioning forms basis enforcing cooperation experimental database proscribes limits interaction however see discussion workspaces leaves hierarchy singleton experimental databases actual changes take place changes module selfconsistent may deposited parent database nonleaf database effects changes determined respect components partition analysis determines local consistency modules within database modules within partition locally consistent may database deposited parent iterative process continues entire system consistent changes conflict experimental database provides forum negotiating resolving conflicts currently formal facilities negotiation framework conflicts resolved database repartitioned change process repeats infuse originated still change management component inscape environment explores use formal interface specifications semantic interconnection model construction evolution software systems however management issues support large number developers sufficiently orthogonal semantic concerns inscape applicable much wider context example environments tools supporting syntactic interconnection model treated independently sub partitioning partitioning algorithm approximation optimal oracle infuse provides escape mechanism workspace programmers may voluntarily cooperate forestall expensive inconsistencies top hierarchy thus rules interaction encoded mechanisms hierarchy providing supporting structure infuse enforced voluntary cooperation automatic partitioning local consistency analysis database deposit local integration testing hierarchy experimental databases whereas infuse concerned technical problems managing system evolution istar concerned managerial problems managing system evolution istar integrated project support environment ipse 29 seeks provide environment managing cooperation large groups people producing large system end embodies implements contract model system development istar directly provide tools system construction instead supports plugging various kinds workbenches contract model dictates allowable interactions among component developers 47 client specifies required deliverables products produced contractor client specifies terms satisfaction deliverables specific validation tests products contractor provides periodic reporting status project state product developed clients thus able monitor progress contracts istar provides support amending contracts project develops thus contract structure change ways products change contract database provides underlying structure environment thus interactions clients contractors proscribed underlying model mechanisms environment enforce rules interaction exact interaction tools construction components system left unspecified means contracting components system enforced environment contract model contract support tools contract data base also investigating utility structure cooperation integration testing notion local integration testing analogous notion local consistency checking expect able assist integration changes providing facilities test harness construction integration regression testing within framework 34 state model pursuing metaphor leads consideration state model certainly notion state collection cities suggestive company collection projects think intimations model following department defense standardizing one particular language ada projects company trying establish uniform development environment unix projects company establishing common methodology set standards used projects easy understand rationale behind decisions reduction cost improvement productivity uniform environment used several projects developers may move freely projects without incurring cost learning new environment reuse various kinds possible tools may distributed little difficulty code may reused design requirements may reused etc commonality policies supporting mechanisms supporting structures model concern commonality standards dominant policy commonality tends induce policies specific projects city model environments thus policies state model higherorder policies quality inducing policies rather particular structures mechanisms one imagine existence instances model certainly many cases needed know one intuition suggests following general description provide generic model attendant tools supporting structures software development used throughout particular company instantiate model project tailoring instance dynamically particular needs individual project manage differences various instances support movement projects thus little known state model appears useful fruitful area investigation scaling one class next ideally scaling one class next would matter adding structures mechanisms top existing environment least one case done without much difficulty scaling individual toolkit model family extended toolkit model example involves small increment policy extremely attractive think higherlevel models using lowerlevel models components upon establish new policies mechanisms structures unfortunately several difficulties first problem tightness coupling structures mechanisms even scaling toolkit extended toolkit environments retrofitting old tools new structures necessary raises fundamental question whether profitable retrofit changes system reconstruct entire environment scratch example environment generators assume common kernel optimized specific model often particular group within model consequently difficult scale mercury scales synthesizer generator extensive modifications common kernel rather adding something coordinate generated editors infuse provides another example since direct generalization smile initially attempted see various position papers discussions 3rd international software process workshop 11 extend smiles implementation strategy failed current implementation completely independent smile second problems arise lack structures mechanisms baselevel environment suitable next level example multipleuser interpretive environments extremely rare lack suitable structures mechanisms particularly important moving family model city model enforcement much serious issue building security measures top permissive environment unix particularly difficult easy subvert enforcement mechanisms last problem well granularity structures mechanisms one level lend supporting next level example file system toolkit approach easily adapted extended toolkit however higherlevel structure extensions embedded convention within lowerlevel structure sccs version information embedded sccs directive within source files note examples illustrating scaling difficulties necessity individual family model since increment much smaller family city expect greater obstructions scaling family city model fundamental source various problems lies fact policies mechanisms structures required higher levels environments sense basic must designed rather added 4 contributions substantial part research focuses problems largescale systems led us consider existing environments inadequate solving problems order characterize compare environments respect suitability largescale systems developed model software development environments introduced metaphorical classification scheme summarize contributions follows general model distinguishes precisely aspects environment useful evaluating software development environments policies mechanisms structures taxonomy delineates four important classes interaction among software developers respect problems scale individual family models represent current state art software development environments explain two models illsuited development large systems show city model introduces qualitative differences policies structures mechanisms required large software development projects propose state model need clarification understanding implementation conclude pressing need research technical managerial aspects city model environments delineation state model acknowledgements careful readings critical comments dave belanger craig cleveland narain gehani warren montgomery peggy quinn maria thompson helpful comments discussions bob balzer lori clarke larry druffel bob ellison peter feiler nico habermann jack wileden alex wolf professor kaiser supported part grants att foundation ibm siemens research technology laboratories new york state center advanced technology computer information systems part digital equipment corporation faculty award r database system support software engineering rationale stoneman program refinement transformation entityrelationship model toward unified view data automatic compilation logical specifications efficient programs impact interprocedure analysis optimization r n programming environment programminginthelarge versus programminginthe small programming environments based structured editors mentor experience integrated project support istar incremental programming environment make program maintaining computer programs views tools integrated environments gandalf software development environments system composition version control ada contemporary software development environments introduction c shell architecture intelligent assistance software development intelligent assistance without artificial intelligence environment system version control multiuser distributed languagebased environments workspaces experimental databases automated support software maintenance evolution unix programming environment idl sharing intermediate representations parallel software configuration management network environment computeraided software engineering distributed workstation environment essential properties ipses controlling evolution large scale software systems toward persistent object base gandalf project multics system examination structure software processes software toolpack experimental software development environment research project prototyping project master database software engineering environments software interconnection models version control inscape environment infuse tool automatically managing coordinating source changes large systems conceptual programming environment synthesizer generator source code control system 3b20d processor dmert operating system software devlopment system software development inferential programming management changing types objectoriented database research knowledgebased software environments kestrel institute introduction istar structural view cedar programming environment arcadia software development environment research project cornell program synthesizer syntaxdirected programming environment interlisp programming environment rcs system version control tr generating languagebased environments smalltalk80 interactive programming environment rcsmyampersandmdasha system version control automating transformational development software research knowledgebased software environments kestrel institute structural view cedar programming environment impact interprocedural analysis optimization rsupnsup programming environment generating editing environments based relations attributes gandalf software development environments systematic software development using vdm shared segmented memory system objectoriented database idl sharing intermediate representations prototyping project master database software engineering environments worlds organizing structure objectbases graphical extensible integrated environment software development essential properties ipses common lisp language software development environments anna language annotating ada programs reference manual software processes software software interconnection models database system support software engineering incremental dataflow analysis algorithms automatic programming programmers apprentice synthesizer generator system constructing languagebased editors evaluation programbased software test data adequacy criteria foundations arcadia environment architecture ergo support system integrated set tools prototyping integrated environments software development environment lawgoverned systems pgraphite experiment persistent typed object management unifying model consistent distributed software development environments object management issues software engineering environments workshop report overview dodstd1838a proposed common apse interface set revision overview pcte pcte integrating noninterfering versions programs inscape environment object management case environment configuration management biin sms interface description language definition use software process models programs observations nature context adequate testing objectoriented programming comparative evaluation object definition techniques large prototype systems metaphor conceptual architecture software development environments entityrelationship modelmyampersandmdashtoward unified view data augmenting parsers support incrementality infuse contemporary software development environments characterizing software process intelligent assistance software development maintenance views tools integrated environments toward persistent object base program refinement transformation graphical program development pecan program development systems computeraided software engineering distributed workstation environment implementing relational views programs document structure modularity mentor ctr arun sen dss dsp taxonomic retrospective communications acm v41 n5es may 1998 rakesh agarwal patricia lago pathosa paradigmatic approach highlevel objectoriented software development acm sigsoft software engineering notes v20 n2 p3641 april 1995 alfonso fuggetta classification case technology computer v26 n12 p2538 december 1993 christopher lott controlled experiment evaluate online process guidance empirical software engineering v2 n3 p269289 1997 alan w brown maria h penedo annotated bibliography integration software engineering environments acm sigsoft software engineering notes v17 n3 p4755 july 1992 nazim h madhavji kamel toubache ed lynch ibmmcgill project software process proceedings 1991 conference centre advanced studies collaborative research october 2830 1991 toronto ontario canada dewayne e perry software evolution light semantics extended abstract proceedings 21st international conference software engineering p587590 may 1622 1999 los angeles california united states p ciancarini c mascolo using formal methods teaching software engineering toolbased approach annals software engineering v6 n14 p433453 april 1999 christopher lott process measurement support sees acm sigsoft software engineering notes v18 n4 p8393 oct 1993 naser barghouti gail e kaiser concurrency control advanced database applications acm computing surveys csur v23 n3 p269317 sept 1991
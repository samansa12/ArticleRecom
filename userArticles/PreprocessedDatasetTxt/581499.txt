tagless staged interpreters typed languages multistage programming languages provide convenient notation explicitly staging programs staging definitional interpreter domain specific language one way deriving implementation readable efficient untyped setting staging interpreter removes complete layer interpretive overhead like partial evaluation typed setting however hindleymilner type systems allow us exploit typing information language interpreted practice mean slowdown cost factor three morpreviously type specialization tag elimination applied problem paper propose alternative approach namely expressing definitional interpreter dependently typed programming language report experience issues arise writing interpreter designing language demonstrate soundness combining staging dependent types general sense formalize language called metad prove type safety formalize metad extend shao saha trifonov papaspyrous h language multilevel setting building h allows us demonstrate type safety setting type language contains calculus inductive constructions without repeat work needed establishing soundness system b introduction recent years substantial effort invested development theory tools rapid implementation domain specific languages dsls 4 22 40 47 45 23 dsls formalisms provide users notation appropriate specific family tasks promising approach implementing domain specific languages write definitional interpreter 42 dsl metalanguage stage interpreter either manually adding explicit staging annotations multistage programming 55 30 45 50 applying automatic bindingtime analysis offline partial evaluation 25 result either steps staged interpreter staged interpreter essentially translation subjectlanguage dsl targetlanguage 1 already compiler targetlanguage approach yields simple compiler dsl addition performance benefit compiler inter preter compiler obtained process often retains close syntactic connection original interpreter inspiring greater confidence correctness paper concerned subtle costly problem arise subject metalanguage statically typed particular metalanguage typed generally need introduce universal datatype represent values uniformly see 48 detailed discussion universal datatype means perform tagging untagging operations run time subjectlanguage un typed would writing ml interpreter scheme checks really necessary subjectlanguage also statically typed would writing ml interpreter ml extra tags really needed necessary statically type check interpreter interpreter staged inherits 29 weakness generates programs contain superfluous tagging untagging operations early estimates cost tags suggested produces 26 times slowdown smlnj system 54 extensive studies metaocaml system show slowdown due tags high 10 times 21 remove tagging overhead inherent use universal types one recently proposed possibility tag elimination 54 53 26 transformation designed remove superfluous tags postprocessing phase scheme dsl implementation divided three distinct stages rather traditional two extra stage tag elimination distinctly different traditional partial evaluation specialization stage essence tag elimination allows us type check subject pro staging multistage language usually implies metalanguage targetlanguage language gram transformed checks superfluous tags simply erased interpretation semantically equivalent interface added around interpretation tag elim ination however statically guarantee tags erased must run tag elimination runtime multistage language paper study alternative approach provide guarantee fact user never introduces tags first place type system metalanguage strong enough avoid need follows describe details superfluous tags problem 11 untyped interpreters begin reviewing one writes simple interpreter untyped language 2 notational parsimony use ml syntax disregard types interpreter small lambda language defined follows datatype int v string l string exp exp exp fun eval e case e l se fn v eval e ext env v fe eval f env eval e env provides simple implementation subject programs represented datatype exp function eval evaluates exps environment env binds free variables term values implementation suffers severe performance limita tion particular able inspect result interpretation eval lxv x env0 would find equivalent term compute correct result contains unexpanded recursive call eval problem arises callby value callbyname languages one main reasons called layer interpretive overhead degrades performance fortunately problem eliminated use staging annotations 48 12 untyped staged interpreters staging annotations partition program stages brackets surrounding expression lift next stage building code escape drops surrounded expression previous stage splicing already constructed code build larger pieces code appear within brackets staging annotations change evaluation order programs even evaluating lambda abstraction force unfolding eval function codegeneration time thus adding staging annotations eval function change behavior achieve desired operational semantics case e 2 discussing issue prove adequacy representations correctness implementations interpreters beyond scope paper examples done found elsewhere 54 l se fn v eval e ext env fe eval f env eval e env computing application eval lxv x env0 directly yields term fn v v leftover recursive calls eval multistage languages come run annotation allows us execute code fragment staged interpreter therefore viewed userdirected way reflecting subject program meta program handed type safe way compiler metalanguage 13 hindleymilner staged interpreters programming languages haskell ml use hindleymilner type system eval function staged unstaged welltyped 48 branch case statement different type types cannot reconciled within hindleymilner system circumvent problem using universal type universal type type rich enough encode values types appear result function like eval case includes function well integer values typical definition universal type example might int f v v interpreter rewritten welltyped program fun unf fun eval e case e l se f fn v eval e ext env v fe unf eval f env eval e env compute eval lxv x env0 get back value untyped eval stage version eval computing eval lxv x env0 yields 14 problem superfluous tags unfortunately result still contains tag f may seem like minor issue small program like one effect larger program profusion tagging untagging operations tags would indeed necessary subject language untyped know subjectlanguage statically typed example simplytyped lambda calcu lus tagging untagging operations really needed benchmarks indicate tags add 23 time overhead 54 sometimes large 310 times 21 number approaches dealing prob lem none approaches however guarantee time writing staged interpreter tags eliminated runtime even tag elimination guarantees elimination tags particular examples requires separate metatheoretic proof subject language obtain guarantee 54 contributions paper propose alternative solution superfluous tags problem solution based use dependently typed multistage language work inspired work writing dependently typed interpreters cayenne 2 illustrate viability combining dependent types staging designed implemented prototype language call metad use language vehicle investigate issues arise taking approach built compiler interpreter beginning end metad also report issues arise trying develop dependently typed programming language opposed type theory features basic staging operators dependent types help avoiding redundant typing annotations dependently typed inductive families dependent datatypes separation values types ensuring decidable type checking treatment equality representation types using equalitytypelike mechanism technical contribution paper formalizing multistage language proving safety sophisticated dependent type system capitalizing recent work shao saha trifonov papaspyrous system 44 turn builds number recent works typed intermediate languages 20 7 59 43 9 57 44 16 organization paper section 2 shows take motivating example turn tagless staged interpreter dependently typed setting first present syntax semantics simple typed language show implemented direct fashion metad first part writing unstaged interpreter similar done cayenne 2 simplified presence dependent datatypes metad see related work key observation interpreter needs defined typing derivations rather expressions dependently typed datatypes needed represent typing derivations accurately next show interpreter easily staged step exactly untyped hindleymilner setting section 3 point address basic practical problems arise implementation interpreters dependently typed programming language first show construct typing judgments consumed tagless inter preter review important clear separation computational language type language motivates need representation types effect code tagless staged interpreter section 4 presents formalization core subset metad formal proof type safety original work used system type computational language includes basic effects nontermination 44 paper develop multistage computational language show essentially techniques used verify soundness key technical modifications needed addition levels typing judgments addressing evaluation type binders section 5 discusses related work section 6 outlines directions future work concludes extended version paper available online technical report 36 staged interpreter section show example discussed introduction redeveloped dependently typed setting begin considering definition syntax semantics simply typed version subject language 21 subjectlanguage syntax semantics figure 1 defines syntax type system semantics example subject language shall call sl simplicity development use de bruijn indices variables binders semantics defines types sl mapped intended meaning example meaning type n set natural numbers meaning arrow type function space furthermore map meaning type assignments g product sets denoting finite number types assignment note semantics programs defined typing judgments maps elements meanings types standard way defining semantics typed languages 56 18 39 implementation next section direct codification definition 22 interpreters metad interpreter sl simply implementation definition figure 1 begin defining datatypes used interpret basic types typing environments sl define datatypes metad uses alternative notation sml haskell datatype definitions example define set natural numbers instead writing datatype write inductive inductive notation convenient defining dependent datatypes wish define new types new kinds meaning types types type expression type assignments represented follows inductive inductive inductive 1 definitions means defining new type implement type judgment sl need dependently typed datatype indexed three parameters type assignment env expression exp type typ define datatype shown figure 2 3 constructor datatype corresponds one rules type system object language example consider rule lambda abstraction lam figure 1 basic idea use judgments types principle 19 view type rule constant combinator judgments combinator takes hypothesis judgments returns conclusion judgment case rule requires environment g two types 0 body e lambda abstraction judgment gt returns judgment rule codified directly following constructor je1 el t1 s2 arrowt t1 t2 definition j see differences traditional datatype definitions inductive datatypes constructors dependently typed arguments range type j indexed different indices variability return 3 practical reasons discuss next section datatype legal metad use section explain basic ideas discuss need socalled representation types figure 1 semantics sl inductive figure 2 typing judgment j without representation types type constructors dependent datatypes provide information values 221 interpreters types judgments defining judgments ready implement terpretations note however type result interpretation judgments depends interpretation sl types dependency captured interpretation function typeval figure 3 presents implementation interpretation types typeval mapping type assignments meta types enveval interpretation judgments eval function eval defined case analysis typing judg ments computationally function significantly different one presented section 12 differences include additional typing annotations case analysis typing judg ments importantly writing require use tags result values type system allows us specify return type function typeval tags longer needed help us discriminate type value getting back runtime type system tells us statically 23 staged interpreters metad figure 4 shows staged version eval hindleymilner types staging complicated dependent types staged interpreter evals returns value type code typeval note type value assignments also changed see envevals figure 4 rather carrying runtime values sl carries pieces code representing values variable assignment executing program produces tagless code fragments interested even though eval function never performs tagging un tagging interpretative overhead traversing input still considerable judgements must deconstructed eval run time may require even work deconstructing tagged values staging overheads performed first stage overheadfree term generated execution later stage staging violations prevented standard way metads type system see technical report 36 staging constructs davies 10 addition crossstage persistence 55 refer reader references details nature staging violations adding run construct along lines previous works 51 30 considered turn addressing practical questions unique dependent typing setting including abovementioned judgements constructed 3 practical concerns building type judgments amounts implementing either typechecking type inference language interpreting another practical concern types depend values lead either undecidable unsound type checking happens values contain diverging sideeffecting computations section discuss concerns addressed context metad 31 constructing typing judgments requiring user dsl supply typing judgment program interpreted likely acceptable although depend situation user able use implementation supplying plain text subject pro gram therefore implementation needs include least type checking function function takes representation type annotated program produces appropriate typing judgment exists might even want implement type inference require type annotations input figure 4 presents function typecheck function useful illustrating number features metad type result 4 typecheck dependent sum jest means result typecheck consists sl type typing judgment proves argument expression particular type given type assignment since judgments built subjudgments case strong dependent sum elimination construct need deconstruct 4 pure computational effects whatsoever setting result typecheck option typ j est since particular term given typecheck may welltyped function given paper omit option save space rely incomplete case expressions instead case natt nat arrowt t1 t1 typeval t1 typeval t2 case e emptye unit exte e2 enveval e2 typeval case j jn e1 n1 n1 jv e1 t1 2rho jw e1 t1 t2 j1 eval e1 1rho ev t1 j1 jl ee1 et1 et2 es2 ej1 fn ja e s1 s2 t1 t2 j1 j2 eval e rho s1 arrowt t1 t2 j1 eval e rho s2 t1 j2 figure 3 dependently typed tagless interpreter without representation types case e emptye unit exte e2 envevals e2 code typeval case j jn e1 n1 jv e1 t1 2rho jw e1 t1 t2 j1 evals e1 1rho ev t1 j1 jl ee1 et1 et2 es2 ej1 fn vtypeval et1 evals exte ee1 et1 rho es2 et2 ej1 ja e s1 s2 t1 t2 j1 j2 evals e rho s1 arrowt t1 t2 j1 evals e rho s2 t1 j2 case ev nn case nn z case e exte ee t2 n case e exte e2 t2 case x rx typj2 typecheck e2 ev n el targ s2 case x rt typ j2 typecheck exte e targ s2 ea s1 s2 case x1 rt1 typj1 case x2 rt2 typj2 case rt1 arrowt tdom tcod cast assert rt2tdomjestdom j2 end typecheck e s1 typecheck e s2 case x case t1 natt eval emptye natt j arrowt t2 t3 z typecheck emptye figure 4 staged tagless interpreter function typecheck without representation types results recursive calls typecheck case constructing application judgments illustrates interesting point building judgment expression ea s1 s2 involves first computing judgments subterms s1 s2 judgments assign types arrowt tdom tcod rt2 respective expres sions however definition inductive family j order build larger application judgment tdom rt2 must sl type ie typ values must equal introduce two language constructs metad express sort constraints values first expression form assert introduces equality judgment id e1 e2 values equality types 5 elimination construct used cast expression e2 type tv1 tv2 e1 equality judgment type id v1 v2 type checker allowed use leibniz style equality prove cast correct since e1 equality judgment stating v1 v2 equal operationally expression assert e1e2 evaluates two subexpressions compares equality indeed equal computation proceeds however two values equal program raises exception terminates cast construct makes sure equality judgment introduced assert evaluated runtime equality check succeeds simply proceeds evaluate argument expression alternative using assertcast include equality judgments types part typing judgments build equality proofs part typecheck function 6 approach possible proves verbose omitted paper assertcast however serve convenient programming shortcut relieves user effort formalizing equality type level manipulating equality types 32 representation types combining effects dependent types requires care ex ample typecheck function partial many input terms well typed sl inputs typecheck would cause runtime pattern match failures equality assertion exception would like metad continue sideeffects nontermination exceptions time dependently typed languages perform computations type checking determine equality types allow effectful computations leak computations done type checking risk nontermination even unsoundness typechecking time goal often described preserving phase distinction compile time runtime 5 basic approach dealing problem allow types depend types values disallowing kind dependency however would allow us express type checking function produces term whose type depends 5 feature restricted ground types whose value shown equal runtime 6 due space limitation omit approach define alternative typechecking function accompanying technical report 36 value argument standard solution introduce mechanism allows limited kind dependency values types limited dependency uses socalled singleton representation types 60 7 9 57 basic idea allow bijections ground terms value type world rewrite interpreter type depend runtime values may introduce effects typechecking phase computation type checking phase guaranteed completely effectfree runtime values forced representation types reflect world values values inductive kinds metad special type constructor r used express kind dependency example define inductive kind nat inductive note definition exactly one type nat except classified 2 instead 1 definition encountered introduced constructors type also possibility using special type constructor r write rss z refer type unique inhabitant also call rep ss z figure 5 presents implementation representation types introducing restriction type system requires us turn definition exp env typ definitions kinds change one character definition terms kinds cannot use general recursion defining interpretation therefore use special primitive recursion constructs provided type language define interpreta tions judgments however remain type type indexed types values part definition judgments interpretation function change need change judgments case natural numbers augmenting representation value number constructor jn becomes definition eval changed accordingly modified eval uses helper function convert representation natural type natural number 7 definition typecheck function requires substantial changes figure 5 particular function requires carrying case analysis types 20 7 59 43 9 purpose metad provides special case construct tycase x cn xn en pattern cn xn matches value x type k k inductive kind provided representation value type rx pattern matching inductive kinds cannot performed without presence corresponding runtime value appropriate representation type inside body case en expression rep xn provides representation value part inductive constructor xn bound 4 formal development section report main technical result type safety formalized core subset metad result shows multistage programming constructs safely used even integrated sophisticated dependent type system follow approach used developers tl build computation language l h uses type language integrating formalization 7 practice see fundamental reason distinguish two identifying however requires addition special support syntactic sugar particular representation type inductive inductive inductive inductive inductive inductive primrec typ nat fn c 1 fn 1 c fun cast n rn z zero cast case j jn e1 n1 rn1 cast n1 rn1 jv e1 t1 2rho jw e1 t1 t2 j1 eval e1 1rho ev t1 j1 jl ee1 et1 et2 es2 ej1 fn ja e s1 s2 t1 t2 j1 j2 eval e rho s1 arrowt t1 t2 j1 eval e rho s2 t1 j2 tycase rs ev n tycase n rep n z tycase e exte ee t2 n tycase e exte e2 t2 case x rx typj2 1 j2 jw e2 rx t2 n 2 j2 typecheck e2 rep e2 ev n rep ev n el targ s2 case x typecheck exte e targ rep exte e targ s2 rep s2 ea s1 s2 case x1 t1 typj1 case x2 t2 typj2 tycase t1 1 j1 arrowt tdom tcod cast assert t2tdomjestdomj2 end typecheck e rep e s1 rep s1 typecheck e rep e s2 rep s2 figure 5 tagless interpreter representation types metad inductive w figure 6 definition types l h type expressions cast e 0 figure 7 syntax l h cast figure 8 type system l h framework gave us significant practical advantages formal development l h important metatheoretic properties type language use tl already proven 44 since change anything type language results eg churchrosser property type language decidable equality type terms easily reused proofs based computational language lh 44 tried make difference two languages small possible result proof type safety l h similar type safety proof lh able reuse certain lemmata techniques developed lh proof detailed proof type safety l h presented extended technical report 36 figure 6 defines l h computational types first step needed integrate l h framework syntax computational language l h given figure 7 language l h contains recursion staging constructs contains two predefined representation types naturals booleans construct lh provides propagating proof information branches analogous tycase construct metad full implementation inductive datatypes style metad left future work since arbitrary dependent types prohibited l h use universal existential quantification express dependencies values types kinds example identity function naturals expressed l h follows l h also formalize assertcast construct requires extending language computational types equality judgment types similarly add appropriate constructs syntax l h able define smallstep semantics staged lan guage define syntax l h terms levelindexed families expressions values 48 typing judgment fig ure 8 well type assignments l h also appropriately extended level annotations 55 levelannotation erasure function j n used convert l h typing assignments form required typing judgment tl44 interface allows us reuse original typing judgment due lack space show definitions smallstep semantics l h together proofs relevant theorems included companion technical report 36 list important theorems proof structural induction e n 2e n examination cases typing judgment proof cases possible reductions e e 0 7 proof uses subject reduction lemma 2 progress lemma 1 lemmas follows wright felleisens syntactic technique 58 5 related work barendregt 3 good highlevel introduction theory dependent type systems number references strictly terminating functional programming dependent type theory literature 32 31 6 cayenne dependently typed programming language 1 essence direct combination dependent type theory potentially nonterminating recursion fact used implement unstaged interpreter similar one discussed paper 2 work presented extends work done cayenne three respects first cayenne allows types depend values thus ensure type checking termi nates second cayenne support dependent datatypes like jest writing interpreter involves use separate proof object encode information carried jest mostly threaded program number parameters passed metad cayenne implementation eval function using dependent datatypes metad allows direct analogy standard definition semantics typing judgments rather raw terms third cayenne provide explicit support staging essential component achieving performance results achieved using tagless staged interpreters xi pfenning study number different practical approaches introducing dependent types programming languages 59 60 work concentrates limiting expressivity dependent types thus limiting constraints need solved presburger arithmetic problems singleton types seem first used xi context dml 60 idea later used number works developed idea representation types intensional type analysis logical frameworks 19 37 use dependent types basis proof systems related work logical frameworks alone sufficient purposes interested computational programming languages effects nontermination recent work shao saha trifonov papaspyrou generic framework safely integrating computation base language rich dependent type system without losing decidability soundness typechecking dybjer extensively studies semantics inductive sets families 11 12 13 14 16 simultaneous inductive recursive definitions 15 uses former type level also use value level jest coq proof assistant provides fairly extensive support kinds definitions 17 34 35 future interesting explore integration second techniques programming languages one interesting problem whether selfinterpretation possible given programming language possible simplytyped languages 54 clear however done dependently typed language 38 exploring problem interesting future work finally staged type inference 46 also used means obtaining programs without tags techniques discussed paper probably closest spirit tag elimination fact multistage setting tag elimination applied runtime nothing nonstandard type analysis key differences staged type inference system code type used reflect type information type information determined dynamic type checking impor tantly success failure staged type inference depend whether value code type undergone simplifica tion easy return value tells us runtime language whether dynamic inference succeeded tag elimination hand works code explicit static type additionally using carefully crafted fallback plan projectionembedding pairs runtime tag elimination guaranteed always denotational semantics certainly operational semantics independently test code analyzed simplifications may done subject program 54 6 conclusions future work paper shown dependently typed programming language used express staged interpreter completely circumvents need runtime tagging untagging operations associated universal datatypes highlighted two key practical issues arise trying develop staged interpreters dependently typed language first need functions build representations typing judgments interpretation function defined second need representation types avoid polluting type language impure terms computational language demonstrate staging constructs dependent types safely combined formalize language multistage computational language typed shao saha trifonov papaspy rous system allows us prove type safety fairly straightforward manner without duplicate work done system practical concern using dependent types writing interpreters systems decidable type inference view highlyvalued feature typed language find annotations burden simple tricks implementation enough avoid need redundant annotations carrying work developed deeper appreciation subtleties involved dependently typed programming implementation type checkers dependently typed languages current implementation prototype system made available online 27 next step study integration dependently typed language practical implementation multistage programming metaocaml 28 also found lot opportunities context dependently typed languages would like explore future examples include syntactically lightersupport representation types formalizing simple tricks used implementation help alleviate need redundant type annotations also interested exploring use dependent types reflect resource needs generated programs 8 24 52 r exercise dependent types welltyped inter preter lambda calculi types little languages phase distinctions type theory type theory programming flexible type analysis resource bound certifica tion intensional polymorphism typeerasure semantics modal analysis staged computation inductively defined sets martinlofs set theory inductive sets families martin lofs type theory settheoretic semantics inductive sets families martinlofs type theory settheoretic semantics inductive families general formulation simultaneous inductiverecursive definitions type theory finite axiomatizations inductive inductiverecursive definitions tutorial recursive types coq semantics programming languages framework defining logics compiling polymorphism using intentional type analysis practical implementation tag elimination building domain specific embedded languages modular domain specific languages tools proving correctness reactive systems using sized types partial evaluation automatic program generation jonesoptimal specialization strongly typed languages metaocaml compiled inherited limits idealized metaml simpler programming constructive set ory examples programming martinlofs type theory oregon graduate institute technical reports inductive definitions system coq rules properties inductive definitions system coq rules properties emir pasalic logic programming lf logical frame work leap language eval polymorphism basic category theory computer scientists microlanguages operating system specializa tion definitional interpreters higherorder programming languages definitional interpreters higherorder programming languages nikolaos pa paspyrou benaissa emir pasalic peyton jones transformation library data structures sound reduction semantics untyped cbn multistage computation directions functional programming realtime applications tag elimination type specialisation typeindexed effect tag elimination jonesoptimality semantics programming languages fully reflexive intensional type analysis syntactic approach type soundness eliminating array bound checking dependent types dependent types practical programming tr basic category theory computer scientists logic programming lf logical framework inductive sets families martinlomyampersandumlfs type theory settheoretic semantics semantics programming languages partial evaluation automatic program generation syntactic approach type soundness compiling polymorphism using intensional type analysis typebased compiler standard ml modal analysis staged computation proving correctness reactive systems using sized types building domainspecific embedded languages multistage programming explicit annotations dynamic typing staged type inference eliminating array bound checking dependent types intensional polymorphism typeerasure semantics dependent types practical programming flexible type analysis resource bound certification sound reduction semantics untyped cbn mutlistage computation theory metaml nontrival extended abstract dsl implementation using staging monads fully reflexive intensional type analysis type system certified binaries principles programming languages semantics applications implementation program generation tag elimination jonesoptimality jonesoptimal specialization strongly typed languages inductive definitions system coq rules properties multistage programming directions functional programming realtime applications idealized metaml inherited limits definitional interpreters higherorder programming languages programming constructive set theory modular domain specific languages tools multistage programming ctr chiyan chen hongwei xi implementing typeful program transformations acm sigplan notices v38 n10 p2028 october jason eckhardt roumen kaiabachev emir pasalic kedar swadi walid taha implicitly heterogeneous multistage programming new generation computing v25 n3 p305336 january 2007 manuel fhndrich michael carbin james r larus reflective program generation patterns proceedings 5th international conference generative programming component engineering october 2226 2006 portland oregon usa adam chlipala certified typepreserving compiler lambda calculus assembly language acm sigplan notices v42 n6 june 2007 seth fogarty emir pasalic jeremy siek walid taha concoqtion indexed types proceedings 2007 acm sigplan symposium partial evaluation semanticsbased program manipulation january 1516 2007 nice france oleg kiselyov chungchieh lightweight static capabilities electronic notes theoretical computer science entcs v174 n7 p79104 june 2007 chiyan chen rui shi hongwei xi implementing typeful program transformations fundamenta informaticae v69 n12 p103121 january 2006 oleg kiselyov kedar n swadi walid taha methodology generating verified combinatorial circuits proceedings 4th acm international conference embedded software september 2729 2004 pisa italy sheard languages future acm sigplan notices v39 n12 december 2004 edwin brady kevin hammond verified staged interpreter verified compiler proceedings 5th international conference generative programming component engineering october 2226 2006 portland oregon usa jim grundy tom melham john oleary reflective functional language hardware design theorem proving journal functional programming v16 n2 p157196 march 2006 walid taha michael florentin nielsen environment classifiers acm sigplan notices v38 n1 p2637 january
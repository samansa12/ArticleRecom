crash resilient communication dynamic networks abstractan endtoend data delivery protocol dynamic communication networks presented protocol uses bounded sequence numbers tolerate link failures intermediate processor crashes previous bounded endtoend protocols could tolerate crasheswe present selfstabilizing version algorithm recover crashes sender receiver well intermediate processors starting network arbitrary state selfstabilizing version guarantees proper transmission messages following finite convergence period b introduction basic communication task network endtoend communication delivery finite time data items generated designated sender processor designated receiver processor without duplication omission reordering data items endtoend communication easy achieve reliable net work links never fail processors crash however existing communication networks link failures processor crashes possible network subject failures called dynamic network one approach constructing endtoend protocols dynamic networks use unbounded sequence numbers uniquely identify data items sent sender approach used protocol ae86 use unbounded sequence numbers implies message size amount memory needed grow number data items transmitted therefore much effort spent designing endtoend protocols use bounded sequence numbers important aspect endtoend communication protocol type faults tolerate clearly endtoend task unsolvable permanent senderreceiver link cut network work supported nsf presidential young investigator award ccr91 58478 funds texas university college engineering contact author jennifer l welch email welchcstamuedu phone 4098455076 fax links forever thus assumption behavior faulty links necessary three common assumptions literature infinitely frequent stability infinitely often network topology stabilizes period time senderreceiver link cut stabilized topology eg aag87 as88 infinitely frequent path stability infinitely often period time links forming least one path sender receiver operating eg agh90 h92 eventual connectivity assumption permanent senderreceiver link cut eg ag88 ams89 ag91 agr92 almost existing endtoend protocols depend physical links made wellbehaved sequence messages delivered always prefix sequence sent ie messages lost middle processors crash behavior ensured running alternating bit protocol bsw69 processors crash good behavior cannot achieved without keeping information including message currently transmitted stable storage 2 even weaker behavior physical links required namely crashes end points sequence delivered prefix sequence sent either stable storage required flms91 bound capacity link must known adw93 unfortunately existing dynamic networks processors may repeatedly crash recover corrupted memory even problem one endtoend protocols caused crash message currently transmitted lost probability data item delivered could exponentially small length path data item travels assuming probability processor crashing delivery data item bounded constant would like protocol resilient crashes intermediate processors ie processors network designated sender receiver rely stable storage exclude possibility sender receiver failing since stable storage would required argument alluded physical link obviously actual systems sender receiver could crash recovery techniques used case application dependent beyond scope paper presence processor crashes previous definition eventual connectivity sufficient existence protocol since permanent cut combination crashed processors crashed links could eliminate connection sender receiver thus make weakest assumption possible namely exists least one viable path sender receiver path contains permanently faulty link 2 known endtoend protocol withstand processor crashes without stable storage randomized protocol presented h92 however protocol bounded probability failure uses headers strictly bounded processor permanently crashed path ie least one path along communication possible elegant approach designing communication protocol view network run black box provides message transfer service messages lost reordered duplicated corrupted 3 however approach limitations wz89 show bounded sequence number protocol tolerate reordering duplication aa92 show although bounded sequence number protocol tolerate reordering loss protocol must property number messages needed transmit data item increases without bound impossibility results hinge assumption black box network reorder messages arbitrarily assumption models situation user network know network layer protocols implement black box route messages even network topology alternative approach avoids arbitrary reordering use knowledge network topology explicitly control retransmissions routes packet indeed lost traveling physical link however duplications caused protocols retransmit packets certain circumstances packet retransmitted protocol duplication exists reordering also protocol property protocol uses single path sender receiver single path receiver sender fifo property direction preserved network thus protocol designed work top bare network consisting nodes connected fifo nonduplicating links lose messages although protocol retransmit uses multiple paths thus messages duplicated reordered lost activities carefully coordinated paper present endtoend protocol dynamic networks tolerate crashes nodes failures links communication network without requiring stable storage knowledge link capacities best knowledge protocol first crash resilient endtoend protocol uses bounded sequence numbers space complexity protocol ie maximum amount space used processors program op 2 log p p number simple paths network message size op log p bits time complexity ol l length viable path message complexity onp1lt n number processors system retransmission parameter roughly speaking time message complexity measured runs time message travel viable link 1 comparable complexity measures agr92 assumes reliable data link layer number possible paths p two processors system theoretically exponential jej number links system could drawback protocol however practical communication schemes 3 practice nonzero probability message corrupted however due error detection schemes assumed messages identified discarded based sending messages along single route source destination see h92 nice discussion practical protocols thus protocol theoretical interest could used improve existing protocols using constant number paths source destination long least one viable data items delivered moreover delivery time time interval due fastest reliable path period another application protocol case parallel physical links two processors application would provide implementation reliable nonparallel link situation number paths would obviously extremely small 2 bare network model communication network graph gv e jv nodes processors edges undirected communication links undirected link consists two directed links delivering messages opposite directions communication link connects two processors two processors connected link called neighbors communication links obeys fifo discipline bound transmission delay known processor system viewed state machine executing pro gram execution program consists sequence steps step consists 1 one receive operation zero one message ceived 2 internal computations 3 zero send operations internal computation sender include input data items internal computation receiver include output data items assume sender receiver subject crashes processor called intermediate processor intermediate processors subject crashes following crash processor reenters initial state may continue executing crash intermediate processor could occur middle step modeled partial step subset messages sent actually sent model link processors p q two fifo queues one holding messages transit p q holding messages transit q p links subject failures link failure causes one messages eliminated component queues configuration system set states processors contents messages links run sequence configurations initial configuration processor initial state links empty going c c i1 one following holds processor p takes next step possibly partial step according program message received head relevant queue c dequeued c i1 p changes state accordingly enters initial state partial step messages sent enqueued c i1 nothing else changes link fails change one messages queues particular link c longer c i1 going concerned runs satisfy certain basic con ditions given run admissible sender takes infinite number steps receiver takes infinite number steps exists least one viable path sender receiver remains define viable path assume infinite run satisfying first two admissibility conditions intermediate processor p viable provided whenever p receives message infinitely often succeeds sending infinitely often 4 link viable provided whenever infinite number messages sent link infinite number messages received receiving processor assume true directions link note definition viable link implies receiving processor must take infinite number steps partial steps path viable every intermediate processor every link path viable definition viability weaker agr92 since latter consider processor crashes viable path network sender receiver every path either nonviable processor nonviable link thus senderreceiver cut note restrictions concerning relative ordering processor steps number steps sending message receipt thus asynchronous system assume whatever entity supplies data items sender provides one sender requests one 3 problem statement algorithm solves endtoend communication problem every admissible run following properties satisfied safety prefix run sequence data items output receiver prefix sequence data items input sender 4 definition restricts behavior intermediate processor ways compatible systems supposed strip part header send one link general definition viable processor would upon receiving message infinitely often p executes infinitely often complete step starts receiving however protocol weaker condition infinite execution partial step succeeds forwarding sufficient liveness receiver infinite number outputs interested complexity measures space maximum amount space required nodes program message size maximum number bits message message number maximum number messages sent transfer data item ideal run 5 two successive inputs time maximum length time two successive inputs ideal run time message complexity discussed ideal runs define processors send messages either response receiving messages based timeout parameter order guard message loss say message retransmitted sent based timeout expiring otherwise new time retransmissions due speed processor naturally frequency retransmission influences total time number messages needed deliver data item processor procedure responsible sending messages send procedure keeps track number steps k processor taken order estimate real time elapsed systemdependent value depends say probability loss distribution message delays links want estimate based k good one rationale condition 1 definition ideal goal retransmitting every units time ensure message delivered within one time unit assuming link viable rationale condition 2 definition ideal admissible run ideal 1 whenever processor taken k steps least real time elapsed 2 processor p receives message time addressed travel viable path path neighbor q path receives time 4 protocol main problem protocol keep track set sequence numbers label messages transit network key observation fifo property links used ensure fifo delivery every path sender receiver vice versa message sent description path take messages sent path obey fifo order note two different paths might shared links thus set messages transit link could related one path order two messages within one link necessarily imply anything relative order sending receipt unless two messages path 5 defined sender receiver use set 2p sequence numbers shortly explained number sufficient sender receiver remember sequence number recent message sent received path sender uses arrays sent sr recvrs entry possible path whenever sender sends message sequence number seqnum path path sender assigns sent sr pathseqnum similarly whenever sender receives message sequence number seqnum sender assigns recvrs pathseqnum receiver uses arrays sent rs recv sr bookkeeping sender uses clean paths send new data item new sequence number path path sender receiver considered clean sent sr pathrecv sr path say sequence number currently repeatedly sent path arrived destination use clean paths ensures set sequence numbers messages particular senderreceiver path path contained sent sr path path moreover case two sequence numbers path path messages ordered path ones sequence sent sr path closer sender message sequence number recv sr path unfortunately array recv sr updated receiver thus value recv sr path known sender consequently receiver sends array recv sr sender however sender able distinguish old values recv sr current values done implementing independent alternating bit protocols bsw69 one entire path r individual physical links given path protocol keeps track number alternating bit tokens ie number times sender receives acknowledgement bit currently trying send arrived sender path since sender input last data item sender uses information concerning recv sr arrives path comes second token arrived path since last data item input rule ensures information received reflects current state path whenever information concerning recv sr arrives sender updates view recv sr array called vrecv sr sender uses information sent sr vrecv sr determine whether senderreceiver path clean similarly receiver uses sent rs vrecvrs determine whether receiversender path clean view run protocol sequence alternating stings beginning sender uses sequence number 1 sting receiver first data item sender repeatedly sends message sequence number 1 possible paths eventually message arrives receiver uses sequence number 1 sting sender acknowledgment time receiver sends next sequence number called stingtag used sender sting receiver second data item receiver chooses sequence number minimal sequence number appear either recv sr vsent sr thus sequence number set size 2p1 big enough case recv sr vsent sr include sequence number 1 thus receiver chooses 2 next sequence number used sender sting receiver sender eventually stung acknowledgment receiver first message sequence number 1 arrives sender sender calculates next stingtag used sting acknowledgment similar arguments sequence number 2 sender ready send ith data item getting acknowledgment 1st data item sequence numbers entries sent sr could distinct roughly speaking entry contains last sequence number sent yet cleaned path ie arrived side however since least one viable path path path eventually cleaned sequence number sent sr path sender eventually gets two tokens path updates vrecv sr vrecv sr pathsent sr path sender uses path sending ith data item ith data item sent seqnum sr chosen receiver 1st acknowledgment ith acknowledgment arrives sender continues update cleandirty status senderreceiver paths use information concerning recv sr arrives messages receiver senderreceiver path changes status clean ith acknowledgment arrives sender uses path also send ith data item seqnum sr receiver uses similar scheme deliver ith acknowledgment unlike endtoend protocols based flooding stead message sent entire path specified formal description protocol appears figures 2 3 4 variables used sender initial values appear figure 1 variables receiver similar except order subscripts r reversed confusion possible use name array eg sent sr represent set sequence numbers yielded entries 41 correctness proof throughout section assume admissible run step causes transition c igamma1 c step denote vari value variable var configuration c correctness proof induction number stings r sender stung whenever sender executes line 02 execution line 02 occurs either first atomic step ends line 10 atomic step starts message receive line 11 ends message send line 10 receiver stung whenever sender executes line line 24 execution line 02 occurs first atomic step ends line 12 execution line 24 occurs atomic step starts line 13 ends line 12 variable name type initial value set paths empty arbitrary fig 1 variables sender forever repeat 06 8 path 07 path 2 cleanpathssr 13 recvrsmsgpath msgseqnum 14 19 vrecvsrpath msgrecvsrpath 22 vsentrs msgsentrs od fig 2 program sender forever msg 6 nil 04 pendingmsgpathmsg 07 od fig 3 program intermediate processor recvsrmsgpath msgseqnum 04 forever 07 repeat else sendpathnilsentrs pathbitrs pathnil sentrs recvsr 14 msg 6 nil 22 26 seqnumrs msgstingtag 28 od fig 4 program receiver copy alternating bit protocol implemented distinct undirected path consider single copy alternating bit protocol undirected path path token alternating bit protocol arrives sender sender receives message bit sender currently sending token arrives receiver receiver receives message opposite bit last bit receiver sent given configuration denote path path sequence messages sender receiver 0 messages sequence messages receiver sender j 0 messages together current values bit sr p ath bit rs p ath following rs well known eg bsw69 messages lost duplicated configuration alternating bit protocol bitseq contains single value either 0 1 exists single border bitseq values furthermore border sender eventually changes value bit sr border produced border look sequence bitseq successive configurations run border travels towards end bitseq important property alternating bit used protocol two successive token arrivals sender one token arrival receiver ensures property following lemma lemma 1 suppose j message msg arrives sender path p step j token p first token p sender received since step exists k k analogous property true receiver well next lemma states consecutive stings sender resp receiver set values fseqnum srg sent sr resp fseqnumrsg sent rs either remains decreases seen true inspecting code since sender changes entry sent sr sending message sequence number equal seqnum sr lemma 2 step sting sender fseqnum sr ig 1 analogous property true receiver well prove correctness protocol theorem 3 protocol crash resilient endtoend protocol proof safety liveness properties proved induction number stings r prove following 1 stings 2 even ith sting occurs receiver causes i2th data item output data output equal data previous input b every configuration gamma 1st ith stings message msg transit sender receiver sting sr msgsent sr sent sr 3 odd ith sting occurs sender causes 1st data item input b 1 every configuration gamma 1st ith stings message msg transit receiver sender sting rs msgsentrs sent rs 4 configuration ith sting every senderreceiver path p sequence sequence numbers messages transit along p order starting closest sender form x j k 5 configuration ith sting every receiversender path p sequence sequence numbers messages transit along p order starting closest receiver form x j k prove statement basis 1 obvious code initialization else vacuously true induction assume j show 1 well show odd case even similar left reader even index step ith sting r occurs exists show 4 consider step sender step assume statement true preceding configurations well show true configuration pick path p message sent p step sequence number sent sr p gamma 1 clearly 4 true suppose message sent p different sequence number p cleanpaths sr sent sr p 1 let equal value sent sr p since p cleanpaths sr sent sr p code first time sender changed sent sr p since step look step steps vrecv sr p updated causing p put cleanpaths sr second token p received since lemma 1 information reflects value recv sr p receiver configuration inductive hypothesis holds messages path p sequence number namely long sequence number p recv sr p continue thus configuration p sequence number assertion 4 holds configuration show 5 similar 4 show 2a must show sender never stung step long receiver stung ie must show every message received sender step sequence number equal sting rs note sting rs changed sender stung chosen vsentrs recvrs note ith sting arrives sender sets vsentrs according information sting message inductive hypothesis 3b since transit sting msentrs superset sent rs sent rs inductive hypothesis 5 message transit configuration sequence number either sent rs though recvrs changed path sting message path following sequence number already included sent rs sequence number thus included recvrs message transit configuration sting sender must show message sent receiver step sting sender follows lemma 2 assertion 5 proved 1st sting occurs occurs receiver inductive hypothesis 2a would output straightforward check data correct show 2b immediately ith sting message transit sender receiver sting receiver chose next stingtag back sting gamma 1 message seqnum transit sender receiver message sent sting seqnum current value sent sr attached lemma 2 current set elements sent sr shrink relative sent message show 3 vacuous since show 1 must show eventually receiver stung ie receiver receives message sequence number equal sting sr suppose true first note sting sr changed receiver stung sender gets least two tokens viable path p puts p cleanpaths sr sends current message p lemma 1 current message sting sr eventually copy message get receiver contradiction message length op log p since message consists constant number components largest sent recv arrays consists p entries size log p assuming data items bigger space complexity due intermediate processors storing message path op 2 log p recall time message complexity defined ideal runs first explain detail messages retransmitted send proce dure send procedure keeps track pending recent message sent path whenever send procedure executed following first consider message input procedure message fresh last message sent path stored pending array differs one component sent recv arrays message stored pending actually already done intermediate nodes needs done sender receiver message fresh immediately sent onwards path otherwise sent least k steps elapsed since last sent determined counting steps modulo k consider viable path p length lp happen input two successive data items worst case path needs cleaned costing olp new messages olp time sender receive two alternating bit tokens costing olp new messages olp time finally new stingtag must sting receiver costing olp new messages olp time similar analysis holds acknowledgment come back sender thus time complexity ol l length shortest viable path discuss message complexity number retransmitted messages sent two successive data item inputs onplt recall retransmission parameter reason ol time inputs n processors retransmits p paths olt times consider new messages path p length lp discussion shows olp new messages used since lp n p paths number new messages onp thus message complexity onp note cost due retransmissions implicitly explicitly protocols assume reliable data link layer concluding remarks presented crash resilient endtoend protocol protocol ensures reliable data transfer even present processor crashes long least one viable path sender receiver although bypassed datalink layer protocol still work links running datalink protocol even presence crashes crash affect correct functioning datalink protocol one two ways either message lost link could even without datalink protocol message duplicated however duplication tolerable protocol could happened point intermediate node protocol well duplicate immediately follows duplicate inserted later malicious way protocol easily modified work case viability one direction imply viability direction let p sr number paths sender receiver prs number paths receiver sender one possibility virtually implement p sr theta prs alternating bit protocols one possible combination senderreceiver path receiversender path since least one combination viable directions current information recv sr array reach sender current information recvrs array reach receiver several optimizations possible one update vrecv sting arrives addition one token arrived change cause paths placed cleanpaths earlier another possible optimization concerns reducing message size sending array elements changed since last time third optimization would every node periodically send one large message neighbor containing individual messages paths go neighbor instead sending messages separately immediately change would decrease total number messages would increase message length time however simplicity presentation incorporated optimizations protocol could also made selfstabilizing details selfstabilizing version appear dw93 acknowledgment thank reuven cohen amir herzberg helpful discussions amir also gave us useful comments written draft r reliable communication unreliable channels applying static network protocols dynamic networks memory requirements connection management reliable broadcast protocols unreliable net works bootstrap network resynchronization efficient technique endtoend communication quantitative approach dynamic networks slide mechanism applications dynamic networks polynomial end end com munication dynamic networks fast static networks note reliable fullduplex transmission halfduplex links crash resilient communication dynamic networks resynch procedures failsafe network protocol impossibility implementing reliable communication face crashes tight bounds sequence transmission problem tr ctr micah adler faith fich complexity endtoend communication memoryless networks proceedings eighteenth annual acm symposium principles distributed computing p239248 may 0406 1999 atlanta georgia united states pierre fraigniaud cyril gavoille headersize lower bounds endtoend communication memoryless networks computer networks international journal computer telecommunications networking v50 n10 p16301638 14 july 2006 faith fich eric ruppert hundreds impossibility results distributed computing distributed computing v16 n23 p121163 september
efficient algorithm aggregating pepa models abstractperformance evaluation process algebra pepa formal language performance modeling based process algebra previously shown using process algebra apparatus compact performance models derived retain essential behavioral characteristics modeled system however efficient algorithm derivation given paper present efficient algorithm recognizes takes advantage symmetries within model avoids unnecessary computation algorithm illustrated multiprocessor example b introduction recent years several markovian process algebras mpas presented literature include pepa 1 mtipp 2 empa 3 classical process algebras formalisms allow models systems constructed amenable functional behavioural analysis variety techniques additionally allow timing information captured models facilitate performance analysis via solution continuous time markov chain ctmc process algebras several attractive features facility highlevel definition compositional structure existence formally defined equivalence relations used compare models markovian context theoretical results shown possible exploit equivalence relations level model description generate aggregated ctmc compositional way 4 great practical importance like statebased modelling techniques mpa models suffer state space explosion problem although prototype tools developed model exploration 5 6 7 little work done exploit full potential use equivalence relations achieve effective aggregation thus put theoretic results practical use paper describe algorithm carry efficient aggregation implementation pepa workbench aggregation widely used wellunderstood technique reducing size ctmc used performance analysis state space ctmc partitioned number classes treated single state new derived stochastic process partition shown condition known lumpability 8 new stochastic process ctmc amenable numerical solution steady state probability distribution via linear algebra mpa context partitioning carried using formally defined equivalence relation establishes behavioural observational equivalence states within model equivalence relation generally discussed relation aggregation called strong equivalence pepa markovian bisimulation mtipp extended markovian bisimulation equivalence empa however problems applying equivalence relationaggregation syntax level compositional way discussed detail section 5 paper use finer equivalence relation called isomorphism although may result coarser aggregations advantage readily amenable automatic generation equivalence classes syntax level thus construction complete state space avoided aggregated ctmc constructed directly rest paper structured follows section 2 introduce pepa language operational semantics aggregation via isomorphism algorithm computation reduced state space discussed section 3 example presented section 4 cases algorithm cannot achieve optimal theoretical partitioning discussed section 5 section 6 presents related approaches finally section 7 concludes paper presenting possible future investigation performance evaluation process algebra pepa algebraic description technique based classical process algebra enhanced stochastic timing information extension results models may used calculate performance measures well deduce functional properties system section briefly introduce pepa detailed information found 1 process algebras mathematical theories model concurrent systems algebra provide apparatus reasoning structure behaviour model classical process algebras eg calculus communicating systems ccs 9 time abstracted awayactions assumed instantaneous relative ordering represented choices generally nondeterministic exponentially distributed random variable used specify duration action process algebra may used represent markov process approach taken pepa several markovian process algebras 2 3 basic elements pepa components activities corresponding states transitions underlying ctmc activity represented two pieces information label action type identifies activity rate parameter negative exponential distribution determining duration thus action represented pair ff r assume set possible action types includes distinguished type type denotes internal unknown activities provides important abstraction mechanism process algebra notation representing systems wholly based use formal language pepa language provides small set combinators allow language terms constructed defining behaviour components via activities undertake interactions syntax may formally introduced means following grammar denotes sequential component p denotes model component executes parallel c stands constant denotes either sequential model component defined defining equation c stands constants denote sequential components component combinators together names interpretations presented informally rs basic mechanism describing behaviour system give component designated first action using prefix combinator example component ff rs carries activity ff r action type ff exponentially distributed duration parameter r subsequently behaves set action types denoted sequences actions combined build life cycle component example comp life cycle sequential component may complex behaviour expressed using prefix combinator alone choice combinator captures possibility competition selection different possible activities component represents system may behave either 1 2 activities 1 2 enabled first activity complete distinguishes one discarded system behave derivative resulting evolution chosen component example faulty component considered may also capable completing task satisfactorily comp constant c already seen convenient able assign names patterns behaviour associated components constants provide mechanism components whose meaning given defining equation eg c def gives constant c behaviour component p cooperation systems comprised several components interact pepa direct interaction cooperation components represented combinator delta set l visible action types l n fg significant determines activities components forced synchronise thus cooperation combinator fact indexed family combinators one possible cooperation set l cooperation imposed namely action types l components proceed independently concurrently enabled activities however component enables activity whose action type cooperation set able proceed activity component also enables activity type two components proceed together complete shared activity rate shared activity may altered reflect work carried components complete activity example faulty component considered may need cooperate resource order complete task cooperation represented follows system ftaskg res component also needs cooperate repairman order repaired could written system delta repman equivalently ftaskg repman cases activity known carried cooperation another component component may passive respect activity denoted ff means rate activity left unspecified determined upon cooperation rate activity component passive actions must synchronised final model cooperation set empty two components proceed indepen dently shared activities use compact notation p k q represent case thus two components compete access resource repairman would represent system ftaskg repman hiding pl possibility abstract away aspects compo nents behaviour provided hiding operator set l visible action types identifies activities considered internal private component activities visible external observer accessible components coopera tion example system introduced may wish ensure components exclusive access resource order complete task thus hide action type task ensuring even system embedded environment component access task activity resource system ftaskg resftaskg activity hidden appears unknown type rate activity however remains unaffected precedence combinators provides default interpretation expression hiding highest precedence prefix next followed cooperation choice lowest precedence brackets may used force alternative parsing simply clarify meaning 21 operational semantics underlying ctmc model components capture structure system terms static components dynamic behaviour system represented evolution components either individually cooperation form evolution governed set formal rules give operational semantics pepa terms semantic rules structured operational style plotkin shown figure 1 interested reader referred 1 full details rules read follows transitions inference line inferred infer transition line one example two rules choice show choice operator symmetric preserves potential behaviours two operands another cooperation operator special case two cooperands synchronise activities notation case e k f case three rules would simplify two shown f rules capture intuitive understanding two components synchronise activities cannot influence others computational state case components synchronise rate resulting activity reflect capacity component carry activities type component e action type ff termed apparent rate ff e denoted r ff e sum rates activities enabled e exact mechanism used determine rate shared activity explained shortly classical process algebra semantics term pepa given via labelled transition system case labelled multitransition systemthe multiplicities arcs significant transition system state corresponds syntactic term language derivative choice f cooperation f f f f r ff e r ff hiding constant e figure 1 operational semantics pepa initial state figure 2 dg multicomponent model without hiding state corresponding derivative ftaskg repman ftaskg repman ftaskg repman ftaskg repman ftaskg repman ftaskg repman ftaskg repman ftaskg repman table 1 states derivation graph figure 2 arc represents activity causes one derivative evolve another complete set reachable states termed derivative set model form nodes derivation graph dg formed applying semantic rules exhaustively example derivation graph system ftaskg repman shown figure 2 assuming following definitions comp res repman simplicity figure chosen name derivatives short names corresponding complete names listed table 1 note pair arcs derivation graph initial state 0 onestep derivative 1 capture fact two distinct derivations activity task according whether first second component completes task cooperation resource even though resulting derivative either case timing aspects components behaviour represented states dg arc parameter negative exponential distribution governing duration corresponding activity interpretation follows enabled activity ff r delay period sampled negative exponential distribution parameter r several activities enabled concurrently either competition independently assume race condition exists thus activity whose delay completion least one suc ceed evolution model determine whether activities aborted simply interrupted state change either case memoryless property negative exponential distribution eliminates need record previous execution time two components carry activity cooperation rate shared activity reflect working capacity slower component assume component fixed capacity performing activity type ff cannot enhanced working cooperation still must carry work unless component passive respect activity type capacity apparent rate apparent rate ae ae ae ae r r ae ae r r ae ffl ae figure 3 ctmc underlying multicomponent model ff cooperation p delta fffg q minimum r ff p r ff q rate particular shared activity apparent rate shared activity weighted conditional probability contributing activities cooperating components interested reader referred 1 details dg basis underlying ctmc used derive performance measures pepa model graph systematically reduced form treated state transition diagram underlying ctmc derivative state ctmc transition rate two derivatives p p 0 dg rate system changes behaving component p behaving p 0 denoted qp p 0 sum activity rates labelling arcs connecting node p node p 0 example state transition diagram ctmc underlying simple component model shown figure 3 note arc labelled rate 2 states x 0 x 1 representing derivatives comp k comp delta ftaskg repman comp k comp delta ftaskg repman respectively order ctmc ergodic dg must strongly connected necessary conditions ergodicity syntactic level pepa model defined 1 syntactic conditions imposed introduced earlier 22 aggregation pepa via isomorphism equivalence relations notions equivalence generally play important role process algebras defining useful equivalence relations essential part language development pepa various equivalence relations defined include isomorphism captures intuitive notion equivalence language terms based isomorphic derivation graphs strong equivalence sophisticated notion equivalence based bisimulation equivalence relation defined state space model induce partition state space aggregation achieved constructing partition forming corresponding aggregated process aggregated process partition states original process forms one state original state space fx aggregated state space fx 0 x general ctmc aggregated resulting stochastic process markov property however partition shown satisfy socalled lumpability condition property preserved aggregation said exact model considered derived process algebra pepa possible establish useful algebraic properties equivalence relation used important congruence equivalence relation congruence respect operators language substituting equivalent component within model expression gives rise equivalent model eg p equivalent p 0 p delta q equivalent q congruence used basis aggregation compositional model aggregation may carried component component avoiding construction complete state space aggregated component equivalent original nevertheless approach applied semantic level model necessitates expansion subsequent partitioning relevant state spaces reduced model produced way may compact would achieved aggregating complete model directly making application aggregation procedure necessary case model consisting aggregated components isomorphism strong equivalence congruence relations used basis exact aggregation pepa models based lumpability 4 either case relation used partition state space possibly compositionally underlying ctmc equivalence class forms one state aggregated state space algorithm presenting use isomorphism relation use strong equivalence purpose discussed section 5 use isomorphism relation may seem surprising since powerful bisimulationstyle equivalence relations one attractive features process algebras often cited one benefits formal languages contrast isomorphism received little attention literature part classical process algebra objective use equivalence relation determine two agents system descriptions exhibit behaviour stochastic process algebra greater emphasis placed using equivalence relations partition derivation graph model order produce aggregation resulting smaller underlying markov process shown pepas strong equivalence relation powerful tool aggregation style always resulting lumpably equivalent markov process 1 ever believe many instances isomorphism also useful purpose since discriminating notion equivalence may give finer partition thus less aggregation strong equivalence hand show may detected syntactic level system description without recourse semantic level necessary detect strong equivalence general thus reduced derivation graph generated without need construct original derivation graph following section present algorithm exploits isomor phism section 6 discuss relation work automated aggregation 3 algorithm algorithm computing reduced derivation graph pepa model begins preprocessing model supplied modeller purpose preprocessing reexpress model convenient form production aggregated derivation graph aggregated derivation graph nodes equivalence classes pepa terms rather single syntactic expressions preprocessing step pepa syntax systematically replaced model expression converted vector form minimised converted canonical form every distinct pepa expression maps distinct vector form equivalent isomorphic expressions canonical representation preprocessing complete generation reduced derivation graph begin process alternates generating onestep derivatives present state compacting order group together derivatives canonical representation algorithm proceeds assumption model supplied reduced named norm form named form representation derivative sequential component explicitly named norm form model expressed single model equation consists cooperations sequential components governed hiding sets reduced form cooperation hiding sets reduced removing redundant elements supplied model form necessary restructuring carried algorithm applied functions achieve carry routine checks validity model supplied modifications make completely transparent modeller proceed describe steps detail 31 restructuring model application algorithm convenient intermediate derivatives model bound identifiers generate identifiers decompose defining equations sequential component example defining equation comp introduce name intermediate derivative replacing single equation following pair equations comp done sequential component model said named form described section 2 pepa model consists collection defining equations sequential components model components one model components distinguished named initial state model definition component may refer model components defined equations wish eliminate uses model components definition order reduce normed form identifiers used sequential components proceed backsubstituting model component definitions defining equation distinguished component example pair equations repman system ftaskg res become ftaskg res delta repman continue process converges definition normed model equation consists cooperations sequential components governed hiding sets cooperation hiding sets model definition contain unnecessary redundant elements equivalence classes formed algorithm may optimal thus circumstances improve subsequent performance algorithm removing redundant elements sets algorithm applied furthermore presence redundant elements cooperation hiding sets regarded potential error part modeller consequently modeller warned reduction previously presented efficient algorithms computing sets activities act performed pepa model components 10 use reduce minimum size cooperation hiding sets following way reduction applied systematically throughout normed model equa tion operation bounded complexity size static representation input pepa model thus hidden cost traversal state space generated dynamic exploration model 32 preprocessing vector form minimisation canonicalisa tion vector form model expression represents model suitable form aggregation algorithm amenable efficient calculation canonical form present vector form vector sequential components decorated brackets denoting scope sets use subscripted brackets delimit cooperation set superscripted angle brackets delimit hiding sets implementation vectors represented linked lists provide efficient manipulation forming canonical representatives reordering rearrangement representations components vector forms achieved safe staticallychecked pointer manipulation thereby avoiding overhead repeated copying data values would incurred use arraybased representation model expression define vector form inductively structure expression let mn expressions c constant denoting sequential component 1 vf delta 2 vf 3 vf following write p denote vector normed model equation vector form representation contains within single expression information static structure model records name current derivative sequential components addition scope cooperation hiding sets force vector form alone sufficient allow us compute derivation graph model defining equations sequential components also needed generated directly full model equation vector form may include redundancies hence include preprocessing step carried reduce vector form generated straightforward translation model equation vector form used remainder state space exploration step consists generating minimal representation vector form minimal respect number brackets needed record scope cooperation hiding sets see reducing number brackets vector form may significant impact aggregation achieved thus perform following simplifications elimination redundant cooperation brackets arises component q delta r vector form component would q contiguous brackets decoration way inner one eliminated example results q elimination redundant hiding brackets would arise whenever hiding brackets contiguous regardless decoration ex ample component plk vector form would would reduced kl hp minimal vector form reduce model representation canonical form choose arbitrary ordering component terms one suitable ordering lexicographic ordering denote ordering denote canonicalisation function c insert component p vector p using p p definitions functions shown definition 2 definitions complex include completeness order prevent appearing hidden complexity definitions canonicalisation insertion functions present definition canonicalisation function first definition insertion function second three cases definition functions 1 2 c l hp 3 1 p 2 p 3 p 33 generating aggregated derivation graph previous preprocessing steps applied input pepa model facilitate subsequent application aggregation algorithm preprocessing model represented pepa expression represented individual initial state contained information necessary dynamic evolution preprocessing steps performed expression reduced canonical minimal vector retains information state structure model represents equivalence class states thus canonical vector form reduced representation two senses firstly information dynamic behaviour cooperation sets hiding sets common states model factored stored separately secondly canonical vector form may fact represent number equivalent model states would distinct vector forms generating reduced derivation graph proceeds via following two steps carried alternately state space fully explored derivation given vector form objective find enabled activities record list paired vector form corresponding derivative done recursing static structure current derivative lowest level sequential components represented simply derivative name point defining equations used find activity set activities enabled derivative identify three cases individual activities within scope hiding operator recorded directly resulting derivative individual activities within scope hiding operator recorded actions appropriate rate together resulting derivative ffl activities within scope cooperation set compared enabled activities components within cooperation matching activity individual activity discarded otherwise activity recorded together resulting vector form reduction carrying derivation may given rise vector forms canonical moreover several activity vector form pairs may turn identical vector form put canonical form case multiplicity recorded one copy kept two steps repeated elements left set unexplored derivative classes remainder section present steps formally first introduce notation describing formulation manipulation vectors vector forms ffl given vector p write p denote subvector elements p satisfy predicate oe vector p obvious context shall omit writing abbreviation ffl write pp denote vector obtained p substituting ffl subvector similarly write ps abbreviation ps 1 0 note use vector substitution vectors number elements rules govern derivation step algorithm shown figure 4 rule constant formally states lowest level defining equations used find activity activities inferred derivative name two rules hiding correspond first two cases identified complex rules cooperation third case examine detail first rule states condition number identical ac tivities ff r give rise derivatives identical canonical forms case activity ff r must enabled one component p p moreover possible activity vector form resulting derivative always canonicalised formally oe arbitrary element vector 0 say first element 0 1 note equation 1 imply p 0 0 equal equivalence class equal canonical forms vector 0 defined subvector consisting derivatives may potentially change via ff r activity formed vector satisfying conditions activity ff r compute rate component performs activity evolves canonical representative derivatives jsj delta r since total rate equivalence class sum rates individual activities may make move case one elements vector performs activity ff complication due consideration multiplicities arise rule simplifies equivalent following constant hiding gammagammagamma gammagammagamma cooperation gammagammagamma cpl 0 gammagammagamma cpl 0 r ff figure 4 operational semantics vector form complexity second rule cooperation due need calculate rate subvector components cooperation performs activity also simpler case vector size two special case rule affords easier comparison operational semantics pepa presented figure 1 gammagammagamma rate r activity performed cooperation computed individual rates r 1 r 2 corresponding cooperation rule figure 1 34 implementation state space reduction algorithm added pepa workbench 5 modelling package implements pepa language provides variety solution analysis facilities pepa models algorithm presented pseudocode form figure 5 driving force algorithm provided procedure vfderive given derivative model finds enabled transitions using function cderiv calls resulting derivative function cderiv carries canonicalisation onestep derivatives produced using function derivatives function different cases depending structure vector form handled reflecting appropriate rules semantics example case choice list possible derivatives consists list derivatives second component choice appended list derivatives first derivatives vector cooperating components computed using function cooperations derive transitions function disallow enforce activities types cooperation set carried without partner make use function lookup retrieve definitions component identifiers environment finally function update takes set elements procedure returns set element modified procedure modification pepa workbench required alteration data structure used represent pepa models abstract syntax tree within workbench representation cooperations pairs components generalised extend lists components pepa model submitted processing contain marked p begin mark ff r n p 0 cderivp output transition p ffndeltar begin 0 empty choose p 0 n p r n replace n p else add remove p 0 return switch p case unary cooperation return updated proc case nary cooperation return case l hp hiding return filterd l case ff rp prefix return singletonff r p case p q choice return case const c constant return derivativeslookupc begin empty remove x add p x return 1 2 empty return else begin remove 1 remove 2 else return begin empty remove ff r p ff l add r p r else add ff r p r return begin empty remove ff r p ff l add ff r p r return figure 5 pseudocode algorithm structure exploited state space reduction algorithm change invisible user workbench however pepa model contain either repeated components structure exploited benefits become apparent user workbench terms reduced time generate ctmc representation model terms matrix smaller dimension required storage model gets certain size see table 3 4 example section show algorithm works example consider multiprocessor system shared memory derive corresponding pepa model underlying derivation graphs ordinary aggregated alternatives approach discussed section 5 introduced means small variants example 41 multiprocessor system consider multiprocessor system shared memory processes running system compete access common memory gain access use common memory need also acquire system bus released access common memory simplicity bus explicitly represented following processes mapped onto processors processors explicitly represented determine rate activities associated processes ie processes functional behaviour actions progress different speeds depending processor running number processes present processor modellers responsibility select rates appropriately protocol completely fair simply prevents one processor monopolising memory might impose access processor memory processor must gain access first access process running ith processor represented case order impose protocol memory modelled remembering processor access last access processor disabled mem n processes running ith processor system modelled following expression sys mem k note cooperation set model expression throughout remainder paper write get shorthand get assume starting state system excludes access arbitrary processor number k vector form model sys derived applying equations definition 1 following form show example derivation state space sys ordinary aggregated simplicity consider smaller system sys 0 two processors two replicas process running processor simplified system thus specified mem 1 expand derivatives processes p memory mem 1 follows mem 1 mem 2 initial state s1 figure ordinary derivation graph sys 0 complete derivation graph complete derivation graph sys computed using pepa workbench 5 aggregation algorithm switched 96 states 256 transitions portion graph shown figure 6 make drawing easier understand chosen name derivatives short names depending whether state completely expanded onestep derivatives also represented vector forms corresponding derivatives listed table 2 row contains name state corresponding vector form moreover contains information whether vector form canonical name state represents corresponding canonical vector form aggregated derivation graph aggregated derivation graph computed using pepa workbench aggregation algorithm switched 42 states 88 transitions portion graph shown figure 7 compared one figure 6 pepa model sys 0 constructed according algorithm sequential components defining processes memory composed means cooperation operator obtain model equation derivatives explicitly named use model equation generate vector form model redundant brackets therefore elimination required point aggregated state space obtained considering canonical vector forms shown graph figure 7 subset states table 2 corresponding canonical vector forms explicitly outlined names nodes integer numbers round brackets close specify number equivalent states represent numbers computed considering number replicas process model equation numbers equal derivatives vector form example let us consider state 10 corresponds vector form state represents four equivalent derivatives number computed dividing product factorial numbers repeated instances components product factorial numbers identical derivatives vector form state vector form canonical representative 22 26 p 0 28 p 0 table 2 states vector forms 22 4 26 2 6 1 11 1 figure 7 aggregated derivation graph sys 0 generally formula could expressed follows number processes running processor n ij numbers equal derivatives p multiplicities arcs also represented indicate number arcs folded together fact single arc represents one activities type reflected rate action labels arc instance model evolves state 1 states 3 executing action think rate 2 1 1 ie mem 1 two activities think concurrently enabled notice aggregation obtain corresponds finding permutations components within brackets form aggregation pictorially represented figure 7 flattening equivalent nodes derivation graph figure 6 onto plane 42 timings ran different configurations multiprocessor system pentium iii machine clock frequency 500 mhz 128 mbytes mem ory times recorded table 3 take account cpu time time necessary file io single component p running processor aggregation possible execution times basic modified workbench almost soon add replicas process state space aggregation becomes apparent compare second fifth columns table 3 well reduction execution times compare fourth seventh columns particularly size model grows alternative aggregations section illustrate cases algorithm indeed syntactic approach cannot achieve optimal theoretical partitioning particular show greater aggregation could achieved circumstances strong equivalence used generate partitions instead processors derivation graph aggregated derivation graph processes states trans time sec states trans time sec processors derivation graph aggregated derivation graph processes states trans time sec states trans time sec table 3 execution times basic modified workbench isomorphism note however cases rely quite strong conditions apparently unrelated activity rates clear conditions occur sufficient frequency real models justify additional complexity needed implement approach based strong equivalence strong equivalence relation sophisticated notion equiv alence bisimulation style based observed behaviour general process algebra two terms bisimilar externally observed behaviour appears strong equivalence assumes action type apparent rate activity observable informally two pepa components strongly equivalent total conditional transition rates strongly equivalent terms action types conditional transition rate p p 0 via action type ff denoted qp sum activity rates labelling arcs connecting corresponding nodes dg also labelled action type ff conditional transition rate thus rate system behaving component p evolves behaving component p 0 result completing activity type ff consider set possible derivatives total conditional transition rate p denoted qp ff equal definition thus formally stated follows denote set language terms derivatives equivalence relation derivatives r theta strong equivalence whenever ff 2 2 r say p q strongly equivalent written strong equivalence r ie fr j r strong equivalence g two following examples demonstrate use strong equivalence aggregation however first example show abstraction operator may used higher syntactic level model introduce symmetries components appear quite distinct defining equations symmetries rely context components placed something currently captured algorithm 11 ribaudo distinguishes two form aggregation found using strong equivalence horizontal aggregation arises interleaving activities similarly behaved components aggregation takes advantage repeated instances pattern behaviour within overall model structure aggregation found using algorithm may termed horizontal aggregation contrast vertical aggregation arises repeated patterns behaviour within single component second example presented variant multiprocessor model considered horizontal aggregation found using strong equivalence although isomorphism would regard components distinct finally give example vertical aggregation possible strong equivalence isomorphism consequently syntactic approach 51 aggregation via abstraction facility hide abstract action types within pepa model designed give modeller freedom construct components detail ensure behaviour accurately represented subsequently restrict visible action types relevant current modelling study example model multiprocessor presented previous section modeller may choose hide get actions terms capturing correct behaviour protocol important action types distinguished terms complete model may regarded internal actions hiding activities introduces strong symmetries model terms functional behaviour moreover find processes running different processors share timing characteris tics ie symmetries apparent aspects models behaviour one process access memory timeand subsequent memory access host processor excludedbut processes processors behave equiv alently means need consider two classes processors excluded eligible access regardless placement processors get activities hidden longer possible identify process type process operating example consider multiprocessor three processors two processes running first one second two third regard system immediately process p 2 completed access memory one process waiting access behaviour system isomorphic regardless whether waiting process processor 1 processor 3 ie following states isomorphic mem mem mem mem although states equivalent isomorphism algorithm would place within single partition two one consisting first two states one consisting second pair processes operating different processors distinct names distinct actions get necessary ensure correct functioning protocoland syntactic form minimisation use cannot recognise contexts p 1 p 3 behave equivalently could regarded penalty richness language example analogous situation arise petri netbased models notion abstraction hiding 52 horizontal aggregation via strong equivalence isomorphism strict structural equivalence must onetoone relationship derivatives activities observationbased strong equivalence strict although corresponding derivatives must capable action types apparent rates implemented activities derivatives may differ following example demonstrates suppose processor 1 two different types process may run ning first identical process p 1 discussed section 41 second similar pattern behaviour two alternative local computations accesses common memory process rates think activities strongly equivalent p 1 although two clearly isomorphic thus consider system mem 2 algorithm distinguish derivatives p 00 mem 0and p 0 mem 0 2 whereas partitioning based strong equivalence would consider equivalent case state space aggregated algorithm 64 states whereas aggregation based strong equivalence would result 42 states 53 vertical aggregation via strong equivalence identify second source aggregation achieved strong equivalence captured algorithm socalled vertical aggregation illustrate vertical aggregation case means another variant multiprocessor example consider process use memory detect error case return directly initial state instead must complete recovery action repeat access memory new process expansion derivatives could follows p probability error occurs derivation graph process p shown figure 8a suppose action b figure 8 derivation graphs p types think recover hidden become internal component moreover assume case derivatives p p 0000 strongly equivalent aggregate form macrostate p similarly combine arcs labelled rel rel p theta r single arc labelled rel r connecting p 000 figure 8b form aggregation relies information operational behaviour component represented derivation graph cannot detected purely syntactic means used algorithm approaches based bisimulation style equivalences strong equiv alence work semantic rather syntactic level thus general comparable approach 6 related work exploitation symmetries achieve aggregation performance models wellexplored topic several automated approaches described literature section give brief account work appeared context stochastic petri nets stochastic process algebras explain work relates case objective generate partitioning original ctmc satisfies condition lumpability closest approach work class stochastic coloured petri nets called stochastic wellformed nets swn 12 stochastic petri nets spn 13 extensively used functional analysis performance evaluation distributed systems modelling primitives consist places timed transitions representing system states system events respectively pepa order analytically solve spn model associated stochastic process must derived computing set reachable states markings moreover pepa realistic systems computation state space often lead models whose size makes intractable order tackle problem swn allow construction parametric representation system achieved folding similar subnets adding colour structure distinguish tokens folding belong place nets restricted terms possible colour domains places transitions terms possible colour functions restrictions allow symmetric structures within model exploited solution purposes particular structures automatically detected reduced state space constructed without recourse complete state space reduction obtained concept symbolic marking 12 informally symbolic marking corresponds equivalence class ordinary markings sharing characteristics unlike approach formal equivalence relation defined underpin partitioning fact ordinary markings equivalence class enable set transitions whose firings lead new ordinary states still equivalent ie belong symbolic marking starting symbolic representation initial marking symbolic reachability graph constructed via symbolic firing rule symbolic marking represented minimal canonical form note unlike algorithm minimisation carried preprocessing swn case minimisation repeated symbolic derivation step symbolic reachability graph used generate reduced ctmc proved 14 lumpably equivalent original ctmc thus performance estimates computed lower computational cost another petri netbased approach developed context stochastic activity networks san 15 formalism incorporates features spns queueing models makes use compositional operators similar found process algebras primitives formalism places activities equivalent petri nets transitions may guarded input gates representing enabling rules output gates representing completion rules submodels constructed representing components system may combined using replication join operations replication operator captures case system containing two identical subsystems join operator combines san submodels different types use operators makes symmetries within model explicit facilitates compact representation state space structure composed san represented directed tree different types nodes leaf nodes capture distinct san submodels ie basic elements construction operators apply internal nodes one child replication nodes child submodel replicated internal nodes two children join nodes children representing submodels joined together tree state representation automatically extracted minimal sense states differ permutation repeated components grouped together single combined state state represented recording replication node number replicated sans possible submodel marking join node vector markings joined submodel addition state maintains information desired performance variable 15 outside scope paper clear parallels state representation vector form discussed section 32 work aggregation stochastic process algebra models developed almost entirely semantic level approach well known graph partitioning algorithms used reduce labelled transition system underlying process algebra model 16 4 17 syntactic approach taken ad hoc basis without corresponding tool implementation equational laws derived markovian bisimulation equivalent strong equivalence used obtain state space reduction mtipp model achieved term rewriting based judicious application laws however although good results obtained particular models set term rewriting rules used aggregation purposes found approaches good results obtained modifying restricting combinators language make symmetries explicit disallowing difficult cases example 18 symmetric parallel composition operator denoted fnpgs used capture case nary parallel composition identical replicas synchronising actions operator provides means expressing number replicated copies process cannot express synchronisation repeated copies different synchronisation sets operational semantics new operator consistent usual parallel composition reduced state space produced regarded spa equivalent san approach outlined states differ permutation replicated submodels treated equivalent earlier work mtipp took similar approach terms altering combinators language 19 replication operator denoted p informal semantics fnpgs hiding usual general parallel composition operator removed language distinction approach denotational matrix semantics given rather usual operational semantics using approach infinitesimal generator matrix ctmc constructed directly moreover rettelbach siegle show transition matrix resulting semantics minimal respect markov chain lumpability ie matrices subsets equivalent states disadvantages approaches require modeller adhere new set combinators form cooperation allow different synchronisation sets amongst replicas component techniques appear automated contrast algorithm works transparently pepa language taking advantage whatever symmetries present model submitted pepa workbench user 7 conclusions work shown existence isomorphisms terms derivation graph stochastic process algebra model exploited aggregate state space model algorithm collapses derivation graph model state require costly computation bisimulation equivalence components model found applicable situations full derivation graph large even generated 20 believe many models occur practice would contain symmetries types exploited isomorphism however advantages algorithm cannot guaranteed achieve maximum possible aggregation models generating aggregated derivation graph allow speedier computation steady state probability distribution ctmc corresponds pepa model discussed paper influence aggregation interpretation probability distribution terms given pepa model examining steady state distribution order determine performance factors throughput utilisation pepa modeller must select sets model states interest via description canonical representatives state space added reason choosing aggregate isomorphism instead bisimulation formation canonical representative isomorphism class simpler however full investigation issue remains work work influenced earlier work swn 21 however stress significant adjustments approach necessary development algorithm spa straightforward translation results nevertheless feel considerable benefit gained studying relationship formalisms objective importing ideas appropriate techniques one acknowledgements collaboration took place within project rom889949 enhanced toolset performance engineers funded british council murst stephen gilmore supported distributed commit pro tocols grant epsrc esprit working group fireworks jane hillston supported esprc compa grant authors would like thank anonymous referees helpful comments earlier version paper thank graham clark implementation work pepa workbench r compositional approach performance modelling stochastic process algebras tutorial empa theory concurrent processes nondeterminism compositional markovian modelling using process alge bra pepa workbench tool support process algebra based approach performance modelling compositional performance modelling tipptool finite markov chains spa models programs aggregation techniques stochastic petri nets stochastic process algebras stochastic wellformed coloured nets symmetric modelling applications performance analysis using stochastic petri nets stochastic wellformed coloured nets multiprocessor modelling applications reduced base model construction methods stochastic activity networks compositional nets compositional aggregation stochastic process algebras tool performance dependability modelling exploiting symmetries stochastic process algebras compositional minimal semantics stochastic process algebra tipp investigating online auction system using pepa wellformed coloured nets symbolic reachability graph tr ctr stephen gilmore jane hillston leila kloul marina ribaudo pepa nets structured performance modelling formalism performance evaluation v54 n2 p79104 1 october marco bernardo nadia busi marina ribaudo integrating twotowers greatspn compact net semantics performance evaluation v50 n23 p153187 november 2002 salem derisavi peter kemper william h sanders tod courtney mbius statelevel abstract functional interface performance evaluation v54 n2 p105128 1 october daniel deavours graham clark tod courtney david daly salem derisavi jay doyle william h sanders patrick g webster mbius framework implementation ieee transactions software engineering v28 n10 p956969 october 2002 david nicol william h sanders kishor trivedi modelbased evaluation dependability security ieee transactions dependable secure computing v1 n1 p4865 january 2004
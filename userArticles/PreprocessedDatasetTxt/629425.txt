generalized algorithm parallel sorting product networks abstractwe generalize wellknown oddeven merge sorting algorithm originally due batcher 2 show generalized algorithm applied sorting product networksif g arbitrary factor graph n nodes rdimensional product contains nr nodes algorithm sorts nr keys stored rdimensional product g or2fn time fn depends g show factor graph g fn establishing upper bound or2n time complexity sorting nr keys product networkfor product networks bounded r eg grids leads asymptotic complexity sort nr keys optimal several instances product networks factor graphs fnorm log2n leads asymptotic running time orm log2n sort nr keys networks bounded n eg hypercube asymptotic complexity becomes or2we show apply algorithm several cases wellknown product networks well others introduced recently compare performance algorithm wellknown algorithms developed specifically networks well others result comparisons led us conjecture proposed algorithm probably best deterministic algorithm found terms low asymptotic complexity small constant b introduction recently increasing interest product networks literature partly due elegant mathematical structure product networks partly due fact several wellknown networks hypercubes grids tori instances family product networks many instances product networks proposed recently products de bruijn networks 9 28 products petersen graphs 25 meshconnected trees 8 products complete binary trees general class routing properties product networks studied 4 10 topological embedding properties product networks analyzed 9 papers aside general study algorithms important class networks paper makes attempt towards filling gap presenting generalized sorting algorithm product networks first version algorithm presented well generalized algorithms several different problems proposed 11 expect researchers eventually develop variety additional algorithms product networks 2 batcher presented two efficient sorting networks algorithms derived networks presented number different parallel architectures like shuffle exchange network 30 grid 22 31 cubeconnected cycles 27 mesh trees 24 one batchers sorting networks main components subnetworks sort bitonic sequences bitonic sequence concatenation nondecreasing sequence keys nonincreasing sequence keys rotation sequence sorting algorithms based method generally called bitonic sorters several papers devoted generalizing bitonic sorters 3 17 21 23 main components sorting network proposed batcher 2 subnetworks merge two sorted sequences single sorted sequence called oddeven merging networks several papers generalized network merging k sorted sequences k 2 generally called kway merging networks examples green 12 constructed network based 4merge drysdale young tseng lee 32 parker parberry 26 lisza batcher 20 lee batcher 16 constructed networks based multiway merging similarly algorithms based multiwaymerge concept presented commonly known leightons columnsort algorithm 19 initially objective algorithm show existence boundeddegree onnode networks olog n time network permutations phase hardwired sortings done aks networks limits applicability practical purposes however aggarwal huang 1 showed possible use columnsort basis apply recursively parker parberrys network cited also based modification columnsort algorithms behave nicely number keys large compared number processors paper develop another multiwaymerge algorithm merges several sorted sequences single sorted sequence keys multiwaymerge operation derive sorting algorithm show use approach obtain efficient sorting algorithm homogeneous product network basic spirit multiwaymerge algorithm somehow similar recent version columnsort 18 page 261 although developed independently outperforms columnsort due fundamental differences interpretation basic concept first algorithm based series merge processes recursively applied columnsort based series sorting steps time use sorting n 2 keys columnsort hand uses several recursive calls order merge second observing fundemental relationships structural properties product networks definition sorted order able avoid routing steps required columnsort algorithm among main results paper show time complexity sorting n r keys n r node rdimensional product graph bounded 2 n also illustrate special cases product networks running times 2 olog 2 n sort n r keys grid meshconnected trees 8 9 bounded number dimensions algorithm runs asymptoticallyoptimal time rdimensional hypercube algorithm asymptotic complexity 2 batcher oddeven merge sorting algorithm hypercube 2 although asymptotically faster sorting algorithms hypercube 6 practically useful reasonable number less 2 20 keys 18 note however randomized algorithms perform better hypercubic networks batcher algorithm practice 5 adaptation approaches product networks appears interesting problem future research products de bruijn networks 9 28 approach yields asymptotic complexity 2 log 2 n time sort n r keys reduces olog 2 n time number dimensions fixed running time obtained products shuffleexchange networks also products shuffleexchange networks equivalent computational power ie asymptotic complexity algorithms products de bruijn networks 9 running time asymptotic complexity sorting n r keys n r node de bruijn shuffleexchange network batcher algorithm finally summarize main contributions paper effectively implement sorting algorithm homogeneous product networks ffl obtain generalized upper bounds running time required sorting homogeneous product network regardless topology factor network used build ffl show several important instances homogeneous product networks upper bound derived matches running time mostpopular algorithms developed specifically networks paper organized follows section 2 present basic definitions notation used paper section 3 present multiwaymerge algorithm show use sorting section 4 show implement multiwaymerge sorting algorithm homogeneous product network analyze time complexity section 5 apply algorithm several homogeneous product networks obtain corresponding time complexity conclusions paper given section 6 figure 1 recursive construction multidimensional product networks factor twodimensional product c threedimensional product definitions notation 21 definitions notation relating product networks let g nnode connected graph define rdimensional homogeneous product follows given graph g vertex set arbitrary edge set eg rdimensional homogeneous product g denoted pg r graph whose vertex set v whose edge set e pgr defined follows two vertices adjacent pg r following conditions true 1 x differ exactly one symbol position 2 differing symbol index paper assume rtuple label node pg r indexed 1 delta delta delta r 1 referring rightmost position index r referring leftmost position index intuitive level construction pg r pg g described referring figure 1 let x node pg rgamma1 let g rgamma1 graph obtained prefixing every vertex x pg rgamma1 u vertex x becomes ux first place vertices pg rgamma1 along straight line shown figure 1 draw n copies pg rgamma1 vertices identical labels fall column next extend vertex labels obtain g rgamma1 finally connect columns interconnection pattern factor graph g ux connected u 0 x u construction use g rgamma1 refer uth copy pg rgamma1 explicitly stated fact g rgamma1 uth copy dimension r extend notation allow us add new symbol position vertex labels purpose use g mean vertex labels pg extended inserting value u position result symbol position j moves position allows us observe construction preceding paragraph could restated g position leftmost position conversely obtain g subgraphs erasing dimensioni edges pg r process repeated recursively described simple extension notation use u vpg ij rgamma2 refer subgraphs isomorphic pg rgamma2 obtained erasing connections dimensions j pg r particular subgraph obtained distinguished unique combination u v values index positions j respectively notation similarly extended erasing arbitrary number dimensions order values square brackets corresponds order superscripts 22 definition properties sorted order arbitrary factor graph g vertex labels 0 define ascending order data sorted however need define order nodes pg r determine final location sorted keys order defined known snake order rdimensional product graph pg r 1 snake order corresponds order used labeling nodes g 2 r 1 suppose snake order already defined pg rgamma1 g r order pg rgamma1 u even reverse order u odd b value g r precedes value vp g r snake order product graphs closely related graycode sequences fundamental property two consecutive terms sequence differ exactly one bit dealing nary symbols instead binary symbols therefore need use nary graycode sequences first recall definition hamming distance hamming weight let z rtuples f0 hamming distance z ds absolute value hamming weight rtuple allow one elements rtuples special symbol defined later symbols rtuple symbol index position omitted whenever rtuple involved computation hamming distances hamming weights say sequence q r nary graycode sequence order r elements rtuples f0 two consecutive elements unit hamming distance consequently hamming weights two consecutive terms different parity use rq r denote sequence obtained listing elements q r reverse order definition shows one way construct nary graycode sequences arbitrary order recursively let uq k denote sequence obtained prefixing element q k symbol u u even prefixing element rq k u u odd definition 3 nary graycode sequence order r denoted q r obtained 1 2 concatenation sequences inside curly brackets note q r fact snake order defined vertices rdimensional product network pg r example 3ary graycode sequences order r 112 102 101 100 200 201 202 212 211 210 220 221 222g note q r could defined inserting value u position definition rather leftmost position observation allows us use uq denote subsequence q r contains value u position especially interested subsequences uq 1 1 given u elements subsequence positions u u given observation identity relationship q r snake order nodes pg r follows pg r contains sequence keys sorted snake order keys subgraph g 1 also sorted snake order positions u etc whole sequence consider dividing q r n rgamma1 subsequences n consecutive elements observe definition 3 two elements within subsequence would differ rightmost symbols thus distinguish particular subsequence elements common symbols positions 2 use denote group sequence obtained q r fashion stands 0 example given q 3 group sequence stands 0 1 2 thus explicitly write element g form hamming weight g even form hamming weight g odd moreover two successive elements still unit hamming distance given relation q r pg r element g identifies dimension1 gsubgraph pg r gsubgraph pg r node labels values symbol positions 2 say gsubgraph even resp odd hamming weight corresponding element even resp odd extend notation write q 21 rgamma2 identify set pg 2 subgraphs dimensions f1 2g two consecutive elements q 21 rgamma2 unit hamming distance thus elements q 21 rgamma2 ordered graycode sequence element rgamma2 even odd hamming weight corresponding subgraph said even odd 3 multiwaymerge sorting algorithm section develops basic steps proposed sorting algorithm without regard specific network discussion even matter whether algorithm performed sequentially parallel subsequent sections give implementation details product networks sorted sequence defined sequence keys multiwaymerge algorithm combines n sorted sequences single sorted sequence since case implement algorithm product networks assume power n hence resulting sorted sequence j contain n k keys heart proposed sorting algorithm multiwaymerge operation thus spend much time discussing merging process order build intuitive understanding basic idea merge operation assume keys sorted placed twodimensional block shown figure 2 imply twodimensional organization data product networks implementing algorithm product networks row data containing stored 1dimensional subgraph product graph twodimensional organization figure 2 readers convenience visualizing happens data various steps algorithm use terms row column order refer groups keys subjected step algorithm use terms row column interpreted imply physical organization data two dimensional array subject clarification initially assume sorted sequence different row see figure 2 also assume existence algorithm sort make assumption efficiency algorithm yet section 5 discuss several possible ways obtain efficient algorithms purpose purpose assumption maintain generality discussions independent factor network used build product network show correctness algorithm use zeroone principle due knuth mn figure 2 initial situation merge process starts sorted sequence represented horizontal block row 13 zeroone principle states algorithm based compareexchange operations able sort sequence zeroes ones sorts sequence arbitrary keys 31 multiwaymerge algorithm consider merge n sorted sequences single large sorted sequence initial situation pictured figure 2 merge operation consists following steps 1 distribute keys sorted sequence among n sorted subsequences 1 subsequence b ij form equivalent writing keys n theta n array snake order shown figure reading keys columnwise column j array becomes b ij 1 note subsequence b ij sorted since keys relative order appeared figure 4 illustrates situation completion process n rows contains n sorted subsequences b ij b ij box figure 4 corresponds column keys figure 3 written horizontally example step 2 merge n subsequences b ij found column j figure 4 single sorted sequence c j 1 done parallel columns recursive call multiwaymerge process total number keys column least n 3 number keys column figure 4 n 2 sorting algorithm sequences length n 2 used already assumed existence algorithm recursive call merge process would make much progress n 2 point cleared end section end step write resulting subsequences vertically n columns length situation step illustrated figure 5 mn figure 3 distribution keys among n subsequences b ij thick line represents keys snake order mn figure 4 situation step 1 sequence distributed n subsequences subsequences contains mn elements still sorted figure 5 situation merging subsequences column keys sorted top bottom step 3 interleave sequences c j single sequence sequence formed simply reading theta n array figure 5 rowmajor order starting top row sequence redrawn figure 6 c j sequences figure 5 change organization data figure 6 identical figure 5 except regard one big sequence read rowmajor order prove almost sorted situation shown figure 6 keys sorted take values zero one shaded area represents position zeroes white area represents position ones obtained reading values rowmajor order potential dirty area window keys sorted length larger n 2 fact shown lemma 1 step 4 clean dirty area start dividing sequence mn subsequences n 2 consecutive keys denote subsequences 1 ith subsequence form first n rows keys figure 6 equivalently figure 5 concatenated obtain next n rows concatenated obtain e 2 see figure 7a independently sort subsequences rows figure 7a alternate orders using algorithm assumed available sorting n 2 keys e transformed sequence f see figure 7b f contains keys e sorted nondecreasing order even nonincreasing order odd apply two steps oddeven transposition sequences f ie vertical direction figure 7b first step oddeven trans position pair sequences f f i1 even compared element element two sequences g g i1 formed shown figure g second step oddeven transposition g g i1 rows figure sequence obtained interleaving order goes top bottom reading successive rows left right shaded area filled zeroes white area filled ones boundary area n rows shown lemma 1 odd compared similar manner form sequences h h i1 figure 7c shows situation two steps oddeven transposition finally sort sequence h nondecreasing order generating sequences figure 7d final sorted sequence j concatenation sequences need show process described actually merges sequences use zeroone principle mentioned earlier sorting input sequence zeroes ones sequence obtained completion step 3 sorted except dirty area never larger n 2 proof assume merging sequences zeroes ones let z number zeroes sequence 1 rest keys ones step 1 breaks sequence n subsequences b ij 1 easy observe way step 1 implemented number zeroes subsequence b ij bz 1 therefore given sequences b ij differ number zeroes one start step 2 column j composed subsequences b ij 1 end step 2 zeroes beginning sequence number zeroes sequence c j sum number zeroes b ij fixed j 1 thus two sequences c j differ n zeroes step 3 interleave n sorted sequences sequence taking one key time sequence c j since two sequences c j differ number zeroes n since n sequences interleaved b c f f figure 7 cleaning dirty area length window keys mixture ones zeroes n 2 show last step actually cleans dirty area sequence lemma 2 sequence j obtained concatenation sequences snake order completion step 4 sorted proof know dirty area sequence obtained step 3 length n 2 divide sequence consecutive subsequences dirty area either fit exactly one subsequences distributed two adjacent subsequences dirty area fits one subsequence e k initial sorting oddeven transpositions sequences h contain exactly keys sequences e 1 last sorting sequence h final concatenation sequences yield sorted sequence j however dirty area distributed two adjacent subsequences e k two subsequences containing zeroes ones figure 7a presents example initial situation first sorting zeroes located one side f k side f k1 see figure 7b one two oddeven transpositions affect distribution going move zeroes second sequence first ones first second two steps h k filled zeroes h k1 filled ones see figure 7c therefore one sequence contains zeroes ones combined last step sorting sort sequence entire sequence j sorted see figure 7d 32 need special algorithm n 2 keys reader observe end step 3 dirty area still length n 2 even merging n sequences length n thus make much progress apply multiwaymerge process case fundamental property merge process weakness algorithm difficulty overcome number ways keep running time low depending application area basic idea merge algorithm example interested building sorting network implement subnetworks based recursively updating n smaller value merge sequences length repeat recursion single sequence obtained paper focus developing sorting algorithms product networks assume availability special sorting algorithm designed twodimensional version product network consideration subsequent sections discuss several methods obtain algorithms consider specific product networks efficiency special algorithm important effect overall complexity final sorting algorithm proposed approach cases considered turn resulting running time either asymptotically optimal close optimal number dimensions bounded 33 sorting algorithm using algorithm algorithm sort sequences length n 2 easy obtain sorting algorithm sort sequence length n r r 2 first divide sequence subsequences length n 2 sort subsequence independently apply following process one sequence remains 1 group sorted sequences obtained sets n sequences figure 1 sorting n r keys initially n rgamma3 groups containing n sorted sequences length n 2 2 merge sequences group single sorted sequence using algorithm shown previous section one sorted sequence terminate otherwise go step 1 4 implementation homogeneous product networks mainly focus implementation multiwaymerge algorithm kdimensional product network pg k detail sorting algorithm trivially follows merge operation described initial scenario n sorted sequences stored n subgraphs g k pg k snake order sorting algorithm starts processor holds one keys sorted sorting algorithm processor needs enough memory hold two values compared throughout discussions steps implementation illustrated threedimensional product graph g nodes interconnection pattern g irrelevant discussion step 1 step need computation routing recall section 2 subgraphs u vpg k1 kgamma2 g k contains subsequence keys sorted snake dimension 3 dimension 2 dimension 1 figure 8 initial situation example 3dimensional product graph dimension 1 dimension 3 dimension 2 b dimension 1 dimension 3 dimension 2 figure 9 step 2 multiwaymerge algorithm order positions keys subsequence respect total sorted sequence v therefore sequence b uv already stored subgraph u vpg k1 kgamma2 sorted snake order illustrated figure 8 three sequences merged available snake order three subgraphs formed removing edges dimension3 subgraph 0p g 3 leftmost subgraph figure 8 contains 0 subgraph 1p g 3 center contains 1 subgraph 2p g 3rightmost subgraph contains 2 example b uv contains n keys fit one g subgraph general b uv available snake order u vpg k1 kgamma2 example u vpg 31 really correspond gsubgraphs dimension 2 ie columns figure 8 step 2 step implemented merging together sequences subgraphs u vpg k1 u value one sequence vp g 1 2 merging done directly sorting algorithm pg 2 step done recursive call multiwaymerge algorithm subgraph vp g 1 merges sorted dimension 3 dimension 2 dimension 1 figure 10 step 3 multiwaymerge algorithm sequences stored u vpg k1 subgraphs illustrate step figure 9 clarity first show initial situation figure 9a situation figure 8 dimensions 1 3 exchanged show subsequences merged together explicitly b uv sequences merged together columns figure 9a result merging shown figure 9b c v sorted snake order found subgraph vp g 1step 3 step directly done reintroducing dimension1 connections pg k reading keys snake order pg k graph movement data involved step explicitly show resulting sequence example figure 10 switching dimensions 1 3 figure 9b reader observe figure 10 keys appear close fully sorted order compare figure 10 figure 11d shows final sorted order fact know lemma 1 case sorting zeroes ones left small dirty area implies every key within distance n 2 final position step 4 last step cleans potential dirty area recall 2dimensional subgraphs 2 pg k identified group sequences element g q 21 kgamma2 identifies unique pg 2 subgraph dimensions f1 2g pg 2 subgraphs ordered corresponding group sequence defines snake order subgraphs step independently sort keys subgraphs dimensions f1 2g sorted order alternates consecutive subgraphs subgraph sorted snake order using algorithm assumed available two dimensions result step illustrated figure 11a perform two steps oddeven transposition subgraphs first step keys nodes odd pg 2 subgraphs compared keys corresponding nodes predecessor subgraphs keys exchanged key predecessor subgraph larger figure 11b shows result first step example keys 3 2 nodes 1 2 1 1 2 2 exchanged two keys value 4 nodes 0 2 1 0 2 2 second step oddeven transposition keys nodes even pg 2 subgraphs compared possibly exchanged predecessor subgraphs figure 11c shows result second step figure key 5 node 200 exchanged key 6 node 100 dimension 3 dimension 1 dimension 2 dimension 3 dimension 1 dimension 2 b3 4 4 dimension 3 dimension 1 dimension 2 c dimension 3 dimension 1 dimension 2 figure 11 step 4 multiwaymerge algorithm finally sorting within 2dimensional subgraphs ends merge process figure 11d one point needs examined detail depending graph g nodes holding two keys need compared possibly exchanged may may adjacent pg k g hamiltonian path nodes g labeled order appear hamiltonian path define sorted order g two steps oddeven transposition easy implement since involve communication adjacent nodes pg k however g hamiltonian eg complete binary tree two nodes whose keys need compared may adjacent always common g subgraph case permutation routing within g may used perform compareexchange step follows first two nodes need compare keys send keys depending result comparison node either keep original key keys already correct order drop original key keep new order cover general case computation running time assume g hamiltonian thus implement compareexchange steps using permutation routing algorithms see whether g hamiltonian effects constant terms running time complexity function 41 analysis time complexity analyze time taken sorting algorithm initially study time taken merge process kdimensional network time denoted k n also denote time required sorting pg 2 rn denote time required permutation routing g lemma 3 merging n sorted sequences n kgamma1 keys pg k takes k steps proof step 1 take computation time step 2 recursive call merge procedure dimensions hence take kgamma1 n time step 3 take computation time finally step 4 takes time one sorting pg 2 two permutation routings g steps oddeven transposition one sorting pg 2 therefore value k n recursively expressed initial condition yields derive value r n theorem 1 factor graph g time complexity sorting n r keys pg r proof algorithm section 32 time taken sort n r keys pg r time taken sort 2dimensional subgraph merge blocks n sorted sequences increasing number dimensions expression time follows r never smaller rn time obtained r following corollary presents asymptotic complexity algorithm one main results paper corollary 1 g connected graph time complexity sorting n r keys pg r proof prove claim first compute complexity sorting algorithm rdimensional torus refer result 8 showed g connected graph pg r emulate computation n r node rdimensional torus embedding torus pg r dilation 3 congestion 2 since embedding constant dilation congestion emulation constant slowdown 14 fact slowdown 6 needed g hamiltonian cycle finally use slowdown values compute exact running time pg r compute complexity sorting rdimensional torus basically need sorting algorithm literature sorts n 2 keys twodimensional torus snake order also need algorithm permutation routing nnode cycle example use sorting algorithm proposed kunde 15 complexity also known permutation routing done nnode cycle n2 steps hence sort n r node rdimensional torus 3r gamma 1 steps since emulation algorithm pg r requires slowdown factor 6 arbitrary n r node rdimensional product network sort complexity 5 application specific networks section obtain time complexity sorting using multiwaymerge sorting algorithm presented several product networks literature obtain upper bounds values 2 n rn network using values theorem yield desired running time grid schnorr shamir 29 shown possible sort n 2 keys n 2 node 2dimensional grid 3non time steps also trivial show time perform permutation nnode linear array rn values 2 n rn imply algorithm take 4r gamma 1 steps sort n r keys n r node rdimensional grid number dimensions r bounded expression simplifies algorithm asymptotically optimal r fixed since diameter grid bounded number dimensions value may need travel far diameter network r bounded diameter n r node grid means running time algorithm optimal value factor r meshconnected trees mct network introduced 9 extensively studied 8 obtained product complete binary trees due corollary 1 sort n r node rdimensional meshconnected trees 2 n time steps r bounded running time running time asymptotically optimal r fixed bisection width n r node rdimensional mct rgamma1 shown 8 worst case may need move omegagamma n r values across bisection network r fixed algorithm bisectionbased lower bound factor r 2 diameterbased lower bound used grids help tighten lower bound diameter mct logarithmic number nodes 8 appears interesting investigate possible sort lower running time 2 n r bounded algorithm exists must use completely different approach value 2 n theorem 1 cannot less due bisection width twodimensional mct network hypercube hypercube fixed 2 hard sort snake order twodimensional hypercube 3 steps permutation routing onedimensional hypercube takes one step therefore time sort hypercube algorithm running time running time wellknown batcher oddeven merge algorithm hypercubes fact batcher algorithm special case algorithm petersen cube petersen cube rdimensional product petersen graph shown figure 12 petersen graph contains 10 nodes consists outer 5cycle inner 5cycle connected five spokes product graphs obtained petersen graph studied 25 like hypercube product petersen graphs fixed n therefore way graph grows increasing number dimensions since petersen graph hamiltonian twodimensional product contains twodimensional grid subgraph thus use grid algorithm sorting 100 keys twodimensional product petersen graphs constant time consequently rdimensional product petersen graphs time constant involved small going unreasonably large either may well figure 12 petersen graph possible improve constant developing special sorting algorithm twodimensional product petersen graphs however outside scope paper product de bruijn shuffleexchange networks sort twodimensional instances use embeddings factor networks presented 9 small constant dilation congestion particular n 2 node shuffleexchange network embedded n 2 node 2dimensional product shuffleexchange networks dilation 4 congestion 2 also n 2 node de bruijn network embedded 2dimensional product de bruijn networks dilation 2 congestion 2 sorting n 2 node shuffleexchange de bruijn networks done olog 2 n time using batcher algorithm 30 thus sort n 2 node 2dimensional product shuffleexchange de bruijn network emulation n 2 node shuffleexchange de bruijn network 2 steps using theorem 1 algorithm take 2 log 2 n time steps sort n r keys r bounded expression simplifies olog 2 n r bounded running time algorithm asymptotically running time sorting n r keys n r node de bruijn shuffleexchange graphs batcher algorithm come across interesting open problem see possible sort products networks asymptotically less time unbounded number dimensions 6 conclusions paper presented unified approach sorting homogeneous product networks present algorithm based generalization oddeven merge sorting algorithm 2 obtain 2 n upper bound complexity sorting product network r dimensions n r nodes time taken sorting algorithm grid meshconnected trees bounded number dimensions optimal hypercube algorithm takes 2 reaching asymptotic complexity oddeven merge sorting algorithm hypercube product networks algorithm running time comparable networks instance product de bruijn shuffleexchange graphs running time 2 log 2 n asymptotically running time batcher algorithm n r node shuffleexchange de bruijn graphs theoretical point view interesting investigate better algorithms product networks r bounded several interesting alternatives appear feasible although time investigate instance could try generalize hypercube randomized algorithms product networks r network complexity sorting graph problems simulating crcw prams interconnection networks sorting networks applications bitonic sorting networks unified framework offline permutation routing parallel networks comparison sorting algorithms connection machine cm2 deterministic sorting nearly logarithmic time hypercube related computers improved dividesortmerge sorting network computational properties mesh connected trees versatile architecture parallel computation products networks logarithmic diameter fixed degree general framework developing adaptive faulttolerant routing algorithms homogeneous product networks processor interconnection improvements nonadaptative sorting algorithms searching sorting workpreserving emulations fixedconnection networks optimal sorting multidimensionally meshconnected computers multiway merge sorting network sorting multiple bitonic sequences introduction parallel algorithms architectures arrays tight bounds complexity parallel sorting modulo merge sorting network generalized bitonic sorting network bitonic sort meshconnected parallel computer kway bitonic sort efficient vlsi networks parallel processing based orthogonal trees folded petersen network new communication efficient multiprocessor topology constructing sorting networks ksorters cubeconnected cycles versatile network parallel computation productshuffle networks toward reconciling shuffles butter flies optimal sorting algorithm mesh connected com puters parallel processing perfect shuffle sorting meshconnected parallel computer parallel sorting scheme whose basic operation sorts n elements economical construction sorting networks tr ctr yuhshyan chen chihyung chang tsunghung lin chunbo kuo generalized faulttolerant sorting algorithm product network journal systems architecture euromicro journal v51 n3 p185205 march 2005 shanchyun ku biingfeng wang tingkai hung constructing edgedisjoint spanning trees product networks ieee transactions parallel distributed systems v14 n3 p213221 march
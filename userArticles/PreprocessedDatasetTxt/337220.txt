three approximation techniques astral symbolic model checking infinite state realtime systems astral highlevel formal specification language realtime systems structuring mechanisms allow one build modularized specifications complex realtime systems layering based upon astral symbolic model checler reported 13 three approximation techniques speedup model checking process use debugging specification presented techniques random walk partial image dynamic environment generation ten mutation tests railroad crossing benchmark used compare performance techniques applied separately combination test results presented analyzed b introduction astral highlevel formal specification language realtime systems includes structuring mechanisms allow one build modularized specifications complex systems layering 9 successfully used specify number interesting realtime systems 1 2 9 10 11 12 astral software development environment sde 20 22 integrated set design analysis tools includes among others explicitstate model checker symbolic model checker mechanical theorem prover explicitstate model checker 12 22 generates customized c code specification enumerates branches execution implementation system time bound set user symbolic model checker 13 tests specifications process level requires limited input set constant values model checking procedure uses omega library 23 perform image computations execution tree astral process trimmed execution graph process 13 symbolic model checker used test railroad crossing benchmark experiments model checker aborted completion two test cases due extremely large size specification instances model checkers astral sde intended used debugging purposes reasonable use lower approximation techniques allow search procedure complete still remaining effective finding violations although lower approximation techniques calculate subset reachable states techniques cause false negativities properties specified using astral essentially safety properties paper three techniques meet need introduced random walk partial image dynamic environment generation idea random walk techniques partial image techniques new although aware use symbolic model checking name random walk borrowed theory stochastic processes technique used allow model checker randomly skip number branches traversing execution tree partial image technique inspired sampling random testing methods 16 15 software testing ever instead picking single sample domain partial image technique selects subset image uses subset calculate postimage node dynamic environment generation technique 14 generates different sequence imported variable values different execution paths similar idea colby godefroid jagadeesan 8 address problem automatically closing open system components present approach targets concurrent programs written c based upon static analysis program translate selfexecutable closed form considering realtime specifications approach presented paper dynamically selects reasonable environment according imported variable clause previous environment reason considering previous environment stated later astral historydependent specification lan guage case study ten mutation tests 21 railroad crossing benchmark used show effectiveness finding bugs performance model checker compared three approximation techniques used separately combination 4 5 bultan used omega library tool symbolically represent set states characterized presburger formula also investigated partitions approximations order calculate fixed points work reported paper bultan worked infinite state systems however systems bultan considered simple following sense 1 quantifications limited small number 2 transition system straightforward history independent transition system ie current state depends upon last state history references allowed 3 transition system realtime system sense duration attached transition start end times allowed referenced unfortunately typical astral specification benchmark considered paper simple complex systems fixed point may even exist however astral symbolic model checker primarily intended used debugger instead verifier calculating fixed point transition system important issue therefore bultans approaches considered orthogonal approaches presented paper model checker considered paper modular ized one need check one process instance process type declared without looking transition behaviors process instances step system also uses modularized approach 7 6 however step primarily uses theorem prover validate property approach presented uses fully automatic model checker remainder paper organized follows section 2 brief overview astral specification language presented along introduction astral modularized proof theory section 3 astral symbolic model checker three approximation techniques presented section 4 gives results using techniques separately combination ten mutation tests analyzes results finally section 5 conclusions drawn work future areas research proposed 2 overview astral railroad crossing specification used benchmark example throughout remainder paper system description taken 19 consists set railroad tracks intersect street cars may cross tracks gate located crossing prevent cars crossing tracks train near sensor track detects arrival trains track critical requirements system whenever train crossing gate must train sensors crossing reasonable amount time gate must complete astral specification railroad crossing system found httpwwwcsucsbedudang astral system specification includes global specification process specifications global specification contains declarations process instances global constants nonprimitive types may shared process types system level critical requirements process specification process type declared global specification process specification consists sequence levels highest level abstract view process specified processes constants variables types global specification begins process type declaration processes gate gate sensors array 1n tracks sensor declaration indicates one process instance type gate n tracks process instances type sensor system n tracks global constant type pos integer astral primitive types include integer real boolean id time additional types declared using typedef construct instance pos integer defined follows pos integer typedef integer 0 process instance unique identifier type id astral specification function idtypei represents type process identifier instance global declaration sensor id typedef id idtypeisensor represents identifiers process instances type nsor railroad crossing specification two process specifications gate sensor correspond two process types declared global specification process specification includes interface section specifies imported variables types transitions constants either global specification exported processes used process variables transitions exported process astral global variables therefore variables well local constants must declared process specification astral supports modularized design principle every variable associated unique process instance changes variable caused transitions specified process instance discussed next subsection transitions astral computation model defined execution state transitions specified inside process specifications transition process instance change variables specified instance body astral transition includes pairs entry exit assertions nonzero duration associated pair entry assertion must satisfied time transition starts whereas exit assertion hold time indicated duration transition fires example process gate transition transition raising end raise raise time specifies gate fully raised rising reasonable amount time raise time startt endt specify last start end time transition starttt endtt predicates used indicate last start end transition occurred time transition instance fired entry assertion satisfied transition process instance executing execution transition instance completed duration indicated transition specification instance dur exported transition must called external environment order fire callt used indicate time call exported transition made astral broadcasts variable values instantaneously time execution finishes process instances may refer variables well start end times transitions assumption variables transitions explicitly exported process instances properly import case one transition instance enabled inside process instance transition executing one enabled transitions nondeterministically chosen fire inside process instance executions transitions nonoverlapping interleaved process stances maximal parallelism supported thus execution transition instances different process instances truly concurrent assumptions critical requirements besides transitions requirement descriptions also included part astral specification comprise axioms initial clauses imported variable clauses environmental assumptions critical require ments axioms used specify properties constants initial clause defines system state startup time imported variable clause defines properties imported variables satisfy stance patterns changes values imported variables timing information transitions exported processes environment clause formalizes assumptions must hold behavior environment guarantee desired system properties typically describes pattern invocation exported transitions critical requirements include invariant clauses schedule clauses invariant expresses properties must hold every state system reachable initial state matter behavior external environment schedule expresses additional properties must hold provided external environment processes system behave assumed ie specified environmental assumptions imported variable clauses invariants schedules safety properties astral rich language strong expressive power detailed introduction astral formal semantics reader referred 9 10 22 modularized proof theory paper modularization means principle system specification broken several loosely independent functional modules although high level specification languages support modularization module specification syntactical module languages provide way write specification several modules however often way verify correctness process without looking behaviors processes ultimate goal modularization partition large system conceptually func tionally several small modules verify small module instead verifying large system whole greatly eases verification design work astral process instance considered module provides interface section including imported variable clause astral wellformed formula regarded abstraction behaviors processes unique feature astral helps develop modular verification theory realtime systems example verifying schedule invariant process instance uses processs local assumptions behaviors thus verifying local invariant uses behaviors transitions process instance verifying local schedule uses processs local environment imported variable clause plus behaviors processs transitions finally imported variable clause must correct assumption needs verified combining invariants process instances global level global invariant astral specification verified using invariants process stances without looking details process instances behavior similarly global schedule verified using global environment schedules process instances due page limita tions astral proof theory presented detail paper interested reader see 10 3 approximation techniques astral symbolic model checker section overview astral symbolic model checker given along motivation introducing approximation techniques next techniques formulated detail overview astral symbolic model checker prototype implementation astral symbolic model checker nontrivial subset astral given 13 prototype uses omega library 23 tool symbolically represent set states characterized presburger formula arithmetic formula integer variables built logical connectives quantifiers omega library provides rich operations omega sets lations join intersection projection operations used image computations symbolic model checker symbolic model checker presented paper implemented process level model checker based upon modularized astral proof theory process type globally declared one needs check one process instances critical requirements astral process declaration p translated labeled transition system consists set q infinitely many states finite set transitions name sigma sigma consists transition names declared p well two special transitions idle initial relation q ie q theta q init q denotes initial states assumption assump property prop also subsets states q restricted form components q presburger formu las usual set states r q one denote preimage p r transition set states state r reached transition p postimage p ost r transition set states reachable state r transition p ost semantics characterized runs q 0 correct respect specification run following condition satisfied k fq initial lower raise figure 1 execution graph gate initial lower raise idle lower idle idle figure 2 execution tree gate model checking procedure starts constructing execution graph g p graph g represents transition declared p initial indicates initial transition defined identity transition initial states zero dura tion idle newly introduced transition duration one idle fires every firable transition currently executing idle change values local variables rg vg thetav g excludes pairs transitions second transition immediately firable first one finishes g automatically constructed using omega library analyzing initial conditions entry exit assertions astral transition process figure 1 example execution graph gate process railroad crossing specification dashed arrow figure 1 means zero idle transitions executed reach next node model checking procedure carried tree possible execution paths trimmed execution graph g figure 2 part execution tree gate process starting initial node initial execution tree p model checker calculates image reachable states every node along path userassigned search depth image checked assumption assump property prop order detect potential errors number techniques also used dynamically resolve values variables according path searched techniques reduce number variables used actual image calculation whenever error found model checker generates concrete specification level trace leading error three approximation techniques subsection three approximation techniques presented speed astral symbolic model checker techniques random walk partial image dynamic environment generation motivation introducing approximation techniques mentioned earlier astral symbolic model checker performs process level model checking checking one process instance process type declared global system correctness ensured modularized proof theory tral without looking global behaviors entire system performance model checker greatly increased since dealing single process instance much easier however mean single process instance necessarily simple 13 model checker used test railroad crossing benchmark experiments model checker failed complete two test cases due extremely large size instances high complexity single process instance come two sources local global constants used instance local imported variables constitute variable portion process instance example gate process 10 global constants 6 local constants constants used parameterize specified system eg specify system containing parameterized number process instances well system containing parameterized timing requirements local variables contribute local state changed executing transitions though process astral modularized process instance stand alone environment assumption typically used characterize pattern invocations calls exported transitions outside environment process instance may also interact process instances imported variables exported process instances since processs local properties proved using local assumptions process instance must specify strong enough assumptions environment clause imported variable clause correctly characterize environment behaviors imported variables order guarantee local properties unusual assumption include complex timing requirements call patterns imported vari ables change patterns thus second source complexity primarily comes historydependency astral expresses systems current state depends upon past states practical symbolic model checker complete search procedure complex process instance desirable define approximation approaches speed procedure sacrificing cov erage based upon analysis two kinds approaches used first assign concrete values constants using model checker 13 shown speed model checker still effective finding bugs cases however reasons using approach first picking right set constant values cause interesting things especially potential errors happen trivial constant value choices miss scenarios specification would fail second even number constant values fixed model checker still expensive cases due complexity behavior local imported variables experience shows approach well using explicit state model checker 12 used earlier stages debugging specification errors relatively easier catch second approach speeds model checker enforcing check either less nodes small nodes approaches free user setting constant values random walk technique used allow model checker randomly skip number branches traversing execution tree approximations also applied limiting image size reachable states node execution tree currently two techniques provided image size reduction one partial image considers subset image uses subset calculate postimage node dynamic environment generation 14 generates different sequences imported variable values different execution paths reduces image size node restricting environment primar ily imported variable part process instance three techniques discussed details following subsections random walk path execution tree astral process sequence transitions node tree containing image reachable states initial node along path theoretically number paths exponential userassigned search depth even though symbolic model checker adopts number trimming techniques 13 time complete search large specification unaffordable experience specification bug bug usually demonstrated many different paths reasons 1 ordering transitions switched without affecting result though practically hard detect since astral history dependent 1 2 specifications contain number parameterized constants specification bug usually numerous scenarios choices parameterized constant values demonstrate scenarios shown many different paths random walk approximation technique searching portion reachable nodes execution tree figure 3 shows recursive procedure based upon depthfirst search algorithm similar procedure proposed 13 except algorithm includes random choice model checker moves one node children al gorithm depth indicates maximal number iterations transitions check p ost defined earlier postimage operator transition indicated node model checking node starts calculating preimage postimage postimage empty means transition firable preimage checked respect property followed checking every child node according execution graph 2 result random boolean function tossa b function toss symmetric probability result tail chosen depth depth numchildrena indicates number successors node execution graph g ie indicates layer node located execution tree reason choice ensure 1 significantly different standard techniques used finite state model checking partial order method 18 2 actual implementation idle nearest nonidle ancestor node 0 nonidle child node b ha 0 bi 62 rg checked nonidle child reachable closest nonidle ancestor execution graph checked ffl short violation less chance miss alayer small probability result tail large alayer large numchildrena greater 1 probability small hence longer path higher probability skipped ffl numchildrena 1 3 probability result tail 1 node one successor skipped model checking procedure starts initial node initial checkinitial depth boolean checknode int depth f depth return true else apostimage ifapreimage 6 prop return false else foreach b ha bi 2 rg tossa return true figure 3 model checking algorithm random walk partial image omega library image represented union convex linear constraints efficiency image calculation depends upon number variables number constraints experience shows specification bug usually numerous sets parameterized constant variable values lead bug values usually satisfy many constraints image thus considering part image usually still let model checker find bug reported 13 fixing number parameterized constant values increases speed model checker since number variables image decreased special case partial image technique however finding right set constant values leading potential bug easy complex specifications usually requires user thoroughly understands specification partial image technique presented paper used without fixing constant values applying partialimage opera tor returns half unions image algorithm presented figure 4 essentially one 13 except depth first search partialimage operator applied preimage node reduced preimage represents 3 numchildrena always least one since node successor idle transition set reachable states node approximated image used calculate postimage node stated algorithm previous experiments 13 two test cases symbolic model checker failed complete search procedure due extremely large size instance large number constants variables used test cases resulted extremely long time hours observed 13 single image computation represented omega library computations usually involve images containing hundreds even thousands unions convex regions thus natural cut image size reachable states node always sound astral symbolic model checker astral safety bounded liveness properties specified boolean checknode int depth f depth return true else apostimage ifapreimage 6 prop return false else foreach b ha bi 2 rg return true figure 4 model checking algorithm partial image dynamic environment generation dynamic environment generation technique used paper proposed detail 14 astral history dependent specification language technique needed encode history imported variable past values referenced since pointed 13 costly encode entire history therefore limited window size technique proposed paper approximate entire history part example window size two means process instance remember imported variables last two change times values changes observed 14 imported variables history encodings main bottleneck symbolic model checker due extra variables introduced imported vari able thus environment characterized imported variables histories inside given win dow every variable environment concrete value environment called concrete dynamic environment generation technique effectively generates reasonable sequence concrete environments execution path sequence selected according imported variable clause previous environment reader referred 14 details algorithm techniques used combination three techniques mentioned also used combination straightforward manner exam ple random walk partial image combined way model checker propagates part reachable states children nodes randomly skips number branches random walk dynamic environment generation also work together along randomly chosen execution path sequence concrete environments generated similarly partial image dynamic environment generation applied part image reachable states used calculate postimage also used generate concrete environments following section results running ten mutation tests gate process using model checker techniques combinations presented performance comparisons case study three approximation techniques integrated astral symbolic model checker since use symbolic model checker astral sde debugging purposes effectiveness detecting potential error specification major concern demonstrate effectiveness approximation techniques proposed last section model checker run ten mutations 21 gate process railroad crossing specification reason gate process specification used contains imported variables well histories imported variables result large instance gate process symbolic model checker previously failed complete 13 using approximation techniques mutation contains minor change original specification 4 detailed list mutations found table 1 pointed 21 mutation techniques used two ways formal specifications help user understand specification test strength specification experience shows realtime specifications hard write read especially involve complex timing con straints user mutate part specification believes change affect behavior system mutant killed ie violation found specification level violation trace demonstrated reading trace 4 unmutated railroad crossing specification proved correct using astral theorem prover also part astral sde 22 helps user quickly figure syntax change affects specification mutation created weakening assumption specification model checker fails find violations potential weakness demonstrated original spec ification two possibilities case one model checker able find bug specific run specific setup mutation equivalent original correct specification m1 delete 1st conjunction axiom gate m2 delete 2nd conjunction axiom gate m3 delete 3rd conjunction axiom gate m4 delete term raise dur 2nd conjunction axiom gate m5 delete term dur 3rd conjunction axiom gate m6 delete nowchangestrain rrimaxresponse time 1st conjunction schedule gate m7 delete imported variable clause gate m8 delete nowendlowerlower time entry assertion transition m9 delete nowendraiseraise time entry assertion transition delete positionraising positionraised entry assertion transition raise table 1 ten mutations railroad crossing specification tests constants min speed speed set 15 20 respectively constant tracks set 2 history window size chosen 2 userassigned con stants maximal search depth 10 reason n tracks window size chosen 2 setting demonstrates effectiveness model checker extremely large instance specification table 2 table 3 show results three approximation techniques used separately used combination respectively tables result contains number nodes visited execution tree time taken measured seconds result status status values theta ie model checker able detect violation ie model checker finishes reports error ie model checker fails finish reasonable amount time number also attached status value indicate actual number runs specific tests performed example theta2 means violation found second run within first run error detected case number nodes time taken sum two runs case two trials made m3 m5 m8 m9 model checker ran reason model checker report errors cases discussed comparison mutations also run using earlier symbolic model checker use approximation techniques results runs shown column plain table 2 tests performed sun ultra 1 64m main memory 124m swap memory noted experiments independent run model checker cache cleaned 5 therefore performances different runs comparable observed 14 among ten mutations m8 m9 correct hence model checker report error cases m3 m5 two cases demonstrate limitation symbolic model checker fails detect error although mutations killed 14 explicit state model checker 12 used successively find violations set constant values provided specifier test results live mutants still meaningful used show node coverage approximation technique model checker completes search procedure remaining six mutations ones model checker able kill used demonstrate effectiveness using model checker debug specification number observations made results shown table 2 table 3 first run six mutations killed using partial image dynamic environment generation separately second run partial image combined dynamic environment generation also able kill six muta tions random walk either applied separately combined two techniques able kill six mutations m6 m7 m10 show relatively short violation traces m1 m2 m4 show long violation traces therefore interested latter three cases first run random walk able kill three mutations average second run however could kill m1 three uses time used finding error 2 4 times faster average time without using approximation techniques even error detected second run total time used two runs still 2 times faster average one also notice using techniques combination could speed procedure though ratio especially high occasion worse reason using techniques combination sacrifices coverage therefore less chance detecting error first run consider results live mutants m3 m5 m8 m9 mentioned mutations random walk least node coverage especially applied combination two techniques contrast partial image dynamic environment generation much cleaning cache 4 10 times speed usually observed however noticed approximation techniques used paper also degrade cache performance partial image dynamic env random walk plain cases nodes time result nodes time result nodes time result nodes time result m4 28 1694 theta1 23 1726 theta1 104 5069 p 2 23 10168 theta1 1 91 3173 p table 2 experiments approximation techniques used separately cases nodes time result nodes time result nodes time result table 3 experiments approximation techniques used combination higher node coverage even applied combina tion however unknown total number reachable nodes since symbolic model checker failed complete searching procedure four mutations analysis one conclude approximation approaches effective able kill least half mutations much shorter time first run finish procedure reasonable amount time live mutants specific set tests partial image dynamic environment generation effective fast detect error error reported attain high node coverage random walk performs slightly worse two tech niques reason random walk didnt reach high node coverage shown results live mutations along execution path image calculations still expensive since node must propagate full reachable image however compared model checker without approximation techniques performance detecting violation still much faster 5 conclusions future work paper three approximation techniques using astral symbolic model checker specification debugger introduced techniques random walk partial image dynamic environment genera tion random walk technique used allow model checker randomly skip number branches traversing execution tree partial image technique considers subset image uses subset calculate postimage node dynamic environment generation technique 14 generates different sequences imported variable values different execution paths three techniques applied separately combination ten mutation tests gate process railroad crossing benchmark specification techniques effective finding bugs besides techniques discussed paper believe many applicable approximation approaches unlike model checkers astral model checker primarily intended use specification debugger fixed point computation question numerous approximation techniques already exist testing area also investigated believe techniques proposed paper also useful model checkers using different specification languages long safety properties considered debugging general temporal property formulated temporal logic still unknown well approximation approaches work area research coverage analysis paper empirical factors considered time number nodes another issue investigated metrics used systematically measure path andor node coverage specific approximation technique applied execution tree challenging topic since sometimes symbolic model checker without using approximation techniques fails complete entire search therefore theoretical estimation urgently needed authors would like thank bultan p kolano many insightful discussions ten mutations tested paper created result discussions among bultan p kolano authors well paper written specification written p kolano r hybrid specification control systems hardware specification using assertion language astral verifying systems integer constraints boolean pred icates composite approach symbolic model checking infinite state systems using presburger arithmetic model checking concurrent systems unbounded integer variables symbolic representations approximations experimental results deductive verification realtime systems using step step deductivealgorithmic verification reactive realtime systems auto matically closing open reactive programs specification realtime systems using astral formal framework astral intralevel proof obligations using astral model checker cryptographic protocol analysis using astral model checker analyze mobile ip symbolic model checker testing astral realtime specifica tions dynamic environment generations astral process report random testing quantifying software validity sampling model checking programming languages using verisoft partial approach model checking generalized railroad crossing case study formal verification realtime systems proof assistance realtime systems using interactive theorem prover mutation tests astral realtime spec ifications design analysis realtime systems using astral software development environment omega test fast practical integer programming algorithm dependence analy sis tr partial approach model checking model checking programming languages using verisoft specification realtime systems using astral verifying systems integer constraints boolean predicates automatically closing open reactive programs using astral model checker analyze mobile ip modelchecking concurrent systems unbounded integer variables design analysis realtime systems using astral software development environment formal framework astral intralevel proof obligations symbolic model checking infinite state systems using presburger arithmetic deductive verification realtime systems using step proof assistance realtime systems using interactive theorem prover report random testing symbolic model checker testing astral realtime specifications dynamic environment generations astral process ctr bernard boigelot louis latour counting solutions presburger equations without enumerating theoretical computer science v313 n1 p1729 16 february 2004 zhe dang tevfik bultan oscar h ibarra richard kemmerer past pushdown timed automata safety verification theoretical computer science v313 n1 p5771 16 february 2004 zhe dang oscar h ibarra richard kemmerer generalized discrete timed automata decidable approximations safety verification theoretical computer science v296 n1 p5974 4 march
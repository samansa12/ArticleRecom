continuationbased multiprocessing multiprocessing facility must include three features elementary exclusion data protection process saving elementary exclusion must rest hardware facility eg testandset instruction two requirements fulfilled features already present applicative languages data protection may obtained use procedures closures funargs process saving may obtained use catch operator use catch particular allows elegant treatment process savingwe demonstrate techniques writing kernel modules multiprocessing system kernel small many functions one would normally expect find inside kernel completely decentralized consider implementation schedulers interrupts implications ideas language design b introduction past years researchers made progress understanding mechanisms needed wellstructured multiprocessing facility seems universal agreement following three features needed 1 elementary exclusion 2 process saving 3 data protection elementary exclusion mean device prevent processors interfering others access shared resources typically elementary exclusion may programmed using test set instruction create critical region critical regions however adequate describe kinds sharing one wants controlling complex resources disks regions highly structured data bases cases one uses elementary exclusion control access resource manager eg monitor 11 serializer 1 turn regulates access resource unfortunately access manager may become system bottleneck standard way alleviate manager save state processes wishes delay manager acts taking request considering state resource either allowing requesting program continue research reported herein supported part national science foundation grant numbers mcs7506678a01 mcs7904183 paper originally appeared j allen editor conference record 1980 lisp conference pages 1928 palo alto ca 1980 company republished acm current address college computer science northeastern university 360 huntington av enue 161cn boston 02115 usa delaying queue picture manager little computing becomes less bottleneck implement kind manager one needs kind mechanism saving state process making request basic observation paper mechanism already exists literature applicative languages catch operator 14 15 21 25 operator allows us write code processsaving procedures little fuss leaves third problem protecting private data would good monitors user could bypass manager blithely get resource standard solution introduce class mechanism implement protected data applicative language data may protected making local procedure closure idea exploited 19 unjustly neglected revive show gives elegant solution problem demonstrate solution writing kernel modules multiprocessing system kernel small many functions one would normally expect find inside kernel semaphore management 2 may completely decentralized use catch system thus answers one questions 3 providing way drastically decrease size kernel implemented system presented slightly different form using indiana scheme 31 system 26 remainder paper proceeds follows section 2 discuss assumptions system code run sections 3 4 show implement classes processsaving respectively section 5 bring ideas together write kernel multiprocessing system sections 6 7 utilize kernel write scheduling modules system section 8 show treat interrupts last section 9 consider implications work applicative languages 2 model computation fundamental model multiprocessor multiprocess system using shared memory many segments code called processes reside single shared randomaccess memory extent processes actually share memory controlled software several active units called processors execute processes several processors may executing process simultaneously make usual assumption memory access marks finest grain interleaving two processors may access read write sane word memory time elementary memory exclusion enforced memory hardware interface processes processors distinguished process called kernel kernels job assign processes ready run processors idle conventional system eg 22 entails keeping track many things shall see kernel need keep track ready processes may worthwhile discuss authors scheme 31 system provided context work scheme applicativeorder lexicallyscoped fullfunarg dialect lisp 25 scheme 31 system indiana university translates input scheme code code suitable multistack machine machine implemented lisp thus constraint could lisp code since addition would constitute modification machine system simulates multiprocessor system means interrupts using protocol discussed section 8 however primitive operations including application lisp functions uninterruptible allows us write uninterruptible testandset operation de testandsetcar x prog2 nil car x rplaca x nil returns car argument sets car nil two features scheme worth mentioning first scheme uses callbyvalue pass parameters means actual parameter evaluated new conscell allocated new cell pointer evaluated actual parameter planted usual association list implementation pointer cdr field ribcage implementation 24 car pointer may changed use asetq procedure thus write define schemedemo1 x asetq x call schemedemo1 always returns 3 since second asetq changes different cell first one feature applicative languages always rather obscure see 17 sec 185 illuminating discussion second property depend stack actually allocated lisp heap using cons reclaimed using garbage collector allows us quite coding techniques shall say assumption conclusions 3 implementing classes us primary purpose class construct provide locus retention private information simula 6 class instance activation record survive caller applicative language record may constructed environment association list closure funarg idea stated clearly 23 discuss briefly completeness example simple conscell may modelled define conscell x lambda msg cond lambda val asetq x val lambda val asetq val define car x x car define cdr x x cdr define rplaca x v x rplaca v define rplacd x v x rplacd v cons cell function expects single argument depending type argument received cell returns changes either components arbitrarily chosen one several ways behaviorally defined data structures discussed 10 20 23 least one similar object known church 5 cited 24 another example important purposes define busywait let x cons nil labels self lambda msg cond testandsetcar x car rplaca x busywait function arguments called creates new locus busywaiting creating function new private variable x x guaranteed new use callbyvalue returned function denoted self expects single argument either p v calling p sends testandset loop calling v resets car x thus releasing semaphore way access variable x except calls function note advocating busywaiting except perhaps certain special circumstances use busywait rest paper may safely replaced hardwaresupported elementary exclusion device reader may prefer concern build complex schedulers elementary exclusions particular shall consider better ways build semaphore section 6 4 process saving catch catch old addition applicative languages oldest version known author landins called either pp program point 15 jlambda 14 1 reynolds 21 called escape somewhat restricted form catch exists lisp 15 errset 16 another version found maclisp pair catch throw form adopted steele sussmans 25 similar reynolds scheme catch binding operator evaluation expression catch id causes identifier id bound using callbyvalue continuation object described shortly expression expr evaluated extended environment continuation object function one argument invoked returns control caller catch expression control proceeds catch expression returned supplied argument value corresponds notion expression continuation denotational semantics understand use catch may consider examples catch cons returns 3 3 evaluated entire catch expression returned 3 form usually use catch similar define foo evaluation junk causes function foo return caller value junk power catch arises store value invoke point program case caller foo restarted ms argu ment portion program called lost unless preserved strategically placed catch small instance phenomenon happened even first examplethere ms caller cons abandoned calling continuation function thus much like jumping hyperspaceone loses track entirely ones current context reemerge context set continuation actually occurrences catch code write remainder section next shall consider things continuations already created catch get section 6 shall start use catch code shall use continuations represent processes process selfcontained computation may represent process pair consisting continuation argument sent continuation corresponds notion command continuation denotational semantics define consprocess cont arg lambda msg cond defined process class instance two components continuation argument single operation runit causes continuation applied argument thus starting process cont contin uation applying causes control revert place refers caller x runit lost terrible since caller x runit may saved continuation someplace else 5 kernel enough machinery write kernel operating system kernels job keep track processes ready run assign process processor asks one kernel therefore class instance keeps queue processes two operations one add process ready queue one assign process processor thereby deleting ready queue shall need queue manipulation therefore assume function createqueue creates empty queue function addq q x side effect adding value x queue q function deleteq q returns top element queue q sideeffect deleting q may write code kernel define genkernel let readyqueue createqueue mutex busywait lambda msg cond lambda cont arg block mutex p addq readyqueue consprocess cont arg mutex mutex p let nextprocess deleteq readyqueue block mutex v nextprocess runit asetq kernel genkernel define madeready cont arg kernel makeready cont arg define dispatch kernel dispatch defined two basic functions makeready dispatch call makeready cont arg puts process built cont arg ready queue must get past short busywait busywait always short kernel never tied long construction also keeping idea building complex exclusion mechanisms simple ones puts process queue releases kernels exclusion exits given code busywait always returns value returned must pointer private data dispatch subtler processor execute dispatch whenever decides nothing better normally call dispatch would preceded call makeready need case passing semaphore next waiting process deleted ready queue assigned nextprocess mutex v executed nextprocess started sending runit signal subtlety order last two operations cannot reversed since nextprocess started would way reset semaphore given order safe however use callbyvalue every call dispatch uses different memory word nextprocess therefore call nextprocess runit uses shared data may executed outside critical region explanatory words code order first note kernel makeready returns function takes two arguments performs required actions kernel dispatch however performs actions directly could made kernel dispatch return function arguments judged confusing asymmetry second block schemes sequencing construct analogous progn also cond uses socalled generalized cond implicit block progn righthandside alternative 6 two better semaphores function busywait would adequate implementation binary semaphore one sure semaphore never closed long section shall write code two better implementations semaphores first implementation use kernel provide alternative testandset loop testandset fails throw remainder current process ready queue execute dispatch sometimes called spin lock define spinlocksemaphore let x cons nil labels self lambda msg cond cond testandsetcar car rplaca x define giveupandtrylater catch caller block makeready caller key function giveupandtrylater puts readyqueue process consisting caller argument calls dispatch switches processor executing ready process enqueued process restarted processor executing dispatch appear giveupandtrylater quietly returned effect execute delay unknown duration depending state ready queue thus process executing p semaphore knock testandset cell closed process go sleep try later example illustrates use catch makeready probably good implementation semaphore better implementation closer standard one would maintain queue processes waiting semaphore process needs delayed tries p stored queue v executed waiting process may restarted precisely placed ready queue code follows define semaphore let q createqueue queue waiting processes count mutex busywait lambda msg cond mutex p catch caller block cond greaterp count asetq count sub1 count mutex v mutex v mutex p emptyq q asetq count add1 count makeready deleteq q mutex v executing semaphore creates class instance queue q used hold processes waiting semaphore integer count traditional value semaphore busywait locus mutex mutex used control access scheduling code always reopened process passes semaphore suggested introduction use small busywait control entrance sophisticated scheduler typical p executed calling process first must get past mutex critical region critical region count checked greater 0 decremented mutex exclusion released semaphore returns value caller count zero continuation corresponding caller semaphore stored queue mutex released processor executes dispatch find process work v executed calling process first gets past mutex semaphores critical region queue checked see processes waiting semaphore none count incremented least one deleted queue deleteq q put kernels ready queue argument restarted kernel think completed call p since p always returns second argument makeready must likewise bookkeeping accomplished mutex released call v returns typical implementation semaphores eg 2 difference semaphore independent object lies outside kernel way privileged code also written code implement complex schedulers complex scheduler actually written code brinch hansens process 4 written scheme syntactic macro code page long 7 one thing turn important issue process creation although semaphores previous section used catch save state current process provide means increase number processes system may function createprocess createprocess takes one argument function arguments creates process execute function parallel caller createprocess define createprocess fn catch caller block catch process block makeready process caller createprocess called fn first creates continuation containing caller calls caller enters block creates continuation called process started continue execution block fn continuation process put kernels ready queue argument ignored process restarted caller executed causes createprocess return caller value thus process called createprocess continues control pro cessor process put onto ready queue kernel decides run process fn executed processor runs process dispatch find something else reader finds code tricky may take comfort opinion trickiest piece code paper difficulty lies fact execution sequence almost exactly reversed lexical sequence 8 use createprocess implement forkjoin function fork takes two functions arguments result cons values execution two functions proceed two independent processes process called fork delayed return define fork fn1 fn2 catch caller let onedone nil ans1 nil ans2 nil mutex busywait let checkdone lambda dummy block mutex p onedone makeready caller cons ans1 ans2 asetq onedone mutex v block createprocess lambda checkdone asetq ans1 fn1 createprocess lambda checkdone asetq ans2 fn2 fork sets four locals one two answers flag called onedone semaphore control access flag creates two daughter processes dispatches saved caller continuation caller two processes computes answer deposits appropriate local variable calls checkdone checkdone uses mutex obtain access flag onedone initially nil value nil set value signifying current call checkdone second one caller moved ready queue argument cons ans1 ans2 8 interrupts written far quite adequate nonpreemptive scheduling system 2 wish use preemptive scheduling system must wish use single processor must consider handling interrupts shall consider problem preemption processes timing interrupts nonpreempting interrupts handled methods analogous 3 27 model timing interrupt follows processor detects timing interrupt next identifier encountered course computation say x executed replaced preempt x preempt name interrupthandling routine believe 23 function application goto binding model quite close conventional model interrupt causes control pass predefined value program counter similar treatment interrupts developed independently use mitxerox parc scheme chip 12 simplest interrupt handler define preempt x catch caller block makeready caller x interrupt handler process processor executing thrown back ready queue processor executes dispatch find something else complication arises preemptive scheduling interrupts must inhibited inside kernel may accomplished changing busywait kernel kernelexclusion define kernelexclusion let sem busywait lambda msg cond sem p sem v note order operations v reverse order wrong interrupt might occur enablepreemption sem v causing instant deadlock discovered hard way first time introduced operations probably privileged disablepreemption enablepreemption 2 make privileged without changing architecture machine introducing readloop like define userreadloop let disablepreemption lambda error protectionerror enablepreemption lambda error protectionerror labels lambda dummy loop print eval read loop intended suggest users input evaluated environment disablepreemption enablepreemption bound errorcreating func tions actually way code written scheme written way avoid dealing complications schemes version eval 9 conclusions issues paper shown many troublesome portions back end operating systems may written simply using applicative language catch course drawn conclusions three categories operating system kernel design applicative languages language design general operating systems work answers part brinch hansens call simplify kernel 3 scheduling apparatus except ready queue moved kernel kernel becomes smaller called less often therefore becomes less bottleneck passing messages class instances functions instead passing processes avoid need individuation processes thereby avoid need maintain process tables etc reducing size kernel meant imply solved problems associated system kernels problems storage allocation performance addressed areas process saving protection however approach discussed seems offer considerable advantages area applicative languages work seems address issue state module said state different calls module identical arguments may give different results different times computation another way describing phenomenon model historydependent confused issues nondeterminism object state never matter whether two processes dealing object two copies processes communicate however must talking module two copies instance modules must communicate kernel two modules produced calls genkernel therefore kernel similar modules must statethey must uses asetq code seems us important observation means must come grips concept state deal semantics parallelism observation could made context imperative languages every module state applicative context distinguish true state binding internal state could make distinction 3 related issue use callbyvalue detailed semantics scheme incorporating algol callbyvalue mechanism would give unambiguous account two modules thus also give account two modules share state account necessary explain use asetq programs determine data private shared last lines kernel dispatch description would find restarting continuation restores environment map identifiers lvalues undo changes global state map lvalues rvalues altered asetq nonetheless find account unsatisfying systematic introduction global state every procedure call seems quite odds usual statefree picture applicative program find unpleasant say pass parameters worth ie without copying except need think harder program regard commend applicative metaprogrammers closer study denotational semantics descriptive denotational semantics expounded chapter 1 17 9 provides tools give accurate description actually happens parameter passed however measures would help alleviate confusion example could use primitive cell operation place unrestricted use asetq values could passed worth rvalue lvalues would arise denotations cells explicit dereferencing would required approach taken various degrees plasma 10 forth 13 bliss 28 4 also john reynolds one students investigating semantics rely single global state personal communication 5 last essay ideas language design process choice work area applicative languages motivated part minskys call separation syntax semantics programming 18 attempted home essential semantic ideas multiprogramming semantic simply mean ideas expressible denotational semantics though surely use denotational semantics exposed simplified basic ideas programming general add ideas basic operational knowledge one goes semantics implementations eg 21 additional operational knowledge expressed formal semantics eg treatment interrupts firm grasp informal semantic ideas begin consider syntax syntax human engineeringreplacing parentheses positional structure grammars keywords syntax may introduced restrict class runtime structures needed support language design russell 7 good example paradigm one spectacular success may claimed approach pascal took wellunderstood semantics algol introduced syntactic restrictions considerably simplified runtime structure case consider syntactic restrictions allow use sequential structures avoid spending ones time garbagecollecting stack clever data structures runtime stack also considered another syntactic restriction might desirable one would prevent continuation restarted language language proposal must embody tradeoff generality sometimes called functionality efficiency considering complete generality first may readily see tradeoffs may occur lost thereby unfortunately typical approach language design start given runtime structure worse yet syntactic proposal authors realize functionality lacking add introducing patch introducing generality cleanness first compromising efficiency one seems likely produce clean small understandable even efficient languages notes 1 though catch callcc clearly interdefinable j callcc differ importantly details see hayo thielecke introduction landins generalization jumps labels higherorder symbolic computation 112 pp 117123 december 1998 2 additional primitives added scheme 31 interpreter 3 paragraph grew conversations carl hewitt nature object identity objected hewitts notion object identity distributed system required notion global state c hewitt h g baker actors continuous functionals e j neuhold ed formal descriptions programming concepts pages 367390 north holland amsterdam 1978 page 388 issue remains interest generation globallyunique identifiers use large distributed systems ip dcom worldwide web 4 approach course adopted ml time changing scheme way least conceivable seriously considered indiana scheme 84 implementation revised 3 report 1984 radical change became impossible sussman steele list among mistakes design scheme gj sussman gl steele jr first report scheme revisited higherorder symbolic computation 112 pp 5 sure refers best guess refers work oles stack semantics j c reynolds essence algol j w debakker j c van vliet eds algorithmic languages pages 345372 north holland amsterdam 1981 r synchronization actor systems operating systems principles architecture concurrent programs distributed processes concurrent programming concept calculi lambdaconversion hierarchical program structures data types go statement considered harmful denotational description programming languages viewing control structures patterns passing messages monitors operating system structuring concept scheme79 chip forth microcomputers correspondence algol 60 churchs lambdanotation part next 700 programming languages theory programming language semantics form content computer science protection programming languages definitional interpreters higherorder programming languages logical design operating systems lambda ultimate declarative art interpreter revised report scheme scheme version 31 reference manual modula language modular multiprogramming bliss language systems program ming tr ctr edoardo biagioni robert harper peter lee network protocol stack standard ml higherorder symbolic computation v14 n4 p309356 december 2001 manuel serrano frdric boussinot bernard serpette scheme fair threads proceedings 6th acm sigplan international conference principles practice declarative programming p203214 august 2426 2004 verona italy zena ariola hugo herbelin amr sabry typetheoretic foundation continuations prompts acm sigplan notices v39 n9 september 2004
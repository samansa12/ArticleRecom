exponential lower bound 2query locally decodable codes via quantum argument locally decodable code ldc encodes nbit strings x mbit codewords cx way one recover bit xi corrupted codeword querying bits word use quantum argument prove ldcs 2 classical queries require exponential 2n previously known linear codes goldreich et al proceedings 17th ieee conference computation complexity 2002 pp 175183 proof proceeds showing 2query ldc decoded single quantum query defined appropriate sense goes establish exponential lower bound lquery locally quantumdecodable code extend lower bounds nonbinary alphabets also somewhat improve polynomial lower bounds katz trevisan ldcs 2 queries furthermore show q quantum queries allow succinct ldcs best known ldcs q classical queries finally give new classical lower bounds quantum upper bounds setting private information retrieval particular exhibit quantum 2server private information retrieval pir scheme on310 qubits communication beating on13 bits communication best known classical 2server pir b introduction 11 setting correcting codes allow one encode nbit string x mbit codeword cx way x still recovered even codeword corrupted number places example codewords length already suce recover errors constant fraction bitpositions codeword even linear time 33 one disadvantage standard error correction one usually needs consider corrupted preliminary version paper appeared stoc03 22 supported darpa agreement number f 306020120524 part work done visiting cwi z work done postdoc uc berkeley supported talent grant 62565 netherlands organization scientic research nwo also partially funded projects qaip ist1999 resq ist200137559 istfet programme ec codeword recover anything x one interested recovering one bits x ecient schemes possible allow us extract small parts encoded information corrupted codeword looking querying positions word schemes called locally decodable codes ldcs found various applications complexity theory cryptography selfcorrecting computations 5 24 17 16 18 probabilistically checkable proofs 2 worstcase averagecase reductions 3 34 private information retrieval 11 extractors 25 informally ldcs described follows q locally decodable code encodes nbit strings x mbit codewords cx bit x recovered probability making q queries even codeword corrupted bits example hadamard code locally decodable code two queries suce predicting bit constant advantage even constant fraction errors code recovery corrupted codeword possible picking random j 2 f0 1g n querying j je computing xor two bits guess x neither two queried bits corrupted output cx corrupted positions fraction least 1 2 j j e pairs indices uncorrupted recovery probability least 1 2 12 long 14 main drawback hadamard code exponential length clearly would like codeword length number queries q small main complexity question ldcs large needs function n q et al 2 showed achieve almost linear size codes xed beimel et al 8 recently improved best known upper bounds constant q log qq log q precise bounds small q study lower bounds initiated katz trevisan 21 proved exist n larger constant depending q 2 proved bound q queries made nonadaptively bound generalized adaptive case deshpande et al 14 establishes superlinear quadratic lower bounds length ldcs constant number queries still large gap best known upper lower bounds particular open achievable constant q goldreich et al 20 examined case showed 2 n8 c linear code obata 29 subsequently strengthened dependence 2 essentially optimal recently bensasson et al 9 studied relaxed notion ldcs decoder allowed output dont know constant fraction indices construct relaxed ldcs constant number queries katz trevisan goldreich et al established close connection locally decodable codes private information retrieval pir schemes pir scheme allows user extract nbit database x replicated k 1 servers without servers learning user wants main complexity measure pir scheme communication complexity ie sum lengths queries user sends server length servers answers roughly queries ldc correspond servers pir scheme fact best known ldcs constant q derived pir schemes one server privacy maintained letting server send whole nbit database user takes n bits communication optimal database replicated k 2 servers exist protocols signicantly less communication chor et al 11 exhibited 2server pir scheme communication complexity 13 one 1k k 2 ambainis 1 improved latter 12k 1 beimel et al 8 improved communication complexity 2 log log kk log k results improve previous best bounds k 3 2 lower bounds better n known pirs k 2 servers case 2 servers best known lower bound 4 log n due mann 26 pir scheme linear every query user makes answer bits linear combinations bits x goldreich et al 20 proved linear 2server pirs tbit queries abit answers user looks k predetermined positions answer require 12 results locally decodable codes main result paper exponential lower bound general 2query ldcs theorem 4 c f0 1g n f0 1g 2 locally decodable code rst superpolynomial lower bound general ldcs one query constant c exponent somewhat worse goldreich et al 20 obata 29 proof establishes exponential lower bound ldcs linear ones proof introduces one radically new ingredient quantum computing show two classical queries recover x probability also recovered probability 1247 using one quantum query words 2 locally decodable code 1 47locally quantumdecodable code prove exponential lower bound 1query lqdcs showing roughly speaking 1query lqdc length induces quantum random access code x length log code enables user recover bit x choice nayaks 27 linear lower bound length codes nishes proof sake completeness include proof result appendix b lower bound classical ldcs one examples tools quantum computing enable one prove new results classical computer science know examples 1 radhakrishnan et al 30 proved lower bounds set membership data structure hold quantum algorithms fact stronger previous classical lower bounds buhrman et al 10 sen venkatesh data structures predecessor problem 32 quantph version klauck et al 23 proved lower bounds kround quantum communication complexity treejumping problem somewhat stronger previous best classical lower bounds cryptography gisin renner wolf 19 used analogy quantum bound entanglement provide evidence conjecture intrinsic information random variable shared alice bob eavesdropper eve always equals amount secret key alice bob extract later conjecture indeed disproved 31 though without using quantum methods cases underlying proof techniques easily yield classical proof one replaces quantum notions like von neumann entropy trace distance classical analogues get classical proof classical 1 quantum lower bound communication complexity inner product function cleve et al 12 provides new insight classical result establish new result classical computer science case contrast proof seems inherently quantum since classical analog 2classicalqueriesto1quantumquery reduction 2query ldcs exist 1query dont section 3 focuses codes binary alphabet section 41 extend result case larger alphabets using classical reduction due trevisan 35 section 42 look ldcs q 3 queries improve polynomial lower bounds katz trevisan 21 bounds still polynomial far best known upper bounds section 43 observe construction implies existence 1query quantumdecodable codes n hadamard code example codewords still classical decoder quantum mentioned allow one classical query ldcs exist n larger constant depending 21 larger q turns best known 2q ldcs due beimel et al 8 actually q lqdcs hence xed number queries q obtain lqdcs signicantly shorter best known ldcs particular beimel et al give 4query ldc length 2query lqdc signicantly shorter 2query ldcs need summarize situation table 1 contributions indicated boldface queries length ldc length lqdc exist 2 n table 1 best known bounds length ldcs lqdcs q queries 13 results private information retrieval private information retrieval setting techniques allow us reduce classical 2server pir schemes 1bit answers quantum 1server pirs turn reduced random access code 27 thus section 51 obtain n lower bound communication complexity classical 2server pirs 1bit answers section 52 extend lower bound pir schemes larger answers previously bound known linear pirs rst proven 11 section 52 1bit answers extended constantlength answers 20 furthermore results combined katz trevisan give 44 log n lower bound general 2server pir rst modest improvement bound mann 26 subsequently work beigel fortnow gasarch 7 found classical proof 2server pir perfect recovery answers needs query length n 2 however proof seem extend case 12 larger answers apart giving new lower bounds classical pir also use 2to1 reduction obtain quantum pir schemes beat best known classical pirs particular beimel et al 8 example 42 exhibit classical 4server pir scheme 1bit answers communication complexity 310 reduce quantum 2server pir 310 qubits communication beats best known classical 2server pir complexity 13 similarly give quantum improvements best known kserver pir schemes k 2 however constitute true classicalquantum separation pir setting yet since good lower bounds known classical pir summarize best known bounds classical quantum pir table 2 servers pir complexity qpir complexity table 2 best known bounds communication complexity classical quantum pir preliminaries 21 quantum give precise denitions locally decodable codes pir schemes related notions rst explain standard notation quantum computing let h denote 2dimensional complex vector space equipped standard inner product pick orthonormal basis space label two basis vectors j0i j1i simplicity identify vectors respectively qubit unit length vector space expressed linear combination basis states complex amplitudes mqubit system unit vector mfold tensor space h 2 basis states space mfold tensor products states j0i j1i example basis states 2qubit system four 4dimensional unit vectors j0i j1i j0i j1i abbreviate eg j0i j0ij1i j1 0i j10i even j2i since 2 10 binary basis states mqubit state ji 2 dimensional complex unit vector use denote conjugate transpose vector ji hj inner product states ji j two states orthogonal hj ji k hji mixed state fp ig classical distribution pure quantum states system state j probability p represent mixed quantum state density matrix dened j note positive semidenite operator trace sum diagonal entries equal 1 density matrix pure state ji quantum system called bipartite consists two subsystems describe state subsystems separately reduced density matrix example quantum state form state system holding second part ji described reduced density matrix quantum state evolve unitary operation measurement unitary transformation linear mapping preserves 2 norm apply unitary u state ji evolves u ji mixed state evolves uu general measurement allowed quantum mechanics specied family positive semidenite operators subject condition given density matrix probability observing ith outcome measurement given trace nonnegative e positive semidenite also sum 1 measurement yields outcome resulting quantum state particular resulting state jik ji k special case forms orthonormal basis mqubit space measuring bbasis means apply measurement given applying pure state ji gives resulting state j probability finally word quantum queries query mbit string commonly formalized following unitary transformation j 2 b 2 f0 1g called target bit quantum computer may apply superposition equivalent formalization using c control bit controls whether phase 1 j added given extra workspace one query either type simulated exactly one query type refer nielsen chuang 28 details 22 codes decoding algorithm mean algorithm quantum classical depending context oracle access bits possibly corrupted codeword x algorithm gets input supposed recover x making queries want emphasize speak algorithm merely convenient way formalize decoding process focus algorithmics decoding informationtheoretic aspects ie tradeo number q queries allowed decoding required codelength denition q locally decodable code ldc classical randomized decoding algorithm 1 makes q queries mbit string nonadaptively 2 x 2 f0 1g hamming distance dcx pra ldc called linear c linear function gf 2 ie cx allowing quantum computer make queries superposition similarly dene q locally quantumdecodable codes lqdcs convenient work nonadaptive queries used denition distribution queries makes independent however main lower bound also holds adaptive queries see rst remark end section 33 23 private information retrieval next dene private information retrieval schemes denition 2 oneround 1 secure kserver private information retrieval pir scheme recovery probability answer size consists randomized algorithm user k deterministic algorithms servers 1 input 2 n user produces k tbit queries q sends respective servers jth server sends back abit string user outputs bit b depending randomness 2 x probability users randomness least 12 3 x j distributions q j users randomness close total variation distance dierent scheme called linear every j q j jth servers answer j x q j linear combination gf 2 bits x straightforwardly generalize denitions quantum pir case servers state query independent case need known upper bounds pir one round communication perfect recovery servers get information whatsoever assume one round mentioning 3 lower bound 2query locally decodable codes proof two parts clear intuition requiring quite technicalities 1 2query ldc 1query lqdc one quantum query compute boolean functions two classical queries albeit slightly worse error probability 2 length 1query lqdc must exponential uniform superposition indices contains log qubits induces quantum random access code x linear lower bound already known 27 31 2 classical 1 quantum query key rst step following lemma suppose make queries bits input string exists quantum algorithm makes one query one independent f outputs fa probability exactly 1114 outputs 1 fa otherwise proof could construct state one quantum query could determine certainty since four possible states orthonormal basis could also see states hadamard encoding strings b 2 f0 1g 2 unfortunately cannot construct j perfectly one query instead approximate state making querypj0ij1i rst bit control bit appropriate phase 1 j put front jji control bit 1 result query state algorithm measures state ji orthonormal basis consisting four states probability getting outcome jhj ij 3 outcomes probability 112 algorithm determines output based f measurement outcome b distinguish 3 cases f 1 completely analogous 0 1 reversed algorithm outputs 1 probability 1 outputs 0 probability 67 1 probability 17 accordingly probability output 1 probability output 0 2 2 algorithm outputs fb probability 1314 outputs 1 fb probability 114 probability output fa exactly 1114 3 f constant case algorithm outputs value probability 1114 thus always output fa probability 1114 2 peter hyer personal communication recently improved 1114 lemma 910 describe algorithm appendix show success probability best possible one quantum query using lemma prove theorem 1 2 ldc 1 47lqdc proof consider x dcx 1query quantum decoder use randomness 2query classical decoder random string classical decoder determines two indices f f0 1g 2 f0 1g probability taken decoders randomness use lemma 1 obtain 1query quantum decoder outputs bit b success probability quantum decoder 2 4 promised 2 32 lower bound 1query lqdcs quantum random access code encoding x 7 x nbit strings x mqubit states x possibly mixed bit x recovered probability p x following lower bound known length quantum codes 27 see appendix b theorem 2 nayak encoding x 7 x nbit strings mqubit states recovery probability least p 1 hpn allows us prove exponential lower bound 1query lqdcs theorem 3 1 lqdc proof goal show recover x good probability number copies uniform logm 1qubit state intuitive reason follows since c lqdc able recover x even codeword corrupted many places therefore distribution queries decoder must smooth ie spread almost positions codewordotherwise adversary could choose corrupted bits way makes recovery probability low uniform distribution provides reasonable approximation smooth distribution since uniform state juxi independent actually recover bit x good probability constitutes quantum random access code x applying theorem 2 gives result use exactly part lemma 1 see could go wrong exactly least suppose classical decoder outputs andy1 y2 outputs x probability 35 12 however quantum procedure computes andy1 y2 success probability 1114 xory3 y4 success probability 1 recovery probability 351114 12 let us precise general query quantum decoder could make recover x form j cj pure states decoders workspace cj nonnegative reals phases could put j cj workspace also incorporate classical randomness used however decoder could equivalently add workspace states query using unitary map jcijjij0i 7 jcijjij cj hence assume without loss generality actual query cj jcijji decoder measures state resulting query let two measurement operators decoder uses measurement corresponding outputs 1 0 respectively probability giving output 1 queryresult jri clarity dont write ji inside p inspired smoothing technique 21 split amplitudes j query jq small large ones 1mg since query aect j0ijjistates assume without loss generality 0j j 0j 1 hence 0 let cj norm smallamplitude part since cj 1 jbj dene nonnormalized states cj2a cj jcijji pure states jaxi jbi jaxi jbi correspond 2 f0 1g corrupted compared cx jbj positions decoder recover x states x x averaging previous two inequalities gives similarly x 0 x 0 hence normalized states 1 jaxi 1 jax 0 since holds every x x 0 x constants q p 1 copy state 1 jaxi could run procedure recover x assume q 1 12 must q 0 12 2 use argument 0 1 reversed q 1 already done output 0 probability otherwise output result decoders 2outcome measurement 1 jaxi probability procedure outputs 1 probability procedure outputs 0 ax thus recover x good probability state 1 jaxi depends well x remains show obtain 1 jaxi juxi reasonable probability applying measurement operators juxi cj2a cj jc jihc jj positive operators required cj 1 c measurement gives rst outcome probability cj2a case obtained normalized version juxi 1 jaxi suppose copies juxi measurement separately probability 1 1 2 2 r 12 one give rst outcome case predict x probability measurements give second outcome output fair coin ip guess x overall recovery probability accordingly r copies logm 1qubit state juxi form quantum random access code recovery probability p using theorem 2 hence log 2 n 33 lower bound 2query ldcs theorem 4 c f0 1g n f0 1g 2 locally decodable code proof theorem combines theorem 1 3 straightforwardly would give constant 2 49 ln 2 get better constant claimed observing 1query lqdc derived 2query ldc actually 13 overall squared amplitude queries control bit c zero 0j hence proof theorem 3 redene small amplitude cj 23m still b elements cj 23 turns allows us make factor 32 larger improves probability getting 1 jaxi juxi 3a 2 4 allows us decrease r 43a 2 translates lower bound log 3 2 n32 ln 2 1 combining theorem 1 makes factor 47 smaller gives remarks 1 note 2 ldc adaptive queries gives 2 2ldc nonadaptive queries query q 1 would followed query q 0 2 q 1 2 depending outcome q 1 guess advance whether query q 1 q 0 2 q 1 q 1 2 probability 12 second query one would made adaptive case ne case ip coin giving overall recovery probability 1212 thus also get slightly weaker still exponential lower bounds adaptive 2query ldcs 2 constant 398 ln 2 optimized bit choosing number r copies bit larger proof theorem 3 using peter hyers 910algorithm appendix instead 1114algorithm lemma 1 interesting however question whether quadratic dependence improved 3 2 ldc decoders output xor two queries give better reduction theorem 1 quantum decoder query 1 extract 1 2 certainty thus recovery probability remains going 1247 accordingly also get better lower bounds 2query ldcs output xor two queries exponent 4 second part proof reduction locally quantumdecodable code smooth quantum code code distribution queries uniform reduction known classical codes well see next section hence alternative way get exponential lower bound would rst invoke result katz trevisan reduces ldc code uniform query distribution reduce case decoder outputs xor q queried bits starting uniformly smooth code use reduction 2 classical queries 1 quantum query without loss recovery probability see remark 3 reduction immediately end quantum random access code log qubits done however proof would give worse dependence current result extensions section give various extensions variations lower bound previous section 41 nonbinary alphabets extend lower bounds binary 2query ldcs case 2query ldcs larger alphabets simplicity assume alphabet query position j returns bit string cx j denition q ldc section 22 carries immediately measuring hamming distance cx need notion smooth codes connection ldcs stated 21 denition q c smooth code classical randomized decoding algorithm 1 makes q queries nonadaptively 2 x pra cx 3 x j probability input machine queries index j cm note smooth codes require good decoding codewords cx close cx katz trevisan 21 theorem 1 established following connection theorem 5 katz trevisan q ldc q qsmooth code converse theorem 5 also holds q c smooth code q cldc probability decoder queries one corrupted positions hence ldcs smooth codes essentially equivalent appropriate choices parameters prove exponential lower bound ldcs nonbinary alphabet reduce smooth code somewhat longer binary smooth code works well averaged x show lower bound averagecase binary smooth codes way similar proof theorem 4 following key lemma suggested us luca trevisan 35 2 c smooth code exists good average ie decoder proof form new binary code c 0 replacing symbol cx j 2 old code hadamard code consists 2 bits length c 0 x 2 bits new decoding algorithm uses randomness old one let us x two queries output old decoder describe new decoding algorithm good average x looks one bit hadamard codes first specic j k f pr x fa new decoder outputs random bit case least good old one average x consider case pr x fa switching f0 1gnotation 1gnotation enables us say 2 viewing b two bit strings represent f fourier representation see eg 6 fa s2s hence 2 averaging using follows exist subsets returning f0 1gnotation must either pr x pr x products mod 2 bit strings accordingly either xor two bits 0 0 b negation predicts x average probability 122 2 bits binary code c 0 x csmoothness c translates c 2 smoothness c 0 averaging classical randomness ie choice j k f gives lemma 2 lemma enables us modify proof theorem 4 works nonbinary theorem 6 locally decodable code proof using theorem 5 lemma 2 turn c binary 2 2 1 2 2 smooth code c 0 average recovery probability bits since decoder xors two binary queries reduce one quantum query without loss average recovery probability see third remark following theorem 4 reduce quantum smooth code quantum random access code modied version proof theorem 4 smoothness c 0 implies amplitudes j depend one quantum query satisfy j hence need split set js b also control bit c always 1 ignore consider states jji 2outcome measurement operators probability measurement takes us juxi renormalized juxi jaxi equal hence copies juxi forms quantum random access code average success probability 1 hpn lower bound quantum random access code holds even recovery probability p average x gives implies statement theorem 2 42 bounds 2 queries address case ldcs binary alphabet decoder asks 2 queries obvious way extend 2to1 reduction 2 classical queries since quantum computer needs dq2e queries compute parity q bits advantage 4 15 particular needs 2 quantum queries compute parity 3 bits dont lower bounds 2query lqdcs still ldcs q 3 queries able improve polynomial lower bounds katz trevisan 21 somewhat theorem 7 q locally decodable code log n constant depends q proof suppose simplicity q even multiple q theorem 5 suces prove bound q c smooth code use following result make smooth code uniform fact katz trevisan 21 discussion section 4 q c smooth code q q 2 2c smooth code good average every new qquery decoder xed partition mq qtuples picks random qtuple j outputs boolean function q bits every decoding x correct probability least 12 averaged x proof analogous lemma 2 ensure decoder actually computes xor q queried bits negation average correctness probability still least derive quantum random access code uniform smooth code let jjihjj projector states jii jji suppose 1 partition qtuples pairs measuring uniform state operators p random 1 m2 obtain cx generate xor random pair partition order recover x need nd q2 dierent pairs come qtuple state juxi gives us random pair possible m2 birthday paradox om 1 2q copies log mqubit state juxi high probability nd q2 dierent pairs come qtuple hence able recover x words copies log mqubit state juxi constitute average random access code random access code lower bound appendix b gives implies example queries lower bound 3 n log n 2 katz trevisan 43 locally quantumdecodable codes queries third remark section 33 immediately generalizes theorem 8 2q ldc decoders output xor 2q queried bits q lqdc ldcs q queries obtained qserver pir schemes 1bit answers concatenating answers servers give possible queries user beimel et al 8 corollary 43 recently improved best known upper bounds qquery ldcs based improved pir construction give general upper bound qquery ldcs constant depending well precise estimates small q particular construct ldc length xortype reduce number queries half allowing quantum decoding instance 4query ldc 2query lqdc length contrast 2query ldc needs length n proved general ldcs something nearly good using van dams result qbit oracle recovered probability nearly 1 using q2 p q quantum queries 13 theorem 9 q ldc q2 p q 2lqdc 44 locally decodable erasure codes recently notion locally decodable erasure code ldec used construction extractors 25 section 31 code even 1 positions codeword erased still recover x using q queries remaining positions denition 4 consider map say message position decodable codeword positions exists function f fcx j 1 x c q ldec every every fraction positions codeword exists qtuple positions decodable show ldecs equivalent smooth codes dened section 41 hence ldcs consider ldec codewords length equivalence shows lower bounds also hold ldecs particular 2 ldecs need exponential length first consider ldec take set fraction positions codeword denition exists good qtuple ie one decode message position remove q positions codeword replace q positions new set 0 positions still good qtuple remove go repeat substitution 1 mq times size code therefore disjoint qtuples good x code smooth code smooth decoder picks one tuples random queries positions converse also true smooth code contains disjoint qtuples say good x hence subset positions codeword size 1 1 exists good qtuple therefore code ldec 1 5 private information retrieval mentioned close connection locally decodable codes private information retrieval section use variant 2to1 reduction prove new lower bounds pir new upper bounds qpir 51 lower bounds binary 2server pir get lower bounds 2server pirs 1bit answers give 2step proof reduction 2 classical servers 1 quantum server combined lower bound 1server quantum pir theorem 10 exists classical 2server pir scheme tbit queries 1bit answers recovery probability exists quantum 1server pir scheme recovery probability proof proof analogous proof locally decodable codes theorem 1 let quantum user employ randomness classical one problem boils computing fa 1 2 1 rst servers 1bit answer query q 1 2 second servers 1bit answer query q 2 however addition hide quantum server making quantum user set 4 0 string 0s user sends everything rst register server state server uniform mixture j0 0 j1 q 1 j2 q 2 security classical protocol j1 q 1 contains information averaged users randomness holds j2 q 2 hence server gets information quantum server puts 1 j front jj q j j 2 f1 2g leaves j0 0 alone sends everything back note need supply name classical server j 2 f1 2g tell server superposition whether play role server 1 2 user compute fa 1 2 success probability exactly 1114 giving overall recovery probability theorem 1 2 combining reduction quantum random access code lower bound obtain rst n lower bound holds 1bitanswer 2server pirs linear ones theorem 11 classical 2server pir scheme tbit queries 1bit answers recovery probability 2 proof rst reduce 2 classical servers 1 quantum server way theorem 10 consider state quantum pir scheme user sends r p r classical probabilities user depend q j r tbit query user sends server j classical 2server scheme wants x random string r letting servers basis states write j ja ib pure states depend x coecients b nonnegative reals depend otherwise measurement b would give server information contradicting privacy server tags appropriate phase bx 1 2g gives b ja ib bx jbi following pure state random access code x user unitarily map j0ijbi 7 ja ib ijbi map j0ij x 7 j ix get completing quantum pir protocol state j x qubits hence theorem 2 obtain 1 hpn 2 2 special case classical pir outputs xor two answer bits improve lower bound 1 h12 n 1 particular n 1 case perfect recovery tight 52 lower bounds 2server pir larger answers also extend linear lower bound 2server pir schemes answer length theorem 11 case 2server pir larger answer length use translation pir smooth codes given lemma 71 goldreich et al 20 lemma 3 gkst classical 2server pir scheme query length answer length recovery probability 2 3 smooth code going roughly steps proof theorem 6 obtain theorem 12 classical 2server pir scheme tbit queries abit answers recovery probability 53 lower bounds general 2server pir previous lower bounds query length 2server pir schemes signicant protocols short answer length slightly improve best known bound 4 log n 26 overall communication complexity 2server pir schemes combining theorem 12 theorem 6 katz trevisan 21 restate theorem pir setting remainder section assume xed positive constant theorem 13 katz trevisan every 2server pir scheme tbit queries abit answers prove following lower bound total communication 2server pir scheme tbit queries abit answers theorem 14 every 2server pir scheme total communication c 44 o1 log n proof distinguish three cases depending answer length scheme let log log n log n case 1 02 log n theorem 12 get c 4648 n 5 case 2 02 log n 22 log n theorem 13 case 3 22 log n obviously log n54 upper bounds quantum pir best known ldcs derived classical pir schemes 1bit answers output xor 1bit answers user receives allowing quantum queries reduce number queries half obtain ecient lqdcs similarly also turn underlying classical kserver pirs directly quantum pirs k2 servers interestingly exists 4server pir 1bit answers communication complexity 310 8 example 42 gives us quantum 2server pir scheme 310 communication improving upon communication required best known classical 2server pir scheme 13 ever since introduction pir chor et al 11 introduction mentioned also quantum upper bounds k 2 servers obtained similarly 6 conclusion open problems paper rst new classical result proved using techniques quantum computing apparently essential way least dont know classical proof result clearly would interesting nd applications would much broaden relevance quantum computing make less conditional whether actual quantum computer ever built also many interesting open questions related tradeos various parameters ldcs particular still open whether one achieve using constant even sublogarithmic number queries would like obtain better lower bounds q 2 queries explore connections ldcs combinatorial constructions similarly main complexity questions general pir schemes still wide open even 2server case dont restrict answer size 13 protocol 11 best known long time 2server case would nice show close optimal finally exhibited 2server quantum pir schemes ecient best known classical ones would interesting improve prove qpir ecient best rather best known classical pir schemes acknowledgments would like thank luca trevisan many insightful comments throughout work also allowing us include lemma 2 section 41 also thank harry buhrman richard gill peter hyer hartmut klauck ashwin nayak kenji obata pranab sen via also rahul jain mario szegedy ashish thapliyal john tromp stephanie wehner helpful discussions thank amos beimel sending us version 8 bill gasarch sending us version 7 claude crepeau nicolas gisin references 19 31 anonymous jcss referee many comments improved presentation paper r upper bound communication complexity private information retrieval checking computations polylogarithmic time bpp subexponential time simulations unless exptime publishable proofs quantum lower bounds polynomials hiding instances multioracle queries polynomial method circuit complexity nearly tight bounds private information retrieval systems breaking 1 robust pcps proximity bitvectors optimal private information retrieval quantum entanglement communication complexity inner product function quantum oracle interrogation getting information almost half price better lower bounds locally decodable codes limit speed quantum computation determining parity highly resilient correctors polynomials linking classical quantum key agreement classical analog bound entanglement eciency local decoding procedures errorcorrecting codes exponential lower bound 2query locally decodable codes via quantum argument interaction quantum communication complexity set disjointness new directions testing extractors optimal constant factors private access distributed information optimal lower bounds quantum automata random access codes quantum computation quantum information optimal lower bounds 2query locally decodable linear codes quantum complexity set membership new bounds secretkey agreement gap formation secrecy extraction lower bounds quantum cell probe model expander codes pseudorandom generators without xor lemma personal communication tr hiding instances multioracle queries checking computations polylogarithmic time selftestingcorrecting polynomials approximate functions highly resilient correctors polynomials randomselfreducibility complete sets bpp subexponential time simulations unless exptime publishable proofs private information retrieval pseudorandom generators without xor lemma extended abstract efficiency local decoding procedures errorcorrecting codes bitvectors optimal interaction quantum communication complexity set disjointness quantum lower bounds polynomials breaking on12k1 barrier informationtheoretic private information retrieval quantum entanglement communication complexity inner product function lower bounds quantum cell probe model upper bound communication complexity private information retrieval optimal lower bounds 2query locally decodable linear codes exponential lower bound 2query locally decodable codes via quantum argument extractors quantum oracle interrogation optimal lower bounds quantum automata random access codes quantum complexity set membership lower bounds linear locally decodable codes private information retrieval better lower bounds locally decodable codes robust pcps proximity shorter pcps applications coding ctr richard beigel lance fortnow william gasarch tight lower bound restricted pir protocols computational complexity v15 n1 p8291 january 2006 sergey yekhanin towards 3query locally decodable codes subexponential length proceedings thirtyninth annual acm symposium theory computing june 1113 2007 san diego california usa ashwin nayak julia salzman limits ability quantum states convey classical messages journal acm jacm v53 n1 p184206 january 2006
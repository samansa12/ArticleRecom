design tradeoffs alpha ev8 conditional branch predictor paper presents alpha ev8 conditional branch predictor alpha ev8 microprocessor project canceled june 2001 late phase development envisioned aggressive 8wide issue outoforder superscalar microarchitecture featuring deep pipeline simultaneous multithreading performance processor highly dependent accuracy branch predictor consequently large silicon area devoted branch prediction ev8 alpha ev8 branch predictor relies global history features total 352 kbitsthe focus paper different tradeoffs performed overcome various implementation constraints ev8 branch predictor one instance pipelining predictor two cycles facilitate prediction 16 branches per cycle two dynamically successive 8 instruction fetch blocks resulted use three fetchblock old compressed branch history information accesing predictor implementation constraints also restricted composition index functions predictor forced usage singleported memory cellsnevertheless show alpha ev8 branch predictor achieves prediction accuracy range stateoftheart academic global history branch predictors consider implementation constraints great detail b introduction alpha ev8 microprocessor 2 features 8wide superscalar deeply pipelined microarchitecture minimum branch misprediction penalty 14 cycles performance microprocessor dependent branch prediction accuracy architecture technology alpha ev8 aggressive new challenges confronted design branch predictor paper presents alpha ev8 branch predictor great de tail paper expounds different constraints work done authors compaq 1999 faced definition predictor various tradeoffs performed lead final design par ticular elucidate following use global history branch prediction scheme b choice prediction scheme derived hybrid skewed branch predictor 2bcgskew19 c redefinition information vector used indexing predictor combines compressed branch history path history different prediction hysteresis table sizes prediction tables hysteresis tables accessed different pipeline stages hence implemented physically distinct tables e variable history lengths four logical tables ev8 predictor accessed using four different history lengths f guaranteeing conflict free access bankinterleaved predictor singleported memory cells 16 branch predictions two 8instruction dynamically succesive fetch blocks g careful definition index functions predictor tables work demonstrates spite hardware implementation constraints encountered alpha ev8 branch predictor accuracy compromised stands comparison virtually equivalent size global history branch predictors proposed far overall ev8 architecture optimized single process performance extra performance obtained simultaneous multithreading considered bonus therefore parameters conditional branch predictor tuned single process performance primary objective however ev8 branch predictor found perform well presence multithreaded workload remainder paper organized follows section briefly presents instruction fetch pipeline alpha ev8 section 3 explains global history branch predictor scheme preferred local section 4 present prediction scheme implemented alpha ev8 2bcgskew section also presents design space 2bcgskew various design dimensions harnessed fit ev8 predictor 352 kbits memory bud get section 5 presents justifies history path information used index branch predictor alpha ev8 branch predictor tables must support two independent reads 8 predictions per cycle section 6 presents scheme used guarantee two conflictfree accesses per cycle bankinterleaved predictor section 7 presents hardware constraints composing index functions prediction tables describes functions eventually used section 8 presents step step performance evaluation ev8 branch predictor constraints added turnaround solutions adopted finally provide concluding remarks section 9 alpha ev8 frontend pipeline sustain high performance alpha ev8 fetches two 8instruction blocks per cycle instruction cache instruction fetch block consists consecutive valid instructions fetched icache instruction fetch block ends either end aligned 8instruction block taken control flow instruction taken conditional branches end fetch block thus 16 conditional branches may fetched predicted every cycle every cycle addresses next two fetch blocks must generated since must achieved single cycle involve fast hardware alpha ev8 line predictor 1 used purpose line predictor consists three tables indexed address recent fetch block limited hashing logic consequence simple indexing logic relatively low line prediction accuracy avoid huge performance loss due fairly poor line predictor accuracy long branch resolution latency ev8 pipeline outcome branch known earliest cycle 14 often around cycle 20 25 line predictor backed powerful program counter address generator includes conditional branch predictor jump predictor return address stack predic tor conditional branch target address computation instructions flowing instruction cache final address selection pcaddressgeneration pipelined wo cycles illustrated fig 1 four dynamically succesive fetch blocks b c simultaneously flight pcaddressgenerator case mismatch line prediction pcaddressgeneration instruction fetch resumed pcaddressgeneration result 3 global vs local history previous generation alpha microprocessor 7 incorporated hybrid predictor using global local branch history information alpha ev8 16 branch outcomes 8 fetch block predicted per blocks b phase 1 phase 1 phase 0 blocks c completed pc address generation blocks z phase 0 completed phase 1 phase 0 line prediction completed prediction tables read cycle 1 cycle 2 cycle 3 figure 1 pc address generation pipeline cycle implementing hybrid branch predictor ev8 based local history including component using local history would challenge local branch prediction requires prediction read local history table read prediction table performing 16 local history reads parallel requires dualported history table one port fetch block sufficient since one read parallel histories sequential instructions sequential table entries performing 16 prediction table reads would require 16ported prediction table whenever occurrence branch inflight speculative history associated younger inflight occurrence branch used 8 maintaining using speculative local history already quite complex processor fetching predicting single branch per cycle20 alpha ev8 number inflight branches possibly equal maximum number inflight instructions 256 moreover ev8 indexing branch predictor three fetch blocks speculative branch outcomes determined see fig 1 three blocks may contain three previous occurrences every branch fetch block contrast single speculative global history per thread simpler build shown section 8 accuracy ev8 global history prediction scheme virtually insensitive effects three fetch blocks old global history finally alpha ev8 simultaneous multithreaded processor 25 26 independent threads running compete predictor table entries interference local history based scheme disastrous pollutes local history prediction tables several parallel threads spawned single application pollution exacerbated unless local history table indexed using pc thread number comparison global history schemes global history register must maintained per thread parallel threads application benefit constructive aliasing 10 4 branch prediction scheme global branch history branch predictor tables lead phenomenon known aliasing interference 28 24 multiple branch information vectors share entry predictor table causing predictions wo branch substreams intermingle dealiased global history branch predictors recently intro duced enhanced skewed branch predictor egskew 15 agree predictor 22 bimode predictor 13 yags predictor 4 predictors shown achieve higher prediction accuracy equivalent hardware complexity larger aliased global history branch predictors gshare 14 gas 27 however hybrid predictors combining global history predictor typical bimodal predictor indexed pc 21 may deliver higher prediction accuracy conventional single branch predictor 14 therefore dealiased branch predictors included hybrid predictors build efficient branch predictors ev8 branch predictor derived hybrid skewed branch predictor 2bcgskew presented 19 section structure hybrid skewed branch predictor first recalled outline update policy used ev8 branch predictor three degrees freedom available design space 2bcgskew predictor described different history lengths predictor components size different predictor components using smaller hysteresis tables prediction ta bles degrees freedom leveraged design best possible branch predictor fitting ev8 hardware budget constraints 41 general structure hybrid skewed predictor 2bcgskew enhanced skewed branch predictor egskew efficient single component branch predictor 15 13 therefore natural candidate component hybrid predictor hybrid predictor 2bcgskew illustrated fig combines egskew bimodal predictor 2bcgskew consists four 2bit counters banks bank bim bimodal predictor also part egskew predictor banks g0 g1 two banks egskew predictor bank meta metapredictor depending meta prediction either prediction coming bim majority vote predictions coming g0 g1 bim 42 partial update policy multiple table branch predictor update policy bearing prediction accuracy 15 partial update policy shown result higher prediction accuracy total update policy egskew applying partial update policy 2bcgskew also results better prediction accuracy bimodal component ac000000000000111111n history egskew prediction bimodal prediction metaprediction meta address majority vote address prediction figure 2 2bcgskew predictor curately predicts strongly biased static branches therefore metapredictor recognized situation tables updated suffer aliasing associated easytopredict branches partial update policy implemented alpha ev8 consists following ffl correct prediction predictors agreeing update see otherwise strengthen meta two predictions different strengthen correct prediction participating tables g0 g1 bim follows strengthen bim bimodal prediction used strengthen banks gave correct prediction majority vote used ffl misprediction two predictions different first update chooser see rationale 2 recompute overall prediction according new value chooser correct prediction strengthens participating tables misprediction update banks rationale 1 goal limit number strengthened counters correct prediction counter strengthened harder another addresshistory pair steal three predictors bim g0 g1 agreeing one counter entry stolen another address history pair without destroying majority pre diction strengthening counters three predictors agree stealing made easier rationale 2 goal limit number counters written wrong prediction need steal table entry another address history pair avoided 43 using distinct prediction hysteresis arrays partial update leads better prediction accuracy total update policy due better space utilization also allows simpler hardware implementation hybrid predictor 2bit counters using partial update described earlier correct prediction prediction bit left unchanged hysteresis bit strengthened participating components need read therefore correct prediction requires one read prediction array fetch time one write hysteresis array commit time misprediction leads read hysteresis array followed possible updates prediction hysteresis arrays 44 sharing hysteresis bit several counter using partial update naturally leads physical implementation branch predictor two different memory arrays prediction array hysteresis array alpha ev8 silicon area chip layout constraints allowed less space hysteresis memory array prediction memory array instead reducing size prediction array decided use half size hysteresis tables components g1 meta result two prediction entries share single hysteresis entry prediction table hysteresis table indexed using index function except significant bit consequently hysteresis table suffers aliasing prediction table instance following scenario may occur prediction entries b share hysteresis entry address history pairs associated entries strongly biased b remains always wrong due continuous resetting hysteresis bit address history pair associated scenario certainly occurs rare two consecutive accesses b without intermediate access allow b reach correct state moreover partial update policy implemented ev8 branch predictor limits number writes hysteresis tables therefore decreases impact aliasing hysteresis tables 45 history lengths previous studies skewed branch predictor 15 hybrid skewed branch predictor 19 assumed tables g0 g1 indexed using different hashing function address history pair history length used tables using different history lengths two tables allows slightly better behavior moreover pointed juan et al 12 optimal history length predictor varies depending application phenomenon less important hybrid predictor featuring bimodal table component significance reduced 2bcgskew two different history lengths used tables g0 g1 medium history length used g0 longer history length used g1 prediction table 16k 64k 64k 64k hysteresis table 16k 32k 64k 32k history length 4 13 21 15 table 1 characteristics alpha ev8 branch predictor 46 different prediction table sizes academic studies multiple table predictors 15 13 14 19 sizes predictor tables considered equal convenient comparing different prediction schemes however design real predictor hardware overall design space ex plored equal table sizes 2bcgkew branch predictor good tradeoff small size predictors instance 44k entries however large branch predictors ie 4 64k entries bimodal table bim used sparsely since branch instruction maps onto single entry consequently large branch predictor used ev8 implements bim table smaller three components 47 ev8 branch predictor configuration alpha ev8 implements large 2bcgskew pre dictor features total 352 kbits memory consisting 208 kbits prediction 144 kbits hysteresis design space exploration lead table sizes indexed different history lengths listed table 1 may remarked table bim originally bimodal table indexed using 4bit history length justified implementation constraints discussed section 7 5 path branch outcome information accuracy branch predictor depends prediction scheme predictor table sizes well information vector used index section describes pipeline constraints lead effective information vector used indexing ev8 alpha branch predictor information vector combines pc address compressed form three fetch blocks old branch path history path information form three last blocks 51 three fetch blocks old block compressed tory three fetch blocks old history information used read predictor tables must available indexing time alpha ev8 branch predictor latency wo cycles two blocks fetched every cycle fig 1 shows branch history information used predict branch outcome block include specu lative branch outcome conditional branches block also blocks c b thus ev8 branch predictor indexed using three fetch blocks old branch history ie updated history information z predicting branches block block compressed history lghist single branch predicted per cycle one history bit shifted global history register every cycle branches predicted per cycle 16 history bits shifted history every cycle update requires complex circuitry alpha ev8 complex historyregister update would stressed critical paths extent even older history would used five even sevenblocks old instead single history bit inserted per fetch block 5 inserted bit combines last branch outcome path information computed follows whenever least one conditional branch present fetch block outcome last conditional branch fetch block 1 taken 0 nottaken exclusiveored bit 4 pc address last branch rationale exclusiveor pc bit branch outcome get uniform distribution history patterns appli cation highly optimized codes tend exhibit less taken branches nottaken branches therefore distribution pure branch history outcomes applications nonuniform using single history bit originally thought compromising design tradeoff since possible compress 8 history bits 1 section 8 shows significant effect accuracy branch predictor notation block compressed history defined referred lghist 52 path information three last fetch blocks due ev8 pipeline constraints section 2 three fetch blocks old lghist used predictor although branch history information three blocks used addresses available indexing branch predictor addresses three previous fetch blocks used index functions predictor tables 53 using long history alpha ev8 features large branch predictor compared implemented previous generation mi croprocessors academic studies global history branch predictors assumed length global history smaller equal log 2 number entries branch predictor table size predictor used alpha ev8 far optimal even using lghist example considering compressed branch history 464k 2bit entries 2bcgskew predic tor using equal history length g0 g1 meta history length 24 found good design point considering different history lengths using 17 g0 20 meta 27 g1 found good tradeoff predictor configuration three fetch blocks old lghist slightly shorter length found best performing however optimal history length still longer log 2 size branch predictor table ev8 branch predictor 21 bits lghist history used index table g1 64k entries section 8 show empirically large predic tors branch history longer log 2 predictor table size almost always beneficial branch pre dictor 16 branch predictions two fetch blocks must computed parallel alpha ev8 normally since addresses two fetch blocks independent branch predictor tables would support two independent reads per cycle therefore predictor tables would multiported dualpumped bank interleaved section presents scheme allowed implementation ev8 branch predictor 4way bank interleaved using singleported memory cells bank conflicts avoided construction predictions associated two dynamically successive fetch blocks assured lie two distinct banks predictors 61 parallel access predictions associated single block parallel access predictions associated single fetch block straightforward prediction tables alpha ev8 branch predictor indexed based hashing function address three fetch blocks old lghist branch path history three last fetch block ad dresses elements single fetch block vector information except bits 2 3 4 pc address used therefore indexing functions used guarantee eight predictions lie single 8bit word tables 62 guaranteeing two successive nonconflicting alpha ev8 branch predictor must capable delivering predictions associated two fetch blocks per clock cycle typically means branch predictor must multiported dualpumped bank interleaved alpha ev8 branch predictor difficulty circumvented bank number computation bank number computation described guarantees construction two dynamically successive fetch unshuffle cycle 0 phase 1 z flows b flows line predictor completed phase phase 1 phase 1 cycle 1 cycle 2 line predictor bank number computation b bank selection wordline selection column selection final pc selection pc address generation completed prediction tables reads figure 3 flow branch predictor tables read access blocks generate accesses two distinct predictor banks therefore bank conflicts never occur moreover bank number computed cycle address fetch block generated line predictor thus extra delay added access branch predictor tables fig 3 implementation bank number computation defined let ba bank number instruction fetch block let z addresses two previous access slots let bz number bank accessed instruction fetch block z let y52y51y6y5y4y3y200 binary representation address ba computed follows y6y5b z ba y6y5phi1 else ba y6y5 computation guarantees prediction fetch block read different bank previous fetch block information bits needed compute bank numbers two next fetch blocks b bits y6y5 z6z5 bz twoblock ahead 18 bank number computation information bits available one cycle effective access branch predictor performed required computations simple therefore delay introduced branch predictor bank number computation fact bank selection performed end phase 1 cycle preceding read branch predictor tables 7 indexing branch predictor previously mentioned alpha ev8 branch predictor 4way interleaved prediction hysteresis tables separate since logical organization predictor contains four 2bcgskew components translate implementation memory ta bles however alpha ev8 branch predictor implements eight memory arrays four banks array prediction array hysteresis word line arrays made four logical predictor components section presents physical implementation branch predictor arrays constraints impose composition indexing functions section also includes detailed definition hashing functions selected indexing different logical components alpha ev8 branch predictor 71 physical implementation constraints four banks alpha ev8 branch predictor implemented two physical memory arrays prediction memory array hysteresis memory array word line arrays made four logical predictor components bank features 64 word lines word line contains prediction words g0 g1 meta 8 8bit prediction words bim single 8bit prediction word selected word line predictor table g0 g1 meta bim prediction read spans 3 half cycle phases 5 phases including bank number computation bank selection illustrated fig 3 4 detailed description given 1wordline selection one 64 wordlines accessed bank selected four predictor components share 6 address bits needed wordline selection fur thermore 6 address bits hashed since wordline decode array access constitute critical path reading branch prediction array consequently inputs decoder must available beginning cycle wordline selection 1 64 permutation 8 8 column selection 1 8 bim 1 32 g0 g1 meta predictions pertable meta time 1 bank selection figure 4 reading branch prediction table 2 column selection wordline consists multiple 8bit prediction entries four logical predictor tables one 8bit prediction word selected logical predictor tables one cycle phase available compute index column single 2entry xor gate allowed compute column bits 3 unshuffle 8bit prediction words systematically read word rearranged xor permutation bit position moved position phi f final permutation ensures larger dispersion predictions array entries corresponding branch instruction finally useful allows also discriminate longer history branch pc since computation parameter f xor permutation span complete cycle bit f computed large tree xor gates notations three fetchblocks old lghist history noted h h20 h0 a52a200 address fetch block z two previous fetch block index function table i1i0 bank number i4i3i2 offset word i10i9i8i7i6i5 line number highest order bits column number 72 general philosophy design indexing functions defining indexing functions tried apply two general principles respecting hardware implementation constraints first tried limit aliasing much possible individual table picking individual indexing function would spread accesses predictor table uniformly possible individual function normally obtained mixing large number bits history address compute individual bit function ever general constraints computing indexing functions allowed complex computations un shuffle bits indexing bits favored use lghist bits instead address bits due inclusion path information lghist lghist vectors uniformly distributed pc addresses 17 pointed indexing functions skewed cache chosen minimize number block pairs conflict two ways applies 2bcgskew branch predictor 73 shared bits indexing functions four prediction tables share total 8 bits bank number 2 bits wordline number i10 i5 bank number computation described section 6 wordline number must immediately available beginning branch predictor access fore either derived information already available earlier bank number directly extracted information available end previous cycle three fetch blocks old lghist fetch block address fetch block address natural choice since allows use effective bimodal table component bim predictor however simulations showed distribution accesses bim table entries unbalanced regions predictor tables used infrequently others congested using mix lghist history bits fetch block address bits leads uniform use different word lines predictor thus allowing overall better predictor performance consequence component bim branch predictor uses 4 bits history indexing function wordline number used given i10i9i8i7i6i5 h3h2h1h0a8a7 74 indexing bim indexing function bim already using 4 history bits three fetched blocks old path information two fetched block ahead bank number computation therefore path information last instruction fetch block z used extra bits indexing bim i13i12i11i4i3i2 a11a9phia5a10phi a6a4a3 phi z6a2 phi z5 75 engineering indexing functions g0 g1 meta following methodology used define indexing functions g0 g1 meta first best history length combination determined using standard skewing functions 17 column indices xor functions three predictors manually defined applying following principles best could 1favor uniform distribution column numbers choice wordline index column index bits must computed using one two entry xor gate since history vectors uniformly distributed address numbers favor overall good distribution column numbers history bits generally preferred address bits 2 instruction fetch block address two histories differ one two bits two occurrences map onto predictor entry table guarantee whenever information bit xored another information bit computing column bit least one appear alone computation one bit unshuffle parameter 3 conflict occurs table try avoid two tables approximate different pairs history bits xored computing column bits three tables methodology lead design indexing functions defined indexing g0 simplify implementation column electors g0 meta share i15 i14 column selection given i15 i14 i13 i12 i11 h7 phi h11h8 phi h12h4 phi h5a9 phi unshufling defined i4i3i2 a4 phi a9 phi a13 phi phia5 a2phia14phia10phih6 phih4 phih7 phia6 indexing g1 column selection given i15 i14 i13 i12 i11 h19phih12h18phih11h17phih10h16phih4h15phih20 unshuffling defined i4i3i2 a4phia11phia14phia6phih4phih6 phih9phih14phih15phih16phiz6 indexing meta column selection given i15 i14 i13 i12 i11 h7phih11h8phih12 h5phih13h4phih9a9phih6 unshuffling defined i4i3i2 a4phia10phia5 phih7phih10phih14phih13phiz5 a3phia12phia14phia6phih4phi h6 8 evaluation section evaluate different design decisions made alpha ev8 predictor design first justify choice hybrid skewed predictor 2bcgskew schemes relying global history step step analyze benefits detriments brought design decisions implementation constraints 81 methodology 811 simulation trace driven branch simulations immediate update used explore design space alpha ev8 branch predictor since methodology three orders magnitude faster complete alpha ev8 processor simulation checked branch predictors using long global history considered study relative error number branch mispredictions trace driven simulation assuming immediate update complete simulation alpha ev8 assuming predictor update commit time insignificant metric used report results mispredictions per 1000 instructions mispki experiment history length wider log 2 table sizes indexing functions family presented 17 15 used pre dictors except section 85 initial state entries prediction tables set weakly taken 812 benchmark set displayed simulation results obtained using traces collected atom23 benchmark suite specin t95 binaries highly optimized alpha 21264 using profile information train input traces recorded using ref inputs one hundred million instructions traced skipping 400 million instructions except compress 2 billion instructions skipped table 2 details characteristics benchmark traces 82 2bcgskew vs global history based predictor first validated choice 2bcgskew prediction scheme global prediction schemes fig 5 shows simulation results predictors memorization size range alpha ev8 predictor displayed results assume conventional branch history predictors best history length results presented fig 6 shows number additional mispredictions configurations fig 5 using log 2 table size instead best history length illustrated configurations ffl 432k entries ie 256 kbits 2bcgskew using history lengths 0 13 16 23 respectively bim g0 meta g1 464k entries ie 512kbits 2bcgskew using history lengths 0 17 20 27 length lengths equal tables 15 256kbit configuration 512kbit ffl bimode predictor 13 consisting two 128k entries tables respectively biased taken taken branches 16 kentries bimodal table total 544 kbits memorization 1 optimum history 1 original proposition bimode predictor assumes equal sizes three tables large size predictors using smaller bimodal table costeffective benchmark set using 16k entries bimodal table add benefit benchmark compress gcc go ijpeg li m88ksim perl vortex dyn cond branches x1000 12044 16035 11285 8894 16254 9706 13263 12757 static cond branches 46 12086 3710 904 251 409 273 2239 table 2 benchmark characteristics figure 5 branch prediction accuracy various global history schemes figure 6 additional mispredictions using log 2 table size history length benchmark set 20 log 2 history length 17 bits used ffl 1m entries 2m bits gshare optimum history length benchmark set 20 ie log 2 predictor table size ffl 288 kbits 576 kbits yags predictor 4 respec tive best history length 23 25 small configuration consists 16k entry bimodal two 16k partially tagged tables called direction caches tags 6 bits wide bimodal table predicts taken resp nottaken nottaken resp taken direction cache searched miss searched direction cache bimodal table provides prediction hit direction cache provides prediction log 2 history length 14 bits resp 15 bits used 1 figure 7 impact information vector branch prediction accuracy first simulation results confirm equivalent memorization budget 2bcgskew outperforms global history branch predictors except yags clear winner yags predictor 2bcgskew however yags predictor uses partially tagged arrays reading checking 16 tags one half cycle would difficult implement second data support predictors featuring large number entries need long history length log 2 table size history suboptimal 83 quality information vector discussion examines impact successive modifications information vector branch prediction accuracy assuming 464k entries 2bcgskew predic tor configuration accuracies best history lengths reported fig 7 ghist represents conventional branch history lghistno path assumes lghist include path information lghistpath includes path information 3old lghist considering three fetch blocks old history ev8 info vector represents information vector used alpha ev8 three fetch blocks old lghist history including path information plus path information three last blocks lghist expected optimal lghist history length shorter optimal real branch history 15 17 23 instead 17 20 27 respectively tables g0 meta g1 quite surprisingly see fig 7 lghist performance conventional branch history depending application either small loss small benefit accuracy embedding path information lghist gener figure 8 adjusting table sizes predictor ally beneficial determined often useful dealias otherwise aliased history paths loss information branches fetch block lghist balanced use history branches eventhough represented shorter information instance vortex 23 lghist bits represent average 36 branches table 3 represents average number conditional branches represented one bit lghist different benchmarks three fetch blocks old history using three fetch blocks old history slightly degrades accuracy predictor impact limited moreover using path information three fetch blocks missing history consistently recovers loss ev8 information vector summary despite fact vector information used indexing alpha branch predictor largely dictated implementation constraints benchmark set vector information achieves approximately levels accuracy without constraints 84 reducing table sizes fig 8 shows effect reducing table sizes base configuration 464k entries 2bcgskew predictor 512kbits data denoted small bim shows performance bim size reduced 64k 16k 2bit counters performance small bim half size go meta hysteresis tables denoted ev8 size latter fits 352kbits budget alpha ev8 predictor information vector used indexing predictor information vector used alpha ev8 reducing size bim table impact benchmark set except go effect using half size hysteresis tables g0 meta barely noticeable go presents large footprint consequently sensitive size reduction figure 9 effect wordline indices indexing function constraints simulations results presented far take account hardware constraints indexing functions 8 bits index must shared hashed computation column bits use one 2entry xor gate intuitively constraints lead loss ef ficiency since restricts possible choices indexing functions however remarked 16 caches partial skewing almost efficient complete skewing applies branch predictors sharing 8 bits indices hurt prediction accuracy long shared index uniformly distributed constraint using unhashed bits wordline number turned critical since restricted distribution shared index ideally ev8 branch predictor one would desire get distribution shared 8 bit index uniform possible spread accesses g0 g1 meta entire table fig 9 illustrates effects various choices made selecting wordline number address path assumes pc address bits used shared index path information used lghist address path assumes pc address bits used shared index path information embedded lghist path assumes 4 history bits 2 pc bits wordline number path information used lghist ev8 illustrates accuracy alpha ev8 branch predictor 4 history bits used wordline number index path information embedded history finally complete hash recalls results assuming hashing information bits 464k 2bcgskew ghist represents simulation results assuming 512kbits predictor constraint index functions conventional branch history previously noted incorporating path information lghist small impact 2bcgskew predictor indexed using hashing functions hardware constraints however adding path information history alpha ev8 predictor makes distribution lghist uniform allows use shared index compress gcc go ijpeg li m88ksim perl vortex lghistghist 124 157 112 120 155 153 132 159 table 3 ratio lghistghist figure 10 limits using global history therefore increase prediction accuracy constraint column bits computation indirectly achieved positive impact forcing us carefully design column indexing unshuffle functions nearly total freedom computing unshuffle fully exploited 11 bits xored unshuffling function table g1 indexing functions used final design outperform standard hashing functions considered rest paper functions originally defined skewed associative caches 17exhibit good interbank dispersion manually tuned enforce three criteria described section 75 summarize 352 kbits alpha ev8 branch predictor stands comparison 512 kbits 2bcgskew predictor using conventional branch history 9 conclusion branch predictor alpha ev8 defined beginning 1999 features 352 kbits memory delivers 16 branch predictions per cycle two dynamically succesive instruction fetch blocks therefore global history prediction scheme used 1999 hybrid skewed branch predictor 2bcgskew prediction scheme 19 represented stateoftheart global history prediction schemes alpha ev8 branch predictor implements 2bcgskew predictor scheme enhanced optimized update policy use different history lengths different tables degrees freedom definition 2bcgskew tuned adapt predictor parameters silicon area chip layout constraints bimodal component smaller components hysteresis tables two components halfsize predictor tables implementation constraints imposed three fetch blocks old compressed form branch history lghist instead effective branch history however information vector used index alpha ev8 branch predictor stands comparison complete branch history achieves combining path information branch outcome build lghist using path information three fetch blocks ignored lghist alpha ev8 fourway interleaved bank single ported cycle branch predictor supports requests two dynamically succesive instruction fetch blocks require hardware conflict res olution since bank number computation guarantees construction two dynamically succesive fetch blocks access two distinct predictors banks alpha ev8 branch predictor features four logical components implemented two memory ar rays prediction array hysteresis array fore definition index functions four logi cal predictor tables strongly constrained 8 bits must shared among four indices furthermore timing constraints restrict complexity hashing applied indices computation however efficient index functions turning around constraints designed despite implementation size constraints alpha branch predictor delivers accuracy equivalent 464k entries 2bcgskew predictor using conventional branch history constraint indexing functions imposed future generation microprocessors branch prediction accuracy remain major issue even larger predictors predictor implemented alpha ev8 may considered however brute force approach would limited return except applications large number branches exemplified benchmark set fig 10 shows simulation results 41m 2bit entries 2bcgskew predictor adding backup predictor components 3 relying different information vector types local history value prediction 9 6 new prediction concepts eg perceptron 11 tackle hard topredict branches seems promising since predictor face timing constraints issues one may consider extending hierarchy predictors increased accuracies delays line predictor global history branch prediction backup branch predictor backup branch predictor would deliver prediction later global history branch predictor r next cache line set pre diction compaq chooses smt alpha cascaded predictor economical adaptive branch target prediction yags branch predictor method apparatus predicting multiple conditional branches digital 21264 sets new standard effect speculatively updating branch history branch prediction accura cy improving branch predictors correlating data values branch prediction simultaneous multithreading dynamic branch prediction per ceptrons dynamic history length fitting third level adaptivity branch predic tion combining branch predictors trading conflict capacity aliasing conditional branch predictors case twoway skewedassociative caches skewed associative caches speculative updates local global branch history quantitative anal ysis study branch prediction strategies agree predictor mechanism reducing negative branch history interference atom system building customized program analysis tools influence branch prediction table interference branch prediction scheme performance simultaneous multithreading maximizing onchip parallelism exploiting choice alternative implementations twolevel adaptive branch prediction comparative analysis schemes correlated branch prediction tr alternative implementations twolevel adaptive branch prediction case twoway skewedassociative caches effect speculatively updating branch history branch prediction accuracy revisited comparative analysis schemes correlated branch prediction next cache line set prediction simultaneous multithreading influence branch prediction table interference branch prediction scheme performance exploiting choice multipleblock ahead branch predictors agree predictor trading conflict capacity aliasing conditional branch predictors bimode branch predictor dynamic historylength fitting yags branch prediction scheme cascaded predictor improving branch predictors correlating data values skewedassociative caches study branch prediction strategies controlflow speculation value prediction superscalar processors dynamic branch prediction perceptrons branch prediction simultaneous multithreading ctr wei zhang bramha allu loopbased leakage control branch predictors proceedings 2004 international conference compilers architecture synthesis embedded systems september 2225 2004 washington dc usa kristopher c breen duncan g elliott aliasing antialiasing branch history table prediction acm sigarch computer architecture news v31 n5 p14 december ayose falcon jared stark alex ramirez konrad lai mateo valero better branch prediction prophetcritic hybrids ieee micro v25 n1 p8089 january 2005 andr seznec antony fraboulet effective ahead pipelining instruction block address generation acm sigarch computer architecture news v31 n2 may daniel chaver luis piuel manuel prieto francisco tirado michael c huang branch prediction demand energyefficient solution proceedings international symposium low power electronics design august 2527 2003 seoul korea jamison collins dean tullsen hong wang control flow optimization via dynamic reconvergence prediction proceedings 37th annual ieeeacm international symposium microarchitecture p129140 december 0408 2004 portland oregon daniel jimenez piecewise linear branch prediction acm sigarch computer architecture news v33 n2 p382393 may 2005 amirali baniasadi andreas moshovos sepas highly accurate energyefficient branch predictor proceedings 2004 international symposium low power electronics design august 0911 2004 newport beach california usa andr seznec eric toullec olivier rochecouste register write specialization register read specialization path complexityeffective wideissue superscalar processors proceedings 35th annual acmieee international symposium microarchitecture november 1822 2002 istanbul turkey renju thomas manoj franklin chris wilkerson jared stark improving branch prediction dynamic dataflowbased identification correlated branches large global history acm sigarch computer architecture news v31 n2 may wei zhang bramha allu reducing branch predictor leakage energy exploiting loops acm transactions embedded computing systems tecs v6 n2 p11es may 2007 chunrong lai shihlien lu yurong chen trista chen improving branch prediction accuracy parallel conservative correctors proceedings 2nd conference computing frontiers may 0406 2005 ischia italy daniel jimnez fast pathbased neural branch prediction proceedings 36th annual ieeeacm international symposium microarchitecture p243 december 0305 haitham akkary srikanth srinivasan konrad lai recycling waste exploiting wrongpath execution improve branch prediction proceedings 17th annual international conference supercomputing june 2326 2003 san francisco ca usa e f torres p ibanez v vinals j llaberia store buffer design firstlevel multibanked data caches acm sigarch computer architecture news v33 n2 p469480 may 2005 abhas kumar nisheet jain mainak chaudhuri longlatency branches much matter acm sigarch computer architecture news v34 n3 p915 june 2006 daniel jimnez improved latency accuracy neural branch prediction acm transactions computer systems tocs v23 n2 p197218 may 2005 jamison collins suleyman sair brad calder dean tullsen pointer cache assisted prefetching proceedings 35th annual acmieee international symposium microarchitecture november 1822 2002 istanbul turkey david tarjan kevin skadron merging path gshare indexing perceptron branch prediction acm transactions architecture code optimization taco v2 n3 p280300 september 2005 andre seznec analysis ogeometric history length branch predictor acm sigarch computer architecture news v33 n2 p394405 may 2005 ayose falcon jared stark alex ramirez konrad lai mateo valero prophetcritic hybrid branch prediction acm sigarch computer architecture news v32 n2 p250 march 2004 oliverio j santana alex ramirez josep l larribapey mateo valero lowcomplexity fetch architecture highperformance superscalar processors acm transactions architecture code optimization taco v1 n2 p220245 june 2004 hans vandierendonck koen de bosschere xorbased hash functions ieee transactions computers v54 n7 p800812 july 2005 yuan xie gabriel h loh bryan black kerry bernstein design space exploration 3d architectures acm journal emerging technologies computing systems jetc v2 n2 p65103 april 2006 alex ramirez oliverio j santana josep l larribapey mateo valero fetching instruction streams proceedings 35th annual acmieee international symposium microarchitecture november 1822 2002 istanbul turkey bradford beckmann david wood managing wire delay large chipmultiprocessor caches proceedings 37th annual ieeeacm international symposium microarchitecture p319330 december 0408 2004 portland oregon philo juang kevin skadron margaret martonosi zhigang hu douglas w clark philip w diodato stefanos kaxiras implementing branchpredictor decay using quasistatic memory cells acm transactions architecture code optimization taco v1 n2 p180219 june 2004
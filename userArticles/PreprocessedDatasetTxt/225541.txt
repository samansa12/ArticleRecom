iteration abstraction sather sather extends notion iterator powerful new way argue iteration abstractions belong class interfaces equal footing routines sather iterators derived clu iterators much flexible better suited objectoriented programming retain property iterators structured ie strictly bound controlling structured statement motivate describe construct along several simple examples compare iteration based clu iterators cursors riders streams series generators coroutines blocks closures lambda expressions finally describe experiences iterators sather compiler libraries b introduction motivation sather objectoriented language developed international computer science institute stoutamire omohundro 1995 clean simple syntax parameterized classes objectoriented dispatch late binding multiple inheritance strong typing garbage collection originally derived eiffel aims achieve performance c without sacrificing elegance safety first version language sather 0 released may 1991 feedback users use led design sather 1 incorporated number new language constructs article describes sather iterators form iteration abstraction original sather fairly conventional loop end state ment suffices basic iterative tasks felt need general construct c sather 0 libraries made heavy use cursor authors addresses murer credit suisse os1 8070 zurich switzerland email stephanmurer skacom omohundro nec research institute inc 4 independence way princeton nj 08540 email omresearchnjneccom stoutamire international computer science stitute 1947 center street suite 600 berkeley ca 94704 email davidsicsiberkeleyedu c szyperski school computing science queensland university technology gpo box 2434 brisbane qld 4001 australia email cszyperskiquteduau permission copy without fee part material granted provided copies made distributed direct commercial advantage acm copyright notice title publication date appear notice given copying permission acm copy otherwise republish requires fee andor specific permission c objects iterate contents container objects omohundro lim 1992 work quite well certain circumstances number problems described detail section 4 section also describes approaches based riders closures streams series generators coroutines blocks like language designers clu liskov guttag 1986 felt need encapsulate common operation iterating data structure typical loops sather loops initialize iteration variables repeatedly execute body loop updating variables way testing end loop important examples pattern arise stepping elements container objects code initializing updating testing iteration variables often complex error prone errors initialization termination iteration fencepost errors common code step complex containers hash tables typically must utilize detailed internal structure container sometimes causing duplication virtually code many places observations argues making iteration operation part interface container class rather part code client container another goal iterator design allow iterators programmed active style without explicitly encode control structure state required cursors iteration constructs beyond use sather iteratorbased loop construct fits well structured programming languages encapsulation iterator states decouples separate iteration processes allows nested name iterator initial design derived iterator construct clu language clu iterator like routine except may yield addition returning may called head special loop construct loop executed time iterator yields value upon termination iterator loop exits clu iterators deal simplest iteration situations stepping elements arrays containers several limitations sather iterators remove one iterator per loop simple way step two structures simultaneously clu way modify elements clu iterators support retrieval elements structure straightforward way add modify elements iterator arguments loop invariant clean way pass loopvariant values iterator wanted sather iterators retain clean design clu iterators removing limitations similar clu sather iterators look like routines except may yield quit instead returning call routines sather equivalent methods goldberg robson 1985 member functions ellis stroustrup 1990 objectoriented languages name routine comes sathers roots eiffel meyer 1988 sather parlance method means either routine iterator c eiffel method arguments sather passed value sather iterators extend clu iterators two important ways iteration abstraction sather delta 3 multiple iterators may invoked within single loop may occur expressions anywhere loop restricted loop head allows stepping multiple structures simultaneously loop terminates soon first iterators terminates contrast clu sather provides hot iterator arguments reevaluated time control passed back iterator arguments may used pass data iterator varies iteration contrast clu iterators may generate sequence values arguments allow classes define iterators modify successive elements structure ie consume sequence values sather iterator arguments hot unless declared keyword self never hot rest article organized follows section 2 introduces sather iterator syntax gives simple examples motivation section 3 describes iterators detail section 4 compares iterators constructs serve similar purposes section 5 describes experience iterators sather compiler libraries 2 examples sather loop statement simple form loop end iterators may called within loop statements iterator called body executed either quits yields yields return value returned loop execution continues routine call execution state iterator maintained however next call iterator transfer control statement following yield local variables arguments retain previous values iterator quits instead yielding loop immediately broken execution continues statement follows loop order able distinguish visually iterator routine calls language requires iterator names end exclamation mark alerts reader places control flow may change helpful iterators may occur expression anywhere loop 21 trivial iterators every class automatically provided three iterators whilebool untilbool break may used obtain several standard forms loop functionality example defined whilepredbool yields pred true quits loop pred yield else quit may used obtain standard behavior loop whileisize 4 delta stephan murer et al iterator takes single boolean argument evaluated iteration loop long argument evaluates true iterator yields example iterator yields without returning value merely used control loop argument evaluates false iterator quits breaks loop placing iterator end loop form possible loop note arbitrary placement iterator also makes easy implement loops single conditional exit middle structured way socalled n12 loops 22 integer iterators integer class int defines number useful iterators including upto sather iterators routines implicit argument self denotes object routine invoked upto iterator self type int keep mind self always implicitly argument iterator uptoonce limitintint yield successive integers self including limit loop yield upto iterator used place explicit initialization increment termination test previous loops example sum integers 20 one might say useful iterator computing kind sum sumsummandintint yield sum previous values summand loop yield r iteration abstraction sather delta 5 sum used place explicit initialization previous loop values could instead summed executing loop example also shows iterators used part expressions like functions results yielded upto directly used arguments sum note loop could written verbosely loop iint10upto20 xsumi end 23 container iterators container classes sather libraries define iterators yield modify contained elements containers arrays simple containers complex implementation hash tables iterated throughout sather compiler iteration construct used client code appears regardless representation arrays variablesize objects sather asize returns size current array bracketed index expressions values 0 asize gamma 1 serve access array elements arrayt class arrays elements type includes following iterators indint yield indices self loop yield 0uptoasize1 end eltt successively yield elements self loop yield ind end setxt set elements successive values x loop indx yield end also examples nested iterators iterator ind generates stream indices used elt set index array nesting iterators allows formation new iterators abstracting existing ones set elements array aarrayint constant value 7 simply write loop aset7 end double elements loop aset2aelt end b another object type arrayftg copy b stopping end shorter two loop bsetaelt end compute sum products elements two arrays use loop xsumaeltbelt end 6 delta stephan murer et al examples providing set elt composition iterators include sparse distributed cf psather murer et al 1993 arrays complex underlying data structures although routines access write element separately knowledge whole set contiguous elements written allows much efficient implementation corresponding iterators compared singleelement accessor routines consider example blockwise distributed matrix central directory pointing blocks matrices row column iterator matrix yields elements block consulting directory next block containing elements row column accessing row column elementwise requires directory access element turn either leads potential bottleneck parallel implementation requires explicit implementation suitable caching heuristics many classes similarly define iterators part interfaces exam ple hash tables able yield elements trees graphs iterators yield nodes depthfirst breadthfirst orders see inorder figure 2 note simple array iterators merely convenient iterators complex data structures hidden internal representation indispensable tool reasons efficiency abstraction 3 details iterator construct previous sections informally introduced iterator construct elements describe precisely begin defining terms conclude defining construct using terms loop statement control structure delimited using keywords loop end causing repeated execution enclosed statements loop termination controlled iterators called within loop iterator method method whose name ends exclamation point iterator methods invoked within loop statements addition constructs allowed within routines except return statements iterators may contain yield quit statements may arguments described iterator call textual call iterator within loop statement denoted name iterator includes exclamation point followed list arguments iterator call always bound innermost lexically enclosing loop statement argument arguments iterator methods marked keyword definition actual argument passed argument intended change value first execution corresponding iterator call corresponding loop statement terminates value obtained first call iterator used subsequent calls ensure defined iteration state loop execution argument used method dispatching self implicitly argument arguments allow implementation avoid redundant evaluations corresponding iterator arguments calling context hot argument arguments iterator methods marked key word expression actual argument evaluated every call iteration abstraction sather delta 7 yield statement yield statement denoted keyword yield may used body iterator method execution causes control return values passed back calling loop statement resuming execution iterator call quit statement quit statement denoted keyword quit may used body iterator method execution causes corresponding loop statement terminate immediately exiting body iterator method considered implicit execution quit statement textual iterator call maintains state execution iterator loop first entered execution state enclosed iterator calls initialized first time iterator call encountered execution loop arguments evaluated subsequent calls however arguments retain earlier values expressions hot arguments reevaluated iterator first called begins execution first statement body yield statement executed control passed back caller current value return parameters returned subsequent call iterator resumes execution statement following yield statement iterator executes quit reaches end body control passes immediately end enclosing loop caller case values returned interface class includes iterators equal footing routines routines iterators may define conditionally compiled preconditions post conditions preconditions checked call iterator postconditions checked iterator yields quits routines iterators may defined abstract classes define interfaces compiler checks conformance iterators may called objectoriented dispatch delaying particular choice iterator runtime allows abstract iteration collections without knowing implementing data structure compile time sather provides general nonresumable exception constructs important interaction loop statements exceptions since loop statement bounds lifetime enclosed iterator calls termination may involve cleanup operations example loop exits space allocated iterator calls must deallocated terminating action loop statement considered allowing nonlocal exits exception raising reason sather protect statements similar try statements languages may contain iterator calls also contain surrounding loop similarly yield permitted within protect statement prevents creation dynamically protected regions overlap instead properly nesting time 4 comparison approaches discussed ways sather iterators generalize clu iterators section compare sather iterators cursors riders streams series generators coroutines closures blocks 8 delta stephan murer et al 41 generalized control structures idea generalizing iteration control structures goes back early work generators iplv newell tonge 1960 generators possi bility lists conniver mcdermott sussman 1974 conniver includes activation records called frames firstclass objects notion pattern generatordefined possibility lists trynext used get next value list special tokens possibility lists cause associated generator invoked means lazily computing lists values generator yields new values option maintaining state aurevoir quitting adieu similar yield quit statements sather finally use firstclass frames allows generators sideeffects caller environment used simulate variable arguments streamconsuming iterators however experience hairy control structures conniver found lead unintelligible programs agree hewitt 1977 found without paraphernalia hairy control structures possibility lists nonlocal gotos assignments values internal variables procedures conniver alternative hewitt proposes lazy evaluation using explicit delay pseudofunction lazy evaluation allows effective handling multiple recursive data structures also poses particularly difficult problem efficient implementations common lisp loop macro steele 1990 generalized iteration control structure contains every iteration primitive authors could imagine somewhat following pl1 tradition builtin features loop clauses loop facility language definition explicitly states currently specified portable method users add extensions loop facility prevents use loop macro support encapsulation datastructurespecific iteration procedures 42 cursors riders c iterators mentioned cursor objects way encapsulating iteration without additional language constructs riders similar idea introduced oberon wirth gutknecht 1992 generalized ethos szyperski 1992 idea define objects point container class may used retrieve successive elements interfaces include routines create initialize increment test completion attributes cursor object maintain current state iteration may simple single index arrays complex traversal stack hash table recording nodes already visited traversing trees graphs note ellis stroustrup 1990 call use cursor objects c iterators found cursors work quite well certain circumstances also become quite cumbersome require maintaining parallel cursor object hierarchy alongside container class hierarchy normally required explicitly create garbage collect cursor objects cursors semantically confusing since maintain location container indefinite period time container may change since storage associated cursor explicit inconvenient use describe nested recursive iteration abstraction sather delta 9 sieveaprimeintbool sieve successive primes yield true loop ddividesaprime yield false else yield sieveaprime primesint yield successive primes loop siever yield r end fig 1 sieve eratosthenes structures cursors explicitly describe implementation prevent number important optimizations inner loops iterators avoid problems cursors part container class state iterators maintained duration single loop iterators may arbitrarily nested support recursion like routines iterator implementation manages use storage use stack instead heap unless multiple recursive iterators finally even though sather language explicit pointers array iterators compile efficient code based pointer arithmetic 43 streams series iterators also share many characteristics streams abelson et al 1985 one class iterators form itert return value arguments yield potentially infinite stream values another class form itert single argument return value accept potentially infinite stream values way iterators suspend transfer control yielding corresponds well lazy evaluation semantics streams main difference iterators streams invocation iterator must consume one input produce one output iterators therefore always onetoone mappings within given loop sieve eratosthenes generating successive prime numbers used show power stream concept abelson et al 1985 conceptually simple algorithm control flow rather complex stream solution based stream takes stream argument filters later elements divisible first element iterators allow following implementation cf figure 1 note ddividesaprime example predicate returns true divides aprime without remainder false otherwise iterator sieve tests stream values passed yields true first value stream false later multiples value recursively calls next higher sieve values feeding sieve stream integers starting 2 leads recursive iterator yields true prime numbers efficient pedagogical way implement sieve eratosthenes sather hints expressive power iterators however important difference streams iterators whereas streams may passed around halfconsumed state state iterator confined calling loop statement even single call point within loop possible suspend iteration one loop resume internal state another loop variant sather development university karlsruhe germany satherk goos 1994 generalize iterators introducing firstclass stream objects retain state across loop termination common lisp incorporation series generators gatherers proposed defining iterative constructs steele 1990 constructs complex include large number builtin operations sather operations may implemented iterators encapsulated classes 44 coroutines generators different approach view iterators body loop communicating sequential processes hoare 1985 tightly coupled communication channels form arguments results iterators since neither preemption true parallel execution among iterators may model iterators loop body coroutines wirth 1983 precisely iterators may thought structured coroutines many languages coroutines call coroutines arbitrary fashion structured programming replaced undisciplined transfer control goto statements structured loop constructs iterators structured coroutines respect freedom passing control suspending coroutine may transfer control waiting coroutine case iterators flow control structured loop statement iterators pass control back either point call within calling loop end loop initialized loop entered signal return breaking loop coroutines added restriction always returning caller sometimes called generators semicoroutines hierarchical coroutines marlin 1980 iterators share property however streams generators activation state bound single call point within single loop instead generator may left halfconsumed state one point picked another mentioned section 43 possible iterators 45 blocks closures lambda expressions traditionally iteration abstraction supported objectoriented languages providing anonymous blocks goldberg robson 1985 lambda expressions abelson et al 1985 closures sussman steele 1975 container classes provide methods apply block part elements execution blockbased iterations controlled container class iterators control shared iterator calling loop example iteration abstraction sather delta 11 class treeftg attr private attr leftright treeftg inordert yields elements order voidself loop yield leftinorder end yield loop yield rightinorder end closed inordert yields order void loop yield inorder end yield void fringeothertreeftgbool returns whether self carry sequence fringe elements loop e1tclosed inorder e2totherclosed inorder voide1 return voide2 end e1e2 return false end return true fig 2 fringe problem traversing two binary trees inorder sequence determine whether contain elements either iterator loop body may abort iteration difference control becomes apparent trying iterate synchronously multiple data structures consider task comparing elements two trees according preorder traversal classical fringe problem defined hewitt 1977 simple solution using iterators shown figure 2 iterator inorder yield trees elements proper order using general technique closing iterators iterator closedinorder uses inorder yield sequence yields void quitting indicate end structure reached samefringe routine steps elements trees simultaneously stopping determined either trees equal fringes difference found one trees shorter fringe one trees kept track size closedinorder iterator would necessary kind situation one structure possible pass body routine one trees execution thus cases requiring traversal multiple structures use blocks closures impractical situation easily handled iterator construct approach cannot used clu allows single iterator per loop closures used implement generators multiple generators within common loop used traverse multiple structures simultaneously table number iterators loops sather compiler libraries number iterators number loops 285 532 163 percentage 29 54 17 also possible sather using bound routines bound iterators however cursors closures disadvantage unbounded lifetime closure state may compensated extensive compiletime analysis explicit association iterators loops solves problem syntactically 46 summary comparisons 1 four constructs commonly used iteration streams cursors builtin looping constructs common lisp variant complex explicitly passing loop body closure block otherwise main points comparing constructs sather iterators 1 cursors harder use less suitable compilerbased optimizations passed around 2 builtin loop constructs general enough 3 passing closures effectively support simultaneous traversal multiple data structures streams particular generators come closest sather iterators bound specific loop 5 experience real power iterators really seen context large system classes section describes experience iterators freely distributed sather compiler libraries last year sather 0 libraries contained several hundred classes iterators used extensively converting sather 1 many cases use iterators allowed us discover powerful new abstractions interacting class much iteration bookkeeping occurs iterator definitions rather loop many classes became dramatically smaller iterationintensive classes vectors matrices sometimes dropped less onethird former size using iterators bodies many routines could reduced concise single line code sather 1 compiler written entirely sather table shows number iterators found 980 loops occurring 107 version sather compiler libraries 39 thousand lines code builtin iterators break counted could replaced traditional constructs languages majority used least one nontrivial iterator validating importance iterators code 17 percent used two within loop clu iterators could used cases however even cases sather iterators eliminate need distinguished loop header allow iterators used directly expressions simplifying code clu iterators allow hot arguments possible express iterators set loops 151 15 percent used one iterators summary based suggestion one anonymous referees iteration abstraction sather delta 13 hot arguments could expressed clu cursor objects language problem semantics usually defined container modified iterate sather iterators problem many iterators libraries fail underlying data structure modified presently way compiler detect situations inserting extra runtime checks also problematic one must define conditions indicate misuse container iteratorsfor example setting flag iterating checking whenever container modified psather parallel extension sather concurrent systems general one ensure readerwriter locking appropriate data structure solutions tedious error prone fortunately experience bugs arisen frequently practice although may hold true novice sather programmers believe positive observation largely due structured nature iterators guaranteeing limited lifetime iteration state iterators powerful construct possible write obscure hardto understand code using sieve eratosthenes figure 1 example novices misunderstanding iterator calls share state simply name example code loop prints two identical columns elements self rather elements distributed two shorter columns 2 another pitfall failure foresee following code foo evaluated one time set set actually terminates loop loop bsetfoo end although seen misconceptions arise number individuals learning sather need explained finally although sather supports higherorder functions hence programming applicative style found iterators often provide cleaner solution iterators provide convenient lingua franca transmitting data disparate data structures without allocate space intermediate container object array linked list 6 conclusions presented sather iterators new approach encapsulating iteration shown several simple examples use iterators eliminate common errors combining initialization progression termination one abstraction need managed client code iterators proven useful practice used extensively standard sather libraries well user code found using iterators code becomes simpler easier read less error prone interfaces classes become concise satherk latter could expressed reusing stream object calls 14 delta stephan murer et al cursor classes abolished excited simplicity power iterators bring sather feel language designs could benefit well sather documentation compiler libraries available httpwwwicsiberkeleyedusather acknowledgments many people involved sather 1 design discussions ari huttunen particular made suggestions improved design iterators jerry feldman chucheow lim heinz schmidt also made useful suggestions furthermore would like thank urs holzle robert griesemer careful reading providing valuable comments structure article last least anonymous reviewers would like thank numerous comments led substantial improvements revised version article r structure interpretation computer programs annotated c viewing control structures patterns passing messages communicating sequential processes abstraction specification program development coroutines programming methodology conniver reference manual artificial intelligence memo 259a psather layered extensions objectoriented language efficient parallel computation introduction information processing language v paper p1929 sather language libraries sather 11 insight ethos objectorientation operating systems project oberonthe design operating system compiler revised october tr smalltalk80 language implementation communicating sequential processes abstraction specification program development structure interpretation computer programs annotated c reference manual common lisp language 2nd ed project oberon objectoriented software construction 2nd ed coroutines interpreter extended lambda calculus ctr stephen watt technique generic iteration optimization proceedings 2006 acm sigplan workshop generic programming september 1616 2006 portland oregon usa marcel weiher stphane ducasse higher order messaging proceedings 2005 conference dynamic languages symposium p2334 october 1818 2005 san diego california jed liu aaron kimball andrew c myers interruptible iterators acm sigplan notices v41 n1 p283294 january 2006 l hines n carnevale neuron simulation environment neural computation v9 n6 p11791209 aug 15 1997 peter h frhlich andreas gal michael franz supporting software composition programming language level science computer programming v56 n12 p4157 april 2005 karsten weihe software engineering perspective algorithmics acm computing surveys csur v33 n1 p89134 march 2001 douglas gregor sibylle schupp stllint lifting static checking languages libraries softwarepractice experience v36 n3 p225254 march 2006
minimal coverautomata finite languages coverautomaton finite language l sgr finite deterministic automaton dfa accepts words l possibly words longer word l minimal deterministic finite cover automaton dfca finite language l usually smaller size minimal dfa accepts l thus cover automata used reduce size representations finite languages practice paper describe efficient algorithm given dfa accepting finite language constructs minimal deterministic finite coverautomaton language also give algorithms boolean operations deterministic cover automata ie finite languages represent b introduction regular languages finite automata widely used many areas lexical analysis string matching circuit testing image compression parallel processing however many applications regular languages use actually finite languages number states finite automaton accepts finite language least one length longest word language even order exponential number restrict automaton accept exact given finite language allow accept extra words longer longest word language may obtain automaton number states research supported natural sciences engineering research council canada grants ogp0041630 preprint submitted elsevier preprint significantly reduced applications know maximum length words language systems usually keep track length input word anyway finite language use automaton plus integer check membership language basic idea behind cover automata finite languages informally coverautomaton finite language l sigma finite automaton accepts words l possibly words longer word l many cases minimal deterministic cover automaton finite language l much smaller size minimal dfa accept l thus cover automata used reduce size automata finite languages practice intuitively finite automaton accepts finite language exactly viewed structures following two functionalities 1 checking patterns words language 2 controlling lengths words highlevel programming language environment lengthcontrol function much easier implement counting integer using structures automaton furthermore system usually lengthcounting anyway therefore dfa accepting finite language may leave structures lengthcontrol function thus reduce complexity concept cover automata totally new similar concepts studied different contexts different purposes see exam ple 17410 previous work study descriptive complexity measure arbitrary languages called automaticity shallit et al 10 study consider cover automata implementing method may reduce size automata represent finite languages paper main result give efficient algorithm given finite language given deterministic finite automaton cover automaton constructs minimal cover automaton language note given finite language might several minimal cover automata equivalent morphism show however number states preliminaries let set mean cardinality elements called strings words empty string denoted w 2 jwj length x define l ordered set k 0 quasilexicographical order denoted oe defined x oe iff jxj jyj say x prefix denoted x p deterministic finite automaton dfa quintuple sigma q finite nonempty sets q transition function extend ffi q theta sigma q theta sigma usually denote ffi ffi language recognized automaton fg simplicity assume follows assume ffi total function ie automaton complete let l length longest words finite language l dfa called deterministic finite coverautomaton dfca l let q sigma ffi 0 f dfca finite language l say minimal dfca l every dfca l q q 0 q 2 q said accessible exists w 2 sigma ffi0 b q said useful coaccessible exists w 2 sigma ffiq w 2 f clear every dfa exists automaton 0 states 0 accessible one states useful sink state dfa 0 called reduced dfa 3 similarity sequences similarity sets section describe lsimilarity relation sigma generalization equivalence relation jl x jl xz 2 l iff yz 2 l z 2 sigma notion lsimilarity introduced 7 studied 4 etc paper lsimilarity used establish algorithms let sigma alphabet l sigma finite language l length longest l let x 2 sigma define following relations 1 x l z 2 sigma jxzj l jyzj l xz 2 l iff yz 2 l 2 x 6 l x l hold relation l called similarity relation respect l note relation l reflexive symmetric transitive exam ple let aabbg clear aab l aabb since aab 6 l baa since 2 l following lemma proved 4 finite language x following statements hold 1 x l x l z l z 2 x l l z x l z 3 x l y6 l z x6 l z x 6 l l z cannot say anything similarity relation x z example 2 let x may l z x l z l z x6 l z indeed choose finite language 1 set sigma called lsimilarity set x l every pair x 2 2 sequence words x called dissimilar sequence pair 3 dissimilar sequence x called canonical dissimilar sequence l exists partition sigma lsimilarity set 4 dissimilar sequence x l called maximal dissimilar sequence l dissimilar sequence theorem 4 dissimilar sequence l canonical dissimilar sequence l maximal dissimilar sequence l proof let l finite language let x canonical dissimilar sequence l corresponding partition sigma lsimilarity set let arbitrary dissimilar sequence l assume n lsimilarity set l j contradiction assumption n false conclude x maximal dissimilar sequence conversely let x dissimilar sequence l without loss generality suppose jx 1 j jx n j note 2 sigma l x least one maximal dissimilar sequence thus partition sigma remaining task proof show x set assume contrary ie 1 n exist y6 l z know x l x l z definition following three cases 1 jx 2 l z lemma 1 would contradict assumption 3 easy prove 6 x j z 6 x j j 6 using lemma 1 definition x replace x z obtain longer dissimilar sequence contradicts fact maximal dissimilar sequence l hence z x similarity set corollary 5 finite language l unique number nl number elements canonical dissimilar sequence l theorem 6 let 1 2 two lsimilarity sets x 1 x 2 shortest words 1 2 respectively x 1 l x 2 set proof suffices prove arbitrary word 1 arbitrary word 2 holds without loss generality assume jx 1 j jx 2 j know jx 1 1 l 2 lemma 1 1 4 similarity relations states clear therefore also define similarity well equivalence relations states dfa define state ie levelq length shortest path initial state q q 2 q denote xa qg minimum taken according quasi lexicographical order la fg automaton understood write x q instead xa q l q instead la q length x q equal levelq therefore levelq defined say equivalent q every w 2 sigma ffis w 2 f iff dfca finite language l let jg say p q state p lsimilar q every w 2 sigma lgammam ffip w 2 f iff ffiq w 2 f dfca finite language l let ffi0 proof let choose arbitrary w 2 sigma jxwj l jywj l jxj j jyj follows jwj l gamma since p q ffip w 2 f means xw 2 la hence x l lemma dfca finite language l let ffi0 proof let x l w 2 sigma lgammam ffip w 2 f ffi0 xw 2 f x l follows ffi0 yw 2 f ffiq w 2 f using symmetry get p q corollary 12 let q sigma ffi 0 f dfca finite language l let sigma ffi0 x 1 x 2 l 2 example 13 x 1 1 minimal ie jx conclusion corollary 12 true 3 following dfca l phi phi phi phi phi phi phi phi phi phi ja b r hy hy fig 1 x l always ffi0 x ffi 0 b l bab b6 l ba 2 l aa 2 l corollary 14 let q sigma ffi 0 f dfca finite language l p q levelp levelq q 2 f p 2 f lemma dfca finite language l let following statements true 1 p q p q 3 p p6 q s6 q proof apply lemma 1 corollary 14 lemma dfca finite language l let lsimilarity set therefore ffip w 2 f jwj l gamma hence p q ffip w 2 f w 2 l q sigma lgammam lemma dfca finite language l q construct dfca l ffis ffis 6 q 2 q 0 2 sigma thus minimal dfca l proof suffices prove 0 dfca l let l length longest words l assume consider word w 2 sigma l prove w 2 l iff prefix w 1 w ffi0 w shortest prefix w remaining suffices prove ffi 0 p w prove induction length w 2 first consider case construction 0 thus suppose statement holds jw consider case jw 2 exist u u shortest nonempty prefix w 2 ffip induction hypothesis lemma dfca l l x l proof let l length longest words l let x jl 0 z 2 sigma xz 2 l 0 iff yz 2 l 0 consider words z 2 sigma j xz j l j yz j l since xz 2 l iff yz 2 l therefore x l definition l corollary 19 let q sigma ffi 0 f dfca finite language l l la p ja q implies p q corollary 20 minimal dfca l minimal dfa proof let q sigma ffi 0 f minimal dfca finite language l suppose minimal dfa la exists p jl 0 q p q lemma 17 follows minimal dfca contradiction remark 21 let dfca l minimal dfa may minimal dfca l example 22 take dfas gammapsi automaton gammapsi fig 2 minimal dfa always minimal dfca dfa figure 2 minimal dfa dfca aag minimal dfca l since dfa b figure 2 minimal dfca l theorem 23 minimal dfca l exactly nl states proof let q sigma ffi 0 f dfca finite language l n suppose n nl exist q x p l x q definition nl p q lemma 14 thus minimal contradiction suppose nl n let canonical dissimilar sequence l exist contradiction therefore 5 construction minimal dfca first part section describe algorithm determines similarity relations states second part construct minimal dfca assuming similarity relation states known ordered dfa dfa ffii implies j states letters obviously dfa sink state 51 determining similarity relation states aim present algorithm determines similarity relations states finite language l define fg taken according quasilexicographical order automaton understood write fl instead respectively fl lemma finite language l p 2 proof assume j obviously ffip j jfl lemma accepting l 2 sigma ffip ffiq pa q proof let 2 sigma ffip r ffiq r jwj also xa qaw 2 l iff xa sw 2 l w 2 sigma jwj l gamma jx sj hence xa paw 2 l iff xa qaw 2 l w 2 sigma jwj l gamma maxfjxa rj jx sjg jx rj jx since 2 sigma chosen arbitrary conclude xa pw 2 l iff xa qw 2 l w 2 sigma jwj l gamma maxfjxa pj jx qjg ie xa p xa q therefore using lemma 11 get p q lemma 26 let accepting l exists 2 sigma ffip a6 ffiq p6 q proof suppose p q aw 2 sigma lgammam ffip aw 2 f iff definition ffip ffiq contradiction algorithm determining similarity relation states dfa dfca finite language based lemmas 25 26 however dfa dfca satisfy condition lemma 26 shall first transform given dfa dfca one dfca l construct minimal dfa language sigma l dfa b exact l states use standard cartesian product construction see eg 3 details dfa taking automata order eliminate inaccessible states obviously satisfies condition lemma 26 lemma 27 dfa c constructed proof lemma 28 dfa c constructed p q c p r proof p 2 gamma1 lemma obvious suppose q r r l follows lemma 29 dfa c constructed q gamma proof ffi c 2 fc 2 fc follows conclusion able present algorithm determines similarity relation states c note qc ordered p pb attaching state c list similar states ff fi 2 qc ff c fi ff fi fi stored list similar states ff assume reduced sink state 1 compute 2 initialize similarity relation specifying n gamma b n gamma 3 c create list list initialized 4 ff 2 following reversed order qc following assuming ff 2 c fi 2 list ffi c ff c ffi c fi 2 sigma ff c fi b put ff list list lemma 24 need determine similarity relations states c set step 2a follows lemma 28 2b lemma 29 step 4 lemma 15 remark 30 algorithm complexity theta l 2 n number states initial dfa dfca l maximum accepted length finite language l 52 construction minimal dfca input dfa c ff 2 qc set fig output dfca l define following 6 following g note constructions x useful proofs following min minimum operator x taken according lexicographical order according algorithm total ordering states qc p q also using construction ie total order qc follows lemma 31 sequence x constructed canonical ldissimilar sequence proof construct sets x g obviously follows x lsimilarity set let w 2 sigma 1imgamma1 partition q w partition sigma therefore canonical ldissimilar sequence corollary 32 automaton constructed minimal dfca l proof since number states equal number elements canonical ldissimilar sequence prove cover automaton l let w 2 sigma l ffi 0 w 2 fd iff ffi c 0 0 w 2 c dfca l 6 boolean operations shall use similar constructions 3 constructing dfca languages result boolean operations finite languages modifications suggested previous algorithm first construct dfca satisfies hypothesis lemma 26 afterwards minimize using general algorithm since minimization follow natural way shall present construction necessarily dfca let two dfca finite languages l l 2 61 intersection construct following dfa lg theorem 33 automaton constructed dfa proof following relations rest proof obvious 62 union construct following dfa r l r l theorem 34 automaton constructed dfa proof following relations rest proof obvious 63 symmetric difference construct following dfa fs r l r l theorem 35 automaton constructed dfa proof following relations exclusive w exclusive w 2 rest proof obvious 64 difference construct following dfa theorem 36 automaton constructed dfa proof following relations rest proof obvious open problems 1 try find better algorithm minimization prove minimization algorithm complexity find better algorithm determining similar states dfca l find better algorithms boolean operations dfca r uniform characterisations nonuniform complexity measures zone regular languages programming languages time complexity gap twoway probabilistic finitestate automata two memory bounds recognition primes automata introduction automata theory minimal nontrivial space space complexity probabilistic oneway turing machines running time recognise nonregular languages 2 way probabilistic automata class measures formal languages properties measure descriptional complexity theory automata state complexities basic operations regular languages finite automata behaviour synthesis state complexity intersection handbook formal languages tr uniform characterizations nonuniform complexity measures minimal nontrivial space complexity probabilistic oneway turing machines time complexity gap twoway probabilistic finitestate automata running time recognize nonregular languages 2way probabilistic automata state complexity intersection regular languages state complexities basic operations regular languages automaticity regular languages introduction automata theory languages computation theory automata ctr martin kappes frank niener succinct representations languages dfa different levels reliability theoretical computer science v330 n2 p299310 2 february 2005 martin kappes chandra r kintala tradeoffs reliability conciseness deterministic finite automata journal automata languages combinatorics v9 n23 p281292 september 2004
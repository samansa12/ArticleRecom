type system higherorder modules present type theory higherorder modules accounts many central issues module system design including translucency applicativity generativity modules firstclass values type system harmonizes design elements previous work resulting simple economical account modular programming main unifying principle treatment abstraction mechanisms computational effects language first provide complete practical formalization critical issues module system design b introduction design languages modular programming surprisingly delicate complex fundamental tension concert project supported national science foundation grant number 0121633 itrsysi language technology trustless software dissemination permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee popl03 january 1517 2003 new orleans louisiana usa acm 1581136285030001 500 desire separate program components relatively independent parts need integrate parts form coherent whole extent design modularity mechanisms independent underlying language 17 large extent two inseparable example languages poly morphism generics type abstraction require far complex module mechanisms without much work devoted design modular programming languages early work clu 19 modula family languages 34 2 particularly influential much effort gone design modular programming mechanisms ml family languages notably standard ml 23 objective caml 27 numerous extensions variations designs considered literature 21 18 28 31 5 despite perhaps substantial efforts field remained somewhat fragmented clear unifying theory modularity yet emerged several competing designs proposed often seemingly odds one another decisions often motivated pragmatic considerations engineering useful implementation fundamental considerations semantics type abstraction relationship design decisions completely clear clear account tradeoffs whether coherently combined single design goal paper provide simple unified formalism modular programming consolidates elucidates much work mentioned building substantial growing body work typetheoretic accounts language structure propose type theory higherorder program modules harmonizes enriches designs would suitable foundation next generation modular languages 11 design issues describing main technical features language useful review central issues design module systems ml issues extend language similar expressive power though tradeoffs may different different languages controlled abstraction modularity achieved using signatures interfaces mediate access program components role signature allow programmer hide type information selectively mechanism controlling type propagation translucency 11 14 transparency opacity limiting cases phase separation mllike module systems enjoy phase separation property 12 stating every module separable static part consisting type information dynamic part consisting executable code obtain fully expressive higherorder modules support abstraction essential build phase separation principle definition type equivalence generativity macqueen coined term generativity creation new types corresponding runtime instances abstraction example may wish define functor symboltable given parameters creates new symbol table natural symbol table module export abstract type symbols dynamically created insertion used subsequent retrieval preclude using symbols one symbol table index another generativity essentialeach instance hash table must yield new symbol type distinct others even applied twice parameters separate compilation one goal module system design support separate compilation 14 achieved ensuring interactions among modules mediated interfaces capture information known clients separately compiled modules principal signatures principal expressive signature module captures known module type checking may used proxy module purposes separate compilation many type checking algorithms including one given paper compute principal signatures modules modules firstclass values modules ml second class sense cannot computed results ordinary runtime computation useful treat module firstclass value stored data structure passed ordinary function argument result 11 24 hidden types introducing local hidden abstract type within scope requires types externally visible components avoid mention abstract type avoidance problem often stumbling block module system design since expressive languages best way avoid type variable 12 type system modules type system proposed takes account design issues consolidates harmonizes design elements previously seen disparate single framework example rather regard generativity abstract types alternative nongenerative types make mechanisms available language support generative applicative functors admit translucent signatures support separate compilation able accommodate modules firstclass values 24 29 generality achieved simple accumulation features rather isolating key mechanisms com bined yield flexible expressive implementable type system modules specifically following mechanisms crucial singletons propagation type sharing handled singleton signatures variant aspinalls stone harpers singleton kinds 33 32 1 singletons provide simple orthogonal treatment sharing captures full equational theory types higherorder module system subtyping previous module system provided abstraction full equational theory supported singletons 1 consequently none provided optimal propagation type information static module equivalence semantics singleton signatures dependent compiletime notion equivalence modules ensure phase distinction respected define module equivalence mean equivalence static compo nents ignoring runtime aspects subtyping signature subtyping used model forgetting type sharing essential part signature matching coercive aspects signature matching dropping fields specialization polymorphic values omitted since required coercions definable language purity impurity type system classifies module expressions pure effectfree impure effectful forms ensure proper enforcement abstraction impure modules incomparable may compared equality module nonprojectible may type components projected follows impure modules also nonsubstitutable may substituted module variable signature abstraction sealing modules sealed signature impose type abstraction 11 regarded impure words sealing regarded pro forma computational effect consistent informal idea generativity involves generation new types run time moreover ensures sealed modules incomparable nonprojectible sufficient ensure proper semantics type abstraction totality partiality functors labstractions level modules functor whose body pure said total otherwise partial follows application pure total functor pure argument pure whereas application pure partial functor pure argument impure partial functors naturally generative meaning abstract types result new instance total functors applicative meaning equal arguments yield equal types result generative functors obtained without resort generative stamps 23 21 weak strong sealing since sealing induces computational effect partial functors may contain sealed sub structures significantly weakens utility total functors overcome limitation distinguish two forms effect static dynamic two forms sealing weak strong weak sealing induces static effect think occurring type checking strong sealing induces dynamic effect think occurring execution dynamic effects induce partiality static effects preserve totality existential signatures manner similar shao 31 type system carefully crafted circumvent avoidance prob lem every module enjoys principal signature however requires imposing restrictions programmer lift restrictions propose use existential signatures provide principal signatures none would otherwise exist show existential signatures typetheoretically illbehaved 1 typically omitted equations missed restrictions named form valuability prevent programmers writing code whose typeability would depend equations first place 4 terms e signatures modules let 1 ms ms contexts g gss figure 1 syntax general restrict use wellbehaved setting style harper stone 13 propose use elaboration algorithm external language may incur avoidance problem type system packaged modules modules system secondclass sense language modules separate language terms however following mitchell et al 24 russo 29 provide way packaging module firstclass value prior work packaged modules typically given existential type whose closedscope elimination construct make awkward programming instead account type generativity allows us employ natural openscope elimination con struct whereby unpackaging packaged module engenders dynamic effect features combine naturally form general language modular programming would little use absence practical implementation strategy previous attempts encountered difficulties undecidability 11 incompleteness type checking 27 contrast formalism leads practical implementable programming language rest paper structured follows section 2 present core type system higherorder modules including intuition behind design brief description decidable typechecking algorithm section 3 discuss programming importance weak strong forms sealing section 4 explain avoidance problem circumvented using elaboration algorithm section 5 present simple orthogonal extension core system provide support packaging modules firstclass values fi nally section 6 compare system related work section 7 conclude technical development begin technical development presenting syntax language figure 1 language consists four syntactic classes terms types modules signatures serve types modules language explicitly include higherorder type constructors kinds ordinarily serve constructors types language roles constructors kinds subsumed modules signatures contexts bind module variables signatures usual consider alphaequivalent expressions identical write captureavoiding substitution expression types three basic types language product standard function type psst type functions accept module argument signature return value type possibly containing usual appear free write psst st convention used dependent products signature class well finally module containing exactly one type say signature type extracted typ fullfeatured language would support variety additional types well terms term language contains natural introduction elimination constructs recursive functions products ad dition module containing exactly one value say signature type value extracted val f appear free e write fix f sste lsse conventional forms functions polymorphic function built module functions ordinary functions built using modules containing single value polymorphic functions built using modules containing single type et signatures seven basic signatures language atomic signature type atomic module containing single type atomic signature type atomic module containing single term atomic modules written e respectively omit type label atomic modules clear context trivial atomic signature 1 type trivial atomic module functor signatures p tot ss 1 2 p par ss 1 2 express type functors accept argument signature 1 return result signature 2 possibly containing reason two different p signatures distinguish total partial functors discuss detail convenience take p without superscript synonymous p tot appear free 2 write pss 1 2 1 2 structure signature sss 1 2 type pair modules lefthand component signature 1 righthand component signature 2 refers lefthand com ponent usual appear free 2 write singleton signature sm used express type sharing infor mation classifies modules signature statically equivalent two modules considered statically equivalent equal modulo term components type fields must agree term fields may differ singletons signatures provided primitively defined using basic singleton described stone harper 33 definition signature containing modules equal signature given figure 5 signature sig type type u val end compiled figure 2 ml signature example modules module syntax contains module variables atomic modules usual introduction elimination constructs p signatures except modules introduced stands 1 may appear free appear free 2 omitted introduction elimination constructs provided singleton signatures singletons introduced eliminated rules static semantics judged equivalent belongs vice versa remaining module constructs strong sealing written ms weak sealing written ms module sealed either strongly weakly result opaque opaque mean client module may depend details implementation exposed signature distinction strong weak sealing discussed detail although higherorder type constructors appear explicitly language faithfully represented language unsealed modules containing type components example kind represented signature constructor lat int aint represented module lst examples mlstyle signatures structures may expressed language appear figures 2 3 comparability projectibility two closely related issues crucial design module system supporting type abstraction 1 module compared equivalence another module 2 type component projected module used type say module comparable iff compared equivalence another module module projectible type components may projected used type expres sions literature presentations emphasize projectibil ity 11 14 15 structure struct structure struct type string val val end compiled figure 3 ml structure example simple analysis properties comparability projectibil ity suggests closely related suppose pro jectible module signature typ type since type equality equivalence relation type may compared particular typ another projectible module signature since typ typ fully determine effect comparing equiva lence suggests projectible modules regarded comparable type checking purposes conversely comparable module extensionality equivalent typ sensible also projectible purity impurity design module system rests semantic notions purity impurity induced computational effects motivate design first recall firstclass module system harper lillibridges 11 impure module expressions yield distinct type components time evaluated example module expression might consult state world yielding different module outcome test type components module statically welldetermined hence admitted type expressions much less compared equiv alence hand even general framework pure effectfree modules may safely regarded comparable projectible secondclass module system examples fact expressible nevertheless find useful classify modules according purity 2 classification semantic sense defined judgments calculus rather syntactic sense determined solely form expression semantic approach important correct account type abstraction fullfeatured module language axiomatization purity impurity system based set rules takes account types expressions well syntactic forms type system conservative assumes worst impure module expression ruling 2 moreover section 5 introduce means recreate examples setting making essential use classification system incomparable nonprojectible even type components fact statically welldetermined see shortly important enforcing type abstraction well ensuring soundness presence firstclass modules addition since sound deem pure module expressions comparable projectible permissive possible without violating soundness abstraction identify comparability projectibility purity finally note module judged pure based whether type components welldetermined independent whether term components computational effects literature different accounts higherorder modules provide different classes pure modules example harper lil libridges firstclass module system 11 syntactic values considered pure leroys secondclass module calculi 14 15 purity limited syntactic category paths harper et als early phasedistinction calculus 12 modules deemed pure means abstraction provided abstraction via sealing principal means defining abstract types sealing written ms sealing prevents client depending identities type components specified opaquelywith signature point view module equivalence means sealed module considered incompara ble see suppose regarded comparable presumably could deemed equivalent since underlying type components different however since module equivalence reflexive comparable must deemed equivalent would mean type system would distinguish two opaque modules based underlying implementation violation type abstraction significant advantage judgmental approach purity affords natural means ensuring sealed module comparable namely judge impure amounts regarding sealing pro forma runtime effect even though actual effect occurs execution time ensure abstraction violations one illustrated ruled also show section 3 allows type system track runtime generation new types applicative generative functors functors standard ml generative sense abstract type result functor generated afresh instance functor regardless whether arguments instance equivalent functors objective caml however applicative sense preserve equivalence applied equivalent arguments yield equivalent results particular abstract types result functor two applications argument continuing analogy computational effects deem functor whose body pure total otherwise partial application pure total functor pure argument pure hence comparable total functors applicative sense application pure total functor two equivalent pure modules yields equivalent pure modules applications pure hence comparable partial functors hand always yield impure modules applied therefore respect equivalence arguments results im pure even comparable ensuring instance yields distinct result distinguish signatures total applicative partial gen erative functors total functors p signatures whereas partial functors p par signatures subtyping relation defined every total functor may regarded degenerately partial functor weak strong sealing system identify applicative functors total ones generative functors partial ones make work however must refine notion effect sealing regarded inducing runtime effect impossible employ abstraction within body total func tor renders body impure may seal entire functor total functor signature impose abstraction ensures exported types functor held abstract clients functor permit substructure body functor held abstract clients functor remainder functor body solution distinguish two forms sealingstrong written ms weak written ms impose abstraction sense limiting type propagation explicitly specified ascribed signature regarding forms sealing inducing impurity however support useful class applicative functors distinguish static dynamic effects weak sealing induces static effect whereas strong sealing induces dynamic effect significance distinction lies definition total partial functors functor whose body involves dynamic effect ie dynamically impure ruled partial hence generative thus strong sealing within functor body induces generativity functor functor whose body either pure involves static effect ie dynamically pure ruled total hence applicative ensures applicative functors may use abstraction within bodies without incurring generative behavior methodological importance distinction discussed section 3 dynamic effect may thought one occurs exe cution whereas static effect one occurs type check ing dynamic effects suspended inside labstraction functor abstractions dynamically pure however applied dynamic effects inside functor released application dynamically impure hand static effects occur type checking hence suspended l abstraction released application formalization typing judgment system written purity classifier k drawn following fourpoint lattice point p indicates pure hence comparable pro jectible indicates dynamic purity indicates static purity w indicates wellformedness purity information hence purity judgment prove convenient typing rules exploit ordering written meets joins lattice p taken bottom w taken top also sometimes find convenient use notation p ss 1 2 functor signature either total partial depending whether figure 4 key typing rules key rules summarized figure 4 pure modules dynamically pure statically pure least wellformed rule 1 strongly sealed modules neither statically dynamically pure 2 weakly sealed modules statically pure dynamically pure body 3 applicative functors must dynamically pure bodies 5 generative functors restriction 6 applicative functors may used generative ones 7 variables pure 4 lambdas dynamically pure 5 6 application applicative functor pure functor 8 application generative functor best statically pure 9 finally purity module preserved signature subsumption 12 complete set typing rules given appendix rules functor application rules 8 require functor argument pure functor argument substituted functors codomain produce result signa ture substitution impure modules variables always pure turn wellformed signatures illformed ones example typ becomes illformed impure module substituted alternative rule proposed harper lillibridge 11 resolves issue induces avoidance problem discuss section 4 therefore functor applied impure argument argument must first bound variable pure similarly projection second component pair restricted pure pairs rule 11 restriction need made projection first component rule 10 since substitution involved static equivalence foregoing discussion frequently made reference notion module equivalence without specifying means key design decision module calculus define two comparable modules deemed equivalent different module systems arise different notions equivalence pure module signature possible extract type component type checking depends essentially matter types equal must consider typ equal typ simplest answer would regard exactly modules equal naive cannot general determine two modules equal suppose f latter equality undecidable general characteristic feature second class module systems respect phase distinction 12 compiletime runtime computation property module system states type equivalence must decidable independently term equivalence intuitively plausible since secondclass module system provides means type component module depend term component happenstance result careful design see section 5 matter subtle appears based principle define module equivalence equiv alence type checking purposes static equivalence roughly speaking two modules deemed equivalent whenever agree corresponding type components 3 write module equivalence judgment g rules static equivalence atomic modules expected ones atomic type components must equal atomic term components need since generative production new types generative functor notionally dynamic operation generative functors static components compare thus pure generative functors always statically equivalent atomic term modules complete set equivalence rules given appendix aside discussion module equivalence refutes misconception firstclass modules general secondclass modules fact expressiveness first secondclass modules incomparable firstclass modules obvious advantage firstclass however since type components firstclass module depend runtime computations impossible get static module equivalence one 3 phase distinction calculus harper et al 12 includes nonstandard equality rules phasesplitting modules structures stat dyn consisting static component stat dynamic component dyn static equivalence amounts saying stat stat system however identify functors structures must use dynamic equivalence instead words one cannot phasesplit modules harper et al 12 consequently firstclass modules cannot propagate much type information secondclass modules singleton signatures type sharing information expressed language using singleton signatures 33 derivative translucent sums 11 14 18 illustration use singleton signatures express type sharing appears figure 2 type system allows deduction equivalences membership singleton signatures vice versa also allows forgetting singleton information using subsignature relation deductions follow using primitive rules type system since tures follow definitions given figure 5 beyond expressing sharing singletons useful selfifica tion 11 instance variable bound signature given fully transparent signature ss fact essential existence principal signatures type checking algorithm note since singleton signatures express static equivalence information formation singleton signatures restricted pure modules thus pure modules selfi fied harper lillibridge 11 leroy 14 singleton signatures complicate equivalence checking since equivalence depend context example lst int lst obviously inequivalent signature ever using subsignatures also given signature signature equivalent since return result given permissible argument int example illustrates context sensitivity equivalence provides type equalities would hold equivalence strictly context insensitive thereby allowing propagation additional type information example types typflst int typ flst equal could case contextinsensitive regime subtle technical point arises use higherorder singletons defined figure 5 suppose f intuitively contains modules equivalent f take members fs domain return thing f formally speaking however canonical member signature f etaexpansion lst fs fact obvious f belongs ensure f belongs singleton signature type system following stone harper 33 includes extensional typing rule using rule f belongs pst sf function fs belongs sf similar extensional typing rule provided products possible need ms figure 5 singletons higher signatures rules could avoided making higherorder singletons primitive explored metatheoretic implications change since module higherorder singleton signature fully transparent obviously projectible comparable hence could judged pure even would otherwise classified impure instance general problem recognizing benign effects need disturb purity since purity judgment framework could readily incorporate extensions capture situations pursue matter type checking type system enjoys sound complete effective type checking algorithm algorithm comes three main parts first algorithm synthesizing principal ie minimal signature module second algorithm checking subsignature relationships third algorithm deciding equivalence modules types module typechecking proceeds usual manner synthesizing principal signature module checking subsignature intended signature signature synthesis algorithm given appendix b correctness theorems stated main judgment signature synthesis g k states ms principal signature ms purity inferred k subsignature checking syntaxdirected easy given algorithm checking module equivalence module equivalence arises two singleton signatures compared subsigna ture relation equivalence algorithm closely based stone harpers algorithm 33 type constructor equivalence presence singleton kinds space considerations preclude discussion algorithm full details algorithms proofs appear companion technical report 7 theorem 21 soundness g theorem 22 completeness g note since synthesis algorithm deterministic follows theorem 22 principal signatures exist finally since synthesis algorithm convenience presented terms inference rules require one result stating really algorithm theorem 23 effectiveness g decidable whether exist k g k signature symbol sig type symbol val string symbol string symbol val symbol string symbol string val functor symboltablefun symbol struct val table string array allocate internal hash table arrayarray initial size none fun string symbol lookup insert x fun symbol string case arraysub table n none raise fail bad symbol structure figure 6 strong sealing example 3 strong weak sealing generativity essential providing necessary degree abstraction presence effects module sideeffects allocation storage abstraction may demand types generated correspondence storage allocation order ensure elements types relate local store store another instance consider example symbol table example given figure 6 symbol table contains abstract type symbol operations terconverting symbols strings equality test presumably faster available strings implementation creates internal hash table defines symbols indices internal table intention implementation fail exception never raised however depends generativity symbol type another instance symboltable2 created types symboltablesymbol symboltable2symbol considered equal symboltable could asked interpret indices symboltable2s table thereby causing failure thus essential symboltablesymbol symboltable2symbol considered unequal symbol table example demonstrates importance strong sealing encoding generative abstract types stateful modules generativity necessary however purely functional mod ules leroy 15 gives several examples modules motivation adoption applicative functors instance one may wish implement persistent sets using ordered lists figure 7 signature sig type elem val compare elem elem order signature persistent sets sig type elem type set val empty set val insert elem set set struct list structure struct val structure structure figure 7 weak sealing example exhibits purely functional setfun functor parameterized ordered element type whose implementation abstract set type sealed setfun instantiated multiple timeseg different client moduleswith element type useful resulting abstract set types seen interchangeable system setfun made applicative still opaque weakly sealing body specifically intset1set intset2set equivalent setfunintordset type wellformed setfun applicative functor sig nature setfun intord variables pure recall functor containing weak sealing impure must bound variable used applicatively astute reader may notice weak sealing truly necessary setfun example fact one achieve effect code figure 7 leaving body functor unsealed strongly sealing functor applicative functor signature binding setfun technique employed shao 31 encoding applicative functors system lacks analogue weak sealing failing approach works functor body fully transparentin absence weak sealing opaque substructures would strongly sealed preventing functor given applicative signature best examples need opaque substructures applicative functors provided interpretation ml datatypes abstract types 13 standard ml caml datatypes opaque sense representation recursive sum types exposed thus distinct instances datatype declaration create distinct types standard ml caml differ however whether datatypes generative presence applicative functors absent standard ml excellent reason datatypes generativenamely generative interpretation would prevent datatypes appearing bodies applicative functors would severely diminish utility applicative functors particularly since ml recursive types provided datatype mechanism example implementation setfun splay trees using datatype declaration define tree type would require use weak sealing reasons strong sealing substitute weak sealing neither weak sealing substitute strong leroy 15 ob served functorfree code generativity simulated call weak sealing seen framework observing dynamic purity provides extra privileges absence functors functors however strong sealing necessary provide true generativity nevertheless worth noting strong sealing definable terms constructs language weak sealing particular define strong sealing using combination weak sealing generative functor application follows existence encoding diminish importance strong sealing made primitive language regardless 4 avoidance problem rules type system particularly rules 8 9 11 figure careful ensure substituted modules always pure expense requiring functor secondprojection arguments pure necessary result substituting impure module wellformed signature ill formed thus apply functor impure argument one must letbind argument apply functor resulting pure variable similar restriction imposed shao 31 harper lillibridge 11 propose alternative softens restriction harper lillibridges proposal expressed terms include nondependent typing rule without purity restriction 2 pure rule carries force dependent rule exploiting singleton signatures contravariance functor signatures 2 impure rule expressive typing rule application still occur however exploit rule type checker must find nondependent supersignature suitable application 2 avoidance problem 9 18 best way example consider signature obtain supersignature avoiding variable must forget first component constant function therefore say second component equal first components result particular argument thus type may promote supersignature gives us infinite array choices choices superior obvious none comparable since f abstract thus minimal supersignature avoiding absence minimal signatures problem means obvious way perform type checking type system circumvent avoidance problem requiring arguments functor application secondprojection pure thereby eliminating need find nondependent super signatures provide let construct operations still applied impure modules shown result type theory enjoy principal signatures achieve however let construct must labeled result signature mentioning variable bound otherwise avoidance problem rearises essentially requires every functor application projection involving impure argument labelled result signature well leading potentially unacceptable syntactic overhead practice fortunately programs systematically rewritten avoid problem describe next 41 elaboration existential signatures consider unannotated let expression let pure let expression given minimal signature 2 1 otherwise left variable leaving scope minimal supersignature 2 mentioning however rewrite let expression may give signature sss 1 2 avoidance problem arises similarly functor application fm rewritten mfs given signature sss 1 2 following harper stone 13 propose use elaboration algorithm systematize rewritings elaborator takes code written external language supports unannotated lets well impure functor application secondprojection produces code written type system since elaborator rewrites modules manner changes signatures also must take responsibility converting modules back expected signature wherever required means elabora tor must track pairs real invented elaborator circumvent avoidance problem elaborator using types elaborator invents pair circumvent avoidance problem gives signature using existential rather internal language ss 1 2 means thing sss 1 2 elaborator treats two signatures differently elaborator expects say functor encounters sss 1 2 generates type error however encounters ss 1 2 extracts 2 component elab orators invariants ensure always looking expected functor space considerations preclude details elaboration algorithm appear companion technical report 7 sense elaborator solves avoidance problem introducing existential signatures serve place nonexistent minimal supersignatures mentioning variable light natural question whether need elaborator could eliminated making existential signatures primitive type system one natural way govern primitive existentials introduction elimination rules rules avoidance problem could solved least supersignature 2 mentioning ss 1 would ss 1 2 unfortunately rules particularly first make type checking undecidable example queries lsst holds exists pure types tms ms equal thus deciding subsignature equivalence queries presence existentials would hard higherorder unification known undecidable 10 42 syntactic principal signatures argued reasons related separate compilation principal signatures expressible syntax available programmer provides strongest support separate compilation programmer break program point write interface expresses information compiler could determined point strong support appear vital practice since systems objective caml standard ml new jerseys higherorder modules used successfully time without principal signatures nevertheless desirable property type system ie internal language provide syntactic principal signatures since principal signatures exist syntax available programmer however elaborators external language provide syntax existential signatures appear elaborator signatures thought principal signatures external modules thus say basic type system provides syntactic principal signatures external language external language programmer permitted write existential signatures elaborating code requires elaborator decide whether coerced belong ss 1 2 turn requires elaborator produce determining whether exists requires elaborator solve undecidable higherorder unification problem tm equal thus allow programmerspecified existential signatures greatest possible generality would make elaboration undecidable partial measures may possible discuss packaging modules firstclass values desirable modules usable firstclass values useful make possible choose run time efficient implementation signature particular data set example sparse dense representations arrays however fully general firstclass modules present difficulties static typing 18 one practical approach modules firstclass values suggested mitchell et al 24 propose secondclass modules automatically wrapped existential packages 25 obtain firstclass values similar approach modules firstclass values described russo implemented moscow ml 29 existentialpackaging approach modules firstclass values built language write type packaged module packaging construct pack elimination packaged modules existentials performed using closedscope unpacking construct may defined follows pack def unpack e ss compare definition standard encoding existential type bt abtaa main limitation existentiallypackaged modules closedscope elimination construct observed repeatedly literature 20 3 18 construct restrictive useful one unpack e ss e result type may mention consequence functions packaged modules may dependent result type may mention argument deficiency mitigated language ability write functions unpackaged secondclass mod ules given dependent type pssts instead another problem closedscope elimination construct term package type cannot unpacked standalone secondclass module unpacked inside enclosing term unpacking packaged module creates abstract type separate scope packages must unpacked early stage ensure coherence among clients leading scope inversions awkward manage practice desire therefore new module construct form unpack e coerces firstclass package e type back secondclass module signature following example illustrates adding construct carelessly lead unsoundness module module module note argument functor f atomic term module arguments f statically equivalent f given applicative signature x 1 x 2 deemed equivalent even original modules 1 2 thus f must types terms e pack modules unpack e pack ss figure 8 packaged module extension deemed generative turn requires unpack construct induce dynamic effect packaged modules admit improved unpacking construct definable core language constitute simple orthogonal extension type system complicate type checking syntax typing rules extension given figure 8 note closedscope unpacking construct definable intuitively unpacking generative module unpacked arbitrary term whose type components may depend runtime conditions core system presented section 2 generativity induced strong sealing merely pro forma effectthe language supporting secondclass mod ules provided way type components module actually generated run time type system however treats dynamic effects truly dynamic thus scales easily handle real runtime type generation enabled extension figure 8 6 related work harper mitchell moggi 12 pioneered theory phase sep aration fundamental achieving maximal type propagation higherorder module systems nonstandard equational rules identify higherorder modules primitive phase split ones similar spirit though different detail notion static module equivalence one may view system subsystem sealing mechanism consequently modules pure macqueen tofte 21 proposed higherorder module extension original definition standard ml 22 implemented standard ml new jersey compiler semantics involves twophase elaboration process higherorder functors reelaborated application take advantage additional information arguments advantage balanced disadvantage inhibiting type propagation presence separate compilation since functors compiled separately applications cannot reelaborated thorough comparison difficult macqueen tofte employ stampbased semantics difficult transfer setting focusing controlled abstraction largely neglecting higherorder modules harper lillibridge 11 leroy 14 16 introduced closely related concepts translucent sums manifest types mechanisms served basis module system revised definition standard ml 1997 23 harper stone 13 formalized elaboration standard ml 1997 programs translucent sums calculus deal avoidance problem harper stone rely elaborator mechanisms similar harper stone language viewed subsystem functors generative strong sealing supported leroy introduced notion applicative functor 15 enables one give fully transparent signatures many higherorder functors leroys formalism may seen defining purity syntactic restriction functor applications appearing type paths must named form one hand restriction provides weak form structure sharing sense abstract type fxt result applying f module named x hand restriction prevents system capturing full equational theory higherorder functors since equations expressed named form 4 together manifest types applicative functors form basis module system objective caml 27 manifest type formalism like translucent sum formalism address avoidance prob lem consequently lacks principal signatures recently russo thesis 28 formalized two separate module languages one close model sml module system higherorder module system applicative functors along lines ocaml abandoning named form restriction russos two languages viewed subsystems first supporting strong sealing second supporting weak sealing adopt use existential signatures address avoidance problem although russo also used existentials model generativity russos thesis also describes extension sml packaging modules firstclass values extension similar existential packaging approach discussed beginning section 5 therefore suffers limitations closedscope unpacking construct russo defined two languages separately implemented higherorder module system experimental extension moscow ml compiler 26 combining two languages without distinguishing static dynamic effects unfortunate consequence moscow ml higherorder module system places restrictions body applicative particular one defeat generativity generative functor etaexpanding applicative one exploiting uncovers unsoundness language 6 retrospect clear analysis one cannot convert partial total functor shao 31 proposed single type system modules supporting applicative generative functors roughly speaking shaos system may viewed subsystem based exclusively strong sealing dynamic effects supporting p p par signatures observed section 3 means bodies applicative functors may contain opaque substructures datatypes shaos system like circumvents avoidance problem section 4 restricting functor application projection pure arguments must paths system eliminating implicit subsumption amounts requiring let expressions annotated system seems likely elaboration techniques could well applied shaos system lift restrictions expense syntactic principal signatures shao also observes fully transparent functors may regarded applicative instance general problem recognizing benign effects described section 2 7 conclusion type systems firstorder module systems reasonably well understood contrast previous work typetheoretic higherorder modules left field fragmented state various competing designs clear statement tradeoffs designs state field made difficult choose one design another left erroneous impression tradeoffs actually exist example previous design supports sound generative applicative functors opaque subcomponents language seeks unify field providing practical type system higherorder modules simultaneously supports key functionality preceding module systems process dispel misconceptions tradeoff fully expressive generative applicative functors thereby eliminating dilemmas facing language designers nevertheless several important issues modular programming go beyond scope type theory chief among structure sharing original version standard ml 22 included notion module equivalence sensitive dynamic well static parts module although notion would violate phase distinction might possible formulate variation system takes account dynamic equivalence conservative fashion possible simulate structure sharing elab orator add abstract type structure serve compiletime name structure however would merely elaboration convention intrinsic account structure sharing within type theory recursive modules important direction future research integrate recursive modules 8 5 30 present framework chief difficulty achieve practical type checking presence general recursively dependent signatures isolate practical sublanguage avoids problems r type systems modular programs specifications modula3 type system abstract types dot notation sound complete elimination singleton kinds recursive module moscow mls higherorder modules un sound type system higherorder modules expanded version cool modules hot languages bounded existentials minimal typing undecidability secondorder unification problem manifest types applicative functors fully transparent higherorder modules syntactic theory type generativity sharing modular module system translucent sums foundation higherorder module systems abstraction specification program development using dependent types express modular structure semantics higherorder functors definition standard ml david mac queen extension standard ml modules subtyping inheritance abstract types existential type types modules recursive structures standard ml transparent modules fully syntactic signa tures singleton kinds singleton types deciding type equivalence language singleton kinds programming modula2 tr abstraction specification program development abstract types existential type modulamyampersandndash3 type system higherorder modules phase distinction extension standard ml modules subtyping inheritance manifest types modules separate compilation typetheoretic approach higherorder modules sharing applicative functors fully transparent higherorder modules bounded existentials minimal typing units recursive module transparent modules fully syntatic signatures deciding type equivalence language singleton kinds typetheoretic interpretation standard ml recursive structures standard ml using dependent types express modular structure definition standard ml semantics higherorder functors sound complete elimination singleton kinds firstclass structures standard ml singleton kinds singleton types ctr oleg kiselyov chungchieh lightweight static capabilities electronic notes theoretical computer science entcs v174 n7 p79104 june 2007 norman ramsey kathleen fisher paul govereau expressive language signatures acm sigplan notices v40 n9 september 2005 karl crary sound complete elimination singleton kinds acm transactions computational logic tocl v8 n2 p8es april 2007 manuel chakravarty gabriele keller simon peyton jones associated type synonyms acm sigplan notices v40 n9 september 2005 dimitrios vytiniotis geoffrey washburn stephanie weirich open shut typecase proceedings 2005 acm sigplan international workshop types languages design implementation p1324 january 1010 2005 long beach california usa derek dreyer type system wellfounded recursion acm sigplan notices v39 n1 p293305 january 2004 andreas rossberg generativity dynamic opacity abstract types proceedings 5th acm sigplan international conference principles practice declaritive programming p241252 august 2729 2003 uppsala sweden derek dreyer robert harper manuel chakravarty gabriele keller modular type classes acm sigplan notices v42 n1 january 2007 daniel k lee karl crary robert harper towards mechanized metatheory standard ml acm sigplan notices v42 n1 january 2007 derek dreyer recursive type generativity acm sigplan notices v40 n9 september 2005 eijiro sumii benjamin c pierce bisimulation dynamic sealing theoretical computer science v375 n13 p169192 may 2007 eijiro sumii benjamin c pierce bisimulation dynamic sealing acm sigplan notices v39 n1 p161172 january 2004 james j leifer gilles peskine peter sewell keith wansbrough global abstractionsafe marshalling hash types acm sigplan notices v38 n9 p8798 september manuel chakravarty gabriele keller simon peyton jones simon marlow associated types class acm sigplan notices v40 n1 p113 january 2005 andreas rossberg missing link dynamic components ml acm sigplan notices v41 n9 september 2006 owens matthew flatt structures functors modules units acm sigplan notices v41 n9 september 2006 john billings peter sewell mark shinwell rok strnia typesafe distributed programming ocaml proceedings 2006 workshop ml september 1616 2006 portland oregon usa martin sulzmann manuel chakravarty simon peyton jones kevin donnelly system f type equality coercions proceedings 2007 acm sigplan international workshop types languages design implementation january 1616 2007 nice nice france
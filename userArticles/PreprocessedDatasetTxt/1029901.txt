efficient incremental algorithms dynamic detection likely invariants dynamic detection likely invariants program analysis generalizes observed values hypothesize program properties reported program properties set likely invariants program also known operational abstraction operational abstractions useful testing verification bug detection refactoring comparing behavior many tasks previous techniques dynamic invariant detection scale poorly report properties incremental algorithms attractive process observed value thus scale well data sizes previous incremental algorithms checked reported small number properties paper takes steps toward correcting problem paper presents two new incremental algorithms invariant detection compares analytically experimentally two existing algorithms furthermore paper presents four optimizations shows implement context incremental algorithms result scalable invariant detection sacrifice functionality b introduction paper presents evaluates algorithms optimizations obtaining operational abstraction formal description properties held series program runs expected hold future runs task generating operational abstraction also known dynamic detection likely invariants dynamic invariant detection dynamic invariant detection important practical prob lem operational abstractions used verifying safety properties 35 30 31 automating theoremproving 27 28 identifying refactoring opportunities 19 predicate abstraction 8 9 generating test cases 38 39 13 14 selecting prioritizing test cases 16 explaining test failures 12 predicting incompatibilities permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee sigsoft04fse12 oct 31nov 6 2004 newport beach ca usa component upgrades 24 25 error detection 34 15 33 23 4 error isolation 37 21 choosing modalities 22 among tasks dynamic invariant detection independently implemented several research groups related tools also produce formal descriptions runtime behavior seen wide use see section 10 dynamic invariant detection valuable implementing efficiently challenging naive implementation straightforward fails scale problems substantial size key parameters control runtime runtime subject program longerrunning program produces data analyzed number variables fields examined size variable ar rays expensive test integers booleans number program points invariant detection performed stance every instruction versus entry exit points one component grammar invariants checked check ing invariants relate three variables expensive considering relate two variables size program relevant except insofar might affect measures previous invariant detection algorithms controlled runtime space limiting one factors see section 10 result results limited ex pressiveness applicable fewer programs would desired goal remove limitations enabling invariant detection applied programs produce detailed results address goal providing two new algorithms invariant detection topdown incremental algorithm bottomup incremental algorithm analytically experimentally comparing algorithms one another two previously known algorithms simple incremental algorithm multipass batch algorithm describe three optimizations equiva lence sets constants suppressions previously implemented multipass batch algorithm show extend incremental algorithms present new optimization hierarchy optimizations take advantage fact certain properties hold properties guaranteed hold need checked experimentally evaluate four optimizations discuss complications arising integrating optimizations algorithms paper organized follows section 2 provides background dynamic invariant detection explains factors affect runtime section 3 gives simple incremental algorithm invariant detection section 4 notes four types redundancy output following sections give algorithms exploit redundancies different ways multipass algorithm section 5 bottomup incremental algorithm section 6 topdown incremental algorithm section 7 along optimizations incremental algorithms section 8 section 9 gives results experiments various algorithms optimizations section 10 discusses related work section 11 concludes 2 background dynamic invariant detection dynamic detection likely invariants 10 discovers likely invariants program executions instrumenting target program source binary form trace variables interest running instrumented program set test cases postulating checking invariants values program computes essential idea use generateandcheck algorithm test set possible invariants observed values instrumented variables set observed values program point called sample invariant detector reports properties tested sufficient degree without falsification output includes properties entry procedure foo mylist sorted exit procedure bar return myvar return stands return value link objects dynamic approaches profiling accuracy results depends part quality completeness test cases even modest test suites produce good results practice 31 30 techniques exist creating good test suites invariant detection 16 14 39 remainder paper brevity use invariant mean likely invariant unless otherwise noted invariants reported depends properties checked specifically grammar properties expressible invariant detector variables properties checked program points properties checked discuss factors section 10 discusses choices various implementations make fac tors reported properties also depend filtering performed checking statistical tests reduce false positives 10 elimination redundant properties 11 program points invariants checked arbitrary locations program two examples procedure entries exits resulting invariants correspond preconditions post conditions useful compute invariants procedure exit ie return statement also compute aggregate exit point viewed client generalizing individual exit points object class invariants also computed aggregate program point object point generalizing objects observed entry exit public methods class passed returned methods classes stored object fields grammar properties invariant detector may check types properties equalities inequalities among variables may check larger variety let xyz variables let abc constants properties might checked include constant range x b linear relationships functions library ness x sorted many others invariant detector may permit users add domainspecific properties checked invariant detector may also report conditional properties implications left null left value thisvalue checking larger number properties makes likely output contain facts needed human tool however also increases runtime invariant detector likelihood false positives grammar variables properties invariant detector express must instantiated particular variables values example x instantiated two variables second must collection addition proce dures parameters return value useful detect invariants additional variables instance global variables prestate values also values called derived variables manifest program example array integer lasti scope properties alasti may terest even though variable may even appear program procedure exit including original values variables permits reporting side effects inputoutput relation ships given object fields af fields afg provide useful additional information results calls sideeffectfree methods also used derived variables examining structure elements results missing variable values example variable null af nonsensical subtler example results fields dereferenced depth say 1 class contains field x type integer field type b contains field z type integer uses b type b b typically represented address hash code field bz available however uses type fields ax ay available field ayz beyond field dereference depth available even ay non null requires special care report correct results one variables invariant may missing invariant falsified cannot relied certain situations experimental evaluation papers experimental evaluation uses daikon implementation publicly available httppagcsailmitedudaikon daikon implements features listed section including ternary derived variables invariants field dereferencing userspecified depth userspecified invariants conditional invariants statistical tests full list 31 derived variables 12 enabled de fault 161 invariants 152 enabled appears daikon user manual available website daikon operates c java perl code various data formats 3 simple incremental algorithm section gives incremental singlepass invariant detection algorithm discards sample processing storage space requirements grow number samples incremental algorithm also run online simultaneously target program eliminating need store trace files disk algorithm follows 1 initially assume properties grammar true instantiate candidate invariant property combination variables example grammar properties odd variables x z instantiate oddx oddy oddz 2 sample check candidate invariant associated program point sample discard contradicted sample example sample 3 4 3 eliminates invariants oddy list 3 report invariants remain processing sam vp number variablesvalues scope program point vd v number derived variables obtained v original variables total variables program point execution length number samples program point number possible invariants program point ri number reported invariants program point number program points gv grammar number invariant templates given v variables figure 1 variables used running time space analyses ples applying postprocessing filtering program point processed independently algorithm uses space store candidate invariants initial maximum space usage figure 1 definitions variables suppose 12 types derived variable involve 3 variables example subarray aij 152 types invariant involve 3 variables example ax 100 program points instrumented 300 reachable variables fields scope program point p 29 prohibitive static analysis determine variables sensibly compared others 32 11 number invariants still highorder polynomial number variables ov 9 hand grammar invariants small simple incremental algorithms space usage reasonable worstcase runtime requires checking invariants sample practice invariants false false invariants falsified quickly o1 samples commoncase runtime first summand falsified properties second summand neverfalsified invariants checked samples simple incremental algorithm implemented number research groups every invariant detector aware except daikon based 4 optimization opportunities redundant properties simple incremental algorithm section 3 checks reports invariants necessary section gives four examples redundancy output optimizations based three equal variables constants suppression yielded significant performance enhancements multipass batch algorithm 11 41 equal variables two variables always equal invariant true one variables true variables example invariant f fx implies fy context condition requires whenever one variable missing example x missing fx necessarily imply fy since value x missing may invalidated invariant 42 dynamically constant variables dynamically constant variable one value observed sample invariant x constant makes invariant x redundant example implies oddx x 5 likewise combinations variables missing values affect concluded group constants must exist least one sample constant group missing 43 variable hierarchy variable values contribute invariants multiple program points example values observed public method exits affect method postconditions also object invariants two program points b samples b also appear invariant true necessarily true b redundant b formalized relationship partial order lesser elements receive subset samples received higher element higher elements contain subset invariants true lower element 29 26 different variables appear different program points partial order better understood variables organized program points rather program points figure 2 illustrates variable hierarchy two simple java classes three ways partial order relates variables enter exit exit point use notation x final value variable x origx initial value x entry procedure variables procedure entry points corresponding original variables procedure exit point object method variables object points corresponding variables method entry exit point object client variables object points corresponding variables client class relations automatically determined program source 44 suppression weaker invariants invariant suppressed logically implied set invariants previous three examples redundancy special cases one give rise specific optimization opportunities example x implies x 0 x equal variables dynamic constants missing values affect suppressed second example must least one sample x z present order x div z true 5 multipass batch algorithm opportunities identified section 4 give powerful ways identify logically redundant properties whenever certain antecedent properties hold properties redundant need created checked reported however simple incremental algorithm cannot take advantage redundancy antecedent properties cannot relied upon invariant detection complete properties may falsified time multipass algorithm 11 addresses issue performing invariant detection multiple passes early passes check simple invariants later passes check complex invariants create derived variables necessary implementation uses 5 passes number represents compromise exposing optimization opportunities reducing number passes 1 unary constant pass determines whether variable constant whether missing subsequent passes ignore constant variables arg thisbx thisbx thisb aobject thisx thisx bobject public class public void putb arg public class b public int x public int get object method object client enter exit type variable relation bgetenter thisb arg thisbx argx aputenter return thisx figure 2 variable hierarchy two simple java classes shaded areas name program point unshaded boxes represent variables program point lines show partial ordering described section 43 lesser elements appear lower figure instance lower left corner note variable connected variable objectclient relation variable arg parameter method put null never null 2 binary equality pass checks equality pair nonconstant variables set equal variables leader variable arbitrarily chosen represent set subsequent passes process leaders 3 unary 4 binary 5 ternary suppression weaker invariants optimization built passes creating invariant invariantspecific code checks whether invariant implied existing invariants one example pass 4 discovered pass 5 need check ternary invariant note per pass 1 invariants checked constants variables powerful optimization undesirable side effects interesting invariants may omitted result previous experiments demonstrated necessary achieve acceptable performance 10 version constant variables optimization incremental algorithms section 82 flaw implementation multipass algorithm currently implement hierarchybased optimizations pos sible would make algorithm complicated would require either postprocessing increasing number passes least additive factor depth hierarchy sections 6 7 describe hierarchy optimization incremental algorithms multipass algorithm processes program points one one performing 5 passes trace data program point program points processed samples associated program points discarded optimization multipass algorithms worstcase space cost first argument storing traces represents total space usage start algorithm second storing invariants represents space usage end algorithm practice first argument dominates interning trace data reduce storage costs worstcase runtime many invariants quickly falsified even never even checked leading commoncase runtime downside multipass approach need store trace data processed multiple times even modest traces occupy gigabytes disk space memory limiting ability algorithm work nontrivial programs making inappropriate online use reading files multiple times another possibility however file io substantial cost imple mentation stores traces memory performing runlength encoding interning identical samples save space alternative storing trace data one could run target program multiple times pass multipass algorithm acceptable prohibitively difficult program performs side effects depends aspects environment may change including random number generators memory addresses hash codes thread scheduling uses expensive resources including human attention many programs operating systems web servers never terminate user may also wish switch gathering invariants checking invariants fly 15 6 bottomup incremental algorithm incremental algorithm handle arbitrarily long executions target program processes sample exactly discards however optimizations become complicated costly invariant detector must undo optimization antecedents depends ever falsified section presents new bottomup incremental algorithm section 7 proposes topdown incremental algorithm two algorithms differ primarily address variable hierarchy optimization optimizations similar two incremental algorithms given section 8 invariant true higher level variable hierarchy also true lower levels instance every object invariant precondition postcondition every public method key idea hierarchy optimizations particular property true multiple program points invariant checked one level hierarchy bottomup imple mentation invariants checked lowest possible level topdown implementation checked highest possible level bottomup algorithm processes samples leaves variable hierarchy aggregate program points handled postpass samples processed invariants nonleaf built merging invariants children invariant created parent iff invariant type variables exists child invariant exist child must falsified child thus falsified parent invariant merging routine operates manner similar runtime processing straightforward stateless sampleindependent invariants express one fact variables whose internal state change result processing sample example greaterthan product stateless invariants sampledependent invariants whose equation includes constant x 42 1 reasonable instantiate check every possible x c variant instead one object stands invariants given variables constants computed fit observed sam ples run time processing sample may change meaning invariant instance adding linearly independent point permits constants computed weakening variant changing x 42 x 10 sample value 10 observed merging sampledependent invariants requires invariantspecific processing example one child contains invariant x 15 child contains invariant x 22 merged invariant parent x 22 one complication populating parent program points need properly relate variables multiple program points illustrated figure 2 variables name need cor respond correspondence cross class boundaries optimizations section 8 complicate correspondence merging parents set equivalence sets variables section 81 intersection sets equivalence sets child two variables equal parent iff equal child invariant merging must also merge information used statistical tests mentioned section 2 statistics computed parent program point processed samples bottom approach sample processed exactly leaf nonleaf program points considered processing complete processing time parents dependent small number invariants found children large number samples 7 topdown incremental algorithm bottomup algorithm instantiates given invariant say x every leaf program point contains x contrast topdown algorithm aims save space cost additional runtime instantiating invariant highest points hierarchy true invariants initially created top partial order sample read trace processed every program point top partial order leaf program point sample belongs invariant falsified program point invariant immediately removed program point added children sample processed child 1 result invariant appears path starting top hierarchy set invariants program point consists invariants appear implementation accounts fact partial order forms dag tree invariant a1 holds program point falsifying sample c1 falsifying sample c2 figure 3 example topdown hierarchy optimization left diagram shows invariant point marked gray back ground top hierarchy holds every program point center diagram shows hierarchy falsifying sample received point c processed order b c right diagram shows hierarchy falsifying sample received point c2 higher program point example see figure 3 order applied multiple program points sample must transformed include correct values correct order required different variables appear different program points nonleaf program point may see samples originating multiple leaves bottomup algorithm transformation postprocessing also transforms invariants samples topdown algorithm also makes incremental optimizations section complex invariants hold program point physically located program point higher locations partial order order search invariant optimizations traverse hierarchy copying invariant possibly different program point place copy target program point appear anywhere higher target unfortunately sampledependent invariants tend numerous practice must exempted topdown hierarchy optimization instantiated everywhere partial order processing sampledependent invariant must observe every sample program point without omitting example suppose figure 3 invariant x equal constant c order samples prog point value first sample would set equation 5 third sample would falsify invariant following algorithm outlined would copied children shown center diagram figure 3 however would incorrect since program points b2 b3 received samples instead indicate c yet bound problems achieving correctness led us modify implementation topdown algorithm rather instantiating invariants highest point hierarchy instantiated level tree lower tree suppressed see section 83 higher tree gains time advantages made possible utilizing variable hierarchy invariant checked one level hierarchy space advantages invariants duplicated words although topdown algorithm intuitively appealing promises space savings instantiating invariants fewer locations hierarchy achieve goals gv v gv v figure 4 copying invariants due splitting equality sets equality sets invariants shown processing sample z 8 optimizations incremental algorithms multipass algorithm later passes rely properties known true across samples contrast properties enable optimizations incremental algorithms always subject change algorithm must able undo optimization may require creating previously suppressed invariants putting state would processed samples seen far 81 equal variables incremental algorithms use equivalence sets variables batch algorithm must dynamically update equivalence sets initially variables placed single equivalence set modulo comparability noted section 3 invariants instantiated leaders sets processing elements equivalence set differ value whether missing equivalence set broken multiple parts invariants original leader copied new leaders copying proceeds follows invariant mentions leader old equivalence set duplicate invariant many times new equivalence sets dupli cate replace first instance old leader different one new leaders original invariant mentioned old leader duplicates still mention old leader least must recursively processed original invariant mentioning old leader n times turns newsets n duplicates example see figure 4 algorithm extends straightforward manner multiple equivalence sets breaking simultaneously reflexive invariants use single variable x x uninteresting never reported however equal variables optimization requires existence processing equal variables optimization invariant leader variable stands multiple invariants members equivalence set left side figure 4 fv stands fv fw gv x stands six invariants reflexive invariants required equivalence set might later break example gx x stands gx gx z 7 invariants without gx x invariants gx z gz x right side figure would created duplication step optimization reflexive invariants need created fewer members equality set variables invariant thus example necessary create gz z 82 constant variables incremental algorithms dynamically maintain set constant variables necessary instantiate invariant variables constant however invariants variables nonconstant member constant set invariant instantiated sample processed new value constant variable examined new value different missing variable removed constant set invariants relating values remaining constants created variable ever missing considered constant variable sometimes missing known combinations variable variables ever existed incremental algorithms instantiate invariants constants nonconstants two reasons first interesting right second necessary constant later becomes nonconstant last variable set becomes non constant late create invariant set previous values variables lost instantiating checking invariants every set variables containing least one nonconstant solves problem 83 suppression weaker invariants type invariant specify set possible suppressions suppression set antecedent invariants together imply invariant example xy z1 xz y1 possible set suppressions product invariant invariant suppressed antecedents suppression hold discuss two implementations suppression mechanism first one instantiates every invariant usual checks invariant might suppressed whether antecedents exist suppression data structure records fact suppressee invariant need checked sample antecedent falsified suppressee becomes unsuppressed unless suppression holds eliminating checking sample saves runtime data structures track suppressions increase memory usage second implementation avoids instantiating suppressed variants maintains state whatsoever indicate whether nonexistent invariant removed falsified never instantiated suppressed saves space cost complicated processing rather linking instantiated invariant acts antecedent information indicating instantiated invariants helps suppress invariant type list suppression types may antecedent whenever invariant might antecedent falsified every noninstantiated invariant might suppressing checked suppression invariant holds falsification antecedent suppression holds falsification antecedent invariant must instantiated words invariant unsuppressed instantiated soon last suppression longer holds example potential antecedent falsified product invariant must considered every set 3 variables includes w every suppression invariant must checked expensive achieves goal requiring storage suppressed invariant implementation topdown algorithm uses solution instantiates suppressed invariants bottomup algorithm uses solution complex expensive search antecedents topdown section 7 combination expense extra searches required non instantiating solution prohibitive invariant count sample count candidate invariant count sample processed without optimizations optimizations figure 5 number candidate invariants samples pro cessed without optimizations bottomup algorithm data single program point flex lexical analyzer 84 discussion optimizations incremental algorithms effective processing initial samples trace initially invariants true redundant variables equality set inmemory representation relatively small samples processed antecedent properties falsified equality sets break number instantiated invariants grows contrast without optimizations simple incremental algorithm initially creates invariants number decreases thereafter figure 5 shows number invariants grows without optimizations figure also highlights effectiveness optimizations maximum number invariants optimizations 100 times less minimum number invariants without optimizations 9 experiments order evaluate algorithms optimizations described paper ran experiments measure terms time space effects algorithm optimizations program size trace size paper presents experiments two rather different target programs flex lexical analyzer c program part standard linux distribution utility libraries daikon written java flex contains 391 program points averaging 275 variables trace used 92 gigabytes 232000 samples trace created running flex number sample scan ners daikon utilities contain 1593 program points averaging variables maximum 3672 variables trace file 115 gigabytes 26 million samples trace file created running daikon small example program simple incremental algorithm creates 750 million candidate invariants flex 460 million daikon ignoring program points 1500 variables could even instantiate 14 gigabytes memory ran two sets experiments first evaluates different algorithms one another optimizations enabled second evaluates optimizations comparing effects optimization isolation run invariant detec tor measured run time wall clock time maximum memory size used five identical 22 ghz pentium 4 pcs 1 gbyte memory limiting maximum java heap 750 mbytes eliminate thrashing results shown sizes graph experiment ran memory completion set experiments simulated programs various sizes considering fewer program points file io operations read entire file invariant detector process samples ignored program points using part single program rather many distinct programs different sizes avoids conflating program size number type variables patterns data factors permits direct comparison results also indicates performance user instruments part large program realistic scenario simulated shorter runs target program reading fraction trace file processing program points invariants created algorithm without optimizations identical except relatively minor differences noted discussion implementation comparing outputs increased confidence implementations 91 algorithm comparison figure 6 shows time space usage multipass bottom topdown algorithms graphed target program run time trace size figure 7 graphs time space target program size number program points simple incremental algorithm complete even minimum program size minimum data trace file size topdown algorithm runs memory processing full flex trace topdown algorithm requires memory bottomup one two reasons first correctness must instantiate invariants every level variable hierarchy second data structures significantly larger needs relate variables hierarchy processing samples bottom algorithm uses hierarchy merging invariants daikon utilities memory usage similar bottom algorithm runs twice fast large program sizes trace sizes due greater overhead required topdown processing memory usage bottomup independent trace size linearly related program size since program point processed independently multipass algorithm similar speed bottomup algorithm multipass cannot process full trace flex daikon utilities maximum memory use multipass grew less quickly expected probably effectiveness interning optimization fact java memory system works harder save memory instance garbagecollecting frequently limit approached explains memory graphs measure maximum memory usage flat near memory limit 92 optimization comparison comparing optimizations used bottomup algo rithm dominates others able process full traces wished use single good baseline optimizations integral part multipass approach difficult turn results shown figure 8 equality optimization far powerful crucial many variables equal one another ex ample sideeffectfree procedure poststate value parameter global variable equal prestate value eliminating one optimization causes daikon run memory flex example none extraneous optimization benefits daikon utility libraries less flex utilities far fewer variables per program point library little state heavily exercised library procedures simple assert represented almost 20 calls library thus much processing time utilities expended optimizations afforded little benefit memory mbytes flex multipass bottomup topdown 010000200000k 50k 100k 150k 200k 250k time seconds flex multipass bottomup topdown2006001000 memory mbytes number samples processed utilities multipass bottomup topdown50001500025000 time number samples processed utilities multipass bottomup topdown figure comparison algorithms flex daikon utilities respect trace length multipass topdown algorithms run memory processing full flex trace multipass also runs memory processing full daikon utilities trace simple incremental algorithm never completes even minimum trace length 20000 samples2006001000 memory mbytes flex multipass bottomup topdown 01000020000 time seconds flex multipass bottomup topdown2006001000 memory mbytes number program points utilities multipass bottomup topdown5000150000 200 400 600 800 1000 1200 1400 1600 time number program points execution time versus program size utilities multipass bottomup topdown figure 7 comparison algorithms flex daikon utilities respect program size multipass topdown algorithms run memory processing program points flex multipass also runs memory processing program points daikon utilities simple incremental algorithm complete even one program point 10 related work numerous researchers adopted adapted ideas dynamic detection likely invariants section 2 discussed relevant features daikon implementation describe implementations based published information implementations daikon publicly available implementations use simple incremental algorithm run faster daikon primarily daikon checks many invariants millions times flex example however incremental algorithms optimizations applicable implementations diduce tool 15 checks one unary invariant java pro grams program point field array reference procedure call invariant checked three values variables current previous values difference invariant indicates previously seen values every bit value invariant weakened new values observed given bit message printed user look weakenings printed program hierarchy equality constants suppression time flex 248 179 160 111 space flex 186 670 181 168 time utilities 120 172 116 100 space utilities 116 156 126 100 figure 8 comparison optimizations averaged variety different program sizes trace lengths reported numbers result without one optimization divided result optimizations enabled example processing flex 179 times slower uses 67 times memory without equality optimization figure time space spent reading trace file common approaches included erroneous runs error occurs find rare corner cases tool used help explain several known errors reveal two new errors carrot tool 33 checks 2 unary 4 binary invariants reusing daikons instrumentation handle languages daikon dereference fields experiment comparing faulty nonfaulty program runs results indicate problem contrast work similar aims 15 12 remote program sampling 21 lightweight mechanism evaluates two properties one unary one binary instantiated linear rather quadratic number variable pairs assignments c programs plus predicate branch counting number times property satisfied properties checked probabilistically executions program point property checking skipped implementations could extended sacrificing soundness test suite gaining performance results processed statistically indicate properties best correlated faults thus likely indicative faults diduce relatively dense instrumentation means early warning one relatively simple properties indicates bug experiment tool rediscovered 7 known errors found one new one arnouts tool extracting implicit contracts 2 aims add preconditions analysis determines conditions give rise exception thrown adds negation condition precondition henkel diwan 17 18 built tool discovers algebraic specifications relate meaning sequences code operations poppushxstackstack tool generates many terms test cases signature java class proposes equations based results tests tool also proposes tests generalizations spin model checker extended check whether two variables related 35 output graph variables nodes edges labeled comparison relations programming demonstration inductive logic programming aim generate program sequence examples data 3 7 20 output similar obtained dynamic invariant detection aims complete rather partial must targeted smaller domain several researchers inferred program system traces finite state automata represent permitted transitions 6 5 1 36 specifications written form automata complementary formulabased program properties generated dynamic invariant detector 11 conclusion presented two new incremental invariant detection algorithms compared two existing algorithms one incremental one batch shown perform three previously described optimizations one new one challenging incremental context requires undoing optimizations antecedents depend become invalidated aspect work viewed specialpurpose automatic theorem prover optimized efficient retraction axioms implemented algorithms optimizations single framework permitting direct experimental comparison conclude discussion merits various al gorithms simple incremental algorithm easy understand implement least 6 implemented invariant detectors based algorithm number invariants checked small example implementation considers small number variables invariant types clearly best algorithm however scale multipass algorithm offers convenient framework op timizations work ever need undone greatly reduces computational complexity storage requirements optimizations storage savings offset need store trace data reprocessing rerun target program often impractical one optimizations eliminates desirable invariants output multipass algorithm reasonable moderatesized datasets large numbers invariants beyond scope simple incremental algorithm however longer runs require incremental algorithm bottomup incremental algorithm best performer experiments algorithm able fully process datasets optimizations control space usage ensuring modest number invariants exist one time even near beginning run substantial accomplishment competitive performance multipass algorithm tuned years use incremental nature algorithm makes runtime proportional space usage independent dataset size permits online invariant detection concurrently target program without storing trace data much complexity algorithm incurred final postprocessing step topdown incremental algorithm shares many characteristics bottomup algorithm however topdown algorithm ineffective sampledependent invariants complicated processing sample requires difficult search determine whether invariant true algorithms implementations experiments suggest invariant detection simultaneously scale nontrivial numbers invariants programs nontrivial size incremental algorithms optimizations implemented version 3 daikon invariant detector available http pagcsailmitedudaikon acknowledgments jeremy nimmer toh ne win wrote preliminary implementation topdown incremental algorithm discussions helped develop many ideas comments anonymous referees helped us improve presentation paper research funded nsf grants ccr0133580 ccr0234651 oxygen project deshpande center technological innovation gifts ntt toshiba 12 r mining specifications extracting implicit contracts inductive learning applied program construction verification finding latent code errors via machine learning program executions discovering models software processes eventbased data watch programming demonstration selecting predicates implications program analysis dynamically discovering likely program invariants support program evolution quickly detecting relevant program invariants went wrong explaining counterexamples generating test data dynamically discovering likely program invariants new structural coverage criterion dynamic detection program invariants tracking software bugs using automatic anomaly detection improving test suites via operational abstraction discovering algebraic specifications java classes tool writing debugging algebraic specifications automated support program refactoring using invariants learning programs traces using version space algebra bug isolation via remote program sampling improving adaptability via program steering technique verifying componentbased software predicting problems caused component upgrades early identification incompatibilities multicomponent upgrades verifying distributed algorithms via dynamic analysis theorem proving automatic generation checking program specifications automatic generation program specifications invariant inference static checking empirical evaluation program understanding tool based type inference automated fault localization using potential invariants anomaly detection online data sources automatic detection invariants spin automatic extraction objectoriented component interfaces checking inside black box regression fault exposure localization based value spectra differences exploiting synergy testing inferred partial specifications tr watch discovering models software processes eventbased data eventbased detection concurrency quickly detecting relevant program invariants dynamically discovering likely program invariants support program evolution mining specifications automatic extraction objectoriented component interfaces automatic generation program specifications tracking software bugs using automatic anomaly detection anomaly detection online data sources invariant inference static checking inductive learning applied program construction verification improving test suites via operational abstraction bug isolation via remote program sampling automated support program refactoring using invariants predicting problems caused component upgrades learning programs traces using version space algebra tool writing debugging algebraic specifications finding latent code errors via machine learning program executions improving adaptability multimode systems via program steering using simulated execution verifying distributed algorithms ctr nadya kuzmina ruben gamboa dynamic constraint detection polymorphic behavior companion 21st acm sigplan conference objectoriented programming systems languages applications october 2226 2006 portland oregon usa christoph csallner yannis smaragdakis dynamically discovering likely interface invariants proceeding 28th international conference software engineering may 2028 2006 shanghai china nadya kuzmina ruben gamboa extending dynamic constraint detection polymorphic analysis proceedings 5th international workshop dynamic analysis p1 may 2026 2007 marat boshernitsan roongko doong alberto savoia daikon agitator lessons challenges building commercial tool developer testing proceedings 2006 international symposium software testing analysis july 1720 2006 portland maine usa sofien khemakhem khalil drira mohamed jmaiel sec search engine component based software development proceedings 2006 acm symposium applied computing april 2327 2006 dijon france zhenmin li yuanyuan zhou prminer automatically extracting implicit programming rules detecting violations large software code acm sigsoft software engineering notes v30 n5 september 2005 philip j guo jeff h perkins stephen mccamant michael ernst dynamic inference abstract types proceedings 2006 international symposium software testing analysis july 1720 2006 portland maine usa
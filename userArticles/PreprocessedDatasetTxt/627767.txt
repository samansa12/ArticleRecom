tries approximate string matching abstracttries offer text searches costs independent size document searched important large documents requiring spelling checkers case insensitivity limited approximate regular secondary storage approximate searches search pattern differs document k substitutions transpositions insertions deletions hitherto carried costs linear size document present triebased method whose cost independent document size experiments show new method significantly outperforms nearest competitor arguably important cases linear cost k methods begins catch small files 2 larger files complexity arguments indicate tries outperform linear methods larger values k trie indexes combine suffixes compact storage text need stored spelling checker even obtain negative overhead 50 compression discuss variety applications extensions including best match spelling checkers case insensitivity limited approximate regular expression matching b introduction need find approximate match string arises many practical problems example optical character reader interprets automatic checker would need look resulting word say eoit dictionary find edit matches one substitution writer may transpose two letters keyboard intended word worstcase run preproc time extra space ref naive mn shiftor om jsigmaj ojsigmaj 4 patricia om log n 10 figure 1 exact match algorithms say sent detected instead error snet applications occur strings text strings dna base pairs strings musical pitch duration strings edge lengths displacements diagram addition substitutions transpositions errors include insertions deletions approximate match problem strings development simpler problem exact match given text w n n characters alphabet sigma string pm characters p w baezayates 2 reviews exact match algorithms summarize figure 1 algorithms except naive approach require preprocess ing knuthmorrispratt kmp boyermoore bm shiftor algorithms preprocess search string p save comparisons boyermoore algorithms sublinear practice better bigger depend n patricia method builds trie truly sublinear 1 preprocessing text search strings although substantially greater linear algorithms need done text note tries size n built ram time secondary storage memory differences make better use n log n method practical sizes trie quote complexity triebased methods best suited large texts require secondary storage emphasize paper compare triebased method experimentally linear methods approximate string matching adds parameter k algorithm reports match string differs text 1 term sublinear literature two meanings distinguish sublinear truly sublinear truly sublinear n means ofn f sublinear function eg log n 1 sublinear means truly sublinear multiplicative constant less 1 k changes change replacement substitution insertion deletion also transposition illustrated operations formulated damerau 8 notion edit distances given levenshtein 15 dynamic programming dp algorithm shown wagner fischer 26 omn worst case ukkonen 24 improved okn clearly k finding cutoff dp chang lawler 7 worst case get sublinear expected time onmk log om space opposed om 2 earlier methods building suffix tree 27 16 patricia trie morrison 19 pattern method detecting common substrings kim shawetaylor 12 propose om log n algorithm preprocessing generate ngrams text represent trie compactness baezayates perlberg 5 propose counting algorithm runs time independent k r r bounded zero characters pm distinct figure 2 summarizes discussion agrep 28 package based related ideas also limited regular expression matching ie pm regular expression regular expression matching kapproximate string matching solve worstcase run preproc time extra space ref cutoff okn ok okn 24 suffix tree okn om om 7 ngram om log n 12 figure 2 kapproximate match algorithms different problems problem areas overlap eg p oneplace wildcard written regular expression also 3approximate match coincide recent review techniques book stephen 23 hall dowling 11 give early survey approximate match techniques work directed searches relatively small texts ie large fit ram texts require secondary storage far slow need olog n faster methods conventional files containing separate records 17 price must pay store index must built whole text unless text changes interested text ordered sequence characters must store text well index represents additional storage requirement interested text substrings contains dictionary spelling check need store index often achieve compression well retrieval speed tries used index large texts 10 18 known truly sublinear way tries trees nodes empty potential subtree letter alphabet sigma encoding data eg 0 1 binary tries data represented nodes path root leaf thus strings sharing prefix represented paths branching common initial path considerable compression achieved 2 substring matching involves finding path cost om log n plus terms number resulting matches log n component reflects number bits required store pointers text unimportant regular expression matching 2 note compression index may still larger text typically index every character text section 4 index five times size text index every word index smaller compression results18 dictionary searches section 6 great compression simulates regular expression trie 9 also fast olog n n ff ff1 paper proposes kapproximate match algorithm using damerau levenshtein dp text represented trie insight trie representation text drastically shortens dp theta n dp table used match given pm text w n would new table suffix w length n trie representation w compresses suffixes overlapping paths corresponding column need evaluated furthermore ukkonen cutoff used terminate unsuccessful searches early soon differences exceed k chang lawler 7 showed ukkonens algorithm evaluated ok columns implies searching trie depth ok fanout trie sigma trie method needs evaluate ok jsigmaj k dp table entries present method terms fulltext retrieval index text must stored applications spelling checkers 14 text dictionary set words need stored separately index special cases describe cases method offers negative storage overhead virtue compression addition fast performance compare work experimentally agrep 28 show tries outperform agrep significantly small k number mismatches since agrep complexity linear k trie search complexity exponential k agrep expected become better tries large k experiments show breakeven occurs beyond practically important case 1 since authors agrep compare work thoroughly approximate search techniques 28 make comparisons paper organized follows next section introduces damerau levenshtein dp approximate string matches section 3 briefly describes data structures gives new algorithm approximate search text tries give experimental results comparing approximate trie methods agrep sections 5 6 discuss extensions advanced applications method including important case dictionary checking attain speedup compression conclude discuss possible research programming pattern target string respectively use dpm distance minimum number edit operations change pm w edit operation either transpose two adjacent symbols pm assume symbols drawn finite alphabet sigma given example example dp 7 3 since changing p 7 w 7 needs 1 delete l edit distance recursively defined follows else null character else else evaluate dpm w need invoke four times subscripts decreasing two thus brute force evaluation must take o2 minm calls however dpm w m1theta1 possible values dp evaluates dpm w storing possible value mtheta table table 1 shows 3theta4 dp table p 2 ab w 3 bbc table 1 dynamic programming furthermore necessary evaluate every values dp table entries ukkonen 24 proposed algorithm reduce table evalua tions algorithm works follows let c j maximum given j c j 0 given set c j largest 0 dp proved algorithm evaluates expected entries shown table 2 p 4 adfd w 7 acdfbdf 5theta840 entries ukkonens algorithm evaluates 23 entries k1 ukkonens algorithm sets dp 1 initial time evaluates first column row c 0 12 since largest entry value column row 2 sets c 1 2 evaluates second column row c 1 13 since largest entry value column row 2 sets c 2 2 similarly evaluates third column row c 2 13 get c 3 2 fourth column get c 4 3 fifth column get c 5 0 indicates impossible change prefix adfd acdfb less one edit operation thus know stop evaluation want know exact value dp 4 3 trie approximate search follow gonnet et al 9 using semiinfinite strings sistrings sistring suffix text starting position text consists many sistrings assume sistrings start word boundaries text echo enfold sample enface example six sistrings kind figure 3 shows sistrings index trie constructed sistrings make figure 3 simpler truncate sistrings first blank index full size sistrings simply replace leaf nodes sistring locations text prevent sistring proper suffix another append either arbitrary numbers null symbol text unique endoftext symbol index trie many distinctive properties ffl conducting depthfirst traverse get sistrings also get lexicographical order ffl searching string say example branching decisions node given character string sought trie figure 3 test first letter e get left branch second letter x get right branch result search time proportional length pattern string independent text size echo enfold sample enface example sistrings echo enfold sample enface example enfold sample enface example sample enface example enface example example example e f ho c ce ld ample x le trie figure 3 text sistring index trie ffl common prefixes sistrings stored trie gives substantial data compression important indexing large texts trie methods text found 10 18 22 describe briefly constructing trie large number extremely long sistrings consider representation huge trie secondary storage tries could represented trees pointers subtrees proposed morrison 19 first came patricia trie text searches orenstein 21 compact pointerless representation uses two bits per node adapted secondary storage merrett shang 18 22 refined method made workable patricia tries one bit per node essentially pointerless representations would entail sequential searches trie except bits partitioned secondary storage blocks trie nodes blocks grouped levels level nodes either entirely entirely level blocks addition two integers per block sequential search restricted within blocks may searched tree details representation see 22 31 two observations introducing approximate search algorithm give two observations link trie method dp technique observation trie path prefix shared sistrings subtrie evaluating dp tables sistrings identical columns prefix therefore columns need evaluated suppose searching string sane trie shown figure 3 calculate distances word need evaluate six tables table 3 shows three table entries ith column depend entries ji th column first letters target word words sample prefix sam therefore share table entries third column first column words echo enface enfold example first three columns words enface enfold general given path length x dp entries words subtrie identical xth column observation tells us edit distances indexed word sistring general calculated traversing trie meantime storing evaluating one dp table sharing common prefixes trie structure saves us index space also search time observation ii entries column k word prefix distance k therefore stop searching subtrie last table table 3 entries second column 1 searching words differences stop evaluating strings subtrie sure dsane en 1 reason evaluating fourth column table sample find entries 1 therefore stop evaluation observation tells us necessary evaluate every sistring trie many subtries bypassed extreme case exact search one subtries trimmed 32 search algorithm algorithm figure 4 shows two functions dfsearch rieroot 1 traverses index trie depthfirst editdist j evaluates jth column dp table pattern string p target string w purpose illustration start stop evaluation word boundary following explanation essentially algorithm trie walker cutoffs rejects reaching leaves given node c roottoc path w 1 w 2 w x prefix shared strings subt riec changing w 1 w 2 w x possible prefix p costs k string subt riec array gamma1max gamma1max integer array 0max integer variables ukkonens cutoff array 0max character pattern target string w number allowable errors procedure dfsearch rienode anode level integer begin depthfirst trie search rienode leaf node character node retrieve characters one one wlevel retrieved character find target word output w1w2wj1 return editdist return level else child node retrieve child node one one childnode retrieved node wlevel retrieved character find target word output w1w2wj1 return editdist search subtrie return dfsearch childnode level1 search subtrie function begin evaluate one column dp table i1 min cj11 lengthp evaluate one table entry r pi1wj piwj1 1 else return cj0 1 else ti1j figure 4 approximate trie search algorithm mismatches hence need walk subtriec cutoff occurs letter w j 1jx path cause call editdistj use ukkonens algorithm minimize row evaluations suppose misspelled word pexsample want words mismatches figure 5 shows index trie intermediate results search evaluating dp ech find entries third column 2 according observation ii word w prefix ech reject word echo continue traversing evaluating dp enf know word w prefix enf therefore need walk subtrie cut subtrie since ech enf share prefix e copy first column ech evaluating enf observation evaluating path 3 find accept word search stops cutting path 4 sa figure 5 shows intermediate results search pattern string search path 2 search path 3 search path 4 string distance action exsample ech enf example sa reject cutoff accept cutoff depth first e fho c ce ld ample x le figure 5 approximate trie search example 4 experimental results built tries five texts 1 king james bible retrieved ak barcacwashingtonedu 2 shakespeares complete works provided oxford university press next inc 3 section one unix manual pages solbourne computer inc 4 c source programs selected randomly departmental teaching machine 5 randomly selected ftp file names provided bunyip information system sistrings start character except word boundary blank tab characters table 4 shows sizes five texts index tries 41 search time randomly picked 5 substrings five texts searched substrings using agrep 28 trie algorithm elapsed time cpu time measured two 25mhz next machines one 28mb ram 8mb ram table 5 shows measured times averaged five substrings seconds testing results show trie search algorithm significantly outperforms agrep exact match approximate match one error exact match trie methods usually give search time proportional length search string measurements show trie search times exact match directly relate text size requires data transfers one search path therefore insensitive ram size let aek average trie search depth average number columns evaluated assuring k proven aek k k less target string length 24 7 complete trie worst case text trie trie search algorithm find substrings k mismatches ok jsigmaj k expected time jsigmaj k paths depth k column dp table k rows time independent trie size fact trie algorithm better agrep small k large k agrep scans text linearly trie grows exponentially measured texts relatively small trie search brings data ram agrep ram size larger data size measured cpu times closer elapsed times since query tested repeatedly data text trie cached ram therefore searches cpubound however smaller ram size larger text data searches wait data transferred secondary storage since agrep scans entire text search time linearly proportional text size file names different tested texts file names distinct two substrings resemble less helps agrep stop evaluation quickly help trie search makes trie shallow toward complete trie takes time scan top trie levels extensions trie search algorithm extended various ways example spelling checkers likely ask best matches rather words fixed number errors optical character recognizers may search words substitutions searching telephone license numbers postal codes etc users require penalties certain types edit operations also combination exact search approximate search often remember numbers sure text searching patterns often expressed terms regular expressions extensions described section except section 55 discussed 28 present using dp 51 best match applications know exact number errors search want strings minimal number mismatches ie strings 0k mismatches string text k 0 k mismatches use algorithm define preset k small number less minimal distance ie exists string text dpattern k simple method set k let arbitrary string text set better way search pattern using deletions insertions substitutions traverse trie following pattern string whenever subtrie corresponds character pattern skip character pattern look subtrie next character number skipped characters used initial k traverse k path root leaf node whenever k k 0 set clear strings found best match searching decreases monotonically 52 weighted costs distances evaluated assumed cost 1 edit op eration sometimes may want different cost example substitution costs least one deletion one insertion disallow deletions completely make edit operations cost differently need modify distance function let r costs insertion deletion substitution transposition respectively assume costs disallow operation say insertions set 1 otherwise redefine else else furthermore may add cost c changing case example case insensitive searches set case sensitive searches set may even disallow case changes setting checking case difference let b mean b case define c ij c else replace else else concept changing cases extended even generally example searching white page telephone numbers dont want apartment number 304b recognized telephone number ie replace character unless digit digit reason may want mix letters digits punctuation searching license plates rmp167 postal codes h3a 2a7 applications use definitions give new interpretation c elaborate 53 combining exact approximate searches sometimes know advance certain parts pattern may errors example many spelling checkers may give suggestions garantee suppose knew suffix rantee spelled right case want search part pattern exactly following agrep standards 28 denote pattern garantee characters inside cannot edited using one four operations support exact approximate searches pattern need modify ij predicate determines whether p member character inside exact match let function p predicate tells whether p last character inside new definitions else else else else r p else definitions string guarantees also matches garantee two insertions disallow insertions end exact match introduce anchor symbol borrowed unix standards pattern garantee means target strings must suffix rantee needs changed set p false ie pattern looks like similar way introduce another anchor symbol prevent insertions beginning exact match example garantee means target strings must start letter g ended suffix rantee time set j p 0 true 54 approximate regular expression search ability match regular expressions errors important prac tice regular expression matching kapproximate string matching solve different problems may overlap coincide example regular expression ac oneplace wildcard written 1approximate match substitutions insertions second character baezayates 5 proposed search algorithm full regular expression tries section extend trie algorithm deal regular expression operators errors however extension operators work single characters ie group operator example may search ab mismatches ab searching tries full regular expression approximation open problem 541 alternative operator suppose want find postal codes h3a 2a either 1 3 7 first introduce notation 137 borrowed unix standard describe either 1 3 7 formally operator defines set alternative characters thus h3a 2a7 matches pattern h3a 2a137 exactly h3a 2a4 matches pattern one mistake substituting one character set allowable characters easily achieved redefining operators section 2 section 52 respectively pattern p 7 h3a 2a137 either 1 w j 3 w j 7 w j words p set allowable characters matches one characters defined operator case insensitive version syntactic sugar unix standards may denote az lower case letters ie range characters aeiou anything vowels ie complement listed characters characters ie wild card 542 kleen star kleen star allows associated characters deleted free replaced one identical character free example ac abc abbc abbbc match pattern abc exactly a09c means unbounded number digits appear c let function lambdap predicate says kleen star associated pattern character p support kleen star operator need change ij ij remember p means delete p cost insert number cost give new definition follows else else 55 counter algorithm also extended provide counters unlike kleen star eg abc means unbounded number bs appear c pattern abc says ac abc match exactly want strings abbc abbbc abbbbc abbbbbc ie two five bs c write pattern abbbbbc abf25gc unix syntax support counters need modify ij since p means character deleted free let us define function p says counter symbol associated pattern character p new definition else 6 dictionary search dictionary mean text file contains keywords ie set strings pairwise distinguishable dictionary searches interested keywords relate pattern measurements case edit distance orders locations keywords important us applications text file stored entirely trie structure trie figure 3 dictionary trie experimental results 22 show dictionary trie sizes 50 file sizes english words words providing algorithm exact approximate searches also data structure compressing data 50 searches done structure without decompression operations searching soundex codes 20 example dictionary search replacing english words soundex codes storing codes dictionary trie able search given soundex code efficiently exact trie search also reduce soundex code size half searching inverted file another example dictionary search inverted file sorted list keywords text trie structure keeps order keys storing keywords dictionary trie either search keywords location furthermore trie algorithm provides search methods various patterns without mismatches 7 conclusion tries used search exact matches long time paper expanded trie methods solve k approximate string matching problem approximate search algorithm finds candidate words k differences large set n words ok jsigmaj k expected worst time search time independent n algorithm achieves time complexity known algorithm searches trie depth first shortcuts smaller k subtries cut irrelevant subtries cut gives exact string search time proportional length string sought algorithm also used search full regular expressions 3 proposed trie structure uses two bits per node pointers trie structure designed storing large sets word strings secondary storage trie partitioned pages neighboring nodes parents children siblings clustered terms pages pages organized tree like structure searched time logarithmic file size trie method outperforms agrep results show order magnitude k0 factor 4 k1 k2 linear worst case performance agrep begin beat trie method moderately large documents measured 8 future work spelling checkers based searching minimal edit distance performs excellently typographic errors phonetic errors example exsample example one difference sinary scenery three differences deal phonetic misspellings may follow veroniss work 25 giving weights edit operations based phonetic similarity using noninteger distances obtain finer grained scores typographic phonetic similarities another solution follow convention assumes mistakes first two letters gives higher penalty first mistakes excluding first errors allows us bypass many subtries near trie root gives quicker search time also reduces number possible candidates small set candidate words impose linear phonetic check even one difference short word say 2 letters matches many english words short words long words type error difficult correct context acknowledgments work supported canadian networks centres excellence nce institute robotics intelligent systems iris projects b3 ic2 natural sciences engineering research council canada grant nserc ogp0004365 r myriad virtues suffix trees string searching algorithms efficient text searching regular expressions new approach text searching fast practical approximate string matching fast string searching algorithm approximate string matching sublinear expected time technique computer detection correction spelling errors efficient searching text pictures new indices text pat trees pat arrays approximate string matching approximate stringmatching algo rithm fast pattern matching strings techniques automatically correcting words text binary codes capable correcting deletions space economical suffix tree construction algorithm relational information systems trie methods representing text patent numbers multidimensional tries used associative searching trie methods text spatial data secondary stor age string searching algorithms finding approximate patterns strings computerized correction phonographic errors stringtostring correction problem linear pattern matching algorithms fast text searching tr ctr johan rnnblom higherror approximate dictionary search using estimate hash comparisons softwarepractice experience v37 n10 p10471059 august 2007 eike schallehn kaiuwe sattler gunter saake advanced grouping aggregation data integration proceedings tenth international conference information knowledge management october 0510 2001 atlanta georgia usa r w p luk timespace tradeoff analysis morphic trie images ieee transactions knowledge data engineering v13 n6 p10281032 november 2001 kimmo fredriksson online approximate string matching natural language fundamenta informaticae v72 n4 p453466 december 2006 sreenivas gollapudi rina panigrahy dictionary approximate string search longest prefix search proceedings 15th acm international conference information knowledge management november 0611 2006 arlington virginia usa liang jin chen li nick koudas anthony k h tung indexing mixed types approximate retrieval proceedings 31st international conference large data bases august 30september 02 2005 trondheim norway eike schallehn kaiuwe sattler gunter saake efficient similaritybased operations data integration data knowledge engineering v48 n3 p361387 march 2004 gonzalo navarro ricardo baezayates joo marcelo azevedo arcoverde matchsimile flexible approximate matching tool searching proper names journal american society information science technology v54 n1 p315 january jungim sanghyun park jeehee yoon sangwook kim efficient approach sequence matching large dna databases journal information science v32 n1 p88104 february 2006
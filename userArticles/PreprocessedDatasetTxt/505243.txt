optimal minimum spanning tree algorithm establish algorithmic complexity minimum spanning tree problem equal decisiontree complexity specifically present deterministic algorithm find minimum spanning tree graph n vertices edges runs time otmn minimum number edgeweight comparisons needed determine solution algorithm quite simple implemented pointer machinealthough time bound optimal exact function describing known present current best bounds known om mn certain natural inverse ackermanns functioneven assumption superlinear show input graph selected gnm algorithm runs linear time high probability regardless n permutation edge weights analysis uses new martingale gnm similar edgeexposure martingale gnp b introduction minimum spanning tree mst problem studied much century yet despite apparent simplicity problem still fully understood graham hell gh85 give excellent survey results earliest known algorithm boruvka bor26 invention fibonacci heaps central algorithms ft87 ggst86 chazelle chaz97 presented mst algorithm based soft heap chaz98 complexity ommn log n certain inverse ackermanns function recently chazelle chaz00 modied algorithm chaz97 bring running time om n later independent work similar algorithm running time presented pettie pet99 gives alternate exposition om n result tightest time bound mst problem date though known optimal updated version utcs technical report tr9917 includes performance analysis random graphs new references part work supported texas advanced research program grant 003658 00291999 seth pettie also supported mcd fellowship algorithms mentioned work pointer machine tar79 restriction edge weights may subjected binary comparisons powerful model assumed mst computed optimally fredman willard fw90 showed unitcost ram bitrepresentation edge weights may manipulated mst computed linear time karger et al kkt95 presented randomized mst algorithm runs linear time high probability even edge weights subject comparisons still unknown whether powerful models necessary compute mst linear time however paper give deterministic comparisonbased mst algorithm runs pointer machine ot n time n number edgeweight comparisons needed determine mst graph edges n vertices additionally show algorithm runs linear time vast majority graphs regardless density permutation edge weights nature algorithm exact running time known might seem paradoxical rst source algorithms optimality mysterious running time use precomputed mst decision trees whose exact depth unknown nonetheless provably optimal trivial lower bound algorithm best upper bound ommn due chazelle chaz00 point precomputing optimal decision trees increase constant factor hidden bigoh notation result nonuniform algorithm optimal mst algorithm contrasted complexitytheoretic result optimal verication algorithm problem used construct optimal algorithm problem jo97 though asymptotically optimal construction hides astronomical constant factors proves nothing relationship algorithmic complexity decisiontree complexity see section 8 discussion related issues next section review wellknown mst results used algorithm section 3 prove key lemma give procedure partitioning graph mst respecting manner section 4 gives overview optimal algorithm discusses structure use precomputed decisiontrees mst problem section 5 gives algorithm proof optimality section 6 shows algorithm may modied run pointer machine section 7 show algorithm runs lineartime whp input graph selected random sections 8 9 discuss related problems algorithms open questions actual complexity mst preliminaries input undirected graph e edge assigned distinct realvalued weight minimum spanning forest msf problem asks spanning acyclic subgraph g least total weight paper assume convenience input graph connected since otherwise nd connected components linear time solve problem connected component thus msf problem identical minimum spanning tree problem wellknown one identify edges provably msf using cut property edges provably msf using cycle property cut property states lightest edge crossing partition vertex set two parts must belong msf cycle property states heaviest edge cycle graph cannot msf 21 boruvka steps earliest known msf algorithm due boruvka bor26 algorithm quite simple proceeds sequence stages stage executes boruvka step graph g identies set f consisting minimumweight edge incident vertex g adds edges msf since must msf cut property forms graph input next stage gnf graph obtained contracting connected component formed f computation performed linear time since number vertices reduces least factor two running time algorithm om log n n number vertices edges input graph optimal algorithm uses procedure called boruvka2g f g 0 procedure executes two boruvka steps input graph g returns contracted graph g 0 well set edges f identied msf two steps 22 dijsktrajarnkprim algorithm another early msf algorithm runs om log n time one jarnk jar30 rediscovered dijkstra dij59 prim prim57 refer algorithm djp algorithm brie djp algorithm grows tree initially consists arbitrary vertex one edge time choosing next edge following simple criterion augment minimum weight edge x x 2 62 cut property edges msf lemma 21 let tree formed execution number steps djp algorithm let e f two arbitrary edges exactly one endpoint let g maximum weight edge path e f g cannot heavier e f proof let p path connecting e f assume contrary g heaviest edge p fe fg consider moment g selected djp let p 0 portion p present tree exactly two edges p p eligible chosen djp algorithm moment one edge g edge p choice g must lighter g edge either e f assumption must lighter g cases g could chosen next djp algorithm contradiction 2 23 dense case algorithm algorithms presented ft87 ggst86 chaz97 chaz00 pet99 nd msf graph linear time graph suciently dense ie suciently large edgetovertex ratio purposes suciently dense mean 3 n n number vertices graph algorithms run linear time density procedure densecaseg f takes input nnode graph g returns msf f g linear time graphs density 263 3 n optimal algorithm call densecase graph derived nnode medge graph contracting vertices number vertices reduced factor n number edges contracted graph straightforward see densecase run om n time graph 24 soft heap main data structure used algorithm soft heap chaz98 soft heap kind priority queue gives us optimal tradeo accuracy speed supports following operations makeheap returns empty soft heap inserts x insert item x heap findmins returns item smallest key heap delete x heap create new heap containing union items stored 1 2 destroying 1 2 process operations take constant amortized time except insert takes olog 1 save time soft heap allows items grouped together treated though single key item adopts largest key item group corrupting item new key diers original key thus original key item returned findmin ie item group minimum key keys uncorrupted items heap guarantee n insert operations n corrupted items heap following result shown chaz98 lemma 22 fix parameter 0 12 beginning prior data consider mixed sequence operations includes n inserts soft heap amortized complexity operation constant except insert takes olog1 time n items corrupted given time 3 key lemma procedure 31 robust contraction lemma well known tree msf edges contract single vertex maintaining invariant msf contracted graph plus gives msf graph contraction algorithm nd tree msf edges corrupted graph edge weights increased due use soft heap lemma given show useful information obtained contracting certain corrupted trees particular constructed using number steps dijkstrajarnikprim djp algorithm ideas similar used chazelles 1997 algorithm chaz97 explicitly recent algorithms pettie pet99 chazelle chaz00 stating lemma need notation preliminary concepts let v g eg vertex edge sets g n cardinality respectively let gweight edge weight graph g g may omitted implied context following denitions c subgraphs g denote g graph derived g raising weight edge arbitrary amounts edges said corrupted let mc set edges exactly one endpoint c let gnc denote graph obtained contracting connected components induced c ie replacing connected component single vertex reassigning edge endpoints appropriately dene subgraph c g djpcontractible executing djp algorithm g number steps suitable start vertex c tree results spanning tree c lemma 31 let set edges graph g c subgraph g djpcontractible wrt g msf g subset msf c msf gnc mc mc proof edge c msfc heaviest edge cycle c since cycle exists g well edge msfg need show edges gnc msfgnc mc also msfg hence need show edge h msf h msf g let e heaviest edge cycle h ie e 2 h msf h involve vertex derived contracting c exists g well e 62 msf g otherwise forms path p g whose end points say x c let end edges p x w included corrupted edges one end point c gweight edges g mweight let spanning tree c derived djp algorithm q path connecting x g heaviest edge q notice p q forms cycle choice e must heavier x w z lemma 21 heavier x w z heavier g mweight g upper bound gweights edges q wrt gweights e heaviest edge cycle p q cannot msf g 2 32 partition procedure algorithm uses partition procedure given procedure nds djp contractible subgraphs c edges progressively corrupted soft heap let mc contain corrupted edges one endpoint c time completed subgraph c djpcontractible wrt graph derived g several rounds contractions edge deletions c nished contracted incident corrupted edges discarded applying lemma 31 repeatedly see c built msf g subset msf partition procedure shown figure 1 arguments appearing semicolon inputs others outputs set edges cfc set subgraphs g edge appear one mc initially partition sets every vertex live objective convert vertex dead signifying part component c maxsize vertices part conglomerate maxsize vertices conglomerate connected component graph intuitively conglomerate collection c linked common vertices scheme growing components similar one given ft87 grow c one time according djp algorithm except use soft heap component done growing reaches maxsize vertices attaches existing component clearly component reach maxsize vertices linked partitiong vertices initially live live vertex increment live vertex create soft heap consisting vs edges uses vertices v live jv j maxsize repeat find delete minweight edge x soft heap live insert ys edges soft heap vertices v dead corrupted edges one endpoint v dismantle soft heap let c fc z subgraph g induced v z exit figure 1 partition procedure conglomerate least maxsize vertices hence vertices designated dead upon completion component c discard set corrupted edges one endpoint c running time partition dominated heap operations depend edge inserted soft heap twice endpoint extracted charge cost dismantling heap insert operations created hence total running time om log 1 number discarded edges bounded number insertions scaled thus jm j 2m thus lemma 32 given graph g 0 1 2 parameter maxsize partition nds edgedisjoint subgraphs b jv c j maxsize c conglomerate p 2 jemj 2 jegj 4 overview optimal algorithm overview optimal msf algorithm rst stage nd djpcontractible subgraphs c associated set edges consists corrupted edges one endpoint c second stage nd msf f c msf f 0 contracted graph gn 31 msf whole graph contained within note point identied edges msf original graph g third stage nd msf edges via boruvka steps recurse graph derived contracting edges execute rst stage using partition procedure described previous section execute second stage optimal decision trees essentially hardwired algorithms designed compute msf graph using optimal number edgeweight comparisons general decision trees much larger size problem solve nding optimal ones time consuming aord cost building decision trees guaranteeing one extremely small time make conglomerate formed c suciently large msf f 0 contracted graph found linear time using densecase algorithm finally third stage reduction vertices due boruvka steps reduction edges due application lemma 31 optimal algorithm vertices edges reduce constant factor thus resulting recursive applications algorithm graphs geometrically decreasing sizes 41 decision trees msf decision tree rooted tree edgeweight comparison associated internal node eg weightx weightw z internal node exactly two children one representing comparison true false leaves tree list edges spanning tree msf decision tree said correct edgeweight comparisons encountered path root leaf uniquely identify spanning tree leaf msf decision tree said optimal correct exists correct decision tree lesser depth let us bound time needed nd optimal decision trees graphs r vertices brute force search fewer 2 r 2 graphs graph must check possible decision trees bounded depth r 2 r 4 possibilities internal node r 2 r 2 o1 decision trees check determine decision tree correct generate possible permutations edge weights solve msf problem given graph simultaneously check permutations decision tree first put permutations root move left right child depending truth falsity edgeweight comparison wrt permutation repeat step permutations reach leaf leaf permutations sharing leaf agree msf decision tree correct process takes longer r decision tree setting allows us precompute optimal decision trees time observe highlevel algorithm gave section 4 maximum size component c suciently small components organized relatively small number groups isomorphic components ignoring edge weights group use single precomputed optimal decision tree determine msf components group optimal algorithm use procedure decisiontreeg f takes input collection graphs g r vertices returns minimum spanning forests f using precomputed decision trees 5 algorithm discussed optimal msf algorithm follows first precompute optimal decision trees graphs log 3 n vertices next divide input graph subgraphs discarding set corrupted edges mc c completed use decision trees found earlier compute msf f c contract connected component spanned f ie conglomerate single vertex resulting graph n log 3 n vertices since conglomerate least log 3 n vertices lemma 32 hence use densecase algorithm compute msf f 0 time linear point lemma 31 msf contained edge set f graph apply two boruvka steps reducing number vertices factor four compute recursively algorithm given used soft heap partition procedure precompute optimal decision trees graphs log 3 n 0 vertices n 0 number vertices original input graph r log 3 jv gj partitiong g apart recursive calls using decision trees computation performed opti malmsf clearly linear since partition takes om log 1 owing reduction vertices call densecase also takes linear time 8 number edges passed nal recursive call m4 giving geometric reduction number edges since msf algorithm better linear time bottleneck must lie using decision trees optimal construction concretely let n running time optimalmsf let n optimal number comparisons needed graph n vertices edges let g optimal number comparisons needed specic graph g recurrence relation given base case note graphs recursive calls connected input graph connected hence base case graph edges one vertex 0 1 equal constant straightforward see n om recurrence gives om one also show n ot n many natural functions including n however show result holds matter function describing n need establish results decision tree complexity msf problem next section 51 results msf decision trees section establish results msf decision trees allow us establish main result optimalmsf runs ot n time proposition 51 n m2 proposition 52 xed proposition 51 obviously true since every edge participate comparison determine inclusion exclusion msf proposition 52 holds since add isolated vertices graph obviously aect msf number necessary comparisons state property used lemmas 54 55 property 53 structure g dictates edgedisjoint subgraphs g components returned partition seen graph denition 53 since every simple cycle graph must contained exactly one c see consider simple cycle let largest index c contains edge cycle since c shares one vertex contain edge proof following lemma found pr99b lemma 54 property 53 holds g exists optimal msf decision tree g makes comparisons form e f e 2 c proof consider subset p permutations edge weights e 2 c holds weighte weightf permutations p two useful properties readily veried first number intercomponent comparisons shed light relative weights edges component second spanning forest component msf component permutation p consider optimal decision tree g let 0 subtree contains leaves reached permutation p intercomponent comparison node must one child rst property msf leaf deduced using intracomponent comparisons second property 0 must determine msf component correctly thus property 53 must determine msf graph g correctly hence contract 0 correct decision tree 00 replacing onechild node child 2 lemma 55 property 53 holds g proof given optimal decision trees c construct decision tree g replacing leaf 1 2 general replacing leaf i1 labeling leaf last tree union labels original trees along path clearly height tree sum heights hence g need prove optimal decision tree g height less sum heights let optimal decision tree g intercomponent comparisons guaranteed lemma 54 show transformed canonical decision tree 0 g height 0 comparisons c precede comparisons c i1 subgraph 0 containing comparisons within c consists collection isomorphic trees establishes desired result since 0 must contain path concatenation longest path optimal decision tree c rst prove result case two components c 1 c 2 assume inductively subtrees rooted vertices certain depth transformed desired structure c 1 comparisons occur c 2 comparisons subtrees c 2 within subtrees rooted depth isomorphic trivially case equal height consider node v depth 1 comparison node c 1 comparison c 2 subtrees descendent nodes must compute set leaves c 2 hence subtree rooted v converted desired format simply replacing c 2 subtrees one minimum depth note two dierent c 2 subtrees c 2 subtrees descendent left right child v must isomorphic comparison v c 2 comparison know c 1 subtrees rooted left child x right child must compute set leaves c 1 hence pick c 1 subtree smaller height wlog let root x replace v x together c 1 subtree rooted x copy comparison node v leaf position c 1 subtree copy place one isomorphic copies c 2 subtree descendant x left subtree c 2 subtree descendant right subtree subtree rooted x depth 1 desired form computes result increase height tree hence induction converted canonical decision tree greater height assume inductively result hold k 1 2 components result easily extends k components noting group rst k 1 components c 0 1 let c k c 0 method transform canonical tree c k comparisons appear leaf subtrees strip c k subtrees canonical tree inductive assumption perform transformation remaining k 1 components 2 corollary 56 let c components formed partition routine applied graph g let g edges n vertices corollary 57 n solve recurrence relation running time optimalmsf given previous section corollary 56 corollary 57 propositions 51 52 c n suciently large c completes induction gives us desired theorem theorem 58 let n decisiontree complexity msf problem graphs edges n nodes algorithm optimalmsf computes msf graph edges n vertices deterministically ot n time 6 avoiding pointer arithmetic precisely specied required underlying machine model upon examina tion algorithm seem require full power random access machine ram bit manipulation used arithmetic limited increment operation however procedure decisiontree implemented obvious manner require using table lookup thus random access memory section describe alternate method handling decision trees run pointer machine tar79 model allow random access memory method similar described b98 ensure time overhead performing table lookups call decisiontree linear size current input decisiontree pointer machine distinguishes pointers data types operations allowed pointers assignment comparison equality dereferencing memory organized records holds constant number pointers normal data words integers oats etc given pointer particular record refer pointer data word record constant time nonpointer data usual array logical arithmetic binary comparison operations allowed rst describe representation decision tree decision tree associated generic graph edge weights decision tree determine mst permutation edge weights generic graph internal node decision tree four pointers rst two point edges generic graph compared second two point left right child node leaf lists edges spanning tree generic graph since decision tree pointerbased structure construct precomputed decision tree enumerating checking possibilities without using table lookups describe representation generic graphs vertices generic graph numbered order integers starting 1 representation consists listing vertices order starting 1 followed adjacency list vertex starting vertex 1 generic graph pointer root decision tree recall precomputed decision trees generic graphs log 3 n 0 vertices n 0 number vertices input graph whose msf need nd generic graphs generated stored lexicographically sorted order note represen tation sorted order generic graphs appear nondecreasing order number vertices graph using decision tree actual graph must isomorphic generic graph decision tree must associate edge actual graph counterpart generic graph thus comparison edge weights generic graph substituted corresponding weights actual graph constant time random access machine encode possible graph single machine word say adjacency matrix index generic graph array according representation thus given graph nd associated decision tree constant time pointer machine however converting bit vector integer pointer specically disallowed describe method identify generic graph c eciently assume c specied adjacency lists representation edge x pointer occurrence x ys adjacency list edge also pointer record containing weight let n number edges vertices rewrite c form generic graphs call numerical representation let c p vertices note p r assign vertices numbers 1 p order listed adjacency lists representation rewrite edge pair numbers indicating endpoints edge retain pointer weight separate numerical representation change format graph follows instead list numbers range 1r represent graph list pointers initialize linked list r buckets labeled 1 r numerical representation number j appears replaced pointer j th bucket transform graph pointer representation traversing rst list vertices list edges order traversing list buckets simultaneously replacing vertex entry rst vertex entry edge pointer corresponding bucket thus edge x also appearing x appear ptrx ptry x employ twin pointers replace remaining x equivalent pointers clearly transformation performed om time sum sizes perform lexicographic sort ahu74 sequence c order group together isomorphic components representation replace bucket indexing performed traditional lexicographic sort access bucket pointer placed element hence running time pointerbased lexicographic sort length th vector decisiontree called graphs size r olog 3 n sum sizes graphs om hence radix sort performed om finally march sorted list c sorted list generic graphs matching appropriate need traverse initial sequence sorted generic graphs containing o2 r 2 entries order match graphs takes time om 7 performance random graphs even assume mst superlinear complexity show algorithm runs linear time nearly graphs regardless edge weights improves upon expected lineartime result karp tarjan kt80 depended edge weights chosen randomly result may also contrasted randomized algorithm karger et al kkt95 shown run om time whp proof depends permutation edge weights random bits chosen graph topology fact none earlier published mst algorithms appear property running linear time whp random graphs edgeweights using analysis section suitably soupedup versions earlier algorithms ft87 ggst86 chaz00 may obtain high probability result analysis hinges observation sparse random graphs whp subgraph constructed partition routine miniscule number edges excess number spanning forst edges subgraph mst graphs computed linear time hence computation optimal decision trees takes linear time graphs throughout section denote n theorem 71 mst graph found linear time probability e graph drawn g nm graph drawn g np 1 2 hold regardless permutation edge weights next section describe edgeaddition martingale g nm model section 72 use martingale azumas inequality prove part 1 theorem 71 part 2 shown follow part 1 71 edgeaddition martingale consider g nm random graph model graph n labeled vertices edges equally likely analytical purposes select random graph beginning n vertices adding one edge time er61 let x random edge st x graph made rst edges g 0 graph n vertices edges martingale sequence random variables prove g graphtheoretic function martingale lemma 72 sequence martingale g graph theoretic function g 0 edgefree graph n vertices g derived g 1 adding random edge g 1 g 1 g given g 1 xed call sequence proved martingale lemma 72 edgeaddition martingale contrast edgeexposure martingale g np recall wellknown azumas inequality see eg as92 theorem 73 azumaa inequality let ym martingale jy let 0 arbitrary prjy facilitate application azumas inequality edgeaddition martingale establish following lemma lemma 74 consider sequence proved martingale lemma 72 let g graphtheoretic function jgg gg 0 j 1 pair graphs g g 0 form average range possible outcomes given g g 1 respectively identify outcome equalsize disjoint sets outcomes x cover outcomes x may regarded average set averages set corresponding outcome p x establish set average diers gg p 1 lemma follows correspondence follows let outcome x corresponding set consists outcomes x j ranges edges appearing g 1 x outcome i1 q p associated set since graphs dier one edge clearly holds well average outcomes q p associated set 2 72 analysis dene excess subgraph h jehj jf hj f h spanning forest h let fg maximum excess graph made intracomponent edges sets components range possible sets returned partition procedure recall size component key observation leading lineartime result pass optimal algorithm denitely runs linear time fg mmn see note bound fg holds reduce total number intracomponent edges 2m linear time using log boruvka steps clearly mst resulting graph determined om time show graph randomly chosen g nm fg mmn high probability show lemma 74 applies graphtheoretic function f apply azumas inequality obtain desired result lemma 75 let two graphs set labeled vertices dier one edge jfg fg 0 j 1 proof suppose wlog fg fg 0 1 could apply optimal set components g g 0 every intracomponent edge g remains intracomponent edge except possibly e reduce excess one contradiction possibility e 0 may become intracomponent edge help argument 2 lemma proof notice simply impossible intracomponent edges assume upper bound f e g 0 expected number indices st edge x completed cycle length k g 1 since edges caused f increase must satised criterion probability x completed cycle length k bounding number cycles probability exist graph n nm recall n either case f g chosen g nm prfg e proof applying azumas inequality prjf e gm setting gives lemma note lemma 76 f insignicant 2 ready prove theorem 71 proof examine rst log k passes optimal algorithm since remaining passes certainly take om time lemma 77 assures us rst pass runs linear time whp however topology graph examined later passes depend edge weights assuming boruvka steps contract parts graph constant rate easily enforced partition graph one pass algorithm corresponds partition original graph components size less k c xed c using k c place k aect lemma 76 gives theorem g nm part 1 g np note probability pn 2 edges exponential pn 2 hence probability algorithm fails run linear time dominated bound part 1for sparse case n theorem 71 part 1 holds probability 1 1n cherno bound part 2 holds probability 1 e n intriguing aspect algorithm know precise deterministic running time although prove within constant factor optimal results nature obtained past sensitivity analysis minimum spanning trees drt92 convex matrix searching lar90 also problem triangulating convex polygon observed drt92 alternate lineartime algorithm could obtained using optimal decision trees small subproblems however earlier algorithms make use decision trees straightforward ways algorithm presented noted section 41 construction optimal decision trees takes sublinear time thus important observe use decision trees result large constant factor running time construction optimal decision trees performed straightforward bruteforce search hence resulting algorithm uniform mentioned introduction optimal algorithm constructed prob lem given optimal verication algorithm problem jo97 construction produces algorithm enumerates programs machine model executes incrementally whenever one programs halts verier checks output correctness using lineartime mst verication algorithm drt92 k97 b98 construction yields optimal mst algorithm however unsatisfactory several reasons aside truly astronomical constant factors roughly exponential size optimal program algorithm optimal respect particular machine model say tm ram pointer machine result contrast robust ties algorithmic complexity mst decisiontree complexity limiting factor machine model always case algorithmic complexity decisiontree complexity asymptotically equivalent fact one easily concoct simple problems nphard nevertheless polynomialdepth decisiontrees eg nd lightest edge hamiltonian path see gks93 pr01 section 8 two sortingtype problems whose decisiontree complexity algorithmic complexity provably diverge 9 conclusion presented deterministic msf algorithm provably optimal algorithm runs pointer machine graphs n vertices edges running time ot n n decisiontree complexity msf problem nnode medge graphs also random graphs algorithm runs linear time high probability possible edgeweights although exact running time algorithm known shown time bound depends number edgeweight comparisons needed determine msf data structural issues determining worstcase complexity algorithm main open question remaining msf problem however subtler open question given optimal uniform algorithm msf problem optimal uniform algorithm use precomputed decision trees similar technique generally problems precomputation necessary one may wish study issue simpler setting say msf verication problem pointer machine still n factor separating best pointer machine algorithm uses precomputed decision trees b98 one tar79b one may also ask parallel complexity msf problem resolved recently randomized worktime complexity pr99 deterministic time complexity chl99 msf problem erew pram open question remains obtain deterministic worktime optimal parallel msf algorithm parallelizing optimal algorithm straightforward although handling decision trees present problems parallel context still need method identifying contractible components parallel base case algorithm performs linear work graphdensities log 3 n existing sequential algorithms suitable base case one ft87 also easily parallelizable r design analysis computer algorithms probabilistic method faster deterministic algorithm minimum spanning trees minimum spanning tree algorithm inverseackermann type complexity parallel time complexity undirected connectivity minimum spanning trees note two problems connexion graphs fibonacci heaps uses improved network optimization algorithms history minimum spanning tree problem optimal randomized algorithms local sorting set maxima computability complexity programming perspective randomized lineartime algorithm nd minimum spanning trees linear expectedtime algorithms connectivity problems simpler minimum spanning tree veri optimal algorithm unknown time complexity convex matrix searching randomized timework optimal parallel algorithm nding minimum spanning forest proceedingsproc optimal minimum spanning tree algorithm computing undirected shortest paths comparisons additions finding minimum spanning trees om shortest connection networks generalizations class algorithms require nonlinear time maintain disjoint sets applications path compression balanced trees tr efficient algorithms finding minimum spanning trees undirected directed graphs fibonacci heaps uses improved network optimization algorithms optimal algorithm unknown time complexity convex matrix searching verification sensitivity analysis minimum spanning trees linear time optimal randomized algorithms local sorting setmaxima transdichotomous algorithms minimum spanning trees shortest paths randomized lineartime algorithm find minimum spanning trees computability complexity lineartime pointermachine algorithms least common ancestors mst verification dominators applications path compression balanced trees soft heap minimum spanning tree algorithm inverseackermann type complexity concurrent threads optimal parallel minimum spanning trees algorithm computing shortest paths comparisons additions minimizing randomness minimum spanning tree parallel connectivity set maxima algorithms design analysis computer algorithms randomized timework optimal parallel algorithm finding minimum spanning forest faster deterministic algorithm minimum spanning trees finding minimum spanning trees om alphamn time ctr jess cerquides ramon lpez mntaras tan classifiers based decomposable distributions machine learning v59 n3 p323354 june 2005 artur czumaj christian sohler estimating weight metric minimum spanning trees sublineartime proceedings thirtysixth annual acm symposium theory computing june 1316 2004 chicago il usa tzuchiang chiang chienhung liu yuehmin huang nearoptimal multicast scheme mobile ad hoc networks using hybrid genetic algorithm expert systems applications international journal v33 n3 p734742 october 2007 seth pettie new approach allpairs shortest paths realweighted graphs theoretical computer science v312 n1 p4774 26 january 2004 ran mendelson robert e tarjan mikkel thorup uri zwick melding priority queues acm transactions algorithms talg v2 n4 p535556 october 2006 amos korman shay kutten distributed verification minimum spanning trees proceedings twentyfifth annual acm symposium principles distributed computing july 2326 2006 denver colorado usa
prioritized multiprocessor spin lock abstractin paper present pr lock prioritized spin lock mutual exclusion algorithm pr lock contentionfree spin lock blocked processes spin locally stored cached variables contrast previous work prioritized spin locks algorithm maintains pointer lock holder result spin lock support operations lock holder eg abort ceiling protocols unlike previous algorithms work maintain priority queue done process acquires lock blocked anyway releasing lock constant time operation present simulation results demonstrate prioritized acquisition locks compare performance pr lock best alternative prioritized spin lock b introduction mutual exclusion fundamental synchronization primitive exclusive access critical sections shared resources multiprocessors 17 spinlock one mechanisms used provide mutual exclusion shared memory multiprocessors 2 spinlock usually implemented using atomic read modifywrite instructions testset compareswap available sharedmemory multiprocessors 16 busy waiting effective critical section small processor resources needed processes interim however spinlock usually fair naive implementation severely limit performance due network memory contention 1 11 careful design avoid contention requiring processes spin locally stored cached variables 19 real time systems process timing constraints associated priority indicating urgency process 26 priority used operating system order rendering services among competing processes normally higher priority process faster request services gets honored synchronization primitives disregard priorities lower priority processes may block execution process higher priority stricter timing constraint 24 23 priority may cause higher priority process miss deadline leading failure real time system work done synchronization based priorities thus suitable real time systems furthermore general purpose parallel processing systems often processes important others kernel processes processes hold many locks etc performance systems benefit prioritized access critical sections paper present prioritized spinlock algorithm prlock prlock algorithm suitable use systems either use staticpriority schedulers use dynamicpriority schedulers relative priorities existing tasks change blocked earliest deadline first 26 minimum laxity 15 prlock contentionfree lock 19 use create excessive network memory contention prlock maintains queue records one record process requested yet released lock queue maintained sorted order except head record acquire lock operations release lock operation performed constant time result queue order maintained processes blocked anyway high priority task perform work low priority task releases lock lock keeps pointer record lock holder aids implementation priority inheritance protocols 24 23 tasks lock request release performed welldefined points time makes lock predictable present correctness proof simulation results demonstrate prioritized lock access locality references improvement previously proposed prioritized spin lock organize paper follows section 11 describe previous work area section 2 present algorithm section 3 argue correctness algorithm section 4 discuss extension algorithm presented section 2 section 5 show simulation results compare performance prlock similar algorithms section 6 conclude paper suggesting applications future extensions prlock algorithm 11 previous work prlock algorithm based mcslock algorithm spinlock mutual exclusion algorithm sharedmemory multiprocessors 19 mcslock grants lock requests fifo order blocked processes spin locally accessible flag variables avoiding contention usually associated busywaiting multiprocessors 1 11 process record represents place lock queue mcslock algorithm maintains pointer tail lock queue process adds queue swapping current contents tail pointer address record previous tail nil process acquired lock otherwise process inserts pointer record record previous tail spins flag record head queue record lock holder lock holder releases lock reseting flag successor record successor exists lock holder sets tail pointer nil using compareswap instruction molesky shen zlokapa 20 describe prioritized spin lock uses testandset instruction algorithm based burns fair testandset mutual exclusion algorithm 5 however lock contentionfree markatos leblanc 18 presents prioritized spinlock algorithm based mcslock algorithm acquire lock algorithm almost mcs acquire lock algorithm exception markatos algorithm maintains doubly linked list lock holder releases lock searches highest priority process queue process record moved head queue flag reset however point task requests releases lock well defined lock holder might release lock low priority task even though higher priority task entered queue addition work maintaining priority queue performed lock released choice makes time release lock unpredictable significantly increases time acquire release lock shown section 5 craig 10 proposes modification mcs lock markatos lock substitutes atomic swap compareswap instruction permits nested locks using one lock record per process goscinski 12 develops two algorithms mutual exclusion real time distributed systems algorithms based token passing process requests critical section broadcasting intention processes system one algorithm grants token based priorities processes whereas algorithm grants token processes based remaining time run processes holder token enters critical section utility prioritized locks demonstrated rate monotonic scheduling theory 9 24 suppose n periodic processes uniprocessor let e c represent execution time cycle time periodicity process assume c 1 c 2 cn assumption blocking 9 show j processes meet deadlines suppose b j worst case blocking time process j incur 24 show tasks meet deadlines thus blocking high priority process lower priority process significant impact ability tasks meet deadlines much work done bound blocking due lower priority processes example priority ceiling protocol 24 guarantees high priority process blocked lower priority process duration one critical section priority ceiling protocol extended handle dynamicpriority schedulers 7 multiprocessors 23 8 contribution previous work developing prioritized contentionfree spin locks 18 10 directly implement desired priority queue algorithm maintains pointer head lock queue record lock holder result prlock used implement priority inheritance 24 23 work maintaining priority ordering performed acquire lock operation task blocked anyway time required release lock small predictable reduces length variance time spent critical section prlock welldefined points time task joins lock queue releases lock result guarantee highest priority waiting task always receives lock finally provide proof correctness prlock algorithm similar mcslock algorithm maintain queues blocked processes using compareswap instruction however mcslock markatos lock maintain global pointer tail queue prlock algorithm maintains global pointer head queue mcslock markatos lock processes queued fifo order whereas prlock queue maintained priority order processes 21 assumptions make following assumptions computing environment 1 underlying multiprocessor architecture supports atomic compareswap instruction note many parallel architectures support instruction related instruction 13 21 3 28 2 multiprocessor shared memory coherent caches locallystored globally accessible shared memory 3 processor record place queue lock numa architecture record allocated local globally accessible memory record used purpose lifetime queue section 4 allow record used among many lock queues 4 higher actual number assigned priority higher priority process also assume opposite 5 relative priorities blocked processes change acceptable priority assignment algorithms include earliest deadline first minimum laxity noted process p participating synchronization associated unique processor p expect queued processes preempted though requirement correctness 22 implementation prlock algorithm consists two operations acquire lock operation acquires designated lock release lock operation releases lock process uses acquire lock release lock operations synchronize access resource acquire lockl r critical section release lockl following subsections present required version compareswap needed data structures acquire lock release lock procedures 221 compareswap prlock algorithms make use compareswap instruction code shown figure 1 compareswap often used pointers object records record refers physical memory space object refers data within record current pointer record old previously sampled value current new pointer record would like substitute old record pointed old compute record new based object old decide perform swap based object old want set current equal new current still points record old however even current points old might point different object one originally read occur old removed data structure reinserted current new object sequence events cannot detected compareswap known aba problem following work prakash et al 22 turek et al 27 make use doubleword com pareswap instruction 21 avoid problem counter appended current treated part current thus current consists two parts value part current counter part current counter incremented every time modification made current variables procedure casstructure pointer current old new assume cas operates double words atomicf current old else f figure 1 cas used prlock algorithm current old new twice original size approach reduces probability occurrence aba problem acceptable levels practical applications doubleword compareswap available address counter packed 32 bits restricting possible address range lock records use version compareswap operation current value target location returned old compareswap fails semantics compareswap used given figure 1 version compareswap instruction returns true false used performing additional read 222 data structures basic data structure used prlock algorithm priority queue lock l contains pointer first record queue first record queue belongs process currently using lock process l contains nil process locallystored globallyaccessible record insert lock queue process inserts record q queue say q ps record p qs process record contains process priority nextrecord pointer boolean flag locked process owning element busywaits lock free additional field data used store applicationdependent information lock holder nextrecord pointer double sized variable one half actual pointer half counter avoid aba problem counter portion pointer two parts one bit counter called dq bit used indicate whether queuing element queue rest bits used actual counter technique similar one used prakash et al 22 turek et al 27 counter refers record referenced pointer algorithm counter refers record contains pointer record pointed dq bit record q false record queue lock l dq bit true record probably queue short period time record might queue dq bit set true dq bit lets prlock avoid garbage accesses process keeps address record local variable self addition process requires two local pointer variables hold previous next queue element navigating queue enqueue operation prev node next node data structures used shown figure 2 dq bit pointer field initialized true ctr field initialized 0 record first used typical queue formed prlock algorithm shown figure 3 l points record q 0 current process holding lock record q 0 pointer record q 1 next process highest priority among processes waiting acquire lock l record q 1 points record q 2 next higher priority waiting process record q n belongs process least priority among waiting processes 223 acquire lock operation acquire lock operation called process using critical section resource guarded lock l parameters acquire lock operation lock pointer l record q process passed local variable self acquire lock operation searches correct position insert q queue using prev node next node keep track current position figure 4 prev node next node abbreviated p n records pointed p n q q i1 belonging processes p p i1 process positions p rp r function maps process priority position found q prepared insertion making q point q i1 insertion committed making q point q using compareswap instruction various stages final result shown figure 4 acquire lock algorithm given figure 5 acquire lock procedure called data priority fields process record initialized appropriately addition dq bit next pointer implicitly true acquire lock operation begins assuming lock currently free lock pointer l structure pointer f structure object ptr boolean dq structure record f structure structure data data boolean locked integer priority structure pointer next shared variable structure pointer l private variables structure pointer self prev node next node boolean success failure constant true false null max priority data priority nextctr nextptr locked nextdq record structure figure 2 data structures used prlock algorithm figure 3 queue data structure used prlock algorithm start position prepare commit figure 4 stages acquire lock operation null attempts change l point record compareswap instruction compareswap successful lock indeed free process acquires lock without busywaiting context composite pointer structures algorithm uses null pointer zeros swap unsuccessful acquiring process traverses queue position higher equal priority process record lower priority process record junction found point record higher priority process next node point record lower priority process process first sets link next node attempts change previous records link record atomic compareswap successful process sets dq flag record false indicating presence queue process busywaits locked bit set false indicating admitted critical section three cases unsuccessful attempt entering queue problems detected examining returned value failed compareswap marked f algorithm note returned value next node addition process might detect misnavigated searching queue read next node contents record pointed prev node fixed records counter read next node 1 concurrent acquire lock operation may overtake acquire lock operation insert procedure acquire lockl self f f else f lock use f next nodeprev nodeptrnext ifnext nodedqtrue deque try ii prev nodeptrpriorityselfptrpriority f iii else f ifnext nodeptrnull next nodeptrnull next nodeptrpriorityselfptrpriorityf use lock else f ifnext nodedqtrue deque try ii prev nodeptrpriority else next nodeprev node gwhilesuccess failure figure 5 acquire lock operation procedure record immediately prev node shown figure 10 case compareswap fail position marked f figure 5 correctness operations position affected operation continues current position line marked figure 5 2 concurrent release lock operation may overtake acquire lock operation removes record pointed prev node shown figure 11 case dq bit link pointer record true algorithm checks condition scans queue tries commit modifications algorithm detects situation two places marked ii figure 5 every time new record accessed prev node link pointer read next node dq bit checked addition compareswap fails link pointer saved next node dq bit tested dq bit true algorithm starts beginning 3 concurrent release lock operation may overtake acquire lock operation remove record pointed prev node record put back queue shown figure 12 record returns priority higher equal selfs priority position still correct operation continue otherwise operation cannot find correct insertion point start beginning condition tested lines marked iii figure 5 spinlock busy waiting process broken eventual release lock process immediately ahead waiting process 224 release lock operation release lock operation straight forward algorithm given figure 6 process p releasing lock sets dq bit records link pointer true indicating record longer queue setting dq bit prevents acquire lock operation modifying link releasing process copies address successor record l process releases lock setting locked boolean variable record next process waiting false avoid testing special cases acquire lock operation priority head record set highest possible priority 3 correctness prlock algorithm section present informal argument correctness properties prlock algorithm prove prlock algorithm correct showing maintains priority queue head procedure release lockl selff lselfptrnext release lock ifselfptrnextnullf figure release lock operation procedure priority queue process holds lock prlock decisiveinstruction serializable 25 operations prlock algorithm single decisive instruction decisive instruction acquire lock operation successful compareswap decisive instruction release lock operation setting dq bit corresponding concurrent execution c queue operations equivalent respect return values final states serial execution operation 1 executes decisive instruction operation 2 c 1 2 thus equivalent priority queue prlock single state instant simplifying correctness proof concurrent data structure linearizable decisiveinstruction serializable might several states simultaneously 14 use following notation discussion prlock l lock pointer l points first record lock queue record process holds lock let n processes p 1 participate lock synchronization priority lock l using prlock algorithm mentioned earlier process p allocates record q enqueue dequeue thus process p participating lock access associated queue record q let p rp function maps process priority number 1 n also define another function p rq maps record belonging process p priority priority queue abstract data type consists ffl finite set q elements simplicity assume every n unique assumption required correctness fact processes priority obtain lock fcfs order ffl two operations enqueue dequeue instant state queue defined call q 0 head record priority queue q head records process current lock holder note nonhead records totally ordered enqueue operation defined enqueue dequeue operation nonempty queue defined return value q 0 dequeue operation empty queue undefined every prlock l abstract priority queue q initially l q empty process p record q performs decisive instruction acquire lock operation q changes state enqueue q q similarly process executes decisive instruction release lock operation q changes state dequeueq show observe l find structure equivalent q observe l take consistent snapshot 6 current state system memory next start lock pointer l observe records following linked list head record dq bit set process exited acquire lock operation discard observation observe records sequence l q say l q equivalent write l q theorem 1 representative priority queue q equivalent observed queue prlock l proof prove theorem induction decisive instructions using following two lemmas release lock decisive instruction q l release lock decisive instruction proof let release lock decisive instruction release lock operation equivalent dequeue operation abstract queue definition q1 qn figure 7 observed queue l release lock figure 8 observed queue l acquire lock states l shown figure 7 l points record q 0 release lock decisive instruction release lock decisive instruction sets dq bit q 0 true removing q 0 observable queue thus q l release lock operation note l point q 1 next release lock decisive instruction 2 acquire lock decisive instruction q l acquire lock decisive instruction proof two different cases consider case 1 acquire lock decisive instruction equivalent operation abstract queue q enqueue operation thus lock l empty qs process executes successful decisive compareswap instruction make l point q acquires lock figure 8 clearly q acquire lock decisive instruction case 2 acquire lock decisive instruction state queue q acquire lock given corresponding l acquire lock shown figure 9 pointers p n prev node next node pointers qs acquire lock operation positions record process observes p rq next pointer q set address q i1 figure 9 observed queue l acquire lock compareswap instruction marked f figure 5 attempts make next pointer q point q compareswap instruction succeeds decisive instruction qs process resulting queue l illustrated figure 9 equivalent q enqueue operation compareswap succeeds q queue q i1 successor record p rq concurrent operations queue observe p n positioned correctly compareswap succeeds concurrent operations interfere execution acquire lock operation three possibilities case another acquire lock enqueued record q 0 q q i1 q yet dequeued p rq qs process attempt insert q q q i1 process 0 modified q next pointer qs compareswap fail since q dequeued process continue search q happens qs process skip q 0 continue searching q i1 happens scenario illustrated figure 10 case b release lock operation r overtakes removes q queue ie r set q dq bit q yet returned queue dq bit still false since q lock queue lost must start searching based observations q q i1 may decided continue searching queue commit operation either case sees dq bit set fails starts beginning queue scenario illustrated figure 11 case c release lock operation r overtakes removes q queue q put back queue another acquire lock tries commit operation pointer q changed compareswap fails note even q pointing q i1 version numbers prevent decisive instruction succeeding continues searching two possibilities based new value p rq lost cannot find correct place insert q condition detected priority q examined lines marked iii figure 5 operation restarts head queue p still find correct place insert past q q continue figure 10 concurrent acquire lock succeeds f r r restart figure 11 concurrent release lock r succeeds continues searching scenario illustrated figure 12 interference occurs always takes right action therefore q l acquire lock decisive instruction 2 prove theorem use induction initially points nil q l trivially true suppose theorem true th decisive instruction th decisive instruction acquire lock operation lemma th decisive instruction th decisive instruction release lock operation lemma 1 th decisive instruction therefore inductive step holds hence q l 2 extensions section discuss couple simple extensions increase utility prlock algorithm 41 multiple locks described record prlock used one lock queue otherwise process might obtain lock one desired realtime system several critical sections locks likely process must lock record lock queue wastes space fortunately simple extension prlock algorithm allows lock record used many different lock queues replace dq bit dq string l bits dq string evaluates 0 interpreted ri1 ri1 rm rm restart prq prqi continue prq prqi r r figure 12 release lock r acquire lock succeed binary number record queue lock dq string evaluates 0 record probably queue acquire lock release lock algorithms carry modifying test queue appropriately note process sets nested locks new lock record must used level nesting craig 10 presents method reusing record nested locks 42 backing process obain lock certain deadline might wish stop waiting continue processing process must first remove record lock queue process follows steps 1 find preceding record lock queue using method algorithm acquire lock operation process determines record head lock queue return lock obtained value 2 set dq bit dq string process record dequeued 3 perform compare swap predecessor records next pointer process next pointer compareswap fails go 1 compareswap succeeds return lock released value value processs successor process removes queue without obtaining lock compareswap decisive instruction compareswap fails predecessor might released lock third process enqueued predecessor process cant distinguish possibilities must research lock queue 5 simulation results simulated execution prlock algorithm proteus configurable multiprocessor simulator 4 also implemented mcslock markatos lock demonstrate difference acquisition release time characteristics simulation use multiprocessor model eight processors global shared memory processor local cache memory 2048 bytes size proteus units execution time cycles process executes uniformly randomly distributed time range 1 35 cycles issues acquirelock request acquiring lock process stays critical section fixed number cycles 150 plus another uniformly randomly distributed number 1 400 cycles releasing lock procedure repeated fifty times average number cycles taken acquire lock process computed proteus simulates parallelism repeatedly executing processors program time quanta q simulations 10 priority process set equal processprocessor number lower number higher priority process figures 13 14 show average time taken process acquire lock using mcslock algorithm prlock algorithm respectively process using mcslock algorithm wait fifo queue processes every round however process using prlock algorithm wait time proportional number higher priority processes example highest second highest priority process average waits one critical section period note two highest priority processes acquire lock execution time alternate acquiring lock processes completed execution third fourth highest priority processes obtain lock figure 14 clearly demonstrates average acquisition time lock using prlock proportional process priorities whereas average acquisition time proportional number processes case mcslock algorithm feature makes prlock algorithm attractive use real time systems figure 15 show average time taken process acquire lock using markatos algorithm prioritized lockacquisition behavior shown average time acquire lock 50 greater prlock used first result puzzling markatos lock performs majority work lock released prlock performs work lock acquired however time release lock part time spent critical section time acquire lock depends primarily time spent critical section preceding lock holders thus prlock allows much faster access critical section see prlock also allows predictable access critical section figure shows cache hit ratio instance time processors time cachehit ratio 95 higher processors found average cache hit rage 9972 9987 thus prlock generates little network memory contention spite processes using busywaiting finally compared time required release lock using prlock markatos lock results shown figure 17 markatos lock figure 18 time release lock using prlock small consistent processes releasing lock using markatos lock requires significantly time furthermore experiments high priority process required spend significantly average timecycles x 100 processorpriority figure 13 lock acquisition time mcslock algorithm time releasing lock required low priority process behavior result way simulation run high priority processes executing low priority processes blocked queue result many records must searched high priority process releases lock thus high priority process work behalf low priority processes time required high priority process release lock depends number blocked processes queue result long unpredictable amount time required release lock since lock must released next process acquire lock time required acquire lock also made long unpredictable 6 conclusion paper present priority spinlock synchronization algorithm prlock suitable realtime sharedmemory multiprocessors prlock algorithm characterized prioritized lock ac quisition low release overhead little buscontention welldefined semantics simulation results show prlock algorithm performs well practice priority lock algorithm used presented mutually exclusive access critical section used provide higher level synchronization constructs prioritized semaphores monitors prlock maintains pointer record lock holder prlock used implement priority inheritance protocols finally prlock algorithm adapted use singledequeuer multipleenqueuer parallel priority queue average timecycles x 100 processorpriority 28 3213579 figure 14 lock acquisition time prlock algorithm average timecycles x 100 processorpriority figure 15 lock acquisition time markatos algorithm time x 10000 processor figure cache hit ratio prlock algorithm average timecycles processorpriority figure 17 lock release time prlock algorithm average processorpriority figure 18 lock release time markatos algorithm several prioritized spin locks proposed prlock following advantages ffl algorithm contention free ffl higher priority process work lower priority process releasing lock result time required acquire release lock fast predictable ffl prlock welldefined acquirelock point ffl prlock maintains pointer process using lock facilitates implementing priority inheritance protocols future work interested prioritizing access operating system structures make appropriate use realtime parallel operating system r performance spin lock alternatives shared memory multiprocessors concurrent programming principles practice mutual exclusion linear waiting using binary shared variables distributed snapshots determining global states distributed systems dynamic priority ceiling concurrency control protocol realtime systems priority ceiling protocol multipleinstance resources scheduling algorithms multiprogramming hard realtime environ ment queuing spin lock alternatives support timing predictability characterizing memory hotspots shared memory mimd machine two algorithms mutual exclusion realtime distributed computer systems methodology implementing highly concurrent data objects correctness condition concurrent objects performance analysis minimum laxity earliest deadline realtime system efficient synchronization multiprocessors shared memory multiprocessor synchronization primitives priorities algorithms scalable synchronization sharedmemory multiprocessors predictable synchronization mechanisms realtime systems priority inheritance protocols approach realtime synchronization concurrent search structure algorithms tutorial hard realtime systems locking without blocking making lock based concurrent data structure algorithms nonblocking tr ctr prasad jayanti farrays implementation applications proceedings twentyfirst annual symposium principles distributed computing july 2124 2002 monterey california james h anderson yongjik kim ted herman sharedmemory mutual exclusion major research trends since 1986 distributed computing v16 n23 p75110 september
taking walk planar arrangement present randomized algorithm computing portions arrangement n arcs plane pair intersect points use algorithm perform online walks inside arrangement ie compute faces curve given online manner crosses compute level arrangement outputsensitive manner expected running time algorithm olambdat2mnlog n number intersections walk given arcs similarly efficient algorithm known general case arcs case lines certain restricted cases involving line segments algorithm improves best known algorithm h overmars j van leeuwen j comput system sci 23 1981 pp 166204 almost logarithmic factor b introduction set n xmonotone arcs plane computing whole parts arrangement induced arcs one fundamental problems computational geometry received lot attention recent years sa95 one basic techniques used problems based randomized incremental construction vertical decomposition arrangement see by98 example interested computing parts arrangement eg single face zone randomized incremental technique still used requires nontrivial modifications intuitively added complexity caused need trim parts plane algorithm advances waste energy regions longer relevant fact requirement implies algorithm know advance regions interested stage randomized incremental construction variation theme existing algorithms cannot cope efficiently following online scenario start point find face f contains p0 point p starts moving traces connected curve fptg t0 walk continues wish keep track face contains current point work supported grant usisraeli binational science foundation work part authors phd thesis prepared telaviv university supervision prof micha sharir school mathematical sciences tel aviv university tel aviv 69978 israel sarielmathtauacil httpwwwmathtauacil sariel pt collection faces constitutes zone curve pt however function pt assumed known advance may change cross new face abruptly change direction middle face see bdh97 application scenario arises work aware deal problem efficiently due overmars van leeuwen ovl81 applies case lines simple modifications case segments well compute walk deterministic log 2 n time inside arrangement n lines number intersections walk lines done maintaining dynamically intersection halfplanes corresponds current face algorithm ovl81 somewhat complicated probably practical actual implementation paper propose new randomized algorithm computes zone walk general arrangement arcs t2 nm log n expected time t2 nm maximum length davenportschinzel sequence order sa95 new algorithm interpreted third online alternative algorithms ceg dbds95 algorithm rather simple appears practical matter fact currently implementing experimenting variant algorithm application new algorithm present new algorithm computing level arrangement arcs computes single level t2 n log n expected time complexity level results improve almost logarithmic factor best previous result ovl81 case lines case general arcs aware similarly efficient previous result paper organized follows section 2 describe algorithm section 3 analyze performance section 4 mention applications algorithm including computing single level concluding remarks given section 5 2 algorithm section present algorithm performing online walk inside planar arrangement randomized incremental construction zone using oracle given set n xmonotone arcs plane pair arcs intersect times fixed constant denote arrangement namely partition plane faces edges vertices induced arcs see sa95 details assume general position meaning three arcs common point xcoordinates intersections endpoints arcs pairwise distinct vertical decomposition denoted vd partition plane vertical pseudotrapezoids obtained erecting two vertical segments vertex ie points intersections pairs arcs endpoints arcs extending either reaches arc otherwise way infinity see by98 details concerning vertical decomposition simplify though slightly abuse notation refer cells vd trapezoids selection r ordered sequence distinct elements slight abuse notation also denote r unordered set elements let oe denote set selections permutation let denote subsequence consisting first elements computing decomposed arrangement vd done follows pick random permutation compute incrementally decomposed arrangements vd inserting ith arc vd compute district vd igamma1 set trapezoids vd igamma1 intersect split trapezoid o1 trapezoids trapezoid intersects interior sa95 finally perform pass newly created trapezoids merging vertical trapezoids adjacent identical top bottom arcs merging step guarantees resulting decomposition vd independently insertion order elements let fl curve walk selection r 2 let z fl r denote zone fl ar set faces ar nonempty intersection fl let flvd denote union trapezoids cover z goal compute assume moment supplied oracle os delta decide constant time whether given vertical trapezoid delta flvd equipped oracle computing flvd fairly easy using variant randomized incremental construction outlined algorithm depicted figure 1 present algorithm conceptual level algorithm shall actually use given help us describe analyze actual online algorithm shall describe later note set trapezoids maintained algorithm ith iteration superset flvd might trapezoids c longer z however implies trpaezoids eliminated first time arc belonging conflict list handled moreover algorithm compzonewithoracle augmented compute history dag sa95 whose nodes trapezoids created algorithm trapezoid destroyed execution algorithm points trapezoids created let ht fl denote structure ith iteration algorithm definitions trapezoid created split operation compzonewithoracle called transient trapezoid later merged iteration form larger trapezoid trapezoid generated compzonewithoracle final transient rank rankdelta trapezoid delta maximum indices j arcs containing bottom top edges delta permutation denote ddelta defining set final trapezoid delta minimal set delta 2 vd easy verify jddeltaj 4 also define ddelta transient trapezoid delta minimal set delta trnasient incramental construction vd easy verify jddelta 6 index indexdelta trapezoid delta minimum ddelta trapezoid delta denote cldelta conflict list delta set arcs intersect delta interior let nextdelta denote first element cldelta according ordering trapezoid delta generated compzonewithoracle merged larger trapezoid denote fatherdelta trapezoid delta generated vertical side algorithm compzonewithoracle input set n arcs curve fl oracle output flvd begin choose random permutation 1 n delta 2 int splitdelta operation splitting vertical trapezoid delta crossed arc constant number vertical trapezoids dbvkos97 new trapezoids cover delta intersect interior end merge adjacent trapezoids temp top bottom arcs let temp 1 resulting set trapezoids let temp 2 set trapezoids temp 1 flvd compute set using jt emp 1 j calls end return c n compzonewithoracle figure 1 randomized incramental algorithm constructing zone walk arrage ment arcs using oracle vertical trapezoid delta called splitter splitter transient incident intersection point endpoint induced vertical edge contains means two trapezoids adjacent transient merged larger final trapezoid figure 2 illustration definitions easy verify trapezoid delta transient least one bounding splitters transient thus one decide whether trapezoid transient inspecting splitters constant time online algorithm constructing zone let us assume random permutation fixed advance note predetermines ht key observation online algorithm order construct specific leaf ht fl maintain entire dag suffices compute parts dag lie paths connecting leaf root ht fl might several paths since structure dag tree facilitate computation maintain partial history dag nodes two types final nodes nodes whose corresponding trapezoids appear ht fl l 1 l 2 l 3 l 4 l 5 figure 2 illustration defintions transient splitter thus 0 transient rank ii transient nodes leaves whose corresponding trapezoids transient namely internal nodes copies identical nodes ht fl whose corresponding trapezoids final leaves might transient intuitively stores portion ht fl computed explicitly far transient leaves delimit poritions ht fl expanded yet inside node also maintain conflict list corresponding trapezoid suppose wish compute leaf ht fl contains given point p first locate leaf contains p done traversing path starting root going downward step child current trapezoid contains p requires o1 time outdegree node ht fl bounded constant depends end either reach final leaf required leaf ht fl encounter transient leaf v latter case need expand v first step replace v coresponding node v ht fl obtained merging transient trapezoid v adjacent transient trapezoids form final trapezoid associated v assume moment supplied method described shortly generate transient trapezoids whose union forms final trapezoid stored v ht fl following merge transient trapezoids new final trapezoid delta ii compute conflict list cldelta conflict lists transient trapezoids 1 iii compute first element delta cldelta according permutation iv compute transient trapezoids final generated delta splitting delta generates o1 new trapezoids overall requires ok number transient trapezoids merged l total length conflict lists transient trapezoids thus upgraded transient node v final node v denote operation expandv continue going passing child delta contains p repeating recursively procedure child reaching desired leaf ht fl contains p let newly created trapezoid transient one splitters must transient let denote transient splitter let us assume right edge implies either top arc bottom arc cause splitting generated particular next f either top bottom arc f denotes trapezoid generated perform merging conflict lists linear time one may use either hashtable bitvector one maintains conflict lists consistent ordering see by98 compute transient trapezoid 0 lies right taking te midpoint p performing pointlocation query p pointlocation process always go trapezoid delta contains p interior left edge stop soon encounter transient trapezoid 0 left edge identical right edge happens 0 top bottom edges namely stop intuitively trapezoid 0 rank smaller rank left edge longer right edge first time 0 indentical connecting edge top bottom edges identical namely rank continue process collecting adjacent transient trapezoids using pointlocation queries midpoints transient splitters two extreme splitters left right nontransient take union trapezoids new expanded trapezoid see figure 2 course pointlocation process might forced going parts ht fl appear yet case compute parts online manner performing expand calls relevant transient trapezoids might encounter going thus process turning transient trapezoid final trapezoid recursive process might quite substantial let g denote adjacency graph vd graph vertex trapezoid vd edge connects two vertices corresponding trapezoids share common vertical side moreover general position assumptions vertex g degree 4 easy verify connected component g corresponds face performing pointlocation query described point p compute node v g whose trapezoid delta v contains p furthermore carrying pointlocation query similar used expand operation compute node u g indeed pointlocation query traverse reach leaf u ht fl ie conflict list corresponding trapezoid empty node u node g adjacent v ie uv edge g repeating process perform dfs g corresponds entire face contains p let fl curve online walk whose zone wish compute consider fl directed curve supplied us user function escapepoint fl function escapepoint fl p delta receives input point p 2 fl trapezoid delta contains p outputs next intersection point fl delta following p reach end fl function returns nil assume although crucial algorithm fl intersect thus given walk fl compute zone algorithm depicted figure 3 note time algorithm terminates final parts contained ht fl proper inclusion might arise see remark 36 analyzing performance algorithm first bound overall expected time required compute ht fl done bounding expected running time compzonewithoracle appropriate model computaiton next bound additional time spent algorithm traversing adjacent trapezoids ie time spent performing pointlocation queries remark 21 skipping expansion face contains current point p compzoneonline get efficient algorithm computes walk might cases sufficient algorithm compzoneonline input set n arcs starting point p walk function escapepoint fl represents walk output decomposed zone fl begin choose random permutation partial history dag root corresponding whole plane leafht leaf ht fl whose associate trapezoid contains p paths ht fl v root exist compute face f containing delta v flvd add output zone z compute v next leaf ht fl done performing pointlocation query described text enlarging accordingly compute face f delta v flvd computed already add output zone z return z compzoneonline figure 3 algorithm constructing zone walk arragement arcs online manner 21 correctness section try prove correctness compzoneonline observation 22 execution compzoneonline union trapezoids leaves form pairwise disjoint covering plane vertical trapezoids corollary 23 conflict list computed trapezoid delta procedure compzoneonline list arcs cross delta proof induction steps compzoneonline observe regions delta generated cover delta thus union conflict lists must contain conflict list delta corollary 24 trapezoid delta created compzoneonline curves ddelta appears curves k delta lemma 25 pointlocation query middle transient splitters never fails namely query always generate transient trapezoid whcih adjacent current transient trapezoid save top bottom arcs proof let current transient trapezoid let transient splitter let p point located middle assume without loss generality right edge pointlocation query must end trapezoid delta currently node contains left edge point algorithm refines delta going performing sequence splitting expansion operations sequence trapezoids created visited p left side computed hunt transient trapezoid adjacent first note process perform insertion arc endpoint interior since either contradict general position assumption imply transient splitter let delta trapezoid ranks maximl clearly left edge delta must contain otherwise arc l igamma1 intersects interior implies computation conflict list incorrect contradicting coroallary 23 thus must top bottom arcs implying left side delta conclude pointlocation process compute delta definition 26 permutation let hist hists denote historydag generated computing whole vertical decomposition vd incremental construction inserts curves order lemma 27 final trapezoid delta created expand procedure execution compzoneonline exists 0 delta trapezoid vd matter fact proof induction depth nodes depth node defined length longest path root node indeed base induction node depth 0 must root computed initialization algorithm thus trapezoid vd 0 let delta final trapezoid depth k generated directly trapezoid procedure expand let final trapezoid split generate induction hypthesis f trapezoid vd l corollary 23 conflict list f computed correctly final trapezoid vd namley nextfather otherwise transient expansion computed several transient trapezoids using pointlocation queries note pointlocation queries performed placing points transient splitters namely soon encounter nontransient splitter aborted expansion direction thus must two arcs floor ceiling otherwise either algorithm performed pointlocation middle nontrnasient splitter computation conflict lists incorrect let clearly delta trapezoid two splitters nontransient claim two splitters delta induced intersections index generated father splitting caused father conflict list computed correctly induction hypothesis moreover left splitter delta either empty ie delta left vertical side intersection point final final adjacent intersection point induces defined three arcs must appear sm similarly right splitter delta final defined three arcs appear sm thus delta trapezoid intersect arc sm interior top bottom arcs belong sm two splitters final defined arcs sm implies delta vd sm lemma 28 final nodes computed compzoneonline appear ht fl proof let delta final trapezoid computed compzoneonline trapezoid delta generated sequence recursive calls expand let set final trapezoids created direcly recursive calls ordered according recursive call ordering let l trapezoid delta 1 created performed pointlocation query point p appear zs since zs i1 moreover delta i1 computed computation delta must point p lie inside vertical trapezoids computation delta i1 initiated pointlocation query must also lie inside delta i1 implies p 2 zs l thus follows delta i1 appears ht fl l i1 induction follows delta k 2 ht fl 3 analysis 31 constructing history dag following analyze performance compzonewithoracle assume maintains trapezoid conflictlists stores set arcs cross thus cost operation trapezoid proportional size conflict list also assume call oracle takes o1 time lemma 31 algorithm compzonewithoracle computes zone fl vd t2 n log n expected time expected number trapezoids generates t2 n proof proof straightforward adaptation proof ceg omit easy details observation 32 trapezoids computed compzoneonline either final trapezoids computed compzonewithoracle thus appear ht fl transient trapezoids split trapezoids ht fl lemma 33 expected number transient trapezoids generated compzoneonline t2 n expected total size conflict lists t2 n log n proof final trapezoid generated compzoneonline might split o1 transient trapezoids final trapezoid computed compzoneonline also computed compzonewithoracle lemma 31 expected number trapezoids t2 nm second part lemma follows similar argument definition 34 curve fl locally xmonotone decomposed inside face constant number xmonotone curves theorem 35 algorithm compzoneonline computes zone fl t2 n log n expected time provided fl locally xmonotone curve proof time spent compzoneonline bounded time required construct history dag time spent maintaining conflict lists trapezoids time spent performing pointlocation queries move one trapezoid another flvd lemmas 31 33 expected time spent maintaining conflict lists trapezoids computed algorithm t2 n log n since total time spent handling conflict lists proportional total length lemma 33 expected total size conflict lists t2 n log n moreover depth history dag constructed algorithm olog n probability polynomially close 1 mul94 thus expected time spent directly performing single pointlocation query ignoring time spent maintaining conflict lists move one trapezoid next olog n curve fl locally xmonotone implies intersects splitters trapezoid flvd o1 times thus expected number pointlocation queries performed algorithm proportional expected number transient trapezoids created plus om lemma 33 expected running time remark 36 note compzonewithoracle computes zone fl vd fact might compute trapezoid delta 2 flvd intersect zone fl flvd particular trapezoid delta computed compzoneonline slackness analysis currently know whether exploited improve analysis algorithm suspect cannot remark 37 result type aware classical result due overmars van leeuwen ovl81 maintains dynamically convex hull n points plane olog 2 n time insertion deletion operation dual variant results maintaining intersection halfplanes used perform walks inside line arrangements deterministic log 2 n time number intersections walk lines algorithm ovl81 requires somewhat involved rebalancing tree represents current intersection halfplanes algorithm somewhat simpler faster applies general arrangements segments general arcs aware result type literature course curve fl known advance simple sense one compute quickly intersections arc compute single face modified arrangement proof general planar zone theorem sa95 theorem xx using algorithms dbds95 ceg 93 algorithms slightly simpler algorithm theorem 35 although expected performance however algorithms useless online walks applications section present several applications algorithm compzoneonline 41 computing level arrangement arcs subsection show modify algorithm previous section compute level arrangement xmonotone arcs definition 41 let set n xmonotone arcs plane pair intersect times fixed constant assume general position level point plane number arcs lying strictly consider closure l set points arcs level l 0 l n e l xmonotone necessarily connected curve polygonal case lines segments called level l arrangement xcoordinates vertical line intersects less l lines consider e l undefined levels fundamental structure computational combinatorial geometry subject intensive research recent years see aacs98 dey98 tt97 tt98 tight bounds complexity single level even arrangements lines proved surprisingly hard obtain currently best known upper bound case lines onl1 13 dey98 lower bound omegagamma n log l bounds classes arcs first note set lines know leftmost ray belongs e l level l locally defined move left right along e l time encounter intersection point vertex change line traverse also depicted figure 4 particular compute level e l 3 n using compzoneonline procedure used compute level arrangement general arcs nonlocal behavior watch jump discontinuities level caused endpoint arc appears current level figure 4 first level arrangement segments vertical edges show jump discontinuities level part level current level reaches endpoint arc see figure 4 see details concerning handling jumps following let l 0 l n prescribed parameter let e l denote level l arrangement following adaption compzoneonline setting rather straightforward include sake completeness sort endpoints arcs x coordinates time walk reaches xcoordinate next endpoint updated e l jumping next arc needed additional work requires log n time walk maintain invariant top edge current trapezoid part l compute first trapezoid walk compute intersection level l yaxis done sorting arcs according intersections yaxis let 0 starting point perform pointlocation query p 0 virtual history dag compute starting trapezoid delta 0 walking right delta 0 compute part e l lying right yaxis indeed let delta current trapezoid maintained algorithm top edge part e l let pdelta denote top right vertex delta performing pointlocation queries partial history dag compute trapezoids vd contain pdelta general position assumption number trapezoids 6 number materializes pdelta lies intersection two xmonotone arcs inspecting set trapezoids one decide e l continues right delta determine next trapezoid e l roof algorithm sets delta trapezoid algorithm reaches xcoordinate endpoint arc update e l jumping right endpoint arc lies level left endpoint lies level namely set delta trapezoid lying current delta algorithm continues manner reaching last edge e l algorithm performs symmetric walk left yaxis compute portion level let complevel denote modified algorithm summarize result theorem 42 algorithm complevel computes level l t2 n expected time remark 43 since complevel online use compute first 0 points e l expected t2 n 0 log n time remark 44 straightforward extension complevel allows us compute connected path within union ie restrict walk arcs online manner randomized expected time t2 n log n number vertices path extended version also handle jumps adjacent arcs walk 42 applications subsection provide additional applications compzoneonline theorem 45 let l set n lines plane let prescribed constant one compute 1rcutting al 1 8r randomized expected time log n ffn inverse ackermann function sa95 proof follows plugging algorithm theorem 42 remark 43 algorithm described hp98 discussion cuttings small asymptotic size applications see mat98 hp98 remark 46 theorem 45 improves previous result hp98 almost logarithmic factor remark 47 computed level l arrangement general arcs clip arcs portions level supplied clipped arcs compute arrangement level l omn log n r time complexity level l r complexity first l levels thus compute first l levels t2 mn log nr expected time using randomized incremental construction mul94 improves previous result ervk96 computes portion arrangement log n note running time output sensitive byproduct technique compzoneonline ability perform pointlocation queries using partial history dag mechanism definition 48 point set p set arcs denote connected polygonal set ii number intersections arcs minimum let wm denote number intersections set interpreted minimum spanning steiner tree p metric intersections arcs lemma 49 given set n arcs plane one answer pointlocation queries set p points online manner overall expected time answer queries t2 n log n time proof precompute random permutation let partial history dag answer pointlocation queries computing relevant parts history dag vd compzoneonline time algorithm terminates contained flvd however expected total weight trapezoids zs t2 n logn lemma 31 bounds overall expected query time remark 410 result lemma 49 somewhat disappointing since wm aga91 case lines faces computed roughly 23 23 ams98 ie j aware algorithm better running time algorithm lemma 49 case lines query points given online fashion currently case general arcs better bound known complexity faces arrangement n arcs see egp algorithm lemma 49 simple favorable additional property adaptive namely wm smaller ie query point close together overall query time improves furthermore alot queries close together first query slow later ones fast since later queries use parts paths already exists partial history dag conclusions paper presented new randomized algorithm computing zone planar arrangement online fashion algorithm first efficient algorithm case planar arcs performs faster nearly logarithmic factor algorithm ovl81 case lines segments considerably simpler also presented efficient randomized algorithm computing level arrangement arcs plane whose expected running time faster previous algorithm problem main result paper relies application pointlocation queries compute relevant parts offline structure ie history dag author believes technique additional applications particular approach might useful also algorithms higher dimensions leave open question research acknowledgments author wishes thank pankaj agarwal danny halperin micha sharir helpful discussions concerning problems studied paper related problems r levels arrangements lines intersection decomposition algorithms planar arrangements area bisectors polygon force equilibria programmable vector fields algorithmic geometry computing face arrangement line segments lazy randomized incremental construction computational geometry algorithms applications improved bounds planar ksets related problems algorithms combinatorial geometry arrangements curves plane topology optimal algorithm constructing cuttings theory practice complexity many cells overlay many arrangements computational geometry introduction randomized algorithms maintenance configurations plane characterization planar graphs pseudoline arrangements cut pseudoparabolas segments tr ctr nisheeth shrivastava subhash suri csaba tth detecting cuts sensor networks proceedings 4th international symposium information processing sensor networks april 2427 2005 los angeles california naoki katoh takeshi tokuyama notes computing peaks klevels parametric spanning trees proceedings seventeenth annual symposium computational geometry p241248 june 2001 medford massachusetts united states
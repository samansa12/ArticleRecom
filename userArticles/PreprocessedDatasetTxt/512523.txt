objects classes algollike languages many objectoriented languages used practice descend algol motivation study theoretical issues underlying languages via theory algollike languages shown basic framework theory extends cleanly elegantly concepts objects classes moreover clear correspondence emerges classes abstract data types whose theory corresponds existential types equational hoarelike reasoning methods relational parametricity provide powerful formal tools reasoning algollike objectoriented programs 2002 elsevier science usa b introduction objectoriented programming first developed context algollike languages form simula 67 17 majority objectoriented languages used practice claim either direct indirect descent algol thus seems entirely appropriate study concepts objectoriented programming context algollike languages paper effort formalize objects classes used algollike languages develop theoretical underpinnings formal framework adopt technical notion algollike languages defined reynolds 51 idealized algol reynolds typed lambda calculus base types support statemanipulation expressions commands etc typed lambda calculus framework gives mathematical flavor idealized algol sets within broader programming language research yet base types statemanipulation make remarkably close practical programming languages combination gives us ideal setting studying various programming language phenomena relevance practical languages like c modula3 java etc reynolds also argued 50 appendix objectoriented programming concepts implicit idealized algol essential idea classes correspond new operators generate instances every time invoked obviates need separate class concept idea echoed others 46 2 contrast take position significant benefit directly representing objectoriented concepts formal system instead encoding constructs effect classes obtained corresponding new operators properties classes exhibited new operators thus classes form specialized form new operators independent interest paper define language called ia extension idealized algol objectoriented programming study semantics formal properties important idea comes light classes abstract data types whose theory corresponds existential types 35 sense ia idealized algol sol polymorphic lambda calculus however sol faithfully encoded polymorphic lambda calculus 45 ia constrained idealized algol corresponding encoding preserve equivalences thus ia proper extension related work number papers 19 1 11 18 discuss objectoriented type systems languages side effects clear contribution type systems make reasoning principles programs related direction object encodings pierce turner 44 study encoding objects abstract types bears similarity parametricity semantics paper recent work along line 12 fisher mitchell 20 also relate classes data abstraction work assumes functional setting objects ideas deal state work specification stateful objects includes 5 28 29 30 addressing subtyping issues 3 6 addressing selfreference issues major developments research algollike languages collected 43 tennent 58 gives gentle introduction concepts 1994 2 language ia language ia extension idealized algol classes thus typed lambda calculus base types corresponding imperative programming phrases base types include ffl comm type commands statetransformers ffl expffi type statedependent expressions giving ffityped values ffl valffi type phrases directly denote ffityped values without statedependence ranges collection data types integer boolean whose values storable vari ables types like expffi comm called phrase types distinguish data types values arbitrary phrase types storable variables 1 collection phrase types types short given following syntax fi ranges base types expffi comm valffi except cls types remaining type structure simply typed lambda calculus record types sub typing see instance mitchell 34 ch 10 details basic subtypings include collection types called statedependent types ffl standard record subtyping width well depth subtyping interpretation subtyping coercions 34 sec 1042 parameter passing mechanism ia callbyname usual typed lambda calculus second coercion makes available algols notion callbyvalue expression argument supplied value needed type cls type classes describe behavior typed objects object abstraction encapsulates internal state represented fields provides externally visible operations called methods class defines fields methods collection objects called instances distinction classes instances arises objects stateful class stateless observable difference instances would little point making classinstance distinction classes represent abstract mathematical concept behavior instances represent concrete physical realizations behavior defining classes use notation form class fields c1 methods init various components description follows ffl type type instances class called signature class identifiers fields terms denoting classes respective fields ffl term type defining methods class 1 possible postulate data type references pointers ref every phrase type whose values storable variables obtains essential expressiveness objectoriented programmer desires unfortunately theoretical understanding references welldeveloped omit main presentation mention issues relating sec 43 ffl commtyped term initializing fields admittedly complex term form represents quite closely term forms classes typical programming languages moreover see much detail clear typetheoretic basis noteworthy cannot define nontrivial classes without first primitive classes needed defining fields assume single primitive class mu table variables via constant x instance varffi variable xget statedependent expression gives value stored x xputk command stores value k x 2 often use abbreviation signature type variables assume subtyp ings whose coercion interpretations corresponding field selections note type varffi different class varffi values type varffi need general instances varffi instance following trivial class instances type varint class fields methods init skip instances class always give 0 get message nothing response put message yet type varint essence type object merely gives signature types methods whereas class defines behavior tighter integration classes types would certainly desirable return issue sec 41 example nontrivial class consider following class counter objects class finc comm val expintg fields cnt methods init counter state variable keeping count inc method increments count val method returns count definition inc method could also written cnt cnt using subtypings varffi use explicit coercions clarity assume new variables come initialized specific initial value init ffi also possible use modified primitive cls varffi allows explicit initialization via parameter one would want variety combinators classes following product combinator making pairs objects essential primitive cls 1 theta cls 2 cls 1 theta 2 instance class c1 c2 pair consisting instance c1 instance c2 useful combinators abound instance following combinator motivated work fudgets 14 instance f1 f2 pair b instance f1 b b instance f1 two objects thus interlinked creation time using mutual recursion common data structures programming languages arrays records also give rise class combinators array data structure regarded combinator type array array c n equivalent nfold product c c viewed partial function integers cobjects record construction record c1 essentially like c1 delta delta delta cn except instances records instead tuples creating instances classes use notation new c value type signature class c example new counter b creates instance counter binds executes command b scope extends far right possible often delimited parentheses beginend brackets type newc illustrates physical nature objects reconciled mathematical character algol new c regarded value type mathematical nature algol would prohibit stateful objects entirely example construction form let new counter ainc print aval would useless would equivalent fireduction new counterinc print new counterval thereby implying every use gives new counter state propagated higher order type newc gives rise problems insight due reynolds 51 used several languages 37 56 21 formal system assume standard treatment typed lambda calculus aspects ia type rules cls types shown fig 1 note one rule introduction cls types one elimination show single field class term simplicity obviously fields c x methods init cls intro cls elim figure 1 type rules cls types cls 1 theta cls 2 cls 1 theta 2 figure 2 essential constants ia limitation combinator classes used instantiate multiple classes significant initialization command restricted acting field x allow alter arbitrary nonlocal objects methods term hand act nonlocal objects useful instance obtain effect static fields languages like c java class term free identifiers call constant class restriction initialization command free identifiers x motivated reasoning considerations programmers typically want assume order instance declarations insignificant initializations global effects order would become significant however restriction stated rule stringent one would want initialization command able least read global variables appendix outline general type system based ideas 50 48 allows readonly free identifiers important constants ia shown fig 2 constants expression value types omitted constant skip denotes donothing command denotes sequential composition letval operator sequences evaluation expression another expression command precisely letvalef evaluates e current state obtain value x evaluates f x note would make sense letval e f type valffi 0 infix operator variant letval defined example command cntput cntget 1 definition counter class involves sequencing letval operator extended higher types follows letval fst letval thus statedependent types defined appendix letval operators coercion serves interpret subtyping valffi equational calculus typed lambda calculus part ia standard cls type constructs following laws new class fields c x methods init new c x j class fields c x methods x init skip fl new c1 x new c2 new c2 new c1 x fi law specifies effect introelim combination j law specifies effect elimintro combination elim implicit elimination field declara tions fl law allows one reorder new declarations note important initializations free global effects fl law hold interaction new declarations various constants axiomatized following equational axioms new c x new c x new c g 2 new c x gx ae new c x letval e z h x z oe ae letval e z new c x h x z oe new c x p f x g presence nontermination first equation must weakened inequality new c x skip v skip equations state new operator commutes operations ia computation independent new instance moved scope notice derive second equation setting famous equation new c x 6 discussed various papers semantics local variables 31 32 40 compilers implicitly use kinds equations enlarge contract scope local variables eliminate dead variables formally introducing classes feature able generalize classes 50 appendix reynolds suggests encoding classes corresponding new operators involves cls class fields c x methods init new c x pm new 3 note axioms equations lambda calculus equational schemas symbols c never substituted terms capture bound identifiers instance equation 2 cannot substituted term x occurring free instance class counter would encoded tunately arbitrary functions type satisfy axioms new listed means reynoldss encoding give fully abstract translation ia idealized algol treatment seen formalization properties intrinsic new operators classes 22 specifications ideal framework specifying classes ia specification logic reynolds 52 specification logic theory within typed firstorder intuitionistic logic hence name somewhat misnomer use intuitionistic connectives 8 9 types include idealized algol additional base type assert assertions statedependent classical logic formulas atomic formulas specification logic include ffl hoare triples fpg fqg command assertions p q ffl noninterference formulas b b terms arbitrary types note assertions form logic within logic one use classical reasoning even though outer logic intuitionistic noninterference formula b means intuitively b access common storage locations except readonly fashion definition property uses possibleworld semantics 41 use symmetric noninterference predicate 38 somewhat easier use original reynoldss version proof rules noninterference predicate free identifiers b respectively 2 b b passive types 3 b either b constant type passive types give expffityped values constant types give valffityped values see appendix discussion effect noninterference predicate best illustrated proof rule states two noninterfering commands freely reordered survey article tennent 58 detailed description specification logic handling ia extend specification logic cls types new formula form inst c x oex c class x identifier bound formula oex formula meaning instances x class c satisfy formula oex example following specification variable class inst varffi x inst queue q 8xy valint 8g expint comm g q figure 3 equational specification queue class inst queue q 9elems list valint assert 8k valint 8s list valint ftrueg qinit felems g figure 4 hoaretriple specification queues thus hoare logic axiom assignment becomes axiom variable class one also write equational specifications classes example consider specification counters inst counter x quantified function identifier g plays role con version function convert expressions commands less trivial example equational specification queue class shown fig 3 structure similar counter specification specification logic allows use equational reasoning reasoning via hoaretriples choice matter preference hoarelike reasoning better understood often simpler illustration show fig 4 hoaretriple specification queue specification asserts existence elems predicate representing abstraction internal state queue list using mllike notation lists note logical facilities specification logic allow us specify exitence abstraction function would implementationdependent example fig 5 shows implementation queue class using unbounded arrays 4 show meets hoaretriple specification pick predicate queuestate represents queue elements list array elements f 1 r note predicate incorporates representation invariant representation function americas terminology 5 fact americas theory class specifications implicit specification logic 4 using unbounded arrays abstraction finesse technicalities bounds clearly specification implementation queue modified deal bounded queues class queue fields unboundedarray varint methods init f 0 r figure 5 implementation queues specification logic also able express history proper ties recommended liskov wing 30 example formula states counters value increase time inst counter x using instspecifications formulate following proof rule new declarations inst c x oex new c g x occur free undischarged assump tions terms formula gamma states prove property newc g need prove g x x arbitrary instance c assuming specification oex fact x interference anything unless c interferes terms terms whatever typical usage rule free identifiers gx noninterference assumptions arise fact x new instance rule inferring instspecifications inst c z z oem inst class fields c z init methods x oex z occur free undischarged assump tions terms formula oegamma instspecifications always adequate capturing entire behavior class instances since specify behavior instances arbitrary states miss specification initial state final state transforma tions additional axioms involving newterms necessary capture aspects example counter class satisfies following initialization axiom new counter x gxval hx new counter x g0 hx specifies initial value counter 0 finalization axiom new counter x gx hxinc new counter x gx hskip states increment operations done deallocation redundant denotational semantics ia brings important properties classes objects consider two styles semantics parametricity semantics along lines 42 highlights data abstraction aspects classes objectbased semantics along lines 49 highlights classinstance relationship 31 parametricity semantics pointed reynolds 53 parametricity fundamentally data abstraction since classes incorporate data abstraction one expects parametricity play role interpretation follow presentation 42 sec 2 discussion particular ignore recursion curried functions later discussion 42 handling features immediately applicable type operator small collection sets ffl set part set assigns set x 2 set set x ffl relation part rel assigns binary relation normally write set rel simply using context disambiguate notation similarly nary type operators n type variables defined type operators constant types variable types product function space constructors standard example function space constructor relation part relation part constant type k identity relation denoted delta k define quantified type operators universal quantifier 8 existential quantifier 9 ffl type operator 8z x z represents parametrically polymorphic functions p components pz 2 formally set part consists sindexed families fpzgz2s relations z relation part written 8s r r x defined z gz2s ffl operator 9z x z represents data abstractions implement abstract type z operations type x z define formally consider imple mentation pairs form hz pi z 2 two implementations said similar hz pi hz exists relation relation termed simulation set part 9z x z consists equivalence classes implementations equivalence relation write equivalence class hz pi hjz pji relation part 9s r relation r x least relation basic reference parametricity reynolds 53 plotkin abadi 45 define logic reasoning parametricity notion existential quantification 35 parametricity semantics mentioned idea simulation relations abstract type implementations dates back milner 33 appears various sources including 9 27 25 36 54 types ia interpreted type operators sense parameters type operators state sets typically capture states involved representation objects relation parts operators specify two values type related change representation interpretation note meaning class data abstraction involves state set z internal state instances component type q theta z methods class component type z initial state two implementations internal state sets z z 0 similar hence equivalent relation z z 0 initial states related methods preserve according relation example consider following class alternative counter st methods meanings counter counter2 calculated follows two implementations similar simulation relation int int given gamman preserved two implementations hence two abstractions equivalence classes equal thus parametricity semantics gives extremely useful proof principle reasoning equivalence classes interpretation terms follows term function write component q semantics algol phrases 42 important point recall paper sec 32 fact parametricity makes available certain expand functions expand every value v 2 q unique expanded value qthetaz acts way v use abbreviated notation v qthetaz q denote expand q zv example expanded command leaves z component unchanged expand functions play crucial role interpreting instance declarations inheritance also significance interpreting con stants constant value q value form qobtained expanding value unit state set need specify interpretation constant unit state set semantics class constructs follows fields c x methods init q fst pz mq z hjz class definition builds abstract type illustrated counter new operator opens abstract type passes client procedure p representation method suite class thus instance created note normal case p abstraction x meaning lambdaz body term use expanded state set q theta z every time class c instantiated new z component added state set fashion thus every opening abstract type gives rise new instance state component interfere others comparing operation object encoding proposed pierce turner others 44 12 note treat objects abstract types whereas treat classes abstract types thus bureaucratic opening closing code appears model finessed message send model simply field selection record nevertheless idea abstract types appears models implications commonality explored class constants following interpretation init hjz1 theta z2 0 varffi class denotes state set ffi get put operations operator combines two classes joining state sets method suites individual classes expanded operate combined state set theorem 1 parametricity model satisfies equivalences axioms sec 21 plain parametricity semantics described handle equality relation general fashion implementing data abstractions normal allow abstract value represented multiple concrete representations context means equality relation abstract states general equality relation concrete states corresponds partial equivalence relation per concrete states 24 example queue implementation fig 5 empty queue represented state f r equal second axiom equational specification fig hold implementation left hand side gives state right hand side gives state remedied modifying parametricity semantics parametric per semantics type carries notion equality 5 formally type new setting called pertype pair x set ex per x representing notion equality x ideas modified work pertypes see appendix b per semantics influences reasoning programs follows suppose obtain package hhz delta z 9z x z meaning class p preserves per ez sense p thus liberty make per ez preserved p use equality relation representation example queue class fig 5 state set z consists triples ha f ri int int f r 2 int pick equivalence relation ez given ha f ri ez ha map f represent intuition portion array f 1 r contains meaningful values verifying axioms queues interpret comm per 5 seem possible obtain information semantics plain parametricity semantics quantified type operators map pers pers general inc val1 val2 inc inc figure trace set counter object theta z viz eq theta ez eq theta ez eq per q respected variables like g verification problematic second axiom two sides equation denote respective state transformations clear equivalent relation eq theta 32 objectbased semantics objectbased semantics 49 39 see also 4 treats objects state machines describes purely observable behavior observable behavior given terms event traces whose structure determined type object similar processes described semantics csp ccs since internal states appear denotations proving equivalence two classes reduces proving equality trace sets looking formal definitions consider example figure 6 depicts trace set counter object initial state events object inc denoting successful completion inc method vali denoting completion val method result integer nodes thought states events state transitions note val event change state whereas inc event takes object state higher val value discussion purposes label node integer might well integer given val trace set described mathematically recursive definition parameter cnt function label state note labels anything make often makes sense use labels correspond states implementation instance another description trace set using negative integers labels description corresponds class counter2 obvious two trace sets formal proof would use simulation relation defined 9 show fixed point induction follows note description virtually difference classes instances class determines trace set shared instances class specification equations classes directly verified trace sets example equation xinc gxval counter class verified noting states n objectbased semantics described 47 39 makes ideas work idealized algol simplicity consider version idealized algol syntactic control interference functions applied arguments interfere start notion coherent space 22 simple form event structure 59 coherent space pair jaj countable set reflexivesymmetric binary relation jaj elements jaj thought events objects particular type relation called coherence relation states whether two events possibly observed object state free object space generated coherent space set sequences jaj traces defined states carrying sequence events two traces must coherent events position condition applies position two events lead distinct states coherence condition future events element coherent space pairwise coherent subset x jaj elements object spaces denote trace sets objects functions appropriate object spaces called regular maps turns described simply terms linear maps f b actually define multipleargument linear maps needed semantics linear jbj whenever every linear map denotes multipleargument regular coherent spaces events various idealized algol types shown figure 7 trace sets objects type elements since statefree description objects virtually difference ja1 theta a2 figure 7 coherent spaces events ia types objects classes difference class used repeatedly generate new instances trace class sequence object traces one instance generated therefore define meaning term x1 multipleargument linear map regard vector traces 2 j 1 j record j 2 pi x linear map set pairs j indicates produce event result term carries event traces objects free identifiers interpretation interferencecontrolled algol terms 49 interpretation class terms follows fields c x methods init meaning class term says trace set c must trace s0s1 s0 represents effect initialization command methods term maps trace s1 2 j j trace 2 jj possible trace new class meaning new c p finds trace supported c p ready accept object trace course c supports many traces p use one traces theorem 2 objectbased model satisfies equivalences axioms sec 21 adapted version ia syntactic control interference 4 modularity issues section briefly touch upon higherlevel modularity issues relevant objectoriented programming work needed understanding issues 41 types classes objectoriented languages notion types classes fused one arrangement feasible ia classes firstclass values equality decidable example classes array c n array c 0 n 0 equal n n 0 equal comparisons neither feasible desirable however tighter integration classes types achieved using opaque subtypes modula3 also called partially abstract types 21 example counter class may defined newtype counter finc comm val expintg class counter client program knows counter subtype corresponding signature type counter type cls counter class counter hand inside abstraction boundary abstract type counter regards equal signature type specify requirements partially abstract types example specification 8x counter states every value type counter instance class monotonically increasing reveal blocks type counter get proof obligation demonstrate use type counter satisfies specification example use reveal blocks define classes counter counter2 job showing instances monotonically increasing note partially abstract types correspond america 5 calls types 42 inheritance typed lambda calculus records inheritance models literature adapted illustration show recursive record model 13 15 46 class uses selfreference defined type cls instead cls method suite parameterized self combinator close cls close class fields c f methods fix f init skip converts selfreferential class c class whose instances ordinary objects let c type cls define derived class record type extension use construction form class fields c f methods self f self init recordcombination operator 16 operator qualified type indicate record fields get updated needed coherence subtyping example suppose define variant counter class provides set method protected fashion type protected counter counter phi fset valint commg protected counter class counter counter fieldsvarint cnt methods self define derived class issues warnings whenever counter reaches specified limit protected counter warn counter class counter counter fields counter f methods self f self withset print limit reached f selfset kg init skip note close counter close warn counter type cls counter instances satisfy specification counter including history property set method cause problem inaccessible clients proof principle selfreferential classes derived fixedpoint induction inst c f 8x oex oefx inst close c x oex example lim satisfy inst close c x 8k valint 8p expint assert 43 dynamic objects typical languages algol family provide dynamic storage via hoares 26 concept references pointers object created dynamic storage accessed reference treated data value becomes storable variables modern languages like modula3 treat references implicitly assuming every object automatically reference seems preferable make references explicit reasoning principles much harder yet wellunderstood provide dynamic storage ia stipulate every type data type ref operations references roughly follows rule newref sound general since references stored variables exported scope refer local variables obey stack discipline local variables deallo cated references would become dangling references correct type rule newref given appendix knowledge semantics dynamic storage rather incomplete semantic models exist 55 56 yet clear integrate reasoning principles presented 5 conclusion reynoldss idealized algol quintessential foundational system algollike languages extending objects classes hope provide similar foundation objectoriented languages based algol paper shown standard theory algol including equational calculus specification logic major semantic models extends objectoriented setting fact much already implicit algol theory perhaps form accessible specialists among issues leave open future work thorough study inheritance models reasoning principles references investigation callbyvalue algollike languages acknowledgments pleasure acknowledge peter ohearns initial encouragement development work well continued feedback bob tennent hongseok yang anonymous referees fool 5 provided valuable observations led improvements presentation thanks martin abadi explaining intricacies per semantics research supported nsf grant ccr9633737 appendix reflective type classes type rules section 21 initialization command class restricted local fields class restriction leads clean reasoning principles fl law equations 26 restrictive practical instance counter class parameterized initial value n typecheck restriction init command free occurrences n reasonable relaxation restriction allow initialization command read storage locations write kind restriction also useful contexts eg defining function procedures read global variables modify 58 56 use dynamic storage involves similar restriction class used instantiate dynamic storage object references local store define general notion useful formalizing restrictions reflective type class set type terms 1 2 3 terminology motivated fact classes interpreted reflective subcategories semantic category 48 define several reflective type classes based following intuitions constant types involve values stateindependent neither read write storage loca tions values called various qualifications applicative 56 pure 37 chaste 57 dually statedependent types involve values necessarily depend state values passive types read storage locations write one senses const c values dynamic types access dynamic storage via references add three new type constructors const pas dyn identify values properties even general types value type const typed value built using constanttyped information outside regarded constant value define following classes least reflective classes satisfying respective conditions 1 constant types include valffi const types 2 statedependent types include expffi comm closed const pas dyn type constructors 3 passive types include valffi expffi const pas types 4 dynamic types include valffi const dyn types said used every free occurrence x subterm type particular say constantly used passively used dynamically used three kinds usages introduction rules const pas dyn follows constantlyused occurrences const passively used dynamically used dereference operator treated used means every identifier gamma used elimination type constructors use subtypings types const pas const dyn note closed term given type const example counter class section 2 type const cls counter application class definitions type rule classes modified follows fields c x methods init passively used allows free identifiers gamma used readonly fashion parametricity interpretation cls type must modified cls z rest theory remains except equation 2 becomes conditional noninterference c new c x application references use following rule creating references rule ensures class instantiated dynamic store use locations local store instance use either avoids dangling reference problem b semantics specifications section consider issue interpreting specifi cations raises two issues first noninterference formulas specifications require sophisticated functor category interpretation 57 41 whose relationship parametricity interpretation yet wellunderstood however possible interpret restricted versions specifi cations 8quantified identifiers restricted interfere free identifiers note queue specification fig 3 form second issue discussed section 31 equality relation specifications must general enough refined implementations allow equality relations refined implemen tations define parametric per semantics ia basic ideas bainbridge et al 7 see also 8 adapt predicative polymorphic context per e set x symmetric transitive relation differs equivalence relation need reflexive domain e defined x 2 dome note e reduces total equivalence relation dome set equivalence classes e denoted qe see 34 sec 56 discussion pers type new setting called pertype pair set ex per x per specifies notion equality type ordinary relatin called saturated relation type operator pair htper rel mappings pertypes saturated relations pertype operators products function spaces follows r theta assume small collection pertypes interested pertype operators operators inst c x oe 9hz hp z0ii figure 8 interpretation specifications inherit product sum function space constructors notions define type quantifiers follows ffl pertype operator 8z x z maps pertype x pertype h set consists families indexed z 2 per equates two families p p 0 saturated relations z z 0 relation part operator maps saturated relation ffl pertype operator 9z x z maps pertype x pertype h given relation part operator maps saturated relation r x comparing plain parametricity semantics section 31 note pers take place identity relations theorem 5 every type operator types pertypes saturated relations r saturated relations proof similar 8 interpretation ia exactly plain parametricity semantics except type operators understood pertype operators interpretation specifications shown fig 8 judgment form q j means formula oe free holds state set q environment j 2 domgammae q r imperative object calculus theory objects logic objectoriented programs linearity sharing state designing objectoriented programming language behavioural subtyping functorial polymorphism refinement concurrent objectoriented programs mathematical foundations programming semantics eleventh annual conference comparing object encodings semantics multiple inheritance fudgets graphical user interface lazy functional language denotational semantics inheritance inheritance subtyping algolbased simulation language calculus concurrent objects interpretation typed oop language state relationship classes proofs types theoretical aspects objectoriented programming abstract data types software validation data refinement refined record handling axiomatic approach binary logical relations applications data refinement reasoning refinement objectoriented specification languages modular specification verification objectoriented programs behavioral notion subtyping axiomatizing operational equivalence presence side effects towards fully abstract semantics local variables algebraic definition simulation programs foundations programming languages abstract types existential types refinement calculus call name syntactic control interference revisited objects interference yoneda embedding semantics local variables semantical analysis specification logic simple typetheoretic foundations objectoriented programming logic parametric polymorphism objects closures abstract semantics objectoriented languages global state considered unnecessary semantics interferencefree imperative programming passivity independence global state considered unnecessary introduction objectbased semantics syntactic control interference essence algol idealized algol specification logic types abstraction parametric poly morphism behavioral correctness data representations categorical models local names assignments applicative languages semantical analysis specification logic denotational semantics introduction event structures tr semantics multiple inheritance structure interpretation computer programs communicating sequential processes understanding types data abstraction polymorphism event structures abstract types existential type objects closures abstract semantics objectoriented languages communication concurrency proofs types inheritance smalltalk80 denotational definition towards fully abstract semantics local variables sound complete axiomatization operational equivalence programs memory semantical analysis specification logic behavioural correctness data representations inheritance subtyping call name assignment lambda calculus theoretical aspects objectoriented programming two semantic models objectoriented languages behavioral notion subtyping parametricity local variables denotational semantics interpretation typed oop language positive subtyping imperative object calculus algollike languages v2 assignments applicative languages relationship classes objects data abstraction semantics dynamic variables algollike languages simula algolbased simulation language syntactic control interference theory objects refinement calculus modular specification verification objectoriented programs data refinement refined comparing object encodings logic parametric polymorphism reasoning refinement objectoriented specification languages imperative firstorder calculus object extension logic objectoriented programs calculus concurrent objects introduction event structures designing objectoriented programming language behavioural subtyping abstraction denotational semantics inheritance ctr bernhard reus thomas streicher semantics logic object calculi theoretical computer science v316 n13 p191213 28 may 2004 uday reddy hongseok yang correctness data representations involving heap data structures science computer programming v50 n13 p129160 march 2004 bernhard reus jan schwinghammer denotational semantics program logic objects mathematical structures computer science v16 n2 p313358 april 2006 matthew parkinson gavin bierman separation logic abstraction acm sigplan notices v40 n1 p247258 january 2005 anindya banerjee david naumann ownership confinement ensures representation independence objectoriented programs journal acm jacm v52 n6 p894960 november 2005
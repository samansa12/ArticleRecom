lingua franca concurrent logic programming two important concurrent logic programming languages nonflat guards ghc parlog balance requirements clean semantics providing good control facilities rather differently respective merits compared contrasted since concurrent logic programming would benefit neither language able express programs expressible language lingua franca languages defined justified method given translating ghc parlog method preserves arities execution conditions clause enables lingua franca implementation support languages transparently provide simple concurrent logic programming language suitable programming right b introduction among concurrent logic programming clp languages like concurrent prolog 16 two prominent ghc 21 parlog 6 ghc parlog similar execution models complementary virtues argued hence could desirable find common denominator languages sufficiently expressive worth programming right yet sufficiently close languages inter translatable implementations language would support programming ghc parlog well common denominator style lingua franca simpler implement either ghc parlog benefits streamlined implementation could realised well paper describes lingua franca 2 ghc parlog ghc parlog program set relations r 1 r n r made guarded horn clauses name arity edinburgh prolog syntax h g 1 g atomic formulae unitary prolog goals clause following form h g 1 g b 1 b n clauses head h gives relation name arity g b j guard body goals separated commitment operator metasymbol signifies conjunction operator primitive true always succeeds fills empty guards bodies clauses declarative reading h true g 1 g b 1 b n true place filler ghc parallel conjunction operator parlog either parallel sequential conjunction operator one clauses form ordered relation c n c guarded horn clause metasymbol acting place filler clause search operator symbol terminates relation ghc stands parallel search operator whereas parlog stands either parallel sequential clause search operator operators right associative binding tightly allowing nesting parlog parlog clauses relation r arity n 0 preceded single mode declaration mode rm 1 n r clause heads principal functor either input argument symbol output argument symbol head arguments parlog clauses relation classified input output declaration ghc clause head arguments always input arguments operational semantics ghc redescribed way correspondences parlog come point view execute ghc parlog program refute conjunction goals g 1 g n resolvent n 1 input resolution ignoring moment parlogs sequential operators clause search goal conjunction goal g solved parallel either primitive satisfied removed resolvent user defined goal follows goal matched input arguments clause heads relation determining parallel whether relevant goal arguments unified input arguments head fresh copy clause without binding goal variables sharing algorithm explicit input matching using primitive given later clauses may satisfy head matching requirements goal instantiated suspended upon relevant goal variables input head arguments unified corresponding goal arguments variables upon suspended bound parallel head matching guard goals clause solved parallel one clauses head matching requirements guard goals relation satisfied one selected nondeterministically parallel clause searches terminated goal reduced goals selected clauses body replacing resolvent guard goal head match fails clause goals relation goal fails resolution succeeds goals solved resolvent empty fails goal resolvent obtained original goals fails parlog execution subject following special conditions output unification head arguments author department computer science heriotwatt university edinburgh scotland ghc actually defined without assuming finite failure effective implementation make assuming finite failure practical necessity chapter 4 especially section 410 21 14 p352353 sequential clause search sequential goal conjunction reduction output arguments parlog clause heads specified mode declaration unified corresponding goal arguments parallel body goal evaluation parlog clauses sequential search restrictions clauses goal initiates guard goal satisfaction head matching clauses next unencountered sequential clause search operator order left right guard goal head match fails clause heads guards clauses next unencountered clause search operator evaluated parlog goals conjoined sequential operator goal conjunction left hand side operator satisfied satisfaction attempted right hand side goal conjunction ghc execution subject following special conditions synchronisation rule sequencing rule synchronisation rule states trying bind calling argument variable passive part head guard prior commitment cause unification suspend guarantees safety guard evaluation namely guard whose clause figure reduction goal instantiate goal sequencing rule states clause body may executed commitment long attempt bind passive part variable prior commitment causes unification suspend simply satisfied delaying execution body goals commitment ghc parlog distinctive among clp languages 17 performing guard evaluation single binding environment avoids big runtime overheads faced clp languages concurrent prolog 16 supporting multiple binding environments flattening clp languages banning user defined goals clause guards overcomes problem sacrificing significant expressive power 3 3 lingua franca ghc parlog follows lingua franca ghc parlog characterised justified main feature parlog ghc clause expressed lingua franca clause satisfaction conditions lingua franca common language variation ghc parlog similar syntax semantics like ghc parlog lingua franca program set relations r 1 r n relation r composed guarded horn clauses h g 1 g b 1 b n metasymbol signifying parallel conjunction operator 1 n 1 like ghc lingua franca sequential conjunction operator clauses c form ordered relations c n relation c guarded horn clause terminates relation like parlog acts metasymbol place filler either sequential parallel clause search operator lingua franca relations modeless ghc fashion clause head argument occurring input matching role lingua franca goals executed andparallel input resolution common way described earlier ghc parlog except sequential clause search operators constrain orparallel execution parlog style full metainterpreter lingua franca given later lingua francas operational semantics differs ghcs allowing sequential search parlogs disallowing sequential conjunctions differs sequencing head matching guard evaluation instead requiring compile time analysis guards ensure guard safety like parlog requiring runtime safety test like ghc lingua franca imposes mandatory requirement safety however supplies language primitives supporting runtime safety test anywhere safe guard evaluation must guaranteed shall see standard ghc parlog primitives supported lingua franca well three new primitives 2 satisfy2 ward3 needed translating ghc parlog lingua franca point developing lingua franca made reviewing factors responsible differences ghc parlog 4 control emphasis parlog thematises control logic programs full constructs allow programmer synchronise sequence execution parts logic program parlog supports sequential parallel operators clause search goal conjunction thus following clauses process1 recursively process list queryresponse messageq r elements mode process process processmessage rb true second clauses guard tests whether query part q valid goal executeq r unifies r response otherwise message query ignored reply given sequential conjunction operator second third clause bodies ensures element executed processing continues next element second clauses sequential search operator ensures failure validquery1 guard test allows third clause tried types sequential operator enhance control features parlog used sequence calls inputoutput primitives help control extent computation demand driven control granularity parallelism however sequential operators weaken complementarity parlogs operational declarative semantics needed parlogs status logic programming language declarative reading parlogs orsequential operator signify negation prior clauses guards subsequent clause guards cannot soundly realised operationally implementing negation merely failure prior guards without imposing extra restrictions determined compile time analysis 6 p8992 restrictions raise problem precisely identifying unsafe guards discussed later furthermore sequentiality parlogs andsequential operator affects termination properties parlog program contribute declarative meaning swapping sequential parallel conjunction operators deadlock parlog goals used succeed thus unbound goal valida truth succeeds relation mode valid validtruth whereas sequential variant truth suspends ever although operator swap change declarative meaning query makes query longer satisfiable lack emphasis clean semantic properties parlog allowed defined certain kinds parlog programs could written unsafe guards could validly executed unsafe guards sabotage successful reduction goal relevant clauses enabling irrelevant guard evaluations whose clause figure reduction goal bind calling arguments mode choice choicea life waya true choiceb faith true mode way godless making call choicex faith program makes following things possible x first top level goal shared first argument first clause choice2 x first clauses guard bound godless satisfaction wayx second top level goal bound faith first top level goals head match first clause fails first top level goals match second clause head succeeds instantiates b godless happens top levels goals reduced body second clause choice2 fails thus examination subsequently rejected clause resulted unsafe guard goal wayx binding x godless interfered top level goals able succeed second clause order try rectify kind difficulty gregory introduced compile time safety check try weed unsafely guarded clauses parlog programs unfortunately analysing safety parlog program compile time undecidable matter general 6 p121132 thus algorithm exists selecting clauses parlog programs whose guards unsafe control emphasis parlog also allows parlog use primitives like var1 time call semantics 6 p82 thus conjunction goals called unbound succeeds fails depending upon whether first primitive executed second like unsafe guards time call behaviour makes harder prove correctness properties programs whether goal succeeds fails depends upon meaning goal upon nondeterministic properties implementation time call properties confined primitives like var1 apply even key parlog primitives like two argument metacall call2 primitive always succeeds initiates attempt satisfy first argument unifies second argument constant expressing result however satisfiable goal transformed new conjunction obtained whose success failure depends time execution conjunct preservation execution conditions transformation program clause replacing occurrence term guardbody fresh variable x conjoining goal parallel rest guardbody called antisubstitutability 21 472 clearly parlog clauses containing call2 lack property thus parlogs semantic drawbacks sequentiality affects goal termination declarative meaning unsafe guards cannot precisely identified prevent causing invalid execution realising declarative meaning negation failure also raises safety identification problem primitives time call semantics make computation outcomes nondeterministic drawbacks exist addition basic drawback clp languages precluding complete searches embracing dont care nondeterminism committed choice mechanism however extra semantic deficiencies bought significant price enhancing control parlog features make apt systems programming argued 5 semantic emphasis ghc approaches clp language design opposite point view parlog thematises semantic rather control issues clp language programs sequential conjunction search operators excluded language remove execution order constraints marring declarative reading guarded clauses termination properties programs rule synchronisation introduced ensure guards guaranteed safe primitives like var1 2 metacalls excluded eschew time call effects allow ghc clauses possess antisubstitutability lastly localising generation output bindings unification primitive 2 becomes simpler reason flow bindings ghc execution measures produce simple powerful language open application various transformation techniques 5 21 amenable formal analysis 9 14 20 however emphasis ghc clarity simplicity semantics weakens ability used general purpose programming tool excluding primitives like var1 ghc cannot use condition whether variable currently unbound decide whether commit clause although delay commitment variable bound precludes ghc defining unification within also precludes able define wide range related unification functions within ability program variations unification crucial logic programming languages ability program metainterpreters languages language flavours different experience prolog demonstrated prologs ability support wide variety metainterpreters related languages top major part reason success 18 losing access metaprogramming unification ghc hamstrung capacity mirror prologs wide metaprogramming capability systems programming clp languages requires ability handle failures exceptions runtime errors subcomputations modular fashion localises effects also requires ability control interact tasks suspend resume abort metainterpreters flavours extra control features needed either explicitly programmed implemented control metacalls 2 operating systems also need dynamic programmable control scheduling resource allocation subcomputations sophisticated control metacall achieve 4 however ghc refuses support parlog metacalls refuses support primitives needed programming unification ghc limited ability support flavoured metainterpreters result impoverished systems programming capability ghcs eschewal sequential search operators makes programming ghc difficult example lack sequential search operator makes difficult control grain orparallelism making harder control order clause examination furthermore clause choice userdefined condition test1 holding holding conveniently expressed sequential search goalin testin processin goalin true transformin using negation failure not1 6 p8992 goalin testin processin goalin nottestin transformin avoids condition testin evaluated twice hold wellknown clp languages like fcp parlog cp pprolog support sequential search form ghc lacks sequential conjunction operator ghc programs limited able use short circuit technique test set goals satisfied using technique conjunction alphaa betaa b gammac transformed give goal two extra arguments chain alphaa x1 x2 betaa b x2 x3 gammac x3 x4 goal succeeds unifies last two arguments test joint termination done binding one end x1 constant done waiting chains end x4 bound done ghc goals executed andparallel ghc programs cannot use parlogs simple expedient sequencing execution goal unification local chain ends mode alpha design kl1b basic machine language icots parallel inference machine 15 already influenced considerations kl1b 10 based upon flat ghc extended pragmas metacall price loss ghcs nice semantic properties neither ghc generally use sequencing rule alphaa x1 x2 alphaa achieve effect first goal sequence cannot violate safety guard alpha2s second argument accepted input tried instantiate goal would suspend attempted binding use short circuit fully general way ghc programs must extended test termination primitive call liable bind variables relevant program unification body ghc clauses defining alpha2 means replacing goal unifya b x1 x2 defined follows 17 p462463 unifya b x1 x2 true local part short circuit closed match4 detects unification done plainly overheads transformation mark gulf expressiveness ghc parlog paper shows choice made clp language clean semantics like ghc one good systems programming capability like parlog possible benefit respective virtues language single implementation rewriting lingua franca emulating language directly 6 common linguistic denominator lingua franca ghc parlog must abstract differences yet enable languages translated lingua franca back expressive either neither ghc parlog expressive enough translate away languages clauses parlog cannot support ghcs runtime suspension test ghc disallows action many parlog primitives besides restrictions primitives ghc four main features distinguish parlog mode declarations purely parallel search conjunction operators clause bodies executable commitment long trying instantiate body variable shared head guard causes unification suspend commitment attempts guard goals write upon calling argument variables commitment suspend 61 mode declarations ghc input matches head argument explicitly represents output bindings unifications bodies clauses parlog easily transformed obey rule 6 p6469 output mode parlog head arguments removed replaced fresh variable extra unification goal original head argument added clause body change parlog head arguments treated input arguments mode declarations dispensed way lingua franca translate away mode declarations parlog relations without supporting 62 passive part concurrency ghc parlog allow head matching proceed parallel guard evaluation lingua franca would made simpler required instead head matching completed guard evaluation begins would eliminate implementation overheads providing safe storage variables shared head arguments user defined guard goals accessed execution guard goal relevant binding variable supplied goal head match would also enable indexing tests head matching used sole means determining early whether clause suitable reducing goal would avoid early evaluation guards clauses whose heads dont yet match goal detect whether guard fails clause guards empty signified true transformation needed translating ghc parlog lingua franca compensate lingua francas sequencing head matching guard evaluation furthermore guard goal fail head match succeeds transformation necessary either however cases head match performed parallel guard evaluation otherwise suspension head match could delay indefinitely discovery guard goal execution fail thus guard nonempty known guard fail head match succeeds head match decomposed extra one way unification guard fashion translating parlog kernel parlog 6 p6566 variant gregorys method uses different oneway unification primitive 2 tries unify arguments suspends relevant left hand argument variables successful unification would bind one share two whole head match realised forming aggregate term head argument occur unique variable head oneway unifying similar aggregate distinct variable replacements thus guarded clause compareab cd testa c compareb translated comparee f e f ab cd testa c compareb new clause head distinct fresh variables arguments approach gives simpler representation head matching separate goals created match head argument repeated variables gregorys method however multiprocessing implementations may want implement 2 using several simple matching goals gregorys fashion avoid creating contention exclusive access variables tying variables together one primitive process sequential algorithm given figure 1 specifies behaviour required oneway unification operation algorithm returns success failure suspend execution executed time 2 process run returns success failure returns suspend 2 process suspended least left hand side variables detected bound unify procedure early detection failure requires suspended variables well awoken made runnable variables gets bound lists represented two argument structures handled separately whole algorithm executed atomically faster algorithms would circumvent using full unification test nonunifiability determining variables suspend order avoid obtaining exclusive access left hand variables execution 63 sequential operators unlike ghc parlog supports andsequential operators however synchronised satisfaction parlog goals achieved indirectly sequentially conjoined goals removed parlog clauses using metacalls synchronisation flags linking metacalls 6 p 9899 141142 absence andsequential operators ghc possibility eliminating sequential conjunction operators parlog way establishes another common feature ghc parlog copied lingua franca need support andparallel conjunctions andsequential operators eliminated transforming away parlog source would help lingua franca programs extract andparallelism applications ghclike programming style make programs less prone sequential style prolog programming dogging many parlog programs rather using gregorys method employs parlogs three argument control metacall simpler two argument metacall satisfy2 introduced instead attempts satisfy first argument succeeds binds second argument simple term succeeds attempted satisfaction fails fails different parlog metacall call2 never fails although metacall satisfy2 defined using call2 however violate antisubstitutability unlike call2 seen earlier introducing new primitive ground1 suspends argument ground satisfy2 used define auxiliary relation wait3 follows waitgoal control flag groundcontrol satisfygoal flag wait3 suspends second argument ground executes first argument goal fails goal fails succeeds signals fact binding third argument constant wait3 provides simple means realising sequential execution controlling execution order andparallel goals synchronisation flags thus mixed conjunction translated follows aa b waitonea waittwob e waitthreeab e control variables e delay execution threeab onea twob satisfied general form method translating away sequential conjunctions applies prolog syntax structure containing reserved predicate wait3 pure prolog program given figure 2 query pgoals newgoals parallel goals conjunction parlog goals unifies newgoals lingua franca translation 64 orsequential search ghc supports orparallel clause search although option allowing sequential search means otherwise predicate considered ghcs design one stage 21 347 hand parlog allows clauses searched parallel sequence gregory shown possible eliminate orsequential clause search using three argument parlog metacall 6 p140141 however using gregorys rather complex method would mean abandoning principle representing parlog ghc clause lingua franca clause translation relation name arity fortunately unnecessary sequential search easy support directly clp implementations 1 7 65 rule sequencing option executing bodies ghc clauses commitment subject ghcs rule sequencing 21 may seem appropriate highly parallel dataflow architectures likely result lot redundant computation less parallel architectures expense could profitably executed furthermore allowing premature computation almost ghc program guaranteed terminate without importing extra fairness assumptions 14 p353354 avoid semantic difficulties keeping extant implementations ghc 8 12 special suspension mechanism proposed supporting ghcs rule sequencing lingua franca rule obeyed parlog strict sequencing evaluation obeyed lingua franca clause committed evaluation body commence 66 rule synchronisation ghcs rule synchronisation preserves guard safety requiring unification would bind share calling argument variables ancestor guard unification suspend thus clauses yes call aska suspend unification yes suspend order instantiate calling argument variable ancestor guard two main approaches canvassed implementing guard suspension test uedas pointer colouring scheme 12 21 miyazakis guard numbering scheme 11 schemes concentrate upon suspending unifications bodies ghc clauses used evaluate guard goals event unification attempting write upon calling argument variable either scheme threatens impose suspension test overhead upon every explicit unification however ghc clauses either match input head arguments primitives input arguments guards evaluating remaining cases necessary test user defined primitive guard goal output arguments writing upon calling argument variable demand driven scheme could separate suspension producing conditions ghc clauses order localise requirement suspend evaluation extra primitive goal responsible guard would impose general overhead upon unification body allowing unsafe userdefined guard goals evaluated without suspension constraints output bindings evaluation made eager computation space effectively recycled computation space used represent guard goal processes process tree claimed released soon guard goal satisfied fails claimed frozen unused pending communication input values remove suspension goal process suspended unsafe binding deep guard evaluations frozen space may include space claimed store ancestor processes suspended upon suspended userdefined guard process well claimed store process performing suspended unification 661 localisation central idea behind localisation 19 suspension effects due rule synchronisation arise happens guard evaluation restricted locus evaluation follows variables termed unsafe occur heads ghc clauses either user defined guard goals argument positions primitive guard goals liable bind given values unsafe variables guard goals replaced fresh variables transformed calls guard goals allowed proceed without subject safety suspension condition safety suspension condition achieved new primitive relinks unsafe guard variable new replacement way ghc program distilled lingua franca clauses interleaved special primitives achieve safe guard suspension mechanism special primitives job allow old variable values passed new replacement ensure unifying new old guard variables would bind calling argument variable commitment special primitive suspend example take ghc clause remove head match manner already described replaced fresh variable a1 userdefined guard test1 special primitive ward2 added link two variables way protects calling environment bound suspending call instead result ward2 needs able suspend several variables must handle complex terms complex terms get progressively bound also needs able suspend awake pass values maybe suspend properties ward2 inferred fact guard goal test1 might need argument bound value succeed satisfaction guard achieved ward2 goal passes bindings second argument first however ward2 goal allow user defined guard goal export value satisfaction ward2 simply unify a1 unidirectional unification apt however ward2 equated 2 second goal guard succeed cases calling argument b bound might get bound 121 first input matching unidirectional unification succeed sharing 121 since a1 still unbound second guard safety unidirectional unification succeed sharing shortly afterwards parallel test1 call might bind variable a1 incorrect result could instantiation calling argument variable 121 incorrect clause committed behaviour cannot avoided insisting second goals unidirectional unification performed test1 goal succeeded bindings could never passed ward2 user defined guard goal better idea make ward2 predicate reluctant unidirectional unification ward2 predicate suspends order unify unidirectionally arguments share variables reluctant unidirectional unification unidirectional unification bindings made instantiable side whenever nonvariable bindings detected noninstantiable side unidirectional unification possible fails two sides never unified instantiable side variables need associated complex noninstantiable side terms containing variables bound consistent copy complex term avoid variable sharing unidirectional unification reluctant variables instantiable side get bound nonvariables never get shared variables noninstantiable side predicate suspends instead problem test severe guard goal needs partially bound unbound argument order succeed ward2 predicate must suspend ever example guard goal defined follows true true result reluctant unidirectional unification would ward2 predicate suspend two variable arguments even userdefined guard test1 succeeded ward2 predicate suspend two unbound arguments long guard goal warding succeeded implement variable binding used signal success userdefined guard goal signal sent ward predicate extra argument predicate defined gets signal abandons reluctance oneway unification tries relink original variable replacement nonreluctantly unidirectionally ensures bindings generated evaluating guard goal passed calling environment causes primitive suspend attempted putting considerations together gives following original clause gets transformed first guard goal implements head matching next two implement original guard goal set ghc suspension test userdefined guard goal succeeds calling argument variable replacement linked reluctant unidirectional unification allow sharing variables ward3s first two arguments guard goal succeeds c bound metacall satisfy2 signals ward3 unidirectionally unifies first two arguments allow sharing variables algorithm ward3 first two arguments unifiable opposite order given 19 662 general localised suspension transferring translation scheme general scheme requires taking account multiple occurrences unsafe variables one guard goals simple sound way place entire original guard satisfy2 metacall part guard contains original head argument variable aggregate term unsafe variables consistent copy also formed substituting fresh variables unsafe variable two terms related ward3 general rule implementing guard safety suspension ghc applies guard goals containing userdefined predicates primitives liable bind arguments variables head argument userdefined guard goal primitive goal argument primitive goal may bind formed risk set distinct fresh substitute variables set created risk set empty nothing done every member risk set guard goal uniformly replaced substitute whole ghc guard put first argument satisfy2 metacall fresh variable called control variable put second argument structure arbitrary functor arguments consisting members risk set variables formed copy structure made substitute variables replacing risk variables ward3 predicate goal added guard structure structure copy control variable satisfy2 first three arguments head matches decomposed guard fashion described earlier although ward3 used compile ghc lingua franca cannot used satisfy2 compile ghc flat ghc metacall violate antisubstitutability unlike parlog metacall call2 21 472 primitive ward3 unbound variables goal wardcd aa yes suspends whereas antisubstitution may succeed hence ward3 cannot made ghc primitive applies 2 7 example translations example shows result applying transformation ghc following ghc clause processab c ad checkab e testad e processb c translated lingua franca clause processj c k j k ab ad e testfh e processb c first guard goal implements head match second implements safe guard suspension test three relevant variables third satisfies original guard two extra primitive goals metacall required implement localised runtime suspension test head match different example shows transformation parlog clause mode test e testb c following lingua franca clause waitchecka j waittestc j k waitanalysea l waitsynthesiseb f waittransformb f l n waitunfoldc e l waittestb c l n p 8 translating back lingua franca reverse translation translated ghc simple general method presupposes occurrences predicates ward3 2 satisfy2 solely product original correct translation 1 satisfy2 predicate replaced first argument 2 first two arguments ward3 unified goal removed two arguments 2 unified goal removed guard left empty space filled primitive true simplicity reverse translation method done translating ghc lingua franca decompose unifications way appropriate suspension effects unification directionality associated clearly reunifying restore status quo reverse translation lingua franca parlog performed three steps first head matches restored unifying two arguments 2 removing 2 goal sequential conjunctions put back finally output head arguments restored general algorithm sequential conjunction replacement given executing query qgoal newgoals pure prolog program given figure 3 goals bound lingua franca conjunction goals newgoals unified original parlog conjunction output head arguments restored unifying arguments 2 predicates body created original translation removing uniquely identified giving reserved name original translation mode declarations cannot always correctly inferred initial translation lingua franca preserved independently 9 lingua franca semantics metainterpreter full lingua franca invoked callgoals given figure 4 call1s first clause handles conjunctions second clause evaluates primitives recognised suspending primitive primitive1 third clause handles committed choice resolution frozen clauses retrieved second list argument clauses2 define first argument relation operators joining adjacent clauses clauses selectability tested reduce3 first clause reduce3 examines whether leading clause reduce goal second clause searches next clause parallel third clause examines last clause group clauses searched parallel sequential search operator ensures fourth clause considered first three considered rejected continues clause search previous reduce3 clauses shown unable reduce goal test3 ensures head match performed guard called match3 uses primitive melt2 obtain fresh melted copy frozen clause input matching goal instead imposing inadequately selective guard safety criterion validity programs like parlog requiring mandatory runtime safety test evaluating every clause guard like ghc lingua franca supplies precise means supporting runtime safety test anywhere safe guard evaluation must guaranteed test used augment compile time safety analysis 6 p121132 thus unsafe guards reduce3 made safe replacing test3 ward3 goal acts valve preventing execution g1 metacall satisfy2 exporting bindings g hence goal calling environment lingua franca simplifies clp language semantics making safety clp clauses guard constraint must satisfied execute clp language validly guaranteeing guard safety enabled providing means let precise test safety applied anywhere needed language semantics make optional apply test realised clause using methods translation described earlier exercised generally program unsafe guards using safe guard metainterpreter described lingua franca exceeds ghc parlog expressive power able translate ghc parlog clause lingua franca clause operational semantics ghc parlog unable lingua franca clause furthermore able translate clp languages lingua franca back lingua franca implementation presented transparently ghc parlog lingua franca implementation programming style lingua franca hybrid ghcs parlogs lingua franca follows ghc eschewing provision andsequential operator modeless steers programmers away lapsing sequential prologlike style relying misleading assurances given mode declarations lingua franca follows parlog providing rich set control constructs disallowing use time call primitives thus provides clp vehicle right rather like parlog programming systems uncoupling evaluation user defined guards suspension mechanism using ward3 localise suspension effects unsafe guard lingua franca makes execution guard goals eager effectively recycles computation space ghc computation space used represent user defined guard goal processes claimed released soon guard goal satisfied fails claimed frozen unused pending communication input values remove suspension goal process suspended unsafe binding lingua franca require head matching concurrent guard evaluation incurs less runtime overheads respect ghc parlog eliminates need provide safe storage variables shared head arguments user defined guard goals accessed guard goal execution relevant variable bindings supplied head matching also expedites use indexing clause selection avoiding early evaluation guards clauses whose heads dont yet match goal detect whether guard fails 10 kernel parlog viewed intermediate language compilation parlog lingua franca plays role similar kernel parlog 6 p6469 however several important differences unlike kernel parlog lingua franca made expressive enough used programming vehicle first instance like parlog ghc thus preserves full head matching functionality rather translating away fashion kernel parlog furthermore kernel parlog support primitives like ward3 would enable translate away ghc runtime suspension test kernel parlog execution obey runtime suspension test implementation independently supports ward3s complex action cannot performed kernel parlogs simple input matching primitives would require ensuring atomic execution several together however kernel parlog lacks means part method described translating away ghcs runtime suspension test complex series simple matches performed parallel context translating full ghc clp language cp 14 however translation exploits multiple environment property clp language atomic operations required kind possible kernel parlog cannot follow cp ward3 suitable treating kernel parlog primitive design philosophy underlying choice kernel parlog primitives aimed ensuring processes intended andor tree implementation model 6 pp163164 never require suspend variable however ward3 able 11 conclusion strategy absorbing differences two prominent clp languages assimilating common language variant proposed meets different demands clp languages supporting common medium strategy detailed translate ghc parlog lingua franca back implementation lingua franca transparently presented user either executing ghc parlog directly supporting languages lingua franca provide user semantically desirable properties ghc control features parlog simple programming style single implementation according requirements acknowledgements would like thanks steve gregory papers reviewers many detailed helpful comments well colleagues heriotwatt university members imperial colleges parlog group r implementation committed choice languages shared memory multiprocessors logic operating systems design issues flat parlog basis comparison parlog systems programming language partial evaluation ghc programs based upon urset constraints parallel logic programming parlog language implementation abstract machine implementation parlog uniprocessors distributed implementation flat ghc multipsi preliminary note semantics guarded horn clauses abstract kl1 machine instruction set dataflowbased parallel inference machine support two basic languages kl1 ghc abstract machine instruction set translation safe ghc safe concurrent prolog fcp ghc operational semantics problems relationship cp subset concurrent prolog interpreter family concurrent logic programming languages metainterpreters expert system construction localising ghc suspension test operational semantics guarded horn clauses guarded horn clauses tr parallel logic programming parlog language implementation metainterpreters expert system construction abstract machine implementation parlog uniprocessors family concurrent logic programming languages ghc abstract machine instruction set implementation committed choice logic languages shared memory multiprocessors
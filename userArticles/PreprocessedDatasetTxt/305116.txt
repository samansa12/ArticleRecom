broadcasting multiple messages multiport model abstractwe consider problem broadcasting multiple messages one processor many processors kport model messagepassing systems systems processors communicate rounds every round processor send k messages k processors receive k messages k processors paper first present simple practical algorithm based variations k complete kary trees present optimal algorithm additive term one problem number processors number messages value k b introduction paper explores broadcast problem multiport model messagepassing systems particular consider onetoall broadcast problem messagepassing system modeled complete graph n nodes kport model assume n processors nodes system denoted 0 source broadcast broadcaster processor 0 also assume source messages denoted broadcast processors kport model n processors k distinct input ports k distinct output ports communication round every processor send k distinct messages k processors round processor receive k distinct messages sent k processors broadcasting important communication operation many multiprocessor systems application domains use operation extensively include scientific computations network management protocols database transactions multimedia applications due significance operation important design efficient algorithms broadcasting operation frequently used many applications messagepassing systems see 11 several collective communication libraries express 9 parasoft message passing library mpl 1 2 ibm sp2 parallel systems provide broadcast primitive operation also included part collective communication routines messagepassing interface mpi standard proposal 8 several variations broadcasting problem studied literature see 13 comprehensive survey research focused designing broadcasting algorithms specific network topologies rings trees meshes hypercubes however emerging trend many communication systems treat system fullyconnected collection processors every pair processors communicate directly trend identified number modern multiprocessor systems ibms vulcan 17 thinking machines cm5 15 ncubes ncube2 16 intels paragon 12 ibms sp2 well highspeed communication networks eg paris 6 communicating large amounts data many systems break data sequences messages packets sent received individually approach motivates research problem disseminate multiple messages efficiently systems focus problem broadcasting multiple messages one source broadcasting single message model simpler task problem broadcasting multiple messages fullyconnected systems studied several communication models cockayne thomason 7 farley 10 presented optimal time solutions problem model processor either send one message receive one message communication round model sometimes referred unidirectional telephone model telegraph model model optimal number rounds odd n optimal number rounds even n 2m ne bidirectional telephone model barnoy kipnis schieber 5 provided optimal algorithm requires ne rounds even n odd n presented algorithm optimal additive term 1 requires rounds also solved broadcasting problem optimally simultaneous sendreceive model model every round processor send message one processor receive message another note sendreceive model equivalent 1port model solution requires ne rounds barnoy kipnis 3 4 well karp et al 14 also investigated problem broadcasting multiple messages postal logp models communication models processor simultaneously send one message receive another message message delivery involves communication latency models optimal solutions problem broadcasting multiple messages known nontrivial values communication latency multiport model generalizes oneport model widely investigated examples parallel systems kport capabilities k 1 ncube2 16 cm2 k dimension hypercube machines transputerbased machines results paper present two algorithms broadcasting messages within nnode complete graph kport model n k 2 first algorithm called ktree algorithm simple practical time complexity dmke compared simple lower bound dmke log upsilon gamma 1 thus delay message optimal small multiplicative factor logk second algorithm called rotation algorithm optimal additive term one specifically algorithm requires dmke log upsilon rounds second algorithm complicated uses first algorithm subroutine throughout paper assume 2 bounds section present bounds regarding multiple messages broadcasting problem first two lemmas simple extensions wellknown lower bound 1port case first observation broadcasting time single message among n processors kport model must take least log upsilon rounds one round processors know message two rounds k know message etc lemma 1 broadcasting time one message among n processors kport model least log upsilon rounds second observation earliest round broadcaster send mth message round dmke gamma 1 since round send k messages thus simple lower bound follows lemma 2 broadcasting time messages among n processors kport model least upsilon log upsilon rounds however many combinations n k lower bound one larger previous lower bound broadcast time second algorithm also one larger previous lower bound second lower bound shows many cases algorithm optimal specifically following lemma ne let lower bound broadcasting messages among n processors kport model log upsilon proof following proof lemma 2 broadcaster needs least rounds send messages furthermore tightest schedule respect broadcaster fi messages 1 fi need sent round fi messages reach processors total bandwidth n gamma 1fi needed starting round however maximum bandwidth used fi messages starting round k k round log upsilon total n bandwidth used fi messages thus n least one round needed 2 example 2 lower bound dmke log upsilon among n range ie lower bound dmke log upsilon among n range special case n power k 1 following corollary corollary 4 n power k 1 number rounds required broadcasting messages among n processors kport model k 2 least upsilon log upsilon log k1 n otherwise note gamma1 term appears case last round sending broadcaster broadcaster one message send cases broadcaster could start complete broadcasting tree paper circumvent distinction different values k considering minimum broadcasting time version problem version assume broadcaster infinite number messages round sends k new messages k less processors processors responsible broadcasting messages among rest processors goal minimize broadcasting time messages show maximum broadcasting time message rounds broadcasting time messages achieved dmke simply instructing broadcaster idle finishes sending messages reduction yields algorithm optimal additive term log upsilon optimum summarize discussion following lemma lemma 5 suppose exists algorithm minimum broadcasting time problem complexity rounds exists algorithm multiple messages broadcasting complexity far optimum additive term log upsilon rounds 3 ktree algorithm section describe simple algorithm called ktree algorithm time complexity algorithm dmkemax2 dlog k n 2ke thus delay message optimal small multiplicative factor logk 31 general ktree theorem algorithm based construction k spanning trees size n proper labeling tree nodes first give general theorem regarding kport broadcast based k spanning trees theorem 6 one construct k spanning trees size n properties 1 tree n nodes uniquely labeled 0 root labeled broadcaster 2 height tree less h 3 node identified label number children summing k trees k broadcasting messages among n nodes kport model finished time proof round root broadcaster send distinct message tree messages propagated tree pipelining one level per round make sure scheduling violate kport model number incoming messages outgoing messages respectively per round node must exceed k clearly nonroot node receive k messages per round one parent per tree since property 3 node k children summing k trees number outgoing messages per round also bounded k time complexity follows property 2 2 32 almost complete kary trees following definition needed algorithm almost complete kary tree n nodes denoted k n constructed follows starts root adding nodes level level topdown manner within level l k leaf nodes attached node level l gamma 1 left right either nodes level filled tree reached total n nodes say node tree internal node neither root tree leaf node also root internal nodes jointly referred nonleaf nodes clearly nonleaf nodes k n k children except last nonleaf node children also last two levels leaf nodes since complete kary tree height h nodes follows trees consequently values n height k n derived convenience also define 0 k n tree derived attaching root k n gamma 1 new node serving new root 0 k n broadcast based k spanning trees tree topology 0 possibly minor modification goal find mapping f0 tree node 0 mapped root property 3 theorem 6 satisfied consider three cases separately following k divides divide 2 33 broadcasting k divides use k spanning trees broadcasting topology 0 k n complete kary tree n nodes nodes counted groups k except root therefore complete kary tree k divides k n composed k n gamma 1 trees follows k divides every internal node k n gamma 1 tree full fanout ie k children hence case number internal nodes per tree n gamma 2k total nodes k trees note broadcaster root k trees processors choose define onetoone mapping nodes since processor mapped internal node ie mapped leaf nodes trees k children summing k trees thus theorem 6 algorithm finishes time dmke h height trees figure 1 shows example 5 12 used broadcasting among processors 5port communication model 34 broadcasting k divide 1 first construct k trees topology 0 trees labeled according described case add ff nodes tree follows clarity call trees 0 k gamma 1 add nodes trees order 0 k gamma 1 convenience refer first resp second leaf node leaf node first resp second rank among leaf nodes ordered topdown manner left right within level note since n 2 tree 0 contains least therefore least two leaf nodes let added ff processors process adding ff nodes create new internal nodes following algorithm two tasks first specify parents nodes attached second assign processor new internal nodes way violates property 2 theorem 6 note need describe assignment processors leaves since assignment valid algorithm attaching ff nodes tree assigning new internal nodes ff new processors follows attach ff nodes first leaf node jth tree assign processor p new internal node endif else attach nodes first leaf node jth tree assign processor p new internal node attach c nodes second leaf node jth tree assign processor p new internal node endif endfor following algorithm new ff nodes either entirely attached first leaf node spread first second leaf nodes 0 ff counter c used make sure processor p k children summing k trees since ffk new children need covered new processor k children enough processors act new internal nodes figure 2 shows example tree structure adding nodes figure 1 note example previous example processor 14 assigned internal node 35 broadcasting 2 case trivial 2 approach adding extra nodes case work one leaf node 0 2 thus need redefine second leaf dynamic way specifically redefine second leaf node first child first leaf node case algorithm attaching ff nodes described still holds easy show maximum height trees 3 figure 3 shows example trees 5 36 time complexity let h maximum height trees theorem 6 broadcasting messages realized upsilon showed section 35 h 3 derive h cases let fn height k n maximum height k trees defined section 33 k maximum height k trees defined section 34 1 k additive term 2k first operand function f upper bound maximum number nodes could added creating two new internal nodes since fn k monotonely increasing function respect n focus height second case thus time complexity algorithm note 2 k thus time complexity also bounded dmke ne overall n k 2 time complexity bounded recall simple lower bound dmke log upsilon 1 thus algorithm multiplicative factor logk lower bound delayterm bandwidthterm tight table 1 lists selected k n number additional rounds required algorithm simple lower bound accuracy use time complexity ktree algorithm approximation ie 2 4 rotation algorithm section describe complicated algorithm algorithm based three broadcasting blackboxes described later broadcasting black box bbbh ffi referred also system defined follows ffl h processors system ffl round k messages injected system received k less processors h processors ffi rounds k messages sent system k less processors necessarily processors ffl h processors know k messages rounds parameter stands broadcasting time broadcasting blackbox parameter ffi stands delay time stream messages time injected system time ejected system trivial broadcasting blackbox broadcaster denote special blackbox bbb1 0 0 since assume broadcaster already knows messages sends delay using broadcasting blackboxes generate broadcasting algorithm chaining blackboxes follows let bbb broadcasting blackboxes bbb 0 broadcaster blackbox bbb1 0 0 bbb form bbbh connect output stream messages bbb igamma1 input stream messages bbb output stream bbb need sent refer algorithm chain algorithm overall number processors system p difficult verify processors bbb know message p rounds time sent broadcaster get following theorem theorem 7 broadcasting blackboxes let bbb trivial blackbox consisting broadcaster chain algorithm bbb broadcasting algorithm among 1 processors takes maxft rounds algorithm based following proposition regarding representation number n sum properties proposition 8 n 1 represented following properties 1 either 2 depending previous property value 1 either log upsilon therefore log upsilon proof proof construction first check whether 1 1 case done otherwise let 1 1 largest pair lexicographically process finding delta done either finding clearly 1 log upsilon order prove property 3 show 2 1 rest follows recursive construction assume contrary distinguish two cases 1 first case get inequality contradicts maximality 1 given choice 1 1 inequality contradicts maximality 1 second case contradiction achieved since rest section describe following three broadcasting blackboxes 1 2 3 bbbn 2 1 n 2k use proposition 8 construct chain algorithm apply chain algorithm blackboxes bbb1 0 0 bbbn case get following corollary corollary 9 chain algorithm broadcasting time message log upsilon proof theorem 7 complexity algorithm maxfd rounds third property proposition 8 get 1 j hence round complexity bounded maxfd 2g corollary follows since log upsilon log upsilon note chain algorithm delay stream messages last blackbox insignificant output stream longer needed therefore use types blackboxes delay 1 return original multiple messages broadcasting algorithm messages mth message null messages chain algorithm yields following theorem theorem exists broadcasting algorithm among n processors takes upsilon log upsilon rounds note bound greater simple lower bound one matches second lower bound many values k n 41 broadcasting black box nice numbers subsection describe broadcasting blackbox bbbk 1 let 1 blackbox nice numbers since together broadcaster system consists processors since algorithm based structure ddimensional cube base k 1 recall round k new messages enter system delay rounds round k different messages leave system denote messages input output messages correspondingly throughout algorithm processors dynamically partitioned disjoint sets round set processors instructed send message processors set send message k processors sets verified processor receives k messages round end round processors instructed move new set however size sets remain first define partition processors partition consists k delta sets 1 sets arranged matrix size k theta size set sets include processors denote messages following order arrive blackbox next define set message send definition depends round assume enters blackbox round 0 let r 1 current round processors assigned message rgamma1gammajki r case finite number message assigned message define recipients messages sent set processors processors dgamma2 sends k copies assigned message processors addition k input messages goes one sets j processors set send assigned message kjs processors one message output message indeed number equal number processors verify processor receives k messages processors receive k messages sets 1 processors messages sets 1 one message set input message conclude description algorithm defining new partition processors sets 1 0 consist k processors received k input messages sets consist processors processors received message round note processors change sets going circle manner among sets 1 processors remain set throughout algorithm example demonstrate flow algorithm follow message arriving blackbox sent blackbox consider processor x set received message outside round r round r one belongs set 0 round x sends k processors set processors join x create new 1 set round r 2 round r kk processors set recipients message join senders create new set round r size process continues manner round r beginning round x belongs processors set knows assigned send processors showed round processor know moreover one processors say x send outside exactly rounds x received round x another processor gets new message outside process starts correctness correctness algorithm implied next lemma states invariants maintained throughout algorithm whenever refer message mean null message lemma 11 beginning round r 1 message rgamma1gammajki known processors 2 messages known processors proof proof induction round number follows send receive movement instructions algorithm 2 following dissemination particular message hard see lemma implies correctness bbb stated next theorem theorem 12 message known processors rounds leaves system output message rounds 42 broadcasting black box special numbers subsection describe broadcasting blackbox bbbak 1 1 k let blackbox special type numbers cover numbers recall round k new messages enter system delay one round k messages leave system denote messages input output messages algorithm variation algorithm described previous subsection first define partition processors partition consists k delta sets 1 sets arranged matrix size k theta size size 0 one indeed sets include processors assignment messages previous subsection define recipients messages sent set processors processor sends k copies assigned message follows gamma 1 copies processors copies processors specified later one copy sent output message processors dgamma2 sends k copies processors addition k input messages goes one sets j processors sets send assigned message kk processors number kjs means k gamma processors get message assigned sets choose processors processors always remain sets receive message rounds earlier processor set verification processor receives k messages new partition similar one appears previous subsection correctness algorithm follows next lemma states invariants maintained throughout algorithm lemma 13 beginning round r 1 message rgamma1gammajki known processors 2 message rgamma2ki known k gamma additional processors set 0 3 messages known processors proof proof induction round number follows send receive movement instructions algorithm 2 following dissemination particular message hard see lemma implies correctness bbb stated next theorem theorem 14 message known processors rounds leaves system output message one round 43 broadcasting black box small numbers subsection describe broadcasting blackbox bbbx 2 1 0 x 2k note broadcasting blackbox definition broadcaster outside box thus consider broadcasting 1 n 2k n includes broadcaster using ktree algorithm 1 2 use construction section 35 height k trees 3 means delay within black box 2 use construction section 34 height k trees bounded 2 thus height h means delay within black box 2 note fact given construction bbbx 2 2 summary presented two algorithms broadcasting multiple messages multiport model ktree algorithm simple structure scheduling policy furthermore time complexity close lower bound practical k n see table 1 rotation algorithm optimal additive term one certain values n use broadcaster help broadcasting messages achieve optimal algorithm since method work values n omit description also values k algorithm optimal exact characterization finding optimal algorithms values n still open mentioned introduction postal model even known optimal algorithm values n actually values n exist optimal algorithms ultimate problem find optimal algorithm kport postal model multiple messages broadcasting problem value n k delay parameter postal model see 3 r ibm external user interface scalable parallel systems ccl portable tunable collective communication library scalable parallel computers designing broadcasting algorithms postal model messagepassing systems multiple message broadcasting postal model optimal multiple message broadcasting telephonelike communication systems paris approach integrated highspeed private networks optimal multimessage broadcasting complete graphs document standard messagepassing interface express 30 introductory guide broadcast time communication networks solving problems concurrent processors intel paragon xps supercomputer survey gossiping broadcasting communication networks optimal broadcast summation logp model network architecture connection machine cm5 ncube family parallel supercomputers architectures implementation vulcan tr
partial evaluation aircraft crew planning paper investigate partial evaluation program transformations used real problem namely speeding airline crew schedulingscheduling crews subject many rules restrictions restrictions expressed rule language however given planning situation much known fixed rule set partially evaluated respect known inputthe approach somewhat novel uses truly static input data well static input data values known belong set valuesthe results partial evaluation quite satisfactory compilation running times decreased using partial evaluator part crew scheduling system carmen systems ab markets use major european airlines daily production b introduction next fuel costs crew costs largest direct operating cost airlines 1991 american airlines reported spending 13 billion crew agpt91 major airlines similar costs therefore much work devoted planning scheduling crews last thirty years planning aircrafts crews large airlines complex prob lem see ahkw97 good overview make problem tractable normally divided four parts construct timetable first time table produced objective match expectations marketing department available fleets constraints output process number legs nonstop flights airline decides operate fleet assignment second aircrafts allocated legs must match expected number passengers goods available aircraft fleets output problem timetable augmented aircraft information crew pairing third pairings constructed pairing sequence flight legs unspecified crew member starting ending crew base sequence often called crew rotation crr crew member normally working legs pairing may also contain legs crew member transported leg called deadhead legs naturally grouped duty periods working days called rotation days rtd rotation day separated layover overnight stop legal pairings must satisfy large number governmental regulations collective agreements vary airline airline output phase set pairings covering legs timetable crew assignment fourth planning problem assign pairings named individuals crew assignment rostering prob lem objective cover pairings previous stage well training requirements vacations etc satisfying work rules regulations carmen systems ab markets system handles last two parts planning problem system use major european airlines optimiser runs stages first generates large number possible pairings using clever heuristics te96 second selects subset covers legs scheduled minimal cost second part huge set covering problem wed95 covering potential solution needs checkedso fulfils rules mentioned run optimizer computationally heavy job run may take minutes days computer time important make fast possible since enables tries find good solution made finding good solution usually requires manual tweaking rerunning optimizer testing rule validity usually takes largest part computation time improvement beneficial rules carmen system expressed special language de scribed complete rule set usually rather large containing thousands lines covers fleets long haul short haul crew categories different union agreements scheduling standards etc however particular problem solved subset rules really needed problem may particular crew category specific aircraft type etc large program rule set input data known crew category etc spells partial evaluation 2 rule language express rules affect legality costs different solutions planning problem carmen systems developed proprietary language carmen rule language crl boh90 crl said pure zeroth order strongly types functional language zeroth order language functions except built ones evaluation rules also uses form lazy evaluation consequence us leg number attributes attributes eg aircraft type arrival time departure time given leg attributes eg length flight computed given ones calculations rule language describes input rule evaluation set pairings ie number crrs crr contains number rtds rtd contains number legs task rule evaluation find given set crrs legal legal cost also computed less important legs rtds crrs attributes given computed attributes examples use different syntax real language uses hopefully make things clearer define externally given attributes levelattribute type level leg rtd crr attributes defined language written levelattribute expression level type definitions really necessary since deduced given clarity program fdefinitiong definition constantdefinition leveldefinition ruledefinition constantdefinition name leveldefinition ruledefinition rule level type level leg j rtd j crr expression literal name expression binop expression expression expression else expression aggregatelevel builtinfunctionexpressions case expressions fcaseblock otherwisegcaseblock endcase case expressions external stringliteralendcase caseblock pattern literal literal literal expressions aggregate sum j j j count next j prev j first j last figure 1 simplified grammar crl definition means item given level leg rtd crr attributed computed according formula rule set program defines number attributes rules rules boolean expressions preceeded keyword rule checking solution ie grouping legs rtds crrs legal amounts checking rules evaluate true types operators language fairly limited mostly self explanatory give formal description except simplified grammar figure 1 two unfamiliar types probably abstime reltime represent absolute times time differences respectively aggregate functions evaluate expression lower level aggregate clause acts guard makes possible aggregate expressions lower level guard true eg sumleg legdeparture abstime time plane departs legarrival abstime time plane arrives legaircrafttype string type plane eg 747 legdeadhead bool deadhead leg legblocktime rule hours per flight figure 2 simple example rtd sum x attributes legs attributes true language carefully designed impossible write nonterminating computations way program fail 1 properties make rule language amenable program transformations since cannot occur 21 rule example figure 2 shows simple rule set expects departure arrival aircraft type supplied externally leg whereas blocktime 2 computed leg also rule states blocktime less 4 hours leg need quantify rule expression automatically tested wherever applies extended example figure attributes defined total worktime defined rtd level defined sum worktime leg belonging rtd sum one built functions aggregate data lower level hierarchy remember hierarchy wired problem thus language therefore ambiguities legs sum given rtd note second rule refers attribute leg level rtd level since leg belongs exactly one rtd ambiguity rtd use computation rule 1 program principle divide 0 told ignore divisions rare real life 2 blocktime time wheel blocks removed departure replaced arrival considered total time flight legbriefing legdebriefing legworktime rtdtotalworktime maxtotalworktime rule rule may longer half work day rtddeadheadsperrtd crrdeadheadspercrr rule deadheads pairing figure 3 extension simple example legbriefing case timeofdaydeparture 0000 0600 015 0601 1800 030 2359 020 legminimumgroundstop case arrivalairportname deadhead dayofweekarrival fra false 1 5 100 otherwise otherwise 030 figure 4 tablecase expressions 22 tables lot rule computations simply expressed table lookups crl fairly powerful case construct express case construct several values keys matched simultaneously set patterns pattern literal range patterns allowed overlap marked explicitly figure 4 shows simple examples table constructs first one determines briefing time depending time day arrival arrival abstime time day function drops date part second table states minimum ground stop one hour arrival frankfurt fra nondeadhead leg monday thru friday etc 221 external tables avoid repeated recompilations rule set make flexible concept external tables external table like case construct described case arms given rule file instead loaded dynamically file run time case arms available compiler construct less efficient 23 void although crl defined way everything terminates failures small complication handle functions sometimes given attributes fail concept exception called void typical expression could give rise void nextleg x supposed give value x attribute next leg relative leg computed within rtd final leg rtd exist gives value void void occurs expression propageted result void propagates caught special language construct 3 program transformations transformations done program really fall three categories first transformations performed given program transformations like constant propagation constant folding second transformations made given static data prob lem static called parameters parameter like global rule constant given compile time instead run time external tables also considered static data third category transformations performed legs known 31 constant propagation folding typical rule set contains many definitions merely constants constants course substituted code constant folding applied step much work one might imagine first constant folding handle built functions also includes matching case expressions one keys turns constant means column case expression removed together rows match key 311 external tables external tables turned internal tables partial evaluator internal tables efficient semantics external tables unfortunately somewhat different internal tables internal table overlap allowed entries unless explicitly stated however external tables entries matched top bottom means external table converted internal one cannot used overlap annotation could inserted entry resulting table much efficiency would lost since rule compiler handles nonoverlapping entries much efficiently legdebriefing deadhead cloning legdebriefing deadhead debriefingdh else debriefingndh legdebriefingdh legdebriefingndh deadhead cloning figure 5 simple example therefore external table needs transformed remove overlaps converted internal table processing complicated fact column table range well literal fact table n columns table entry thought defining ndimensional box ie rectangular parallelopiped defines matches ndimensional space defined columns insight transformation external tables new table entry processed topdown box computed boxes preceding entries subtracted result subtracting one box another always expressed sum boxes subtracting preceding boxes left possibly empty set boxes correspond nonoverlapping entries righthandside boxes converted entries added internal table 32 cloning one features partial evaluation generates different specialisation function distinct argument crl functions kind function specialisation carry directly crl partial evaluator also specialisation ad hoc deadhead flights really part normal flight want plan since used transport means many attributes computed different way deadhead legs compared ordinary legs furthermore leg set contains much precise information dead heads considered reason even problem hand plan particular aircraft fleet deadheads may happen completely different fleets even different airlines handle deadheads good way treated specially transformation definition leg level split two part one assumed deadhead true one assumed deadhead false see figure 5 example definition original attribute debriefing inlined everywhere occurs two new definitions optimized assumtion deadhead true resp false inlined expressions often reduce one branches value deadhead known local context 33 set based evaluation given planning situation set legs arranged rtds crrs means actually lot information values externally supplied leg attributes leg attributes take values leg attributes appear flight plan really valuable information considering many attributes take one two different values reason flight plan normally covers week two time limited geographical area aircraft types practical consequence expression like aircraft type else simplified flight plan contains aircrafts transformations quite frequent rule set typically covers airlines operation information sort haul long haul cockpit cabin personnel times year etc given flight plan use subset rules eg short haul cabin personnel one week august set based transformations based set evaluator set evaluator like ordinary evaluator expressions language except environment contains sets values variables instead single values result evaluation set fragment set evaluator shown figure 6 sets computed set evaluator always large larger real set values expression interesting part set evaluator handling naive way would take union sets two branches slightly sophisticated check condition singleton true false pick corresponding branch singleton otherwise take union however case actually additional information within branches condition known hold hold means evaluating x5 e1 else e2 within branch x known 5 within else branch known 5 use facts account change environment evaluation branches environment modification function looks relational operations variables modify environment imagine much much sophisticated analysis keeps track condition literal literal literal f f f literal f literal f l true figure set based evaluator uses premise theorem prover within branch currently implement since looks like would little practical impact set evaluator figure 6 handle void void could seen ordinary value set course take part arithmetic operations void also needs handled specially since even need use worst possible approximation like sum ie universal set still want know void part using set evaluator tool possible transform program subexpression set evaluator invoked yields singleton value value replaces subexpression yield single value parts subexpressions examined transformed way pass whole program constant propagation constant folding rerun take advantage new constants might seem like lot work repeatedly run set evaluator like form caching could used practice shows essential 331 implementation value sets operations value sets must support usual set operations union membership test etc used set based evaluation handling different language constructs handle arithmetic different operations needed eg possible values expression xy set fx g operations sets must include crossproduct like arithmetic operations cardinality sets values obtained input data could worst case large number legs flight plan number range hundered 10000 cardinality usually much lower normally less 15 unfortunately arithmetic operations sets cause cardinality resulting sets explode arithmetic operations size set could easily exceed memory computer able handle large sets efficiently need approximated approximation used switch exact set representation interval representation interval retains smallest largest elements original set arithmetic sets becomes ordinary interval arithmetic implementation fact switch four representations singleton set exact list elements interval universal set first present improve space time efficiency representations also keeps track set contains void 34 ad hoc transformation rules studying output partial evaluator easily find number expressions simplified transformations needed cannot done constant folding set based evaluation since deal actual values transformations interest symbolic nature needed transformations range trivial eg 0 x replaced 0 trivial eg countlevel wherep 0 replaced anylevel p many transformation rules side conditions relate void eg x 0 replaced 0 x cannot value void since crl hs lefttoright evaluation expression void x transformation side conditions checked using set evaluator examine possible values subexpressions figure 7 contains partial list transformations utilised derived adhoc studying output partial evaluator verified correct using semantics language set transformations could extended course handles many cases occur practice 35 transformations transformations also performed ffl simple eg literal variable definitions definitions used inlined definitions coalesced unused definitions removed ffl simple theorem proving used removed rules covered rules eg rule removed also rule rule implementation partial evaluator reads dump abstract syntax tree input program generates new rule set concrete syntax dump abstract syntax tree generated ordinary crl compiler output partial evaluator quite readable program one requirements comments even preserved way system used without partial evaluation follows steps true else e false else e e c true else false c c false else true c c else e c e else c else c 0 else e c else e c else ex c tx else ex x variable xif c else e c xt else xe x variable etrue efalse e e e e e e e e e e 1 e 2 e 1 e 2 e 1 e 2 e 1 e 2 alll e anyl e anyl e alll e figure 7 symbolic transformation rules ffl compile rule set using crl compiler crl compiler translates rule language c compiled standard c compiler user step looks like one operation ffl use compiled rule set solve different problems different problems may different parameters different external table different leg sets input compiled rule set dynamically linked runtime system run important system look exactly partial evaluator use steps looks user different internally ffl compilation rule set invoke crl compiler collect used modules together produce dump abstract tree ffl use compiled rule set following happens partial evaluator run dumped rule set current parameters external tables leg set input values would used runtime system partial evaluator used resulting rule set compiled crl compiler uses c compiler used runtime system partial evaluator consists 7000 lines haskell hud92 code early development hugs system jon96a jon96b used initial period hbc compiler aug93 used exclusively heap profiling rw93 time profiling used improve performance program 5 practical evaluation conclusions partial evaluator used rule sets written crl table 1 presented figures lufthansa problem lufthansa biggest rule set airlines seen table running time decreases half tested larger variety problems running time varies 30 65 original time 50 typical figure consider runs often takes several hours quite gain total time processing rule compilation c compilation rule set also decreased rule compiler generates pe pe rules 88 90 leg definitions 209 68 rtd definitions 391 106 crr definitions 192 22 total rule size 461 kbyte 176 kbyte c code generated 217 mbyte 099 mbyte time pe 3 min time c compilation running time table 1 summary partial evaluation results lufthansa rule set partially evaluated lufthansa express aircraft types flying within europe problem captain run time solving small subset weeks scheduling huge c program takes long compile 3 number definitions reduced unused definitions removed simple definitions inlined many many definitions becomes simple transformations reason number rules increased cloning leg level definitions handle deadheads without cloning number rules would also reduced running time partial evaluator problem remarkably long one considers example table input program almost five hundred kbytes external tables another hundred kbytes given attributes legs flight plan five hundred kbytes even running time transformed program decreased fair amount surprisingly always biggest gain speed made particularly difficult planning problem output partial evaluator human readable inspected expert plannerrule writer since rule set decreased much size able grasp rules meant make manual adjustments adjustments made program run order magnitude faster changes could course made original program studying comprehending would daunting task partial evaluator part carmen system delivered several customers use daily work 3 actually broken smaller pieces since c compiler cannot compile files several megabytes 6 acknowledgements would like thank people carmen systems especially tommy bohlin answered naive questions airline scheduling problems would also like thank jessica twitchell proof reading improving english paper r recent advances crewpairing optimization american airlines crew pairing optimization hbc users manual carmen rule language report programming language haskell nonstrict hugs 13 user manual hugs distribution heap profiling lazy functional programs algorith large scale 01 integer programming application airline crew scheduling tr report programming language haskell ctr luke hornof trevor jim certifying compilation runtime code generation higherorder symbolic computation v12 n4 p337375 december 1999
transparent replication fault tolerance distributed ada 95 paper present foundations rapids replicated ada partitions distributed systems implementation pcs supporting transparent replication partitions distributed ada 95 using semiactive replication inherently nondeterministic executions multitasked partitions modeled piecewise deterministic histories discuss validity correctness model computation show used efficient semiactive replication rapids prototype ensures replicas partition go history hence consistent b introduction virtual nodes ie partitions ada 95 distributed application rendered faulttolerant replication failure replica replicated partition masked thanks remaining replicas ensure partition remains available spite failure despite adas strong position development dependable systems ada 95 language standard addresses issue replication distributed systems implementation permission clause implementation may allow separate copies partition configured different processing nodes provide appropriate interactions copies present consistent state partition active partitions statement standard argues favor transparent solution replication distributed application configured programmed com piled follows intent replication offered way transparent replicas replicated partition replica transparency note although distribution quite transparent ada 95 imply replication shouldnt either quoted paragraph also clearly addresses issue replication transparency stating replicated partition present consistent state active partitions take mean behavior indistinguishable singleton parti tion replication therefore also seen transparent towards active partitions system paper present results work replication fault tolerance distributed ada 95 wol98 replication ada 95 complicated inherent nondeterminism partitions simple state machine approach sch90 applicable assume following system model distributed ada 95 application executes asynchronous distributed system timing assumptions synchronized clocks distributed system may heterogeneous partitions share memory ie passive partitions system active partitions communicate remote procedure calls reliable channels network partitions subject crash failures partitions multitasked incoming rpcs handled concurrently separate tasks viewsynchronous group communication system provides consistent membership information various reliable multicast primitives replicas organized group goal replication render partition faulttolerant crash failures way ideally preserves replica replication transparency application rest paper structured follows briefly review various causes nondeterminism ada 95 section 2 section 3 presents piecewise computation model abstracts vagaries nondeterministic executions section 4 give brief consideration active passive replication schemes describing detail semiactive replication section 5 section 6 gives brief overview rapids implementation replication manager gnat system using semiactive replication 2 nondeterminism ada 95 deterministic partition replicated active replication using state machine approach sch90 used replica consistency ensured fulfilling following two conditions atomicity one replica handles request r replicas order replicas handle requests order insufficient replicas nondeterministic multitasked partition instance task scheduling may well violate order imposed requests leading different state evolutions replicas instead sequence state accesses must ordered identically replicas several causes nondeterminism ada 95 besides behavior tasking system eg choices made selective accept statements explicit timing dependencies delay statements obvious sources nondeterminism implicit timing dependencies also may cause nondeterministic behavior eg use preemptive timesliced task scheduler simply different message delivery times even order preserved originating network delays coordinated time distributed ada 95 application dependencies time make use deterministic task scheduler ie one always makes decisions corresponding task dispatching points given set tasks impractical guaranteeing replica determinism even explicit time dependencies delays forbidden eg pragma restrictions implicit timing differences may cause replicas diverge overcome difficulties refined model concurrent executions ada 95 needed piecewise deterministic computation model sy85 eln93 views execution sequence deterministic state intervals separated nondeterministically occurring events model applied ada 95 well signaling model language iso95 910310 guarantees accesses objects shared two tasks actually happen sequential order result shared objects must protected using appropriate applicationlevel synchronization protected objects rendezvous 1 partition considered erroneous contains two tasks access unprotected object without signaling execution piecewise deterministic computation model characterized events occur distinguish two different classes events internal events account nondeterminism language model cover task dispatching points signaling actions events related abort deferral choice made selective accept statement outcome conditional timed entry calls entering leaving protected actions locking unlocking protected objects queueing requeueing entry calls task creations abortions terminations abortions atc initialization finalization assignment controlled objects external events basically account nondeterminism network delivery rpc request another partition sending rpc request partition sending rpc result back calling partition delivery rpc result partition additional internal events concerning local calls subprograms whose results depend upon state outside application eg system calls like calling adacalendarclock piecewise deterministic computation model replicas synchronized making sure follow execution history ie go sequence events signaling actions task dispatching points subsumed list events two concurrent state accesses must separated signaling action ensure sets tasks states replicas consistent abortions abortdeferred regions included otherwise abortions atc might basically cause replicas diverge abortions didnt happen precisely logical moment replicas consider example fig 1 assignment variable x aborted x may abnormal iso95 9821 hence subsequent use 1 special cases though task could eg write value unprotected variable create another task read however task creations also signaling actions erroneous iso95 1391 even true centralized applications even asynchronous aborts may cause problems application make sure state accessed asynchronous select statement remains consistent face abortions critical sections abortable parts sense making state modifications may influence execution application must therefore encapsulated within abortdeferred regions language defines several constructs defer abortion iso95 98611 particular protected actions also initialization finalization assignment controlled objects cannot aborted abortion delayed abortdeferred region com pleted entering leaving abortdeferred regions subsumed list events coordinating replicas ensuring follow sequence events sufficient guarantee consistency semantics ada 95 preserved abortions occur two abortdeferred regions replicas 4 active passive replication active replication attractive offers high availability replicated partition replicas execute parallel failures incur additional overhead seems one could use active replication piecewise deterministic computation model reaching consensus bmd93 events fact several systems employ method see eg however specialpurpose reliable hard realtime systems general systems synchronous systems use severely constrained tasking models intertask communication strongly reduced task scheduling restricted even performed offline prior runtime static scheduling eg mars conse quence relatively events thus needs interactive agreement limited still sift reports overhead 80 replica synchronization pra96 p 272 admittedly assuming byzantine failures maft achieves better performance delegating consensus protocols dedicated hardware nevertheless approach seems feasible general systems one assumes deterministic task scheduling implies disallowing use explicit time dependency delay statements calls package adacalendar adarealtime assump tion progress measured task dispatching points passed consensus must reached task dispatching point message delivered 2 message deliveries sole remaining source non determinism advanced task dispatching point must taken common consensus value 3 replicas lag behind continue executing task dispatching point reached deliver message way deliver messages task dispatching point hence sets tasks continue evolve identically replicas overhead additional consensus message delivery may significant seems still tolerable however method violates replica transparency forbidding use delay statements severe restriction certainly transparent delays allowed replicas must reach consensus every event message deliveries timed entry call instance replicas must agree whether entry call timed timeout occurred respect task scheduling decisions taken delay sufficient agree first condition whether timeout occurred thus forced track synchronize task scheduling decisions timeouts words active replicas supporting full tasking model ada 95 communicate network run consensus protocol every task scheduling decision seems impractical would tremendously slow replicated partition fact one loses main advantage active replication high availability passive replication hand suffer communication overhead primary replica executes request interactive agreement protocol needed however case failure theres higher latency one backups taken passive replication either requires checkpointing coordinated output 4 remote calls must semantics nested transactions latter approach 2 besides earlier consensus needed totally ordered multicast necessary ensure ordering condition given section 2 3 although replicas make scheduling decisions execute lockstep one replica may already advanced another task body begin select triggerevent abort loop exit something x use x erro neous increment must encapsulated abortdeferred region aborted fig 1 abortions atc wol97 cannot implemented transparently applicationdefined scheduling partial operations ie entry calls may conflict constraints imposed scheduling serializability correctness criterion transactions conflicts may result deadlocks cannot resolved transparent manner transactional nature remote calls would exposed application wol98 transactions offered ada 95 must therefore integrated language level 5 5 semiactive replication since active passive replication deficiencies used replication nondeterministic partitions ada 95 focussed semiactive replication piecewise deterministic computation model lends readily form replica organization pioneered delta4 project pow91 replicas organized viewsynchronous group ss93 replicas execute incoming rpc requests one replica designated leader responsible taking nondeterministic decisions replicas followers forced make choices replica synchronization thus achieved logging events leader leader synchronizes followers using fifoordered reliable multicast ht94 followers replay events occurred leader result replicas go sequence deterministic state intervals ensures replica consistency events instead message deliveries ordered synchronized semiactive replication less stringent requirements group communication layer active replication partitions may use relatively simple reliable multicast communication group replicas instead expensive totally ordered multicast fifo multicast needed synchronization within group built easily upon basic primitive reliable multicast nevertheless synchronizing followers every event would probably impractical since internal events bound occur frequently would entail prohibitively high performance overhead task scheduling decision would involve communication network reaching agreement fortu 4 checkpointing multitasked partition trivial complete tasking state program counters stacks etc must included checkpointing also limited replicas running homogeneous physical nodes 5 case transactional rpcs would constitute inversion abstractions opinion transactions built upon rpcs way round nately necessary synchronization needed observable events sending rpc result back client sending rpc request partition long effects state intervals remain purely local leader followers need informed events followers must brought date effects become visible rest system ie leader sends message beyond group repli cas leader must update followers order guarantee reach state otherwise failure might corrupt overall consistency distributed application one followers becomes new leader observable events leader logs events buffering event log execute observable event multicasts log follow ers may proceed perform observable event log records extended state interval may contain many simple state intervals rather events delimiting observable event starts new extended state interval follower recreates extended state intervals replaying events logs receives replayed events received logs waits next extended state interval arrives leader becomes leader due failure former leader follower reexecute observable event beginning extended state interval would result duplicate message sent uses logged outcome events execution leader replay event leader thus replica interacts rest system beyond group replicas extended state intervals generally started observable events leader free synchronize followers tightly may necessary event log buffer leader threatens overflow case leader send logs current contents followers order make room new events given reasonably sized event buffer synchronization interval still kept large enough obtain acceptable performance scheme followers participate interaction beyond group failures followers completely transparent replica organization upon failure leader however one followers must take role new leader first replays pending events already received failed leader bring date last known state latter simply continues executing henceforth logging events synchronizing remaining followers fig 2 shows failure leader l replicated par tition started executing request req made nested remote call req b partition waited result continued processing req failing sent events extended state interval 1 followers recreate extended state interval replaying logged events l finally fails view change occurs follower f 1 chosen new leader continues executing 1 note extended state interval 3 may well different 2 since 2 could possibly affected part system except l overall state system remains consistent failure view change occurred reply rep b nested remote call arrived new leader f 1 would way tell whether former leader l still send req b failure point p indistinguishable one point r conse quently new leader f 1 choice reexecute observable event req b l failed point r later results duplicate request analogous situation arises f 1 finally sends reply rep back client fails synchronization 3 4 synchronized new leader f 2 know whether rep sent implies partitions must able deal duplicate messages 6 messages must tagged unique systemwide identifier repeated rpc result messages simply ignored repeated invocations difficult handle partition handles first rpc request message receives later messages message identifier ignored arrive rpc still progress return result first invocation rpc already completed latter case necessitates results remote subprogram calls retained therefore kind garbage collection retained results must provided see section 6 semiactive replication based piecewise deterministic computation model offer transparent replication nondeterministic ada 95 partitions replication transparency ie transparency towards partitions given application level although partitions must able handle duplicate messages correctly system level yet application level remains unaffected replica transparency ie transparency towards application level replicated partition also main tained piecewise deterministic computation model supports full tasking model ada 95 however replica transparency heterogeneous systems given long failures considered thus holds kresiliency recovery included model replica transparency cannot fully maintained general case new follower join running group must get groups current state state transfer done transparently homogeneous system taking systemlevel checkpoint one old group members installing checkpoint newly joining replica replicas execute heterogeneous physical nodes state transfer possible restricted subset possible partitions furthermore requires cooperation application wol98 case replica transparency cannot upheld totally 6 rapids rapids replicated ada partitions distributed sys tems wol98 implementation semiactive replication scheme based piecewise deterministic computation model presented gnat com piler implemented within runtime support thus largely transparent application core rapids event log buffer implemented within pcs child package garlic kpt95 called systemgarlicrapids choice made synchronization leader 6 reliable multicast primitive assumed communication clients servers replicated partition ie group replicas already makes duplicate message detection necessary however one needs second duplicate message detection scheme higher level would beneficial highlevel duplicate message detection could exploit fact facility already exists hidden lowlevel protocols group communication layer rep sync sync view change client r fig 2 failure semiactive replication followers triggered observable events ie sending messages event occur within pcs actual synchronization involves multicasting message within group done conveniently new protocol added garlic new protocol interface thirdparty viewsynchronous group communication system currently rapids uses phoenix mfsw95 toolkit group communication system used long satisfies view synchrony offers reliable multicast primitive pcs also modified include unique message identifiers messages using duplicate message detection implemented garbage collection retained results also included garlic whenever partition sends message another partition b piggybacks information messages already received b partition b discard messages rapids actually offers three different interfaces logging replaying events transferring event log leader followers pcs uses direct calls first interface given systemgarlicrapids handle external events handle internal events tasking support gnarl modified use callback interface rapids logging replaying events task scheduling decisions packages runtime support also use callbacks rapids eg sys temfinalizationimplementation uses log replay events regarding entry exit abort deferred regions given initialization finalization controlled objects finally public interface event log systemrpcreplication shown fig use standard libraries also may log replay events eg adacalendarclock file accesses event log buffer organized heterogeneous fifo list storing event descriptors derived abstract tagged type event leader append events log using log subprogram multicast log followers using sendlog operation also empties log event also contains unique groupwide task identifier task involved follower replays events order logged get subprogram blocks calling task event matching tag actual parameter e taskss groupwide id frontmost log returns event valid set true leader get returns immediately valid set false remove opera tion follower actually remove frontmost event log replayed event makes next event log become new frontmost event thus call get may unblocked log follower empty ie wholly replayed get also blocks either next extended state interval received leader matching event appears front log follower becomes leader old leader failed case get returns even matching event appeared log exhausted cf section 5 valid set false former follower leader may make choices interface event logging replay implemented following pattern shown fig 4 package systemrpcreplication type event abstract tagged private procedure log procedure get procedure remove procedure private fig 3 public interface event log fig 4 pattern event logging replay systemrpcreplication package example package repl renames systemrpcreplication type event new replevent record characterizing data event eventexternaltag use exampleevent procedure theoperation theevent begin replget theevent isfollower isfollower use description theevent replay event remove else leader observable event send log followers observable event log event theevent replevent repllog theevent event replay follower atomic tasks also might call get events remain blocked event removed leader event logging must done right places dooperation cause additional nondeterministic events dooperation instead theoperation implemented using pattern also event must logged right moment consider example event locking protected object obviously task must first get lock log event logged event first task might actually get lock first event log would inconsistent actual execution history groupwide task identifiers implemented task creation events events contain groupwide id creating task newly created task follower replays event therefore also knows groupwide id must assign new task references time delay statements calls adacalendarclock generate events rapids implements mapping time values replicas always run logically initial leaders time base avoids time suddenly jumps backwards failure occurs thus guarantees monotonicity time application internal events logged rapids makes distinction system tasks local runtime support application tasks events involving application tasks logged replayed system tasks however execute independently repli cas runtime support must different things leader follower interface pcs tasks may change status application task calling eg systemrpcdorpc becomes system task inside call conversely system task becomes application task time executes remotely called subprogram rapids currently nov 1998 still prototype stage still needs serious optimization efforts doesnt yet handle dynamically bound remote calls remote accesstosubprogram remote accesstoclasswide values also events due assignments controlled objects yet handled seems require cooperation compilers part 7 conclusion modeling executions ada 95 partitions using piecewise deterministic computation model overcomes problems due nondeterminism occur replication model together abstractions language stan dard abstracts timing dependencies thus makes replication possible seems semiactive replication appropriate replication scheme general ada 95 partitions using full tasking model language prototype replication manager called rapids replicated ada partitions distributed systems developed guarantees replica consistency logging nondeterministic events leader replaying followers although project still early prototype stage first results encouraging indicating efficient replication attainable using model r delta4 extra performance architecture xpa consensus problem faulttolerant comput ing manetho fault tolerance distributed systems using rollback recovery process replication modular approach faulttolerant broadcasts related problems iso international standard isoiec 8652 realtime systems development programming model mars gar lic generic ada reusable library interpartition communication maft architecture distributed fault tolerance phoenix toolkit building fault tolerant distributed applications largescale networks implementing faulttolerant services using state machine approach understanding power virtuallysynchronous model optimistic recovery distributed systems sift design analysis faulttolerant computer aircraft control fault tolerance distributed ada 95 replication nondeterministic objects tr
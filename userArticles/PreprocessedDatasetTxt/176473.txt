executable interprocedural slices notion program slice originally introduced mark weiser useful program debugging automatic parallelization program integration software maintenance slice program taken respect program point p variable x slice consists statements program might affect value x point p interprocedural slice slice entire program slice crosses boundaries procedure calls weisers original interproceduralslicing algorithm produces imprecise slices executable programs recent algorithm developed horwitz reps binkley produces precise smaller slices accurately identifying statements might affect values x point p slices however executable extension algorithm produces precise executable interprocedural slices described together proof correctness new algorithm b introduction slice program respect program point p variable x consists statements predicates program might affect value x point p concept originally discussed mark weiser 17 used isolate individual computation threads within program slicing help programmer understand complicated code 17 aid debugging software maintenance 7 8 12 used automatic parallelization 2 16 horwitz reps binkley identify two different related slicing problems 9 important understand distinction names come 15 work supported part summer research grant loyola college authors address computer science department loyola college 4501 north charles street baltimore maryland 212102699 binkleycsloyolaedu version 1 closure slice slice program respect program point p variable x consists components eg statements predicates program might affect value x point p version 2 executable slice slice program respect program point p variable x consists reduced program computes sequence values x p point p behavior reduced program respect variable x indistinguishable original program intraprocedural slicingslicing within single procedure slice extend across procedure boundariesa solution version 1 provides solution version 2 since reduced pro gram required version 2 obtained restricting original program components found solution version 1 13 interprocedural slicinggenerating slice entire program slice extends across boundaries procedure callsrestricting original program components found version 1 may yield program syntactically incorrect thus certainly solution version 2 reason behind phenomenon multiple calls procedure possible program elements found algorithm version 1 include multiple calls procedure different subsets procedures parameters weisers original interprocedural slicing algorithm provides solution version 2 17 however algorithm potentially includes large portions program affect value x p fails account calling context procedure slice includes one callsite procedure slice includes callsites procedure b callsites treated indivisible com ponents slice includes one parameter must include parameters horwitz et al 9 compute interprocedural slice variables x point p using system dependence graph extends previous dependence representations incorporate collections procedures procedure calls rather monolithic programs algorithm hereafter referred hrb algorithm identifies subgraph system dependence graph whose components potentially affect sequence values x p hrb algorithm provides solution version 1 correctly accounts procedure calling context treats call statement divisible components thus produces slices precise smaller determined weisers algorithm 1 slices however executable algorithm discussed paper produces executable slices precise produces weiser term precise means algorithm correctly handles calling context may selectively choose parameters call statements precise mean produces smallest possible slice would require solving unsolvable dataflow problems consequence algorithm must make safe approximations although may include unnecessary statements include necessary statements 1 hrb algorithm restriction present weisers algorithm slice taken respect program point p variable x x defined used p executable slices useful required variety applications example software maintenance technique discussed 7 algorithm reducing cost regression testing presented 6 rely able execute slice executable slices also used provide coarse grain parallelism sequential programs running separate slices different processors finally producing executable programs permits execution behaviors program slices compared providing brief summary system dependence graph hrb slicing algorithm section 2 section 3 first illustrates slice produced hrb algorithm may correspond syntactically correct program describes steps necessary extend hrb algorithm produce precise executable interprocedural slices section 4 proves new algorithm produces slices satisfy version 2 finally section 5 provides brief summary 2 hrb algorithm 21 system dependence graph hrb slicing algorithm makes use system dependence graph 2 sdg 9 summarized section sdg models language following properties addition input output represents slight extension definition given 9 1 complete system consists single main procedure collection auxiliary procedures 2 parameters passed valueresult 3 3 input output modeled streams thus example statement print x treated assignment statement sdg system denoted g contains collection procedure dependence graphs pdgs one procedure system connected interprocedural control flowdependence edges procedure dependence graphs similar program dependence graphs 1 10 11 pdg procedure p denoted g p contains vertices represent components p edges represent dependences exception call statements single vertex represents assignment statements input statements output statements predicates conditional whileloop statements addition distinguished vertex called entry vertex initialdefinition vertex variable may used defined initialdefinitions vertices represent assignment value 0 variable may used defined call statement represented using call vertex four kinds parameter vertices represent parameter passing calling side parameter passing represented actualin actualout ver tices control dependent see call vertex called procedure parameter passing 2 term program dependence graph associated graphs represent single procedure programs term system dependence graph chosen dependence graphs represents multiprocedure programs 9 similarly term systemrather program used mean program multiple procedures 3 techniques handling parameter passing reference dealing aliasing discussed 9 represented formalin formalout vertices control dependent procedures entry vertex actualin formalin vertices included every parameter global variable may used modified result call formalout actualout vertices included every parameter global variable may modified result call interprocedural dataflow analysis used determine parameters globals may used andor modified result procedure call 3 4 procedure dependence graphs include three kinds intraprocedural edges control dependence edges data dependence edges summary edges source control dependence edge either entry vertex predicate vertex call vertex edge labeled either true false control dependence edge vertex v vertex u means execution whenever predicate represented v evaluated value matches label edge u program component represented u eventually executed provided system terminates normally 4 edges entry call vertices always labeled true vertices assumed always evaluate true data dependence edge vertex v vertex u means systems behavior might change relative order components represented v u reversed two kinds data dependence edges flow dependence edges deforder dependence edges flow dependence edge connects vertex v represents assignment variable x vertex u represents use x reached assignment deforder edge runs two vertices v u represent assignments variable x assignment reach common use v lexically precedes u ie v left u programs abstract syntax tree chief difficulty interprocedural slicing correctly accounting calling context called procedure address callingcontext problem system dependence graph includes summary edges edges represent transitive dependences due effects procedure calls summary edge connects actualin vertex v actualout vertex u path sdg v u respects calling context matching calls returns connecting procedure dependence graphs form sdg straightforward involving addition three kinds interprocedural edges 1 call edge connects call vertex corresponding procedureentry vertex 2 parameterin edge connects actualin vertex callsite corresponding formalin vertex called procedure 3 parameterout edge connects formalout vertex corresponding actualout vertex call site procedure insert figure 1 example figure 1 shows example system corresponding sdg 4 two ways system may fail terminate normally 1 system contains nonterminating loop 2 fault occurs division zero 22 hrb slicing algorithm interprocedural slicing defined reachability problem using sdg intraprocedural slicing defined reachability problem using program dependence graph 8 slices obtained using approach similar obtained using weisers interproceduralslicing method 17 however approach produce slices precise possible considers paths graph possible execution paths example path graph shown figure 1 vertex procedure main labeled sum vertex main labeled z however path corresponds procedure add called first call main returning second call main possible value first call main independent value sum call vertex labeled sum included slice respect vertex labeled z achieve precise interprocedural slices interprocedural slice sdg g respect set vertices v computed using two passes graph summary edges used algorithm permit moving across call site without descend called procedure thus need keep track calling context explicitly ensure legal execution paths traversed passes operate sdg traversing edges find set vertices reach given set vertices along certain kinds edges traversal pass 1 starts vertices v goes backwards target source along flow edges control edges call edges summary edges parameterin edges along deforder parameterout edges traversal pass 2 starts vertices reached pass 1 goes backwards along flow edges control edges summary edges parameterout edges along deforder call parameterin edges result interprocedural slice consists sets vertices encountered pass 1 pass 2 hrb algorithm finding vertices interprocedural slice stated figure 2 insert figure 2 example figure 1 shows hrb slice remainder paper use operators b1 b2 designate individual passes hrb slicing algorithm terminology figure 2 defined follows b1g v reachingverticesg v deforder parameterout b2g v reachingverticesg v deforder parameterin call 3 execu slices section describes extension hrb algorithm produces precise executable interprocedural slices presenting extension first consider example hrb slice execut able example discuss three steps necessary produce executable system hrb slice section concludes discussion new slicing algorithms complexity 31 nonexecutable slice intraprocedural slicing slice dependence graph used produce executable program restricting original system elements whose vertices slice dependence graph true hrb slice sdg example system produced restricting system shown figure 3 statements whose vertices slice also shown figure 3 syntactically illegal contains parameter mismatch two call statements representing calls procedure contain different subsets procedures parameters making system syntactically legal simply adding parameter c second call statement p leaves semantically unsatisfactory system aborts divisionbyzero error second call p although divisionbyzero error could caught exception handler important point system representing slice computes values computed original system example similar one figure 3 replaced divisionbyzero error infinite loop would prevent system represents slice computing values original system points beyond infinite loop presence infiniteloop cannot caught exception handler algorithmic means order produce executable slice components take part computation parameters c must also included slice insert figure 3 applied example shown figure 3 weisers interprocedural slicing algorithm produces executable slice treats call statements indivisible components however causes unwanted program components included example causes consequently computation included slice 32 executable slices closer inspection hrb slice figure 3 reveals two related mismatch problems 1 two callsites procedure may include different actualin vertices 2 two callsites procedure may include different actualout vertices example slice shown figure 3 contains actualin vertices parameters first callsite p one second callsite vertices labeled x b respectively slice also mismatched actualout vertices first callsite actualout vertex first parameter second callsite actualout vertex second parameter section describes three steps used produce executable slice hrb slice first step adds vertices remove actualin vertex mismatches second step adds vertices remove actualout vertices third step produces system resulting set vertices original system describing first step formalize notion mismatch following definition definition vertex mismatch subset v vertices sdg g contains actualin vertex mismatch contains callsite procedure formalin vertex parameter procedure actualin vertex corresponding formalin vertex callsite similarity v contains actualout vertex mismatch contains callsite procedure formalout vertex parameter procedure actualout vertex corresponding formalout vertex callsite note formal definition actualin vertex mismatch differs intuitive definition given formal definition implies intuitive definition hrb slice contains formalin vertex contains least one corresponding actualin vertex consequently actualin vertex also corresponds formalin vertex slice two callsites procedure include different actualin vertices true actualout vertices following discussion let v hrb set vertices hrb slice system first step algorithm removes actualin vertex mismatches v hrb actualin mismatch actualin vertex v v hrb illustrated c figure 3 simply adding v v hrb insufficient appropriate initial parameter value must computed actual parameter represented v order include program components necessary compute safe value parameters vertices slice b2g v added v hrb b2 slice include components procedure p procedures called p components procedures call p necessary components procedures already slice unless actualin mismatch process adding b2 slices repeated actualin vertex mismatches exist choice b2 slice operation would include call sites p eg b1 slice full slice avoids including unwanted callsites p b1 full slices include callsites pro cedure may include unwanted call sites contrast b2 slice includes none procedures callsites combined definition actualin vertex mismatch avoids including unwanted callsites second step making hrb slice executable removes actualout vertex mismatches missing actualout vertices represent deadcode additional slicing necessary actualout mismatches removed simply adding missing actualout vertices v hrb third step algorithm produces system set vertices v hrb system projecting statements represented v hrb words statements sliced system statements represented vertices v hrb statements appear order nesting level complete algorithm producing executable interprocedural slices stated figure 4 example figure 3 b2 slice taken respect actualin vertex x c includes statement c 2 computes necessary actual parameter value c insert figure 4 33 complexity complexity algorithm executableslice presented figure 4 given terms size input system complexity hrb algorithm used line 1 executableslice analyzed 9 two parts polynomial complexity constructing sdg linear complexity slicing g construction cost tcs cs 2 np v 2 tcs total number callsites system cs maximum number call sites one procedure np number procedures system v maximum number vertices statements predicates one procedure assumes number parameters associated procedure bounded constant complexity slicing g linear size sdg size sdg conservatively bounded np v 2 since one pdg complexity extension also linear complexity b2 slices result lines 23 linear size sdg vertex currently slice need considered complexity adding vertices line 5 complexity projecting final system slice line 6 also linear assumes pointer vertex sdg originating line source text summary overall complexity constructing sdg polynomial size system complexity producing executable interprocedural slice sdg linear size sdg 4 proof correctness definitions definition verticesofslice system vertex set v verticesofslice v refers vertices v line 6 figure 4 definition induced graph g system set vertices v inducedgraphg v graph v e e set edges g whose endpoints v deforder edge three points involved must v definition rollout rollout system produced exhaustive inline expansion call statements produce program without procedure calls expansion step replaces call statement new scope statement scope statement creates separate name space avoid variable naming conflicts contains body called procedure parameterized two lists assignment statements transferin statements transferout statements make explicit transfer values outof name space scope one transferin statement every parameter global variable represented actualin vertex one transferout statement every parameter global variable represented actualout vertex presence recursion rollout leads infinite program meaning infinite program defined least upper bound meanings finite programs approximate use notation rollouts denote program produced repeatedly expanding call statements procedure main system previous results 1 theorem syntactic correctness theorem intraprocedural slices 14 q slice singleprocedure program p taken respect vertex set v g q isomorphic 5 inducedgraph g p verticesofslice p v 5 two system dependence graphs g 1 g 2 isomorphic iff following conditions satisfied 1 1to1 mapping g vertex set g 1 onto vertex set g 2 every v g 1 v g v text 2 1to1 mapping h edge set g 1 onto edge set g 2 every edge e type eg control edges label 3 every edge v u g 1 h v g 1 g 2 isomorphic trying prove g 1 g 2 isomorphic brevity say v g v vertex e h e edge 2 theorem slicing theorem single procedure programs 14 singleprocedure program including induced edges g p program points q q p produce sequence values evaluated input evaluation p terminates corollary theorem applies slices infinite program rolloutp proof technique discussed chapter 8 5 demonstrates theorem applies series finite approximations rolloutp meaning infinite program defined least upper bound meanings finite approximations theorem extend infinite programs produced rollout 3 theorem rollout theorem 5 rollout semanticspreserving transformation sequences values produced occurrences rollouts sequences values produced calling contexts new results lemma induced graph isomorphism lemma let slice executableslice v g slice isomorphic inducedgraph g verticesofslice v proof trivial transformation procedure call statements procedure sequences assignment statements dataflow effect hence flow dependence edges transformation preserve semantics procedure dependence edges associated calls including assignment statements tmp actual parameter used called procedure syntactic correctness theorem intraprocedural slices implies exists isomorphism f transformed versions slice isomorphism untransformed versions slice isomorphism composition f 1 lemma slicing lemma slice executableslice v g rolloutslice slice including induced edges g rollouts proof sufficient prove 1 g rolloutslice subgraph g rollouts 2 every vertex x vertexsetg rolloutslice every nondeforder edge e edge set graph g rollouts edge e exists edge set graph g rolloutslice point 2 ensures slice g rollouts never escapes vertices g rolloutslice part 1 follows induced graph isomorphism lemma implies g slice isomorphic subgraph g thus subgraph g relationship extends g rolloutslice g rollouts vertex edge occurrence g rolloutslice exists vertex edge g slice sequence callsites expanded since vertex edge sequence call sites g vertex edge occurrence g rollouts edges g slice respectively g occurrences g rolloutslice call statement expansion produces copy procedure control data dependences exists original procedure prove 2 assume x e occurrences x e respectively vertex x g slice vertex edge e g proof two cases represent transferin statement induced graph isomorphism lemma implies x verticesofslice v represent transferin statement e intraprocedural edge g thus b2 slice g includes x verticesofslice v also includes slice taken line 1 3 figure 4 x verticesofslice v e inducedgraph g verticesofslice v implies induced graph isomorphism lemma e g slice finally expanding callsites slice whose expansion leads creation x produces occurrence edge connecting e g rolloutslice b represents transferin statement represents transferin vertex x represents statement called procedure represents actual parameter call procedure unlike previous case b2 slice x include b2 slice traverse parameterin call edges however removal actualin vertex mismatches lines 23 figure 4 ensures verticesofslice v remainder proof identical proof case theorem slicing theorem let slice executableslice v program component v slice produce sequence values evaluated input terminates proof first since g rolloutslice slice g rollouts corollary slicing theorem single procedure programs implies component rolloutslice rolloutslice rollouts compute sequence values rolloutslice terminates rollouts terminates rollout semantics preserving transformation sequences computed slice slice terminates terminates must show component c v calling contexts c slice calling contexts encountered order execution slice first b1s c first pass hrb slice traverses call edges therefore slice includes calling contexts c second since statements slice occur relative order calling contexts common slice encountered order execution slice 5 paper presented first algorithm interprocedural slicing correctly accounts calling context produces executable programs algorithm extension hrb interprocedural slic ing fillsin parameter mismatches left hrb algorithm paper also proves slices capture subcomputation original program acknowledgement comments art delcher three reviewers editor led substantial improvements exposition paper suggestions james lyle keith gallagher improved examples r overview ptran analysis system multiprocessing minimizing communication synchronizing parallel dataflow pro grams efficient way find side effects procedure calls aliases vari ables practical interprocedural data flow analysis algorithm multiprocedure program integration using semantic differencing reduce cost regression testing using program slicing software maintenance integrating noninterfering versions programs interprocedural slicing using dependence graphs number operations simultaneously executable fortranlike programs resulting speedup dependence graphs compiler optimizations experiments slicingbased debugging tools semantics program slicing semantics program slicing program integration semantic approach program slicing reconstructing sequential behavior parallel behavior projections program slicing tr experiments slicingbased debugging aids integrating noninterfering versions programs interprocedural slicing using dependence graphs semantic approach program slicing using program slicing software maintenance multiprocedure program integration practical interprocedural data flow analysis algorithm dependence graphs compiler optimizations efficient way find side effects procedure calls aliases variables semantics program slicing program integration ctr david binkley computing amorphous program slices using dependence graphs proceedings 1999 acm symposium applied computing p519525 february 28march 02 1999 san antonio texas united states david binkley semantics guided regression test cost reduction ieee transactions software engineering v23 n8 p498516 august 1997 dave binkley sebastian danicic tibor gyimthy mark harman kos kiss bogdan korel theoretical foundations dynamic program slicing theoretical computer science v360 n1 p2341 21 august 2006 susan horwitz thomas reps david binkley interprocedural slicing using dependence graphs acm sigplan notices v39 n4 april 2004 mark harman david binkley sebastian danicic amorphous program slicing journal systems software v68 n1 p4564 15 october anthony sloane jason holdsworth beyond traditional program slicing acm sigsoft software engineering notes v21 n3 p180186 may 1996 dave binkley sebastian danicic tibor gyimthy mark harman kos kiss bogdan korel formalisation relationship forms program slicing science computer programming v62 n3 p228252 15 october 2006 baowen xu ju qian xiaofang zhang zhongqiang wu lin chen brief survey program slicing acm sigsoft software engineering notes v30 n2 march 2005
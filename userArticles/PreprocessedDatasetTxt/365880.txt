exact analysis exact change introduce kpayment problem given total budget n units problem represent budget set coins k exact payments total value n made using k disjoint subsets coins goal minimize number coins given n k allowing actual payments made online namely without need know payment requests advance problem motivated electronic cash model coin long bit sequence typical electronic wallets limited storage capacity kpayment problem additional applications resourcesharing scenariosour results include complete characterization kpayment problem follows first prove necessary sufficient condition given set coins solve problem using characterization prove number coins solution kpayment problem least k hnk hn denotes nth element harmonic series condition also used efficiently determine k maximal number exact payments given set coins allows worst case secondly give algorithm produces n k solution minimal number coins case denominations available algorithm finds coin allocation k1hnk1 coins upper lower bounds best possible finally show generalize algorithm case denominations available b introduction consider following everyday scenario want withdraw n units money bank teller asks would like let us assume need exact change ie given payment request p n able choose subset coins whose sum precisely p let us assume would like withdraw n units least possible number coins case answer depends estimate many payments going make worst case may making n payments 1 unit forcing take n coins denomination 1 extreme may need make single payment p case even dont know p advance log coins sometimes sufficient explain later article provide complete analysis general question call kpayment problem smallest set coins enables one satisfy k exact payment requests total value n motivation payment system physical electronic transactions require payments exact amounts forcing shops provide change customer possess exact change simply shifts problem customers shops number coins particularly important electronic cash see eg 2 3 electronic coins inherently long bit sequences handling computationally intensive typical smartcard used store small memory space computational power 7 another interesting application problem arises context resource sharing concreteness consider communication link whose total bandwidth n link shared timemultiplexing fixed schedule assigns timeslots say cells atm lines different connections typical schedules small time slots since assigning big slots small requests entails underutilization important note however inherent fixed overhead associated time slot eg header atm cell would therefore desirable multiplexing schedule time slots various sizes accommodate set requests least number slots similarly withdrawal scenario improvement upon trivial n unitslot solution achieved know many connections might running parallel know bound k number restrict longlived connections problem designing schedule naturally reduces kpayment problem kpayment problem definition formally problem follows two parameters budget denoted n number payments denoted k problem find 1 number icoins also called coins denomination denoted c following two requirements satisfied budget compliance kpartition sequence k payment requests denoted n exists way exactly satisfy payments using coins exist nonnegative integers represents number icoins used jth payment problem thus broken two parts follows coin allocation problem partition n coins given n k ie determining c coin dispensing problem given c actually make payment possible variants kpayment problem first many systems denominations available example know system 3coins even electronic cash realm denominations may expensive resource denomination requires distinct pair secretpublic keys central authority see eg 1 8 thus interesting variant allocation problem restricted denominations version set possible solutions restricted c given allowed denomination set also one may consider online coin dispensing problem algorithm required dispense coins payment request without knowledge future requests offline version value k payments assumed known first coin dispensed results turns coin dispensing problem easy greedy strategy works even online setting results concern coin allocation problem sometimes refer part problem kpayment problem basic result simple necessary sufficient condition sequence c 1 coins solve allocation problem theorem 31 using characterization prove theorem 36 lower bound khnk k lnnk number coins solution n k h n denotes nth element harmonic series lower bound best possible sense met equality infinitely many n ks theorem 38 characterization used efficiently determine maximal number k given collection coins solves k payment problem corollary 39 next major result efficient algorithm finds solution n k using least possible number coins first deal case denominations allowed theorem 41 case number coins never theorem 47 similarly lower bound upper bound best possible general theorem 48 finally using ideas slightly refined way extend algorithm general case restricted denomination set theorem 51 related work best knowledge current work first formulate general kpayment problem hence first analyze one related classic combinatorial problem kpartition question many ways natural number n represented sum k positive integers problem less structured kpayment problem used derive lower bounds however bounds suboptimal see section 2 postagestamp problem also closely related cast terms postage stamp problem find set denominations allow pay request value using h coins n maximized postagestamp problem viewed inverse 1payment problem one payment make number coins given goal find denomination set given size maximize budget remark postagestamp problem considered difficult problem even small number denominations see eg 10 11 4 another related question change making 6 problem represent given budget least number coins given allowed denomination set general changemaking weakly nphard kozen zaks 5 verma xu 14 study question denominations sets allow one use greedy strategy optimal change making organization section 2 introduce notation give preliminary observations briefly discuss suboptimal results section 3 prove characterization k payment problem lower bound number coins solution section 4 present analyze optimal algorithm unrestricted denomination case section 5 extend algorithm case restricted denominations finally section 6 give short overview applications results electronic cash notation simple results section develop intuition kpayment problem presenting simple upper lower bounds number coins required notation shall use throughout article summarized figure 1 solution c clear context remainder article fix n k arbitrary given positive integers note may assume without loss generality k n since payment requests value 0 ignored let us rough analysis kpayment problem already mentioned case trivial solve take c better solution possible since c 1 k would satisfy k payments value 1 case quite simple least integer 1 solve coins denominations given request p satisfy using coins correspond ones binary representation p however immediately clear one generalize solution arbitrary n k consider arbitrary n usual technique rounding next power 2 parameters problem specification total budget ffl k number payments ffl set allowed denominations unrestricted case quantities related solution specification number coins denomination aka icoins convention budget allocated using coins denomination less formally ffl largest denomination coin formally always quantities related making payment refer respective quantities payment made standard quantities convention h figure 1 glossary notation seem appropriate kpayment problem ask teller bank round amount withdraw convenient us let us ignore point moment consider problem general k allowed make dubious assumption may enlarge n one simple solution would duplicate solution 1payment k times let payment use dedicated set coins specifically means allocate k 1coins k 2coins k 4coins k 2 dlog 2 coins result approximately k log 2 n coins guarantee based simplistic construction pay k payments know payments must value n however total budget allocated solution fact kn thus seem solve kpayment problem stated limit value payments placed sum rather individual values aside remark one corollary work specifically theorem 31 coin dispensing done using greedy strategy see binary construction coin allocation indeed solves general kpayment problem precisely highest possible denomination use many icoins possible 4 dispense j icoins figure 2 greedy algorithm coin dispensing p amount paid assume power 2 coin allocation algorithm allocates k coins denomination clearly number coins k log 2 sum n coin dispensing made greedily point largest possible coin used description greedy dispensing algorithm presented figure 2 however one note perhaps surprisingly results also indicate binary algorithm right generalization 1 best algorithm described section yields factor improvement ie roughly 30 fewer coins let us reconsider question general n algorithm infinitely many values k n generalizing arbitrary n k easy find solution n 0 dispense payment value remaining set coins coin allocation total budget n used k additional payments since original set solved 1payment problem close section simple lower bound number coins required solution kpayment problem bound based counting argument sketch number distinct possible payment requests allowed observe algorithm must dispense different set coins response request follows number coins solution must least log 2 n 1 argument extended general k using observation number distinct responses algorithm disregarding order least p k n number ways represent n sum k positive integers using standard bounds partitions see eg 13 since number responses exponential number coins one conclude number coins omegagamma k lognk 2 3 problem characterization section first prove simple condition necessary sufficient set coins correctly solve kpayment problem using result obtain sharp lower bound number coins solution kpayment problem finally outline efficient algorithm given set coins determines maximal k solution kpayment problem please refer figure 1 notation 31 necessary sufficient condition theorem 31 solves kpayment problem ki theorem proven series lemmas necessity proof hard intuition hardest cases payment requests equal interesting part sufficiency proof start upper bounding largest denomination solution lemma 32 solves kpayment problem dnke proof contradiction suppose dnke consider k payments values bnkc dnke total sum n clearly none payments use mcoins since c 1 definition total budget available payments n gamma contradiction following lemma slightly stronger condition theorem 31 use version proof theorem 36 lemma 33 solves kpayment problem ki proof let bnkc ki n consider k payments value payment done coins denomination hence ki turn sufficiency start showing condition theorem 31 holds single payment value n satisfied greedy algorithm lemma 34 let p payment request suppose j 1 2 p satisfied greedy algorithm using coins denomination j less proof prove induction j claim holds j p base case hence least p 1coins used pay amount total sum inductive step assume claim holds j p consider j 1 let number j 1coins dispensed greedy algorithm namely let r denote remainder payment algorithm dispenses j 1 note 2 trivially holds dispensing j 1coins need show 1 holds well consider two cases c j1 using 1 get done case c j1 since algorithm greedy must case r 1 hand 2 j j hence j r done case following lemma key invariant preserved greedy algorithm interesting note algorithm proceeds larger coins smaller ones inductive proof goes opposite direction recall primed quantities refer value payment done lemma 35 ki holds greedy algorithm dispenses amount tm 0 holds proof induction claim trivial assume claim holds amount dispensed using coins denomination namely j smallest remaining denomination larger note j well defined since namely largest remaining coin next note since coins denomination whose sum used algorithm observe since algorithm greedy since least one jcoin used algorithm must case total amount dispensed using coins denomination smaller j less j ie using eq 1 get finally using assumption applied complete proof characterization proof theorem 31 necessity condition follows directly lemmas 32 33 sufficiency assume ik consider sequence k requests total value n lth request served greedy algorithm inductive application lemma 35 0 moreover lemma 34 amount total remainder paid long completes proof 32 lower bound number coins using theorem 31 derive lower bound number coins solution kpayment problem theorem 36 number coins solution kpayment problem least first prove little lemma use theorem 47 lemma 37 number j proof proof theorem 36 lemma 37 lemma 33 bnkc ki lower bound theorem 36 best possible general shown following theorem theorem 38 natural numbers infinitely many n exists solution kpayment problem budget n exactly kh bnkc coins proof choose natural number km case solution solves kpayment problem theorem 31 total number coins precisely kh bnkc 33 determining k given set consider inverse problem given set coins c coins denomination question many payments make using coins ie find k note k well defined say k 0 payment request cannot satisfied set k never total budget theorem 31 directly applied answer question efficiently implied following simple corollary corollary 39 let given coin allocation solves kpayment problem k min fbt ic mg 4 optimal algorithm unrestricted denominations present coin allocation algorithm finds minimal solution kpayment arbitrary n k assuming denominations available first prove optimality algorithm give upper bound number coins allocates section 5 generalize algorithm handle restricted set denominations algorithm given arbitrary integers n k 0 algorithm presented figure 3 finds optimal coin allocation intuitively algorithm works scanning possible denominations least number icoins suffices make ki number coins c thus approximation ith harmonic element multiplied k budget exhausted remainder added simply single addiotinal coin 41 optimality allocate theorem 41 let denote solution produced allocate solves kpayment problem using least possible number coins allocaten 4 denominations order add icoins dont overflow 9 n add remainder figure 3 algorithm optimal solution kpayment problem unrestricted denominations proof follows lemma 43 lemma 45 important properties algorithm stated following loop invariant lemma 42 whenever allocate executes line 4 following assertions hold ii proof line 4 reached executing lines 13 executing loop lines 58 former case lemma holds trivially suppose line 4 reached iteration loop denote 0 value variable last execution loop lines 7 8 executed holds trivially executed hence holds loop executed also note l kigammat 0 1 therefore iii holds true execution loop finally prove ii holds executing loop lines 78 executed ii holds trivially suppose lines 78 executed case line means therefore line 7 c l kigammat hence l kigammat 0 done using lemma 42 theorem 31 correctness easily proven introduce notation facilitate separate handling remainder value c variable line 9 executed lemma 43 solves kpayment problem proof lemma 42 conjunction lines 910 code upon completion algorithm ii lemma 42 since lines 4 10 largest denomination denominations therefore theorem 31 solves kpayment problem proving optimality takes work first deal coins allocated line 9 reached show even remainder nonzero additinal coin allocated line 10 solution produced allocate still optimal end fix arbitrary solution kpayment problem use following additional notation ffl number icoins ffl u budget allocated using coins denomination less u ffl n largest denomination coin formally note definitions following holds 0 c lemma shows allocate optimalignoring remainder lemma 44 c proof contradiction suppose l smallest index ie using eq 2 l hence eq 3 l c implies integrality l c since iii lemma 42 ld l ic ie u l kl contradiction theorem 31 since l n prove optimal even considering remainder lemma 45 proof consider two cases n using lemma 44 fact n 1 definition n get c done case suppose n let prove lemma showing first note since lemma 44 using eq 3 get hand since u therefore follows eq 2 consider two subcases reduces nb done subcase otherwise proof lemma 45 complete 42 number coins allocated allocate theorem 41 proved number coins solution produced allocate optimal give tight bound number terms n k nice interpretation bound says worst penalty n k nice equivalent requiring extra payment ie solving 1payment problem nice n k remark know direct reduction proves result first prove upper bound slightly sharper general bound lemma 32 lemma 46 largest denomination coin generated allocate satisfies l n proof iii lemma 42 1i particular ii lemma 42 using also eq 5 get 1 integrality l n theorem 47 number coins solution produced allocate k proof iii lemma 42 integrality conjunction lemmas 37 46 implies c therefore upper bound given theorem 47 best possible general proven following theorem theorem 48 natural numbers infinitely many n solution kpayment problem budget n requires least k coins proof choose natural number divisible 2 3 n k algorithm produces largest denomination c follows number coins case precisely 5 generalization restricted set denominations turn attention restricted denomination case setting given set natural numbers requirement solution c get optimal algorithm arbitrary set denominations allows solution 1 follow idea algorithm allocate ensure least number coins treatment remainder complicated motivation add remainder least possible number coins also make sure invariant maintained main loop broken restrict remainder allocation use denominations already considered fact remainder allocation precisely changemaking problem solvable dynamic program ming allowed denomination sets 5 14 greedy strategy works main algorithm allocategeneralized given figure 4 completeness also include figure 5 description dynamic programming algorithm optimal changemaking allocategeneralized analysis use following additional notation ig largest allowed denomination smaller ig smallest denomination larger prove allocategeneralized correct number coins allocates optimal remark general arguments similar unrestricted case somewhat refined theorem 51 let denote solution produced allocategeneralized solves kpayment problem allowed denominations using least possible number coins proof follows lemmas 53 58 use loop invariant capture important properties algorithm lemma 52 whenever allocategeneralized executes line 4 following assertions hold ii proof line 4 reached executing lines 13 executing loop lines 510 former case lemma holds trivially 1 observe problem solvable 1 2 1coins certainly cannot satisfy payment request value 1 1 allowed trivial solution n 1coins works k allocategeneralizedn k 4 largest den smaller next one l j 8 l kj gammat check budget exhausted 9 c l kj gammat add coins else goto 12 13 0 fd j 2 ig add remainder without greater denominations figure 4 algorithm optimal solution kpayment problem allowed denominations latter case let 0 denote value variable last execution loop lines 9 10 executed holds trivially executed holds loop executed whether lines 9 10 executed l kj gammat 0 thus iii true execution loop finally show ii holds executing loop line 8 executed line 11 executed ii holds trivially otherwise lines 910 executed c l kj gammat hence l kj gammat 0 correctness allocategeneralized proven next lemma following conventions section 4 denote allocation produced allocategeneralized line 12 denote c values corresponding c respectively lemma 53 solves kpayment problem allowed denominations proof lemma 52 conjunction lines 1214 code upon completion algorithm highest denomination allocated algorithm ii lemma 52 fact makechange use coins higher denominations line 13 1 therefore theorem 31 solves kpayment problem makechangerd 2 6 r downto 1 7 8 9 gamma j return r figure 5 dynamic programming algorithm finding least number coins whose sum r units using denomination set array multisets turn prove optimality algorithm analysis proceeds similarly section 4 first show allocation coins remainder ie line 12 executed optimal prove handling remainder optimal well proof complicated fact order ensure correctness allocategeneralized allocates remainder using denominations already considered main loop hence immediately clear remainder allocated optimally remainder section fix arbitrary competitor solution define notions analogous defined solution produced allocategeneralized ffl number icoins ffl u budget allocated using coins denomination less u ffl n largest denomination coin formally facilitate treatment remainder fix arbitrary subsulotion solves kpayment problem budget possible since solution budget n also solution budget smaller n use following additional definitions jd analogous largest denomination largest denomination allocated line 12 allocategeneralized hence finally define definitions 0 c start proving allocategeneralized produces optimal solutionignoring remainder lemma 54 1 c proof suppose l smallest index ie using l hence eq 7 implies integrality l c l iii lemma 52 therefore since l u ld l id ic u contradiction theorem 31 since l corollary 55 n proof suppose lemma 54 u contradiction fact u next prove solution use denomination larger largest one used lemma 56 n proof consider two cases suppose first line 12 reached testing condition line 4 hence remainder allocated dynamic algorithm note n maxn therefore n maxm done case suppose next line 12 reached line 11 case since hence suppose contradiction n least one coin denomination allocated hence n get eq 8 contradiction theorem 31 since follows remainder allocated optimally choice subsolution corollary 57 c proof lemma 56 amount must allocated using denominations used statement therefore follows optimality dynamic programming used makechange prove optimality full solution lemma 58 proof corollary 57 sufficient prove number coins least much n done lemma 54 remains consider case similarly lemma 45 define notation sufficient show lemma 54 using eq 7 get u id also since u u c ic hence b thus eq 6 get required 6 exact payments electronic cash section discuss issue exact payments model electronic cash ecash briefly model bank set users set shops withdrawal deposit protocols involving bank user shop payment protocol involving shop user required users anonymous given coin impossible infer user withdrew even shops bank collaborate hand identity user revealed user pays coin model implemented electronic wallets called smart cards severely limited capacity storage computation 7 ways implement exact payments ecash simplest way use multiple coins case results presented paper explain coins withdrawn another approach divisible coins 9 8 12 arbitrary portions coin spent long sum exceed value coin expected size divisible coin computational resources time communication required manipulation greater nondivisible coins intermediate approach presented 12 composite coin divisible set prescribed set subcoins subcoins used payment deposit cannot divided although size composite coin grows linearly number constituent subcoins c subcoins typical size composite coin 500 size still smaller size arbitrarily divisible coins sufficiently small number subcoins results paper particularly useful composite coin one get reasonable bound k number exact payments composite coins better arbitrarily divisible coins respects certain ranges n k current technology technique 12 better k acknowledgments thank mike saks richard stanley yishay mansour helpful discussions eric bach bringing postage stamp problem attention rakesh verma providing us copy 14 agnes chan valuable suggestions comments r untraceable offline cash wallets observers blind signatures untraceable payments untraceable electronic cash construction distributed loop networks optimal bounds changemaking problem knapsack problems algorithms computer implementations cryptographic smart cards efficient divisible electronic cash scheme universal electronic cash postage stamp problem 3 denominations associate bases postage stamp problem efficient electronic notions techniques course combinatorics optimal greedy change making tr
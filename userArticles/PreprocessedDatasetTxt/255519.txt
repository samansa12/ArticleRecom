implementing atomic actions ada 95 abstractatomic actions important dynamic structuring technique aid construction faulttolerant concurrent systems although developed years ago none wellknown commerciallyavailable programming languages directly support use paper summarizes software fault tolerance techniques concurrent systems evaluates ada 95 programming language perspective support software fault tolerance shows ada 95 used implement software fault tolerance techniques particular shows packages protected objects requeue exceptions asynchronous transfer control tagged types controlled types used building blocks construct atomic actions forward backward error recovery resilient deserter tasks task abortion b introduction software fault tolerance often classified according whether static mask ing dynamic static redundancy several versions software component written version executes response requests voting performed output determine result use static version software fixed relationship every version voter operates whether faults occurred dynamic redundancy redundant components come operation error detected dynamic fault tolerance four constituent phases anderson lee 1990 1 detection faults significance eventually manifest form error fault tolerance scheme utilised error detected 2 damage confinement assessment error detected decision must made extent system corrupted delay fault occurring manifestation associated error means erroneous information could spread throughout system 3 recovery error recovery techniques aim transform corrupted system state continue normal operation perhaps degraded functionality 4 fault treatment continued service error symptom fault although damage may repaired fault may still exist therefore error may recur unless form maintenance undertaken paper primarily concerned dynamic redundancy techniques particular damage confinement error recovery sequential systems damage confinement well understood techniques modular programming objectoriented encapsulation within context stronglytyped programming language enable faults confined judicious placement acceptance tests assertions allow errors detected damage propagate similarly techniques exception handlinggoodenough 1975 forward error recovery recovery blockshorning et al 1974 backward error recover allow error recovery performed according whether fault anticipated concurrent systems position clear cut although techniques conversationscampbell randell 1986 atomic actionslomet developed time ago mainstream languages operating systems provide direct support burns wellings 1990 stead languages concurrent pascal used basis experimentationkim 1982 set procedural extensions object extensions produced arjuna uses latter approach provide transactionbased toolkit cshrivastava et al 1991 arguably highlevel support needed required functionality programmed lowerlevel primitives example attempts made program conversations ada 83burns wellings 1989clematis gianuzzi 1993 romanovsky strigini 1995 however severely hampered lack suitable language support stance romanovsky strigini 1995 allow parallelism exist inside conversation approach appropriate collection preexisting tasks wish participate collectively conversation none approaches address structure atomic actions forward backward error recover ada 95 goal paper show atomic actions programmed ada 95intermetrics 1995 section 2 reviews requirements atomic action section 3 briefly describes backward forward error recovery undertaken section 4 describes new features ada 95 required implement atomic actions section 5 shows features used program simple actions actions backward error recov ery actions forward error recovery nested actions actions resilient deserters section 6 gives simple example section 7 considers distributed systems issues finally conclusions presented section 8 atomic actions one main motivations introducing concurrent processes system enable parallelism real world reflected application programs enables programs expressed natural way leads production reliable maintainable systems however concurrent processes create many new problems exist purely sequential program particular consideration given way groups cooperating concurrent processes structured order coordinate activities example withdrawal bank account may involve ledger process payment process sequence communications authenticate drawer check balance pay money furthermore may necessary two processes interact way perform required action situations imperative processes involved see consistent system state concurrent processes easy groups processes interfere one atomic actions proposed dynamic mechanism controlling joint executing group processes combined operation appears indivisible action several almost equivalent ways expressing properties atomic action lomet 1977 randell et al 1978 1 action atomic processes performing aware existence active process active process aware activity processes time processes performing action 2 action atomic processes performing communicate processes action performed 3 actions atomic processes performing detect state change except performed reveal state changes action complete 4 actions atomic considered far processes concerned indivisible instantaneous effects system interleaved opposed concurrent although atomic action viewed indivisible internal structure allow modular decomposition atomic actions notion nested atomic action introduced processes involved nested action must subset involved outer level action case nested action could smuggle information concerning outer level action external process outerlevel action would longer indivisible 21 requirements atomic actions programming language capable supporting atomic actions must possible express requirements necessary implementation requirements independent notion process form interprocess communication provided language jalote 1985 1 welldefined boundaries atomic action start end side boundary start boundary location process involved atomic action action deemed start end boundary location process involved atomic action action deemed end side boundary separates processes involved atomic action rest system 2 indivisibility atomic action must allow exchange information processes active inside action outside resource managers excluded two atomic actions share data value data atomic actions determined strict sequencing two actions order implied synchronisation start atomic action processes enter different times however implied synchronisation end atomic action processes allowed leave atomic action processes willing able leave 3 nesting atomic actions may nested long overlap atomic actions consequently general strict nesting allowed 4 concurrency possible execute different atomic actions concurrently one way enforce indivisibility run atomic actions sequentially however could seriously impair performance overall system therefore avoided nevertheless overall effect running collection atomic actions concurrently must would obtained serialising executions 5 recovery intention atomic actions form basis damage confinement must allow recovery procedures programmed executing atomic action requires participating processes coordinate activities imposed synchronisation action follows processes entering action blocked process blocked inside action wait resource allocated attempts communicate another process inside action process either active action position accept communication yet active action may leave action processes active action wish leave hence possible subset named processes enter action subsequently leave without recourse interactions missing processes facility deemed essential realtime system deadlines important solves deserter problem processes held action one process arrived considered along error recovery next two sections 3 recoverable atomic actions section considers atomic actions forward backward error recovery 31 atomic actions backward error recovery backward error recovery applied groups communicating pro cesses possible processes rolled back start execution called domino effect problem occurs consistent set recovery points recovery line atomic action provides recovery line automatically error occurs inside atomic action processes involved rolled back start action alternative algorithms executed atomic action ensures processes passed erroneous values communication processes outside action atomic actions used way called conversations randell 1975 conversations action statement contains recovery block example action ensure acceptance test primary module else alternative module else alternative module else error processes involved conversation declare part action similarly basic semantics conversation summarised follows ffl entry conversation state process saved set entry points forms recovery line whilst inside conversation process allowed communicate processes active conversation general resource man agers conversations built atomic actions property inherited ffl order leave conversation processes active conversation must passed acceptance test case conversation finished recovery points discarded ffl process fails acceptance test processes state restored saved start conversation execute alternative modules therefore assumed error recovery performed inside conversation must performed processes taking part conversation ffl conversations nested strict nesting allowed ffl alternatives conversation fail recovery must performed higher level noted conversations defined randell 1975 processes taking part conversation must entered conversation processes leave differs semantics described process enter conversation either tardiness failed long processes active conversation wish communicate conversation complete successfully process attempt communicate missing process either block wait process arrive continue adopting approach two benefits gregory knight 1985 1 allows conversations specified participation compulsory 2 allows processes deadlines leave conversation continue necessary take alternative action conversations discussed kim 1982 context extensions concurrent pascal tyrrell holding 1986 jalote campbell 1984 1986 context csp although conversations allow groups processes coordinate recov ery criticised one important point conversation fails processes restored enter alternative modules forces processes communicate achieve desired effect process cannot break conversation may quired gregory knight 1985 point practice one process fails achieve goal primary module communication one group processes may wish communicate completely new group processes secondary module furthermore acceptance test secondary module may quite different way express requirements using conversations overcome problems associated conversations gregory knight 1985 proposed alternative approach backward error recovery concurrent processes 32 atomic actions forward error recovery although backward error recovery enables recovery unanticipated errors difficult undo operation may performed environment system operates consequently forward error recovery exception handling must also considered section exception handling concurrent processes involved atomic action discussed backward error recovery error occurs processes involved atomic action participate recovery true exception handling forward error recovery exception occurs one processes active atomic action exception raised processes active action exception said asynchronous originates another process following possible adalike syntax atomic action supporting exception handling action action exception exceptiony sequence statements exceptionz sequence statements others raise atomicactionfailure termination model exception handling processes active action handler handle exception without raising exception atomic action completes normally resumption model used exception handled processes active atomic action resume execution point exception raised either model exception handler one processes active action one handlers fails atomic action fails standard exception atomic action failure exception raised involved processes two issues must considered exception handling added atomic actions resolution concurrently raised exceptions exceptions nested actionscampbell randell 1986 briefly reviewed resolution concurrently raised exceptions possibly one process active atomic action raise different exceptions time campbell randell 1986 point event likely errors resulting fault cannot uniquely identified error detection facility provided component atomic action two exceptions simultaneously raised atomic action may two separate exception handlers process may difficult decide one chosen furthermore two exceptions conjunction constitute third exception exception indicates two exceptional conditions occurred order resolve concurrently raised exceptions campbell randell propose use exception tree several exceptions raised concurrently exception used identify handler root smallest subtree contains exceptions although clear combined parameters associated exception atomic action component declare exception tree different processes involved atomic action may well different exception trees exceptions internal atomic actions atomic actions nested possible one process active action raise exception processes action involved nested action figure 1 illustrates problem exception raised processes involved must participate recovery action unfortunately internal action definition indivisible exception raised action nested action b im figure 1 exception nested atomic actions raise exception action would potentially compromise indivis ibility furthermore internal action may knowledge possible exception raised campbell randell 1986 discussed two possible solutions problem first solution hold back raising exception internal action finished reject ffl realtime system exception raised may associated missing deadline hold back recovery procedure may seriously place jeopardy actions timely response ffl error condition detected may indicate internal action may never terminate deadlock condition arisen reasons campbell randell allow internal actions predefined abortion exception exception raised indicate action exception raised surrounding action preconditions action invoked longer valid exception raised internal action invoke faulttolerant measures abort action aborted containing action handle original exception internal action cannot abort must signal atomic action failure exception may combined outstanding exception affect choice recovery performed surrounding action abortion exception defined surrounding action must wait internal action complete alternatively default handler could provided would raise atomic action failure exception ada 83 along concurrent programming languages unable support full functionality atomic actionsburns wellings 1989 ada 95 support atomic actions directly provide rich supply language primitives potentially used implement functionality particular packages provide encapsulation information hiding exceptions provide basic termination model exception handling protected objects provide monitorlike communication mechanism asynchronous transfer controls atc provides mechanism one task asynchronous obtain attention another tagged types provide framework within objectoriented programming performed controlled types provide mechanism finalisation code associated objects packages exceptions available ada 83 therefore discussed however protected objects atc tagged types controlled types new briefly described full discussion aspects ada 95 see burns wellings 1995 41 protected objects protected object ada 95 similar concept conditional critical regionhoare 1972brinchhansen 1972 monitorhoare 1974brinch hansen 1973 data accessed mutual exclusion encapsulated protected object data accessed procedures entries also declared protected object execution procedure entry requires mutual exclusion access object tasks ada protected objects may declared instances protected record type single oneoff protected object anonymous type example following protected object single instance anonymous protected record type allows mutually exclusive access shared data protected shareddata operations shared data procedure procedure readd private thedata data someinitialvalue encapsulated data protected body shareddata procedure begin thedata procedure readd data begin difference procedure entry protected object follows procedure simply provides mutual exclusive access data task active protected object call procedure gain immediate access data entry associated guard called barrier call guarded entry allowed guard evaluates true task active protected object following shows readerwriter example write must initialise data read protected shareddata procedure entry readd private thedata protected body shareddata procedure begin thedata dataavailable true indicate data available dataavailable begin inside protected entry call requeued back onto entry another entry different protected object 42 atc ada 83 selective entry call facility extended ada 95 allow task execute section code whilst waiting entry timeout occur code finishes entry call accepted timeout expires call timeout cancelled call accepted timeout expires section code finishes execution code aborted following illustrates syntax select triggerevent trigger protected object optional sequence statements executed event received abort abortable sequence statements 43 tagged types objectoriented programming ada supports objectoriented programming two complimentary mechanisms provide type extensions dynamic polymorphism tagged types classwide types ada new type created old type properties type changed using derived types example following declares new type subtype called setting properties integer type restricted range setting integer distinct cannot interchanged type setting new integer range 1 100 new operations manipulating setting defined however new components added tagged types remove restriction allow extra components added type type might potentially extended way must declared tagged type extending type inevitably leads type becoming record record types private types implemented records tagged tagged types provide mechanism types extended crementally result programmer create hierarchy related types parts program may wish manipulate hierarchy purposes without concerned member hierarchy processing one time ada stronglytyped language therefore mechanism needed object member hierarchy passed parameter classwide programming technique enables programs written manipulate families types associated tagged type type tclass comprises types family types starting operation called parameter whose type classwide runtime dispatching occurs appropriate operation associated actual type object typically represented package containing tagged type primitive operations package object type objtype tagged limited private procedure op1o objtype procedure op2o objtype procedure classwideopo objtypeclass private type objtype tagged limited record object extended usually child library package allows access private part parents declaration package objectextended type extendedtype new objtype private procedure op1o extendedtype procedure op2o extendedtype private type extendedtype new objtype record 44 controlled types support objectoriented programming provided controlled types types possible define subprograms called automat ically objects type ffl created initialize ffl cease exist finalize ffl assigned new value adjust gain access features type must derived controlled predefined type declared library package adafinalization must part controlled class hierarchy package adafinalization defines procedures initialize finalize adjust type derived controlled procedure may overridden objects typically cease exist go scope exiting block may involve number calls finalize representing recoverable atomic actions ada 95 section 21 requirements atomic actions defined briefly reviewed illustrate general approach implementation ada 95 1 welldefined boundaries atomic action encapsulated one ada packages hence side boundaries action well defined subprograms procedures functions package interfaces used provide start end points task 2 indivisibility protected objects provide mechanisms indivisibility property action implemented protected entries used provide required synchronisation exit action 3 nesting nested actions supported implementing actions abstract data types 4 concurrency concurrency execution atomic actions provided concurrency tasks groups tasks share action automatically execute concurrently 5 recovery backward forward recovery programmed using combination protected objects atc exceptions 51 simple actions illustrate atomic action programmed ada consider first simple nonnested action recovery say three tasks action encapsulated package three visible procedure called appropriate task assumed tasks aborted deserter tasks package simpleaction procedure t1params param called task 1 procedure t2params param called task 2 procedure t3params param called task 3 body package automatically provides welldefined boundary required provide indivisibility protected object action controller used purpose provides similar function coordinated atomic action manager introduced randell et al 1995xu et al 1995 packages visible procedures call appropriate entries protected object four entries sufficient component action calls individual entry indicate arrived finishing component calls finished entry package body simpleaction protected actioncontroller entry first called entry second called t2 entry third called t3 entry finished called tasks private firsthere thirdhere release definition local protected objects controlling resources protected body actioncontroller separate procedure t1params begin acquire resources action communicates tasks executing t3 via resources release resources similar second third task begin initialisation local resources implementation action controller given protected body actioncontroller entry first firsthere begin firsthere true first entry second secondhere begin secondhere true entry third thirdhere begin thirdhere true entry finished release finishedcount 3 begin release false firsthere false secondhere false thirdhere false else release true barriers entries first second third ensures three tasks active action one time three tasks called finished entry barrier lowered tasks released boolean release used program required release conditions finished first two calls finished blocked parts barrier expression false third call comes count attribute become three barrier comes one task execute entry body release variable ensures two tasks released last task exit must ensure barrier raised note adas task identifiers used necessary validate identity task performing action components following sections assumed tasks participating action use package implementing action task call associated operation 52 backward error recovery section ada atc facility exception handling used implement backward error recovery scheme based backward error recovery requires use form recovery cache section assumes existence following generic package saving restoring tasks variables assumed strong typing provided ada ensure ada program remains viable type data private package recoverycache procedure procedure consider three ada tasks wish enter recoverable atomic action call appropriate procedure package given package conversation procedure t1params param called task 1 procedure t2params param called task 2 procedure t3params param called task 3 body package encapsulates action ensures communication three tasks allowed controller protected object responsible propagating error condition noticed one task tasks saving restoring persistent data recovery cache ensuring tasks leave action time contains two protected entries protected procedure ffl wait abort entry represents asynchronous event tasks wait whilst performing part action first call indicates new action controller save persistent data recover cache requeue facility used place first task back queue ffl task calls done finished three tasks called done allowed leave ffl task recognises error condition either raised exception failure acceptance test call signal abort restore persistent data defined within package body set flag killed true indicating tasks must recovered note backward error recovery performed tasks concerned actual cause error killed becomes true tasks action receive asynchronous event event handled task must wait done entry terminate conversation module together recoverycache package body conversation primaryfailure secondaryfailure tertiaryfailure exception type module primary secondary package persistentcache new recoverycache persistent data retained conversations protected controller entry waitabort entry done procedure signalabort private killed releasing informed newconversation local protected objects communication actions protected body controller entry waitabort killed newconversation begin newconversation save persistent data recovery cache requeue waitabort abort return executed killed informed killed false informed 0 procedure signalabort begin restore persistent data killed true entry done donecount 3 releasing begin donecount 0 releasing true else releasing false newconversation true procedure t1params param separate procedure t2params param separate procedure t3params param separate code task contained within single procedure t1 etc within procedure three attempts made perform action attempts fail exception atomic action failure raised attempt surrounded call saves state restores state attempt fails attempt encapsulated separate local procedure t1 primary etc contains single select abort statement perform required protocol controller recovery cache used task save local data procedure t1params param procedure t1primary begin select triggering event finish raise primaryfailure abort begin code implement atomic action acceptance test might raise exception failed controllersignalabort else controllerdone signal completion exception others controllersignalabort procedure t1secondary procedure t1tertiary package mycache new recoverycache local data begin try module loop begin case try primary t1primary exit secondary t1secondary exit tertiary t1tertiary exception primaryfailure secondaryfailure tertiaryfailure raise atomicactionfailure others raise atomicactionfailure similarly t2 t3 53 forward error recovery adas atc facility used exceptions implement atomic actions forward error recovery concurrently executing tasks consider following package implementing atomic action three tasks package action procedure t1params param called task 1 procedure t2params param called task 2 procedure t3params param called task 3 body package encapsulates action ensures communication three tasks allowed controller protected object responsible propagating exception raised one task tasks ensuring leave action time adaexceptions use adaexceptions package body action type votet commit aborted protected controller entry waitaborte exceptionid entry done vote votet procedure signalaborte exceptionid private entry waitvote votet killed releasing informed local protected objects communication actions protected body controller entry waitaborte exceptionid killed begin informed killed false informed 0 entry done vote votet result votet true begin aborted finalresult aborted requeue wait abort procedure signalaborte exceptionid begin killed true reason e entry wait vote votet result votet releasing begin waitcount 0 releasing true else releasing false finalresult commit reason nulloccurrence procedure t1params param begin select triggering event exception abort begin code implement atomic action controllerdonecommit decision signal completion exception e others exception exception raised action tasks must participate recovery e others exceptionidentitye raised tasks handle exception handledok controllerdonecommit decision else controllerdoneaborted decision aborted raise atomicactionfailure procedure t2params param procedure t3params param component action t1 t2 t3 identical structure component executes select statement abortable part triggering event signaled controller protected object component indicate exception raised handled locally one compon ents abortable part contain actual code component code executes without incident controller informed component ready commit action exceptions raised abortable part controller informed identifier exception passed note unlike backward error recovery given previous section cause error must communicated controller received notification unhandled exception releases tasks waiting wait abort triggering event task late arriving receive event immediately tries enter select statement tasks abortable parts aborted started exception raised task statement entry call controller exception successfully handled component task indicates prepared commit action indicates action must aborted task indicates action aborted tasks raise exception atomic action failure example illustrates possible program atomic actions forward error recovery ada however first exception passed controller raised tasks possible get concurrent raising exceptions exception raised abortable part lost aborted 54 nested actions implementing nested action ada 95 requires extensions al gorithms first convert basic approach atomic action type therefore one instance created easily achieved introducing notion action identifier example consider implementation actions forward error recovery given previous section package specification becomes package action type actionid private function newaction return actionid procedure procedure procedure private type actiont type actionid access actiont action id private assignment comparison available implementation action type record containing instance controller becomes protected type instances persistent data controlling access protocols type actiont record interface procedures use action id generate call correct controller example acwaitabort action types introduced nested action called within body action produce following ada structure nested action package containing action nested action id nestedaction package body action procedure t1a actionid otherparams param begin select abort begin code implement atomic action including nested action call acdonecommit decision completion outer action exception e others exception e others exceptionidentitye raised tasks handle exception handledok acdonecommit decision else acdoneaborted decision aborted raise atomicactionfailure code expanded remove explicit procedure nested actiont1 following equivalent structure obtained select abort begin code implement atomic action including select abort begin code implement inner atomic action ncdonecommit decision signal completion exception e others acdonecommit decision signal completion exception e others outer action exception signalled outer abort sequence code aborted turn cause inner action aborted without recovery action facilitate recovery inner action necessary use another ada 95 facility called controllled types objects controlled type amongst things finalisation routines defined hence action procedure following extra components nestedactionid new finalizationlimitedcontrolled null record procedure finalizear abortrecovery finalisation action signal action controller action aborted procedure finalizear abortrecovery begin action arncdoneaborted procedure t1n nestedactionid nestedaction begin inner action represented nested t1 aborted ar controlled variables goes scope however happen finalisation procedure called note small modification controller tasks required finalize routine called every time variable goes scope irrespective whether action aborted 55 deserter problem task abortion far assumed expected tasks arrive leave action task fails arrive tasks blocked trying leave solve deserter problem necessary know many tasks entered action tasks entered ready leave action complete simple modification action controller protected object allows protected type controller entry waitaborte exceptionid entry done vote votet procedure signalaborte exceptionid private entry enterede exceptionid entry waitvote votet killed releasing informed active new private entry provided called entered count active number tasks active action task calls wait abort entry part atc statement call immediately accepted count incremented call requeued entered entry entry waitaborte exceptionid true begin active requeue entered abort entry enterede exceptionid killed begin informed active killed false informed 0 guard wait entry simply changed include active count reset zero tasks finally finished action entry wait vote votet result votet active releasing begin waitcount 0 releasing true else releasing false finalresult commit reason nulloccurrence active 0 required action contain timeouts synchronous communication might block cooperating task absent communication essential action exception raised timeout expires one final problem address happens task executing atomic actions aborted another task outside action similar nested action situation recovery approach 56 objectoriented programming reusability action systems developed far easily rewritten make ex tensible example consider basic package provides action controller supporting forward error recovery action controller protected type placed private part package child packages written implement atomic actions particular systems code therefore reused adaexceptions use adaexceptions package atomicactionsupport abstract tagged limited private private type votet commit aborted protected type actioncontrolleratleast positive entry waitaborte exceptionid entry done vote votet procedure signalaborte exceptionid private entry enterede exceptionid entry waitvote votet killed releasing active actiontatleast positive tagged limited record notice example action parameterised tagged type allows type extended child packages parameter indicates controller minimum number tasks must active action action terminate body package simply contains body action controller one given section 55 except barrier wait entry entry wait vote votet result votet active active atleast releasing actions created extending action type example given next section 6 example action system consider example controlling position three axis robot software consists several tasks including coordinate controller three tasks controlling robot one axis coordinate controller task informs three tasks new position required act moving one position another atomic action rest system see robot one position another atomic action support robot simply child package atomic action support given previous section action extended include protected type used communicate synchronise four tasks coordinate controller task written new position tasks acquire routines added task package atomicactionsupportrobot type myactiont new actiont private subtype coordinate integer range 0 180 type coordinates record procedure procedure procedure procedure private protected type sharedcoord procedure writecoordsnewpos coordinates private type myactiont new actiont record note ada 95s access parameters used avoids allocate actions data dynamically allows runtime dispatching operations used action extended body package given structure interface procedure similar given previous sections package body atomicactionsupportrobot protected body sharedcoord separate procedure access myactiont begin select abort begin code implement atomic action including move new position acdonecommit decision signal completion exception e others exception e others move back origin acdoneaborted decision similarly ycoord zcoord procedure begin select abort begin code implement atomic action including acdonecommit decision signal completion exception e others exception e others acdoneaborted decision raise atomicactionfailure body shared coord protected object protected body sharedcoord procedure writecoordsnewpos coordinates begin nextpos newpos newvalue true newvalue begin xgot true ygot zgot xgot false ygot false zgot false newvalue false similarly ready readz finally code four tasks given atomicactionsupportrobot use atomicactionsupportrobot procedure main robotaction aliased myactiontatleast 4 action four tasks must enter leave type dimension x z task control three axis controller tasks task body control begin coordcontrollerrobotactionaccess start loop determine next position coordcontrollerrobotactionaccess next loop task body axis begin loop x xcoordrobotactionaccess ycoordrobotactionaccess z zcoordrobotactionaccess perform required operation new position begin 7 distributed systems ada defines distributed system interconnection one processing nodes system resource computational storage cap abilities zero storage nodes system resource storage capabilities storage addressable one processing nodes ada model programming distributed systems specifies partition unit distribution partitions firstclass language entities sense cannot declared types instances created instead comprise aggregations library units separately compiled library packages subprograms collectively may execute distributed target execution environment inability declare partition types main limitation ada model example arrays partitions expressible within languageburns wellings 1995 partition resides single execution site library units occupy logical address space one partition may however reside execution site partitions may either active passive library units comprising active partition reside execute upon processing element contrast library units comprising passive partition reside storage element directly accessible nodes different active partitions reference model ensures active partitions cannot directly access variables active partitions variables shared directly active partitions encapsulating passive partition communication active partitions defined language via remote subprogram calls however implementation may provide communication mechanisms help construct distributed programs ada distinguishes different categories library units imposes restrictions categories maintain type consistency across distributed program two categories designated following pragmas ffl pure pure packages packages restrictions enable freely replicated different active passive partitions without introducing type inconsistencies restrictions concern declaration objects types particular variables named access types allowed unless within subprogram generic subprogram task unit protected unit type declared pure package considered single declaration irrespective many times package replicated distributed system package replicated partition references hence pure packages enable types declared subsequently used communication partitions ffl remote call interface remote call interface package defines interface active par titions body exists within single partition occurrences stubs allocated using standard rpc implementation techniquesbirrell nelson 1984 specification remote call interface various restrictions example prohibit definition variable ensure remote data access package categorised called normal library package included one partition replicated types objects viewed distinct 71 programming distributed actions many ways distributed programs constructed ada see burns wellings 1995 clientserver model used robot arm problem given previous section used example following assumptions made ffl control axis tasks distributed machines fail silentschlichting schneider 1983 ffl replication availability required achieved transparently program ffl communication reliable common distributed programming languages possible take arbitrary ada program distribute therefore necessary restructure one given section 6 figure 2 illustrates logical partitioning application box represents partition arrow shows control flow several restrictions imposed interface partitions distributed ada system particular influence implementing distributed actions ffl protected objected cannot called directly remote partition instead necessary provide rpc interface ffl exception identifiers cannot passed one partition another consequently necessary pass enumeration type instead convert distributed ada runtime support system instead collection communicating runtime support systems proposed solution considered first pure package constructed provide types used throughout system coordinator shared data local action local action coordinator coordinator coordinator subaction axes controller z axis task subaction axis task subaction axis task subaction coordinator distributed action coordinator figure 2 partioning robot arm problem package commontypes pragma pure subtype coordinate integer range 0 180 type coordinates record type votet commit aborted type type dimension x z next necessary construct servers act controllers shared data distributed action section 6 data communicated action new x z coordinates encapsulated protected object cannot directly called across distributed system necessary encapsulate package provide rpc interface commontypes use commontypes package shareddata pragma remotecallinterface procedure writecoordsnewpos coordinates procedure readddimensionc coordinate package body simply declares protected object identical one given section 6 procedures write coords read call appropriate procedures entries distributed action controller similar translation originally centralised controller implemented protected type encapsulated package given remote call interface exception identifiers replaced error id commontypes use commontypes package globalactionsupport pragma remotecallinterface procedure abortactionae procedure doneavote votet procedure signalabortae procedure donecleanupavote votet however one change needs made original controller called asynchronous select atc statement possible call protected object across network atc statements triggering event must entry call delay hence possible replace calling code simple rpc help solve problem necessary distinguish tasks waiting action finish normally waiting finish following exception previously entry done used occasions new routine done cleanup used indicate latter done used former body package package body globalactionsupport protected type globalactioncontrolleratleast integer entry waitaborte entry done vote votet procedure signalaborte entry donecleanup vote votet private entry enterede entry waitvote votet entry waitcleanup vote votet killed releasing informed active globalactioncontrolleratleast 4 protected body globalactioncontroller entry waitaborte errorid entry enterede errorid entry done vote votet result votet entry donecleanup vote votet result votet true begin aborted finalresult aborted requeue waitcleanup abort procedure signalaborte begin possible get multiple exceptions raised approach raise first error participants killed true reason e firste reason entry wait vote votet result votet active active atleast releasing begin waitcount 0 releasing true else releasing false finalresult commit reason nullid active 0 killed true flush remote calls entry waitcleanup active active atleast releasing2 begin waitcleanupcount 0 else active 0 releasing true flush orphans procedure waitabortae errorid begin similar donea signalaborta donecleanupa essential note tasks call global action controller tasks created local implementation remote procedure calls therefore cannot guaranteed remote task waiting atc event entry distributed action complete one call immediately cancelled accepted consequently necessary global controller flush tasks waiting also note multiple errorsexceptions possible first error one returned participants however would possible implement exception trees next local action controllers considered atc necessary local task forwards trigger event waits occur commontypes use commontypes package localactionsupport task type localactioncontroller entry waitaborte private entry aborttakene body globalactionsupport package body localactionsupport task body localactioncontroller begin loop accept waitaborte errorid requeue aborttaken abort forward request select accept aborttakene errorid else task accepts triggering event requeues passes event global action controller rpc returns error may signalled call may flushed error returned conditional accept issued possible client gone away time executed individual participants action programmed local action axes considered instantiation generic package commontypes use commontypes local device parameters move package axesaction procedure move commontypes use commontypes localactionsupport use localactionsupport globalactionsupport use globalactionsupport adaexceptions use adaexceptions shareddata use shareddata package body axesaction procedure move begin select local call convert x ex abort begin code implement atomic action including shareddatareadd c remote call move c doneacommit decision remote call exception e others convert x ex exception e others donecleanupacommit decision remote call aborted raise atomicactionfailure note identically structure given previously paper however triggering event call local action controller task calls rpc calls remote action controller shared data controller return signal abort remote call triggering event might still occurred therefore necessary raise exception instead task called done return triggering event occurs rpc call therefore cancelled cancellation occur global action controller finished cleaning controller views call orphan automatically flushes code robot controller action similar structure necessary create axes tasks done follows commontypes use commontypes package axes axesaction commontypes use commontypes package body axes task body axis package mylocalaction new axesactiona appropriate params begin loop perform operation exception atomicactionfailure finally partition defined using main procedure example axes use axes commontypes use commontypes procedure main begin configuration program used group together library packages partitions allocating nodes distributed system 8 conclusion atomic actions powerful dynamic structuring technique allow software faulttolerant systems implemented however clear programming language operating system support application programming language operating system provides direct sup port ada 95 programming language however provide rich set mechanisms aid programming concurrent realtime systems paper shown facilities used implement aspects atomic actions lack truly distributed runtime support system ada means possible call protected objects across partitions pass exception identifiers cause difficulty programming distributed actions ada facilities impressive defines support particular ffl encapsulation ffl communication synchronisation ffl exceptions asynchronous transfer control ffl objectoriented programming ffl finalisation fundamental building blocks allow resuable atomic actions constructed ability program atomic actions ada lead increase use engineering high integrity applications r fault tolerance principles practice implementing remote procedure calls structured multiprogramming operating system principles programming atomic actions ada concurrency ada recovery asynchronous systems structuring conversations oper ationprocedure oriented programming languages exception handling issues proposed notation towards theory parallel programming program structure error detection recovery fault tolerance using communicating sequential processes atomic actions faulttolerance using csp approaches mechanization conversation scheme based monitors process structuring system structure software fault tolerance recovery blocks concurrent atomic actions reliability issues computing system design backward error recovery via conversations ada design reliable software distributed systems using conversation scheme fault tolerance concurrent objectoriented software coordinated error recovery tr ctr jrg kienzle alexander romanovsky implementing exceptions open multithreaded transactions based ada 95 exceptions acm sigada ada letters vxxi n3 september 2001 lus miguel pinho francisco vasques multi ada 95 based architecture fault tolerance support realtime systems acm sigada ada letters vxviii n6 p5260 novdec 1998 marta patiomartnez ricardo jimnezperis sergio arvalo synchronizing group transaction rendezvous distributed ada environment proceedings 1998 acm symposium applied computing p29 february 27march 01 1998 atlanta georgia united states alexander romanovsky bo sandn except exception handling acm sigada ada letters vxxi n3 september 2001 patiomartnez r jimnezperis arvalo implementing transactions using ada exceptions features missing acm sigada ada letters vxxi n3 september 2001 alexander romanovsky jrg kienzle actionoriented exception handling cooperative competitive concurrent objectoriented systems advances exception handling techniques springerverlag new york inc new york ny 2001 durgesh pant k c joshi software fault tolerant computing needs prospects ubiquity v8 n16 p11 april 24 2007 april 30 2007
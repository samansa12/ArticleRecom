parallel algorithm mesh smoothing maintaining good mesh quality generation refinement unstructured meshes finiteelement applications important aspect obtaining accurate discretizations wellconditioned linear systems article present meshsmoothing algorithm based nonsmooth optimization techniques scalable implementation algorithm prove parallel algorithm provably fast runtime bound executes correctly parallel random access machine pram computational model extend pram algorithm distributed memory computers report results two threedimensional simplicial meshes demonstrate efficiency scalability approach number different test cases also examine effect different architectures parallel algorithm present results ibm sp supercomputer atmconnected network sparc ultras b introduction unstructured meshes proven essential tool numerical solution largescale scientific engineering applications complex computational domains problem meshes shape elements mesh vary significantly variation affect accuracy numerical solution example twodimensional triangulations classical finite element theory shown element angles approach limits 0 discretization error condition number element matrices adversely affected 3 12 poorly shaped elements frequently produced automatic mesh generation tools particularly near domain boundaries addition adaptive refinement techniques used solution problem tend produce highly distorted elements contained initial mesh particularly adaptation occurs along curved boundaries 18 obtain highquality meshes often one must repair improve meshes solution process improvement based element quality measure appropriate particular problem solved two mesh improvement techniques proven successful sequential computers face edge swapping mesh smoothing 2 6 7 8 15 16 22 ever sequential mesh optimization methods appropriate applications using distributedmemory computers 1 mesh usually distributed across processors 2 mesh may fit within memory available single processor 3 parallel algorithm significantly reduce runtime compared sequential version applications parallel algorithms mesh improvement techniques required paper present efficient robust parallel algorithm mesh smoothing organized paper follows section 2 briefly review various local mesh smoothing techniques including laplacian smoothing number optimizationbased ap proaches parallel algorithm theoretical results correct execution parallel runtime bound discussed section 3 section 4 present numerical results obtained ibm sp atmconnected network sparc ultras demonstrate scalability algorithm 2 local meshsmoothing algorithms meshsmoothing algorithms strive improve mesh quality adjusting vertex locations without changing mesh topology local smoothing algorithms adjust position single grid point mesh using information assistant computer scientist mathematics computer science division argonne national laboratory ar gonne il assistant professor computer science department university tennessee knoxville knoxville tn z computer scientist mathematics computer science division argonne national laboratory argonne il incident vertices rather global information mesh typical vertex v adjacent set adjv shown figure 21 vertices adjacent set shown solid circles figure vertex v moved quality elements incident v shown shaded triangles figure changed vertices adjacent v shown unfilled circles quality elements contain vertices affected change location v one sweeps mesh performed improve overall mesh quality thus critical individual adjustment inexpensive compute fig 21 vertex v elements whose quality affected change position neighbors v shown solid circles quality shaded elements affected changing position vertex v specific represent local smoothing technique function smooth given location x v vertex v neighbors locations x adjv returns new location thus sequential form local mesh smoothing algorithm given simple loop figure 22 v set vertices mesh smoothed positions choose ordering vn enddo fig 22 local smoothing algorithm sequential implementation vertices sweep unique determined ordering vertices smoothed aspect local mesh smoothing techniques discussed detail section 24 action function smooth determined particular local algorithm chosen section briefly review several previously proposed techniques 21 laplacian smoothing perhaps commonly used local meshsmoothing technique laplacian smoothing 9 20 approach replaces position vertex v average neighbors positions method computationally inexpensive guarantee improvement element quality fact method produce invalid mesh containing elements inverted negative volume example showing laplacian 1 smoothing function might require information addition neighbor vertex position example nonisotropic problems function may require derivatives approximate solution v adjv specific information elements contain vertices however information still local included within framework smoothing lead invalid mesh shown figure 23 fig 23 set elements laplacian smoothing center vertex v results invalid triangu lation shaded square marks average positions vertices adjacent v variant laplacian smoothing guarantees valid improved mesh allows vertex v move 1 local submesh still contains valid elements 2 measure mesh quality improved note evaluating rules significantly increases cost laplacian smoothing technique 10 22 optimizationbased smoothing optimizationbased smoothing techniques offer alternative laplacian smoothing inexpensive guarantee valid elements final mesh effective wide variety mesh quality measures several techniques proposed recently briefly review methods methods differ primarily optimization procedure used quantity optimized bank 4 describes smoothing procedure twodimensional triangular meshes uses element shape quality measure given area triangular element l length edge maximum value qt corresponds equilateral triangle local submesh improved using line search procedure search direction determined line connecting current position v position results worst element becoming equilateral line search terminates least one elements shape quality value equals improving element one variant technique attempts directly compute new location using two worst elements local submesh case line search procedure used cases new position results third element different original two worst elements smallest shape measure shephard georges describe similar approach tetrahedral meshes 23 shape function element incident v computed using formula v volume element area face parameter chosen qt maximum one corresponding equilateral tetrahedron line search similar done bank performed search direction determined line connecting current position v position improves worst element local submesh equilateral line search subproblem done using golden section procedure terminates worst element improved beyond specified limit freitag et al 10 11 propose method two threedimensional meshes based steepest descent optimization technique nonsmooth functions goal optimization approach determine position maximizes composite function 1il functions f based various measures mesh quality maxmin angles andor element aspect ratios l number functions defined local submesh example twodimensional triangular meshes maximizing minimum angle local submesh containing evaluations quality measures interest functions continuous differentiable derivatives composite function oex discontinuous discontinuity occurs change set functions obtain minimum value search direction step computed solving quadratic programming problem gives direction steepest descent possible convex linear combinations gradients active set line search subproblem solved predicting points set active functions change based firstorder taylor series approximations f x amenta et al show optimization techniques used 10 11 equivalent generalized linear programming technique expected linear solution time 1 convex level set criterion solution uniqueness generalized linear programs applied smoothing techniques determine convexity level sets number standard mesh quality measures two three dimensions techniques mentioned previously optimize mesh according element geometry bank smith 5 propose two smoothing techniques minimize error finite element solutions computed triangular elements linear basis functions methods use damped newtons method minimize 1 interpolation error 2 posteriori error estimates elliptic partial differential equation quantity minimized cases requires computation approximate second derivatives solution element well shape function qt triangular elements mentioned previously 23 combined laplacian optimizationbased smoothing shephard georges 23 freitag olliviergooch 10 present experimental results demonstrate effectiveness combining variant laplacian smoothing respective optimizationbased procedures variant laplacian smoothing used shephard georges allows vertex move centroid incident vertices worst element maintains shape measure qt fixed limit otherwise line connecting centroid initial position bisected bisection point used target position freitag olliviergooch accept laplacian step whenever local submesh improved cases laplacian smoothing step followed optimizationbased smoothing worst elements experiments 10 showed using optimizationbased smoothing minimum angle dihedral angle 3d less degrees two dimensions 15 degrees three dimensions significantly improve meshes small computational cost results also showed three sweeps mesh offer minimal improvements meshes tested 24 nonuniqueness smoothed vertex location mentioned earlier locations vertices mesh pass smoothing unique determined ordering vertices smoothed example nonuniqueness shown figure 24 simple twodimensional mesh original mesh shown left v q vertices smoothed position vertex given top series meshes vertex q relocated using optimizationbased smoothing described 11 followed adjustment vertex v shown highlighted submeshes middle rightmost meshes bottom series meshes vertices smoothed reversed order resulting final meshes considerably different final meshes resulting minimum maximum average angles two orderings presented table 21 higherquality mesh obtained moving vertex q moving vertex v v q q q fig 24 order vertices smoothed significantly affect final mesh quality series meshes show intermediate final meshes vertex q smoothed followed vertex v top vice versa bottom table minimum maximum average angles mesh shown figure 24 single pass optimizationbased smoothing two different orderings vertices ordering min angle max angle avg angle original mesh 1736 v q 10445 q v 19038 general vertices incident poorquality elements likely significantly change location smoothing process large changes adversely affect quality neighboring submeshes effects mitigated subsequent adjustment neighboring vertices therefore ordering vertices would tend effective random ordering would smooth vertices incident elements lowest quality first 3 parallel meshsmoothing algorithm section present framework correct parallel implementation local meshsmoothing algorithms presented preceding section parallel smoothing algorithm formulated within context graph mesh define follows let ng set vertices mesh mg set mesh elements either triangles tetrahedra let e graph associated mesh g first consider problem coordinating information mesh processors ensure mesh remains valid smoothing invalid mesh created smoothing two adjacent vertices simultaneously different processors consider triangulation shown first mesh figure 31 vertices q v smoothed owned different processors new locations vertices simultaneously smoothed indicated following mesh v 0 q 0 positions determined assuming locations q v fixed given first mesh shaded region second mesh shows inverted triangle created new locations v 0 q 0 define correct execution parallel algorithm follows let quality initial valid mesh 0 q 0 parallel algorithm executed correctly smoothed mesh 1 valid quality q 1 greater equal q 0 note require quality mesh smoothed parallel equal quality mesh smoothed serial different vertex ordering may used v q fig 31 example invalid mesh created adjacent vertices different processors smoothed simultaneously inverted triangle indicated shaded region elements incident v affected change location vertex v ensure correct execution parallel algorithm preventing two vertices adjacent mesh different processors simultaneously smoothed define independent set vertices subset mesh vertices v adji approach parallel smoothing algorithm 1 select independent set mesh vertices 2 smooth vertices parallel 3 notify neighbors new position procedure repeated new independent set approach avoids synchronization problems processors first formulate algorithm using parallel random access machine pram computational model prove algorithm correctness give parallel runtime bound formulate practical variant distributed memory architectures 31 pram computational model pram computational model assume processors communicate common shared memory essential aspect pram model used analysis processor access data computed another processor stored shared memory constant time using model assume many processors vertices smoothed vertex v assigned processor p parallel algorithm gives correct implementation mesh smoothing given figure 32 minimum number steps required correct execution parallel pram algorithm given lemma 1 lemma 1 number steps required guarantee correct execution smoothing algorithm least joe opt j oe opt coloring g v e joe opt j minimal among colorings g proof parallel smoothing algorithm set vertices smoothed time step two vertices v j v k e jk exists two neighboring vertices smoothed initial set vertices marked smoothing choose independent set k v 2 enddo endwhile fig 32 pram parallel smoothing algorithm simultaneously shown earlier may result invalid mesh mesh lesser quality initial mesh guaranteeing correct execution requires independent set algorithm requires disjoint sequence independent sets 1 2 found j thus parallel smoothing algorithm requires steps sequence independent sets mcoloring g definition must least joe opt j determining optimal coloring general graph known nphard problem 13 effective heuristics efficiently choosing independent sets parallel developed implemented describe two heuristic approaches 1 vertex coloring method 2 randomization scheme coloring method assumes coloring vertices oe necessarily optimal labeling oev 6 oeu u 2 adjv clearly vertices color constitute independent set used purpose parallel algorithm maximum degree graph delta number colors found coloring heuristics bounded delta 1 second approach based assignment distinct random number aev vertex step algorithm choose independent set according rule given 17 based 21 v 2 coloring approach yields running time bound independent size graph smoothed however efficient parallel computation coloring requires use randomized algorithm 17 therefore coloring approach cost effective used enough times amortize initial expense computing coloring maintained purpose typically use small number smoothing passes randomized approach used experimental results presented next section addition randomized approach memory efficient color vertex oev must stored whereas random num bers aev computed needed practical implementation use pseudorandom number generator determine aev based solely global number vertex evaluate parallel runtime pram computational model assume mesh generated finite element finite volume solution physical model graph meshes local edges connect vertices physically close general maximum degree vertex mesh bounded independent size system given local nature graph assumption vertex assigned unique independent random number aev expected number independent sets generated loop figure 32 bounded eolognlog logn n number vertices system bound consequence corollary 35 17 maximumtime required smooth vertex max also bounded following expected runtime bound lemma 2 algorithm figure 32 expected runtime pram computational model eo logs0 log logs0 number vertices initially marked smoothing proof assumptions pram computational model running time parallel smoothing algorithm proportional number synchronized steps multiplied maximum time required smooth local submesh step k upper bound time given maximum time max smooth local submesh algorithm number synchronization steps equal number independent sets chosen 31 expected number eo logs0 loglogs0 32 practical implementation distributed memory computers practical implementation distributed memory computer assume number vertices far greater number processors modify pram algorithm accordingly assume vertices partitioned disjoint subsets v j distributed across processors processor owns v j based partitioning v elements mesh also distributed processors parallel computer given processor owns set vertices rather one case pram model choose independent sets according slightly different rule used figure 32 independent set chosen according rule v 2 incident vertex v j 62 modified rule allows two vertices owned processor smoothed step vertex locations distributed across many processors share common memory must add communication step algorithm given figure 32 communication asynchronous requiring global synchronization 2 independent set smoothed communicate new vertex locations processors containing vertices adji smoothing next independent set vertices show additional step ensures practical algorithm avoids synchronization problems mentioned beginning section incident vertex information correct step algorithm lemma 3 vertex information correctly updated execution parallel smoothing algorithm proof proof induction assume initial incident vertex location correct incident vertex location correct following step k gamma 1 position vertex v adjusted step k properties independent set none incident vertices v j adjusted thus following step k parallel smoothing algorithm incident vertices notified repositioning vertex v given new location note finding requires processor communication processor stores incident vertex information communication random numbers necessary seed given pseudorandom number generator determine aev based solely global numbering thus communication required practical algorithm notification new vertex positions processors containing nonlocal incident vertices global reduction required check whether k empty 4 experimental results illustrate performance parallel smoothing algorithm two three dimensions consider two finiteelement applications 1 scalar poisson problem gaussian point charge source circular domain pcharge 2 linear elasticity problem elastic upper right quadrant domain twodimensional elasticity problem shown figure 41 threedimensional test cases solved regularly shaped sixsided solid meshes problems generated coarse mesh global synchronization expensive practical distributed memory architectures adaptive refinement elements refined rivaras bisection algorithm refinement indicator function based local energy norm estimates parallel adaptive refinement algorithm test problems described detail 19 meshes partitioned using unbalanced recursive bisection urb algorithm strives minimize number processor neighbors ensure vertices equally distributed 19 case compare two different smoothing approaches one using optimizationbased smoothing approach optimizationbased one using combined laplacianoptimization technique combined 10 combined approach use laplacian smoothing first step accept new grid point position whenever quality incident elements improved quality incident elements exceeds userdefined threshold 30 10 algorithm terminates otherwise optimizationbased smoothing performed attempt improve mesh quality measure used cases maximize minimum sine angles dihedral angles 3d eliminates extremal angles near 0 measures considered 10 maxmin angle maxmin cosine measure produced highest quality meshes computational cost test cases considered paper perform two smoothing sweeps mesh grid points vertices maintained queue processed order illustrate qualitative effect mesh smoothing present figure 41 results optimizationbased approach described 11 twodimensional elasticity problem mesh left shows initial mesh series refinement steps global minimum angle mesh 113 average minimum element angle 357 initial edges coarse mesh still clearly evident many levels refinement contrast mesh right obtained smoothing grid point locations refinement step bisection lines longer evident elements mesh less distorted global minimum angle mesh 217 average minimum element angle 411 fig 41 typical smoothing results optimizationbased approach twodimensional elasticity prob lem mesh left shows refinement without smoothing mesh right shows results interleaving smoothing refinement experiments described section designed examine scalability parallel smoothing algorithm therefore problem adjusted element error tolerances number vertices per processor remains roughly constant number processors varied show scalability two threedimensional algorithms ran four test cases 164 processors ibm sp system sp3 thin nodes tb3 switch examine effect different architectures algorithm also ran twodimensional test cases network 12 sparc ultras connected via atm network message passing accomplished using mpich implementation mpi particular p4 device sparc ultra atm network mpl device ibm sp 14 table smoothing results 2d problems ibm sp optimizationbased combined max max vtx max vtx number number total smooth smoothed smooth smoothed local number time per time per procs vtx vtx sec second sec second 48 10384 498379 125 8307 571 1818 48 4198 201392 410 1023 160 2623 table 41 give experimental results optimizationbased combined smoothing techniques twodimensional test cases ibm sp different numbers processors used show maximum number vertices assigned processor total number vertices final mesh maximum smoothing time longest time taken processor perform two smoothing passes mesh vertices vertices smoothed per second average rate per processor vertices smoothed smoothing algorithm scaled perfectly numbers would remain constant expected combined approach obtains much higher average rate smoothing applications computationally expensive optimization procedure performed subset mesh vertices average smoothing rates two applications different amount work required smooth two meshes different point charge problem average vertex smoothing rate slowly decreases number processors increases smoothing techniques elasticity problem quality meshes varies significantly number processors change resulting nonmonotonic change smoothing rate combined approach example one processor 165 percent vertices require optimizationbased smoothing whereas four processor 10 percent require optimizationbased smoothing number vertices assigned processor roughly equal thereby implying variation smoothing rate due primarily two factors 1 increasingly unbalanced load caused varying computational cost required smooth local submesh 2 increased communication costs implementationoverhead associated parallel smoothing algorithm let time required compute new locations vertices owned processor p let time associated communication costs implementation overhead processor time thought time required smooth vertices local subproblems constructed include overhead associated determining adjacency set vertex quantify effects average smoothing rate define following ffl work load imbalance ratiothe maximum time required compute new locations vertices processor divided average time ffl efficiencythe maximum amount time required compute new locations vertices processor divided maximum time including overhead costs theta 100 note implementation overhead costs include computations setting adjacency information local submeshes determining independent sets thus even sequential case overhead associated global computations efficiency thought percentage time solving local smoothing problems therefore good parallel implementation nearly constant efficiency indicating little additional overhead associated parallelism quantities value 10 implies processors perfectly balanced value implies overhead costs associated sequential parallel algorithm work load imbalance ratios parallel efficiencies corresponding test cases table 41 given table 42 number processors increases work load stays roughly balanced 18 processors becomes increasingly unbalanced especially true combined approach work load imbalance ratio increases 17 64 processors test cases larger imbalance associated combined approach results fact processors required optimizationbased smoothing others parallel efficiency calculation takes imbalance account efficiencies optimizationbased combined approaches eo ec remain roughly constant respect p conclude parallel algorithms scale well despite increasing imbalance work load general efficiency optimizationbased approach higher combined approach higher computational cost smoothing step better amortizes overhead costs numbers monotonic varying meshes corresponding work loads different numbers processors performance parallel smoothing algorithm could improved repartitioning mesh account imbalance work load however approach practical applications smoothing small portion overall solution process would computationally efficient repartition mesh mesh smoothing efficiency results show parallel algorithm performing well even though partitioning determined aspects solution process work load imbalance parallel efficiency parallel smoothing algorithm twodimensional test cases ibm sp optimizationbased combined number max max max max total smooth io eo total smooth ic ec procs time time time time 4 826 78 11 944 287 24 12 836 8 772 73 11 945 278 23 11 827 48 125 12 14 960 571 50 17 875 4 266 25 10 939 115 94 10 817 8 267 24 10 898 124 98 12 790 48 410 37 15 902 160 14 18 875 table 43 give number vertices average vertex smoothing rates smoothing techniques applied threedimensional application problems cost smoothing threedimensions roughly ten times twodimensional cost increase cost results roughly fivefold increase number function evaluations required vertex due higher vertex degree addition function evaluation approximately twice expensive 3d 2d trends evident twodimensional test cases apparent threedimensional test cases particular combined approach roughly two three times faster optimizationbased approach average smoothing rates slowly decrease function number processors work load imbalance efficiency results given table 44 see combined approach tends produce imbalanced load number processors increases optimizationbased smoothing approach efficient combined approach higher computational cost optimizationbased smoothing efficiency slowly decreasing function number processors test cases considered contrast efficiency results combined approach slightly variable differing ratios optimizationbased smoothing laplacian smoothing roughly constant efficiencies demonstrate algorithm scales well despite imbalance work load figure 42 graphically summarize results two threedimensional test cases ibm sp show average rate vertices smoothed efficiency test set smoothing technique show parallel algorithm achieves roughly results whether run parallel sequentially twodimensional elasticity problem table 45 show test case results single mesh containing 76118 vertices initial minimum angle 590 sors smoothing techniques improved minimum angle roughly 13 column labeled smoothing results 3d problems ibm sp optimizationbased combined max max vtx max vtx number number total smooth smoothed smooth smoothed local number time per time per procs vtx vtx sec second sec second 48 6377 305414 7281 8758 2532 2519 48 4121 196332 3626 1136 1716 2401 timecall gives maximum average time smooth local submesh across processors time constant techniques 18 processors numbers slightly increase 16 processors increase work one processors work increase clearly reflected combined approach maximum percentage cells require optimization processor percentage increases approximately 10 percent 18 processors 1421 2079 percent 16 32 processors respectively finally show parallel smoothing algorithm scalable twodimensional application problems switched atmconnected network sparc ultras table 46 show number vertices average smoothing rates 112 processors average rate results sporadic atm network ibm sp general trends evident particular parallel smoothing algorithm effectively handles higher message startup latencies lower bandwidth atm network delivers scalable performance 5 conclusions paper presented parallel algorithm class local mesh smoothing techniques numerical experiments performed two algorithms mentioned section 2 parallel framework presented suitable use techniques theoretical results show parallel algorithm provably fast parallel runtime bound pram computational model presented variant pram algorithm implemented distributed memory computers proved correctness numerical experiments performed optimizationbased smoothing technique combined laplacianoptimizationbased technique two different distributed memory architectures results showed parallel smoothing algorithm scales well despite variance processor work load associated smoothing individual submeshes work load imbalance ratios efficiency optimizationbased combined smoothing techniques threedimensional test cases ibm sp optimizationbased combined number max max max max total smooth io eo total smooth ic ec processors time time time time 48 7281 69 15 947 2532 20 13 788 28 11 863 1372 11 13 801 48 3626 table mesh quality smoothing information parallel algorithms ibm sp optimization combined number pre min min call min call percent processors angle angle ms angle ms optimized acknowledgments work first third authors supported mathematical information computational sciences division subprogram office computational technology research us department energy contract w31109eng38 work second author supported national science foundation grants asc9501583 cda9529459 asc9411394 r optimal point placement mesh smoothing method improvement 3d solid angle condition finite element method pltmg software package solving ellipitc parital differential equations mesh smoothing using posteriori error estimates optismoothing optimizationdriven approach mesh smoothing optimization tetrahedral meshes incremental topological flipping works regular triangulations communications applied numerical meth ods comparison tetrahedral mesh improvement techniques efficient parallel algorithm mesh smoothing condition finite element matrices generated nonuniform meshes computers intractability portable parallel programming messagepassing interface parallel graph coloring heuristic new mesh generation scheme arbitrary planar domains simple parallel algorithm maximal independent set problem constrained optimization approach finite element mesh smooth ing automatic threedimensional mesh generation finite octree technique tr ctr qiang du max gunzburger grid generation optimization based centroidal voronoi tessellations applied mathematics computation v133 n23 p591607 15 december 2002 henning biermann ioana martin fausto bernardini denis zorin cutandpaste editing multiresolution surfaces acm transactions graphics tog v21 n3 july 2002 shuli sun jianfei liu efficient optimization procedure tetrahedral meshes chaos search algorithm journal computer science technology v18 n6 p796803 november
experimental evaluation continuous testing development continuous testing uses excess cycles developers workstation continuously run regression tests background providing rapid feedback test failures source code edited intended reduce time energy required keep code welltested prevent regression errors persisting uncaught long periods time paper reports controlled human experiment evaluate whether students using continuous testing successful completing programming assignments also summarize users subjective impressions discuss results may generalizethe experiment indicates tool statistically significant effect success completing programming task effect time worked participants using continuous testing three times likely complete task deadline without participants using continuous compilation twice likely complete task providing empirical support common feature modern development environments participants found continuous testing useful believed helped write better code faster 90 would recommend tool others participants find tool distracting intuitively developed ways incorporating feedback workflow b introduction continuous testing uses excess cycles developers workstation continuously run regression tests background developer edits code provides developers rapid feedback regarding errors inadvertently introduced continuous testing inspired continuous compilation feature many permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee july 1114 2004 boston massachusetts usa modern development environments gives rapid feedback compilation errors paper experimentally evaluates whether extra feedback continuous testing assists developers programming task without producing harmful side effects good practice use regression test suite performing development tasks enhancing refactoring existing codebase testdriven development 3 seeks extend situation development tasks piece functionality added test functionality written added suite observed fail development running test suite bolsters developers confidence making steady progress catches regression errors early longer regression error persists without caught larger drain pro ductivity error found code changes must considered find changes directly pertain error code changes longer fresh developers mind new code written meanwhile may also need changed part bug fix running tests cost remembering run tests waiting complete returning task hand distract development order avoid running tests often seldom developers often wait least confident code unfortunately hardest errors fix introduced developer believes innocuous change developer unlikely run tests soon change unlikely remember change possible source error finally discover problem developers may employ test case selection 16 25 prioritization 36 26 reduce cost running tests may also continue editing code tests run old version complicates reproducing tracking errors continuous testing uses realtime integration development environment asynchronously run tests current version code notify developer regression errors version code tested constantly kept sync version edited whenever thinking time two edits long enough run least one test continuous testing provide useful feedback without requiring attention developer unless regression error found continuous testing combined selection prioritization approaches optimization developer longer consider run tests errors caught quickly especially developer cause suspect previous work prospectively evaluated continuous testing 28 developer behavior monitored fine granularity including state editor buffers ondisk files tests run observations permitted determination ignorance time introduction regression error developers editor developer becoming aware error running test suite fix time developer becoming aware error fixing error ignorance time fix time related larger ignorance times yield larger fix times suggests reducing ignorance time reduce fix time observation along development history permit prediction much time could saved use tool reduced ignorance time indirectly reduced fix time previous work suggested continuous testing could reduced development time 1015 two singledeveloper software projects substantially would achieved changing manual test frequency reordering tests paper reports study evaluated whether extra feedback provided continuous testing improved productivity student developers without producing detrimental side effects like distraction annoyance controlled human experiment 22 students software engineering course completed two unrelated programming assignments part normal coursework assignments supplied partial program implementations tests missing functionality simulating testfirst development methodology participants given standard emacs development environment randomly assigned groups provided continuous testing continuous compila tion additional tools data gathered remote monitoring development progress questionnaires distributed study course records 444 personhours active programming observed experimental results indicate students using continuous testing statistically significantly likely complete assignment deadline compared students standard development environment continuous compilation also statistically significantly increased success rate though smaller mar gin believe first empirical validation continuous compilation analysis show higher success rate students frequently tested manually furthermore tools feedback prove distracting detrimental tool users suffered significant penalty time worked large majority study participants positive impressions tool interested using study concluded paper organized follows first detail tools provided students section 2 design experiment sec tion 3 present quantitative section 4 qualitative section 5 results threats validity section 6 finally discuss related section 7 future work section 8 conclude summary findings section 9 2 tools implemented continuous testing infrastructure java junit 13 testing framework eclipse 8 emacs development environments junit regression testing framework java supports assertions checking expected results organizing test cases hierarchical suites running suite presenting results textually graphically junit extension used plugins persistently records whether test ever succeeded past permits change order tests run order results printed instance regression errors likely surprising developer prioritized unimplemented tests built continuous testing plugins eclipse 30 emacs focus emacs plugin used experiment describe user notified problems code plugin decides run tests conclude section comparison preexisting features eclipse emacs emacs standard notification mecha nism indicated compilation test errors mode line mode line last line emacs text window typically indicates name underlying buffer whether buffer unsaved modifications emacs modes use emacs plugin minor mode emacs parlance uses empty space mode line errors report space remains blank errors mode line contains text compileerrors regres sions3 text indicates following states code cannot compiled regression errors introduced tests used give correct answers longer tests unimplemented tests never completed correctly space mode line premium details beyond number failing tests provided user click mode line notification order see details er ror clicking shows errors separate window places cursor line corresponding failed assertion thrown exception additional clicks navigate lines corresponding additional errors andor different stack frames within backtrace emacs plugin performs testing whenever sufficiently long pause 1 require user save code save code user emacs plugin indicates errors would occur developer save modified emacs buffers compile test ondisk version code words emacs plugin indicates problems de velopers current view code emacs plugin implements testing modified buffers transparently saving separate shadow directory contains copy software development performing compilation testing shadow directory users never view shadow directory test results approach advantage providing earlier notification problems otherwise developer would possibility learning problems next save might occur long period notification inconsistent intermediate states positive reinforces developer made intended change negative distracts developer see section 5 continuous testing tool represents incremental advance existing technology emacs eclipse default emacs indirectly indicates syntactic problems code via automatic indentation fontification coloring different syntactic entities different colors indication matching parentheses similar mechanisms eclipse provides feedback editing though less full compiler automatically compiles user saves buffer indicates compilation problems text editor window task list provides integrated interface running junit test suite emacs plugin provides complete compilation feedback real time junit integration plugins provide asynchronous notification test errors 3 experimental design section describes experimental questions subjects tasks treatments evaluation continuous testing 31 experimental questions continuous testing exploits regression test suite provide feedback developers would get testing manually also reducing overhead manual testing continuous 1 tests run 5 seconds idle time least 15 seconds 30 keystrokes since last test run testing intuitive appeal many developers others skeptical benefits experimental evaluation required begin settle disagreements designed experiment address issues hopes gaining insight three main questions 1 continuous testing improve developer productivity increased developer productivity could reflected either accomplishing task quickly accomplishing given timeframe could control neither time worked whether students finished assignments measured quantities via monitoring logs class records 2 asynchronous feedback provided continuous testing distract annoy users intuition strongly divided people explained idea continuous testing confidently asserted continuous testing would distract developers much would actually make slower address question used qualitative results participant questionnaire quantitative productivity data noted 3 continuous testing group productive continuous testing subsumes continuous compilation enforces frequent testing perhaps one incidental features continuous testing environment factor true cause improvement continuous compilation compared performance three treatment groups one continuous testing one continuous compilation one additional tool b frequent testing although students encouraged test throughout development compared performance students tested frequently tested less frequently continuous testing tool effect easy fast testing unimpor tant since students could run tests five seconds single keypress c demographics chose control group randomly participants measured statistically tested various demographic factors programming experience 32 participants experimental subjects students primarily college sopho mores mits 6170 laboratory software engineering course httpwwwmitedu6170 second programming course mit first one uses java first programming course uses scheme 100 students taking class fall semester 34 volunteered participate experiment order avoid biasing sample participants rewarded way order maintain consistency experimental control groups excluded volunteers use provided development environment development excluded students used home pc different development environment work left us 22 participants first task 17 second task see section 33 average participants 3 years programming experi ence one third already familiar notions test cases regression errors figure 1 gives demographic details regarding study participants mean dev min max years programming 28 29 05 140 years java programming 04 05 00 20 years using emacs 13 12 00 50 years using java ide 02 03 frequencies usual environment unix 29 win 38 33 regression testing familiar 33 familiar 67 used emacs compile least 62 never 38 used emacs java least 17 never 83 figure 1 study participant demographics n22 dev standard deviation dont use emacs 45 dont use athena 29 didnt want hassle 60 feared work would hindered 44 privacy concerns 7 figure 2 reasons nonparticipation study n31 students could give many reasons liked differences participants nonparticipants affect internal validity study chose control group supplied experimental tool among participants volunteered study analysis indicates would wrong use nonparticipants control group statistically significant differences participants nonparticipants respect programming experience programming environment preference two factors measured predicted participation statistically significant degree first students java experience less likely participate participants average 4 years java experience whereas nonparticipants average almost 8 years java experience many experienced students said already work habits tool preferences regarding java coding overall programming experience predictor participation second students experience compiling programs using emacs likely participate variety emacs experience predict factors measured however figure 2 summarizes reasons given students chose participate 31 nonparticipants answered questionnaire regarding decision students indicated privacy concerns factor decision participate encouraging considering degree monitoring performed students see section 35 6170 course staff supported use athena mits campuswide computing en vironment emacs editor experiment provided emacs plugin worked athena students used different development environment could participate four nonemacs development environments cited students order popularity eclipse text editors grouping together vi pico editplus2 sun one studio jbuilder students complete assignments athena typically used home computers neither student experience use emacs athena statistically significant predictor measure success see section 42 33 tasks experiment participants completed first two assignments problem sets course participants treated participants 22 17 skeleton lines code 732 669 written lines code 150 135 methods time worked hours 94 132 figure 3 properties student solutions problem sets data except number participants means students received skeleton files javadoc method signatures classes implemented students added 150 lines new code complete programs files students provided need modify omitted table tests initial failing tests 45 46 lines code 3299 1444 running time secs 3 2 compilation time secs 14 14 figure 4 properties provided test suites initial failing tests indicates many tests passed staffprovided skeleton code times measured typical xwindows enabled dialup athena server typical load 36 hours problem set deadline differently students students encouraged staff assignment handout run tests often throughout development problem sets changed way accommodate experiment ask participants change behavior solving problem sets students given 20minute tutorial experimental tools access webpages explaining use students treatment groups chose ignore tools thus gained benefit problem set provided students partial implementation simple program students also provided complete test suite see section 331 partial implementation included full implementations several classes skeleton implementations classes remaining implemented skeletons included javadoc comments method signatures body method containing runtimeexcep tion documentation tasks required students assignments code compiled tests ran time students received problem sets initially tests exercised code students intended failed runtimeexception however tests initially passed failed student introduced regression provided code first problem set ps1 required implementing four java classes complete poker game second problem set ps2 required implementing two java classes complete graphing polynomial calculator problem sets also involved written questions ignore questions purposes experiment figure 3 gives statistics regarding participant solutions problem sets 331 test suites students provided junit test suites prepared course staff see figure 4 passing test suites correctly accounted 75 grade programming problems problem set test case suites consists one volunteers nonvolunteers waited end test 31 51 tested throughout 69 49 test frequency minutes mean 20 figure 5 student use test suites selfreported volunteers omits used continuous testing includes students volunteered study excluded using ide emacs students tested regularly throughout development reported test frequencies method calls code base results checked expected values suites optimized grading performance coverage usability test cases developed organized according pedagogical goals class however experience teaching assistants students suggests tests quite effective covering specification students required meet compiling testing required less five seconds even loaded dialup server since suites relatively small see figure 4 thus point using test prioritization selection running particular test suites rare professional development developer develop receive complete test suite desired functionality begin writing code new development project however since students encouraged concentrate one failing test time effect development scenario similar increasingly common practice testdriven development 3 task also similarities maintenance programmer must ensure tests regression test suite continue succeed finally developers striving compatibility interoperability existing system de facto test suite available since two systems behavior compared several deficiencies provided test suites code impacted usefulness teaching tools students development effec tiveness ps1 test suite made extensive use test fixtures essentially global variables initialized special man ner covered lecture confusing follow even experienced students ps2 provided implementation polynomial division depended students implementation polynomial addition maintain several representation invariants failure resulted failure division test addition test despite problems students reported enjoying use test suites found examining helpful developing solutions figure 5 gives detail student use provided test suites ignoring participants used continuous testing note students volunteered study even data later excluded thus knew monitored likely report testing throughout development 34 experimental treatments experiment used three experimental treatments control group continuous compilation group continuous testing group control group provided emacs environment java programs could compiled single staffprovided tests could run single keystroke continuous compilation group additionally provided asynchronous notification compilation errors code continuous testing group provided asynchronous notification test errors tools described section 2 problem set participants randomly assigned one experimental treatments 25 control group 25 continuous compilation group 50 continuous testing group larger group increase opportunities qualitative feedback users thus participants assigned different treatments two problem sets avoids conflating subjects treatments also permits users compare multiple treatments monitoring participants agreed additional emacs plugin installed system monitored behavior securely transmitted logs central remote server logged events included downloading problem set remotely turning problem set changes made buffers emacs containing problem set source even changes saved changes source file system outside emacs clicking mode line see errors total 444 personhours almost 3 personmonths active time worked monitored logs afforded us additional predictor criterion variables beyond section 42 yield statistically significant results omit paper brevity full details may found elsewhere 27 4 quantitative results section reports quantitative results experiment section 5 gives qualitative results 41 statistical tests paper reports effects statistically significant level statistical tests properly account mismatched group sample sizes comparing nominal also known classification cate gorical variables used chisquare test except used fishers exact test conservative test 20 cells classification table expected counts less 5 chisquare valid circumstances using nominal variables predict numeric variables used factorial analysis variance anova appropriate determined many effects differed using bonferroni correction using numeric variables predictors first dummy coded effect coded numeric variables make nominal used appropriate test listed less interested whether correlation could obtained standard multiple logistic regression whether effect predictor criterion variable statistically significant experiment 42 variables compared used 20 variables predictors experimental treatment problem set quantities figures 1 8 key criterion effect variables success time worked work development typing code divided wall clock time 5minute intervals counted 5 minutes interval student made edits java files comprising solution errors number tests student submission failed correct true student solution passed tests treatment n correct continuous compilation 10 50 continuous testing figure treatment predicts correctness n number participants group correct means participants completed program passed provided test suite grade assigned tas count points assigned code 75 points assigned automatically based number passed test cases 43 statistical results overall found statistically significant effects expected result effects statistically significant overwhelmed effects either ones measured factors wellknown large variation among individual programmers another reason might relatively small sample size fact effects significant suggests sample large enough expose important effects section lists statistically significant effects 1 treatment predicts correctness see figure 6 central finding experiment supported students provided continuous testing tool three times likely complete assignment correctly provided tool furthermore provision continuous compilation doubled success rate latter finding highlights benefit developers may already get continuous compilation capabilities included modern ides eclipse 8 idea 12 2 continuous testing vs regular manual testing predicts cor rectness students asked online questionnaire whether tested throughout development see figure 5 participants given continuous testing reported testing throughout 33 successfully completed assignment significantly less 78 success rate continuous testing statistically significant difference test frequency complete incomplete assignments within group mean frequency manual testing see figure 5 among tested throughout every 20 minutes longer mean time pass additional test development possibly indicating students often writing code pass several tests time running tests confirm 3 problem set predicts time worked ps1 took 94 hours programming time average compared 132 hours ps2 therefore reran analyses considering problem sets separately also reran analyses considering successful users submitted correct programs ps1 years java experience predicted correctness grade first problem set participants previous java experience advantage 83 success rate average grade 7475 versus 14 success rate average grade 6175 never used java one week later others caught least longer statistically significantly behind treatment worked errors grade cont cont testing figure 7 effect treatment success variables defined section 42 n number participants group time worked hours successfully completed tasks errors grade participants means shown followed standard deviations parentheses effect statistically significant b ps1 participants correct programs years java ide experience predicts time worked previously used java ide spent 7 hours compared 13 hours two reported never previously using java ide similar effect observed group including ps1 participants incorrect programs group ps2 participants worth emphasizing found statistically significant effects particular predictors section 42 cluding user perceptions experimental tools none predicted number errors time worked grade except effects experience seen ps1 effects student performance throughout study period effects continuous testing continuous compilation helping significantly students complete assignment figure 7 shows effects significant treatment success variables completion time worked among participants completed assignment shows trend counterintuitive us based previous suggestive results 28 expected continuous testing reduce time worked may continuous compilation continuous testing truly affect time worked may true positive negative effects masked parkinsons law work expands fill time available completion students may budgeted certain amount time problem set worked toward budget either rushing complete behind goldplating code clarity ahead turned whatever time ran 5 qualitative results gathered qualitative feedback tools three main sources students asked complete online questionnaire containing multiplechoice freeform questions interviewed staff members experiences using tools helping students teaching java tools running finally students provided direct feedback via email section 51 discusses results multiple choice questions remainder section summarizes feedback changes work habits positive negative impressions suggestions improvement 51 multiple choice results figure 8 summarizes multiplechoice questions experiences tools participants appear felt continuous compilation provided somewhat incremental benefit continuous testing though statistical evidence section 43 indicates opposite impressions tools positive overall continuous continuous compilation testing reported errors often surprised 10 07 discovered problems quickly 20 09 completed assignment faster 15 06 wrote better code 09 07 distracted tool 05 06 enjoyed using tool 15 06 tool changed way worked 17 would use tool 6170 yes 94 6 programming yes 80 20 would recommend tool others yes 90 10 figure 8 questionnaire answers regarding user perceptions continuous testing tool first 6 questions answered 7point scale ranging strongly agree reported neutral reported 0 strongly disagree reported 3 behavior change question scale 0 3 definitely negative response distracted tool positive indicator tools fact 70 continuous testing continuous compilation participants reported leaving continuous testing window open edited tests run confirms participants find distracting could easily reduced distraction reclaimed screen space closing reopening demand errors indicated especially important us 94 students wanted continue using tool class study 80 wanted apply programming tasks outside class 90 would recommend tool others showed developers enjoyed continuous testing negative impressions distraction annoyance 52 changes work habits participants reported working habits changed using tool several participants reported similar habits one got small part code working moving next section rather trying debug everything end another said easier see errors one method time course staff recommended students use singlekeystroke testing macro provided benefits however participants felt got benefits even small step automated blessing could also curse however exacerbating faults test suites see section 331 constant testing made look quick fix rather examine code see heart problem seeing success message made think often id finished section code fact may additional errors test cases dont catch 53 positive feedback participants enjoyed using tools noted tools ease use quickness felt could code one enjoyed watching unimplemented tests disappear correctly addressed several mentioned enjoying freedom mechanical tedium frequent manual testing finally figured worked got even lazier never manually ran test cases anymore one said especially useful someone extremely prone stupid typostyle errors kind obvious easily fixable see error line dont jump glance staff feedback predominantly positive head ported continuous testing worked well students students used output constantly also seemed great handle overall environment staff reported participants provided tools first problem set second problem set missed additional functionality several participants pointed first two problem sets special case made continuous testing especially use ful full test suites provided course staff students began coding passing test suite major component students grades assignments several participants mentioned unsure would use continuous testing without provided test suite uncomfortable writing testing code believed incapable one said programming seldom easily tested individual parts code appears study made participants think much testing modular design important parts goals class often ignored novice programmers tools likely become even useful students learn concepts 54 negative feedback participants didnt enjoy using tools often said interfered established working habits one said since already writing extensive java code year using emacs xterm simply got way work instead helping suppose already set way coding continuous testing could useful many felt reporting compilation errors implemented tool helpful far often knew errors reported others appear understood documentation several didnt understand get information clicking errors reported modeline participants believed tool reported compilation test error tool saved compiled code fact tool reporting would happen user save compile test code users surprised running tests without saving compiling work gave different results hypothetical ones provided tool 55 suggestions improvement participants many suggestions improving tools one recommended flexibility configuration provided tools hardcoded report feedback based staff provided test suite study completed students given instructions using tools test suite another wanted even sophisticated feedback including guess error occurring section 9 proposes integrating continuous testing debugging 37 provide hint 551 implementation issues students confused continuous testing tool filtered information junit output displaying particular removed java stack frames related junit infrastructure never relevant code errors users alarmed differences continuous testing output output tests run directly junit test caused infinite loop code test continuous testing feedback appeared identical behavior standard junit since students manually run tests thought tool failed participants reported irreproducible error results appeared change reflect state code particular circumstances one participant reported happened 2 3 times two weeks study participants still reported would continue using tools future assume huge impediment work common complaint improvement recommendation computebound workstations 333mhz pentium ii running modern operating system development envi ronment dialup workstation shared 100 users running x applications background compilation testing processes could monopolize processor sometimes much cursor movement typing erratic uncontrollable one said needs faster computer worthwhile ever students found performance acceptable conclude potential users warned use system acceptable performance additional performance optimizations worthwhile 6 threats validity experiment produced statistically significant results showing student developers using testfirst methodology continuous compilation tool doubles success rate creating correct program continuous testing tool triples success rate however circumstances experiment must carefully considered applying results new situation one potential problem experiment relative inexperience participants average 28 years programming experience 04 years experience java two thirds initially familiar notion regression testing experienced programmers might need tools much might less confused make effective use student feedback suggests benefits available users open new development tools methodologies set ways see sections 32 54 participants students strength weakness plus side use students several bene fits subject demographics relatively homogeneous subject performed task subjects externally motivated perform task part regular coursework invention experimenters subjects exposed two experimental treatments would difficult reproduce conditions professional developers 1 reason controlled experiments software engineering commonly use students 2 minus side use students limits ability generalize results software develop ers however results strongly suggest continuous compilation continuous testing valuable least beginning programmers enthusiastic adoption professionals programming environments offering continuous compilation suggests benefits limited students qualitative feedback students tas experienced programmers leads us believe benefits continuous testing apply broadly hypothesis partially confirmed positive user response industrial developers public beta release continuous testing plugin eclipse 30 emphasize however yet quantitative evidence general benefit evidence desired reviewed last two proceedings icse fse issta 5 papers reported new controlled experiments humans 4 7 18 19 38 used students would require series experiments broad range programmers tasks experiments would complement one performed would likely lesser external threats validity greater internal threats validity experiment involved relatively participants addressed risk type error false alarm reporting statistically significant effects statistical tests account number data points also risk type ii error failed alarm relatively large differences effects statistically significant may effects less important smaller magnitude yet would become statistically significant given larger data set statistics available us least indicate important effects five participants dropped study problem set 2 simply work outside emacs athena computer system eliminated participants even control group unable measure time worked similar quantities could account effects development environments switching environments may success identified several problems tools section 551 many since corrected would likely improve results participants provided tool furthermore students ignored tools thus gained benefit results would probably even better students used tools proposed continuous testing aid developer performing maintenance tasks adding functionality refactoring presence regression test suite though may also useful circumstances testfirst development continuous testing thought way making test suite valuable using effectively failing tests discovered quickly otherwise would continuous testing useful relieves developers difficult lengthy easily forgotten tasks developers performing maintenance tasks likely introduce regression errors circumstances present experiment experiment provided much less ideal scenario continuous testing tool testing easy required single fast seconds see figure 4 students repeatedly reminded course staff test often initial development tends introduce fewer regression errors maintenance factors suggest use continuous testing software maintenance real project settings rather classroom may yield even better results measured ex periment noted future experiments build upon one evaluate continuous testing environments experiment developers given test suite ahead time thus experimental results yield insight use continuous testing increasingly popular practice testfirst development certain circumstances striving compatibility interoperability existing sys tem experimental results somewhat less applicable maintenance noted finally applicable initial development absence test suite naturally test execution methodology help absence test suite errors exposed test suite possible test execution methodology continuous testing focusing developers attention existing test suite could distract developer considering measures progress project conformance written specification experiment shed light question since used definition success students judged passing tests provided suite one could run similar study participants required pass additional test suite provided results student solutions public suite private suite matched would provide evidence solutions generally correct rather simply debugged existence public test suite suggest results study would created new ps2 test suite containing 22 classroom tests polynomial algebra calculus 35 new test suite revealed one new bug one 17 student solutions 7 related work previously introduced notion continuous testing development reduce wasted development time 28 previous work also presented model developer belief along detailed record prior development project enabled estimation effects would developer used different testing tool prior project case study one developer indicated savings 1015 development time could possible research extends previous research implementing continuous testing tool performing controlled experiment order measure rather estimate effect tool order obtain qualitative feedback regarding developer perceptions tool continuous testing viewed natural extension continuous compilation modern ides integrated development envi ronments continuous compilation supply developer rapid feedback performing continuous parsing compilation indicating syntactic semantic errors immediately rather delaying notification user explicitly compiles code magpie 31 montana 14 systems pioneered practical incremental compilation enable continuous compilation large programs recompiling part program changed capability standard ides eclipse idea study appears first empirically evaluate productivity improvement provided continuous compilation programs small enough incremental compilation unnecessary continuous testing also viewed natural extension extreme programming 2 emphasizes importance unit test suites run frequently ensure code augmented refactored rapidly without regression errors continuous execution 11 programming example 6 15 editing example 20 17 provide continuous feedback developers results program one inputs program changes work abstracts entire output boolean result individual test case several authors use terms similar uses continuous compilation continuous testing plezbert 24 uses continuous compilation denote unrelated concept context justintime compilation continuous compilation occurs program running amortize reduce compilation costs speed execution program edited order assist development childers et al 5 use continuous compilation similar context siegel advocates continuous testing means frequent manual testing development process pairs developers 32 perpetual testing residual testing 23 also known continuous testing 33 monitors software forever field rather tested developer field aspects software never exercised developer testing need monitored software tomography 22 partitions monitoring task testing 21 many small subpieces distributed multiple sites instance testing might performed client sites enabling technology software tomography continuous evolution software deployment permits addition removal probes instrumentation code software running remotely 8 future work like experiment certain limitations see section 6 future research evaluate continuous testing new situations yet unproven instance industrial case studies would provide additional qualitative information regarding continuous testing plan provide continuous testing tools company performing software development real customers observe interview developers learn use tools impressions suggestions regarding experiment test suites ran quickly easily providing realtime notification several ways extend suites take longer run first intend integrate eclipse plugin one provided andreas zeller performs delta debugging 37 continuous testing gives early indication program change introduced regression error however test suites take long time run may multiple program changes last successful test run discovery regression error delta debugging reduce program changes minimum set causes regression error continuous testing application delta debugging reduce number program changes user must examine order understand cause regression error using continuous testing debugging entire process might made faster beneficial developer second continuous compilation large programs infeasible without incremental compilation see section 7 continuous testing large test suites require form incremental testing test suites many tests test selection 16 10 25 runs tests possibly affected recent change test prioritization 36 26 34 uses limited time available run tests likely reveal recently introduced error taken first steps toward showing continuous testing combined kinds test prioritization 28 continuing investigate traditional standard prioritization algorithms perform continuous testing however tests suites longrunning tests prioritization insufficient necessary use data collected previous test runs run parts tests may reveal recently introduced errors technique call test factoring example error introduced file input component compiler full endtoend test necessary find suffice run fileinput part test test generated data structures match observed previous run full test actively investigating 29 implementation test factoring integration continuous testing 9 conclusion continuous testing continuously runs regression tests background developer edits code notifies developer quickly errors discovered test intuition timely feedback valuable software developers especially feedback surprising augmented development environment continuous testing conducted controlled experiment student developers developers continuous testing significantly likely complete programming task without without working significantly longer shorter time effect could explained incidental features experimental setup continuous compilation regular testing differences experience preference developers study could manually run tests quickly single keystroke majority users continuous testing positive impres sions saying pointed attention problems would overlooked helped produce correct answers faster write better code staff said students quickly built intuitive approach using additional features 94 users said intended use tool coursework study 90 would recommend tool others users found feedback distracting negative effects productivity observed students used continuous compilation without continuous testing statistically significantly likely complete assignment without either tool although benefit great continuous testing continuous compilation proved popular feature modern ides knowledge first controlled experiment assess effects results lend weight claim improves productivity least developers positive results came despite problems tools despite continuous testing used situation necessarily give benefit initial development situation tests easy run complete quickly good reason hopeful continuous testing prove useful many kinds software developers acknowledgments thank students mits 6170 course participated study course staff helped us run sebastian elbaum anonymous reviewers provided helpful comments presentation research supported part nsf grants ccr0133580 ccr0234651 gift ibm 10 r role experimentation software engineering past extreme programming explained embrace change continuous compilation new approach aggressive adaptive code transformation watch programming demonstration investigations development evaluation reading techniques objectoriented code inspection methodology controlling size test suite continuous execution visiprog environment idea httpwww architecture montana open extensible programming environment incremental c version space algebra application programming demonstration insights regression testing lightweight structure text evaluating quality information models empirical testing conceptual model quality framework invariant inference static checking empirical evaluation editing example leveraging field data impact analysis regression testing continuous evolution software deployment residual test coverage monitoring time analyzing regression test selection techniques prioritizing test cases regression testing automated continuous testing speed software development reducing wasted development time via continuous testing automatic mock object creation test factoring continuous testing eclipse incremental compilation magpie continuous testing effectively prioritizing tests development environment tacoma community college elementary algebra syllabus study effective regression testing practice investigating readability statebased formal requirements specification languages tr editing example methodology controlling size test suite watch role experimentation software engineering object oriented software testing analyzing regression test selection techniques myampersandldquojust timemyampersandrdquo myampersandldquobetter late nevermyampersandrdquo architecture montana residual test coverage monitoring extreme programming explained yesterday program worked today continuous execution incremental compilation magpie system effectively prioritizing tests development environment test driven development investigating readability statebased formal requirements specification languages investigations development evaluation reading techniques objectoriented code inspection invariant inference static checking version space algebra application programming demonstration enduser software engineering assertions spreadsheet paradigm evaluating quality information models continuous compilation study effective regression testing practice lightweight structure text leveraging field data impact analysis regression testing reducing wasted development time via continuous testing mock object creation test factoring ctr david saff michael ernst test focusing test suites task hand proceedings 27th international conference software engineering may 1521 2005 st louis mo usa david saff michael ernst mock object creation test factoring proceedings acmsigplansigsoft workshop program analysis software tools engineering june 0708 2004 washington dc usa david saff michael ernst continuous testing eclipse proceedings 27th international conference software engineering may 1521 2005 st louis mo usa jaime spacco david hovemeyer william pugh eclipsebased course project snapshot submission system proceedings 2004 oopsla workshop eclipse technology exchange p5256 october 2424 2004 vancouver british columbia canada marat boshernitsan roongko doong alberto savoia daikon agitator lessons challenges building commercial tool developer testing proceedings 2006 international symposium software testing analysis july 1720 2006 portland maine usa steven p reiss visual representations executing programs journal visual languages computing v18 n2 p126148 april 2007 sebastian elbaum hui nee chin matthew b dwyer jonathan dokulil carving differential unit test cases system test cases proceedings 14th acm sigsoft international symposium foundations software engineering november 0511 2006 portland oregon usa hyunsook gregg rothermel alex kinneer prioritizing junit test cases empirical assessment costbenefits analysis empirical software engineering v11 n1 p3370 march 2006 antonia bertolino software testing research achievements challenges dreams 2007 future software engineering p85103 may 2325 2007
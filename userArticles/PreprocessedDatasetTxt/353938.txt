integrating objectoriented programming protected objects ada 95 integrating concurrent objectoriented programming active research topic since late 1980s plethora methods achieving integration majority approaches taken sequential objectoriented language made concurrent approaches taken concurrent language made objectoriented important latter class ada 95 language extension objectbased concurrent programming language ada 83 arguably ada 95 fully integrate models concurrency objectoriented programming example neither tasks protected objects extensible article discusses ways protected objects made extensible b introduction arguably ada 95 fully integrate models concurrent objectoriented programming atkinson weller 1993 wellings et al 1996 burns wellings 1998 example neither tasks protected objects exten sible ada 95 designed extensions ada 83 objectoriented programming part considered separate extensions concurrency model although consideration given abandoning protected types instead using javalike synchronised methods place public debate issue similarly public debate issues associated allowing protected types tasks extended purpose paper discuss ways ada 95 concurrency model better integrated objectoriented programming paper structured follows section 2 introduces main problems associated integration objectoriented concurrent programming section 3 describes main features ada 95 language relevant work section 4 argues ada 95 wellintegrated objectoriented concurrency model achieve better integration section 5 proposes adas protected type mechanism made extensible discusses main syntactic semantic issues sections 6 considers extensible protected types integrate adas general model abstraction inheritance sections 7 8 discuss proposals address inheritance anomaly used conjunction current objectoriented mechanisms section 9 presents extended examples section 10 draws conclusions work concurrent objectoriented programming integrating concurrent objectoriented programming active research topic since late 1980s plethora methods achieving integration see wyatt et al 1992 review majority approaches taken sequential objectoriented language made concurrent example various versions concurrent eiffel meyer 1993 caromel 1993 karaorman bruno 1993 approaches taken concurrent language made objectoriented important latter class ada 95 language extension objectbased concurrent programming language ada 83 full discussion language given next section general two main issues concurrent objectoriented programming ffl relationship concurrent activities objects distinction often concept active object definition execute concurrently active objects example maio et al 1989 mitchell wellings 1996 newman 1998 concurrent execution created use asynchronous method calls early returns method calls yonezawa et al 1986 yokote tororo 1987 corradi leonardi 1990 ffl way concurrent activities communicate synchronise yet avoid socalled inheritance anomaly matsuoka yonezawa see mitchell wellings 1996 summary various proposals perhaps interesting recent development concurrent objectoriented programming java lea 1997 oaks wong 1997 notion ally new language able design concurrency model within objectoriented framework without worrying backward compatibility sues java model integrates concurrency objectoriented framework combination active object concept asynchronous method calls descendants predefined class thread predefined methods run start start called new thread created executes run subclassing thread overriding run method allows application express active objects also possible obtain start run implementing interface runnable methods available thread class allow wide range thread control communication synchronisation achieved allowing method object specified synchronised synchronised methods execute mutual exclusion lock associated object classes java derived object class methods implement simple form condition synchronisation thread therefore wait notification single event used conjunction synchronised methods language provides functionality similar simple monitor hoare 1974 arguably java provides elegant although simplistic model objectoriented concurrency 3 ada 95 programming language ada 83 language allowed programs constructed several basic building blocks packages subprograms procedures functions tasks tasks considered types integrated typing model language type ada many instances task type declared tasks placed arrays records pointers tasks declared created ada 83 fully integrated concurrency model sequential components language tasks encapsulate data objects well tasks built using consistent underlying type model 31 dataoriented synchronization protected types ada 95 extends facilities ada 83 areas language weaknesses perceived one innovations introduction dataoriented communication synchronization protected types instances protected type called protected objects basically monitors hoare avoid disadvantages associated use lowlevel condition variables instead protected types may guarded entries similar provided conditional critical regions brinchhansen 1972 protected type ada 95 encapsulates data items accessed protected types operations declared shown following example protected type sharedint public operations procedure function get return entry waituntilzero private encapsulated data current private operations might follow operations protected type implemented corresponding body protected body sharedint procedure integer begin current value function get return integer begin return current entry waituntilzero current 0 entry barrier guard begin instances protected type ie protected objects declared like variable protected object named x operations shared object invoked following way somevariable xget calls operations protected type socalled protected actions guarantee mutually exclusive access protected object usual semantics multiple readers function calls readonly one writer procedure entry calls entry called barrier false call queued calling task blocked call finally executed otherwise call accepted executed protected action end procedure entry call barriers entries examined barrier become true possibly queued call executed part protected action ie without relinquishing mutual exclusion servicing entry queues repeated either queued calls barriers false protected action terminates following example illustrates use entries simple bounded buffer items taken buffer empty items put full protected type integerboundedbuffer entry entry get private array 1 10 integer first last natural nofitems natural 0 protected body integerboundedbuffer entry nofitems bufferlength begin buffer last last last mod bufferlength nofitems entry get nofitems 0 begin bufferfirst first first mod bufferlength nofitems nofitems get called nof items zero call queued another task calls put nof items incremented entry queues serviced call put finished barrier get true queued call allowed proceed thus unblocking task made call requeue statement form requeue targetentry allows entry put call already begun processing back entry queue requeue immediately leaves current entry requeues call initiates entry queue servicing requeued call executed control returned task made original call example requeue statement found section 92 within operations protected type attribute ecount represents number calls queue entry e potentially blocking calls particular entry calls forbidden within protected action language rule helps avoid deadlocks due nested monitors problem also avoids possible unbounded priority inversion might otherwise occur means procedure protected type may call procedures functions protected object entries functions protected type may call protected functions protected object avoid circumvent readonly restriction however may call protected functions procedures protected objects entries may call procedures functions entries may requeue another entry 32 objectorientation tagged types one main extensions ada 83 introduction objectoriented programming facilities designers ada 95 faced dilemma ada 83s facility encapsulation package unfortunately packages unlike tasks fully integrated typing model package types rather introduce classlike construct language done almost objectoriented languages ada 95 followed oberon wirth 1988 approach achieved objectorientation type extension designers argued ada 83 already ability derive types types override operations consequently objectorientation achieved via introduction tagged types tagged types ada 95 record types extended thus class ada represented following package objects type class tagged record data attributes class following primitive operations type procedure method1 class params sometype procedure method2 class params sometype objects class created used objects use objects params sometype begin contrast call objects method typical objectoriented paradigm call form objectmethod1params difference purely syntactical forms expressive power denote language construct namely call primitive operation tagged type call method class respectively inheritance ada 95 achieved extending parent type overriding primitive operations objects use objects package extendedobjects type extendedclass new class new data attributes overridden primitive operations procedure method1 extendedclass params sometype procedure method2 extendedclass params sometype new primitive operation procedure method3 extendedclass params sometype polymorphism ada 95 achieved use classwide types pointers classwide types possible example declare pointer hierarchy tagged types rooted place tree type extensions pointer reference object type hierarchy primitive method called passing dereferenced pointer runtime dispatching occurs correct operation type pointer access objectclassclass class indicates classwide type ap pointer new object derived objectclass dispatches appropriate method ada 95 dispatching occurs actual parameter call primitive operation classwide type contrasts objectoriented programming languages dispatching default eg java order force dispatching ada parameter must explicitly converted classwide type invoking primitive operation situation often occurs one primitive operation object wants dispatch primitive operation object called redispatching achieved converting operand classwide type shown following example type tagged record procedure p x procedure q x begin redispatch type new record procedure p x t1 procedure q redispatch explicitly converting parameter x classwide type invoking p conversion omitted called px call would statically bound procedure p regardless actual parameter passed q noted ada allows calls overridden operations statically bound outside defining tagged type example although extended objects package defined earlier extended class tagged type overridden method1 possible client write following eo extendedclass call overridden method explicitly arguably broken extended class abstraction perhaps disallowed explicit conversions safely done within overridden method wishes call parent method 33 objectoriented programming concurrency although task types protected types fully integrated typing model ada 95 possible create tagged protected type tagged task type designers shied away possibility partly felt fully integrating objectoriented programming concurrency wellunderstood topic therefore suitable iso standard professional programming language also inevitable concerns scope potential language changes proposed large ada community accept spite level integration tagged types tasks protected objects tagged types part typing mechanism therefore used protected types tasks types way types indeed paradigms use developed see burns wellings 1998 chapter 13 however approaches cannot get around basic limitation protected types task types cannot extended making concurrent programming ada 95 objectoriented dust beginning settle around ada 95 standard important begin look future objectoriented paradigm largely welcomed ada community even realtime community originally sceptical facilities worried impact would predictability beginning see advantages furthermore people become proficient use language begin realise better integration concurrency objectoriented features would beneficial goal paper continue debate best achieve full integration future version language following classes basic types ada ffl scalar types integer types enumeration types real types etc ffl structured types record types array types ffl protected types ffl task types ffl access types access types special provide mechanism pointers types created note although access types subprograms procedures functions created subprograms basic type language providing tagged types ada 95 provided mechanism whereby structured type extended stressed though record types extended array types understandable record primary mechanism grouping together items represent heterogeneous attributes objects furthermore variable length array manipulation already catered language similarly scalar types already extended using subtypes derived types allowing records extended thus consistent allowing variable length arrays subtypes derived types protected type similar record groups items together case protected type items must accessed mutual exclusion would consistent allow protected type extended additional items following sections discuss issues allowing extensible protected types issues associated extensible task types subject ongoing research 5 extensible protected types requirements extensible protected types easy articulate par ticular extensible tagged protected types allow ffl new data fields added ffl new functions procedures entries added ffl functions procedures entries overridden classwide programming performed simple requirements raise many complex semantic issues proposed extensions fully integrated ada model objectoriented programming 51 declaration primitive operations consistency usage elsewhere ada word tagged indicates protected type extensible described section 31 protected type encapsulates operations performed protected data consequently primitive operations tagged protected type effect already defined course similar primitive operations tagged types spirit syntax since primitive operations defined declared package specification tagged type consider following example protected type tagged procedure w function x return entry private data attributes w x viewed primitive operations interestingly call ox takes syntactic form similar objectoriented languages indeed adas protected object syntax conflict languages usual representation object see section 32 52 inheritance tagged protected types extended manner tagged types hence protected type t1 new procedure w override tw procedure z new method private new attributes issue overriding protected entries considered section 54 one consideration whether private fields parent type seen child type t1 protected types data declared private changed without first obtaining mutual exclusion four possible approaches visibility issue 1 prevent child protected object accessing parents data would limit childs power modify behaviour parent object allowed invoke operations parent 2 allow child protected object full access private data declared parent would flexible potential compromise parent abstraction 3 provide additional keyword distinguish data fully private data private visible child types keyword would used similar way private much like c uses keyword protected permit descendent classes direct access inherited data items 4 allow child protected types access private components parent protected type declared child package parent protected type declared would slightly inconsistent way protected types currently work ada protected types rely using packages provide encapsulation remainder paper assume second method provides flexibility requires new keywords also consistent normal tagged types procedure child protected type calls procedure function parent wait obtain lock protected object entering parent otherwise deadlock would occur one lock instance protected type lock used protected object converted parent type consistent current ada approach one procedurefunction calls another protected object 53 dispatching redispatching given hierarchy tagged protected types possible create classwide types accesses classwide types example type pt access protected type tclass p pt new type hierarchy dispatches appropriate projected object course within pw possible convert back classwide type redispatch another primitive operation unfortunately operation inside tagged protected type option converting object originally dispatched classwide type object passed implicitly operation two possible strategies taken 1 make calls operations within tagged protected type dispatching 2 use form syntactic change make possible specify whether redispatch first strategy ideal often useful able call operation type parent type without redispatching addition first strategy inconsistent ordinary tagged types redispatching automatic solution according second strategy uses calls form typeoperation type type implicit protected object con verted following example syntax redispatch protected body procedure p begin tclass indicates type protected object hierarchy type tclass viewed type passed implicitly p view converted allows define q procedure call syntax also necessary allow operation call overridden operation parent example protected body t1 extension procedure w overrides w procedure begin calls parent operation new syntax conflict part language strictly type precedes period could instance protected type call could misinterpreted external call alternative syntactic representation might typeoperation ada reference manual intermetrics 1995 distinguishes external internal calls use full protected object name burns wellings 1998 call would bounded error requeuing also lead situations redispatching desirable procedures redispatching would occur explicitly requested example protected type requeue e would dispatch whereas requeue tclasse would dispatch requeuing parent entry would require barrier reevaluation requeues protected objects accept statements tasks could also involve dispatching correct operation similar way 54 entry calls allowing entries primitive operations extensible protected types raises many interrelated complex issues include 1 child entry call parents entry objectoriented per spective essential allow child entry call parent reuse achieved unfortunately protected object perspec tive calling entry potentially suspending operation allowed within body protected operation see section 31 clear compromise required child entry must able extend facilities provided parent 2 relationship parents barrier childs barrier three possibilities relationship child weaken parents barrier child strengthen parents barrier frlund frlund 1992 suggests child method extends parents method child must restrictive synchronisation constraints order ensure parents state remains consistent however also indicates behaviour child method totally redefines parent possible redefine synchronisation constraints alternatively also argued synchronisation constraints child weaken par ent strengthen order avoid violating substitutability property subtypes liskov wing 1994 3 many queues implementation need maintain overridden relationship parent child barrier necessary maintain separate entry queue overridden entry one queue count attribute reflect hence count might give different values called parent called child problem using separate entry queues different barriers overridden overriding entries harder theorise order entries serviced normally entries serviced firstin firstout fifo order separate queues separate barrier might possible example later call overridden entry accepted perhaps noted child access parents state barrier strengthening sufficient condition ensure consistency state child make barrier false calling entry see also discussion section 541 earlier call overriding entry barrier overridden entry becomes true overriding entrys barrier remaining false 4 happens parent entry requeues another entry entry call requeues another entry control returned calling entry task originally made entry call see section 31 means child entry calls parent parent entry requeues control returned child given code parent invisible child would effectively prohibit child entry undertaking postprocessing order reduce number options discussion assumed child entries must strengthen parents barrier remainder paper syntax used indicate z avoid body child protected object depend body parent necessary move declaration barrier body specification protected type private part consider protected type tagged private integer 0 barrier given private part protected type t1 new private entry e 0 call made ae would statically defined call t1e would subject barrier ecount 1 0 barrier would repeated entry body even barrier strengthening issue barrier evaluation must addressed consider case tagged protected object converted parent type using view conversion external protected type entry called type clear barrier needs passed three possible strategies taken 1 use barrier associated exact entry called ignoring barrier associated entry overrides exact entry parent type know new data added child could argued allowing entry parent execute child strengthened barrier entry safe unfortunately case consider bounded buffer extended put get operations locked lockable buffer viewed converted normal buffer getput called buffer barriers evaluated locked buffer accessible even locked furthermore approach would z short circuit control forms could also made available also mean would separate entry queues overridden entries problems associated maintaining one entry queue per overridden entry already mentioned 2 use barrier associated entry dispatching would occur object converted class wide type ie barrier entry objects actual type strongest barrier would allow safe redispatching entry body method results one entry queue per entry instead one entry every overridden entry however perhaps misleading parents code executed childs barrier expression evaluated 3 allow view conversions inside protected object require external calls dispatching calls hence one entry queue external calls would always invoke primitive operations objects actual type problem approach currently ada dispatch default consequently approach would introduce inconsistency way tagged types extensible protected types treated remainder paper assumed external calls protected objects always dispatch x 541 calling parent entry parent requeues far section discussed various issues associated overridden entry calls however details child entry actually calls parent left unspecified main problem ada forbids entry explicitly calling another entry see section 31 several approaches problem 1 use requeue although ada forbids nested entry calls allow entry call requeued hence child requeue parent requeue gives impression calling parent possible child postprocessing parent entry executed call returns caller child entry requeue parents barrier would reevaluated given child barrier strengthened parents barrier parents barrier would normally open case exception raised queue call would require one entry queue furthermore atomicity maintained parent requeue part protected action parent entry must serviced entries whose barriers also happen open hence requeue slightly different semantics requeue unrelated entries 2 allow child entry call parent entry treat call procedure call clear calling parent entry different x harmonize regular tagged types new pragma could introduced called ex ternal calls always dispatch applied regular tagged types requeue approach multiple entry queues need relationship parent child barriers approach already ruled previous subsection normal entry call special syntax already introduced facilitate see section 53 approach parent call viewed procedure call therefore potentially suspending operation however parents barrier still potential cause concern one option view barrier assertion raise exception true k option test barrier based premise barrier true child called therefore need reevaluated whole protected action completed either approaches still problem control returned child parent entry requeues requests entries servicing course could made illegal exception raised however requeue essential part ada 95 model effectively forbid use extensible protected types would severe restriction remainder paper assume model parent calls treated procedure calls issue assertion left open requeue parent allowed consequence postprocessing allowed parent call 6 integration full ada 95 model section considered basic extensible protected type model course proposal introduction facility must also consider full implications introduction section considers following topics ffl private types abstract types ffl generics mixin inheritance 61 private types encapsulation mechanism ada 95 package gives programmer great control visibility entities declared package par ticular ada 95 supports notion private limited private types ie types whose internal structure hidden clients packages types declared modified primitive operations declared packages types protected type limited type hence necessary show extensible protected types integrate limited private types following illustrates easily achieved order make type private full definition moved private part package also done extensible protected types package example1 protected type pt0 tagged private private k special consideration would need given barriers use count attribute parent since clearly change child begins execution protected type pt0 tagged primitive operations private data items etc note example primitive operations type pt0 declared private part package thus visible child packages package example1 packages cannot anything type pt0 access types primitive operations nevertheless construct useful classwide programming using access types eg type ptref access pt0class private types also give finer control visibility one might declare type make primitive operations publicly visible primitive operations would private thus visible child packages example package example2 protected type pt1 tagged primitive operations visible anywhere private data items etc private protected type pt1 tagged private primitive operations visible child packages private data items etc note public declaration type pt1 uses private instead private start private section supposed give syntactical indication public view pt1 incomplete type must completed later private part package alternatively protected type declared private extension given protected type pt2 package base protected type pt2 tagged private private extension written base package example3 protected type pt3 new basept2 private private protected type pt3 new basept2 additional primitive operations private additional data items features inherited pt2 publicly visible additional features introduced private part package private hence visible child packages package example3 private types used ada 95 implement hidden semihidden inheritance two forms implementation inheritance opposed interface heritance ie subtyping instance one may declare tagged type publicly root type ie derived type privately deriving another tagged type reuse latters implementation hidden inheritance also possible extended protected types given package base hidden inheritance pt2 implemented follows base package example4 public view pt4 root type protected type pt4 tagged primitive operations visible anywhere private data items etc private private view pt4 derived pt2 protected type pt4 new basept2 additional primitive operations visible child packages private additional data items etc derivation pt4 pt2 publicly visible operations data items inherited pt2 cannot accessed packages primitive operations inherited pt2 fact visible public view pt4 pt4 must redeclare implement callthroughs privately inherited primitive operations pt2 child packages package example4 derivation relationship exposed hence inherited features accessible child packages semihidden inheritance similar spirit exposes part inheritance relation given existing hierarchy extensible protected types package example5base protected type pt5 tagged private protected type pt6 new pt5 private one declare new type pt7 uses interface inheritance pt5 implementation inheritance type derived pt5 eg example5base use example5base package example5 protected type pt7 new pt5 private private protected type pt7 new pt6 private examples show extensible protected types offer expressive power concerning private types ordinary tagged types fact protected types encapsulation unit right addition encapsulation provided packages extensible protected types offer even greater visibility control ordinary tagged types primitive operations extensible protected type declared types private section visible within type within child extension type combining kind visibility similar javas protected declarator visibility rules packages gives visibility specifications exist ordinary tagged types one difficulty scheme though currently possible ada 95 define limited private type implemented protected type raises question whether following legal package example6 type tagged limited private private protected type tagged private although child packages could treat extensible protected type client packages could little type furthermore mixture protected nonprotected views one type may give rise incalculable implementation problems cases accesses object would done mutual exclusion even view objects type protected simply full view protected type consequently kind private completion shown example6 probably best disallowed 62 abstract extensible protected types ada 95 allows tagged types primitive operations abstract means instances type cannot created abstract type extension another abstract type concrete tagged type extension abstract type abstract primitive operation declared abstract type however abstract type nonabstract primitive operations ada 95 model easily applied extensible protected types following examples illustrate integration protected type ept abstract tagged concrete operations function f return procedure p abstract operations function f1 return abstract procedure p1 abstract entry e1 abstract private one issue perhaps obvious concerns whether abstract entry barrier one hand abstract entry cannot called barrier superfluous hand programmer may want define abstraction appropriate guard abstract entry example protected type lockableoperation abstract tagged procedure lock procedure unlock entry operation abstract private entry operation locked bodies lock unlock set locked variable corresponding values barrier strengthening rule locked barrier automatically enforced concrete implementation operation remainder paper assume abstract entries bar riers example rewritten concrete entry operation null body noted however concrete null operation one cannot force concrete children supply implementation entry abstract entry one 63 generics mixin inheritance ada 95 support multiple inheritance however support various approaches used achieve desired affect one approach mixin inheritance generic package take parameter tagged type declared version ada extensible protected types must also allow parameters generics hence take part mixin inheritance normal tagged types two kinds generic formal parameters defined type basetype abstract protected tagged private type derivedfrom abstract new protected derived private former generic body knowledge extensible protected type actual parameter latter actual type must type tree extensible protected types rooted derived unfortunately facilities enough cope situations involving entries one causes inheritance anomaly matsuoka yonezawa 1993see also section 7 adding code child object affects synchronisation code parent consider case predefined lock mixed protected object define lockable version without extra functionality way express reasons generic modifier entry used mean entries actual parameter lockable mixin type achieved type basetype abstract protected tagged private package lockableg protected type lockabletype new basetype procedure lock procedure unlock private entry locked lockableg code entry locked indicates entries parent protected type barriers strengthened boolean expression locked entry feature makes possible modify barriers entries unknown time generic unit written time generic unit instantiated entries actual generic parameter supplied base type known entry denotes welldefined set primitive operations generic barrier modifier similar frlunds allexcept specifier frlund 1992 except latter also applies primitive operations added later derivations whereas entry new primitive operations added derivations programmers responsibility make sure new entries get right barriers ie include locked clearly effect limited entries procedures unaffected gives rise following anomaly barriers need strengthened adding condition locked may well inherited procedures need similarly guarded cannot done without introducing mechanism overriding procedures entries adaspecific inheritance anomaly discussed next section 7 inheritance anomaly combination objectoriented paradigm mechanisms concurrent programming may give rise socalled inheritance anomaly matsuoka yonezawa 1993 inheritance anomaly exists synchronization operations class local may depend whole set operations present class subclass adds new operations may therefore become necessary change synchronization defined parent class account new operations section examines extensible protected types deal inheritance anomaly synchronization extensible protected types done via entry barriers entry barrier interpreted two slightly different ways ffl precondition must become guard concurrency introduced objectoriented programming language meyer 1997 ar gues sense entries equivalent partial operations herlihy wing 1994 ffl synchronization constraint use entry barriers ie guards synchronization makes extended protected types immune one kinds inheritance anomalies identified matsuoka yonezawa 1993 guards subject inheritance anomalies caused partitioning states avoid major break encapsulation mandatory concurrent objectoriented programming language way reuse existing synchronization code defined parent class incrementally modify inherited synchronization child class proposal given clause incrementally modifies inherited entry barrier hence inherited synchronization code inheritance anomalies ada 95 extended protected types still occur though mitchell wellings 1996 argue root cause inheritance anomalies lies lack expressive power concurrent objectoriented programming languages five criteria identified bloom 1979 fulfilled inheritance anomalies may occur ada 95 satisfies three criteria synchronization based history information cannot expressed directly using entry barriers local state must instead used record execution history synchronization based request parameter values also possible directly ada 95 example resource controller shown section 92 exhibits inheritance anomalies barrier entry allocate n cannot depend parameter n internal queue wait n must used instead synchronization constraint wait n historysensitive operation allowed call deallocate freed resources result deallocate must overridden record history information local state although synchronization constraints deallocate well functionality remain unchanged addition extensible protected types may suffer ada specific inheritance anomaly synchronization done via barriers entries synchronised procedures synchronization constraints subtype restrict inherited primitive operation implemented procedure parent type subtype would override procedure entry however using classwide programming task may assume protected operation implemented procedure base type indicates therefore nonblocking runtime call might dispatch entry block barrier would make call illegal occurred within protected action reasons overriding procedures entries allowed extensible protected types discussed section 63 adaspecific inheritance anomalies might arise mixin inheritance used avoided providing additional functionality generics new generic barrier modifier entry alone sufficient avoid introduction new adaspecific inheritance anomalies generic mixin class must define synchronization complete class resulting combination mixin class priori unknown base class entry barrier modifier introduced allows mixin class impose synchronization constraints unknown set inherited operations however also necessary way mixin class adapt synchronization additional primitive operations synchronization constraints imposed actual base type generic mixin instantiated base type create new result type must possible parametrise mixins synchronization based upon base type order obtain correct synchronization new result type parametrisation could obtained still topic ongoing research 8 interaction tagged types far discussion focused protected types extended section considers interaction tagged types protected tagged types consider following defines simple buffer package simplebuffer type datat tagged private procedure write procedure read private type datat tagged record buffer used safely sequential environment make prewritten buffer safe concurrent access requires encapsulated protected type following illustrates easily achieved protected type buffer tagged procedure write procedure read x integer private buffer accessed protected interface course buffer protected type extended following dispatch buffer type b access bufferclass new alternatively simple bufferdata made protected encapsulated following protected type buffer tagged procedure write procedure read private would allow buffer accessed directly without protection overheads situation dictates safe combining extensible protected types classwide tagged types allow even powerful paradigms consider protected type buffer tagged procedure write simplebufferdatatclass procedure read singledatatclass private protected type tagged type easily extended program arrange dispatching buffer within writeread routines using access discriminants data encapsulated protected concurrent use type ad access simplebufferdatatclass protected type tagged normal discriminant procedure write procedure read x integer private type b access bufferclass new buffernew simplebufferdatat b1 dispatch correct buffer writeread dispatch correct data encapsulated 9 examples section presents two examples illustrating principles discussed paper assume external calls dispatch postprocessing parent calls checking parents barriers child access parents state 91 signals concurrent programming signals often used inform tasks events occurred signals often different forms transient persistent signals wake single task wake tasks sections illustrates abstractions built using extensible protected types consider first abstract definition signal package signals protected type signal abstract procedure send entry wait abstract private signalarrived type allsignals access signalclass package body signals protected body signal abstract procedure send begin signalarrived true create persistent signal signals use signals package persistentsignals protected type persistentsignal new signal entry wait private entry wait signalarrived package body persistentsignals protected body type persistentsignal entry wait signalarrived begin signalarrived false create transient signal signals use signals package transientsignals protected type transientsignal new signal procedure send entry wait private entry wait signalarrived package body transientsignals protected body type transientsignal procedure send begin return entry wait signalarrived begin signalarrived false create signal release tasks type basesignal new protected signal package releaseallsignals protected type releaseallsignal new basesignal entry wait private entry wait true package body releaseallsignals protected body releaseallsignal entry wait true begin waitcount 0 return basesignalwait course mysignal allsignals dispatch appropriate signal handler 92 advanced resource control resource allocation fundamental problem aspects concurrent pro gramming consideration exercises blooms criteria see section 7 forms appropriate basis assessing synchronisation mechanisms concurrent languages ada consider problem constructing resource controller allocates resource group client agents number instances resource number bounded contention possible must catered design program mitchell wellings 1996 propose following resource controller problem benchmark concurrent objectoriented programming languages implement resource controller 4 operations ffl allocate allocate one resource ffl deallocate deallocate resource thus becomes available allocation ffl hold inhibit allocation call ffl resume allows allocation following constraints operations 1 allocate accepted resources available controller held synchronization local state history 2 deallocate accepted resources allocated synchronization local state 3 calls hold must serviced calls allocate syn chronization type request 4 calls resume accepted controller held synchronization history information ada 95 deontic logic operators history information expressed directly barriers however possible use local state variables record execution history following solution simplifies presentation modelling resources counter indicating number free resources requirement 2 interpreted meaning exception raised attempt made deallocate resources yet allocated package rsccontroller maxresourcesavailable constant natural 100 example noresourcesallocated raised deallocate protected type simpleresourcecontroller tagged entry allocate procedure deallocate entry hold entry resume private entry allocate free 0 locked req 1 entry hold locked entry resume locked req 4 body package simply keeps track resources taken freed sets resets locked variable package body rsccontroller protected body simpleresourcecontroller entry allocate free 0 locked begin free free 1 allocate resource taken procedure deallocate begin raise noresourcesallocated free return resource taken taken entry hold locked begin locked true entry resume locked begin locked false rsccontroller mitchell wellings 1996 extend problem consider impact inheritance extend resource controller add method allocate n takes integer parameter n allocates n resources extension subject following additional requirements 5 calls allocate n accepted least available resources 6 calls deallocate must serviced calls allocate allocate n additional constraint calls must serviced fifo within priorities fashion ignored mitchell wellings 1996 also implement ada 95 would done pragmas note specification flawed implementation shown mitchell wellings 1996 also exhibits flaw deallocate called resources allocated resource controller deadlock service calls deallocate allocate allocate n implemen tation corrected implicitly calling deallocate resources allocated viewed error exception raised requirement 5 implemented requeueing wait n enough resources available requirement 6 implicitly fulfilled calls deallocate never queued since deallocate implemented procedure use rsccontroller package advancedcontroller protected type advancedresourcecontroller new simpleresourcecontroller entry allocaten n natural procedure deallocate adaspecific anomaly barriers cannot access parameters must also override method set changed see private entry allocaten free 0 locked req 1 note ada allow access parameters barrier purely efficiency reasons cases must ada always imple mented using internal suspension method statement everything necessary overhead ada 95 implement equivalent access parameters barriers indicates two waitforn entry queues one currently shall used two queues used one queue used trying satisfy requests requests cannot satisfied requeued roles two queues swapped avoids problems calling tasks different priorities changed something deallocated needed correct implementation allocaten waitforn reset outstanding calls routines serviced actually encodes history information waitforn accepted call deallocate entry waitforn queue boolean n natural entry waitforn queue boolean locked holdcount 0 private entry used allocaten requeue less n resources currently available package body advancedcontroller protected body advancedresourcecontroller procedure deallocate overridden account new history information encoding needed access parameter barrier allocaten begin changed true entry allocaten n natural free 0 locked begin free n free free n taken else requeue waitforncurrentqueue entry waitforn queue booleann natural locked holdcount 0 changed begin currentqueue currentqueue changed false free n free free n taken else requeue waitfornnot queue conclusions paper argued ada 95s model concurrency well integrated objectoriented model focussed issue make protected types extensible yet avoid pitfalls inheritance anomaly approach adopted introduce notion tagged protected type underlying philosophy normal tagged types although requirements extensible protected types easily articu lated many potential solutions paper explored major issues appropriate made concrete proposals ada extremely expressive language many orthogonal features paper shown introduction extensible protected types undermine orthogonality proposal fits well limited private types generics normal tagged types work presented however without difficulties major one associated overridden entries fundamental principle objectoriented programming child object build upon functionality provided parent child call parent access functionality therefore extend ada calling entry potentially suspending operation allowed within protected object hence overriding entries gives conflict objectoriented protected type models furthermore ada allows entry requeue call another entry requeued entry serviced control returned entry issued requeue request consequently parent entry issues requeue control never returned child causes conflict objectoriented programming model child allowed undertake postprocessing parent call paper discussed conflicts detail proposed range potential compromise solutions ada 95 important language international standard objectoriented realtime distributed programming important continues evolve paper tried contribute growing debate best fully integrate protected type model ada objectoriented model clear introducing extensible protected types large change ada one acceptable next major revision language many complications come ability override entries one possible major simplification proposal made would allow facilities entries would considered final using java terminology simplification might lead early transition path current ada fully integrated version acknowledgements authors gratefully acknowledge contributions oliver kiddle kristina lundqvist ideas discussed paper also would like acknowledge participants 9th international workshop realtime ada issues gave us feedback initial ideas r integrating inheritance synchronisation ada9x evaluating synchronisation mechanisms structured multiprogramming concurrency ada toward method objectoriented concurrent program ming parellism objectoriented programming languages inheritance synchronization constraints cocur rent objectoriented programming languages linearizability correctness criterion concurrent objects extended protected types concurrent programming java behavioral notion subtyping dragoon adabased object oriented language concurrent analysis inheritance anomaly objectoriented concurrent programming languages systematic concurrent objectoriented programming extendable dispatchable task communication mechanisms classic programming language design synchronous concurrent object oriented languages java thread programming language oberon parallelism objectoriented languages survey concurrent programming concurrents malltalk tr objectoriented concurrent programming abcl1 concurrent programming concurrent smalltalk programming language oberon linearizability correctness condition concurrent objects systematic concurrent objectoriented programming toward method objectoriented concurrent programming introducing concurrency sequential language analysis inheritance anomaly objectoriented concurrent programming languages integrating inheritance synchronization ada9x behavioral notion subtyping concurrency ada java threads objectoriented software construction 2nd ed extensible protected types concurrency distribution objectoriented programming classic programming language design synchronous concurrent object oriented languages extendable dispatchable task communication mechanisms monitors structured multiprogramming parallelism objectoriented languages inheritance synchronization constraints concurrent objectoriented programming languages evaluating synchronization mechanisms ctr rodrigo garca garca alfred strohmeier experiences report implementation epts gnat acm sigada ada letters vxxii n4 december 2002 albert k cheng james ras implementation priority ceiling protocol ada2005 acm sigada ada letters vxxvii n1 p2439 april 2007 knut h pedersen constantinos constantinides aspectada aspect oriented programming ada95 acm sigada ada letters vxxv n4 p7992 december 2005 gustaf naeser kristina lundqvist lars asplund temporal skeletons verifying time acm sigada ada letters vxxv n4 p4956 december 2005 aaron w keen tingjian ge justin maris ronald olsson jr flexible distributed programming extended java acm transactions programming languages systems toplas v26 n3 p578608 may 2004
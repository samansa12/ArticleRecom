bounded delay timing analysis class csp programs describe algebraic technique performing timing analysis class asynchronous circuits described csp programs including martins probe operator restrictions orcausality guard selection either completely free mutually exclusive description transformed safe petri net interval time delays specified places net timing analysis perform determines extreme separation time two communication actions csp program possible timed executions system formally define problem propose algorithm solution demonstrate polynomial running time nontrivial parameterized example petri nets 3000 nodes 1016 reachable states analyzed using techniques b introduction much work past decade synthesis speedindependent quasidelay insensitive circuits develop paper basic results allow designers reason thus synthesize nonspeedindependent timed circuits whether designing timed asynchronous circuits good idea debated ad infinitum event designers applying seat pants techniques design timed circuits years work used verify designs vision however much broad includes complete synthesis methodology developing robust highperformance timed designs description methodology beyond scope paper major motivation addressing difficult timing analysis problem asynchronous circuit specified using csp set concurrent processes description transformed safe petri net input timing analysis algorithm analysis determines extreme case separation time two communication actions csp specification timed executions determining tight bounds separation times communication actions system events provides information used answer many different temporal questions example may wish know bounds cycle period asynchronous component use drive clock signal synchronous component similar information used generate worstcase amortized performance bounds may also perform minimum separation analyses order determine feasible remove circuitry speedindependent implementation 16 algorithm performs sorts analyses useful many contexts many levels abstraction separation analyses highlevel used help designer choose among potential designs perform given computation lower level used determine correctness implementation eg whether isochronic fork assumptions valid 12 related work timing analysis verification concurrent systems comes variety different research communities including realtime systems vlsi cad operations research timed automata 1 one powerful models automated verification methods exists timed automaton number clocks timers whose values used guards transitions automaton models extensively studied several algorithms exist determining timing properties timed automata 8 9 untimed case timed automata suffer state explosion problem constructing cross product component specifications furthermore verification time proportional product maximum value clocks also proportional number permutations clocks improve runtime complexity burch 7 extends trace theory discrete time still uses automatabased methods verification approach also suffers exponential runtime size delay values avoids factorial associated permutations clocks orbits 19 uses convex regions represent sets timed states thus avoids explicit enumeration individual discrete timed state orbits based petri net model augmented timing information petri net based approaches include timed petri nets 18 time petri nets 3 timed petri nets fixed delay associated transitions time petri nets use general model delay ranges associated transitions paper composed seven sections follow introduction description csp specification language translation petri nets timed untimed execution semantics petri nets introduced section 3 algorithm performing timing analysis petri nets describe section 4 5 section 6 presents parameterizable example used benchmark performance algorithm finally section 7 summarizes contributions paper specification describe specification language show translate specification intermediate form suitable timing analysis 21 csp programs specify computations using csp martin style 14 simplify timing analysis restrict expressive power specification language first exclude disjunctions guards correspond orcausality known difficult 11 15 second require semantic property untimed executions either choice guards completely free guards identically true one guard evaluates true shall see section 32 allows use untimed executions determining possible timed behaviors important simplification timing analysis problem restrictions still allow analysis large interesting class csp programs including many programs specifying implementations abstractions asynchronous control circuits syntax restricted csp program p shown table 1 figure 1a shows simple csp program three processes table 1 syntax restricted csp p program statement c communication action e expression b guard term terminal symbols x x represent variable identifier communication channel respectively 22 petri nets csp specification translated safe petri net direct input timing analysis net n tuple finite disjoint nonempty sets respectively places transitions f theta theta flow relation petri net sigma pair n 0 n net initial marking see 17 details petri net model graphically petri net represented bipartite graph whose nodes whose edges represent flow relation f circles represent places straight lines represent transitions initial marking shown dots tokens figure 1b shows simple petri net element x preset postset x defined fy fy marking represents global state system transition enabled marking input place marked ie 8s firing enabled transition produces new marking 0 constructed removing token places preset adding token places postset transformation firing denoted tim 0 let mi denote set markings reachable marking 23 translation csp petri nets csp specification translated safe petri net petri net transitions used model communication synchronizations places used model control choice petri net constructed syntax directed translation 4 mapping amounts introducing single token corresponding program counter communicating process variable x modeled two places x 0 x 1 x true x 1 marked otherwise x 0 marked constructing nets process transitions combined corresponding matching communication actions figure 1 shows simple csp specification corresponding petri net c e f b figure 1 csp specification b corresponding petri net sigma two complications translation one consistently label petri net transitions corresponding communication actions occur different numbers times connected processes labeling problem illustrated simplest form following csp program composed divide two counter connected trivial environment x communication p 1 connect two x communications p 2 solve labeling problem introducing separate label possible pairing communication actions 4 example introduce two labels x 0 x 1 choice possible communications obtaining nets shown figure 2 figure 2 petri nets individual processes divide two counter second complication translation probe construct x probed communication action x completed immediately split two first half implements guard selection statement second half implements actual communication action figure 3 illustrates translation 24 properties petri net petri net obtained csp specification following properties figure 3 petri net incomplete csp program ffl petri net safe ie never one token place choice place ie jsfflj 1 either extended free choice unique choice place extended free choice place unique choice one successor transitions ever becomes enabled denote number transitions sffl enabled marking place unique choice 8m 2 1 place 2 net figure 1b 3 execution semantics represent set untimed executions introduce notion process intuitively process unfolding petri net represents one possible finite execution petri net processes used give timing semantics petri net process define set legal assignments time stamps transitions process 31 process petri net sigma net n labeling lab subscript f distinguish nets sigma net n acyclic without choice ie without branched places n lab must satisfy appropriate properties interpreted execution sigma 5 21 figure 4 shows process petri net figure 1b true choice net place 2 nondeterministic selection either transition c process represents execution first time transition c fires next time transition fires denote untimed executions petri net sigma set process sigmag safe petri net finite number reachable markings processes property cut places corresponds reachable marking sigma 5 lemma 27 therefore sufficiently long processes contain repeated segments processes represent potentially infinite e c f figure 4 process petri net sigma figure 1b places transitions process labeled using lab function names corresponding places transitions sigma set processes pisigma finite graph call process automaton vertices process automaton correspond markings sigma edges annotated segments processes let v 0 denote vertex corresponding initial marking 0 consider path p process automaton vertex u v denoted u p v p process obtained concatenating process segments annotated edges p process automaton property pref p v path process automaton pref set prefixes defined partial orders 21 process construct process automaton without first constructing reachability graph 6 10 concurrency net size process automaton equal size reachability graph however high degree concurrency process automaton considerably smaller figure 5 shows process automaton associated processes petri net figure 1b process figure 4 constructed f e figure 5 left process automaton petri net figure 1b three process segments annotated edges shown right labeled elements sigma sigma 32 timed execution incorporate timing petri net model associate delay bounds place net lower delay bound ds 2 r 6gamma upper delay bound ds 2 r 6gamma f1g r 6gamma set nonnegative real numbers satisfy 0 delay bounds restrict possible executions petri net timed execution net token added place earliest becomes available transition sffl later latest ds units later transition must fire available tokens places fflt unless firing transition disabled firing another transition firing instantaneous formally timing assignment process function maps transitions process time values definition 31 let sigma safe petri net let process sigma consider cut c let enabled sigma set transitions enabled corresponding marking c timing assignment transition 2 enabled earliest latest global firing time given starttimeb denotes set elements mapped lab note c lab gamma1 fflt nonempty enabled marking c function starttime takes place returns time token entered place labb ie e transition e set starttimeb 0 timing assignment consistent cut c timing assignment process consistent consistent place cuts c process let pi timed sigma set timed executions sigma timed pisigma exists consistent timing assignment restrictions csp specification section 2 crafted set untimed timed processes underlying petri net equivalent allows us use process automaton enumerate possible processes without referring timing information perform timing analysis process individually prove need two lemmas first states always possible find timing assignment satisfying 1 definition 31 second lemma states simple structural property extended free choice places lemma 32 let sigma safe petri net 2 sigma earliestt latestt process sigma timing assignment necessarily consistent proof definition earliest latest fact place lemma 33 let sigma petri net let 2 sigma extended free choice place 8t proof contradiction assume fflt 1 6 fflt 2 place 0 assume without loss generality 0 fflt 1 fflt 2 definition extended free choice place follows ffl premise lemma 2 sffl thus also 0 ffl simple fact pre postsets 2 xffl x 2 ffly 2 0 ffl 0 fflt 2 contradicting assumption 2 theorem 34 let sigma safe petri net choice either extended free choice unique choice pi timed proof clearly pi timed sigma pisigma show pisigma pi timed sigma ie exists consistent timing assignment 2 pisigma prove cuts c b 2 c constraint 2 subsumed constraint 1 lemma 32 follows process exists consistent timing assignment observe labbffl labbffl thus labbffl enabled nonempty labbffl enabled let c cut let b place c 2 trivially satisfied bffl 6 let e one element bffl places b process jbfflj 1 let place sigma corresponding b ie labb observation states labe 2 enabled consider two cases labe element sffl enabled 2 reduces e latestlabe 1 choice place either extended free choice unique choice extended free choice lemma 33 definition latest follows 8t minimization idempotent labe 2 reduces e latestlabe unique choice definition unique choice thus labe element sffl enabled condition 2 reduces e latestlabe4 timing analysis formally defined timing semantics petri net state timing analysis problem present algorithm solving problem 41 problem formulation given two transitions petri net sigma 2 sigma wish determine extremecase separation time related firings let b pi set triples dst 2 pisigma src dst transitions process labt src labt dst set b pi used describe possible processes distinguished transitions src dst appropriate relationship timing analysis perform b pi consistent timing assignments determine largest ffi smallest delta transitions src dst must related order timing analysis yield interesting information consider finding maximum time consecutive firings transition figure 1b corresponding maximum cycle time transition separation occurrences src dst transitions must restricted elements b pi property transition src dst label example one elements b pi process figure 4 src dst leftmost rightmost transitions labeled respectively relationship src dst defined backward relative indexing specifying two numbers fi fl reference transition ref 2 sigma particular find corresponding transitions src dst following procedure start end process move backwards looking transition found continue moving backwards looking fith transition starting src simultaneously find flth transition dst found include h src dst b pi specification separation analysis petri net sigma thus consists three transitions ref sigma two constants fi fl 2 n call fi fl occurrence indices relative transition ref let pisigma fi fl ref denote set triples h src dst 2 pisigma src dst relation described one communication action csp program may map many transitions sigma transitions considered equivalent performing timing analysis instead specifying separation individual transitions specify sets transitions ie separation analysis specified two occurrence indices fi fl three sets transitions sigma ref final formulation straightforward given communication actions determine transitions included sets sometimes may also want consider several csp communication actions equivalent respect separation analysis see example section 6 conveniently achieved adding corresponding petri net transitions appropriate ref sets sequel discuss maximum separation analysis ie find delta separation ffi found maximum separation analysis src dst accomplished computing b pi using reversed roles fi fl b 42 ctse algorithm let delta b maximum separation src dst particular execution b delta b consistent timing assignment maximum separation executions given show elements b pi constructed obtain delta section 5 describes algorithm computing delta b process automaton represents possible executions however whatever topologically dst process cannot influence maximum separation two transitions portion process following src dst therefore ignored processes b pi end terminal process segment includes two transitions src dst let p process containing src dst path p process automaton starting decompose process p 0 p 0 path process automaton minimal process segment containing src dst process segment called terminal segment let pi u finite set process segments path v 0 u process automaton 2 pi u process p b pi figure 6 shows two terminal process segments belonging pi v 0 atoa separation analysis example example processes b pi constructed p v 0 e c f figure two terminal processes labeled using lab separation analysis next transition petri net figure 1b algorithm computing delta b phrased algebraic terms segment process corresponding element algebra use denote element process segment algebra allows us reuse analysis shorter processes computing delta b operators algebra associative details shown next section two operations algebra choice j concatenation fi approach analyzing infinite set b pi enumerate processes b increasing length unfolding process automaton using breadthfirst traversal traverse automaton backwards starting terminal segments element algebra stored node v process automaton let v k denote algebraic element stored node v process automaton k th iteration initially v vg traversing process automaton backwards elements algebra composed using fi two paths series combined using j two paths parallel choice operator combines backward paths reach marking process automaton illustrated showing backward traversal reconvergence corresponding process automaton figure 5 two terminal processes figure 6 example v 0 whenever node v 0 reached k th unfolding v 0 represents maximum separation executions represented unfolding denoted delta k value maximized values previous unfoldings delta kg 3 follows delta k lower bound delta given node v process automaton compute upper bound unfoldings bound denoted v k let c vertex cut process automaton upper bound delta k th unfolding delta cg delta k less equal delta k k stop unfolding report exact maximum separation possible upper lower bounds converge case bounds may still provide useful information delta range main loop ctse algorithm shown figure 7 algorithm ctseg vg v f unfold onceg return figure 7 ctse algorithm computing delta given process automaton g runtime algorithm depends size representation algebraic elements size element may large number paths two nodes related element ie exponential number iterations k practice pruning drastically reduces element size computing delta b section describes algebra used ctse algorithm algebra used reformulate algorithm mcmillan dill 15 determining maximum separation two events acyclic graph 51 algebras presenting algorithm computing delta b introduce two algebras first min algebra r f1g phi 0 elements 1 0 identity elements phi 0 second algebra denoted element f function represented set pairs singleton set fhl uig u rowvector length n represents columnvector length n andomega 0 denotes inner product min algebra general set fhl represents function associate two binary operators functions function maximization f phi g function composition fomega g follows 4 function maximization defined set union f phi g function composition gomega h defined fx hgx notice use lefttoright function composition function compositionomega distributes function maximization phi elements identity elements function maximization composition respectively two pairs representation function remove since x minx proper application observation greatly simplify representation function 52 acyclic time separation events algorithm present algebraic formulation mcmillan dills algorithm computing delta b place transition compute pair f f 2 f 2 rf1g algorithm shown figure 8 informally algorithm works follows maximize value dst need find timing assignment maximizes dst minimizes src first element f represents longest path using ds transition dst second element represents shortest path using gammads src algebra f 0 part complicated fact delay given place assigned ds ds f 0 part must represent longest path respecting delays assigned shortest path computation details see 13 find maximum separation represented f pair evaluate f 0 computing sum longest shortest paths compute delta b maximize f pairs initial marking delta b pair 2 fflg ffl denotes set fs similarly ffl denotes set fs 2 j g 53 decomposition algebraic formulation allows decomposition computation using matrices consider process segment represent computation algorithm two n theta matrices f given vector mvalues ffl algorithm deltab element backward topological order place compute pair f ae 0 migomega f f pair stored ae pair stored transition compute pair f ae dst phiff place j 2 tfflg otherwise ae phi 0 fm place j 2 tfflg otherwise figure 8 algorithm computing deltab find vector mvalues ffl 0 phi 0 illustrated using process segment 1 figure 5 shown figure 9 associate delay range 1 2 place ie places compute expressions refers mvalue computed element x process backwards topological order 1 compute gamma1omega 0 ms 5 substitution substitution asomega 0 distributes phi 0 associative represent computation matrix form using phi 0 figure 9 process segment 1 figure 5 similar matrix constructed fpart process segment 1 computation igomega fs 5 substitution substitution substitution igomega fh2 ms 5 deltaomega distributes phi definition ofomega expressions depend mvalues internal elements 1 eg mt 1 expression fs 0 mvalue nodes computed linear expression mvalues places ffl linear expression encoded vector u length jfflj vector product computes mvalue internal node u stored eg expression used fs 0 represented vector express fcomputation matrix form using given process segment denote corresponding function mvalue matrices f algebraic element defined singleton set ff mg define two operators fi j choice operator defined set union composition operator complex composing two segments 1 2 functions 1 need refer mvalues 2 ffl rather 1 ffl shift functions make refer mvalues 2 ffl multiplying uvectors f 1 2 singleton function fhl uig obtain function fhl ig nonsingleton functions shifted shifting pair matrix functions shifted elementwise use notation f denote shift matrix f matrix singleton sets composition operator defined theta nonsingleton sets multiplied applying distributive law 54 pruning consider element ff g removed f set show pairs composed left right result scalar scalar greater composition f sufficient condition eliminating following let ie k largest difference elements 2 1 0 difference negative 1 rowvector appropriate length entries set 1 condition used eliminate entire execution paths analysis central obtaining efficient algo rithm sophisticated conditions use information particular computation possible may increase efficiency algorithm 55 upper bound computation consider determine upper bound v k node v process automaton determine nontrivial upper bound backward paths v v 0 considered ie need bound infinite set algebraic elements constructed backward paths oe simple path p compute p p simple write p 3 simple path p 2 simple cycle p 1 finite may contain cycles introduce upper bound operator r property 1 thus expression righthand side upper bound lefthand side expression r operator recursively applied path simple path hence bound infinite set 5 finite set algebraic elements constructed paths consisting simple cycle followed simple path ending v r operator defined follows assume f k theta n k matrix form 0m 0 vector lenght containing 0 k identity matrix size k operator rf defined hi z vector length containing function z fh1 1ig function z largest element f ie z f functions f 2 f effect r operator apply function z part f matrix identity upper bound determined individually pair set node v upper bound given f pair less equal present global lower bound delta k pair removed set pruning backward execution paths must considered order f pairs multiplied greatly affects runtime algorithm example consider precomputing node process automaton algebraic expression upper bound ie node compute algebraic element set simple paths followed simple cycles going backwards dont know composed elements pairs pruned representation therefore may efficient multiply pairs iteration even though doesnt allow reuse work previous iterations experience upper bound expressions become large precomputed better recomputing iteration effective pruning takes place precompute r simple cycles observation key achieving polynomial runtime example described following section 6 benchmark example eager stack replicating single process linear array provides efficient implementation lastin firstout memory refer eager stack eager stack contains interesting mixture choice concurrency represents excellent parameterizable example explaining analyses performed algorithm also benchmarking implementation algorithm 61 eager stack stack capable storing n elements constructed n equivalent processes arranged linear array process four ports put get ports put get connect ports respectively stage right figure 10 shows block diagram put get environment 3stage eager stack put get put get figure 10 block diagram 3stage eager stack csp specification single stage boolean variables b rb used control communication adjacent right stage value b indicates whether stage holds valid data value rb mirror value b stage right concurrency occurs position must created space must filled choice whether put get made environment potentially propagated throughout entire stack order avoid overflow underflow condition environment interacting stack must attempt put n elements already stored stack must attempt get stack empty following process represents suitable environment ep ut get j process unfolded n times actual data x eliminated simplicity get construct repeated guard command trailing chosen repeated otherwise number parenthesis refers number items stack time communication performed put 2 stack full get communication possible 1 nice property example port names occur number times along compatible choice paths adjacent processes thus identify superscripted number occurrence port name program use petri net transition p communications put port stage port stage 1 similarly g denotes communications get port stage port stage figure 10 1 possible stack indicate whether empty full make environment behave accordingly complicates stage stack 62 timing analysis numerous interesting time separation analysis perform eager stacks determine minimum maximum separations consecutive put communications environment process maximum separation analysis 3stage stack would correspond set delay communication actions range 1 2 get maximum separation obtained filling empty stack three put operations emptying three get operation finally inserting one element put operation maximum separation achieved third fourth put operation minimum separation exchange sets negate result case possibly interesting analysis might minimum maximum separations consecutive put get communications corresponds minimum maximum response time stack equivalently minimum maximum cycle period environment must include petri net transitions corresponding put get communications environment thus results 1 2 delay ranges communication actions fixed delay values eager stack constant response time ie time environment performs either put get operation next operation independent size stack n case introduce uncertainty delay values maximum response time turns n linear stack size however look maximum response time amortized put get communication actions get following maximum separations delta dividing delta obtain amortized separations shown deltam 6 5 466 45 44 433 429 predict 4 although maximum separation two consecutive operations increases linearly n amortize number operations response time converges 4 fact maximum response time converges 4 independently n sense eager stack constant response time even delays uncertain 63 run time execution times ctse algorithm eager stacks various sizes n shown table 2 using 1 2 delay ranges size specification ie number places number transitions size flow relation given n table js sigma j jt sigma j jf sigma j respectively number nodes reachability graph shown jrgj column note reachability graph constructed performing timing analysis reported give idea complexity nets separation analysis denoted delta 1 maximum separation consecutive put operations delta 2 maximum separation consecutive put get operations cpu times obtained sparc 10 256 mb memory 3 4 43 176 268 24 23 28 1220 813 36 2000 1333 5366 table 2 run times ctse algorithm eager stack various sizes figure 11 shows cpu times two separation analysis plotted function size petri net orbits 19 authors knowledge developed efficient tool answering temporal questions petri nets specifications orbits constructs timed reachability graph ie states reachable given timing information noted orbits capable analyzing larger class petri net specifications one described partial order techniques also used orbits reduce state space explosion 20 however time construct timed reachability graph eager stack increases exponentially size n 6 time 234 cpu seconds decstation 5000 256 mb ie two orders magnitude slower ctse algorithm orbits ran memory 7 conclusion described algorithm solving important time separation problem class petri nets contains choice concurrency practice algorithm able analyze nets considerable size demonstrated example whose petri net specification consists 3000 nodes 10 reachable states report polynomial runtime result single parameterizable example expect similar results specifications exhibiting limited choice abundant concurrency acknowledgments thank chris myers stanford university many fruitful discussions well supplying orbits runtimes work supported nsf yi award mip9257987 110010000 petri net size jf sigma j figure 11 double logarithmic plot cpu time two separation analyses function petri net size jf sigma j darpacsto microsystems program onr monitored contract n0001491j4041 r theory timed automata synchronization linearity modeling verification time dependent systems using time petri nets relation nets csp partial order behavior structure petri nets interleaving partial orders concurrency formal comparison trace algebra automatic verification realtime concurrent systems minimum maximum delay problems realtime systems computer aided verification using partial orders improve automatic verification methods timing analysis digital circuits theory minmax functions practical applications efficient time separation events algorithm algorithm exact bounds time separation events concurrent systems programming vlsi communicating processes delayinsensitive circuits algorithms interface timing verification synthesis timed asynchronous circuits petri net theory modeling systems performance evaluation asynchronous concurrent systems using petri nets automatic verification timed circuits modular construction partial order semantics petri nets tr ctr ken stevens shai rotem steven burns jordi cortadella ran ginosar michael kishinevsky marly roncken cad directions high performance asynchronous circuits proceedings 36th acmieee conference design automation p116121 june 2125 1999 new orleans louisiana united states
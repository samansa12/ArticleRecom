improving efficiency symbolic model checking statebased system requirements present various techniques improving time space efficiency symbolic model checking system requirements specified synchronous finite state machines used techniques analysis system requirements specification tcas ii complex aircraft collision avoidance system together reduce time space complexities orders magnitude making feasible analysis previously intractable tcas ii requirements written rsml dialect statecharts b introduction formal verification based state exploration considered extreme form simulation every possible behavior system checked correctness symbolic model checking using binary decision diagrams bdds efficient stateexploration technique finite state sys tems successful verifying falsifying many industryscale hardware systems application nontrivial software processcontrol systems far less mature increasingly promising ex ample obtained encouraging results applying symbolic model checking portion preliminary version system requirements specification tcas ii complex software avionics system collision avoidance full requirements comprising four hundred pages written requirements state machine language work supported part national science foundation grant ccr970670 w chan supported part microsoft graduate fellowship rsml hierarchical statemachine language variant statecharts representing state sets relations implicitly bdds symbolic model checking sheer number reachable states longer obstacle analysis instead limitation size bdds depend structure system analyzed considerable effort hardware formal verification focused controlling bdd size typical circuits however transferring technology new domains may require alternative techniques heuristics combat bddblowup problem pa per present modifications algorithms implemented symbolic model checker smv modifications model well simple abstraction technique improve time space efficiency tcas ii analy sis experimental results show techniques together reduce time space complexities orders magni improvements made feasible analysis previously intractable specific techniques discuss paper ffl shortcircuiting reduce number bdds generated stopping iterations fixed point reached managing forward backward traversals reduce size bdd generated iteration notably improve backward traversals making certain invariants particular events mutually ex clusive explicit search ffl sophisticated conjunctive partitioning transition relation applying disjunctive partitioning unusual way reduce size intermediate bdds iteration improvements made combining two techniques obtain dnf partitioning ffl abstraction decrease number bdd variables given property check perform simple dependency analysis generate reduced model guaranteed give results full model techniques like shortcircuiting abstraction conceptually straightforward applicable many systems techniques designed exploit simple synchronization patterns tcas ii example events mutually exclusive state machines enabled simultaneously believe also help analyze statecharts machines simple synchronization patterns provide experimental results showing techniques affected performance tcas ii analysis psfrag replacements way wax figure 1 example statecharts effects combinations improvements shown addition individual effects focus reachability problems properties tcas ii interested fall class however principle techniques benefit general temporallogic model checking well conclude paper discussion related techniques background section give brief overview statecharts rsml turn attention symbolic model check ing finally review applied symbolic model checking tcas ii requirements 21 rsml statecharts tcas ii requirements written rsml language based statecharts like variants statecharts rsml extends ordinary statemachine diagrams state hierarchies every state contain orthogonal mutually exclusive child states however feature concern us paper state hierarchy portion tcas ii analyzed shallow incur special difficulties model checking instead think system consisting number parallel state machines communicating executing synchronous way figure gives simple example two parallel state machines b local state 0 say system state a0 state machines synchronized using events arrows without sources indicate start local states arrows represent local transitions labeled form ucv u trigger event c guarding condition v action event guarding condition simply predicate local states states machines andor inputs system exam ple guarding condition may say system b0 input altitude least 1 000 meters rsml guarding condition specified separate diagram tabular form called andor table use simpler statecharts notation instead guarding condition action optional general idea event u occurs guarding condition c either absent evaluates true transition enabled initially external events along possibly nu meric inputs environment arrive marking beginning step events may enable transitions described maximal set enabled transitions collectively called microstep takenthe system leaves source local states enters target local states generates action events events broadcast entire system generated events may enable transitions events disappear one microstep unless regenerated transitions step finished transitions enabled semantics rsml assume synchrony hypothesis step values inputs change new external events may ar rive words system assumed infinitely faster environment figure assume w external event boolean input system currently a0 b0 w arrives input false event generated step finished since new transitions enabled instead true w arrives transitions a0 a1 b0 b1 simultaneously taken event x generated completing one microstep second microstep starts notice synchrony hypothesis input must true external event w cannot occur transition b1 b2 enabled taken generating event z finishing step subtle important semantic differences exist among variants statecharts semantics statemate another major variant statecharts close rsml statemate enforce synchrony hypothesis semantics provides option simulator rsml statemate also richer set synchronization primitives provide sort variable assignments however features important paper 22 symbolic model checking switch gears discuss ordinary finitestate transition systems without state hierarchies synchrony hy pothesis etc model checking goal model checking determine whether given state transition system satisfies property given temporal logic formula try give counterexample sequence states falsifies formula example properties include bad state never reached good state always reached infinitely often explicit model check ing answer determined graphtheoretic manner traversing labeling vertices state graph method impractical many large systems state explosion problem much efficient large state spaces symbolic model checking model checker visits sets states instead individual states illustration focus reachability problem simplest common kind temporal property checked practice let q finite set system states q state transition relation q set initial states e q set error states reachability problem asks whether system always stays away error states e demands counterexample sequence states q 0 q define compute preimage start iteratively compute reaching fixed point psfrag replacements backward traversal fixed point figure 2 algorithm computing pre e 1 let q 0 nonempty subset pre e iteratively compute q reaching e psfrag replacements forward traversal 2 start qm 2 qm e iteratively pick obtain counterexample q 0 psfrag replacements qm figure 3 algorithm counterexample search weakest precondition set states transition relation r intuitively set states may reach state one transition characterize decision problem reachability settheoretic manner using fixed points determine whether pre e empty pre e set states may eventually reach error state specifically smallest state set satisfies existence guaranteed finiteness q monotonicity pre figure shows iterative algorithm computing fixed point set states may reach error state transitions many temporal properties similarly defined computed using possibly multiple nested fixed points intersection pre e initial states empty set e reachable done otherwise would like find counterexample first define post postimages words posts set states reachable one transition figure shows counterexample search algorithm set q 0 nonempty subset intersection convenient choose q 0 arbitrary singleton set set q states reachable q 0 transitions obtain counterexample tracing backward qm e improve algorithm later crucial factor efficiency representation state sets notice state space q represented finite set variables x state q corresponds valuation variables two states correspond valuation finite state systems assume without loss generality variable boolean set states symbolically represented boolean function sx state set makes function true transition relation states similarly represented boolean function copy x represents next state intersection union complementation sets relations respectively becomes conjunction disjunction negation boolean functions problem representation state sets reduced boolean functions empirically efficient representation boolean functions bdds canonical efficient implementation boolean operations example time space complexities computing conjunction disjunction two bdds product sizes usually complexities observed practice still lower negation equivalence checking done constant time bdds often succinct relies critically chosen linear variable order variables x represent state set transition relation r bdds compute preimage postimage follows notation 9x refers existentially quantifying variables x addition boolean operations equivalence checking operations like existential quantification variable substitution also performed algorithms figures similar algorithms many temporal logics ctl implemented using bdds thanks succinctness bdds efficiency algorithms systems 10 120 states analyzed 23 symbolic model checking tcas ii analyzed tcas ii requirements using symbolic model checker smv version 244 smv uses algorithms similar figures notable difference figure instead computingy uses equivalent recurrence advantage usually requires much smaller bdd resulting faster preimage com putation fact sufficient compute preimage z apply computation q figure smv support hierarchical states rsml features directly translate requirements ordinary finitestate transition system smv language requirements consist two main parts ownaircraft otheraircraft occupy 30 70 document respectively initial study translated ownaircraft quite faithfully smv lan guage abstracted otheraircraft mostly nondeterministic state machine details translation including transitions state hierarchy synchrony hypothesis handled well properties analyzed given previous paper certain details system model relevant paper ffl rsml microstep corresponds transition smv program thus step corresponds sequence transitions ffl encode rsml event boolean variable true event occurred ffl assume numeric input discrete bounded encode bit boolean variable ffl maintain synchrony hypothesis prevent inputs changing external events arriving variables encode events true ffl analyze one instance tcas ii asynchrony among multiple instances system issue major source complexity analysis tran sitions guarding conditions occupy many pages description contain predicates local states input variables may involve complex arith metic many researchers conservatively encode arithmetic predicate independent boolean variable encode input bit boolean variable resulting accurate analysis expense boolean variables addition guarding condition refer part system interdependencies bdd variables high imply relatively large bdds guarding conditions plus side control flow ownaircraft simple concurrency among state machines ownaircraft minimal see techniques presented later attempt exploit simple synchronization patterns shortcircuiting easy see figure need compute fixed point error states reachablewe stop intersection empty need element intersection shortcircuiting technique may substantially reduce time space used short counterexample exists generally shortcircuiting applied outermost temporal operator temporallogic model checking however reduction obtained probably less start q iteratively pick obtain counterexample q 0 q 1 psfrag replacements figure 4 simplified algorithm counterexample search reachability analysis one many fixed points stopped prematurely 4 forward vs backward traversals fixedpoint computation counterexample search done either forward backward section elaborate performance difference analysis short backward traversals generate smaller bdds big win system improved incorporating certain invariants prune searches 41 improved counterexample search analysis tcas ii found property disproved minutes finding counterexample might take hours coauthor previous paper subsequently simplified counterexample search algorithm resulting substantial speedup technique described used study forward traversal first part figure bot tleneck system sequence postimages requires large bdds however eliminate step remember every computed figure actual implementation stores difference modification illustrated figure means innovative considered natural 1 disadvantage algorithm use additional memory store state sets wasted case error states reachable nevertheless dramatic speedup made possible far outweighs modest additional memory requirements important question remains backward traversal figure much efficient forward traversal figure inefficiency forward traversals also witnessed smvs inability compute set reachable states system finding reachable state set searching forward initial states common technique hardware verification set used help analyze temporal properties synthesize indeed search forward find reachable state set smv optionally use similar counterexample search algorithm used default backward traversal psfrag replacements xay xby xby xay figure 5 state machine local invariants circuit backward traversal often takes fewer iterations reach fixed point forward traversal set error states usually general set initial states however problem number iterations rather size bdds generated general observe backward traversals bdds usually hundreds tens thousands bdd nodes forward traversals two orders magnitude larger nevertheless verification many hardware systems tends benefit rather suffer forward traversals example iwashita et al report significant speedup ctl model checking hardware benchmarks forward instead backward traversals used partly inspired hu dill believe inefficiency mainly due complex invariants tcas ii maintained forward backward traver sals example consider state machine figure event generated invariant system whenever event occurred machine a0 condition true bdd large bdd invariant even small likely many implicit invariants system conjunction may large bdd representation addition invariants may globally relate different state machines also likely result large bdds forward traversals maintain invariants intuitively bdds forward traversals tend blow size lowlevel hardware verification bdds often remain small invariant usually localized involves small number state variables however case tcas ii backward traversals situation quite different example counterparts invariant mentioned backward traversals used truth value imply state system microstep certainly different backward invariants maintained backward traversals tend depend states search starts bdds tend smaller system 42 improved backward traversals using invariants interestingly main disadvantage backward traversals also forward invariants maintained variants particularly small bdds help simplify bdds state sets speed backward traversals incorporated search context statecharts many systems simple synchronization patterns lost backward traversals particular invariant find useful rectify prob psfrag replacements uav vbw wcx figure system linear structure lem mutual exclusion certain events illustrate idea example consider system figure assuming u external event concurrency systemat one local transition enabled time forward traversals explore concurrent executions state machines however backward traversals analysis may fooled consider many concurrent executions reachable suppose want check whether system b1 c1 simultaneously traversing back ward find previous microstep system may b0c1 b1c0 b0c0 last case however possible events v w cannot occur time notice true assume synchrony hypothesis tracing iterations see search considers concurrent executions also many unreachable interleaving ones bdds thus may blow guarding conditions complex fortunately greatly simplify search observing events mutually exclusive invariant incorporated traversals either intersecting state sets using careset simplify bdds find set mutually exclusive events may perform conservative static analysis causality events alternatively designer may know events mutually exclusive synchronization patterns designed careful consideration confirm mutual exclusion may verify using model checking static analysis techniques states reachable set state variables encoding events consideration case tcas ii large part model behaves similarly machine figure set mutually exclusive events evident partitioned transition relation apart bdd size state sets another bottleneck model checking bdd size transition relation reduced conjunctive disjunctive partitioning former used naturally tcas ii modified smv partition transition relation effectively also apply disjunctive partition ing normally used asynchronous systems combining two techniques obtain dnf partitioning see issues section bdd size transition relation also size intermediate bdds generated image computation 51 background subsection review idea conjunctive disjunctive partitioning described burch et al transition relation r sometimes given disjunction bdd r huge even though disjunct small bdd instead computing monolithic bdd r keep disjuncts separate image computations easily modified distributing existential quantification disjunc tion preimage computation thus compute preimage without ever building bdd r postimage computation symmetric however r given conjunction c 1 still keep conjuncts separate image computations become complicated problem existential quantification distribute con junctions appears compute bdd r anyway quantify variables trick avoid early quantification define x 0 disjoint subsets x 0 union x 0 conjunctc depend variable x p p consider preimage computation compute intuition quantify variables early possi ble hope intermediate c remains small effectiveness procedure depends critically choice ordering conjuncts c 1 c 52 determining conjunctive partition could construct monolithic bdd transition relation r model tcas ii hours cpu time r naturally specified conjunction use conjunctive partitioning although smv supports fea ture determines partition simplistic way smv program consists list parallel assignments whose conjunction forms transition relation smv constructs bdds assignments incrementally builds conjunction reverse order appear pro gram process whenever bdd size exceeds userspecified threshold creates new conjunct par tition partition solely determined syntax heuristic semantic information used better determine partition changed smv allow user specify partition manually also implemented smv variant heuristics geist beer ranjan et al automatically determine partition central idea behind heuristics select conjuncts allow early quantification variables introducing fewer variables cannot quantified implementation heuristics worked quite well partitions generated compared favorably sometimes outperformed manual partitions tried 53 disjunctive partitioning statecharts disjunctive partitioning superior conjunctive partitioning sense ordering disjuncts less critical intermediate bdd function x instead thus tends smaller another advantage exploited possibility parallelizing image computation constructing intermediate bdds concurrently unfortunately transition relation r conjunc tion general simple methods converting small set small disjuncts define cover disjunction tautology indeed disjunctively partition r distributing r cover choices covers still large tcas ii many statecharts however exploit mutual exclusion certain events say u psfrag replacements figure 7 event x triggers two state machines words corresponds states u occurred j none events j1 least two events clearly form cover made two observations first drop j1 contradiction mutual exclusion assumption second parallel assignments smv program guarded conditions events example assignment models state transition requires occurrence trigger event event say u bdd assignment applicable disjunct disjuncts transition relation unaffected disjunct may remain small notice apply technique find set provably mutually exclusive events done described section 54 dnf partitioning serialization disadvantage partitioning r based events sizes disjuncts often skewed particular single event may trigger number complex transitions corresponding disjunct could large figure shows example event x triggers two state machines guarding conditions complex bdd disjunct corresponding x may large one solution problem apply conjunctive partitioning large disjuncts resulting call dnf partitioning uses bdd size conjunctive par titioning structural information disjunctive parti tioning partition transition relation may perform better relying either alone alternatively may serialize complicated microstep cascading microsteps reduce bdd size figure illustrates idea inserted new event u x note resulting machine microsteps step although method effective reducing bdd size often increases number iterations reach fixed point also transformation may preserve behavior system property analyzed sufficient condition guarding conditions psfrag replacements figure 8 serialized machine machine b refer machine local states x mutually exclusive events checking reachability property explicitly mention state machines transitions events involved 6 abstraction section give simple algorithm remove part system model guaranteed interfere property checked example state machine may number outputs may local states events verifying one logic produces outputs may abstracted away provided outputs fed back system abstraction obtained exact respect property sense particular property holds abstracted model holds original model 61 dependency analysis determine abstraction simple dependency analysis statecharts description initially local states events transitions inputs explicitly mentioned property considered relevant analysis following rules applied recursively ffl event relevant transitions may generate event ffl transition relevant trigger event source local state everything appears guarding condition ffl local state relevant transitions parent state state hierarchy rules repeated fixed point reached es sentially search dependency graph time complexity linear size graph evident everything determined relevant rules removed without affecting analysis result 2 criterion applied arbitrary ctl mulas provided use nexttime operator x count number microsteps words assumptions transformation preserves equivalence stuttering bisimulation psfrag replacements wbx wby way wax xdy xdy xcy xcy figure 9 false dependency event depends guarding condition 62 false dependency similar dependency analyses could also performed model checkers vis boolean model statecharts machine however straightforward implementation would effective reason model input would appear depend every event way encoded synchrony hypothesis sec tion hand carrying dependency analysis highlevel statecharts description fall prey false dependencies forms false dependencies possible however suppose given system figure previous section syntax event u appears depend conditions 0 fact regardless truth values 0 event u generated result event x detect false dependencies one check whether disjunction guarding conditions transitions local state trigger action events tautology sometimes checked efficiently using bdds however syntax rsml statemate allows easy detection false dependencies kind notice selfloops figure solely synchronizationthey make sure u generated regardless whether local state change improve visual presentation rsml statemate allow specifying generation events separate state diagram using identity transitions static reactions respectively actually semantics slightly different selfloops distinctions important false dependencies harder detect automatically example maybe guarding conditions involved form tautology reachable states one guarding conditions holds whenever trigger event occurs another example figure event depends guarding conditions always generated one two microsteps w 3 practice synchronization system evident designer may specify suspected false dependencies temporal logic formulas verified using model check ing results indeed show real dependencies 3 however nexttime operator x used may considered conservatively dependent b formation used dependency analysis obtain smaller abstracted model system tcas ii anal ysis synchronization ownaircraft simple enough false dependencies easily detected however method may used analyzing rest tcas ii systems 7 experimental results table summarizes results applying techniques mentioned model tcas ii shows resources time seconds number bdd nodes used thousands building bdds transition relation r well resources evaluating six properties note latter excludes time spent building transition relation resources finding counterex amples counterexample search took one two seconds per state counterexample never bottleneck thanks algorithm figure algorithm used checks without none counterexamples could found less one hour table also shows number iterations needed reach fixed points length shortest counterexamples performed experiments sun sparcstation 10 128mb main memory successful checks used less 30mb main memory properties p1 p4 refers properties increase descent inhibition function consistency transition con sistency output agreement explained previous paper property p5 refers assertion britt p 49 ownaircraft never two local states correctiveclimb yes correctivedescend yes simultaneously comments version tcas ii quirements however explicitly say two local states mutually exclusive property p6 somewhat con trived simply conjunction p3 p4 since searching simultaneously two unrelated sets states tends blow bdds checking property provides easy way scaling bdd size also mimics checking properties involving large part system six properties reachability violated model entry table indicates timeout one hour emphasize purpose data investigate general effects techniques model tcas ii picking clear winner among techniques since bdd algorithms sensitive various parameters chosen model analyzed note also results shown compared directly earlier results models parameters model checking algorithms used different full model first part table shows results full model 227 boolean state variables row 1 gives results base analysis two properties could completed using conjunctive partitioning implemented smv actually implemented small improvement used results including base analysis explained section image computation step involves conjunction existential quantification two operations carried simultaneously avoid building usually large conjunction explicitly smv performs optimization except conjunctive partitioning used building p1 p2 p3 p4 p5 p6 bdds r full model 227 variables fixpoint iterations 24 29 29 38 26 26 counterexample length 15 15 11 24 17 11 optimizations time nodes time nodes time nodes time nodes time nodes time nodes time nodes mistranslated model optimizations time nodes time nodes time nodes time nodes time nodes time nodes time nodes serialized model 231 variables fixpoint iterations 36 41 45 54 38 38 counterexample length 23 23 19 36 25 19 optimizations time nodes time nodes time nodes time nodes time nodes time nodes time nodes abstracted models variables 142 142 150 142 150 171 optimizations time nodes time nodes time nodes time nodes time nodes time nodes time nodes sc shortcircuiting mx mutual exclusion events cp improved conjunctive partitioning dp disjunctive partitioning fixpoint iterations counterexample lengths identical full model table 1 resources used analysis simply changed smv optimization conjunctive partitioning expected shortcircuiting sc gave savings number iterations needed became length shortest counterexample incorporating mutual exclusion certain events backward traversals mx generally gave order magnitude time space reduction addition could easily disprove p5 p6 particular britts claim mentioned provably true version requirements improved conjunctive partitioning cp mentioned section used heuristic produce partition effective reducing time space used disjunctive partitioning dp must combined mutual exclusion events appeared inefficient row 5 reason one disjuncts transition relation large 10 5 bdd nodes least order magnitude larger disjuncts reflected table large number bdd nodes needed construct transition relation conjunctively partitioned large disjuncts leading dnf partitioning dicated row 7 marking cp dp performs marginally better pure conjunctive partitioning terms time space requirements consistently lower combining two optimizations observed orders magnitude improvements time space row 8 mistranslated model illustrate differences conjunctive dnf partitioning looked version model contains translation error rsml machine smv program real bug made early study although soon discovered inspection mistake omitting selfloops similar figure bdds faulty systems often larger corrected versions bugs tend make system behavior less regular therefore investigating performance bdd algorithms faulty designs meaningful interestingly particular partition generated heuristic performed poorly model row 10 dnf partitioning continued give significant time space savings row 11 serialized model mentioned disjunctive partition contains disproportionally large bdd serialized microstep full model break large disjunct four bdds sizes hundred times smaller expected disjunctive partitioning performed better rows 5 vs 14 however since number microsteps step increased partitioning techniques suffered larger number iterations needed reach fixed points ended performing disjunctive dnf partitioning slight edge data suggest serializing microstep order use disjunctive partitioning advantageous model general find effects serializing dual collapsing microsteps difficult predict represents tradeoff complexity image computations number search iterations abstracted models last part table shows performance analyzing abstracted models obtained dependency analysis section number variables abstracted away quite large recall full model omitted details otheraircraft many outputs ownaircraft inputs aircraft thus become irrelevant unless explicitly mention property explains relatively large reduction obtained 8 discussion related work first summarize differences symbolic model checking hardware circuits tcas ii major focus hardware verification concurrent systems complex control paths often subtle concurrency bugs data paths relatively simple forward traversals usually perform much better bdds tend small reachable state spaces contrast major complexity tcas ii requirements lies concurrency among components intricate influence data values control paths bdd transition relation tends huge forward traversals inefficient backward traversals usually perform better focusing property analyzed improved exploiting simple synchronization patterns method pruning backward traversals using invariants similar spirit work hardware verification cabodi et al propose approximate forward traversal compute superset reachable states used prune backward traversals method automatic invariants suggest take advantage simple synchronization system also independently propose disjunctive partitioning synchronous circuits method requires designer come partition manually exploit mutually exclusive events work also independent heimdahl whalen use dependency analysis technique similar one described section motivation facilitate manual review tcas ii requirements rather automatic verification noted gained relatively large reduction otheraircraft fully mod eled suspect complete system reduction obtained exact analysis could limited however reduction obtained forsake exactness example localization reduction one technique aggressively generates abstracted model may satisfy property full model model checker finds abstracted model counterexample exist full model automatically refine abstraction iterate process either correct counterexample found property verified would interesting see well techniques paper scale system complexity natural way try applying rest tcas ii unfortunately part contains arithmetic operations multiplica tion provably cannot represented small bdds recent paper suggest coupling decision procedure nonlinear arithmetic constraints bddbased model checking attack problem research needed see whether technique scales large systems acknowledgments thank steve burns observed inefficiency algorithm figure implemented one figure smv r efficient implementation bdd package case study applying formal methods traffic alert collision avoidance system tcas ii characterizing finite kripke structures propositional temporal logic efficient state space pruning symbolic backward traversal combining constraint solving symbolic model checking class systems nonlinear con straints automatic verification finitestate concurrent systems using temporal logic specifications verification futurebus verification synchronous sequential machines based symbolic execution model checking graphical user interfaces using abstractions statecharts visual formalism complex systems statemate semantics statecharts completeness consistency analysis statebased require ments reducing bdd size exploiting functional dependencies new techniques efficient verification implicitly conjoined bdds model checking based forward state traversal requirements specification processcontrol systems symbolic model checking formal verification gigamax cache consistency protocol automatic verification hydroelectric power plant dynamic variable ordering ordered binary decision diagrams feasibility model checking software requirements case study tr automatic verification finitestate concurrent systems using temporal logic specifications graphbased algorithms boolean function manipulation statecharts visual formalism complex systems characterizing finite kripke structures propositional temporal logic verification synchronous sequential machines based symbolic execution complexity vlsi implementations graph representations boolean functions application integer multiplication reducing bdd size exploiting functional dependencies requirements specification processcontrol systems computeraided verification coordinating processes completeness consistency hierarchical statebased requirements statemate semantics statecharts model checking large software specifications model checking based forward state traversal disjunctive partitioning partial iterative squaring model checking graphical user interfaces using abstractions reduction slicing hierarchical state machines symbolic model checking efficient state space pruning symbolic backward traversal automatic verification hydroelectric power plant combining constraint solving symbolic model checking class systems nonlinear constraints efficient model checking automated ordering transition relation partitions vis ctr gleb naumovich conservative algorithm computing flow permissions java programs acm sigsoft software engineering notes v27 n4 july 2002 jamieson cobleigh lori clarke leon j osterweil right algorithm right time comparing data flow analysis algorithms finite state verification proceedings 23rd international conference software engineering p3746 may 1219 2001 toronto ontario canada jin yang andreas tiemeyer lazy symbolic model checking proceedings 37th conference design automation p3538 june 0509 2000 los angeles california united states ji lee hye j kim kyo c kang real world object modeling method creating simulation environment realtime systems acm sigplan notices v35 n10 p93104 oct 2000 c michael overstreet improving model development process model testing special case software testing proceedings 34th conference winter simulation exploring new frontiers december 0811 2002 san diego california ofer strichman accelerating bounded model checking safety properties formal methods system design v24 n1 p524 january 2004 jonathan whittle formal approaches systems analysis using uml overview advanced topics database research vol 1 chan richard j anderson paul beame david h jones david notkin william e warner decoupling synchronization local control efficient symbolic model checking statecharts proceedings 21st international conference software engineering p142151 may 1622 1999 los angeles california united states chan richard j anderson paul beame david notkin david h jones william e warner optimizing symbolic model checking statecharts ieee transactions software engineering v27 n2 p170190 february 2001 guoqing shu fengdi wang min chen weiqing requirements specifications checking embedded realtime software journal computer science technology v17 n1 p5663 january 2002 shoham bendavid cindy eisner daniel geist yaron wolfsthal model checking ibm formal methods system design v22 n2 p101108 march chan richard j anderson paul beame steve burns francesmary modugno david notkin jon reese model checking large software specifications ieee transactions software engineering v24 n7 p498520 july 1998
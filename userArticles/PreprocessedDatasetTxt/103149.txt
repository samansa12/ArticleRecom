reliable solution special event location problems odes computing solution initial value problem ordinary differential equations odes may part larger task one task finding algebraic function solution event function root event occurs task difficult theory software practice certain useful kinds event functions possible avoid two fundamental difficulties described achieve reliable solutions problems way allows capability grafted onto popular codes initial value problem b introduction computing solution yfflr n initial value problem ordinary differential equations may part larger task possibly common task find either first point 0 set points ft g one equations satisfied g j called event functions event j said occur root jth event function paper concerned class problems event function g j defined polynomial either 0 specifically assume g j 12 form either x component solution vector yx general polynomial forms g j treated techniques expense rather complicated machinery common problems finding component solution assumes given value ii finding component solution extremum form 13 14 single event function allow several event functions forms time solve complicated problems iii tabulating values dependent variable iv determining location switching points points discontinuity defined terms linear functions dependent variable v determining zeros general event function qx adjoining differential equation q system 11 difficulty event location problem often appreciated next section investigate theoretical difficulties two fundamental difficulties usual approaches one cannot sure noticing event one realizes event occurred one cannot sure finding first occurrence special problems consider present efficient way overcome difficulties least principle difficulties remain section 3 state key observation describe exploit presence one event function causes many complications present software design reasonably easy use provides considerable flexibility produced codes event location used many popular codes initial value problem goal add capability locating events without altering integrator section 4 describe accomplish section 5 discuss codes important application 2 problem difficulties popular codes initial value problem 11 step b producing approximations yx set points usual codes test values event function 12 different signs x x i1 change sign one indicates event occurred x adams backward differentiation formulas bdf codes produce polynomial px approximates yx whole interval natural compute first root approximation location event j popular rungekutta formulas produce solutions mesh points x approach event location problem important reason recent work aimed providing formulas polynomial approximate solutions valid x way locating events described natural many led think task easy far true mesh points x chosen provide efficiently approximations yx 0 x specified accuracy event functions 12 influence selection mesh spacing may appropriate locating positions events roots 12 even number roots counting multiplicity occur x x i1 noticed presence event noticed general way certain rootsolver find first root course one might monitor behavior closely reduce chance missing root particularly careful algorithm watts 12 13 expensive guaranteed succeed unlikely deceived nearpathological cases event function form qx yx converted form consider analytical partial derivatives available new dependent variable added system 11 noting dz dx look event conversion force integrator select step sizes appropriate qx yx consequence location events much reliable unfortunately may expensive compute qx yx accurately way cost would paid even event occur b also partial derivatives q x q may difficult obtain stated event location problem equation 11 integrated least first event occurs common use event functions determine function fx redefined example might one set differential equations describe temperature room temperature drops low thermostat switches heater new situation described new set equations example definition f clearly depends history integration natural locate event restart integration new definition f deceptive problem occurs f may redefined various possible definitions depend history integration example suppose fx otherwise temptation program f straightforward fashion large measure defeats efficient location events difficulty codes initial value problem expect f smooth programming f value determined simple test magnitude presents integrator function f continuous lacks continuous derivative integrator steps value 1 value 1 function f smooth enough basic theory underlying construction integrator applies happens unpredictable integrator may realize produced inaccurate solution mathematical software solving differential equations tries recognize cope problems designed quality codes likely recognize inaccurate solution reject step try smaller step often case codes repeatedly try steps cross event rejection steps fall short succeed way eventually integrator steps past event step size small result accurate proper use code event location ability avoids clumsy unreliable handling discontinuity initial value jyj 1 smooth function fx integrated one events occurs location event determined f redefined intgration restarted new f smooth namely fx case may way proceeding efficient furnishes reliable solution task intended paper suppose function f smooth f redefined event new integration initiated point accurately locate event depends accurately integrate underlying differential equations conditiong root difficulties present even simple event functions treat discuss matter specific context finding root event function step code produces polynomial px approximating solution component j x event approximated root equation minor source error location event computation codes require user specify accurately computed authors prefer compute accurately possible precision available reasonable suppose computed satisfies exactly though quite true discrepancy far smaller errors consider relate j approximation p simple root approximate second term leads immediately approximation error p 0 small root poorly determined easy extend argument deal multiple roots come conclusion multiple roots illconditioned differs usual algebraic case term represents true global error integration 11 codes initial value problem even try control error directly best size comparable local error tolerance used integration generally cannot expect locate event accurately integration tolerance problem 11 illconditioned may achieve even close accuracy would helpful user code event location capability estimate error reported code provide estimate quantity multiplying global error equivalent quantity multiple roots esimate 21 refers event functions form 13 easy obtain analagous results event functions form 14 code estimates condition problems similar way estimate error location would need estimate global error j one case 0 aware satisfactory way estimate quantities commonly assumed global errors comparable local error tolerance assumption along condition numbers provide yields crude useful indication error implications facts discomfiting perfectly possible event occurs integration done one tolerance occur different tolerance unpleasant worse happen tolerance integration performed differently example different output requirements alter choice step size particular repeating integration code stepping alleged location event ordinarily result value gx yx 0 x different obtained using polynomial approximation px mesh points related matter general computed event position contrary one might expect often discussed typical codes allow yx 0 x 12 large part answer suffice many problems seen practice however fundamental difficulty higher order derivatives polynomial may fit yx well yet derivatives exhibit even qualitative agreement adams methods based polynomial approximation 0 x perfectly natural include 12 methods presence 0 x 12 debatable expensive way handle first derivative eliminate solving instead reliable nonstiff problems avoided stiff problems wellknown p 0 x associated bdf codes ordinarily far better approximation 0 x fx px derivative handled analytical partial derivatives available adding derivative new variable system 11 rather like event function q added variable proceeding way causes codes produce independent polynomial approximation derivative specified local accuracy unfortunately obtaining equation satisfied derivative may difficult besides fundamental difficulties another arises polynomial approximations produced popular codes polynomial produced popular fehlberg 45 rungekutta formulas horn 8 adams code shampine gordon 10 connect mesh points x form globally continuous function bdf adams code gear 5 form continuous function first derivative jump discontinuities jumps seen codes comparable size local error tolerances obviously scheme described locating events exhibit anomalous behavior approximate solutions used remedy difficulty number authors recently supplied algorithms c 1 piecewise polynomial approximations rungekutta 4 11 adams 14 bdf 1 13 codes 3 rootfinding algorithm section describe technique use solve special event location problems appropriate necessary describe details code aim present important ideas suitable structure realization code discussed detail section 5 presented 2 consider task integrating 11 first position satisfying 12 located key observation event functions form 13 14 yx approximated polynomial px function polynomial course true kinds event functions well restrict forms 13 14 allow us solve interesting practical problems still provide simple user interface approach also generalizes kinds approximations found 6 x4 purposes piecewise rational approximation yx offers advantages easy see event functions form 13 14 rational approximation also leads finding roots polynomials shall say obvious generalizations using sturm sequences say principle answer question root polynomial g j x px p 0 x interval also possible sure computing first root one present using example bisection sturm sequences test presence root follows describe one way exploit observation first need clear mean first position equation 12 satisfied quite possible indeed fairly common practice 12 satisfied initial point course user able check without assistance need report integration 11 intend employ codes used mode call routine integrator steps current point x internally chosen point x i1 direction integration intend search current integration interval next occurence event defined 12 define current integration interval half open interval overall lose points range integration except possibly initial point x definition two significant advantages first technique determining position events based sturm sequence algorithm 9 count number zeros given algorithm always defined interval second locate event point wish go locate next event direction integration interval searched initially naturally codes provide two basic modules one module designed solely checking whether events 12 module takes input interval shifted power series representation event functions g j uses standard sturm sequence algorithm determine precisely many occurrences counting multiplicities event ii second module used locating first event user specified interval call module described determined one events occur modules output accurate estimate first position event c multiplicity andor type depending context condition number interval c search c largest interval seen contains one event solution yx approximated px change position events possibly multiplicity especially original problem events high multiplicity well separated assume solving stated section 2 return condition numbers roots used gain impression accuracy want algorithm locating first position event efficient robust tried devise algorithm converges rapidly satisfied reduced task locating event single event function cautious less frequently occurring circumstances insist efficiency might employ simpler algorithm example could apply standard code computing roots polynomials locate occurrences events rank results determine location first event approach would palpably inefficient even first check events occur shall say event functions active important efficiency fact many applications one event function also whether expect many integration intervals events event occur usually one interval several events occur one integration interval usually isolated relative machine roundoff codes whenever isolated single active event function single occurrence hence computed c use standard bisec tionsecant algorithm 3 rewritten reverse communication form locate position event accurately get stage first identify events active interval c current interest make list next use bisection algorithm identify point dc first element active events list event occurs c suppose current interval c initially set c may single active event case set c use bisectionsecant algorithm locate precisely even one active event worth proceeding similar way variety possibilities include using bisectionsecant algorithm active events turn followed ranking computed positions find first second possibility locate position first active events accurately check position first events find active events c start however adopted approach generally efficient choose arbitrarily work first active events proceed one iteration time bisectionsecant algorithm event compute estimate e position event call bisectionsecant code several possibilities estimate right locations events reduce interval c e similarly left reduce interval e cases compute new estimate location event first function repeat remaining possibility event functions events left e case reduce list active event functions restart interval c e possibly new first event function two variations basic problem computing first event occur frequently present difficulties software involve continuing integration 11 next event one case event functions remain changed difficulty first task one event occur immediately another compute position obtain interval c 2 c contains events big help also difficulty events may occur several times vicinity finite precision arithmetic used yet infinite precision arithmetic hence even though excluded interval search position next event point nearby may identified incorrectly position help overcome problem search search proceeds two stages first check remaining part current integration interval using information computed already least one event occurs interval compute position closest proceeding otherwise move next integration interval proceed case finding first position event second problem information contained computed interval longer useful changing event definition may occurrence one newly defined events hence never avoid possible numerical roots without recourse error analysis discussed section 2 implementation redefine set events point proceeding must compute internal data example sturm sequence coefficients may check occurrences events x i1 algorithm proceeds like one described earlier possible work throughout set events includes possible definitions arise stage integration point view least sometimes avoiding rounding effects would better choice possible one use algorithm described first problem rather second even though might involve postprocessing user event position information 4 combining rootfinder integrator section consider design interface allows root finding code grafted onto many popular integrators version plan disseminate makes minimal assumptions integrator assume used mode returns calling program step x x i1 polynomial known degree r represent solution x noted earlier anomalous behavior possible interpolants certain popular codes connect smoothly mesh points interfere rootfinder treatment interval provided user appreciates potential difficulties arising lack smoothness reason cannot use rootfinder code effects lack smoothness similar marked arising loss smoothness due numerical errors algorithm discuss end section modules written rootfinding task assume polynomial form r r r popular integrators represent interpolating polynomials many forms viz taylor lagrangian divided difference hermite routine needed 7 32e5 14 98e10 table 1 condv convert standard form first consider information form supplied ability evaluate interpolant hardly surprising better job done information supplied examples taken ability evaluate polynomial px degree r provided integrator convert form 41 choosing r forming values construction p way involves solution van der monde system computations illconditioned especially high degrees sometimes occur adams codes table 1 gives extrema chebyshev polynomial r1 x shifted 0 1 degrees 15 typical bdf rungekutta codes higher degrees occur adams codes condition numbers uncomfortably large higher degrees however notoriously pessimistic analysis 7 shows expect size condition number reflected errors coefficients r 41 long use appropriate algorithm solving van der monde system general purpose package written uses nodes specified except user may override choice approach one might hope nordsieck form interpolating polynomial used number popular codes taylor series expansion polynomial special interface convert shifted scaled form 41 need much natural general approach special interface less troubled conditioning matter straightforward go details 5 29e3 11 40e8 table 2 condv r interpolation nodes function derivative routines evaluating px evaluate p 0 x time odd replace 43 set distinct points table 2 tabulate condv values little smaller table 1 increase similarly recently considerable interest providing rungekutta codes kind polynomial interpolant require paper 4 provides entry literature proposed 11 6 algorithm based dormandprinceshampine dps formulas 45 pair embedded formulas use local extrapolation yield fifth order approximations local solution derivative x quintic hermite interpolant yields polynomial approximation order five x connects approximations intervals yield globally c 1 piecewise polynomial approximate solution natural take nodes fs g f0 1 46 solve directly using 44 45 experimented special interface similar cases well general one presented earlier observe even underlying polynomial px theory globally property shared computed piecewise polynomial functions defined 41 interval x turn loss smoothness arise inaccurate solution van der monde system interval 41 obtained evaluations px imposing condition p 0 directly manifest errors locations events importantly far less frequently loss event occurrences mesh points switch polynomials successive intervals general little codes driver routine control move one interval next check report discontinuities event location caused errors mesh points first checking sign changes mesh points representations event functions two intervals meeting point first approach reveals nothing check sturm sequence counts match two representations small subinterval new interval ffi chosen fairly small relative size interval extrapolation representation computed likely inaccurate larger 5 codes 2 present collection subroutines implementing algorithm described paper refer reader fuller description codes restrict general comments pertinent material paper also discuss use driver subroutine alevnt important application theoretical discussion faithfully reflected codes gives adequate appreciation efficiency clearly make usual assumption evaluating ode 11 expensive part integration event location technique constitutes additional overhead comparatively low cost particular normally case evaluations ode required algorithm required integration alone assuming common modern codes calculating interpolant associated ode solver involve ode evaluations even extra evaluations would made per step rather per event function evaluation interval containing event located algorithm nearly efficient root finder based used standard way calculate root single equation addition computed event locations codes return condition numbers based extension 21 take account high order zeros turning points event function event occurence order g r similarly occurrence order event locating event codes return condition number appropriate note due rounding integration error effects codes may return small value cases compensation closely clustered roots p 51 p m1 thus small hence condition number large consider problem tabulating independent variable x terms equispaced values dependent variable wish solve 11 locating first points x given value 0 given increment delta pose problem two ways first approach define single event function proceed compute position x 0 event redefine event since necessary redefine event function differential equation use subroutine alevnt figure 1 second approach define set event functions simul taneously namely tabulation points interest events located must processed maintain order tabulation subroutine alevnt used purpose designed drive integrator users choice determine locations events important distinction approaches example start wish know yx values 2 3 4 etc quite possible first approach know definition use next event function happens find example wish continue look next event first approach priori information behavior solution expect reflected computed solution even believe information useful check problem formulation coding use second approach possibly modified include event functions could occur starting current position three event functions almost cases example consider problem tabulating x equispaced steps solution artificially constructed equation equation solution tabulate values x using nag code d02nbf integrator relative local error tolerance 10 gamma5 would expect results reproduced approximately standard integrator define one event function time alevnt event located redefine event function alternatively use four event functions corresponding four tabulation points simultaneously table 3 present tabulated values latter approach error estimate based substituting local error tolerance expression though value substituted global error j local error tolerance used quantity available related error j though well established error estimate clearly tabulation point multiplicity error estimate table 3 tabulation points equispaced values reasonable approximation true error overestimate error approximations double zero computed events using different error tolerances call d02nbf sufficiently stringent tolerances obtain underlined event locations given table 3 cases detect one event never detect multiple root even though root multiplicity two numerical approximation either roots close pair value error estimates associated close pair consistent error tolerances integration always indicate illconditioned roots results illustrate value using four event functions simultaneously reveal monotonic results first approach using one event function exactly underlined values table 3 results obtained redefining event functions restarting integration general likely accurate calculated without restarting integration case restarting errors made calculating early event locations propagate later integrations hence accuracy later event locations case restarting effect 6 conclusions outlined approach finding event locations certain special event functions associated solution ode addition emphasizing difficulty problem shown construct event locating code outlined graft code onto standard integrator interpolation feature grafting process requires integrator step oriented mode determine degree associated interpolating polynomial step evaluate interpolating polynomial anywhere span step pseudocode redefining event functions locations detected f declarations g f user initializes integrator sets x1 tend g f user defines first event set neqg comps1 alpha1 appropriately g f irevcm reverse communication integer variable set alevnt exit determine next action required userg call alevntneqg comps alpha turn x1 x2 nord mxord neqf xval yvals lbound xevent rbound mltplc f variables input values alevnt output integrator variables output variables alevntg f user checks ier nature error g f user calls integrator take first integration step goto call alevnt f user calls integrator take integration step g goto call alevnt f user evaluates interpolant xval yvals g goto call alevnt print xevent f user resets comps1 alpha1 define next event g goto call alevnt endif end figure 1 using alevnt redefining event function r c 1 interpolant codes based backward difference formulae codes reliable solution special event location problems odes algorithms minimisation without derivatives numerical initial value problems ordinary differential equations practical aspects interpolation rungekutta codes analysis bjorckpereyra algorithms solving van der monde systems fourth fifthorder scaled rungekutta algorithms treating dense output first course numerical analysis 2nd edition computer solution ordinary differential equations initial value problem practical rungekutta formulas backward differentiation formulae revisited improvements debdf new root solving code rdebd smoother interpolants adams codes tr italiccsupscrpt1 interpolant codes based backward differentiation formulae smoother interpolants adams codes practical rungekutta formulas practical aspects interpolation rungekutta codes analysis bjomyampersandumlrckpereyra algorithms solving vandermonde systems numerical initial value problems ordinary differential equations ctr r w brankin gladwell algorithm 771 rksuite90 fortran 90 software ordinary differential equation initialvalue problems acm transactions mathematical software toms v23 n3 p402415 sept 1997 joel esposito vijay kumar state event detection algorithm numerically simulating hybrid systems model singularities acm transactions modeling computer simulation tomacs v17 n1 p1es january 2007 joel esposito vijay kumar asynchronous integration event detection algorithm simulating multiagent hybrid systems acm transactions modeling computer simulation tomacs v14 n4 p363388 october 2004 przemyslaw prusinkiewicz mark hammel eric mjolsness animation plant development proceedings 20th annual conference computer graphics interactive techniques p351360 september 1993 aleksandar donev salvatore torquato frank h stillinger neighbor list collisiondriven molecular dynamics simulation nonspherical hard particles ii applications ellipses ellipsoids journal computational physics v202 n2 p765793 20 january 2005
volume leases consistency largescale systems abstractthis article introduces volume leases mechanism providing serverdriven cache consistency largescale geographically distributed networks volume leases retain good performance fault tolerance server scalability semantically weaker clientdriven protocols used web volume leases variation object leases originally designed distributed file systems however whereas traditional object leases amortize overheads long lease periods volume leases exploit spatial locality amortize overheads across multiple objects volume approach allows systems maintain good write performance even presence failures using tracedriven simulation compare three volume lease algorithms four existing cache consistency algorithms show new algorithms provide strong consistency maintaining scalability faulttolerance tracebased workload web accesses find volumes reduce message traffic servers 40 percent compared standard lease algorithm volumes considerably reduce peak load servers popular objects modified b introduction fulfill promise environment essentially human knowledge available set servers distributed across wide area networks data infrastructure must evolve protocols optimized one applicationbrowsersto protocols support range demanding applications future expect dataintensive applications extend beyond humandriven browsers include programdriven agents robots distributed databases data miners place new demands datadistribution infrastructure new applications require aggressive caching acceptable performance tolerant cache inconsistencies browser unfortunately current cache consistency protocols scale large systems web poor performance weak consistency guarantees poor fault tolerance article appear ieee transactions knowledge data engineering special issue web technologies 1999 work funded part nsf cise grant cda9624082 gifts novell sun microsystems darpaspawar grant number n66001988911 dahlin alvisi supported nsf career awards ccr9733842 ccr9734185 respectively cache consistency achieved either clientdriven protocols clients send messages servers determine cached objects current serverdriven protocols servers notify clients data change either case challenge guarantee client read always returns result latest completed write protocols achieve said strongly consistent clientdriven protocols force caches make difficult choice must either poll server access cached data risk supplying incorrect data first option polling read increases load server latency cache request effects significant large scale systems servers support many clients polling latencies high option periodic polling relaxes consistency semantics allows caches supply incorrect data example web browsers account weak consistency humanbased errorcorrection protocol users manually press reload button detect stale data weak consistency semantics may merely annoying human cause parallel distributed programs compute incorrect results complicate use aggressive caching replication hierarchies replication transparent application serverdriven protocols introduce three challenges first strong consistency difficult maintain face network process failures modifying object server using protocols must contact clients cache object many cached copies likely least one client unreachable case server cannot complete write without violating consistency guarantees second server may require significant amount memory track clients cache objects third sending cache invalidation messages may entail large bursts server activity popular objects modified distributed file systems problems server driven protocols addressed using leases 8 specify length time servers notify clients modifications cached data leases timeout expires client must renew lease sending message server client may access cached object leases maintain strong consistency allowing servers make progress even failures occur server cannot contact client server delays writes unreachable clients lease expires time becomes clients responsibility contact server furthermore leases free servers notifying idle clients modifying object reduces size server state load sustained server reads writes bursty although leases provide significant benefits file system workloads may less effective wide area network wan amortize cost renewing lease across multiple reads lease long enough common case cache accessed without renewal request unfortunately least browser workloads repeated accesses object often spread minutes lease lengths shorter time reads leases reduce client polling hand longer lease lengths reduce three original advantages leases article show volume leases 22 restore benefits leases wan work loads volume leases combine short leases groups files volumes long leases individual files volume leases algorithm client may access cached object holds valid leases object objects volume combination provides faulttolerance short leases clients become unreachable server may modify object short volume lease expires time cost maintaining leases modest volume leases amortize cost lease renewal large number objects examine three variations volume leases volume leases volume leases delayed validations best effort volume leases delayed invalidations algorithm servers defer sending object invalidation messages clients whose volume leases expired optimization reduces peaks server load reduce overall load batching invalidation messages eliminating messages entirely cases clients never renew volume lease third variation motivated observation workloads require strict consistency prefer clients observe fresh data example important event occurs news service would like invalidate stale cached copies front page quickly may want begin distributing new front page immediately rather wait notified customers old page invalid best effort variation volume leases uses relaxed consistency satisfy applications find approach improve performance allowing servers utilize longer volume lease timeouts article evaluates performance volume leases using tracebased simulation compare volume algorithms three traditional consistency algorithms client polling server invalidations server invalidations leases simulations demonstrate benefits volume leases example volume leases delayed invalidations ensure clients never see stale data servers never wait 100 seconds perform write using number messages standard invalidation protocol stall server writes indefinitely compared standard object lease algorithm also bounds server write delays 100 seconds volume algorithm reduces message traffic 40 rest article organized follows section 2 describes traditional algorithms providing consistency cached data section 3 describes new volume lease algorithms section 4 discusses experimental methodology section 5 presents experimental results discussing related work section 6 section 7 summarizes conclusions traditional consistency algorithms section reviews four traditional cache consistency algorithms first twopoll read pollrely client polling remaining algorithmscallback leaseare based server invalidation describing algorithm refer table 1 summarizes key characteristics algorithm discussed paper including three new algorithms also refer figure 1 defines several parameters algorithms table 1 summarize cost maintaining consistency object using algorithms columns correspond key figures merit expected stale time indicates long client expects read stale data modified assuming random reads random updates failures worst stale time indicates long cached stale assuming 1 loaded immediately modified 2 network failure prevented server contacting client caching read cost shows expected fraction cache reads requiring message server write cost indicates many messages server expects send notify clients write acknowledgment wait delay indicates long server wait write cannot invalidate cache server state column indicates many clients server reads writes state expected worst read write acknowledge server stale time stale time cost cost wait delay state seconds seconds messages messages seconds bytes poll read volume leasest v ro rdeltat co mint v vol delay invalt v rdeltat cv mint v delay invalt v table 1 summary algorithm performance variable meaning timeout object timeout volume servers store state inactive clients r frequency object read v number active objects per volume c tot number clients copy object number clients lease object c v number clients lease volume v c number clients whose volume leases expired less seconds ago bytes server state support x clients figure 1 definition parameters table 1 expects track object 21 poll read poll read simplest consistency algorithm accessing cached object client asks objects server object valid server responds affirmatively server sends current version algorithm equivalent always clients read data server optimization unchanged data resent thus clients never see stale data writes server always proceed immediately network failure occurs clients unable contact server guarantees validity cached objects cope network failures clients take applicationdependent actions signaling error returning cached data along warning may stale primary disadvantage algorithm poor read performance reads delayed roundtrip message client server addition messages may impose significant load servers 11 22 poll poll based poll read assumes cached objects remain valid least timeout period seconds client validates data hence equivalent poll read choosing appropriate value presents tradeoff one hand long timeouts improve performance reducing number reads wait validation particular client accesses data rate r reads per second timeout long enough span several reads 1 rdeltat clients reads require network messages see table 1 hand long timeouts increase likelihood caches supply stale data applications gwertzman seltzer 10 show web browser workloads even timeout ten days server load significantly higher callback algorithm described study finds adaptive timeout scheme works better static timeouts algorithms parameters set make adaptive timeout algorithm impose server load callback 4 client reads receive stale data servers predict certainty objects modified poll ideal case servers tell clients use cached copies objects time next modification study assume servers information future 23 callback callback algorithm 11 17 servers keep track clients caching objects modifying object server notifies clients copies object proceed modification received acknowledgment client shown table 1 callbacks read cost low client guaranteed cached object valid told otherwise however write cost high object modified server invalidates cached objects may require c tot messages furthermore client crashed network partition separates server client write may delayed indefinitely 24 lease address limitations callback gray cheriton proposed lease 8 read object client first acquires lease associated timeout client may read cached copy lease expires object modified objects server invalidates cached objects clients whose leases expired read object lease expires client first contacts server renew lease lease allows servers make progress maintaining strong consistency despite failures client network failure prevents server invalidating clients cache server need wait lease expires performing write contrast callback may force write wait indefinitely leases also improve scalability writes rather contacting clients ever read object server need contact recently active clients hold leases object leases thus reduce amount state server maintains track clients well cost sending invalidation messages 14 servers may also choose invalidate caches simply waiting outstanding leases expire rather sending messages large number clients explore option study lease presents tradeoff similar one offered poll long leases reduce cost reads amortizing lease renewal r delta reads hand short leases reduce delay writes failures occur polling client unable contact server renew lease knows holds potentially stale data client may take applicationspecific actions signaling error returning suspect data along warning however unlike poll lease never lets clients believe stale objects valid 3 volume leases traditional leases provide good performance cost renewing leases amortized many reads unfortunately many wan workloads reads object may spread seconds minutes requiring long leases order amortize cost renewals 10 make leases practical workloads algorithms use combination object leases associated individual data objects volume leases associated collection related objects server scheme client reads data cache object volume leases data valid server modify data soon either lease expired making object leases long volume short overcome limitations traditional leases long object leases low overhead short volume leases allow servers modify data without long delays furthermore spatial locality within volume overhead renewing short leases volumes amortized across many objects section first describes volume leases algorithm examines variation called volume leases delayed invalidations end section examine best effort volume leases support applications timely updates desired required 31 basic algorithm figures 2 3 4 show data structures used volume leases algorithm server side algorithm client side algorithm respectively basic algorithm simple ffl reading data clients read cached data hold valid object volume leases corresponding objects expired leases renewed contacting appropriate servers granting lease object client c modified since last time c held valid lease server piggybacks current data lease renewal ffl writing data modifying object server sends invalidation messages clients hold valid leases object server delays write receives acknowledgments clients volume object leases expire modifying object server increments objects version number 311 handling unreachable clients client crashes network partitions make clients temporarily unreachable may cause problems consider case unreachable client whose volume lease expired still holds valid lease object client becomes reachable attempts renew volume lease server must invalidate modified objects client holds valid object lease algorithm thus maintains server unreachable set records clients acknowledgedwithin timeout periodone servers invalidation messages receiving read request lease renewal request client unreachable set server removes client unreachable set renews clients volume lease notifies client renew leases currently cached objects belonging volume client responds sending list objects along version numbers server replies message contains vector object identifiers message 1 renews leases objects modified client unreachable 2 invalidates leases objects whose version number changed client unreachable data structures volume volume v following attributes set objects v number incremented server reboot time current leases v expired set hclient expirei valid leases v set clients whose volume leases expired may missed object invalidation messages object object following attributes data objects data time current leases expired set hclient expirei valid leases figure 2 data structures volume lease algorithm 312 handling server failures server fails assume state used maintain cache consistency lost lan systems servers often reconstruct state polling clients 17 approach impractical wan protocol allows server incrementally construct valid view object lease state relying volume lease expiration prevent clients using leases granted failed server recover crash server first invalidates volume leases waiting expire invalidation done two ways server save stable storage latest expiration time volume lease upon recovery reads timestamp delays writes expiration time alternatively server save stable storage duration longest possible volume lease upon recovery server delays writes duration passed since object lease information lost server crashes server effectively invalidates object leases treating clients unreachable set maintaining volume epoch number incremented reboot thus client requests server writes object hclient expirei 2 oat expire currenttime client 62 ovolumeunreachable contact contact client sendinv alidate oid clients contact receiveack inv alidate oid c 2 contact contact contact gamma f c g ovolumeunreachable oversion server renews client lease receiverenew lease reqvolid volepoch objid clientv ersion c let v volume vid volid let object vepoch volepoch vunreachable recoverunreachableclientc v see c 62 vunreachable vexpire vat old leases client vat oexpire oat old leases client oat else recoverunreachableclientclient c volume v sendmust renew vid c renewrecvd false f currenttime renewrecvd receiverenew obj leasesvolid leaseset c rewnewrecvd true renewrecvd return client still unreachable hobjid objv ersioni 2 leaseset let object renewlist renewlist hoid oversion oexpirei sendinv alidateinvallist renew renewlist receive ack inv alidate c vunreachable figure 3 volume leases protocol server side client reads object renewleaseovolumeo read local copy renewleasevolume v object epoch maxvepoch gamma1 vnum maxoversion gamma1 sendrenew lease req vid epoch oid vnum note recieve times abort read receivemust renew vid server renewallv note recieve times abort read receiverenew lease respvid vexpire vepoch oversion oexpire odata server renewallvolume v objects ovolume v validleaseo sendrenew obj leasesvid leaseset server note recieve times abort read receive inv alidateinvallist renew renewlist server objid 2 invallist let object hobjid version expirei 2 renewlist let object oexpire expire sendack inv alidatevid server validleaselease l lexpire currenttime return true else return false client receives object invalidation message object receiveinv alidate objid server let object sendack inv alidate oid server figure 4 volume leases protocol client side renew volume must also indicate last epoch number known client epoch number current volume lease renewal proceeds normally epoch number old server treats client client volumes unreachable set also possible store cache consistency information stable storage 5 9 approach reduces recovery time cost increased overhead normal lease renewals investigate approach paper 313 cost volume leases analyze volume leases assume servers grant leases length v volumes length objects typically volume lease much shorter object leases client accesses multiple objects volume short amount time volume lease likely valid accesses read cost column table 1 indicates cost typical read measured messages per read 1 rdeltat first term reflects fact volume lease must renewed every v seconds renewal amortized objects volume assuming object read r times per second second term standard cost renewing object lease ack wait delay column indicates client network failure prevents server contacting client write object must delayed mint v ie either lease expires write cost server state columns indicate servers track clients hold valid object leases notify objects modified finally stale time columns indicate volume leases never supplies stale data clients 314 protocol verification verify correctness consistency algorithm implemented variation volume leases algorithm described figures 3 4 using teapot system 4 teapot version algorithm differs one described figures two ways first teapot version uses simplified reconnection protocol unreachable clients rather restore clients set object leases teapot version clears clients object leases unreachable client reconnects second difference teapot version every network request includes sequence number repeated corresponding reply sequence numbers allow protocol match replies requests teapot allows us describe consistency state machines convenient syntax generate murphi 7 code mechanical verification murphi system searches protocols state space deadlocks cases systems correcness invariants violated although murphis exhaustive search state space exponential algorithm allows us verify small models system practice approach finds many bugs difficult locate hand gives us confidence correctness algorithm 3 murphi verifies following two invariants hold 1 server writes object client valid object lease valid volume lease object 2 client reads object current version object system verified contains one volume two objects includes one client one server communicate network clients servers crash time network layer lose messages time cannot deliver messages order network layer also report messages lost fact delivered tested portions state space larger models larger models exhaust test machines 1 gb memory entire state space examined 32 volume leases delayed invalidations performance volume leases improved recognizing volume lease expires client cannot use object leases volume without first contacting server thus rather invalidating object leases immediately clients whose volume leases expired server send invalidation messages client renews volume lease particular volume leases delayed invalidations algorithm modifies volume leases follows server modifies object client holds valid object lease expired volume lease server moves client pervolume inactive set server appends object invalidations inactive clients perinactiveclient pending message list inactive client renews volume server sends pending messages client waits clients acknowledgment renewing volume client inactive seconds server moves client inactive set unreachable set discards clients pending message list thus limits amount state stored server small values reduce server state increase cost reestablishing volume leases unreachable clients become reconnected table indicates write occurs server must contact c v clients hold valid volume leases rather c clients hold valid object leases delayed invalidations provide three advantages volume leases first server writes proceed faster many invalidation messages delayed omitted second server batch several object invalidation messages client single network message client renews volume lease thereby reducing network overhead third client renew volume long period time server avoid sending object invalidation messages moving client unreachable set using reconnection protocol client ever returns 33 besteffort volume leases applications require strong consistency want deliver timely updates clients example important event occurs news service would like invalidate stale copies front page quickly rather wait customers know old page invalid thus interesting consider besteffort algorithms best effort algorithm always allow writes proceed immediately notify clients writes delay writes volume algorithms may converted best effort algorithms sending invalidations parallel writes table 1 summarizes characteristics best effort version delayed invalidations algorithm sending invalidations parallel writes algorithm limits expected stale read time notifyc v time takes server send messageswithout delaying writes note best effort algorithms volume leases serve different purpose original volume algorithms limit time clients see stale data whereas strong consistency algorithms generally set volume lease time longest period willing delay write longer factor best effort algorithms instead algorithms set v longest time allow disconnected clients unknowingly see stale data since disconnected clients affected long v values may allow larger values v example news service using strong consistency might want block dissemination news update seconds may willing allow disconnected clients see old news several minutes thus system might use seconds strong consistency might use minutes best effort algorithm original volume algorithms combining short volume leases long object leases allows leases short amortizing renewal costs many objects examine algorithms performance simulated algorithm discussed table 1 workload based web trace data 41 simulator simulate set servers modify files provide files clients set clients read files simulator accepts timestamped read modify events input files updates cache state simulator records size number messages sent server client well size cache consistency state maintained server validated simulator two ways first obtained gwertzman seltzers simulator 10 one traces compared simulators results algorithms common two studies second used simulator examine algorithms simple synthetic workloads could analytically compute expected results cases simulators results match expected results limitations simulator simulator makes several simplifying assumptions first simulate concurrencyit completely processes trace event processing next one simplification allows us ignore details mutual exclusion internal data structures race conditions deadlocks although could change messages sent instance file read time written believe simulating details would significantly affect performance results second assume infinitely large caches simulate server disk accesses effects reduce potentially significant sources work across algorithms thus results magnify differences among algorithms finally assume system maintains cache consistency entire files rather finer granularity chose examine wholefile consistency currently common approach wan workloads 1 finegrained consistency may reduce amount data traffic also increases number control messages required consistency algorithm thus finegrained cache consistency would likely increase relative differences among algorithms 42 workload use workload based traces http accesses boston university 6 traces span four months january 1995 may 1995 include http accesses mosaic browsersincluding local cache hitsfor 33 sparcstations although traces contain detailed information client reads indicate files modified therefore synthesize writes objects using simple model based two studies write patterns web pages bestavros 2 examined traces boston university web server gwertzman seltzer 10 examined write patterns three university web servers studies concluded files change rapidly globally popular files less likely change files example gwertzman seltzers study found 2 23 files mutable file greater 5 chance changing given day 05 files mutable greater 20 chance changing 24hour period based studies synthetic write workload divides files trace four groups give 10 referenced files low average number random writes per day use poisson distribution expected number writes per day 0005 randomly place remaining 90 files three sets first set includes 3 files trace mutable expected number writes per day 02 second set 10 files trace mutable expected number writes per day 005 remaining 77 files expected number writes per day 002 section 54 examine sensitivity results parameters simulate 1000 frequently accessed servers subset servers accounts 90 accesses trace workload consists 977899 reads 68665 different files plus 209461 artificially generated writes files files workload grouped 1000 volumes corresponding 1000 servers leave sophisticated grouping future work 5 simulation results section presents simulation results compare volume algorithms consistency schemes interpreting results remember trace workload tracks activities relatively small number clients reality servers would accessed many clients absolute values report server network load lower servers would actually experience instead focusing absolute numbers experiments focus relative performance algorithms workload 51 servernetwork load figure 5 shows performance algorithms xaxis uses logarithmic scale gives object timeout length seconds used algorithm yaxis gives number messages sent client servers volume lease refers object lease timeout volume lease timeout use different curves show different volume lease timeouts indicate volume lease time second parameter label timeout seconds volumet delay volumet 10 callback volumet 100 delay volumet 100 client pollt object leaset number messages figure 5 number messages vs timeout length delay volume lines assume infinite acknowledgement wait delay signified third parameter means server never moves idle clients unreachable list line callback flat callback invalidates cached copies regardless lease basic volume lease lines decline reaches 100000 seconds rise slightly shape comes two competing influences rises number lease renewals clients declines number invalidations sent clients holding valid leases increases workload client held object 100000 seconds likely server modify object client read leases shorter reduce system load increases client poll delayed invalidation send strictly fewer messages client poll never sends invalidation messages delayed invalidation avoids sending invalidations clients longer accessing volume even clients hold valid object leases note timeouts 100000 seconds client poll results clients accessing stale data 1 reads timeout values 1000000 seconds algorithm results clients accessing stale copies 5 reads separation leaset volumet lines shows additional overhead maintaining volume leases shorter volume timeouts increase overhead lease thought limiting case infinitelength volume leases although volume leases imposes significant overhead compared lease given value applications care fault tolerance achieve better performance volume leases without example triangles figure highlight best performance achievable system allow writes delayed 10 seconds leaset messages exchanged timeout seconds delay volumet 1000 delay volumet 10 delay volumet 10000 delay volumet 100 figure number messages vs timeout length volume leases delayed invalidates volume lease length varied sends 32 fewer messages sends 39 fewer messages similarly indicated squares figure applications delay writes 100 seconds volume lease outperforms lease 30 delayed invalidations outperforms lease algorithm 40 although providing strong consistency expensive poll algorithm cost appears tolerable many applications example uses 15 fewer messages delayed supplies stale data clients 1 reads even extreme case clients see stale data 35 reads delayed invalidations uses less twice many messages polling algorithm also examined network bytes sent algorithms server cpu load imposed algorithms metrics difference cost providing strong consistency compared poll smaller difference metric network messages relative differences among lease algorithms also smaller metrics network messages metric reasons key advantage best effort volume leases applications permit relaxed consistency algorithm may enable longer volume lease timeouts thus may reduce consistency head strict consistency algorithms set volume timeout v longest tolerable write delay best effort algorithms set v longest time disconnected clients server states bytes timeout seconds object leaset delay volumet10 delay volumet100 delay volumet1010000 delay volumet10010000 callback figure 7 state popular server vs timeout allowed unknowingly access stale data may allow larger values v services use best effort figure 6 shows effect varying volume lease timeout number messages sent 52 server state figures 7 8 show amount server memory required implement algorithms first shows requirements traces heavily loaded server second shows demand traces tenth heavily loaded server xaxis shows timeout seconds using log scale yaxis given bytes represents average number bytes memory used server maintain consistency state charge servers 16 bytes store object volume lease callback record messages queued delay algorithm also charge bytes short timeouts lease algorithms use less memory callback algorithm lease algorithms discard callbacks inactive clients compared standard leases volume leases increase amount state needed servers increase small volume leases short servers generally maintain active volume leases delay algorithm never moves clients unreachable set may store messages destined inactive clients long time use memory algorithms conversely delay uses short parameter move clients inactive set unreachable set discard pending messages callbacks delay use less state lease callback server states bytes timeout seconds callback delay volumet10 delay volumet100 object leaset delay volumet1010000 delay volumet10010000 figure 8 state 10 th popular server vs timeout algorithms note running delay short discard times increase server load number consistency messages yet quantified effect depend implementation details reconnection protocol 53 bursts load figure 9 shows cumulative histogram value shown log scale counts number 1second periods load server least x messages sent received per second three groups lines client poll object lease use short timeouts clients read groups objects server algorithms send groups object renewal messages server callback volume use long object lease periods read traffic puts less load server writes result bursts load popular objects modified workload peak loads correspond bursts one message per client finally delay uses long object leases reduce bursts read traffic clients accessing groups objects delays sending invalidation messages reduce bursts traffic writes occur combination reduces peak load server workload experiment described previous paragraph client poll object lease periods higher load callback volume two reasons first system shows performance modest number clients larger numbers clients would increase peak invalidate load callback volume client poll object lease increasing number clients would increase peak server load less dramatically read requests additional clients would periods least load messages per 1 second client object callback delay volume1x10710 figure 9 periods heavy server load default workload heavily loaded server spread time second reason callback volumes advantage experiment trace clients read data servers bursts writes volumes bursty write one object volume make likely another object volume soon modified conversely figure 10 shows bursty write workload one object modified select k objects volume modify time graph compute k random exponential variable mean 10 workload significantly increases bursts invalidation traffic volume callback 54 sensitivity workload utilizes trace read events generates write events synthetically subsection examine different assumptions write frequency affect results figure 11 shows performance algorithms representative parameters vary write frequency default workload gives 10 referenced files perday change probability 05 3 files perday change probability 20 10 files probability 5 77 files perday change probability 2 point graph multiply perday probabilities value indicated xaxis note workload generator converts perday change probabilities persecond change probabilities perday probabilities greater 100 possible examine lease algorithms might parameterized system never wishes delay writes 100 seconds compare poll algorithm 100second timeout periods least load messages per 1 second delay volume1x10710 client object callback figure 10 periods heavy server load bursty write workload heavily loaded server callback algorithm infinite timeout results indicate client little affected changing write rates object timeouts short writes unlikely cause many invalidations even frequency increased 100fold volume lease algorithms callback cost write frequency increases cost callback increase quickly cost delayed first two algorithms long object callback periods thus send invalidation messages clients done reads pair writes delayed volume rises slowly send object invalidations volume lease expires 6 related work study builds efforts assess cost strong consistency wide area networks gwertzman seltzer 10 compare cache consistency approaches simulation conclude protocols provide weak consistency suitable weblike environment particular find adaptive version pollt exerts lower server load invalidation protocol polling algorithm allowed return stale data 4 time arrive different conclusions particular observe much apparent advantage weak consistency strong consistency terms network traffic comes clients reading stale data 14 also use volume leases address many challenges strong consistency messages exchanged write multiplier delay volume1x107100 callback figure messages sent different write frequencies xaxis represents multiplier write frequency compared default workload also build work liu cao 14 use prototype server invalidation system evaluate overhead maintaining consistency servers compared client polling also study ways reduce server state via perobject leases study workload based trace read requests syntheticallygenerated write requests work differs primarily treatment fault tolerance issues particular server recovers algorithm uses volume timeouts notify clients must contact server renew leases liu caos algorithm requires server send messages clients might caching objects server also volume leases provide graceful way handle network partitions network failure occurs liu caos algorithm must periodically retransmit invalidation messages guarantee strong consistency case cache consistency protocols long studied distributed file systems 11 17 19 several aspects codas 13 consistency protocol reflected algorithms particular notion volume similar used coda 16 however differ two key respects first coda associate volumes leases relies instead methods determine servers clients become disconnected combination short volume leases long object leases one main contributions second coda designed different workloads design tradeoffs different example coda expects clients communicate small number servers regards disconnection common occurrence coda aggressively attempts set volume callbacks servers hoard environment clients associated larger universe servers renew volume leases client actively accessing server also algorithm object modified server send volume invalidation messages clients hold volume leases object leases object question thus avoid false sharing problem mummert warns 16 best effort leases algorithm provides similar semantics inspired codas optimistic concurrency protocol 13 bayou 20 rover 12 also implement optimistic con currency detect react general types conflicts coda worrell 21 studied invalidationbased protocols hierarchical caching system concluded serverdriven consistency practical web plan explore ways add hierarchy algorithms future cache consistency protocols long studied distributed file systems 18 17 19 howard et al 11 reached somewhat counterintuitive conclusion serverdriven consistency generally imposed less load server client polling even though serverdriven algorithms provide stronger guarantees clients servers enough information know exactly messages need sent moguls draft proposal http 11 15 includes notion grouping files volumes reduce overhead https pollingbased consistency protocol aware implementations idea finally note volume leases set objects provided server thought providing framework heartbeat messages used many distributed state systems conclusions taken three cache consistency algorithms previously applied file systems quantitatively evaluated context web workloads particular compared timeoutbased client poll algorithm callback algorithm server invalidates write gray cheritons lease algorithm lease algorithm presents tradeoff similar one offered client poll one hand long leases reduce cost reads amortizing lease renewal many reads hand short leases reduce delay writes failure occurs solve problem introduced volume lease volume lease delayed invalidation best effort volume lease algorithms allow servers perform writes minimal delay minimizing number messages necessary maintain consistency simulations confirm benefits algorithm acknowledgments work described appeared earlier paper 22 thank james gwertzman margo seltzer making simulator available us could validate simulator thank carlos cunha azer bestavros mark crovella making bu web traces available us work funded part nsf cise grant cda9624082 gifts novell sun microsystems darpaspawar grant number n66001988911 dahlin alvisi supported nsf career awards ccr9733842 ccr9734185 respectively r hypertext transfer protocol http10 speculative data dissemination service reduce server load experience language writing coherence protocols teapot language support writing memory coherence protocols rio file cache surviving operating system crashes characteristics www traces protocol verification hardware design aid efficient faulttolerant mechanism distributed file cache consistency notes data base operating systems scale performance distributed file system toolkit mobile information access disconnected operation coda file system maintaining strong cache consistency worldwide web design caching http 11 preliminary draft large granularity cache coherence intermittent connectivity caching sprite network file system design implementation sun network filesystem spritely nfs experiments cache consistency protocols managing update conflicts bayou invalidation large scale network object caches using leases support serverdriven consistency largescale systems tr ctr xianjun geng ram gopal r ramesh andrew b whinston scaling web services capacity provision networks computer v36 n11 p6472 november venkata duvvuri prashant shenoy renu tewari adaptive leases strong consistency mechanism world wide web ieee transactions knowledge data engineering v15 n5 p12661276 september randal c burns robert rees darrell e long efficient data distribution web server farm ieee internet computing v5 n4 p5665 july 2001 rajeev gupta ashish puri krithi ramamritham executing incoherency bounded continuous queries web data aggregators proceedings 14th international conference world wide web may 1014 2005 chiba japan l cao zsu evaluation strong consistency web caching techniques world wide web v5 n2 p95123 2002 yuguang fang yibing lin strongly consistent access algorithms wireless data networks wireless networks v11 n3 p243254 may 2005 mohammad raunak prashant shenoy pawan goyal krithi ramamritham implications proxy caching provisioning networks servers acm sigmetrics performance evaluation review v28 n1 p6677 june 2000 randal c burns robert rees darrell e long efficient data distribution web server farm ieee internet computing v5 n4 p5665 july 2001 edith cohen haim kaplan refreshment policies web content caches computer networks international journal computer telecommunications networking v38 n6 p795808 22 april 2002 chihung chi hongguang wang generalized model characterizing content modification dynamics web objects web content caching distribution proceedings 8th international workshop kluwer academic publishers norwell 2004 anoop ninan purushottam kulkarni prashant shenoy krithi ramamritham renu tewari cooperative leases scalable consistency maintenance content distribution networks proceedings 11th international conference world wide web may 0711 2002 honolulu hawaii usa jian yin lorenzo alvisi mike dahlin arun iyengar engineering serverdriven consistency large scale dynamic web services proceedings 10th international conference world wide web p4557 may 0105 2001 hong kong hong kong randal c burns robert rees larry j stockmeyer darrell e long scalable session locking distributed file system cluster computing v4 n4 p295306 october 2001 magnus e bjornsson liuba shrira buddycache highperformance object storage collaborative strongconsistency applications wan acm sigplan notices v37 n11 november 2002 purushottam kulkarni prashant shenoy weibo gong scalable techniques memoryefficient cdn simulations proceedings 12th international conference world wide web may 2024 2003 budapest hungary jian yin lorenzo alvisi mike dahlin arun iyengar engineering web cache consistency acm transactions internet technology toit v2 n3 p224259 august 2002 amol nayate mike dahlin arun iyengar transparent information dissemination proceedings 5th acmifipusenix international conference middleware october 1822 2004 toronto canada arun iyengar daniela rosu architecting web sites high performance scientific programming v10 n1 p7589 january 2002 mingkuan liu feiyue wang daniel dajun zeng web caching way improve web qos journal computer science technology v19 n2 p113127 march 2004
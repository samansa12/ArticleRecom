complexity propositional linear temporal logics simple cases well known model checking satisfiability pltl pspacecomplete contrast little known whether exist interesting fragments pltl lower worstcase complexity results would help understand pltl model checkers successfully used practice article investigate issue consider model checking satisfiability fragments pltl obtainable restricting 1 temporal connectives allowed 2 number atomic propositions 3 temporal height 2002 elsevier science usa b introduction background pltl standard lineartime propositional temporal logic used specification automated verification reactive systems mp92 eme90 wellknown model checking satisfiability pltl pspacecomplete sc85 hr83 wol83 deter research groups implementing pltl model checkers provers using successfully practice bbc hol97 fundamental question raises makes pltl feasible practice question commonanswer starts observation pspace complexity applies formula part problem lp85 worstcase complexity often argued pltl formulae used actual practical situations complex low temporal height article completed version ds98 demri ph schnoebelen number nested temporal connectives mainly boolean combinations simple eventuality safety responsiveness fairness properties certainly question calls systematic theoretical study aiming turning answers formal theorems helping understand issue hand consider example sat famous boolean satisfiability problem current indepth investigations tractable subproblems eg dal96 fv98 regarding pltl know systematic study kind literature surprising considering wide use pltl model checkers reactive systems objectives article develop systematic study looking natural subclasses pltl formulae complexity decreases potential results 1 better understanding makes problem pspacehard 2 formal identification classes temporal formulae lower complex ity called simple cases 3 discovery efficient algorithms simple cases furthermore since pltl basic temporal logic simple cases pltl often corollaries logics starting point revisit complexity questions sc85 bound number propositions andor temporal height formulae precisely let us write h 1 h 2 arbitrary set lineartime combinators among u f x let l k denote fragment restricted formulae 1 using combinators h 1 2 temporal height k 3 n distinct atomic propositions article measure complexity model checking satisfiability fragments choice starting point natural relevant original motivations propositional calculus several modal logics k45 kd45 s5 von wrights logic elsewhere satisfiability becomes lineartime n propositions used see hal95 dem96 contrast satisfiability k remains pspacecomplete even one proposition allowed pltl practical applications temporal height often turns 3 fairness involved even specification quite large combines large number temporal constraints bounded height often invoked reason pltl model checking feasible practice made formal contribution 1 first contribution evaluation computational complexity model checking satisfiability l k fragments table section 8 summarizes 2 also identify new simple cases complexity lowered npcomplete give nondeterministic algorithms think worth investigating whether ideas underlying algorithms could help develop deterministic algorithms perform measurably better relevant simple case usual methods results also implications beyond pltl eg npcompleteness pltl without temporal nesting prop 74 leads p model checking algorithm ctl fctl lms01 3 third contribution proof techniques develop show logspace reductions allow compute almost complexity measures needed remaining ones solved adhoc methods reductions lead rules thumb summarized section 8 used guidelines additionally reductions transform wellknown problems sat qbf model checking problems formulae simple structure eg low temporal height used contexts second author used restricted fragments ctlpast ls00 believe constructions interesting right think scarcity available proofs exercices suitable classroom framework unfortunate pltl model checking widely taught computer science curriculums related work common find papers considering extensions earlier temporal logics search fragments lower complexity less common especially works considering model checking ees90 investigates restricted fragments ctl branchingtime logic satisfiability polynomialtime kv98 studies particular pltl formulae linearsized equivalent ctl formula one aims understand pltl model checking often behaves computationally well practice bk98 tries understand mona performs well practice isolates fragment ws1s usual nonelementary blowup occur hal95 investigates systematic way complexity satisfiability model check ing various multimodal logics modal height number atomic propositions restricted fact pltl quite different standard multimodal logics found behaves differently syntactic restrictions enforced hem00 complexity fragments modal logics also 4 demri ph schnoebelen studied restricting set logical boolean temporal operators fragments mainly relevant description logics see eg dlnn97 far pltl concerned complexity results particular restricted fragments pltl found el87 cl93 spa93 dfr00 systematic studies sharing objectives har85 simple proof based general reduction tiling problems modal logics satisfiability lf x pspacehard fact proof proofs spa93 dfr00 shows pspacehardness already obtained temporal height 2 finally special situation lf lx two limited fragments pltl actually coincide semantically respectively modal logics s43dum also called s431 bul65 seg71 gor94 npcompleteness s43dum satisfiability first proved on80 generalized spa93 modal logic extending modal logic s43 complexity lx satisfiability also studied sr99 plan article section 2 recalls various definitions need throughout article sections 3 4 study complexity pltl fragments number atomic propositions bounded logspace transformations qbf model checking found section 5 section 6 section 7 studies complexity pltl fragments temporal height bounded section 8 contains concluding remarks provides table summarizing complete picture established complexity pltl fragments 2 basic definitions results computational complexity assume reader understands meant complexity classes l deterministic logspace nl nonde logspace p polynomialtime np pspace see eg pap94 given two decision problems p 1 exists logspace transformation manyone reduction p 1 p 2 rest article reductions logspace chardness mean logspace hardness complexity class c temporal logic follow notations definitions eme90 pltl propositional lineartime temporal logic based countably infinite set p propositional variables classical boolean connectives temporal operators x next u f sometimes set formulae defined standard way using connectives g always abbreviations standard meaning let denote length size string assuming reasonably succinct encoding following usual notations see eg sc85 eme90 let lh 1 h 2 denote fragment pltl temporal operators h 1 h 2 allowed 3 instance lu pltl without x used lam83 denotes set propositional variables occurring temporal height written th maximum number nested temporal operators write l k denote fragment lh 1 n 1 propositions used temporal height k 0 allowed write nothing n andor k use bound imposed lh 1 example given flat say form u uses flat lefthand side contain temporal combinator ie boolean combination propositional variables write u want stress occurrence u flat eg sometimes write au buc aubuc best knowledge dams first explicitely isolate name restricted use 4 prove u less expressive u dam99 argued flat often sufficiently expressive practice hoped model checking satisfiability would simpler u u following treat u one pltl combinator expressive f less u semantics lineartime structure also called model pair sequence states mapping labeling state set propositions hold often write structure use fact structure viewed infinite string subsets p rop let structure n position formula satisfiability relation inductively defined follows omit usual conditions propositional connectives def x def f def 3 negations allowed instance lf lg denote fragment 4 flat fragments temporal logics used many places eg mc85 dg99 cc00 6 demri ph schnoebelen u def j j satisfiability say formula satisfiable iff satisfiability problem fragment l written sat l set satisfiable formulae l model checking kripke structure triple n nonempty set states r n n total 5 nextstate relation labels state finite set propositions hold path sequence states n path lineartime structure lineartime structure possibly infinite kripke structure r total function follow eme90 sc85 write exists path starting 6 model checking problem fragment l written mcl set finite l definition size use reasonably succinct encoding practice convenient pretend complexity pltl far computational complexity concerned make substantial use already known upper bounds theorem 21 on80 hr83 sc85 sat lf mclf npcomplete sat lf x mclfx sat lu andmclu pspacecomplete consequence proofs establish lower bounds stuttering equivalence two models equivalent modulo stuttering written display sequence subsets p rop repeated consecutive elements seen one element see lam83 bcg88 considering kripke structures total relations common technical simplification usually impact complexity temporal logic problems however total r assumption implies two states satisfy temporal formulae l fragment satisfiability trivial nontotal r frameworks branchingtime formula behaves propositional variable impact complexity satisfiability fragment k propositions pspacecomplete nontotal r framework hem00 l total r framework 6 existential formulation well suited complexity studies makes model checking closer satisfiability dual definition used verification paths satisfy complexity results model checking easily translated modulo duality two formulations formal definition lamport argued one distinguish stutter equivalent models advocated prohibiting x highlevel specifications since theorem 22 lam83 iff satisfy lu formulae 3 bounding number atomic propositions section evaluate complexity satisfiability model checking number propositions bounded ie fragments l n number propositions bounded satisfiability reduced model checking proposition 31 let h 1 nonempty set pltl temporal combi nators n n sat l n h 1 l mcl n h 1 proof take l n h 1 p rop 1 n let kripke structure n def set 2 n relates two states n one see satisfiable iff n st manyone reduction pick 0 n use reduction logspace since n constants prop 31 used extensively rest article note reduction work empty set combinators could expected since sat l npcomplete mcl amounts evaluating boolean expression l lyn77 also prop 31 holds n bounded confused reductions model checking satisfiability one uses additional propositions encode structure temporal formula used eg sc85 eme90 31 pspacehardness propositions next two propositions show model checking problems n propositional variables encoded two u allowed one one f x allowed proposition 32 mclh 1 l mcl 2 u set h 1 temporal operators 8 demri ph schnoebelen proof kripke structure formula lh 1 p associate kripke structure n ir srs otherwise fig 1 displays example alternations ab ab fig 1 d3 example n define visible slots 2j 2s used encode truth value propositional variables b ith slot encodes p holds given alt 0 alt k1 satisfied n j alt k fact remain k aa alternations next state satisfying translate formulae formulae n via following inductive definition gives reduction need since clearly construction n done space ologt construction n done space olog observe n l 2 u lf x combining theorem 21 obtain corollary 31 mcl 2 u pspacecomplete proposition 33 mclh 1 l mcl 1 x h 1 set pltl temporal operators proof kripke structure formula lh 1 p jr 1s 2 def otherwise fig 2 displays example demri ph schnoebelen fig 2 c3 example idea use aa resp aa ith slot aa encode p holds resp hold aa marker beginning 2j 1 distinguish slots starting new slots p translate formulae formulae c n via following inductive definition c clearly c satisfied c n j n iff c n 1 finally construction c n done space ologt construction c n done space olog combining theorem 21 obtain corollary 32 mcl 1 f x pspacecomplete similar results exist satisfiability problems proposition 34 h 1 set pltl temporal operators proof 1 let lh 1 p formula g du b bu alt n describes shape models form n formally one show model n n b n exists unique n l n h 1 formula satisfiable iff l 2 u h 1 formula satisfiable already know n built space olog moreover n also built space olog since already know alt n n built space olog n fortiori space olog p describes shape models form c n model c n n n exists unique isomorphic c n l n h 1 formula satisfiable iff satisfiable already know c n built space olog moreover n also built space olog since need count n requires space olog n computing space olog proof proposition 34 also shows combining theorem 21 get corollary 33 sat l 2 u pspacecomplete 32 nphardness propositions show mcl 2 nphard using prop 31 proposition 35 sat l 0 proof consider structures p say n aalternations iff exist positions k hence contains alternation 2n consecutive nonempty segments holds first oddnumbered segments hold evennumbered segments infinite suffix holds continually let us define following formulae 0 one check n 0 structure n aalternations n n thus formula size stating models exactly naalternations aalternation segment composed asegment followed segment l lsegment nonempty finite sequence states l holds true generally n expresses n n holds state belonging n th aalternation also holds exactly n aalternations view encoding valuation v p 1 p n saying p k holds iff b b found kth asegment formally v iff exist encode propositional formula p 1 p n f n lfformula obvious homomorphic rules one see n aalternations v iff f n satisfiable iff f n n proof completed checking f n n l 2 fformula computed space olog transformation 3sat mclf sc85 uses formulae temporal height 1 provide logspace transformation 3sat using formulae two different propositional variables proposition 36 3sat l mcl proof consider instance 3sat conjunction v clauses c disjunction w 3 l ij literals l ij propositional variable x rij negation x rij propositional variable wlog assume n 3 ri distinct consider structure n labeled propositions b figure 3 observe n depends n number different boolean variables occuring fig 3 structure path 0 associate valuation v symmetrically valuation v v unique path n lf formula stating v satisfy clause c done several steps define l ij x r negation involves alternations ab andab r cannot satisfied starting nr r r thus 0 rth positive occurence b b necessarily satisfied r u r hence define satisfiable finally computed space olog corollary 34 mcl 2 npcomplete 14 demri ph schnoebelen 4 fragments one proposition section give polynomialtime algorithm l 1 u relies linearsized b uchi automata recall standard approach pltl satisfiability model checking computes given pltl formula b uchi automaton 7 recognizing exactly models alphabet b uchi automaton set possible valuations propositional variables satisfiability nonemptiness checking whether path satisfies done computing synchronous product checking nonemptiness resulting system larger b uchi automaton method first presented wvs83 first algorithm computing given complexity approach comes fact exponential size indeed rest easy lemma 41 var94 possible given buchi automaton recognizing models formula kripke structure say non deterministic space ologt loga whether computation accepted remarks easily follows fragments pltl low complexity corresponding small 41 fragment l u consider single proposition p linear model equivalent modulo stuttering one following n n ndef 3 n 6 depend n satisfiable l lemma 42 iff n 7 muller automaton alternating b uchi automaton proof structural induction using fact first suffix n n eg first suffix n 1 n1 first suffix n 2 n 1 recognizing n easy lemma 43 1 6 n n exists buchi automaton n buchi automaton n st n accepts model iff furthermore n n states generated uniformly using log n space proof show 2 3 examples see fig 41 2 n fig 4 b uchi automata lemma 43 combining lemmas 41 43 see problem deciding given 0 state given n n 1 6 whether path starts 0 st n solved non deterministic space ologn deterministic time similarly problem deciding whether path n st solved complexity theorem 41 model checking l 1 u p proof consider kripke structure state 0 n path 0 satisfying l conversely n path starting 0 0 possible check whether contains path polynomialtime consider seen time ok check demri ph schnoebelen time okt whether 0 admits path k also consider know km correct check whether admits path k complete algorithm needs ot 2 time remark 4 1 know whether mcl 1 u phard know nlhard 8 open question applies sat l looking algorithm used proof theo 41 appears 9 open question linked important open problem remained unnoticed many years open problem 41 complexity model checking path path finitely presented lineartime structure given deterministic kripke structure ie state exactly one successor regular expression uv u v finite sequences valuations model checking path clearly p known whether phard nl somewhere 42 fragment l proposition 42 sat l 1 x npcomplete proof satisfiability lx np lx temporal height k enough guess first k states witness model checking also np reason nphardness sat l 1 x shown reduction 3sat consider boolean formula propositional variables p 1 p n replace resulting l prop 31 1 x nphard proposition 43 k n sat l k u x l proof key observation finite number essentially distinct formulae given fragment l k given n k one compute finite subset j k 8 one easily shows already mcl 1 1 nlhard reduction gap graph accessibility problem jon75 9 vardi pointed connection us 1 l k equivalent j k canonical representative 2 j j equivalent given satisfiable iff canonical representative canonical representative j k n finite precisely j 0 j k1 n 2 2 oj k assume n k fixed consider problem given computing canonical representative equivalently index 1 n done compositional way j representative k u say representative u j need compute finite table u operators temporal boolean tables computing canonical representative amounts evaluating expression fixed finite domainwhich done logspace see lyn77 proposition 44 k n mcl k u x nl proof proof prop 43 l k logspace canonical representative lemma 41 checking whether done non deterministic space olog log since n k fixed constant mcl k u x nl 1 nlhard remark 41 get corollary 41 1 k 1 n set h 1 temporal operators mcl k contrast lyn77 mcl 0 u x l concludes study fragments bounded number proposi tions remaining article bound removed 5 qbf mclu section offer logspace transformation validity quantified boolean formulae qbf model checking lu involves rather simple constructions models formulae reduction adapted various fragments apart fact offers simple means get pspace hardness obtain new master reduction wellknown logical problem demri ph schnoebelen sideeffect establish mcl 2 pspacehard subsumed reduction literature consider instance qbf form q z every q r 1 r n universal existential quantifier 0 propositional formula without quantifier consider wlog 0 conjunction clauses ie every l ij propositional variable x rij negation x rij propositional variable question decide whether valid recall lemma 51 valid iff exists nonempty set v x valuations correctness closure v v r q v v associate kripke structure given figure 5 using labels 1 assumes infinite path starting n fig 5 structure associated q1x1 qnxn 0 0 n picks boolean valuation variables x reaches wm goes back b r labeled state 1 r n possibly distinct valuations x r x r1 x n picked position lying n next wm notion current valuation associates x r depending latest u r r node visited associate set vs valuations current positions visits n infinitely many positions consider r q assume whenever visits r1 visits r u r visit r1 lu let clo clo vs closed sense lemma 51 whenever visits l j state say agrees current valuation v v l ij written lu using fact current valuation x r cannot changed without first visiting b r state vs correct sense lemma 51 lemma 52 let valid proof vs nonempty closed correct valid conversely valid exists validating v lemma 51 v one build infinite path starting 0 lexicographical enumeration v easily constructed clo ensure corr visit n next wm visits states validated current valuation v possible v 0 worth observing belongs l 2 computed logspace th using prop 32 get corollary 51 qbf l mcl 2 corollary 52 mcl 2 pspacehard 6 qbf mclf x section 5 consider instance q l ij qbf associate kripke structure given figure 6 demri ph schnoebelen path starting 0 seen infinite succession segments length segment directly yields valuation x form infinite sequence v 1 v 2 necessarily repetitions let vs denote associated set fig 6 structure associated q1x1 qnxn using f x easy state segment visits l j states way agrees corresponding valuation implies vs correct sense lemma 51 remains enforce closure vs require valuations visited according lexicographical ordering cycling means successive choices truth values universally quantified propositional variables behave successive binary digits counting modulo assuming n universal quantifiers q 1 q n usual existentially quantified variables free vary earlier variable varied assume moving valuation v successor v t1 require v remains unchanged iff r r q r written change z r r q restricted universally quantified variables behaves like counting modulo 2 n assume q r moving v successor v change unless v equivalently latest r r q thanks assumption counting equivalently means universally quantified x r change following existentially quantified x r v change either following mean q r q r ie r scr behaviour written vx r change z r scr vx r change z r define lemma 61 0 iff valid proof vsvalidates explained conversely somev validates enumerating v lexicographical order easy build computed logspace using prop 33 get corollary 61 qbf l mclfx l mcl corollary 62 mcl 7 bounding temporal height section investigate complexity satisfiability model checking temporal height bounded section 5 already know 22 demri ph schnoebelen first consider ways reducing temporal height sections 71 72 show improve upper bounds temporal height 2 sections 73 74 71 elimination x model checking assume kripke structure k n possible partially unfold kripke structure k state codes state 0 k next states 1 k already chosen k labeled new propositions encoding fact satisfy j formally let k n p first let p rop k def defined kripke structure r j 1 k peculiar unraveling also called bulldozing see eg seg71 fig 7 contains simple example observe k ot k1 k computed fig 7 example bulldozing 2 side side space ologk say formula innernexts occurrences x subformulae form xx xa propositional variable innernexts k nested x replace x j propositions obtain new formula denoted k starting 1 k k computed space ologt formulae innernexts using following equivalences lefttoright rewriterules possible translate pltl formula equivalent one innernexts translation may involve quadratic blowup size modify number propositional variables temporal height formula 10 corollary 71 k n set h 1 pltl temporal combina tors mcl k proof given l k x somet transform equivalent innernexts evaluate k k corollary 72 mcl k x l mcl k f x np fixed k 0 nphard seen proof nphardness sc85 hence k 1 mcl k 72 elimination x satisfiability elimination x satisfiability relies ideas satisfiable thanks 1 k converse true consider given gagxa clearly satisfiable 1 ga 0 ga 1 satisfiable k satisfiable may satisfiable model k using l 2 express fact given model k satisfiable iff k actually approach based standard renaming techniques get us fur ther write denote formula obtained replacing occurences rules may introduce xs righthand side u repaired later replace x j demri ph schnoebelen inside occur satisfiable iff ga using repeatedly systematically remove renaming 2 exists least one occurence scope two temporal combinators lefthand side u example faufgb gb replaced faufa 1 new new new gb turn replaced new 1 new new gb new fa 1 new starting repetitive construction eventually halts found resulting formula temporal height 2 uses flat satisfiable iff computed logspace proposition 71 set h 1 pltl temporal combinators corollary 73 sat l 2 pspacehard 73 satisfiability without temporal nesting consider formulae l 1 u x ie without nesting temporal opera tors main result proposition 72 assume l 1 u x satisfiable satisfiable model j guessed checked polynomial time hence corollary 74 set h 1 pltl temporal combinators np hence npcomplete proceed proof prop 72 main tool notion extracted structure definition 71 extraction pattern infinite sequence n 0 increasing natural numbers given extraction pattern n structure extraction along n structure 0 1 copy n consider formula l 1 u x since temporal height 1 boolean combination atomic propositions temporal subformulae form x u temporal height 0 example given temporal subformulae definition 72 u x extract set positions called witnesses rules 0 always witness temporal subformula may require one witness 1 temporal subformula x 1 witness 2 temporal subformula u three cases u smallest position witness observe j j ii f witness needed iii otherwise u f let smallest position witness observe j clearly n 0 witnesses k continue earlier example let structure c never holds indeed xa auc witness xa 1 witness 6 since case definition 72 6 first position holds witness needed auc since case b witness aub 4 since case c 4 first position hold finally witnesses 0 1 4 6 lemma 71 let l 1 u x structure let n extraction pattern containing witnesses let structure extracted along n subformula iff 26 demri ph schnoebelen proof induction structure since cases obvious need deal case 1 u 2 show 1 u 2 iff 1 u 2 assume 1 u 2 let witness 1 u 2 2 appears n n n n copies j j hence 1 u 2 remember 1 2 temporal operator assume 1 u 2 1 u 2 witness therefore witness 1 u 2 appears n may conclude proof prop 72 consider satisfiable u x assume let n 0 n k witnesses turn extraction pattern considering sequence n 0 prolongated n k1 n k2 n ki positions states carrying valuation must least one valuation appearing infinitely often extracted form required prop 72 continuing previous example assuming valuation 6 appears infinitely often resulting made 0 1 4 6 satisfies 74 model checking without temporal nesting consider model checking formulae temporal height 1 proposition 73 mcl 1 u x np proof consider l 1 u x assume path starting witnesses consider extraction pattern containing witnesses w extracted path may imply retain positions n w following ensure connectivity case possible find extraction pattern n k appears position l k therefore seen along path form guessing path checking done non deterministic polynomialtime corollary 75 set h 1 pltl temporal combinators 8 concluding remarks article measured complexity model checking satisfiability fragments pltl obtained bounding 1 number atomic propositions 2 temporal height 3 restricting temporal operators one allows table 1 provides complete summary table use u denote u u since one outcome study problems considered computational complexity replaced weaker flat thereby ruining hopes dam99 general conclusions read table cases reduction complexity occurs two propositions allowed temporal height two moreover cases equal fragments satisfiability model checking belong complexity class still table displays exceptions two deserve comments 1 model checking satisfiability l one proposition p admittedly fragment relevant comes say protocol verification moreover open whether problems phard nl quote possibilities 2 model checking l k shows fx simpler u nphardness already intractable result immediately suggest improved deterministic algorithms however isolated fragment relevant another way see results focus general techniques developed provided simple transformation qbf model checking problems formalized number logspace transformations leading basic rules thumb 1 number propositions fixed satisfiability transformed model checking 28 demri ph schnoebelen 1 complete summary complexity measures checking satisfiability lf npcomplete sc85 npcomplete on80 propositional variables encoded one f sometimes x next allowed 22 two u allowed 3 arbitrarily many propositions allowed temporal height reduced 2 f allowed model checking logics x transformed model checking without x besides formula temporal height 1 knowing whether depends places time techniques used strengthen earlier hardness results showing also apply specific fragments cases develop specific arguments showing complexity really decreases identified threshold values general situation study lower bounds preserved fragments taken account hence investigations give formal justification alleged simplicity simple practical applications rather show several natural suggestions sufficient understanding taming complexity linear temporal logics remains important issue present work seen additional contribu tion ground open investigations think future work could different finer definitions fragments witness ees90 inspired practical examples aim defeating one hardness proofs eg forbidding renaming technique use sections 71 72 restrictions models rather formulae complexity measures eg average complexity separated complexity measure models formulae analysis hard easy distributions additionaly must noted considered satisfiability model checking ignored problems important verification module checking semantic entailment r automata based symbolic reasoning hardware verification algebraic study diodorean modal systems flatness weakness another look ltl model checking computational complexity satisfiability temporal horn formulas propositional lineartime temporal logic complexity theoremproving procedures almost quadratic class satisfiability problems flat fragments ctl ctl simple tableau system logic elsewhere execution proof hornclause temporal logic expressively complete temporal logic without past tense operators mazurkiewicz traces complexity concept languages information computation complexity propositional linear temporal logics simple cases extended abstract limits efficient temporal decidability modalities model checking branching time logic strikes back temporal modal logic perspective certain polynomial time solvable classes satisfiability effect bounding number primitive propositions depth nesting complexity modal logic recurring dominos making highly undecidable highly understandable complexity poor mans logic model checker spin propositional dynamic logic deterministic relating linear branching model checking good temporal logic model checking ctl checking finite state concurrent programs satisfy linear specification specification ctl log space recognition translation parenthesis languages hierarchical verification asynchronous circuits using temporal logic temporal logic reactive concurrent systems specification size refutation kripke models linear modal tense logics computational complexity complexity propositional linear temporal logics essay classical modal logic three vols complexity modal logics initially temporal logic expressive reasoning infinite computation paths extended abstract tr complexity propositional linear temporal logics modalities model checking branching time logic strikes back characterizing finite kripke structures propositional temporal logic temporal modal logic temporal logic reactive concurrent systems computational complexity satisfiability temporal horn formulas propositional lineartime temporal logic effect bounding number primitive propositions depth nesting complexity modal logic complexity concept languages model checker spin automata based symbolic reasoning hardware verification logic myampersandldquoinitiallymyampersandrdquo myampersandldquonextmyampersandrdquo checking finite state concurrent programs satisfy linear specification log space recognition translation parenthesis languages specification ctl past verification ctl another look ltl model checking perspective certain polynomialtime solvable classes satisfiability nontraditional applications automata theory complexity propositional linear temporal logics simple cases extended abstract complexity poor mans logic model checking ctl fctl hard relating linear branching model checking flatness weakness simple tableau system logic elsewhere expressively complete temporal logic without past tense operators mazurkiewicz traces complexity theoremproving procedures ctr nicolas markey philippe schnoebelen mucalculus path checking information processing letters v97 n6 p225230 31 march 2006 alexander rabinovich philippe schnoebelen btl f laroussinie ph schnoebelen turuani expressivity complexity quantitative branchingtime temporal logics theoretical computer science v297 n13 p297315 17 march stphane demri polynomial space construction treelike models logics local chains modal connectives theoretical computer science v300 n13 p235258 07 may demri f laroussinie ph schnoebelen parametric analysis stateexplosion problem model checking journal computer system sciences v72 n4 p547575 june 2006
generic validation structural content parametric modules demonstrate natural mapping xml element types ml module expressions mapping inductive definitions common xml operations derived module expressions composed show derive generic way validation function checks xml document conformance dtd document type definition one view validation assigning ml types xml elements validation procedure prerequisite typeful xml programming ml mapping uses parametric module facility ml contrived way example validating wml wap markup language documents need use 36ary type constructors well higherorder modules take many 17 modules input one systematically model xml dtds module level suggests mllike languages suitable typesafe prototyping dtdaware xml applications b introduction motivation xml extensible markup language language tagging documents structural content 2 xml document tagged tree nested elements xml extensible xml document include dtd doc ument type lists tags elements specifies tagging constraints central concept document processing validation xml document valid content tagged constraints specified submitted international conference functional pro gramming 2001 available technical report triis 001005 institute information science academia sinica taipei taiwan httpwwwiissinicaedutw comments suggestions welcome dtd xml document wellformed element enclosed matching starttag endtag wellformed xml document necessarily valid following xml document contains dtd defines two element types folder record document contains root folder element empty record element child valid xml document xml version10 folderfolderrecord element record empty dtd xml document models structure record must contain element folder empty contains another folder one may think modeling tidy bookmark file following three elements f3 valid items f1 f2 note record shorthand recordrecord tag sequence recordfolderrecordfolder example notwellformedness simplify discussion may say element type dtd specified element content model ie tagging constraint unambiguous regular expression element type names symbols content model element type specifies element sequences allowed children element naturally coding xml programs one need map element types dtd corresponding data types source programming language requirement mapping content validation translated type correctness programming language welltyped programs always produce valid xml elements note goes beyond required socalled validating xml processor need report violations element content models input xml document need impose restrictions output several directions programming language support writing xml applications classify following three categories adt wellformed elements abstract data types accompanying library routines designed traverse transform wellformed xml elements xml data assumed validated separate phase validation separate issue may even required examples category include standard xml api c java languages eg document object model dom 1 combinator approach writing xml processing functional programs 3 18 type translation dtd strongly typed language used xml programming type system language used embed dtds embedding complete every element type corresponding data type embedding language sound expression embedding language evaluates valid xml element expression welltyped language examples category include haxml 3 18 xmlambda 14 strongly typed language statically typed soundness proof done type checker compile time hence typecorrect program produce invalid xml elements one also use constraintbased languages logic programming languages encode content models similar way 19 type translation approach completely satisfactory two reasons one type translation may systematic tedious done manually inconvenience code generic xml processing operations need rewritten every dtd translated different types xml content validation check wellformed xml documents conformance dtds generic operation native language support dtd new languages designed builtin xml support help build xmlrelated applications xduce functional language regular expression types allow direct representations dtds processing valid elements expressions language evaluated valid xml elements variables must annotated element types concept validation built language type correct ness programs typechecked compiletime xduce also provides regular expression patterns help write concise xml programs xduce however currently firstorder monomorphic language lacks language features eg module system paper show use parametric modules mllike languages write xmlsupporting program modules expressive generic expressive xml dtds constructed provided parametric modules generic common operations including validation function automatically generated approach advantages type translation approach native dtd support approach without disadvantages need recode generic operations need design new language 2 illustrating example tidy bookmark example described section 1 following actual code write objective caml specify dtd produce validation functions two element types dtd module struct type x0 record x1 let map f0 module struct module module module tag bookmarktag module module tidysys contains two modules f0 f1 translations word word objective caml module language xml element type declarations folder record higherorder module alt seq star plus ideally would like define two xml element types two mutually recursive ml modules t0 t1 following module objective caml mllike languages support recursive modules instead use two place holder modules p0 p1 two parameters higherorder modules alt seq etc use another higherorder module mu pronounced derive two simultaneous fixed points module tidydtd contains ffl module u defines type wellformed elements ffl module v contains modules t0 t1 defines type valid folder record elements ffl functions validate forget provide mappings wellformed elements valid elements also defines exception invalid may raised function validate note following equations always hold forget validate sample element f3 shown section 1 defined validated following objective caml code f3 u wellformed f3 v addition valid element returned validation function parsed typed sense substructures given specific types extracted using ml patternmatching paper use example explain idea describe construction however idea construction systematically applied dtds element types one need define nary fixed point module mun take system n nary higherorder modules f0 f1 produce simultaneous fixed points definition mun symmetric similar mu later use wml markup language wireless applications whose dtd defines 35 element types benchmarking example show effectiveness approach 3 genericprogrammingwithpara xml element types folder example translated objective caml using series type definitions shown type b alt l r b type b list type plus one plus folder record folder record alt star seq folder folder record alt plus seq alt one abstract righthandsides type equations folder record two binary type constructors f0 f1 view folder record least fixed points f0 f1 functions folder record syntactic sugars defined let folder ulist bookmarktagfolder tidydtduup ulist let record ulist bookmarktagrecord tidydtduup ulist type b b alt plus seq alt type b folder folder record f0 record record folder record f1 one rewrite f0 f1 using two projection functions p0 p1 empty type constructor type b type b type abp1 abp0 abp1 alt star seq type point clear one program module level define f0 f1 two module expressions using predefined set constant modules p0 p1 empty unary parametric modules star plus binary parametric modules alt seq shown figure 1 also define map function inductively xml element types defined using fixed set parametric modules may say modules f0 f1 objects functor category object type constructor map types types function map map typed functions typed functions parametric modules like plus arrows functor category ie natural transformations view definition map function generic one map instance inductively indexed governing type expression later show definitions generic values used definition validation function generic well 4 parametriccontentmodelsand simultaneous fixed points figure modules f0 f1 defines binary type constructor two type constructors used together mutually define types folder record code reproduced module f0 module f1 folder folder record f0t record record folder record f1t type constructors f0t f1t parametric content models sense maps tuple type instances content model example given type instances folder record type expression folder record f0t expands record folder record alt star seq module type sig type b val map x b module type module type module empty struct type b let map f g module p0 struct type b let map f g module plus struct type b one b ft b ft b let rec map f g match one one fmap f g v w module struct type b let map f g u f1map f g v module p1 module star module alt module f0 module f1 folder folder record f0t record record folder record f1t figure 1 inductive definitions xml element types using parametric modules note module type annotations often omit ted w take f2f part module plus time expose implementation module plus annotations added clarity typechecking purposes folder folder record alt plus seq alt exactly xml content model element type folder main idea use type constructors parametric content models view xml element types simultaneous fixed points set parametric content models viewpoint helps us develop primitive functions abstract applicable different content models primitives polymorphic one primitives simultaneous induction operator fold function later show validation procedure defined using fold function model two recursively defined xml element types two interdependent ml modules t0 t1 signatures following module t0 sig type x0 x1 cm val t0t t1t cm t0t val t0t t0t t1t cm module t1 sig type x0 x1 cm val t0t t1t cm t1t val t1t t0t t1t cm type constructor x0 x1 cm parametric content model type element type functions map element content model together define equivalence note mutually defined signatures allowed objective caml mllike languages however one use auxiliary type names additional type sharing constraints overcome problem define higherorder module muvalid derives modules t0 t1 given module specifies corresponding parametric content models tag set see figure 2 figure 2 modules f0 f0 input module specify parametric content models module tag specifies tag set note module returned muvalid type valid elements simply defined disjoint sum type t0t type t1t also note simultaneous fold function type val fold b t0cm t0t t1t b function fold returns two reduction functions whose types t0t t1t b given two properly typed induction functions bases whose types b t0cm b t1cm b similarly higherorder module muwf defined derive module wellformed elements see figure 3 module muwf type constructor x0 x1 cm parametric content model wellformed elements defined list tagged values list type u type wellformed elements defined fixed point parametric content model cm type note well type wellformed elements type defined disjoint sum u u representing elements two distinct tags definition simultaneous fold function module muvalid figure 3 several functions module u2v v2u given types left undefined used specify functions validate forget function validate maps wellformed element valid ele ment forget inverse function let us look functions cm0 cm1 module u2v first types following val cm0 vt0t vt1t ucm vt0t vt1t vt0cm val cm1 vt0t vt1t ucm vt0t vt1t vt1cm function cm0 maps wellformed content whose constituting parts valid elements already valid content function cm0 composed function vt0up one gets function returns valid element type vt0t result use function composition operator given two functions inductive bases simultaneous fold function one derives validation functions elements types vt0t vt1t module type sig type x0 x1 val map x0 y0 x1 y1 module type sig module f0 fun module f1 fun module tag tag module struct module tag stag module struct let let v0 module struct let let v0 let fold f0 let rec t0down t1down figure 2 module muvalid derives element types simultaneous fixed points set parametric content models module struct module list let map type let u let fold f0 let rec module struct module module module exception invalid module struct let cm0 vt0t vt1t ucm vt0t let cm1 vt0t vt1t ucm vt0t let t0 t1 uu vt0t uu ufold vt0up let ut module struct let cm0 uu uu vt0cm let cm1 uu uu vt1cm let t0 t1 vt0t uu vt1t vfold uup let vt figure 3 module muwf derives type wellformed elements module mu uses simultaneous fold define validation function note type annotations functions added clarity purpose ufold vt0up recall types wellformed elements valid elements defined follows validation function defined ufold vt0up shown figure 3 one define function forget similar way remains shown functions like cm0 cm1 defined content models shown next 5 generic validation content models recall figure 1 map function defined generic way module signature fun long module generated predefined set parametric modules empty p0 p1 star etc vaildation forgetting functions defined generic way well first define validation functions inductive bases validation function content model derived automatically module expressions content built two remaining details first time building content model one access tag module tag module signature tag defines variant data type tagging elements eg module bookmarktag section 2 therefore validation forgetting functions must reside higherorder module takes tag module input one need also maintain nullable condition first set element tags content model nullable accepts empty element sequence first set contains tags appear first position valid sequence used check content model ambiguous eg first sets two input modules alt overlap combined lookahead tag used implement nonbacktracking validation procedure well section 8 nullable first generic values module signature fun parametric content model consists following components module type sig type x0 x1 val map x0 y0 x1 y1 val nullable bool val first natsett module content functor tag sig val validate x0 x1 tt list val forget x0 x1 x0 x1 tt list function validate takes list tagged values turns value content model followed remaining list note type input x0 x1 tt list content model wellformed element two share tag set figure 4 illustrates construction showing implementations modules p0 star validation forgetting functions wrapped module content definition content inductive depends content module input module f see eg module expression module star view constituting generic definition validation function instance systematically generated module expression evident module star adapt longest prefix matching rule validating input element sequence content model longest prefix matching rule indeed required xml validation functions modules ie empty p0 p1 plus seq alt similarly defined omitted return figure 3 complete defintions functions cm0 cm1 modules u2v v2u defined following module struct module let cm0 ulist match cm0validate ulist v v raise invalid module struct module function cm0 module u2v need validate input sequence tagged value content model element type vt0t using current tag set accomplished using validation function module sysf0contentsystag difference remains nonempty sequence validated longest prefix entire sequence valid respect content model vt0t module p0 struct type x0 natsetoflist 0 module content functor tag struct let validate ulist match ulist tfold fun x x fun x success return untagged value along remaing list otherwise returns none let forget tx0 tag first variant type tt module star struct type x0 ffirst module content functor tag struct module let rec validate ulist match ulist ulist h first match cmvalidate ulist u match validate us uus else ulist let rec forget match figure 4 generic definition content validation functions 6 typefulxmlprogramminginml one purposes validation assign type xml element programming validated xml elements programming typed values using statically typed langauge programming allows one detect type errors hence expressions invalid elements compile time generic validation procedure gives types valid ele ments allows one construct xml processors typeful way following illustrating diagram let u ml type wellformed elements v v 0 ml types correspond specific xml element types u validate f forgetwe may say functions u u untyped may produce invalid elements however functions typed always output valid elements whenever one programming function expects output also valid one programming figure 5 show ml code fragment illustrate approach code maps wellformed tidy bookmark wellformed flat bookmark function tidy2flat u mapping composed typed conversion routine function tidy2flat v always output valid element input element valid note types functions inferred ml functions annotated types figure 5 clarity purpose 7 combing genericity poly morphism generic modeling xml dtds combined type polymorphism better result indeed use genericity polymorphism model xml element type declarations accompanied attributelist declarations extend previous folder example requiring optional subject attribute folder element pair title url attributes record element following valid xml document newly extended dtd xml version10 folderfolderrecord element record empty subject attlist record title module module struct module module module tag tag module module module module module module let t2ffolder fun fd match fd case flat record r followed sequence flat records folders case flat folder f followed nonempty sequence flat records folders let t2frecord let flattenv tidyfoldert tidyrecordt tagt tagmap tidydtdvfold flatrecordup let flattenu tidydtdut flatdtdforget figure 5 example typeful xml programming note type annotations functions added clarity purpose url folder subjectresearch institutes record titleacademia sinica urlhttpwwwsinicaedutw original definitions folder record figure 1 last two lines folder folder record f0t record record folder record f1t replaced following type u v folder u v record record v u vfolder u vrecord f1t string option string attribute declarations modeled type level lifted model level needed generic definition validation function modified accordingly accommodate validation check attribute formats values 8 xml content validation xml requires content models element type declarations deterministic bruggemannklein wood clarified requirement meaning 1unambiguity 7 8 regular expression 1unambiguous sequence symbols recognized deterministically onesymbol lookahead corresponding nondeterministic finitestate machine example content model b cb 1unambiguous given initial b one cannot know b model matched without looking ahead see follows b however equivalent content model bcd 1unambiguous 2 use nullable predicate first set check whether content model specified module expression 1unambiguous check performed module elaboration time ambiguous content model detected exception raised soon possible content model may also contain epsilon ambiguity allowed xml demands additional work validation example epsilon ambiguity ab empty sequence derivable b besides element content models ie regular expressions element type names xml element type may use content specifications example element type may empty specification mixed content specifi cation specifications impose additional difficulty definition generic validation function specification means sequence child elements may contain elements declared element types including text order mixed content specification allows text data interspersed elements prescribed types one may think special case mixed content one view text data denoted parsed character data mixed content specification elements enclosed within pair implicit text starttag text endtag pcdata module similar empty module already defined help inductive definitions mixed content specifications ex ample dtds 2 element types one define module following using 3ary alternative module alt3 module 9 experience larger dtds wml markup language wap applications dtd consists 35 element type definitions applied generic approach validate wml documents order need produce ml modules include operate upon 36ary type constructors 35 element types plus 1 pcdata also need construct higherorder modules take many 17 modules input one element type definitions needs 17ary alt mod ule experience quite satisfactory code compiled without problem objective caml compilation time negligible 1 min desktop workstation validation time negligible ever least smallish examples tried around 100 elements working larger dtds documents collecting performance data size ml source code quite large however take following ml module expression example module one need 10ary module seq10 construct required content model specifies sequence 10 elements different element type code module seq10 looks like following module struct type x0 x1 x35 x0 x1 x35 f1t x0 x1 x35 f9t clear dtd n element types source module seq code size omn worst case dtd length n code need unique type variables contain type sharing constraints length 2 overall code size 2 source code necessary ml modules 35element wml dtd size 05 mb compiled produces binary size 175 kb cmo file objective caml interface size 23 mb cmi file objective caml ml code wap examples accessible following url httpwwwiissinicaedutwtrcxdotmlhtml one connected component analysis dtd set element types partitioned disjoint subsets typedependency sub sets subset k element types need use kary type constructors overall code size modules used subset reduced 10 related work conclusion section 1 introduced previous work uses existing new functional languages model program xml dtds wealth research system work related xml content modeling necessarily perspective functional programming languages list bruggemannklein wood addressed problem ambiguous xml sgml content models based theory regular languages finite automata 7 8 particu lar showed linear time suffices decide whether content model ambiguous showed regular expressions star normal form epsilon normal always unambiguous 9 glushkov automaton corresponds regular expression used checking ambiguity unambiguous validation well murata proposed data model xml document transformation based forestregular language theory 15 16 model lightweight alternative xml schema provides framework schema trans formation also work type modeling document transformation structured editing systems using data types 5 however none work used specific programming language modeling language xml schema maturing specification language xml content developed world wide web consortium 4 xml schema expressive dtd specification language uses xml syntax difference xml schema dtd seems xml schemas ability derive new types extending restricting content models existing types xml schema also provides substitution groups mechanism allow elements substituted elements investigating whether mllike module languages expressive enough model mechanisms backhouse jansson jeuring meertens written detailed introduction generic programming 6 see also introduction foldunfold meijer fokkinga paterson 13 well work using foldunfold structuring reasoning program semantics hutton 12 extension simple fold simultaneous fold seems new work generic programming functional programming research community seems rely mechanism type class derive typespecific instances generic functions language choice often haskell shown paper parametric module mechanism mllike languages suitable generic programming well fact think parametric modules allow one take finer control inductive derivations generic values powerful module systems developed allow mutually recursive modules well modules depend values types see eg russo 17 however showed lack recursive modules need problem long mutual dependency modules interdependent type definitions viewed context work thought use ml module facility generate deterministic automata specialized validation elements specific dtd validation automata also gives types elements parts additional construction validation automata entirely generic au tomated work also serves usage case ml parametric modules used stress test current ml implementations delight see contrived code 36ary type constructors 17ary higherorder modules compiled executed problem objective caml 11 r xml schema part 0 primer type modelling document transformation structured editing systems generic programming introduction anne brugemannklein derick wood anne bruggemannklein xduce typed xml processing language regular expression types xml fold unfold program semantics functional programming bananas transformation documents schemas patterns contextual conditions data models document transformation assembly haskell xml generic combinators typebased translation proceedingsin proceedings international conference functional programmingproceedings logic programming approach supporting entries xml documents object database tr functional programming bananas lenses envelopes barbed wire regular expressions finite automata oneunambiguous regular languages underappreciated unfold fold unfold program semantics haskell xml regular expression types xml recursive structures standard ml logic programming approach supporting entries xml documents object database outofcore functional programming typebased primitives transformation documents schemas patterns contextual conditions xduce algebra xml query data model document transformation assembly ctr tyngruey chuang janli lin modular transformation structural content proceedings 2004 acm symposium document engineering october 2830 2004 milwaukee wisconsin usa
elimination java array bounds checks presence indirection java language specification states every access array needs within bounds array ie 0 array length 1 different techniques different programming languages proposed eliminate explicit bounds checks techniques implemented offtheshelf java virtual machines jvms underlying principle techniques bounds checks removed jvmcompiler enough information guarantee sequence accesses eg inside forloop safe within bounds techniques elimination array bounds checks developed programming languages support multithreading andor enable dynamic class loading two characteristics make tech niques unsuitable java techniques developed specifically java addressed elimination array bounds checks presence indirection index stored another array indirection array objective optimising applications array indirection paper proposes evaluates three implementation strategies implemented java class classes provide functionality java arrays type int objects classes used instead indirection arrays strategy enables jvms examining one classes time obtain enough information remove array bounds checks b introduction java language jsgb00 specied avoid common errors made software developers arguably memory leaks array indices outofbounds type inconsis tencies features basic pillars make java attractive language software development basic pillars java builds rich api distributed network graphical programming builtin threads features even important considering signicant eort devoted make java programs portable cost enhanced language features iswas performance rst generation java virtual machines jvms ly99 bytecode interpreters concentrated providing functionality performance much reputation java slow languages comes early performance benchmarks immature jvms nowadays jvms third generation characterised mixed execution interpreted bytecodes machine code generated justintime proling application execution selective application compiler transformations timeconsuming sections application performance modern jvms increasing steadily getting closer c c compilers see example scimark benchmark pm java grande forum benchmark suite bspf01 epc especially commodity processorsoperating systems despite remarkable improvement jvms standard compiler transformations eg loop reordering still included overheads intrinsic language specication remain java grande forum group researchers highperformance computing constituted explore potential benets java bring research areas perspective forum observed limitations noted solutions jav98 jav99 pbg bmpp01 thi02 overhead intrinsic language specication paper addresses array bounds checks java language specication requires array accesses checked run time access outside bounds less zero greater equal length array throws arrayindexoutofboundsexception specic case consideration elimination array bounds checks presence indirection example consider array accesses foo indices6 indices foo java onedimensional arrays type int array foo accessed trough indirection array indices two checks performed run time rst checks access indices scope paper readers interested techniques implemented java jvmscompilers eliminating checks kind array accesses second checks access foo kind array bounds check subject paper array bounds check eliminated java program two things accomplished performance point view rst direct reward elimination check least two integer comparisons second indirect reward possibility compiler transformations due strict exception model specied java instructions capable causing exceptions inhibitors compiler transformations exception arises java program uservisible state program look like every preceding instruction executed succeeding instructions executed exception model prevents general instruction reordering following section motivates work provides description problem solved section 3 describes related work section 4 presents three implementation strategies enable jvms examine one class time decide whether array bounds checks removed solutions described classes included multiarray package jsr083 jsr strategies generated process understanding performance delivered java library oolala luj99 lfg00 lfg02a lfg02b independently jsr section 5 evaluates performance gained eliminating array bounds checks kernels array indirection also determines overhead generated introducing classes instead indirection arrays section 6 summarises advantages disadvantages strategies conclusions future work presented section 7 motivation description problem array indirection ubiquitous implementations sparse matrix operations matrix considered sparse elements matrix zero less 10 elements nonzero elements kind matrix arises frequently computational science engineering cse applications physical phenomena modeled dierential equations combination dierential equations stateoftheart solution techniques produces sparse matrices ecient storage formats data structures sparse matrices rely storing nonzero elements arrays example coordinate coo storage format data structure sparse matrix consists three arrays size two type int indx jndx value oating point data type given index k elements kth position indx jndx represent row column indices respec tively element kth position array value corresponding matrix element elements stored value zero figure 1 presents kernel sparse matrixvector multiplication matrix stored coo gure illustrates example array indirection kernel described commonly used iterative solution systems linear equations estimated 75 cse applications require solution system linear equations one stage another joh82 public class examplesparseblas public static void mvmcoo int indx int jndx double value double vectory double vectorx int figure 1 sparse matrixvector multiplication using coordinate storage format array indirection also occur implementation irregular sections multidimensional arrays mmg99 solution nonsparse systems linear equations pivoting gvl96 consider set statements presented figure 2 statement comment access executed without problems hand statement comment access would throw arrayindexoutofboundsexception exception tries access position 4 array foo int double foo indx0 access foo indx1 access b figure 2 java example array indirection diculty java compared main stream programming languages several threads running parallel one access array indx thus possible elements indx modied statements comments executed even jvm could check classes loaded make sure thread could access indx new classes could loaded invalidate analysis 3 related work related work divided techniques eliminate array bounds checks b escape analysis c eld analysis related eld analysis precursor present work ibms ninja compiler multidimensional array package survey techniques improve performance java applications found kcsl00 elimination array bounds checks best knowledge none published techniques per se existing compilersjvms optimise array bounds checks presence indirection ii suitable adaptive justintime compilation iii support multithreading iv dynamic class loading techniques based theorem probers si77 nl98 xmr00 heavy weight algorithms based data owstyle published extensively mcm82 gup90 gup93 kw95 asu92 cg96 languages provide multithreading another technique based type analysis application functional languages xp98 linear program solvers also proposed rr00 bodik gupta sarkar developed abcd array bounds check demand algorithm bgs00 java designed time constraints analysing program applying transformation runtime abcd targets businesskind applications sparse representation program include information multithreading thus algorithm although interesting purposes cannot handle indirection since origin problem multithreading strategies proposed section 4 provide cheaply extra information enable abcd eliminate checks presence indirection escape analysis 1999 four papers published conference describing escape analysis algorithms possibilities optimise java programs optimal allocation objects heap vs stack removal synchronization cgs wr99 escape analysis tries determine whether object created method thread another object escapes scope creator escape means another object get reference object thus make live garbage collected beyond execution method thread object created three strategies presented section 4 require simple escape analysis strategies provide information class invariants every instance variable escape object otherwise dierent thread get access instance variables update possibly breaking desired class invariant field analysis related field analysis eld analysis grs00 related eld analysis ar01 techniques look one class time try extract much information possible information used example resolution method calls object inlining related eld analysis looks relations among instance variables objects aggarwal randall ar01 demonstrate related eld analysis used eliminate array bounds checks class following iterator pattern ghjv95 strategies presented following section make use concept eld analysis objective provide meaningful class invariant represented instance variables elds however actual algorithms test relations used previous work eld analysis demonstration eliminating array bounds checks given ar01 cannot applied presence indirection ibm ninja project multidimensional array package ibms ninja group focused numerical intensive applications based arrays java midki moreira snir mms98 developed loop versioning algorithm iteration spaces nested loops would partitioned regions proved exceptions null checks array bound checks synchronisations occur found exceptionfree syncronisationfree regions traditional loop reordering transformation applied without violating strict exception model ninja group design implement multidimensional array package mmg99 replace java arrays discovery safe regions becomes easier eliminate overhead introduced using classes develop semantic expansion wmmg98 semantic expansion compilation strategy selected classes treated language primitives compiler prototype static compiler known ninja successfully implement elimination array bounds checks together semantic expansion multidimensional array package loop reordering transformations ninja compiler compatible specication java since doesnt support dynamic class loading semantic expansion technique ensures computations use directly multidimensional array package suer overheard although compiler compatible java mean techniques developed could incorporated jvm techniques would especially attractive quasistatic compilers sbmg00 paper extends ninja groups work tackling problem elimination array bounds checks presence indirection strategies described section 4 generate classes incorporated multidimensional array package proposed java specication request jsr 083 jsr accepted jsr dene standard java multidimensional array package direct consequence ninja groups work strategies described section common goal produce class jvms discover invariants simply examining class thereby derive information eliminate array bounds checks class provides functionality java arrays type int thus substitute objects classes would used instead indirection arrays three strategies generate three dierent classes naturally multidimensional array library one described jsr083 jsr figure 3 describes public methods three classes implement three classes extend abstract class intindirectionmultiarray1d package multiarray public class runtimemultiarrayexception extends runtimeexception public class uncheckedmultiarrayexception extends runtimemultiarrayexception public class multiarrayindexoutofboundsexception extends runtimemultiarrayexception public abstract class multiarray public abstract class multiarray1d extends multiarray public abstract class multiarray2d extends multiarray public abstract class multiarray extends multiarray public final class booleanmultiarray extends multiarray public final class multiarray extends multiarray public abstract class intmultiarray1d extends multiarray1d public abstract int get int public abstract void set int int value public abstract int length public abstract class intindirectionmultiarray1d extends intmultiarray1d public abstract int getmin public abstract int getmax figure 3 public interface classes substitute java arrays int multidimensional array package multiarray part class invariant jvms discover common three strategies values returned methods getmin getmax always lower bounds upper bounds respectively elements stored common part invariant computed example using algorithm constraint propagation proposed abcd algorithm suitable justintime dynamic compilation bgs00 ection mechanism provided java interfere three strategies example program using ection access instance variables methods without knowing names even private instance variables methods accessed way program read write instance variables thereby violate visibility rules circumstances happen depend security policy inplace jvm order avoid interference hereafter security policy assumed 1 security manager inplace 2 allow programs create new security manager replace existing one ie permissions setsecuritymanager createsecuritymanager granted see java 3 allow programs change current security policy ie permissions getpolicy set policy insertprovider removeprovider write security policy les granted see javasecuritysecuritypermission javaiofilepermission 4 allow programs gain access private instance variables methods ie permission suppressaccesschecks granted see javalangreflectreflectpermission jvms test assumptions linear time invoking specic methods java langsecuritymanager javasecurityaccesscontroller objects startup assumptions imply loss generality since authors knowledge cse applications require ection accessing private instance variables methods addition described security policy assumptions represent good security management practice general purpose java programs authoritative detailed description java security see gon98 rst strategy simplest given problem arises parallel execution multiple threads trivial situation occurs thread write indirection array words part problem disappears indirection array immutable immutableintmultiarray1d class second strategy uses synchronization mechanisms dened java objects class namely mutableimmutablestateintmultiarray1d either two states default state mutable state allows writes reads state immutable state allows reads second strategy thought way simplify general case trivial case proposed rst strategy third nal strategy takes dierent approach seek immutability index outside bounds array con generate arrayindexoutofbounds exception ie jvms need include explicit bounds checks number threads accessing writingreading simultaneously indirection array irrelevant long every element indirection array within bounds arrays accessed indirection third class valueboundedintmultiarray1d enforces every element stored object class within range zero given parameter parameter must greater equal zero cannot modied passed constructor 41 immutableintmultiarray1d methods given class divided constructors queries commands mey97 constructors methods class executed without anomalies create new object class addition java constructor must name class queries methods return information state instance variables object methods modify state object depend expression several instance variables commands methods change state object modify instance variables class immutableintmultiarray1d follows simple idea making objects im mutable consider abstract class intindirectionmultiarray1d see figure 3 methods get length getmin getmax query methods method set command method class abstract declare constructors figure 4 presents simplied implementation class immutableintmultiarray1d order make immutableintmultiarray1d objects immutable command methods implemented simply throwing uncheckedmultiarrayexception 1 obviously query methods modify instance variable instance variables data 2 length min declared final instance variables every instance variable initialised constructor public final class immutableintmultiarray1d extends private final int data private final int length private final int min private final int max public immutableintmultiarray1d int values int temp auxmin auxmax new int length int public int get int return datai else throw new multiarrayindexoutofboundsexception public void set int int value throw new uncheckedmultiarrayexception public int length return length public int getmin return min public int getmax return max figure 4 simplied implementation class immutableintmultiarray1d note statements bytecodes terms jvms write instance variables occur constructors instance variables private final two conditions almost enough derive every object immutable another condition instance variables whose type primitive escape scope class escape analysis words instance variables created method class none methods returns reference instance variable declared private life span instance variables exceed uncheckedmultiarrayexception inherits runtimeexception unchecked exception thus methods need neither include signature provide trycatch clauses 2 declaration instance variable type array final indicates array assigned instance variable assignment applied instance variable however elements assigned array modied without restriction creator object example instance variable data escapes scope class constructor implemented shown figure 5 also escapes scope class nonprivate method getarray see figure 5 included class cases number threads get reference instance variable array modify content see figure 6 public final class immutableintmultiarray1d extends public immutableintmultiarray1d int values int temp auxmin auxmax int public object getarray return data figure 5 methods enable instance variable array escape scope class immutableintmultiarray1d public class examplebreakimmutability public static void main string args int new int figure example program modies content instance variable data member every object class immutableintmultiarray1d using method constructor implemented figure 5 consider algorithm checks bytecodes constructors write instance variable every instance variable private final instance variable whose type primitive escape class algorithm determine whether class produces immutable objects ob iv complexity b number bytecodes iv number instance variables hence algorithm suitable justintime compilers jsr083 java standard multidimensional array package jvms recognise class produce invariant without checking constructor provided class immutableintmultiarray1d inecient terms memory requirements constructor implies point execution program would consume double necessary memory space hold elements indirection array constructor included mainly sake clarity complete implementation class provides constructors read elements les input streams implementation method set includes specic test parameter accessing instance variable data test ensures accesses data bounds tests kind implemented every method set get subsequent classes hereafter clarity tests omitted implementations subsequent classes 42 mutableimmutablestateintmultiarray1d figure 7 presents simplied nonoptimised implementation second strategy idea behind strategy ensure objects class mutableimmutablestateintmultiarray 1d two states mutable state default state elements stored object class modied read users risk immutable state elements stored object class read modied strategy relies synchronization mechanisms provided java implement class every object java associated lock execution synchronized method 3 synchronized block 4 critical section given object synchronized method thread start execution method must rst acquire lock object upon completion thread releases lock applies synchronized blocks point time one thread executing synchronized method synchronized block given object java syntax standard java api provide concept acquiring releasing objects lock thus java application contain special keywords invokes method standard java api access lock object concepts part specication execution java applications details multithreading java found jsgb00 lea99 consider object indx class mutableimmutablestateintmultiarray1d implementation class see figure 7 enforces indx starts mutable state state stored boolean instance variable ismutable value kept equivalent boolean expression reader null mutable state implementations method get set expected object indx change state thread invokes synchronized method passtoimmutable state mutable indx changes instance variable ismutable false stores thread executed method instance variable reader 3 synchronized method method whose declaration contains keyword synchronized 4 synchronized block set consecutive statements body method declared synchronized surrounded clause synchronized object fg public final class mutableimmutablestateintmultiarray1d extends intindirectionmultiarray1d private thread reader private final int data private final int length private int min private int max private boolean ismutable public mutableimmutablestateintmultiarray1d int length new int length public int get int return datai public synchronized void set int int value ismutable try wait catch interruptedexception e throw new uncheckedmultiarrayexception public int length return length public synchronized int getmin return min public synchronized int getmax return max public synchronized void passtoimmutable ismutable try wait catch interruptedexception e throw new uncheckedmultiarrayexception public synchronized void returntomutable reader threadcurrentthread else throw new uncheckedmultiarrayexception figure 7 simplied implementation class mutableimmutablestateintmultiarray1d state immutable thread executing method stops 5 state becomes mutable 5 explanation waitnotify thread communication mechanism clarify stops means sen tence wait notify methods part standard java api members class javalangobject java every class subclass directly indirectly javalangobject thus every object inherits inherits methods wait notify methods part communication mechanism java threads example thread executing method passtoimmutable indx immutable state thread starts executing synchronized method acquiring lock indx checking state needs wait state indx mutable thread cannot force state transition needs wait another thread provoke transition rst thread stops execution invoking method wait indx method makes rst thread release lock indx wait second thread invokes method notify indx reacquire lock prior return wait several threads waiting indx ie invoked wait one thread notied second threads invokes notify indx proceeds explained mutable state indx immutable state get method implemented expected set method cannot modify elements data indx returns mutable state object indx returns mutable state thread successfully provoked transition mutabletoimmutable invokes indx synchronized method return tomutable transition completed thread noties threads waiting indx state transition given complexity matching lockingwaitnotify logic statements byte codes write instance variables authors consider jvms incorporate tests kind class invariant thus possibility jvms recognise class part standard java api automatically provide class invariant note requirement proving class invariant instance variables class mutableimmutablestateintmultiarray1d escape scope class 43 valueboundedintmultiarray1d figure 8 presents simplied implementation third strategy implementation class valueboundedintmultiarray1d ensures objects store elements greater equal zero less equal parameter parameter upperbound passed every object constructor cannot modied public final class valueboundedintmultiarray1d extends private final int data private final int length private final int upperbound private final int lowerbound 0 public int upperbound new int length public int get int return datai public void set int int value value lowerbound value upperbound else throw new uncheckedmultiarrayexception public int length return length public int getmin return lowerbound public int getmax return upperbound figure 8 simplied implementation class valueboundedintmultiarray1d implementation method get previous strategies implementation method set includes test ensures elements range stored methods getmin getmax contrast previous classes return actual minimum maximum stored elements lower zero upper bounds information threads java waitnotify mechanism found jsgb00 lea99 tests jvms need perform extract class invariant include escape analysis instance variables class described section 41 mentioned introduction section 4 respect common part invariant construction constraints using data ow analysis modication instance variables previous classes jvms also recognise class produce invariant without checking 44 usage classes section revisits matrixvector multiplication kernel matrix sparse stored coo format see figure 1 order illustrate three dierent classes used figure presents kernel follows recommendations ninja group facilitate loop versioning statements inside forloop produce nullpointerexceptions arrayindexoutofboundsexceptions use synchronization mechanisms new implementation checks parameters null accesses indx jndx within bounds checks made prior execution forloop checks fail none statements forloop executed method terminates throwing exception implementation sake clarity omits checks generate loops free aliases example variables fib aux aliases array according declaration figure 9 int systemoutprintlnare output aliases true figure 9 example array aliases note checks ensure accesses vectory vectorx within bounds require traversing completely local copies arrays indx jndx local copies arrays necessary since indx jndx escape scope method makes possible example another thread modify contents checks execution forloop creation local copies memory inecient approach overhead copying checking element element maximum minimum similar greater overhead explicit checks figure 11 presents implementations mvmcoo using three classes described previous sections checks nullity replaced line comment indicating checks would placed implementation mvmcoo immutableintmultiarray1d complete others include comments statements complete implementation would appear due class invariants implementations include checks accesses vectory vectorx checks passed jvms nd loop free arrayindexout ofboundsexception nullpointerexception implementations mvmcoo immutableintmultiarray1d valueboundedint multiarray1d identical statements dierent method signature implementation mutableimmutablestateintmultiarray1d builds previous implemen tations rst needs ensure objects indx jndx immutable state implementation also requires objects returned state mutable upon completion abnormal interruption public class examplesparseblaswithninja public static void mvmcoo int indx int jndx double value double vectory double vectorx throws sparseblasexception indx null jndx null value null vectory null vectorx null indxlength valuelength jndxlength valuelength int else throw new sparseblasexception figure 10 sparse matrixvector multiplication using coordinate storage format ninjas group recommendations 5 experiments section reports two sets experiments rst set determines overhead array bounds checks cse application array indirection second set also cse application determines overhead using classes proposed section 4 instead accessing directly java arrays words experiments seek experimental lower bound performance improvement achieved array bounds checks eliminated upper bound overhead due using classes introduced section 4 lower bound array bounds checks together strict exception model specied java inhibitors optimising transformations see ninja project 01 improve performance upper bound techniques semantic expansion wmmg98 proposed authors optimising oolala lfg02b lfg02a remove source overhead using class instead java arrays considered example matrixvector multiplication matrix coo format mvmcoo matrix operation kernel iterative methods gvl96 solving systems linear equations determining eigenvalues matrix iterative nature methods implies operation executed repeatedly sucient accuracy achieved upper bound number iterations reached experiments consider iterative method executes mvmcoo 100 times results reported four dierent implementations see figures 10 11 mvmcoo four implementations mvmcoo derived using java arrays ja implementa tion objects class immutableintmultiarray1d ima implementation class mutable immutablestateintmultiarray1dmima implementation class valueboundedintmulti array1d vbma implementation experiments consider three dierent square sparse matrices matrix market collection bpr 97 three matrices utm5940 size 5940 83842 nonzero elements s3rmt3m3 size 5357 106526 entries symmetric s3dkt3m2 size 90449 1921955 entries symmetric implementations take advantage symmetry thus s2rmt3m3 s3dkt3m2 stored operated using nonzero elements vectors vectorx vectory see implementations figures 10 11 initialised random numbers public class kernelsparseblas public static void mvmcoo immutableintmultiarray1d indx immutableintmultiarray1d jndx double value double vectory double vectorx throws sparseblasexception nullchecks int else throw new sparseblasexception public static void mvmcoo double value double vectory double vectorx throws sparseblasexception idem implementation mvmcoo immutableintmultiarray1d throw statement include returntomutable indx andor jndx else throw new sparseblasexception public static void mvmcoo double value double vectory double vectorx throws sparseblasexception idem mvmcoo immutableintmultiarray1d figure 11 sparse matrixvector multiplication using coordinate storage format ninjas group recommendations classes described figures 4 7 8 according uniform distribution values ranging 0 5 zeros respectively experiments performed 1 ghz pentium iii 256 mb running windows 2000 service pack 2 java 2 sdk 131 02 standard edition jove static java compiler version 20 associated java 2 runtime environment standard edition 130 programs compiled ag hotspot jvm executed ags server xms128mb xmx256mb jove used following two congurations rst hereafter refer jove creates executable windows program using default optimisation parameters optimization level 1 lowest level second conguration namely jovenochecks conguration plus ag eliminates every array bounds checks experiment run 20 times results shown average execution time seconds timers accurate millisecond run total execution time mvmcoo recorded recall execution one experiment implies program loop executes 100 times mvmcoo table 1 presents execution times ja implementation compiled two congurations described jove compiler fourth column gives overhead induced array bounds checks overhead 903 983 percentage execution time matrix jove jovenochecks overheard s3rmt3m3 1700 1538 951 table 1 average times seconds ja implementation mvmcoo table 2 presents execution times four implementations mvmcoo case jvm hotspot server part described java sdk environment table 3 gives overheads implementations proposed section 4 respect ja implementation ima implementation produces greatest overheads matrices middle sits imma implementation bv implementation always produces smallest overhead matrix ja ima imma vbma table 2 average times seconds four dierent implementations mvmcoo matrix ima table 3 overhead implementations mvmcoo using proposed classes respect ja implementation although section omits second set experiments run also linux pentium solarissparc platforms equivalent java environment omitted results consistent presented 6 discussion thus far development assumed three classes incorporated multidimensional array package proposed jsr083 following paragraphs try determine whether one classes best whether package needs one class consider rst class mutableimmutablestateintmultiarray1d object indx class order obtain benet array bounds checks elimination using indx indirection array programs need follow steps 1 change state indx immutable 2 execute actions normally inside loops acess elements stored indx 3 change state indx back mutable example steps implementation matrixvector multiplication using class mutableimmutablestateintmultiarray1d see figure 11 third step omitted possibly accidentally indirection array indx becomes useless purpose array bounds checks elimination threads thread abandoned execution without adequate clean would stopped waiting indenitely noti cation indx returned back mutable state another undesirable situation arise several threads executing parallel least two threads need indx jndx another object class time depending order execution aliases object deadlock occur one might think two undesirable situations could overcome modifying implementation class maintains adequately list thread readers instead one thread reader however omission third step leads starvation writers given undesirable situations inherent two strategiesclasses experiments section 5 show performance benet favor class mutableimmutablestateintmultiarray1d decision disregard class discussion looks scenarios cse applications two remaining classes used words functionality classes immutableintmultiarray1dand value boundedintmultiarray1d contrasted functionality requirements cse applications remember classes although public interface provide dierent functionality name suggests class immutableintmultiarray1d implements method set without modifying instance variable simply throws unchecked exception see figure 4 hand class valueboundedintmultiarray1d provides expected functionality method long parameter value method positive less equal instance variable upperbound see figure 8 various scenarios cse applications lufactorisation dense banded matrices pivoting strategies gauss elimination sparse matrices llin applications need update content indirection arrays gvl96 example llin means new nonzero elements created zero elements existed thus gauss elimination algorithm creates new nonzero matrix elements progressively assuming matrix stored coo format indirection arrays indx jndx need updated row column indices respectively new nonzero element given cse applications indirection arrays remain unaltered initialisa tion reason including class immutableintmultiarray1d would performance however performance evaluation reveals case therefore conclusion incorporate class valueboundedintmultiarray1d multidimensional array package conclusions array indirection ubiquitous cse applications specication array accesses java current techniques eliminating array bounds checks applications array indirection suer overhead explicitly checking access indirection array building previous work ibms ninja jalapeno groups three new strategies eliminate array bounds checks presence indirection presented strategy implemented java class replace java indirection arrays type int aim three strategies provide extra information jvms array bounds checks presence indirection removed normal java arrays type int extra information would require access whole application ie dynamic loading heavy weigh algorithm remove array bounds checks combination loop versioning used ninja group mms98 mmg00a mmg construction constraints based data ow analysis abcd algorithm bgs00 experiments evaluated performance benet eliminating array bound checks presence indirection overhead estimated 903 983 percentage execution time experiments also evaluated overhead using java class replace java arrays otheself jvm overhead varies class 613 1472 percentage execution time evaluation three strategies also includes discussion advantages disadvantages overall third strategy class valueboundedintmultiarray1d best takes dierent approach seeking immutability objects number threads accessing indirection array time irrelevant long every element indirection array within bounds arrays accessed indirection class enforces every element stored object class values zero given parameter parameter must greater equal zero cannot modied passed constructor remaining problem overhead programs using class valueboundedint multiarray1d instead java arrays authors proposed set transformations lfg02a lfg02b java library oolala luj99 lfg00 paper demonstrates set transformations designed oolala enough optimise away overhead using class valueboundedintmultiarray1d preparation future work concentrates developing algorithm suitable justintime dynamic compilation determine apply set transformations r jalapeno virtual machine optimization array subscript range abcd eliminating array bounds checks demand escape analysis object oriented languages matrix market web resource test matrix collections benchmarking java c fortran scienti reexamination sreedhar samuel midki practicing judo java dynamic optimizations marmot optimizing compiler java design patterns elements reusable object oriented software fiel analysis getting useful lowcost interprocedural information fresh look optimizing array bound checking optimizing array bound checks using ow analysis matrix computations making java work highend computing numerical methods sofware approach jove optimizing native compiler java technology java language spec cation elimination redundant array subscript range checks concurrent programming java design principle patterns mikel luj mikel luj mikel luj mikel luj java virtual machine speci optimization range checking object oriented software construction harissa hybrid approach java execu tion design implementation certifying compiler scimark 20 java applications way ahead time wat compiler symbolic bounds analysis pointer implementation array bound checker overview ibm java justintime compiler java middle age enabling java computational science compositional pointer escape analysis java programs safety checking machine code elinating array bound checking dependent types tr fresh look optimizing array bound checking optimization array subscript range checks optimizing array bound checks using flow analysis reexamination myampersandldquooptimization array subscript range checksmyampersandrdquo elimination redundant array subscript range checks objectoriented software construction 2nd ed matrix market eliminating array bound checking dependent types design implementation certifying compiler escape analysis java escape analysis objectoriented languages removing unnecessary synchronization java compositional pointer escape analysis java programs marmot flop megaflops practicing judo safety checking machine code symbolic bounds analysis pointers array indices accessed memory regions abcd field analysis quicksilver oolala techniques obtaining high performance java programs benchmarking java c fortran scientific applications related field analysis ninja project implementation array bound checker numerical methods java numerical computing java middle age optimization range checking ctr sudarshan srinivasan srikanth kandula christopher r andrews yuanyuan zhou flashback lightweight extension rollback deterministic replay software debugging proceedings usenix annual technical conference 2004 usenix annual technical conference p33 june 27july 02 2004 boston
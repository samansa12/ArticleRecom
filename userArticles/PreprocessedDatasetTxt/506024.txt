fault detection byzantine quorum systems abstractin paper explore techniques detect byzantine server failures asynchronous replicated data services goal detect arbitrary failures data servers system client accesses replicated data subset quorum servers operation system correct servers outofdate write therefore return values uptodate value response clients read request thus complicating task determining number faulty servers system point time initiate study detecting server failures context propose two statistical approaches estimating risk posed faulty servers based responses read requests b introduction data replication wellknown means protecting data unavailability corruption face data server failures servers suffer byzantine ie arbitrary failures foremost approach protecting data via state machine replication sch90 every correct server receives processes every request order thereby producing output quest client accepts value returned least arbitrary server failures masked numerous systems built support approach eg pg89 sestt92 rei94 kmm98 improve efficiency availability data access still protecting integrity replicated data use quorum systems proposed quorum preprint paper appear seventh ifip international working conference dependable computing critical applications dcca7 january 1999 san jose california department computer science university texas austin texas lorenzocsutexasedu work funded part nsf career award ccr 9734185 darpaspawar grant number n66001988911 nsf cise grant cda z att labsresearch florham park new jersey daliaresearchattcom x department computer science university texas austin texas tumlincsutexasedu bell laboratories lucent technologies murray hill new jersey reiterresearchbell labscom alvisi malkhi pierce reiter systems family protocols allow reads updates replicated data performed subset quorum servers tmasking quorum system quorums servers defined two quorums intersect least 2t system maximum faulty servers read write operation performed quorum quorum used read operation intersect quorum used last preceding write operation least t1 correct servers appropriate read write protocols intersection condition ensures client able identify correct todate data mr97a difficulty using quorum systems byzantine fault tolerance detecting responsive faulty servers hard state machine replication server response disagrees response majority immediately exposes failure disagreeing server client property lost however quorum systems servers remain date given write contrary response server read operation necessarily suggest servers failure therefore must design specific mechanisms monitor existence faults quorumreplicated system eg detect whether number failures approaching paper initiate study byzantine fault detection methods quorum systems proposing two statistical techniques estimating number server failures service replicated using tmasking quorum system methods estimate total number faulty servers responses clients read requests executed quorum servers readily applicable threshold quorum construction mr97a quorum defined set size n2t1 e first method advantage requiring essentially change read write protocols proposed mr97a second method require alteration read write protocols advantages improved accuracy specific identification subset faulty servers furthermore fault identification protocol second method applicable without alteration types tmasking quorum systems indeed types byzantine quorum systems proposed mr97a methods set alarm line issue warning whenever number server failures exceeds show system use information read operation statistically test hypothesis actual number faults f system show correctly selected read operations frequent methods expected issue warnings timely fashion ie still case f service repaired least disabled integrity data set compromised initial investigation statistical monitoring replicated data paper adopts number simplifying assumptions first perform statistical analysis context read operations concurrent write oper ations observing partially completed writes read substantially complicates task inferring server failures second assume clients correct distinguishing faulty server server faulty client fault detection byzantine quorum systems written incorrect data raises issues consider third restrict attention techniques modify read write protocols minimally exploit data gathered single read without aggregating data across multiple reads show paper surprising amount information obtained without aggregation assumptions represents area possible future research goal work substantially different various recent works adapted failure detectors ct96 solve consensus distributed systems suffer byzantine failures mr97b ds97 kmm97 works focus specification abstract failure detectors enable consensus solved goal develop techniques detecting byzantine failures specifically context data replicated using quorum systems without regard abstract failure detector specifications consensus problem lin et al lrm98 analyze process gradual infection system malicious entities analysis attempts project failures exceed certain thresholds extrapolating observed failures onto future basis certain priori assumptions communication patterns processes infection rate system methods depend assumptions address propagation failures system rather attempt measure current number failures point time summarize contributions paper twofold initiate direction fault monitoring detection context byzantine quorum sys tems propose two statistical techniques performing detection tmasking quorum systems conditions described rest paper organized follows section 2 describe system model necessary background sections 34 present analyze two statistical methods using exact formulae alarm line placement relatively small systems section 5 present asymptotic analysis estimating appropriate alarm line placement larger systems methods conclude section 6 preliminaries 21 system model system model based universe u n data servers correct server one behaves according specification whereas faulty server deviates specification arbitrarily byzantine failure denote maximum allowable number server failures system actual number faulty servers system particular moment f goal paper detect faulty servers stipulate faulty server fact deviate io specification ie returns something specification would dictate returns nothing though unresponsive servers ignored paper target detection methods hardly fruitful attempt detect faulty servers whose visible behavior consistent correct execution alvisi malkhi pierce reiter system model also includes number clients assume correct clients communicate servers pointtopoint channels channels reliable sense message sent client correct server eventually received destination addition client authenticate channel correct server ie client receives message correct server server actually sent 22 masking quorum systems assume server holds copy replicated variable z clients execute write read operations change observe value respectively protocols writing reading z employ tmasking quorum system mr97a mrw97 ie set subsets servers q 2 u intuitively read write performed quorum servers use tmasking quorum system ensures read quorum q 2 intersects last write quorum q 1 least suffices enable reader determine last written value specifically base methods threshold masking quorum systems mr97a defined ie quorums sets servers size n2t1 2 e systems easily seen tmasking property consider following protocols accessing replicated variable z shown mr97a give z semantics safe variable lam86 server u maintains timestamp u copy z u variable z client writes timestamp writes variable protocols require different clients choose different timestamps thus client c chooses timestamps set c intersect c 0 client c 0 client operations proceed follows write client c write value v z queries server quorum q obtain set valuetimestamp pairs timestamp 2 c greater highest timestamp value greater timestamp chosen past updates z u u server u quorum q 0 v respectively read client read variable z queries server quorum q obtain set valuetimestamp pairs among pairs returned least servers q client chooses pair v highest timestamp returns v result read operation pair returned least servers result read operation null value write operation server u updates z u u received values v greater present value u convention guarantees seri fault detection byzantine quorum systems alizability concurrent writes mentioned section 1 consider reads concurrent writes case read operation never return provided assumed maximum number failures exceeded 23 statistical building blocks primary goal paper draw conclusions number f faulty servers system specifically whether f exceeds selected alarm threshold using responses obtained read protocol previous subsection make extensive use statistical technique called hypothesis testing use technique establish two hypotheses universe servers first experimental hypothesis represents condition tested eg f exceeds alarm threshold second null hypothesis h 0 complementing idea behind hypothesis testing examine experimental results case read operations conditions suggest truth experimental hypothesis ie conditions would highly unlikely null hypothesis true define highly unlikely choosing rejection level identifying corresponding region rejection h 0 region rejection maximal set possible results suggest truth thus falsity h 0 whose total probability given h 0 ff purposes work note although hypotheses strictly complementary region rejection h 0 encompasses every therefore rejection level truly complementary hypothesis f bounded h 0 treatment null hypothesis standard statistical procedure paper typically choose strictly less maximum assumed number failures system reason little use detect dangerous condition integrity data compromised safest value 0 higher value may desirable small numbers faults common countermeasures expensive order statistical calculations valid must able treat individual quorums intersection two quorums random samples universe servers given focus quorum system consisting sets size n2t1 2 e accomplished choosing quorums way quorum containing unresponsive servers approximately equally likely queried given operation statistical method possibility false positives ie alarms sent fault level remains false negatives failure detect dangerous fault level threshold exceeded show however former risk kept reasonable minimum latter made essentially negligible 1 1 except catastrophically unreliable systems neither method alvisi malkhi pierce reiter 3 diagnosis using justifying sets first method fault detection threshold quorum systems uses read write protocols described section 22 random variable statistical analysis use size justifying set read operation set servers return valuetimestamp pair v chosen client read operation size justifying set least 2t faulty servers small justifying set may large n2t1 e case read quorum quorum used last completed write operation suppose read operation performed system size justifying set read operation x would like discover whether evidence supports hypothesis number faults f system exceeds value using formula probability distribution justifying set sizes formula derived follows suppose system n servers quorum size q given f faulty servers system probability exactly j failures read quorum expressed hypergeometric distribution follows qgammaj given number failures read quorum j probability exactly x correct servers intersection read quorum previous write quorum formulated follows number ways choosing x correct servers read quorum x number possible previous write quorums intersect read quorum exactly correct servers number incorrect ones probability previous write quorum intersects read quorum exactly way therefore x get overall probability exactly x correct servers intersection read recent write quorums ie justifying set size size x multiply conditional probability given j failures read quorum probability exactly j failures read quorum sum result f x qgammaj 1 aware protect sudden nearsimultaneous byzantine failures sufficiently large number eg greater servers fault detection byzantine quorum systems formula expresses probability particular read operation tmasking quorum system justifying set size x given presence f faults given rejection level ff region rejection null hypothesis defined x highreject highreject maximum value highreject x x ji ji ngammat qgammaj lefthand expression represents significance level test ie probability false positive false alarm fact failures system probability detecting condition single read highreject x x qgammaj denote value fl probability k consecutive reads fail detect condition shown following examples k need large probability become negligible example 1 consider system fault tolerance threshold order test whether faults system set 0 null hypothesis h 0 experimental hypothesis f 0 plugging numbers 1 full range x yields results table 1 values x shown table 1 probability justifying set size x given 0071 region rejection defined x 53 read operation justifying set size 53 less client rejects null hypothesis concludes faults system test significance level probability 0019 client detect faults none level risk unacceptable particular system ff set lower value thus creating smaller region rejection suppose actually f failures system probability experiment detect presence failures given read isx x26 f x f 101gammaf table shows values 1 f 20 although probability detecting faults given read system relatively low small values f would appear test reasonably alvisi malkhi pierce reiter x 54 051857 67 903 theta 10 gamma07 table 1 probability distribution justifying set sizes example 1 9 739333 19 997720 table 2 probability detecting f 0 example 1 fault detection byzantine quorum systems 9 130284 table 3 probability detecting f 5 example 2 powerful even fault levels low 4 5 client reasonably expect detect presence failures within reads eg probability detecting f 6 reads already 921 fault levels rise probability detection within single read approaches nearcertainty example 2 consider much smaller system consisting quorum size q 46 fault tolerance threshold furthermore suppose administrator system decided action called failures occur set 5 rather 0 given 005 region rejection null hypothesis h x 27 probabilities detecting condition actual values f 8 12 inclusive shown table 3 one might expect error conditions difficult detect narrowly defined contrast examples 1 2 shows even latter experiment however client reasonably expect detect serious nonfatal error condition within small number reads probability alarm triggered within six read operations approximately 965 percent probability triggered within ten reads 996 percent therefore reasonably consider technique useful diagnostic systems read operations significantly frequent server failures particularly systems relatively large ability detect faulty servers threshold quorum systems step forward method leaves something desired gives little indication specific number faults occurred provides little information toward identifying servers faulty next section present another diagnostic method addresses needs 4 diagnosis using quorum markers diagnostic method presented section two distinct functions first uses technique similar previous section estimate fault distribution whole system greater precision second pinpoints alvisi malkhi pierce reiter specific servers exhibit detectably faulty behavior given read diagnostic operates enhanced version readwrite protocol masking quorum systems write marker protocol described 41 write marker protocol write marker protocol uses simple enhancement readwrite protocol section 22 introduce write quorum marker field variables replicated variable z server u maintains addition z u u third value w u name quorum eg nbit vector indicating servers quorum used complete write operation z u u last written write protocol proceeds section 22 except last step addition updating z u u v server u quorum client also updates w u name q 0 specifically update z u u w u correct servers q 0 client sends message containing u 2 q 0 communication reliable see section 2 writer knows z u u w u updated correct servers q 0 server u updates z u u w u received values v greater present value u read protocol proceeds essentially except server returns triple z response read request among triples returned least servers client chooses triple highest timestamp describe two ways detecting faults making use set triples returned servers 42 statistical fault detection revised statistical technique uses quorum markers determine set servers whose returned values would match accepted triple absence faults set 0 servers whose returned values actually match triple sizebased construction threshold quorum systems random selection servers make quorum given operation set considered random sample servers js ns 0 j known faulty taking random variable number faulty servers sample use similar calculations section 3 analyze greater precision probability f exceeds shown section 3 probability finding faults sample size given universe size n containing f faults expressed hypergeometric sgammay fault detection byzantine quorum systems 9 999660 19 999999 table 4 probability detecting f 0 example 3 rejection level ff region rejection hypothesis therefore defined lowest value lowreject ylowreject ngammat sgammay lefthand expression represents parameterized probability false alarm method experiments 0 degenerate case presence faults intersection set visible invalidates null hypoth esis probability false positive cases zero formula confirms likewise number faults increases probability detecting faults within one two reads rapidly approaches certainty example 3 consider system servers fault tolerance threshold quorum size q 76 0 suppose given read quorum overlaps previous write quorum servers likely overlap probability 021 probability alarm single read operation various values f shown table 4 comparison table table 2 illustrates dramatically higher precision writemarker method justifying set method precision additional advantages set value greater 0 example 4 consider system servers fault tolerance threshold quorum size q 46 5 suppose given read quorum overlaps previous write quorum common intersection size servers region rejection null hypothesis calculated using formula 5 probability alarm single read operation various values f shown table 5 alvisi malkhi pierce reiter 9 table 5 probability detecting f 5 example 4 increased strength writemarker method evident see table 3 like method presented section 3 writemarker technique also advantage flexibility wish minimize risk premature alarms ie alarms sent without alarm threshold exceeded may choose smaller ff risk somewhat delayed alarms fact greater precision method decreases risks associated course even delayed alarms expected timely 43 fault identification write marker protocol even stronger potential tool fault de tection allows client identify specific servers behaving incorrectly keeping record list client thereafter select quorums contain servers allows system behave somewhat efficiently would otherwise well gathering information needed isolate faulty servers repair systems integrity maintained fault identification algorithm accepts input triples fz client obtained servers read protocol well triple client chose result read operation computes set n 0 set servers returned read operation servers n 0 identified faulty note fault identification protocol depend way specific characteristics threshold quorum systems easily seen applicable masking quorum systems general 5 choosing alarm lines large systems analysis previous two sections precise computationally cumbersome large systems useful alternative estimate performance possible alarm lines means bound analysis section present asymptotic analysis techniques sections 3 4 shows choose alarm line value arbitrarily large systems fault detection byzantine quorum systems let us denote read quorum q write quorum q 0 set faulty servers b hypothesized size b ie alarm line define random variable justifying set size compute expectation x directly server u 62 b define indicator random variable u otherwise u p since q q 0 chosen independently linearity expectation intuitively distribution x centered around expectation decreases exponentially x moves farther away expectation thus able show x grows smaller expectation exponentially decreasing probability tempting approach analyzing would use chernoff bounds directly apply selection individual servers q similarly q 0 independent analysis thus use powerful tool martingales derive anticipated chernofflike bound bound probability using method bounded differences defining suitable doob martingale sequence applying azumas inequality see mr95 ch 44 good exposition technique appendix provides brief introduction doob martingale sequence conditional random variables defined setting q expected value x selections made q q 0 difficult see jx yields following bound see appendix use formula desired rejection level ff determine ffi probability value probability false alarm diminished decreasing ff recalculating ffi value defines region rejection see section 23 order analyze probability alarm triggered number faults system 0 define second random variable x 0 identical x except revised failure hypothesis gives us analysis similar provides following bound summarize bounds used follows given alarm line desired confidence level ff compute minimum ffi satisfy alvisi malkhi pierce reiter thus derive following test alarm triggered whenever justifying set size less n gamma ffi analysis guarantees alarm triggered false positive probability computed bound ff fact f faults occur f sufficiently larger exists analysis probability triggering alarm greater 8q case write marker protocol tighten analysis using known intersection size q q 0 follows bj hypergeometric distribution n appropriate doob martingale sequence case defines expected value selections made jy set region rejection use 6 conclusion paper presented two methods probabilistic fault diagnosis services replicated using tmasking quorum systems methods mine server responses read operations evidence server failures necessary trigger alarm initiate appropriate recovery actions methods demonstrated context threshold construction mr97a ie quorums sets size n2t1e techniques section 4 generalized masking quorum systems well first method advantage requiring modifications read write protocols proposed mr97a second method requires minor modifications protocols also offers better diagnosis capabilities precise identification faulty servers methods effective detecting faulty servers since faulty servers risk detection every read operation return incorrect answers future work focus generalizations techniques well uses techniques larger systems context particular presently exploring approaches react server failures detected r unreliable failure detectors reliable distributed sys tems muteness detectors consensus byzantine pro cesses solving consensus byzantine environment using unreliable failure detector securering protocols securing group communication interprocess communication part ii algorithms resilience multicasting strategies failurepropagating environment randomized algorithms byzantine quorum systems unreliable intrusion detection distributed computation load availability byzantine quorum systems secure agreement protocols reliable atomic group multicast rampart reliable scheduling tmr database system implementing faulttolerant services using state machine ap proach tutorial principal features voltan family reliable node architectures distributed systems tr randomized algorithms inlineequation f radrcdnrcdradf inlineequation algorithm mutual exclusion decentralized systems unreliable failure detectors reliable distributed systems synchronous byzantine quorum systems probabilistic byzantine quorum systems load availability byzantine quorum systems intrusion detection architecture survivable coordination large distributed systems fault detection byzantine quorum systems unreliable intrusion detection distributed computations comparison connection assignment diagnosis multiprocessor systems ctr andreas haeberlen petr kouznetsov peter druschel case byzantine fault detection proceedings 2nd conference hot topics system dependability p55 november 08 2006 seattle wa meng yu peng liu wanyu zang specifying using intrusion masking models process distributed operations journal computer security v13 n4 p623658 july 2005
constraintbased mode analysis mercury recent logic programming languages mercury hal require type mode determinism declarations predicates information allows generation efficient target code detection many errors compiletime unfortunately mode checking languages difficult one main reasons predicate mode declaration compiler required decide parts procedure bind variables conjuncts predicate definition reordered enforce behaviour current mode checking systems limit possible modes may used keep track aliasing information limited ability infer modes since inference perform reordering paper develop mode inference system mercury based mapping predicate system boolean constraints describe variables produced allows us handle programs supported existing system b introduction logic programming languages traditionally untyped unmoded recent years languages mer permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee ppdp02 october 68 2002 pittsburgh pennsylvania usa cury 19 shown strong type mode systems provide many advantages type mode determinism declarations mercury program provide useful documentation developers also enable compilers generate ecient code improve program robustness facilitate integration foreign languages information gained declarations also useful many program analyses optimisations mercury mode system described language reference manual expressive allowing programmer describe complex patterns dataflow ever implementation mode analysis system current release melbourne mercury compiler limitations remove much expressiveness see 8 particular current mode analyser allows construction partially instantiated data struc tures cases allow filled another limitation mode inference prevents reordering order limit number possibilities examined eect limitations hard write mercury programs use anything basic modes possible write programs certain types data flow well limited ways described current mode analysis algorithm also complicated combines several conceptually distinct stages mode analysis single pass makes modifications algorithm eg include missing functionality quite dif ficult algorithm also quite inecient analysing code involving complex modes paper present new approach mode analysis mercury programs attempts solve problems current system separate mode checking several distinct stages use constraint based approach naturally express constraints arise mode analysis believe approach makes easier implement extensible mode analysis system mercury overcome limitations current system associate program variable set posi tions correspond nodes type graph key idea new mode system identify position type variable position produced ie goal binds part variable function symbol associate node type graph goal program variable occurs boolean variable indicates whether node graph program variable bound within goal given boolean variables describe constraints arise correct moding terms boolean constraints represent manipulate descriptions using standard data structures reduced ordered binary decisions diagrams robdds allowing constraints individual positions dierent data structures obtain much precise analysis current mercury mode system starting 11 considerable research mode inference checking however work based assumptions dier least one two significant respects types reordering almost work mode analysis logic programming focused untyped languages mainly prolog consequence papers use simple analysis domains ground free unknown one use patterns code derive detailed programspecific domains eg 3 10 12 analyses must sacrifice much precision achieve acceptable analysis times 18 proposed fixing problem requiring type information using types variables domains mode analysis several papers since eg 14 17 based similar ideas like papers mode infer ence also assume program analyzed without reordering therefore use modes describe program executions whereas interested using modes prescribe program execution order insist compiler must exact information instantiation states mode analysis systems likewise work much simpler domains example ground prolog 9 recognizes two instantiation states related work mode checking concurrent logic programming languages logic programming languages coroutining 1 5 7 emphasis detecting communication patterns possible deadlocks constraintbased mode analysis aware moded flat ghc 4 moded flat ghc relies position clause head guard versus body determine unification allowed bind variables significantly simplifies problem constraints generated equa tional rely delaying complex cases three occurrences variable goal work constraintbased analysis mercury particular work 20 constraintbased bindingtime analysis notable similar basic approach using constraints po sitions type trees variables express data flow dependencies however bindingtime analysis dierent objectives mode analysis fact analysis requires results mode analysis available section 2 give background information rest paper depends section 3 briefly outline current approach weaknesses section 4 give simplified example constraintbased system presenting full system section 5 section 6 show results analysis used select execution order goals conjunction section 7 give preliminary experimental results 2 background mercury purely declarative logic programming language designed construction large reliable ecient software systems teams programmers 19 mercurys syntax similar syntax prolog mercury also strong module type mode determinism systems catch large fraction programmer errors enable compiler generate fast code rest section explains main features mercury relevant paper 21 programs definition predicate mercury goal containing atoms conjunctions disjunctions negations thenelses simplify algorithms compiler converts definition predicate call superho mogeneous form 19 form predicate defined one clause variables appearing given atom cluding clause head distinct atoms one following three forms paper assume unifications neither side variable appear outside unification unifications meet requirement cannot influence execution program thus deleted simplicity also assume negations replaced ifthenelses one replace g g fail true abstract syntax language deal therefore written atom goal rule order describe variable becomes bound algorithms need able uniquely identify subgoal predicate body code subgoal cannot serve identifier since piece code may appear predicate definition therefore use goal paths purpose goal path consists sequence path components use represent path zero components denotes entire procedure body goal path p conjunction goal path pcn denotes nth conjunct goal path p disjunction goal path pdn denotes nth disjunct goal path p ifthenelse goal path pc denotes condition pt denotes part pe denotes elsepart definition 1 parent goal path pcn pdn pc pt pe goal path p function parentp maps goal path parent definition 2 let g set variables occur within goal g let g g set variables nonlocal goal g ie occur inside outside g convenience also define set goals since goal path uniquely identifies goal sometimes apply operations goals goal paths 22 deterministic regular tree grammars order able express dierent useful modes program variable must able talk individual parts terms program variable able take values finite manner use regular trees expressed tree grammars signature set pairs fn f function symbol n 0 integer arity f function symbol 0 arity called constant given signature set trees herbrand universe denoted defined least set satisfying ft1 tn t1 tn simplicity assume contains least one constant let v set symbols called variables set terms v denoted v similarly defined least set satisfying ft1 tn t1 tn v tree grammar r signature nonterminal set nt finite sequence production rules form x x nt form fx1 xn fn x1 xn nt tree grammar deterministic regular x nt fn one rule form x fx1 xn brevity shall often write tree grammars compressed form use x sequence production rules x t1 x t2 23 types types mercury polymorphic hindleymilner types type expressions types terms language type vtype type type constructors variables vtype type parameters type constructor fn type must definition definition 3 type definition fn form v1 vn distinct type parameters f1m1 fkmk tree distinct tree con structorarity pairs 1 type expressions involving parameters v1 vn clearly view type definition f simply sequence production rules signature tree nonterminal set type vtype order avoid type expressions depend infinite number types restrict type definitions regular 13 essentially regularity ensures type grammart defined finite example 1 type definitions lists simple type abc includes constants b c associate nonparameter type expression production rules define topmost symbol type let type expression form ft1 tn let fn type definition form definition 3 define rulest production rules fv1 vn fv1 vn vtype define rulest empty sequence extend notation associate tree grammar type expression let grammart sequence production rules recursively defined operation concatenates sequences production rules removing second later occurrences duplicate production rules call nonterminal set production rules po sition since use describe positions terms position root one terms subterms also sometimes call positions nodes since correspond nodes type trees example 2 consider type listabc corresponding grammar listabc abc two nonterminals thus two positions grammar listabc abc mode inference checking takes place type check ing assume know type every variable appearing program 24 instantiations modes instantiation describes binding pattern variable particular point execution program mode mapping one instantiation another describes instantiation variable changes execution goal instantiations also defined using tree grammars dierences instantiation associated predicate involves instantiation parameters polymorphic modesalthough possible extension two base instantiations free ground representing completely uninitialized variables completely bound terms instantiation expressions terms inst vinst definition 4 instantiation definition g inst form inst gw 1 wn boundg 1 1 w1 wn distinct instantiation parameters g1m1 gkmk tree distinct tree constructors instantiation expressions inst free ground vinst associate set production rules rulesi instantiation expression type expres sions base instantiations define example 3 example instantiation definition inst list skeli bound list skeli defines instantiation list skeli variable instantiation must bound either empty list cons cell whose first argument instantiation given instantiation variable whose tail also instantiation list skeli example list skelfree describes list elements free instantiation usually intended used specific type eg list skeli listt normally lists function symbols variables type bound instantiations inst non empty skeli boundi list skeli represent kind subtyping variable whose instantiation non empty skelfree cannot bound definition 5 mode f mapping initial instantiation final instantiation f common modes shorthand expressions eg ground ground goal changes instantiation state position free ground said produce bind position goal requires initial instantiation state position ground said consume position 3 current mode analysis system mode analysis algorithm currently used mercury compiler based abstract interpretation abstract domain maps program variable instantia tion mode analysis compiler creates separate procedure mode usage predicate analyses procedure separately starting initial instantiation states argument given mode declaration analysis traverses procedure body goal determining instantiation state variable point goal traversing conjunctions conjunct able scheduled needs input variable suciently bound delayed tried later goal analysed unschedulable subgoals computed final instantiation states arguments match final instantiation states mode declara tion procedure determined mode correct see 8 details although papers talk languages approach mercury similar system also able mode inference predicates exported defining module using top traversal module however prevent combinatorial explosion mode analysis algorithm reorder conjunctions performing arrives call assumes called predicate supposed able run given variables bound left mode analysis system several tasks must 1 determine producer consumers variable 2 reorder conjunctions ensure consumers variable executed producer 3 ensure subtyping constraints met leads complicated implementation one aims constraintbased approach simplify analysis splitting tasks distinct phases done separately 31 limitations two main problems approach first keep track aliasing informa tion two consequences first without mayalias information bound nodes cannot handle unique data structures nontrivial manner particular cannot implement compiletime garbage collection second without mustalias information free nodes cannot accurate mode analysis code manipulates partially instantiated data structures partially instantiated data structures data structures contain free variables useful one wants dierent parts data structure filled dierent parts program example 4 consider following small program pred lengthlistint int mode lengthfree listskelfree det lengthl n pred iotalistint int mode iotalistskelfree ground det goal lengthl 10 iotal 3 length2 constructs skeleton list specified length iota2 fills elements list current system unable verify mode correctness second disjunct iota2 one problem disjunct sets alias variable h first element l initially free variables instantiates h unifying second argument without information aliasing h first element l mode checker unable determine also instantiates first element l second problem absence reordering mode inference prevents many correct modes detected example 5 consider mode inference predicate pred append3listt listt listt listt inference find mode app3inininout find mode app3outoutoutin reordering restriction cannot simply lifted without current mode inference algorithm explore arbitrarily large numbers modes fact useless since look ahead see modes inferred called predicate useful constructing desired mode current predicate 4 simplified example motivation constraint based mode analysis system avoid problems current system order break mode analysis problem phases first phase determines subgoals produce variables second uses information determine execution order procedure focus first task return second section 6 ease explanation first show simplified form approach simplified form requires variables instantiated ie two instantiation states recognizes free ground requires variables eventually reach ground state avoids complexities arise dierent parts variables bound dierent times parts left unbound address complexities give full algorithm section 5 41 constraint generation algorithm associates several constraint variables program variable every program variable v associate family constraint variables form vp vp true v produced goal path p predicate body explain algorithm using append3 code shown transformation compiler superho mogeneous form described section 21 also ensure variable appears one argument one functor adding extra unifications necessary pred appendlisttlisttlistt appendat b ct examine body generate constraints body disjunction constraints get simply specify variable nonlocal disjunction disjunction produces variable disjuncts must produce variable disjunction produce variable disjunct may produce variable append expressed constraints 1 2 process disjuncts one another disjuncts conjunctions processing conjunction algorithm considers variable occurring conjunction one potential producer variable nonlocal conjunction may produced either inside outside conjunction variable shared two conjuncts may produced one conjuncts algorithm generates constraints make sure variable exactly one producer variable local constraints say exactly one conjunct must produce variable variable non local constraints say one conjunct may produce variable first disjunct variables shared among conjuncts constraints get ones say nonlocal produced conjunction produced conjunct appears first conjunct first disjunct yields nontrivial constraints intuitively lack constraints goal reflects fact used produce test value second conjunct first disjunct yields one con straint says goal used produce one b c second disjunct generate constraints analogous first conjunct nonlocal variables disjunct unlike first contains shared local variables ah ch ct appears two conjuncts constraints variables state variables must produced exactly one conjuncts appears first conjunct second disjunct shows handle unifications form key understanding behavior algorithm case knowing trying decide two alternatives either unification takes input produces x takes x input produces contrary peoples experience real programs unifications form also used ways make bindings produce subset however using unification way requires x input possible producers outside unification transform program su perhomogeneous form make sure unification form fresh variables right hand side could producer would replaced right hand side unification new variable addition new unification convert unifications take x input unifications take x input produce variables right hand side variables right hand side appear variables must unbound using unification produce x would create nonground term since simplified approach consider nonground terms cases generates extra constraint requires x input goal case ah ah appear elsewhere get constraints first says either goal produces variables right hand side produces none conjunction first second constraint says goal cannot produce variable left hand side variables right hand side constraints get analogous equation acts equation first disjunct generating last conjunct call case recursive call assume calls predicate scc caller mode 1 means call produces ith argument predicate body produces ith argument leads one constraint argument position concludes set constraints generated algorithm append 42 inference checking constraints generate predicate used infer modes projecting onto head variables constraint set built five dierent solutions append five modes b c appendin b c appendin b c appendout b c appendout b c appendin five modes two appendin appendout call principal modes three implied modes existence implied existence principal modes changing mode argument makes job predicate strictly easier rest pa per assume every predicates set modes downward closed means contains mode pm also contains modes implied pm prac tice compiler generates code mode declared principal mode synthesizes modes caller renaming variables inserting extra unifications synthesis superhomogeneous form equivalent replacing append1 2 3 append1 2 x solution also implicitly assign modes primitive goals body specifying variable produced example solution assigns true constraint variables c c 1 c 1 false others corresponds mode appendininout also shows deconstruction ie uses fields define ah construction ie binds c new heap cell cases values constraint variables head variables uniquely determine values constraint variables sometimes one set value assignments constraint variables body consistent given value assignment constraint variables head cases compiler choose assignment prefers 5 full mode inference 51 expanded grammars consider problem handling programs dierent parts variable may instantiated assumption somewhat restricts set allowable wellmoded programs however found unreasonable restriction practice come across cases typical mercury programs one would want make recursive call dierent mode dierent goals need ensure two distinct positions variable may dierent instantiation haviour way referring separately hence need expand type grammar associated variable begin empty grammar original code predicate expressed superhomogeneous normal form modify grammar predicate body first stage mode analysis unification appears definition predicate x grammar rule functor fn add rule already occurs grammar rule head clause replace occurrence program add equation x grammar rule x fb1 bn replace equation process may add equations form one x occurs nowhere else equations safely removed processing unifications add copy rules rulest grammar variable v type example 6 superhomogeneous form usual source code append variant aah cah ct appendatbct second clause algorithm replaces aah cch ct yielding form shown section 4 expanded computed append nonterminals grammar constitute set positions create constraint variables generate constraints predicate body use nonterminal position well node interchangeably note nonterminal denoting toplevel functor every variable variables eg nonterminals denoting nontoplevel functors well note also nonterminal fulfill functions one variable strictly part another example nonterminal ah stands variable ah first element list bound variable variables b c unified computation paths nonterminal predicate needs three boolean variables position true position produced outside predicate b v true position produced inside predicate c v true position produced somewhere either inside outside predicate note v v v definition 6 let pn tuple h1 hn head variables ie formal parameters predicate pn definition 7 expanded grammar position x define immediate descendants x set positions reachable x generating constraints two variables always type need able refer positions within two variables correspond eg ah ch denote corresponding positions inside c notion correspondence use allows two variables expanded dierent extents expanded grammar example descendant nonterminals appends b even though type unification b nonterminal b would correspond well definition 8 expanded grammar positions x define set pairs corresponding nodes x x w1x wn convenience also define pair ntuples x1 definition 9 given expanded grammar rule say x parent node nodes y1 yn 52 mode inference constraints ensure variable occurs one pred icate renaming necessary construct expanded grammar p program module com piled next group predicates module stronglyconnected components sccs process sccs bottom creating function cscc scc represents boolean constraints generate predicates scc remainder section defines cscc constraint function cscc scc conjunction constraint functions c pred pn generate predicates pn scc ie cscc constraint function infer predicate pn constraint function scc ie c inf pn c inf pn may stricter c pred pn pn alone scc predicates defined modules derive c inf mode declarations using mechanism describe section 53 c pred conjunction two functions c struct structural constraints relating variables goal constraints predicate body goal c pred ph1 hn define c struct c goal 521 structural constraints v proposition v bound call v proposition v bound return v proposition v bound predicate constraints relate relationships variables relationships boundedness dierent times node reachable one predicates argument variables cannot bound call node bound return bound call produced within predicate body node may bound call produced predicate body node bound call parent node must also bound call similarly node bound return parent node must also bound return c struct v v v example 7 append structural constraints ah ah ah ah ah ae ae ae ae ae ch ch ch ch ch ct ct ct ct ct ce ce ce ce ce ah ah ae ae b b ch c ch c ct c ct c ce ct ce ct 522 goal constraints boolean variable vp path p contains program variable x v x variable represents proposition position v produced goal referred path p constraints generate goal fall two categories general constraints apply goal types gen constraints specific goal type c goal complete set constraints goal ccomp conjunction two sets general constraints two components first node reachable variable local goal bound return produced goal second c ext says node reachable variable v external goal g ie occur g cannot produced g conjunction definition c ext could variables predicate occur g however variable v occur gs parent goal parents c goal constraints wont mention v point creating constraint variables v g 523 compound goals constraints generate kind compound goal conjunction disjunction ifthenelse shown figure 1 case goaltypespecific constraints conjoined complete set constraints subgoals conjunctive goal position produced one conjunct disjunctive goal node either must produced disjunct produced disjunct ifthenelse goal node produced ifthen else produced either condition branch else branch node may produced condition branch nodes reachable variables nonlocal ifthenelse must produced condition node reachable nonlocal variable produced branch must also produced else branch vice versa 524 atomic goals due space considerations leave discussion higherorder terms may handled simple extension modechecking algorithm consider three kinds atomic goals 1 unifications form 2 unifications form 3 calls form qy1 yn unification form may produce one pair corresponding nodes mercury allow aliases exist unbound nodes node reachable variable involved unification must produced somewhere 2 unification goal path p constraints c goal example 8 unification append goal path d1 c2 constraints generated 2 goal scheduling phase require node must produced aliased another node two restrictions together disallow uses partially instantiated data structures future mercury implementation handle consequences would like lift restrictions unification form yn path p produce arguments y1 yn x must produced somewhere either p somewhere else constraints c goal example 9 unification append goal path d2 c1 constraints generated call qy1 yn constrain nodes reachable arguments call predicates current scc allow recursive calls mode caller constraints c goal p qy1 yn vw qny 1 n vwp v w first part ensures call produces position position produced predicate scc second part ensures call variable w produced somewhere required bound call call v true v true cant mistakenly use call site produce w example 10 recursive call appendatbct goal path d2 c4 append constraints generated first argument calls predicates lower sccs constraints similar must existentially quantify head variables possible call predicate dierent modes dierent places within current scc c goal p qy1 vw qny 1 n v wp v w 53 mode declaration constraints predicate modes declared mode analysis system check declarations inferred mode information involves generating set constraints mode declarations ensuring consistent constraints generated predicate body declaration constraint c decls predicate set mode declarations disjunction constraints c decl mode declaration dd c decl constraint c decl mode declaration pm1 mn predicate ph1 hn conjunction constraints c arg mh argument mode corresponding head variable h c struct h1 hn structural constraints used determine h variables h h constraint c arg mh argument mode head variable h conjunction constraint c goal p g1 gn figure 1 constraints conjunctions disjunctions ifthenelses c init h initial instantiation state constraint c fin f h final instantiation state f constraint c init h initial instantiation state head variable h given w h w constraint c fin h final instantiation state head variable h given c fin c fin ground w h w c fin mode checking simply determining declared modes least strong inferred modes declared mode predicate pn check whether implication holds doesnt declared mode incorrect given declared modes predicate pn used shortcircuit calculation sccs since use c decls mode inference predicates qm call pn example 11 given mode definition mode lsg listskelfree ground mode declaration gives c decl d1 ignoring v variables ah ae b c ch ct ce ah ae b c ch ct ce show c decl d1 c inf append3 6 selecting procedures execution order generated constraints scc solve constraints constraints solu tion position consumers producer report mode error constraints solu tions solution gives mode predicate scc set solutions thus defines set modes predicate need find feasible execution order mode predicate scc algorithm finding feasible execution orders takes solution input given mode predicate corresponds several solutions sucient one feasible ordering main problem finding feasible schedule mode analyser code generator distinct views means produce position variable grammar generate append example nonterminal ah represents value variable ah value first element variable forward mode append ah true mode analyser considers ah produced caller even execution enters append however far code generator concerned producer ah unification ahat cater divergent views separate notion variable produced notion variable visible definition 10 given expanded grammar assignment boolean values constraint variables predicate pn makes constraint c inf pn true model c inf pn write c inf pn definition 11 given model c inf pn define set nodes produced goal path p produced definition 12 given model c inf pn define set nodes consumed goal g goal path p formula shown figure 2 unification form say node one side equation consumed corresponding node side produced due symmetric nature relationship v 1 v 2 correspond w v 1 consumed v 2 consumed v 1 produced produced also possible pair corresponding nodes neither produced consumed unification mean one two things subterms x node already bound unification test equality subterms still free create alias note unification produces either top level nodes x call assignment unification unification form node x consumed produced nodes ever consumed reason latter half rule grammar use nonterminal eg y1 first subterm x since unification merely creates aliases corresponding subterms x nonterminals produced p v w x produced p produced p y1 ynqn c inf qn v w mvd produced p produced p produced p figure 2 calculating nodes consumed positions cannot produced unification produced produced elsewhere note unification produces x call construction unification consumes x call deconstruction unification call predicate q know nodes actual parameters call model predicate analyzing says produced call need find model constraints q causes corresponding nodes actual parameters q output since first stage analysis succeeded know model exists consumed nodes call nodes actual parameters correspond nodes formal parameters q requires input compound goals consumed nodes union consumed nodes subgoals minus nodes produced within compound goal example 12 mode append produced consumed sets conjuncts path produced consumed d2 c4 ct ce aebbe neither disjunct produces position also con sumes therefore ordering algorithm required node produced consumed would find order acceptable hand code generator fussy example emit code recursive call needs know variables ah stored even bound yet need concept visibility definition 13 variable visible goal path p variable head variable appeared predicate body somewhere left p functions make visible need visible defined figure 3 respectively determine whether goal makes variable visible requires visible example 13 given mode append make visible need visible sets conjuncts path make visible need visible algorithm needs find conjunction body ordering conjuncts producer node comes consumers variable made visible point needs visible traversing predicate body top conjunction construct directed graph whose nodes conjuncts initial graph edge c c j c produces node c j consumes graph cyclic mode ordering fails isnt try add edges keeping graph acyclic sort variables need visible anywhere conjunction also made visible conjunction two classes clear conjunct make visible isnt variable falls first class made visible one conjunct conjunct makes visible also producer top level node forward mode append variables fall first class variable made visible one conjunct ch need visible conjunct conjunction variables add edge conjunct makes variable visible conjuncts c j need visible graph still acyclic start searching space mappings map variable second class conjunct makes variable visi ble looking map results acyclic graph add links selected make visible conjunct variable corresponding need visible conjuncts also happen conjuncts need variable visible none goals conjunction make visible variable made visible goal left whole conjunction another conjunction encloses one everything fine isnt ordering enclosing conjunction would already failed conjunct makes variable visible conjunction whole needs visible mapping yields acyclic graph procedure mode error mappings algorithm general two choices make pick acyclic graph pick order conjuncts consistent graph make visiblem p g make visible pc gc make visible pt g make visible pe ge need visiblem need visiblem need visiblem pccte need visible ppc gpc make visible p g figure 3 calculating make visible need visible nodes forward mode append consumes input predicate ordering constraints producers consumers first disjunct visibility constraints either given der second disjunct visibility requirements dictate must occur appendat b ct make ah visible quired leaves compiler appendat b ct graph completely fix order con juncts parallel implementation may choose execute several conjuncts parallel although case would worth likely implementation may choose schedule recursive call last ensure tail cursion old mode analyser needed program transformation separate mode analysis 15 introduce tail recursion predicates like 7 experimental evaluation analysis implemented within melbourne mercury compiler represent boolean constraints reduced ordered binary decision diagrams robdds 2 using highlyoptimised implementation schachte 16 shown robdds provide ecient representation logic program analyses based boolean domains robdds directed acyclic graphs common subexpressions merged provide ecient canonical representation boolean functions worst case size robdd exponential number variables practice however bit care worstcase behaviour usually avoided use number techniques keep robdds small ecient possible present preliminary results show feasibility analysis timings taken tests run gateway select 950 pc 950mhz amd athlon cpu 256kb l2 cache 256mb memory running linux kernel 2416 table compares times mode checking simple benchmarks column labelled simple time simple constraintbased system ground variables presented section 4 column labelled full full table 1 mode checking ground simple full old simpleold fullold cqueens 407 405 17 23 23 crypt 1032 1335 38 27 35 deriv 13166 32541 59 223 551 poly 1348 5245 63 21 83 primes qsort 847 1084 112 7 9 queens 386 381 9 42 42 query 270 282 11 24 25 tak 204 201 2 102 100 constraintbased system presented section 5 column labelled old time mode checking current mercury mode checker final two columns show ratios new old systems times milliseconds averaged 10 runs constraintbased analyses significantly slower current system partly obtaining much information program thus lot work example current system selects fixed sequential order conjunctions mode analysis order disallows partially instantiated data structures whereas constraintbased approaches allow possible orderings considered building constraints appropriate scheduling selected based execution model con sidering example argument passing conventions eg possibility introducing tail calls whether execution sequential parallel profiling shows much execution time spent building manipulating robdds may worth investigating dierent constraints solvers propagationbased solvers another possible method improving overall analysis time would run old mode analysis first use new analysis predicates old analysis fails interesting observe dierences simple constraint system full system none benchmarks require partially instantiated data structures able analysed simple system cases simple system dierent full system othersparticularly bigger table 2 mode checking partially instantiated check infer infercheck iota 384 472 122 append copytree 150 6174 4116 benchmarksit significantly faster speculate bigger benchmarks benefit reduced number constraint variables simple analysis table shows timings programs make use partially instantiated modes current mercury system simple constraintbased system unable analyse times milliseconds averaged runs iota benchmark program example 4 append benchmark classic append3 however checking version valid combinations lsg modes declared copytree benchmark small program makes structural copy binary tree skeleton elements copy new free variables times check columns checking programs mode declarations whereas infer column shows times mode inference mode declarations removed interesting note saving analysis time achieved adding mode declarations particularly notable copytree benchmark mode inference able infer many modes one declared similarly declare mode append reduce analysis time 210ms 8 conclusion defined constraint based approach mode analysis mercury ecient current system mode checking able check infer complex modes current system decouples reordering conjuncts determining producers although described implementation handles mercury constructs higherorder constraintbased mode analysis yet handle subtyping unique modes plan extend handle features well explore advanced mode sys tems complicated uniqueness modes unique objects stored recovered data structures polymorphic modes boolean variables represent pattern mode usage circular modes needed clientserver programs client server processes modelled recursive loops cooperate instantiate dierent parts data structure coroutining manner would like thank australian research council support 9 r directional types annotation method experimental evaluation generic abstract interpretation algorithm prolog diagnosing nonwellmoded concurrent logic programs abstract interpretation concurrent logic languages static inference modes data dependencies logic programs layered modes type synthesis ground prolog deriving descriptions possible value program variables means abstract interpretation automatic derivation mode declarations prolog programs practicality abstract equation systems polymorphic type system prolog typed static analysis application groundness analysis prolog lambdaprolog making mercury programs tail recursive mode analysis domains typed logic programs system precise modes logic programs execution algorithm mercury tr polymorphic type system prolog graphbased algorithms boolean function manipulation static inference modes data dependencies logic programs abstract interpretation concurrent logic languages deriving descriptions possible values program variables means abstract interpretation experimental evaluation generic abstract interpretation algorithm prolog typed static analysis mode analysis domains typed logic programs making mercury programs tail recursive model checking hal ctr lee naish approximating success set logic programs using constrained regular types proceedings twentysixth australasian conference computer science research practice information technology p6167 february 01 2003 adelaide australia
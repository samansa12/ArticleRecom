modulo scheduling loops controlintensive nonnumeric programs much previous work modulo scheduling targeted numeric programs often majority loops wellbehaved loopcounterbased loops without early exits controlintensive nonnumeric programs loops frequently characteristics make difficult effectively apply modulo scheduling characteristics include multiple control flow paths loops based loop counter multiple exits loops presence unimportant paths high resource usage long dependence chains penalize important paths path contains hazard another nested loop prohibit modulo scheduling loop control dependences severely restrict overlap blocks within across iterations paper describes set methods allow effective modulo scheduling loops multiple exits techniques include removal control dependences enable speculation extensions modulo variable expansion new epilogue generation scheme methods used superblock hyperblock techniques allow modulo scheduling selected paths loops arbitrary control flow case study presented show methods combined superblock techniques enable modulo scheduling effectively applied controlintensive nonnumeric programs performance results several spec cint92 benchmarks unix utility programs reported demonstrate applicability modulo scheduling class programs b introduction scheduling instructions loops great interest many programs spend majority execution time loops often necessary scheduler overlap successive iterations loop order find copyright 1996 ieee published proceedings 29th annual international symposium microarchitecture december 24 1996 paris france personal use material permitted however permission reprintrepublish material resale redistribution purposes creating new collective works resale redistribution servers lists reuse copyrighted component work works must obtained ieee contact manager copyrights permissions ieee service center 445 hoes lane po 9085623966 sufficient instructionlevel parallelism ilp effectively utilize resources highperformance processors software pipelining 18 6 1 15 loop scheduling scheme allows motion instructions one iteration another maintains overlap loop iterations throughout execution loop description various approaches software pipelining given 17 paper focuses class software pipelining methods called scheduling 16 modulo scheduling simplifies generation overlapped schedules initiating iterations constant rate requiring iterations loop common schedule constant interval start successive iterations called initiation interval ii initial candidate ii chosen maximum two lower bounds resourceconstrained lower bound ii resmii 16 equal number cycles heavily used resource used single iteration worstcase constraint among cycles dependence graph determines recurrenceconstrained lower bound ii recmii 16 previous work modulo scheduling targeted numeric programs often majority loops wellbehaved loops loopcounter based loops without early exits extensive performance evaluations modulo scheduling techniques loops seems exist perception modulo scheduling primarily applicable programs controlintensive nonnumeric programs loops frequently characteristics make difficult apply modulo scheduling obtain significant speedup characteristics include multiple control flow paths loops based loop counter multiple exits several techniques developed allow modulo scheduling loops intraiteration control flow hierarchical reduction 11 predicated execution 5 reverse ifconversion 21 work assumed paths loop body included scheduling including paths detrimental overall loop performance presence unimportant paths high resource usage long dependence chains result schedule penalizes important paths infrequent path contains hazard another nested loop function call prohibit modulo scheduling loop previous work also done modulo scheduling loops based loop counter 20 19 key difficulty type loop may take many cycles determine whether start next iteration limiting overlap iterations difficulty overcome speculatively initiating next eration work 20 also mentions sourcetosource transformation convert loop multiple exits singleexit loop resulting loop contains multiple paths control dealt using one methods modulo scheduling loops intraiteration control flow referred however method adds extra instructions delays early exits end loop body work needed evaluate performance approach especially architectures without predicated execution paper describes new set methods allow effective modulo scheduling loops multiple paths control multiple exits use superblock 10 future hyperblock 14 techniques exclude unimportant detrimental paths loop loops multiple exits often occur naturally controlintensive programs beneficial exclusion paths via formation superblock hyperblock loops creates many thus effective method handling multiple exits essential rather transform loop single exit loop proposed methods modulo schedule loop multiple exits present new code generation scheme described creates correct epilogues exits speculation used increase overlap basic blocks within iteration overlap successive iterations extend modulo variable expansion allow speculation instructions write variables live loop exits altogether methods described paper allow effective modulo scheduling selected paths loops arbitrary control flow paper reports speedup results several spec cint92 benchmarks unix utilities first reported performance results modulo scheduling controlintensive nonnumeric programs demonstrate applicability modulo scheduling class programs validate correctness proposed methods paper organized follows section 2 describes methods developed presents case study show methods combined superblock tech niques enable modulo scheduling effectively applied controlintensive loops section 3 reports performance results section 4 provides summary directions future work 2 modulo scheduling controlintensive loops detailed example used illustrate difficulties caused controlintensive loops benefits techniques developed loop chosen case study one frequently executed loops lex lexical analyzer generator source code loop shown figure 1 tempj break return figure 1 source code example loop lex loops general purpose nonnumeric programs frequently complex control flow evident example loop outer loop contains ifstatement inner loop early exit via return statement inner loop contains ifstatement early exit via break statement obviously loop contains number hazards modulo scheduling modulo scheduling would ordinarily target inner loop however profile information indicates inner loop infrequently invoked usually iterations condition ifstatement evaluates false 90 time figure 2a shows simplified version control flow graph loop block x contains code load statei j comparison statement s1 block consists postincrement pointer j code body ifstatement s1 control flow within block omitted clarity block z contains code update test exit condition z z b figure 2 superblock formation example loop detrimental path containing inner loop excluded loop via superblock formation effective superblock formation done using profile information 3 andor static analysis structure hazards program 9 superblock loop consisting frequent path outer loop blocks x z formed shown figure 2b path block excluded via tail duplication block z superblock loop consists single path loop single entrance one exits loop consisting blocks x z appears inner loop multiple exits targeted modulo scheduling detailed description superblock formation see 10 3 shown superblock optimization acyclic scheduling techniques provide substantial speedup 10 general ability superblocks similarly hyperblocks exclude undesirable paths execution provide following benefits modulo scheduling ffl decrease resmii excluding unimportant paths high resource usage ffl decrease recmii excluding unimportant paths contribute long dependence cycles ffl increase number loops modulo scheduled excluding paths containing hazards nested loops function calls although modulo scheduling methods developed paper described using superblock examples equally applicable hyperblock code figure 3 shows assembly code example superblock loop instruction numbered later refer ence block x control flow graph consists instructions 3 instructions 4 6 block z assembly code shown produced impact compiler classic optimizations applied elements array state four bytes size registers shown virtual registers register allocation done modulo scheduling inst assembly register contents 6 ble 0 r4 l1 figure 3 assembly code superblock loop control exits superblock loop instruction 3 taken instruction 6 taken paper exit associated fallthrough path loop back branch termed final exit exits superblock loop via taken branches termed early exits virtual registers r34 r4 r12 live early exit l2 block taken values r34 r4 decremented block z value r12 incremented block virtual registers live loop exits via final exit instruction 6 loops complex control flow occur frequently general purpose nonnumeric programs table 1 shows statistics percentage dynamic instructions single basic block loops basic block multiple exit superblock loops superblock spec cint92 benchmarks several unix utility programs column labeled total sum two columns time spent two types loops spent excluded paths inner outer loops acyclic code table 1 percentage dynamic instructions single basic block superblock loops benchmark basic superblock total block 008espresso 56 578 634 026compress 06 498 504 072sc 44 346 390 085gcc 141 285 426 cmp eqn 26 209 235 lex 20 862 882 tbl 174 96 27 wc yacc 32 455 487 programs except gcc tbl little time spent single basic block loops programs except tbl time usually much spent multiple exit superblock loops single basic block loops table clear modulo scheduling must able effectively handle loops control flow applicable programs remainder section describes proposed techniques overcome control dependences register antidependences associated loops multiple exits liveout virtual reg isters code generation scheme loops multiple exits also presented 21 overcoming control dependence using speculative code motion control dependences major impediment exploitation ilp loops generalpurpose nonnumeric programs crossiteration control dependences restrict overlap loop iterations delaying start subsequent iterations branches current iteration executed frequently branches dependent earlier computations loop body cannot executed late iteration severely limiting overlap intraiteration control dependences combined crossiteration data dependences create recurrences limit throughput modulo scheduled loop also increase length critical paths single iteration resulting longer schedule iteration important consideration short trip count loops described 20 19 crossiteration control dependences loop back branch instructions next iteration relaxed allowing speculative code motion overlap iterations loops multiple exits concept must extended early exit branches often necessary remove crossiteration control dependences early exit branch instructions subsequent iterations achieve desired level overlap also often necessary remove intraiteration control dependences allow overlap blocks within iteration achieve good performance short trip count loops removal either type control dependence quite simple however currently assume stores branches speculatively executed reordering branches subject future work order speculatively execute loads instructions cause exceptions either processor architecture must contain support speculative execution 4 13 compiler must able prove via program analysis speculatively executed instruction except 2 paper assume instruction set architecture contains silent nontrapping versions instructions cause exceptions 4 furthermore instructions write virtual registers live loop exits require special attention removing control depen dences issue discussed section 22 show effect control dependences example superblock loop figure 4a shows dependence graph node numbered id figure 3 instruction represents branch nodes shaded data control dependences shown solid dashed lines respectively transitive dependences shown none register antidependences shown assuming removed removal antidependences discussed section 22 control data figure 4 dependence graph example loop arc labeled two numbers first minimum delay cycles required start two instructions second number distance number iterations two dependent structions arcs distance zero intraiteration dependences distance greater zero crossiteration dependences instruction set assumed similar hps parisc 11 branch delay slots except branches delays shown pa7100 assumed instructions fallthrough path branch potentially executed cycle branch instructions taken path executed cycle following branch several nontrivial recurrences apparent graph longest recurrence circuit runs instructions 1 2 3 4 6 back 1 total delay six spans one iteration resulting recmii six loop scheduled using dependence graph overlap iterations crossiteration control dependences loop back branch instructions next iteration except instruction 3 removed allowing speculative code motion overlap itera tions however still limiting control dependences present recurrence circuit consisting instructions limits recmii five break recurrence intraiteration control dependence instructions 3 5 must removed enabling speculative execution instruction 5 control dependence instruction 3 instruction 4 must also removed break remaining limiting recurrence figure 4b shows dependence graph limiting control dependences removed reducing recmii one instruction legally moved modulo scheduling branch branch data dependent instruction example instruction 5 could legally scheduled instruction 6 instruction moved branch automatically moved paths branch generation epilogues follows actual modulo scheduling process sections 22 24 shown special attention must paid type code motion correct code generation multiple exit loops assuming 4issue processor execute one branch per cycle resmii example loop two recmii one resulting ii two speedup three modulo scheduling using dependence graph figure 4a 22 overcoming antidependence using modulo variable expansion thus far nothing said antidependences constraints imposed virtual registers live loop exits original form instruction writes virtual register v live exit branch b cannot moved b overwrites value v used exit b taken constraint upward code motion exactly v one operands b ie antidependence constraint represented differently many compilers instead adding explicit antidependence arc many compilers including impact overload control dependence arc represent control dependence antidependence several examples antidependence case study loop instruction 1 uses r34 later defined instruction 5 virtual register r34 live branch l2 instruction 3 taken anti dependence instruction 3 instruction 5 antidependences removed renaming modulo variable expansion 11 19 unrolls kernel renames successive lifetimes corresponding loop variant longer overlap time allows register antidependences removed schedul ing knowing modulo variable expansion correct overlap lifetimes lack dependences allows modulo variable expansion algorithm originally described 11 allows removal crossiteration antidependences however intraiteration antidependences also removed lifetime analysis renaming algorithms extended include lifetimes cross iterations assumed done 19 paper describe changes needed figure 5 illustrates relaxation crossiteration antidependence using modulo variable expansion described 11 three iterations abstract loop body containing definition use virtual register r1 shown intraiteration flow dependence marked f crossiteration antidependence marked cycle instruction issued shown square brackets right abstract struction assuming delay flow dependence two antidependence zero original form shown left minimum ii achieved two using modulo variable expansion antidependence removed prior scheduling reducing ii one two virtual registers used shown right use r1 2 f use r1 4 f use r1 6 f use r1 2 f use r2 3 f use r1 4 f b figure 5 relaxation crossiteration anti dependence figure 6 shows relaxation intraiteration anti dependence case use appears definition original iteration lifetime r1 crosses iterations removal intraiteration anti dependence prior scheduling allows definition moved use within iteration shown right previous case two registers used ii reduced 2 1 use r1 0 use r1 2 f use r1 4 f use r1 1 use r2 2 f use r1 3 f b figure 6 relaxation intraiteration anti dependence lifetime virtual register extends first definition last use lifetime loopvariant virtual register v definition use u computed using following equation assuming lifetime starts issued ends u issued issued issueu issue time instances u original iteration 1 distv number iterations separating instance u uses value defined original loop note equation 1 use u could branch v live correct renaming lifetime analysis must extended include uses additional consideration live virtual registers instruction moved downward across branch b code motion occurs definition moved paths branch epilogue generation v longer liveout lifetimev computed equation 1 becomes less equal 0 thus lifetime v computed uses except associated exits moved across figure 7 shows execution two iterations case study loop modulo scheduling first iteration starts time 0 instructions denoted subscript 1 second iteration starts time 2 instructions denoted subscript 2 second erations instructions also shaded distinguish two iterations lifetimes virtual registers written loop shown right execution record virtual registers lifetime begins scheduling generates schedule single iteration original loop schedule working analyzing lifetimes modulo variable expansion definition first iteration subsequent tic marks denotes either explicit use virtual register source operand branch register liveout lifetime extends last use register cycle issue slot lifetimes figure 7 execution record lifetimes two iterations lifetime r13 entirely contained within one iter ation defined instruction 2 used instruction 3 issue2 2 issue3 4 distr13 0 ii 2 using equation 1 length lifetime 2 lifetime r34 crosses iterations defined instruction 5 used instruction 1 5 next iteration live instruction 3 next iteration issue5 1 issue3 4 distr34 1 using equation 1 total length lifetime 5 definitions v renamed cycling set virtual registers assigned v use v renamed first finding iteration contains corresponding definition v current iteration dis tancev zero previous iteration distancev one using virtual register name definition iteration longest lifetime r34 5 cycles loop must unrolled three times modulo variable expansion figure 8 shows unrolled kernel modulo scheduled loop modulo variable expansion instructions renumbered renaming one names used original virtual register name set registers used r34 r34 r342 r343 set registers used r12 r12 r122 r123 instructions put sequential order would done generating code superscalar processor target fallthrough path first two copies loop back branch instructions 6 12 reversed preparation epilogue generation block l3 original fall path loop inst assembly cycle ble 0 r4 l1 5 l3 figure 8 unrolled kernel superscalar processor 23 review code generation scheme single exit loops subsection review existing code generation scheme single exit loops preparation introducing modified scheme multiple exit loops complete discussion possible code schemes single exit loops see 19 use abstract code representation 19 reduce complexity examples figure 9a shows single iteration generic singleexit loop modulo scheduling square represents code one stage ii cycles single iteration original source loop number stages called stage count a3 ii cycles b unrolledkernel code structure one iteration figure 9 abstract representation iterations figure 9b shows code structure modulo scheduled loop kernel unrolling generation prologue epilogue iterations progress left right one starting one stage previous one backedge arrow row 6 row 3 identifies start end unrolled kernel degree unrolling unrelated stage count squares kernel represent prologue squares afterward represent epilogue square also given number specify version code used version uses different names registers avoid overwriting live values code structure figure 9b simplistic allow arbitrary number iterations correctly executed 19 illustrates basic concepts prepares reader complex correct code schemes described later section paper loop back branch refers loop back branch original loop body multiple copies branch modulo scheduling kernel unrolling prologue generation copies except one becomes loop back branch kernel target fallthrough path reversed shown figure 8 loop exited branch taken rather falls exits associated copies loop back branch called final exits exits early exits chain dependences leading loop back branch determines earliest stage loop back branch placed stage loop back branch scheduled determines number iterations speculatively initiated assume stages iteration numbered stage corresponds 0 stage b corresponds 1 using terminology 19 loop back branch scheduled stage speculatively executed stages iteration first example figure 9b loop back branch scheduled stage b stage every iteration first executed speculatively paper last iteration refers last iteration would executed original nonpipelined loop exit last iteration taken speculative iterations aborted figure shows structure code generated possible stages loop back branch could placed threestage schedule figure 10a b c loop back branch scheduled end stage b c respectively a3 a3 c a3 figure 10 code generation scheme single exit loops arrows except backedge represent control transfers prologue kernel epilogues shown final exits scheduled end stage arrows originate close bottom row squares epilogue contains code complete nonspeculative iterations progress time exit taken although explicitly shown end epilogue exists code move live values registers code outside loop expects find jump original target block exit comparing figure 10a b one see structure generated code changes loop back branch scheduled end stage b instead stage loop back branch executed one stage later fewer stages left execute epilogues last iteration predecessors thus epilogues one less row one speculative iteration progress loop exits aborted one less column epilogue one less exit prologue one epilogues disappeared altogether general loop back branch placed stage instead stage 0 rightmost columns epilogue removed corresponding aborted speculative iterations 19 resulting epilogues stage count figure 10c loop back branch scheduled end last stage thus last iteration predecessors complete loop exits epilogues consist code needed move live values shown 24 code generation scheme multiple exit loops figure 11 illustrates changes code generation scheme multiple exit loops figure assumes loop two exits early exit loop back branch scheduled stage figure 11a b c branches scheduled stage b c respectively exits modulo scheduled loop thus epilogues arrows associated early exits originate close top row dashed lines distinguish final exits two key differences final exit early exit first final exit scheduled end stage early exit branch middle stage thus final exit epilogue starts beginning stage following one containing final exit branch early exit remainder row containing exit branch kernel must examined copying epilogue iterations last one remainder iterations stage row containing exit branch copied epilogue treatment last iteration discussed shortly figure small letters used denote partial stage resulting exit branch middle stage a3 a3 c3 c2 c1 a3 c3 c2 c1 a3 c3 c2 c1 figure 11 code generation scheme multiple exit loops second key difference loop back branch always last instruction original loop body early exit branch somewhere middle original loop body final exit taken last iteration always fully executed remaining stages last iteration copied epilogue entirety however early exit taken instructions last iteration appeared exit branch original loop body executed assume basic blocks superblock assigned numerical ids sequentially zero sc gamma 1 define home block instruction basic block instruction resides original loop body early exit instruction remaining stages last iteration copied epilogue id home block less equal home block id exit branch figure 11 shaded squares used denote stages home block checked copying instruction figure 11 epilogues final exits figure 10 epilogues early exits always one row usually one column corresponding final exit stage extra row consists remainder row kernel early exit branch resides thus squares extra row marked small letters extra column corresponds last stage oldest iteration progress time exit taken final exit iteration finished exit taken early exit part last stage remains completed epilogue epilogues early exits prologue extra column none iterations started execution last stage rightmost column early exit epilogue shaded column corresponds last iteration last iteration instructions appeared exit branch original loop body copied epilogue figure 12 shows algorithm generating epilogue exit branch algorithm starts instructions following exit branch copies rows instructions unrolled kernel epilogue wrapping around kernel last row epilogue complete squares copied correspond instructions iterations last instructions last iteration appeared exit branch original loop body algorithm shown assumes processor branch delay slots following paragraphs describe data structures concepts needed understand algorithm unrolled kernel divided sections ii cycles called kernel rows kmin rows kmin degree unrolling kernel row contains linked list instructions contained row data structure instruction contains pointer information structure contains among items stage instruction scheduled instructions home block id row kernel contains instruction sc gamma rows epilogue numbered zero stage exit branch scheduled row zero partial row empty final exit linked list kernel row ends final exit row epi row epilogue last iteration executing stage instructions stages less epi row must iterations last thus copied simplicity algorithm shown generates correct epilogues exits kernel exits prologue practice algorithm contains additional code map exit prologue corresponding exit kernel prologue generated similar manner epilogues copying selected instructions rows unrolled kernel mapping prologue exit corresponding kernel exit facilitates copying rows epilogue also practice epilogue exit prologue algorithm copy instruction later stage stage first iteration executing instructions correspond nonexistent iterations prior first one apply code generation scheme example loop schedule single iteration example loop contains 3 stages stage consists instructions 1 5 original loop see figure 7 stage b contains instruction 2 instructions 3 early exit 4 6 final exit stage c code scheme figure 11c similar would generated example loop dependence structure loop opportunity downward code motion across early exit branch thus early exit branch taken remaining instructions last iteration appeared exit branch original loop body algorithm genepiexit branch create epilogue block generate rows epilogue determine start copying epirow partial row exit final exit exitnextop null instructions copied partial row else full row generate one full partial row oper null copy instruction iteration previous last iteration last iteration appears exit branch original loop body operstage insertopafterepiloguelastop newop rotate rows kernel insert moves end epilogue variants live exit insertmovesforlivevariantsepilogue exit last exit branch falls epilogue exit last exit unrolled kernel create jump target exit branch make epilogue block target exit branch figure 12 epilogue generation algorithm shaded epilogues empty 25 insertion moves liveout values mentioned earlier code must appended end epilogue move values liveout corresponding exit register code outside loop expects find single exit superblock loops value used outside loop must defined last iteration thus final exit instructions last iteration examined corresponding epilogue kernel value produced instruction liveout destination register one expected outside loop move instruction inserted end epilogue multiple exit loops procedure final exits however early exits additional consideration live value could defined last iteration one instructions preceded exit branch original loop body could defined secondtolast iteration one instructions followed exit branch original loop body thus last iteration examined instructions originally resided earlier home block early exit branch secondtolast iteration examined instructions originally resided later home block exit example loop early exit instruction 3 figure taken live values r34 r4 secondtolast iteration live value r12 last iteration values live final exit figure 13 shows code generated example loop using multiple epilogue code scheme figure 11c instructions renumbered moves live values instructions 25 27 28 30 also shown blocks labeled pro l1 prologue unrolled kernel respectively blocks labeled le1 le3 le5 epilogues block immediately following kernel epilogue reached falling loop back branch block l3 original fall path loop label l2 start block epilogues final exits instructions 11 17 23 empty code moved downward across loop back branch virtual registers live final exits rather branching empty epilogues final exits branch directly l3 exception loop back branch falls epilogue jumps l3 early exits instructions 6 12 18 require moves one live virtual registers branch epilogues mentioned end 22 renaming one names used original virtual register name thus live value already correct register move necessary case r34 epilogue le1 r12 epilogue le5 jump placed end early exit epilogue transfer control block inst assembly cycle 22 ble 0 r4 l1 5 26 jump l2 0 28 29 jump l2 0 l3 figure 13 final assembly code example loop virtual registers renamed modulo variable expansion uses livein virtual register first iteration refer original virtual register name thus moves required livein values example virtual register r34 livein first iteration prologue uses r34 instructions 1 2 rather one renamed versions r342 r343 3 experimental results section report experimental results applicability modulo scheduling controlintensive nonnumeric programs results obtained using impact compiler interprocedural alias analysis 7 data dependence analysis done front end memory dependence arcs passed back end giving optimizer schedulers accurate dependence information addition classic optimizations optimizations performed back end increase ilp code 10 modulo scheduling done prepass acyclic scheduling global register allocation modulo scheduler implementation raus iterative modulo scheduling 16 uses machine description system 8 get information instruction latencies resource requirements modulo scheduler used pipeline loops high issue rate versions parisc paper sparc architectures loops eligible modulo scheduling inner loops outer loops may become inner loops superblock formation single basic block superblock loops contain function calls included path function calls may excluded loop superblock formation enabling modulo scheduling target processors experiments multiple issue processors issue rates 4 8 varying resource constraints table 2 shows functional unit mix processor processors assumed integer registers 32 doubleprecision floatingpoint registers latencies used hp pa7100 processor table 2 processor characteristics number name issue integer memory branch fp slots alus ports units alus base speedups reported singleissue base pro cessor base processor ilp optimizations modulo scheduling applied multiple issue pro cessors code generated three ways without modulo scheduling modulo scheduling single basic block loops modulo scheduling superblock loops using techniques described pa per code software pipelined scheduled using acyclic superblock scheduling 10 none loops unrolled acyclic scheduling modulo scheduling general prior unrolling improves performance acyclicly scheduled modulo scheduled loops 12 however complex interactions unrolling optimization scheduling add another variable trying focus effect modulo scheduling purpose paper primarily describe effective method modulo scheduling loops controlintensive nonnumeric pro grams results paper used demonstrate applicability modulo scheduling class programs validate correctness method effects unrolling prior scheduling performance comparisons modulo scheduling acyclic scheduling unrolled loops controlintensive nonnumeric programs subject future work described section 4 execution times whole programs calculated using scheduler cycle counts basic block profile information 100 cache hit rate assumed benchmarks profiled transformations insure accuracy profiling done instrumenting target virtual processors assembly code emulating aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa superblock modulo scheduling basic block modulo scheduling scheduling espresso eqntott compress gcc cmp lex wc yacc figure 14 speedup single issue processor without modulo scheduling hp series 700 workstation execution produces benchmark output used verify correctness target processors assembly code benchmarks chosen experiments four spec cint92 four unix programs table 1 espresso eqntott compress gcc cmp lex wc yacc spend time basic block superblock loops loops apply modulo scheduling chosen programs 40 dynamic instructions loops total 305 loops modulo scheduled figure 14 shows speedup results white part bars show speedup base processor acyclic scheduling applied code espresso eqntott lex yacc performance flat resources increased without overlapping iterations ilp exploited limited black part bars show slightly increased performance modulo scheduling applied single basic block loops benchmarks except gcc less 6 dynamic instructions basic block loops thus slight performance improvement expected benchmark gcc spends half much time 14 single basic block loops superblock loops shows speedups 5 crosshatched part bars show increased performance superblock modulo scheduling applied eligible loops modulo scheduling almost doubles performance lex 4issue processor almost triples performance 8issue processor shown case study limited ilp within single iteration loops program modulo scheduling provides good speedup across benchmarks processors particular speedups 25 obtained across processors espresso eqntott com press lex yacc aggressive processor performance improved 30 benchmarks except gcc wc superblock modulo scheduling performance espresso eqntott lex yacc longer flat processor resources increased ilp exploited overlapping loop iterations results clearly show modulo scheduling using techniques described paper applicable controlintensive nonnumeric programs 4 conclusion paper described set methods allow effective modulo scheduling loops multiple exits methods used allow modulo scheduling selected paths loops arbitrary control flow case study presented show methods enable modulo scheduling effectively applied controlintensive nonnumeric programs performance results several spec cint92 benchmarks unix utility programs demonstrated modulo scheduling significantly accelerate loops class programs previous work shown unrolling prior modulo scheduling improves performance numeric programs 12 unrolling enables additional optimization effective ii integer acyclic scheduling unrolling done allow optimization overlap iterations modulo scheduling unrolling done optimize effective resmii recmii much research needs done study effect unrolling prior modulo scheduling nonnumeric programs understand amount unrolling necessary achieve minimum ii possible given loop next step effort apply modulo scheduling controlintensive nonnumeric programs one result next step ability compare modulo scheduling global acyclic scheduling unrolled loops within common framework acknowledgments research paper benefited conversations mike schlansker bob rau hp labs thanks bob rau scott mahlke grant haab providing feedback early version paper brian deitrich john gyllenhaal anonymous referees suggestions submitted version authors would also like thank jurgen mihm whose work inspired thoughts modulo variable expan sion nancy warterperez noubar partamian past present members impact research group providing underlying technology modulo scheduler built research supported national science foundation nsf grant mip9308013 intel advanced micro devices hewlettpackard sun microsystems ncr national aeronautics space administration nasa contract nasa nag 1613 cooperation illinois computer laboratory aerospace systems software iclass r realistic resourceconstrained software pipelining algorithm using profile information assist classic code optimizations three architectural models compilercontrolled speculative execution overlapped loop support cydra 5 new compilation technique parallelizing loops unpredictable branches vliw architecture memory disambiguation facilitate instructionlevel parallelism compilation machine description language compilation superblock formation using static program analysis superblock effective technique vliw superscalar compilation software pipelining effective scheduling technique vliw machines sentinel scheduling model compilercontrolled speculative execution effective compiler support predicated execution using hyperblock efficient scheduling fine grain parallelism loops iterative modulo scheduling algorithm software pipelining loops scheduling techniques easily schedulable horizontal architecture high performance scientific computing code generation schema modulo scheduled loops parallelization loops exits pipelined architectures enhanced modulo scheduling loops conditional branches tr software pipelining effective scheduling technique vliw machines overlapped loop support cydra 5 new compilation technique parallelizing loops unpredictable branches vliw architecture parallelization loops exits pipelined architectures advances languages compilers parallel processing using profile information assist classic code optimizations effective compiler support predicated execution using hyperblock code generation schema modulo scheduled loops enhanced modulo scheduling loops conditional branches sentinel scheduling instructionlevel parallel processing superblock iterative modulo scheduling unrollingbased optimizations modulo scheduling efficient scheduling fine grain parallelism loops superblock formation using static program analysis three architectural models compilercontrolled speculative execution scheduling techniques easily schedulable horizontal architecture high performance scientific computing ctr elana granston eric stotzer joe zbiciak software pipelining irregular loops tms320c6000 vliw dsp architecture acm sigplan notices v36 n8 p138144 aug 2001 fei chen timothy w oneil edwin hm sha optimizing overall loop schedules using prefetching partitioning ieee transactions parallel distributed systems v11 n6 p604614 june 2000 suhyun kim soomook moon jinpyo park kemal ebcioglu unrollbased copy elimination enhanced pipeline scheduling ieee transactions computers v51 n9 p977994 september 2002 moon evaluation scheduling techniques sparcbased vliw testbed proceedings 30th annual acmieee international symposium microarchitecture p104113 december 0103 1997 research triangle park north carolina united states ganesh lakshminarayana kamal khouri niraj k jha wavesched josep llosa stefan freudenberger reduced code size modulo scheduling absence hardware support proceedings 35th annual acmieee international symposium microarchitecture november 1822 2002 istanbul turkey enric gibert jess snchez antonio gonzlez interleaved cache clustered vliw processor proceedings 16th international conference supercomputing june 2226 2002 new york new york usa mary lou soffa interprocedural conditional branch elimination acm sigplan notices v32 n5 p146158 may 1997 nystrom alexandre e eichenberger effective cluster assignment modulo scheduling proceedings 31st annual acmieee international symposium microarchitecture p103114 november 1998 dallas texas united states satish pillai margarida f jacome compilerdirected ilp extraction clustered vliwepic machines predication speculation modulo scheduling proceedings conference design automation test europe p10422 march 0307 alexander g dean complementing software pipelining software thread integration acm sigplan notices v40 n7 july 2005 samuel larsen rodric rabbah saman amarasinghe exploiting vector parallelism software pipelined loops proceedings 38th annual ieeeacm international symposium microarchitecture p119129 november 1216 2005 barcelona spain sangmin shim soomook moon splitpath enhanced pipeline scheduling ieee transactions parallel distributed systems v14 n5 p447462 may michael dupr nathalie drach olivier temam vhc quickly building optimizer complex embedded architectures proceedings international symposium code generation optimization feedbackdirected runtime optimization p53 march 2024 2004 palo alto california
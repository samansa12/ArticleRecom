software reuse specialization generic procedures views abstracta generic procedure specialized compilation views operate directly concrete data view computational mapping describes concrete type implements abstract type clusters related views needed specialization generic procedures involve several types several views single type user interface reasons relationships concrete types abstract types allows view clusters created easily techniques allow rapid specialization generic procedures applications b introduction reuse software potential reduce cost increase speed software production increase reliability facilitating reuse software could therefore great benefit g novak jr department computer sciences university texas austin automatic programming server demonstration software available world wide web via httpwwwcsutexaseduusersnovak running demo requires x windows rigid treatment type matching presents barrier reuse languages types arguments procedure call must match types parameters procedure reason reuse often found type compatibility occurs naturally ie types basic made compatible language eg arrays numbers truly generic procedure reusable reasonable implementation abstract types developer generic able advertise program work data without knowing users data representation seek reuse without conformity rigid standards envision two classes users developers understand details abstract types generic procedures users programmers reuse generics need less expertise understanding details developers produce libraries abstract types generics specializing generics users obtain program modules applications view provides mapping concrete type abstract type 1 terms generic algorithm written fig 1 illustrates schematically view acts interface adapter makes concrete type appear abstract type 2 view provides clean separation semantics data represented abstract type implementation implementation minimally constrained view made generic procedure associated abstract type automatically specialized concrete type shown fig 2 implementation specialized procedure lisp function desired mechanically translated another language tools exist make easy create views programmer obtain specialized procedure insert records avl tree 185 lines c minutes data procedure data view procedure figure 1 interfacing strong typing views 1 consider abstract type set basis variables set generic procedures written terms basis variables goguen 18 others used similar analogy diagram concrete type view compiler generic procedure specialized procedure figure 2 specialization generic procedure view approach reuse several advantages 1 provides freedom select implementation data data need designed ab initio match algorithms 2 several views data structure correspond different aspects data 3 several languages supported lisp c c java pascal generated single version generic algorithms 4 tools simplify specification views reduce learning required reuse software 5 views used automatically specialize generic procedures library b instantiate program framework components c translate data one representation another generate methods objectoriented programming e interface programming tools data display editing paper describes principles views specialization generic algorithms well implementation techniques using glisp language compiler glisp lispbased language abstract data types section 2 describes conceptual terms views provide mappings concrete types abstract types section 3 describes glisp compiler views used specializing generic algorithms section 4 discusses clusters related views needed reuse generic algorithms involve several types several views type section 5 describes program viewas reasons relations concrete types abstract types makes easy create view clusters section 6 describes higherorder code generic algorithm finding convex hull uses generics uses several views single data structure section 7 describes use views objectoriented programming section 8 surveys related work section 9 presents conclusions 21 computation isomorphism useful think computation simulation formally isomorphism idea long history example isomorphism basis denotational semantics 20 goguen 18 19 describes views isomorphisms mappings unary binary operators views allow broader mappings concrete abstract types include algorithms well operators use isomorphism introduce use views preparata yeh 56 give definition diagram isomorphism semigroups given two semigroups g 1 invertible function said isomorphism g 1 g 2 every b lambda b oe gammapsi gammapsi since invertible computational relationship ffi b difficult obtain directly value computed encoding b using performing computation lambda b decoding interpreting result using diagram said commute 2 result obtained regardless path two points followed shown diagram 22 views isomorphisms reuse generic algorithms views corresponds computation isomorphism concrete type corresponds lefthand side isomorphism diagram view maps concrete type abstract type generic algorithm corresponds operation abstract type mapping concrete type abstract type performing operation abstract type mapping back result performing algorithm concrete type obtained however instead performing view mapping explicitly concrete concrete type abstract generic algorithm abstract type view view oe compilation optimization concrete concrete type specialized algorithm figure 3 specializing generic materializing abstract data mappings folded generic algorithm produce specialized version operates directly concrete data fig 3 example let concrete type pizza contain value represents diameter circular pizza suppose abstract type circle assumes radius value r view pizza circle specify r corresponds d2 simple generic procedure calculates area circle specialized compilation view view mapping folded generic algorithm optimized specialized algorithm operates directly original data case extra computation fig 4 code reference data structure pizza included specialized code area pizza area circle compilation optimization area pizza figure 4 example specialization 23 abstract data types views abstract type abstraction set concrete types assumes abstract record containing set basis variables 3 set named generic procedures written terms basis variables 4 data structure contains basis variables names types implements abstract type maximize reuse constraints implementation must minimized possible specialize generic procedure legitimate implementation abstract type diameter radius pizzaascircle pizza figure 5 encapsulation concrete type view view encapsulates concrete type presents external interface consists basis variables abstract type fig 5 illustrates view type pizzaascircle encapsulates pizza presents interface consisting radius abstract type circle radius implemented dividing field diameter pizza 2 fields pizza hidden code example shown following section general case interface provides ability read write basis variable read write may implemented access variable concrete record procedure emulates read write using concrete record storage 5 view implements abstract type emulates record containing basis variables emulation expressed two properties 1 storage value z stored basis variable v reference v yield z 3 although required abstract types usually specify concrete record containing basis variables useful example testing generic procedures 4 definition abstract type different algebraic description abstract types 11 collection abstract sorts procedure signatures axioms algebraic approach abstract type described without regard implementation approach abstract implementation assumed abstract type generic procedures implement operations 5 views implemented objectoriented system adapter wrapper objects 16 wrapper contains concrete data presents interface abstract type translates messages abstract concrete types views give effect wrappers without creating 2 independence reference basis variable v yields value z value stored basis variable w reference v still yield z properties express behavior expected record stored values retrieved storing one field change values others view implements abstract type exactly described storage independence properties generic procedure operate way produce output side effects operating concrete data view operating record consisting basis variables isomorphism holds abstract type concrete type diagram commutes criterion satisfied following variations data 1 record structure may used contain variables 6 2 names variables may differ abstract type views provide name translation name spaces concrete abstract types distinct generics use subset basis variables used must defined view attempt use undefined basis variable detected error view effect defines functions compute basis variables concrete variables generic procedure store basis variables functions must invertible simple functions inverted automatically compiler complex cases procedure defined effect store basis variable procedures required mathematical views may somewhat complex case polar vector r abstract type cartesian vector x assignment basis variable x must update r x new value unchanged program mkv make view 54 allows user specify mathematical views graphically connecting corresponding parts concrete type diagram associated abstract type mkv uses symbolic algebra derive view procedures correspondences wider reuse storage independence properties must relaxed slightly even simple change representation division diameter value 2 pizza example changes point numerical overflow occurs could also roundoff error significant changes representation allowed representing vector polar coordinates r basis variables cartesian coordinates x polar vector viewed cartesian vector using transformations sin mapping exact due roundoff error onetoone however sufficiently accurate many applications ultimately user system must ensure chosen representation sufficiently accurate cases user might want specify contents type let system define record using eg avl tree containing strings easily done substituting contents type prototype record definition view mappings predefined next section describes views implemented compiled glisp 6 could include arrays subrecords reached fixed sequence pointer traversals 3 glisp language compiler glisp 46 47 48 49 generic lisp highlevel language abstract data types compiled lisp language describing data lisp languages glisp described briefly detail see 49 46 31 dataindependent code glisp type analogous class objectoriented programming oop specifies data structure set methods method name selector definition expression function oop hierarchy types methods inherited ancestor types methods abstract types generic procedures languages syntax program code depends data structures used prevents reuse code alternative implementations data glisp uses single lisplike syntax lisp function call written inside parentheses sqrt x similar syntax feature object used glisp access feature data structure 49 1 feature name field type object data access compiled 2 feature method name selector type object method call compiled 3 feature name view type object type object locally changed view type 4 feature function name code left unchanged 5 otherwise warning message issued feature undefined typedependent compilation allows variations data representation code used data stored one type computed another type example type circle assume radius basis variable pizza object store diameter compute radius glisp compiler performs type inference compiles expressions type object known compile time reference feature compiled inline code call specialized generic specialized code depends types arguments generic compilation inline expansion specialization recursive compile time propagates types recursion important feature recursive expansion allows small amount source code expand large output code allows generic procedures use generics subroutines allows higherorder procedures expanded several levels abstraction operations data reached symbolic optimization folds operations constants 62 performs partial evaluation 7 12 mathematical optimization removes dead code combines operations improve efficiency provides conditional compilation since conditional eliminated test evaluated compile time optimization often eliminates operations associated view use view little cost compilation 32 views glisp view 46 49 50 expressed glisp type whose record concrete type abstract type superclass view type allowing generics inherited 7 view type encapsulates concrete type defines methods compute basis variables abstract type specialized versions generics compiled compiler caches view type examples abstract type circle concrete type pizza view type pizzaascircle shown gives name type followed data structure followed method prop view superclass specifications circle list center vector radius real pizza cons diameter real topping symbol views circle pizzaascircle pizzaascircle p pizza supers circle pizzaascircle encapsulates pizza makes appear circle record named p type pizza defines basis variable radius diameter p divided 2 specifies circle superclass hides data methods pizza 8 following example shows area defined circle compiled view glisp function t1 shown followed compiled code lisp gldefun t1 pzpizza area circle pz result type real code circle pz changes type pz view type pizzaascircle area method inherited circle expanded inline basis variable radius expanded using diameter becomes data access car pz view defines basis variables terms concrete type generic procedure abstract type used view compilation glisp recursive generic procedures written using generics subroutines 7 methods inherited data structures therefore state variables 8 pizzaascircle fails define basis variable center allowable attempt reference undefined basis variable detected error long recursion terminates compile time 9 view type may redefine methods generics abstract type may improve efficiency example cartesian vector defines magnitude generic value stored r polar r vector basis variable assigned value compiler produces code follows 1 basis variable corresponds field concrete type store generated 2 basis variable defined expression inverted algebraically compiler example assigning value r radius pizzaascircle causes r 2 stored diameter record pizza 3 procedure defined view type accomplish assignment basis variable maintaining storage independence properties mkv 54 produces procedures automatically view define procedure create instance concrete type set basis variables abstract type 54 needed generics create new data eg two vectors added produce new vector several points views worth noting 1 general case object view rather view represents aspect object object may data involved view 2 view provides name translation removes necessity concrete data use particular names eliminates name conflicts 3 view specify representation transformation 4 several ways viewing concrete type given abstract type example records might sorted several ways different purposes 4 clusters views several languages eg ada modula2 ml c provide form abstract data type like macro instance formed substituting concrete type eg make linked list whose contents user type technique allows limited software reuse seek extend principle generic reusable reasonable implementation data generics involve several abstract types data structures might regarded single concept linked list involve several types linked list record type pointer type many languages finesse need two types providing pointer type derived record 9 recursion beyond certain depth trapped treated compilation error type general however pointer data uniquely denotes record memory memory address disk address array index employee number etc maximize generality record pointer must treated distinct types view maps single concrete type single abstract type cluster collects set views related used generic algorithm example polygon represented sequence points points could cartesian polar type could viewed point eg city sequence could linked list array etc different generic combination types single generic usable combination cluster collects views used generic algorithm single place allows inheritance specialization generics views used type inference cluster set roles name corresponding view type example cluster linkedlist roles named record pointer cluster may superclusters view type fills role specifies superclass type fills role supercluster allowing inheritance methods view types also define methods constants 10 needed generic procedures example cluster sortedlinkedlist requires specification field property record sort whether sort ascending descending 41 example cluster sorted linked list section gives example record shows cluster made using viewas shows generic specialized begin showing user interaction viewas emphasize ease use later section explains viewas works c structure example record myrec corresponding glisp type shown 11 struct myrecord int char name int struct myrecord next myrec crecord myrec color integer name string next constant specified method returns constant value 11 glisp type could derived automatically c declaration implemented suppose user wishes view myrec sortedlinkedlist obtain specialized versions generics application user invokes viewas make view cluster viewas sortedlinkedlist myrec viewas determines concrete type matches abstract type makes choices automatically asks user choices 12 choice specify choice sortvalue choices color name size name specify choice sortdirection choices ascending descending ascending viewas chooses field next link linkedlist record since possibility asks user field sort direction sorting viewas requires simple choices user resulting cluster myrecassll two view types shown fig 6 cluster myrecassll roles named pointer record filled corresponding view types myrecassll lists cluster sll sorted linked list supercluster view type myrecassllpointer pointer view type myrecassllrecord corresponding type sllpointer cluster sll superclass generics sll defined methods sllpointer view type myrecassllrecord data named z16 13 type myrec lists type sllrecord superclass defines link making view cluster user obtain specialized versions generics expect user would read code generics specializations derived present generic specialization illustrate process fig 7 shows generic sllinsert uses generics rest defined linkedlist value field link sortbefore notation ptr short dereference pointer ptr sortdirection tested code however since constant compile time compiler eliminates keeps one sortbefore test expanded depending type sortvalue converts symbols uppercase uppercase lowercase representations symbol equivalent general user input shown lowercase lisp output symbols uppercase 13 names numeric suffixes new unique names generated system unique name z16 encapsulates myrec prevents name conflicts view type features myrec accessed via name glclusterdef roles pointer myrecassllpointer record myrecassllrecord view type myrecassllpointer glcluster myrecassll view type myrecassllrecord result lst else new figure 7 generic insert sorted linked list 42 uses clusters clusters serve several goals 1 clusters allow independent specification several views used generic 2 generic performs given function written generics reuse generics possible clusters allow generics inherited 3 clusters used derive correct view types generics specialized 421 inheritance clusters desirable inherit reuse generics possible cases cluster considered specialization another cluster eg sortedlinkedlist specialization linkedlist generics defined linkedlist also work sortedlinkedlist length linkedlist whether sorted generics defined highest possible level abstraction facilitate reuse cluster specify superclusters fig 9 shows inheritance among clusters myrecassll example cluster inherit generics clusters mechanism inheritance clusters simply inheritance types type fills role cluster lists superclass type fills corresponding myrec sllinsert1 lst new myrec lst new myrec ptr prev ptr strcmpptrname newname prev return lst else return new figure 8 specialized procedure c role supercluster inheritance paths specified manually abstract types viewas sets inheritance paths creates view clusters inheritance provides defaults generic procedures constants example generics sortedlinkedlist use predicate sortbefore compare records generic sortbefore defined applied sortvalue records predicate turn depends type sortvalue eg string comparison used strings minimal specification sortedlinkedlist use default sorting predicate arbitrary sortbefore predicate specified record view type desired cases inheritance generics superclusters preventable example nreverse destructive reversal order elements linked list defined linkedlist available sortedlinkedlist since destroys sorting order prevention inheritance accomplished defining method error case attempt use method treated compilation error recordwithpointer linkedlist sll sortedlinkedlist figure 9 inheritance clusters 422 type mappings cluster specifies set related types generic procedure specified terms abstract types specialized corresponding view types must sub stituted example abstract level linkedlistrecord contains field link whose type linkedlistpointer dereference linkedlistpointer yields linkedlistrecord generic defined linkedlist specialized types must replaced corresponding view types cluster care required defining generics view types ensure operation produces result correct type otherwise generic compile correctly specialized general generic function f 1 abstract argument result types specialized concrete types 1 2 using views v 1 specialized function must signature f smith 68 uses term theory morphism similar notion dijkstra 15 uses term coordinate transformation similar notion variables replaced others gries 23 uses term coupling invariant predicate describes relation abstract types variables concrete counterparts maintained functions consider following generic gldefun genericcddr llinkedlist rest rest l genericcddr follows link linkedlist record twice rest link value 14 suppose concrete record two pointer fields two distinct linkedlist clusters made using two pointer fields specialize genericcddr rest must produce view type defines correct link rather concrete type fig abstractly illustrates type mappings used genericcddr example figure shows concrete types viewed abstract types views v suppose 14 rest cdr cddr lisp functions use lisp names linkedlist generics similar 1 2 3 f figure 10 cluster views type families composed function g 2 corresponding specialized functions f views virtual operations actually performed concrete data compiled code perform g however result function f seen compiler must function g defined abstract type 2 inherited undefined concrete type 2 roles cluster used within generics specify types related known view type view type pointer cluster clusters roles likewise point view types therefore possible find cluster view type find view type corresponding given role cluster glisp construct clustertype role code returns compile time type fills role cluster type code belongs construct used type specifier generic allowing use view type cluster example generics result type declared view type fills specified role cluster argument generic belongs clustertype also used declare local variable types create new data concrete type view thus type signatures types used within generics mapped abstract level view level specialization generics performed correctly 5 view cluster construction viewas view cluster may complex detailed knowledge generic procedures needed specify one correctly expect abstract types view clusters defined experts however simple programmers reuse generics viewas makes easy create view clusters without detailed understanding abstract types generics inputs name view cluster concrete types viewas determines correspondences abstract types cluster concrete types asking questions needed creates view cluster view types gldefviewspec sortedlinkedlist sortedsequence sll record anything type pointer record prop link partof record pointer result pointer prop copycontentsnames namesexcept record link prop sortvalue choosepropexcept record link prop sortdirection oneof ascending descending pointer pointer record record prop link copycontentsnames sortvalue figure 11 view specification used viewas fig 11 shows view specification sorted linked list record anything list formal parameters correspond types given call viewas argument record type matching anything next list names specifications matched concrete type following pattern output cluster instantiated substitution values determined first part finally list superclusters cluster created sll previous example viewas sortedlinkedlist myrec specifies name target cluster concrete type myrec matched viewas first matches record myrec argument processes matching specifications order 1 type pointer record first thing determined type pointer record pointer defaults standard pointer record different kind pointer array index used defined 2 prop link partof record pointer result pointer link must field record type pointer type filtering restricts possible matches one selected automatically 3 prop copycontentsnames namesexcept record link names fields record link names used generics copy contents record 4 prop sortvalue choosepropexcept record link sortvalue compared sorting chosen either fields computed method values defined record type excluding field link menu choices presented user 5 prop sortdirection oneof ascending descending must ascending descending user asked choose items matched concrete type results substituted pattern form view type cluster fig 6 shows cluster myrecassll view types myrecassllpointer myrecassllrecord produced viewas properties needed generics sortedlinkedlist sortvalue defined terms concrete type generics defined sortedlinkedlist explicitly test sortdirection since value constant code selected direction kept illustrates switch values view types select optional features generics weide 73 notes options reusable procedures essential avoid combinatoric set versions example booch component set 9 contains 500 components batory 5 identified combinations fewer design decisions linkedlist library 28 procedures one view cluster allows specialization viewas requires minimal input presents sensible choices user need understand abstract types detail effect view specifications use specialpurpose language guides type matching language necessarily complete sufficient variety view clusters specifications prevent type errors often allow choice made automatically case link field others eg copycontentsnames perform bookkeeping reduce user input specifications sortvalue heuristically eliminate choices additional restrictions might helpful eg sortvalue could require type ordering viewas powerful type matcher tends selfdocumenting eliminates opportunities errors effective minimal input assume user understands concrete type understands abstract types well enough make choices presented viewas intended views data structures companion program mkv 54 uses graphical interface algebraic manipulation equations make mathematical views also investigated creation programs connections diagrams represent physical mathematical models 51 6 higherorder code 61 compound structures abstract types may used larger structures example several kinds queue made linkedlist frontpointerqueue pointer front linked list twopointerqueue pointers front last record endpointerqueue pointer last record circularly linked list sequence queue turn used priorityqueue generics compound structures often small elegant example insertion priority queue gldefun priorityqueueinsert qpriorityqueue ninteger new insert index q n new code index q n indexes sequence priority n yield queue insert interpreted relative type queue small function expands larger code operations expand operations component structures expanded single definition generic covers combinatoric set component types 62 generic loop macros language abstract types must provide loops collections data alphard 66 clu 38 allow iterators concrete types interlisp 30 provided flexible looping construct lisp lists setl 14 provides sets maps compiles loops implementations chosen compiler 63 generic procedures need loops independent data structure eg array linked list tree done loop macros expansion generic procedures obeys strict hierarchy involves independent name spaces expanding loop however code specified loop statement must interspersed code iterator iterator must introduce new variables lexical level macros used reasons names used macro changed necessary avoid name conflicts glisp provides generic looping statement form item sequence pitem verb fitem statement compiled iterator macros defined verb type sequence expanded inline example consider gldefun t3 rmyrec x sortedlinkedlist r sum size x loop iterates sequence r using sortedlinkedlist view inheriting linkedlist iterator sums size element x linked list macros provided looping summation max min averaging statistics collection macros collect data specified form making possible convert one kind collection another eg array linked list data structures may several levels structure example symbol table might constructed using array buckets array indexed first character symbol array element pointer bucket ie sorted linked list symbols doubleiterator macro defined composes two iterators allowing loop compound structure gldefun t4 ssymboltable sym sum name sym t4 concatenates names symbols loop expands nested loops first array buckets linked list returns string since name string concatenates strings compiled code 23 lines lisp 63 copying representation change glisp compiler recursively expand code levels abstraction operations data reached interprets code relative types applied lisp funcall used call function determined runtime glisp funcall whose function argument constant compile time treated like function calls ie interpreted relative argument types makes possible write higherorder code implements compositions views contents linkedlist record may consist several items different types generic copylist makes new record copies contents fields requiring several assignments accomplished loop copycontentsnames defined view type name copycontentsnames funcall name destination record assigned value funcall name source record name copycontentsnames l funcall name implementation l funcall name implementation since list names constant loop unrolled funcall constant name interpreted field method reference result sequence assignments since function call side assignment statement interpreted relative type applied higherorder code transfer data different record type change representation transfer eg converting radius circle one representation area another representation converting data reflect different representations units measurement 53 example consider two different types cira cirb color lists circle superclass cira cons color symbol cons nxt cira radius supers circle cirb list diameter roman color next cirb prop radius diameter 2 supers circle types different records cira contains integer radius cirb contains diameter represented roman numerals viewing type linkedlist possible copy list either representation illustrates higherorder code expanded first loop unrolled two assignment statements transfer color diameter source record destination record diameter inherited circle source record encoded roman numerals destination record gldefun t5 ucira optional vcirb copylistto linkedlist u linkedlist v t5 red green blue nil 12 47 9 64 several views viewing concrete data conceptual entity may involve several views eg polygon represented sequence points viewing concrete type polygon requires view concrete type 1 sequence type 2 view 2 vector fig 12 view element concrete sequence vector specified declaratively giving name view view name used funcall inside polygon procedures acts type change function changes type sequence element view point effectively implements composition views single generic specialized variety polygon representations example string characters viewed polygon mapping character position keyboard string car contain character keyboard vector iterator iterator figure 12 polygon sequence vector 65 application languages lisp output system mechanically transformed languages including c c java pascal glisp allows target language record type accesses records compiled lisp code transformed target language syntax code also run within lisp create access simulated records allows interactive lisp environment programming datadisplay tools used rapid prototyping conversion lisp target language done stages patterns used transform idioms corresponding target idioms transform certain lisp constructs eg returning value statement constructs legal target language lisptolisp transformations applied repeatedly transformations apply second set patterns transforms code nicelyformatted target language syntax result may substantially restructured c procedure sllinsert1 shown fig 8 code readable dependence lisp versions generic procedures containing hundred lines code created c c java pascal c version convex hull program described runs 20 times faster lisp version 66 larger example convex hull convex hull set points smallest convex polygon encloses kant studied highly qualified human subjects wrote algorithms task subjects took considerable time failed produced inefficient solution although convex hull algorithms described textbooks 64 literature getting algorithm sources difficult necessary understand algorithm published description may omit details algorithm even contain errors 22 handcoded version published algorithm requires testing verification fig 13 illustrates execution generic convex hull algorithm describe algorithm figure 13 convex hull points illustrate use cities viewed points algorithm uses several views data reuses generics similar quickhull algorithms 57 convex hull represented circularly linked list vertex points clockwise order fig 14 edge formed vertex successor associated vertex list points may outside edge edge split fig 15 finding point farthest left edge point must convex hull edge split two edges original vertex new point new point end vertex splicing new point circularly linked list subsets points left new edge collected stored corresponding vertex points edges split algorithm initialized making points minimum maximum x values twopoint polygon input points associated edge edge split finally vertices collected noncircular linked list fig 13 shows successive splittings algorithm rapidly eliminates points consideration fig 16 shows type cluster used convex hull line formed point successor declared virtual linesegment 46 another way specifying view allows polygon treated simultaneously sequence vertices sequence edges vertices represented algorithm deals edges well internalrecord specifies circularlinkedlist property viewspecs causes viewas called automatically make circularlinkedlist view gamma au xy figure 14 convex hull circular linked list points phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi au figure 15 splitting edge procedure splicein iterator view used fig 17 shows generic procedure convexhull procedure initializes algorithm finding two starting points use iterators min max simplifies code next initial circularly linked list made linking together starting points function split called finally vertex points collected noncircular list fig shows generic cvhsplit uses iterator max signed leftofdistance linesegment point generic inherited since line associated vertex virtual linesegment leftofdistance expands inline code operates directly linked list vertex records think vertex successor linesegment without materializing one operator specifies push list collect points cvhsplit also uses procedure splicein circularlinkedlist view points split algorithm views data three different ways vertex point edge linesegment circularly linked list believe use several views common must supported reuse technologies programmer understand algorithm reuse concrete gldefclusterc convexhullcluster sourcepoint convexhullsourcepoint vector sourcecollection convexhullsourcecollection listof convexhullsourcepoint prop hull convexhull specialize internalrecord convexhullinternalrecord list pt convexhullsourcepoint next convexhullinternalrecord points listof convexhullsourcepoint prop line virtual linesegment msg split cvhsplit specialize viewspecs figure data might points per se might attributes find convex hull using traditional algorithm would require making new data set required form finding convex hull making version hull terms original data specialization generics efficient example consider finding convex hull set cities latitude longitude fig 19 shows city data structure handwritten view point using mercator projection viewas used make convex hull view cityaspoint data using view specialized version convex hull algorithm 229 lines lisp produced 5 seconds operates original data example illustrates benefits approach reuse generic procedures relatively small easy understand reuse generics reuse generic procedure application high payoff generated code much larger complex lines entered create views 67 testing verification users must confidence reused programs behave intended programmers apprentice 61 produced ada code user would read code modify necessary believe programmer read output reuse system system inline code expansion symbolic optimization make output code difficult read relate original code sources reading someone elses code difficult less someone else machine gldefun convexhull origpointslistof vector let xminpt xmaxpt hullp1 hullp2 lengthupto origpoints xminpt p origpoints min x p next hullp1 hullp2 link circularly next hullp2 hullp1 split hullp1 split hullp2 p circularlinkedlist hullp1 collect pt p figure 17 generic convex hull procedure believe reuse system reduce errors errors reusing software components might arise several sources 1 component might error 2 component might used improperly 3 specialization component might correct algorithms reused justify careful development tested many applications unnoticed errors unlikely humans introduce errors coding algorithms sedgewick notes quicksort fragile simple mistake implementation go unnoticed cause perform badly files reuse carefully developed generics likely produce better programs hand coding viewas mkv guide user presenting correct choices views written hand type checking usually catches errors although glisp strongly typed lisp ancestry many error checks catch nearly type errors experience system good reused generics new applications eg generic distance line point reused test whether mouse position close line ultimately must verified software meets specification also user really wants rapid prototyping based reuse developers gldefun cvhsplit cpcvhpoint let maxpt pts newcp pts points cp points cp nil pts null maxpt p pts p p1 line cp p p2 line cp leftofdistance line cp p maxpt leftof line cp maxpt newcp typeof cp splicein circularlinkedlist cp circularlinkedlist newcp p pts leftof line cp p points cp p else leftof line newcp p points newcp p split cp figure address programs performance practice make modifications easily system allows significant representation changes accomplished easily recompilation formal verification might applied specialized generics gries prins 21 suggest stratified proof program obtained transformation generic correct implementation abstract type correct transformed algorithm correct morgan 42 extends techniques proofs data refinements morris 43 provides calculational laws refinement programs written terms abstract types bags sets related methods might used proofs refinements system library proven lemmas generic components would greatly simplify task proving software system correct 7 views oop views used generate methods allow concrete data used oop software useful reuse oop software uses runtime messages interface diverse kinds objects glisp compiler automatically compile cache specialized versions methods based definitions given type example method compute area pizzaascircle generated automatically city list name symbol latitude units real degrees population integer longitude units real degrees views point cityaspoint cityaspoint z17 city prop x let radunits real radians rad longitude z17 signum latitude z17 log tan pi abs latitude z17 supers vector figure 19 city mercator projection implemented directmanipulation graphical editors linkedlist array display method editor record made interactively using program dispm allows selection properties displayed display methods used positions given display method record generic displaying editing structured data containing records used concrete data figure 20 shows data displayed generic linkedlist editor user move forward backward displayed list excise selected list element user also zoom element display detail edit contents technique allows single generic editor handle kinds linkedlist display omits detail contents link fields shows data easily understood form figure 20 linked list display 8 related work review closely related work always possible say equivalent program could written language x however system software reuse must satisfy several criteria simultaneously effective 34 claim system described satisfies criteria 1 wide applicability many kinds software expressed reusable generics 2 easy use amount user input learning required small 3 produces efficient code several languages 4 minimally constrains representation data generics specialized use existing data programs brooks 10 contends silver bullets software development system described silver bullet suggests significant improvement software development possible 81 software reuse krueger 34 excellent survey software reuse criteria practical effectiveness biggerstaff perlis 8 contains papers theory applications reuse artificial intelligence approaches described 1 39 60 mili 41 extensively surveys software reuse emphasizing technical challenges 82 software components programmers apprentice 61 based reuse cliches somewhat analogous generics project produced good ideas limited success kbemacs knowledgebased editor integrated emacs helped user transform cliche code unfortunately kbemacs rather slow user read understand lowlevel output code assume user treat outputs system black boxes need read modify code rich 59 describes plan calculus representing program data abstractions overlays relate program data plans analogous views weide 73 proposed software components industry based formally specified unchangeable components components would verified unchangeable errors would prevented however rigidity components might make harder reuse approach adapts components fit application zaremski wing 77 describe retrieval reusable ml components based signature matching functions modules related techniques could used generics batory 4 5 6 describes data structure precompiler construction software systems layers plugcompatible components standardized interfaces use layers whose interfaces carefully specified allows developer ensure layers interface correctly focused adapting interfaces generics reused independently designed data 83 languages generic procedures ada modula2 28 c 69 allow modules parameterized abstract types stacktype books generic procedures 37 44 contain procedures provided system ada modula2 collections limited value code easy write small part applications class template virtual function features c allow reuse generics however stroustrups examples 69 show declarations required complex subtle declarations also complex viewas hides complexity guides user creating correct views ideas viewas might adapted languages 84 functional set languages ml 74 55 like strongly typed lisp includes polymorphic functions eg functions operate lists arbitrary type functors functions map structures types functions structures ml also includes references pointers allow imperative programming ml functors instantiate generic modules container types system allows storing data structure view composition views 52 miranda 71 stronglytyped functional language higherorder functions allows generics often hard write functional programs good performance provides sets set operations 63 describes attempt automatically choose data structures setl improve efficiency kruchten et al 35 say slow beautiful emphasize ease constructing programs inefficient implementations make even small problems intractable transformation systems transformation systems repeatedly replace parts abstract algorithm specification code closer implementation executable code reached views specify transformations features abstract types implementations kant et al 33 describe sinapse generates programs simulate spatial differential equations eg seismic analysis sinapse transforms small specification much larger program fortran c written using mathematica 75 appears work well within domain setliffs elf system 65 automatically generates data structures algorithms wire routing integrated circuits printed circuit boards rules used select refinement transformations based characteristics routing task kids 68 transforms problem statements firstorder logic programs highly efficient certain combinatorial problems user must select transformations used must supply formal domain theory application system interesting powerful user must mathematically sophisticated gries prins 21 proposed use syntactic transformations specify implementation abstract algorithms volpano 72 gries 23 describe systems user specifies transformations variables expression patterns statement patterns performing substitutions algorithm different version algorithm obtained method allows user specify detailed transformations particular specialization algorithm whereas rely typebased transformations general optimization patterns ability specify individual transformations gries system gives flexibility possibly cost writing patterns intentional programming project microsoft 67 based intentions similar algorithm fragments expressed abstract syntax trees intentions transformed enzymes abstract syntax tree level parsed unparsed various surface syntaxes methods stored inherited intentions work progress results date impressive berlin weise 7 used partial evaluation improve efficiency scientific programs given certain features problem constant compiler performs many constant calculations possible compile time yielding specialized program runs faster system includes partial evaluation inlining symbolic optimization consel danvy 12 survey work partial evaluation 86 views goguen 18 proposes library interconnection language lil proposal much common approach goguen uses term view similarly lil stronger focus mathematical descriptions axioms obj language family goguen et al 19 views formal type mappings operators mapped strict isomorphisms tracz 70 describes lileanna implements lil construction ada packages views lileanna map types operations exceptions theories system views computational transformations types general procedures well operators reused garlan 17 kaiser 31 use views allow tools program development environment access common set data meld system combine features collections classes methods allow additive construction system selected features meyers 40 discusses problems consistency among program development tools surveys approaches including use files databases views developed garlan hailpern ossher 25 describe views subsets methods class restrict certain methods particular clients harrison ossher 26 argue oop restrictive applications need views objects propose subjects analogous class hierarchies 87 data translation idl interface description language 36 translates representations possibly structure sharing exchange data parts compiler based precise data specifications herlihy liskov 27 describe transmission data network representation translation shared structure user writes procedures encode decode data transmission common object request broker architecture corba 13 includes interface definition language automatically generate stubs allow interoperability objects across distributed systems across languages machine architectures arpa knowledgesharing project 45 addresses problem sharing knowledge bases developed using different ontologies purtilo atlee 58 describe system translates calling sequences producing small interface modules reorder translate parameters necessary called procedure rerepresentation data allows reuse existing procedure requires space execution time although 36 found small cost compiler 49 paper describe methods data translation handle shared structure guttag horning 24 describe formal language specifying procedure interface signatures properties yellin strom 76 describe semiautomatic synthesis protocol converters allow interfacing clients servers 88 objectoriented programming described views used generate methods oop oop messages interpreted converted procedure calls depending type receiving object methods inherited superclasses close connection class requires user understand great deal class methods many oop systems class must include data superclasses reuse oop restricts implementation data names data messages must consistent must conflict holland 29 uses contracts specify data behavioral obligations composed objects contracts somewhat like clusters require specializations include certain instance data implement data way generics specialized separate contract lens construct used disambiguate names conflicts views provide encapsulation prevents name conflicts views allow reuse benefits oop flexibility implementing data oop systems inefficient since methods small message interpretation overhead large especially layered systems c 69 restricted oop efficient method dispatching opacity objects prevents optimization across message boundaries unless messages compiled inline c allows inline compilation reuse oop may require creating new object reuse method class views allow object thought another type without materialize type 9 conclusions approach based reuse programming knowledge generic procedures abstract types view descriptions envision library abstract types generics developed experts could adapted quickly applications programmers ordinary skill able reuse generics viewas facilitates making views easily used interfaces opposed verbose textual specifications precise syntax essential successful reuse systems like viewas might reduce complexity specifications required languages views also support data translation runtime message interpretation single directmanipulation editor handle implementations abstract type techniques provide high payoff generated code relative size complexity input specifications require modest understanding details library procedures successful reuse techniques allow restructuring data meet new requirements improve efficiency traditional languages reflect data implementation code 3 making changes costly system derives code data definitions design decisions stated single place distributed compilation rather hand coding ability produce code different languages decouples choice programming tools choice application language allows new tools extend old systems write parts system without committing use tool everything computation become commodity user longer cares kind cpu chip inside box may look forward time todays highlevel languages become implementation details acknowledgements computer equipment used research furnished hewlett packard ibm thank david gries hamilton richards ben kuipers anonymous reviewers suggestions improving paper r ieee trans functors categorical imperative 15 year perspective automatic programming design implementation hierarchical software systems reusable components scalable software libraries reengineering complex application using scalable data structure compiler compiling scientific code using partial eval uation software reusability 2 vols software components ada silver bullet essence accidents software engineering introduction data types tutorial notes partial evaluation common object request broker architecture specification programming language discipline programming design patterns elements reusable objectoriented software views tools integrated environments reusing interconnecting software components principles parameterized programming denotational description programming languages new notion encapsulation transform new language construct introduction lcl larchc interface language extending objects support multiple interfaces access control subjectoriented programming critique pure objects value transmission method abstract data types data abstraction program development using modula2 specifying reusable components using contracts xerox palo alto research center synthesizing programming environments reusable features understanding automating algorithm design scientific programming automated synthesis software reuse software prototyping using setl language idl sharing intermediate representations modula2 software component library automating software design difficulties integrating multiview development systems reusing software issues research directions data refinement miracles laws data refinement ada generic library enabling technology knowledge sharing glisp lispbased programming system data abstraction data abstraction glisp negotiated interfaces software reuse software reuse view type clusters generating programs connections physical models composing reusable software components views conversion units measurement creation views reuse software different data representations ml working programmer introduction discrete structures computational geometry module reuse interface adaptation formal representation plans programmers apprentice readings artificial intelligence software engineering programmers apprentice mathematical theory global program optimization automatic technique selection data representations setl programs automatic selection data structures algorithms abstraction verification alphard defining specifying iterators generators intentional programming innovation legacy age kids semiautomatic program development system lileanna parameterized programming language overview miranda templates approach software reuse reusable software components mathematica system mathematics computer interfaces protocols semiautomatic construction software adaptors signature matching key reuse tr ctr heinz pozewaunig dominik raunerreithmayer support semantics recovery code scavenging using repository classification proceedings 1999 symposium software reusability p6572 may 2123 1999 los angeles california united states hai zhuge componentbased workflow systems development decision support systems v35 n4 p517536 july sanjay bhansali tim j hoar automated software synthesis application mechanical cad ieee transactions software engineering v24 n10 p848862 october 1998 batory gang chen eric robertson tao wang design wizards visual programming environments genvoca generators ieee transactions software engineering v26 n5 p441452 may 2000 fabio casati silvana castano mariagrazia fugini isabelle mirbel barbara pernici using patterns design rules workflows ieee transactions software engineering v26 n8 p760785 august 2000 richard w selby enabling reusebased software development largescale systems ieee transactions software engineering v31 n6 p495510 june 2005
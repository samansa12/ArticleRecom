redundant synchronization elimination doacross loops abstractcrossiterations data dependences doacross loops require explicit data synchronizations enforce however composite effect data synchronizations may cover dependences make enforcement covered dependences redundant paper propose efficient general algorithm identify redundant synchronizations multiply nested doacross loops may multiple statements loopexit control branches eliminating redundant sychronizations doacross loops allows efficient execution loops also address issues enforcing data synchronizations iterations near boundary iteration space dependences may exist boundary iterations adds complexity determining redundant synchronizations boundary iterations necessary sufficient condition synchronization uniformly redundant also studied results allow parallelizing compiler generate efficient data synchronization instructions doacross loops b introduction concurrent execution loops crossiteration data dependences termed doacross loops allows us exploit looplevel parallelism beyond vector loops doall loops application programs machine size becoming larger exploitingmore parallelism programbecomes important however efficient data synchronization required support execution model commercially available multiprocessors alliant fx series already provide architectural hardware support executing doacross loops efficiently many crossiteration data dependences doacross loops data dependences needs enforced explicit synchronization order satisfy original memory access order program however many synchronizations redundant transitive nature data dependences statements eliminating redundant data synchronization several advantages first fewer data synchronizations allows us use system resources synchronization registers alliant machines effectively second data synchronization usually requires long communication delays processors fewer synchronizations cause fewer processor stalls third fewer data synchronizations mean fewer synchronization instructions need generated make code size smaller paper propose efficient algorithm identify redundant synchronizations multiplynested doacross loops often multiple statements loop body also address nonuniformity redundancy boundary iterations multidimensional iteration space caused possible backward dependence directions inner loop levels nonuniformity redundancy make enforcement data dependences complicated necessary sufficient condition identify redundant synchronization nonuniformity problem also presented paper presentation organized follows sections 2 3 describe algorithms starting single loop following multiple loop cases discussions summary previous research area given section 4 section 5 concludes presentation tree edge forward edge seodfs search tree b control path graph cpg c iteration space dependence graph isdg i1100 end single loop figure 1 simple loop example redundant synchronization elimination 21 loops straight control flow first look simple case singlynested loop branches loop body figure 1a identify redundant synchronizations among statements different iterations build control path graph cpg cpg loop twodimensional graph column represents iteration nodes column statements iteration assume iteration doacross loop executed sequentially one processor control flow edge one statement immediate successor iteration represented broken edges figure 1b solid edges represent loopcarried crossiteration data dependences number rows determined number statements one iteration number columns longest distance data dependences loop figure 1a loopcarry data dependences distances 1 2 figure 1b shows corresponding cpg shaded area three columns 2 8 shows identify redundant data dependences single loop need examine 4 krothapalli uses sequential execution order depth first search seodfs algorithm iteration space dependence graph isdg entire loop body iteration represented single node isdg edge exists two nodes loopcarried dependence two iterations isdg simple loop obtained collapsing nodes column cpg figure 1b one big node figure 1c important note every iteration figure 1b figure 1c incoming edges outgoing edges except first last iterations incoming outgoing edges missing nonexisting dependence sources one important characteristic isdg acyclic otherwise iteration would executed another iteration seodfs differs normal depthfirst search dfs successors depth level examined according sequential execution order loop edge marked one following see figure 1d ffl tree edge searching path seodfs ffl forward edge already path formed tree edges tail node head node ffl cross edge neither tree edge forward edge goal seodfs find forward edges first iteration isdg starts search node representing first iteration forward edge represents transitive edge corresponds redundant synchronization definition path formed tree edges tail ie dependence source head ie dependence sink let us see extend seodfs cpg cpg also acyclic similar isdg observations 1 node cpg successor column always searched successors 2 important note columns ie iterations dependence pattern need identify forward edges nodes first column 3 cross edge nodes first column algorithm performing dfs cpg shown figure 2 first observation know node reached nodes column must traversed node columns traversed procedure performs dfs marks redundant dependences procedure invoked calling check00 due depthfirst nature procedure process checking forward edges actually performed starting last statement iteration markiter marker iteration mark progress checking iteration initialized n total number statements loop body procedure check iter start begin mark iter start statement n downto statement start begin dependences source sequential execution order begin sink iter iter dist sink iter dmax nothing range else mark sink iter sink sink visited iter 0 check dependences iter 0 mark dependence redundant else check sink iter sink sink first reached recursive examination end end procedure check figure 2 dfs algorithm cpg column use marker record statement traversed column markers initialized last statement column edge whose head statement lexically later marked statement column edge forward edge according dfs algorithm figure 2 head statement must visited hence must alternative path tail statement head statement edge mark edge forward edge corresponds redundant synchronization every edge traversed time complexity algorithm 2 n number nodes cpg storage used proportional sum number dependences number columns cpg checking redundant synchronizations started check0 0 22 loops multiple control flows section show general algorithm handles control branches loop however assume exitloop branches loop statements abort loop execution discussed section 4 branches one control flow path iteration examine every possible control flow path make sure synchronization really redundant paths 8 author showed examining cpgs possible control flow combinations windows dmax iterations necessary sufficient determining redundant synchronization single loop algorithm based approach also incorporates dfs algorithm previous section make checking case easier need identify possible paths one iteration record path pathij jth statement path another array ipath acts inverse function path ipathpathijij sequence number statement path given ipathsi finally iter pathi gives control flow path assumed iteration current cpg total pcount1 possible control flow paths one iteration value iter path range 0 pcount also assume backward jump loop possible control flow paths found variation depthfirst traversal figure 3 shows general algorithm algorithm starts cond check0 examination finished synchronization dependence redundant countm zero 3 doublynested loop redundant synchronization elimination section extend single loop algorithm multiplynested loops single loop one dimension iteration space data dependences must point forward therefore source sink dependence fall within iteration space iterations source sink iterations within iteration space multiplynested loop dependences negative direction nesting levels outmost level synchronization dependence redundant middle iteration space may redundant boundary iterations necessary intermediate iterations may outside iteration space causes redundant synchronization checking different nonuniform boundary iterations iteration space 4 shown doublynested loop inner loop least pmax anmin 1 iterations pmax positive distance anmin absolute value negative distance inner loop redundancy checking uniform redundant synchronization found covered iterations however pointed 11 true loop body single statement synchronization done iteration level instead statement level cpg alternative path cover redundant synchronization consider lexical order statements isdg statements iteration grouped together procedure check iter start begin u ipath n iter path iter get sequence number last statement n ipath start iter path iter get sequence number statement start mark iter start n u downto v begin path iter path iter n current statement examination dependences source sequential execution order begin sink iter iter dist sink iter dmax nothing range else sink cpg nothing else mark sink iter sink sink covered iter 0 examine dependences iteration 0 count redundant cpg else check sink iter sink sink first reached recursive examination end procedure check procedure cond check iter begin try possible flow paths iteration p iter path iter p last iter call recursively iter dmax cond check iter 1 else begin last iter perform redundancy check markers bottom dependences nodes first iteration begin record dependences need checked source sink dependence control flow path examined count gammagamma check 00 start checking end procedure cond check figure 3 dfs algorithm loops branches therefore alternative path isdg imply alternative path corresponding cpg restricted algorithm loops multiple statements proposed 11 find subset redundant synchronizations guaranteed redundant throughout entire iteration space unfortunately algorithm could also miss many synchronizations redundant throughout iteration space section propose new scheme identify uniformly redundant synchronizations multiplynested loop multiple statements iteration scheme based necessary sufficient condition determines synchronization uniformly redundant use doublynested loop illustration however easily extended multiplynested loops without loss generality also assume dependence distances loop levels positive goal determine large area iteration space use generate cpg dfs algorithm show dependence distance vector space iteration space node point iteration cpg dfs algorithm presented figure 3 used identifying redundant synchronization dfs algorithm works cpg handle loops multiple statements synchronization done statement level instead iteration level 31 dependence slope synchronization chain first given data dependence determine areas need checked uniform redundancy synchronization dependence source sink j iteration space dependence distance vector definition 2 dependence slope dependence distance vector defined possible dependence slopes interval gamma1 1 first component valid dependence distance vector positive zero must valid loop execution order zero j second component positive integer zero hence slope gamma1 possible region 1 region 2 region 3 region 4 outer loop index inner loop index j 1 2 ebmb yaxis xaxis xa figure 4 2d dependence distance vector space gammam theta figure 5 line equations figure 4 shows dependence represented dependence distance vector 2d dependence vector space let denote set dependence distance vectors loop gammam maximal minimal value dependence slopes four lines 1 2 3 4 figure 4 defined equations figure 5 four intersections points o0 form parallelogram also four regions figure 4 specified figure 6 regions well defined 6 1 regions 1 4 empty sets easy see union four regions parallelogram adco always include points lines checking redundant synchronization doublynested loop areas left right x region 2 x region 3 region 4 x figure defnitions regions figure 4 ignored synchronization chain dependence distance vector space path p consists ordered set points fp ng space segment dependence vector lemma 1 figure 4 exists synchronization chain point point g region 1 region 1 empty lemma true otherwise 6 1 suppose synchronization chain p g region 1 let maximum dependence slope segment p b b contradicts fact g region 1 hence synchronization chain point g region 1 figure 4 2 lemma 2 figure 4 exists synchronization chain point g region 2 point proof observation 1 gammam 6 gamma1 suppose synchronization chain p g region 2 let ng since gammam minimum dependence slope segment p b b contradicts fact g region 2 b hence synchronization chain point g region 2 2 similar lemmas proved regions 3 4 theorem 1 shows parallelogram adco need examine find redundant synchronizations theorem 1 synchronization chain p contains points region 1 2 3 4 proof exists synchronization chain p containing g region 1 subpath g synchronization chain end point g region 1 contradicts result lemma 1 therefore synchronization chain p contains points region 1 similar results regions 2 3 4 proved lemmas 1 2 2 32 boundary problem redundant synchronization elimination previous section see exists alternative path must follow synchronization chain contained entirely parallelogram adco use conclusion examine every iteration iteration space eg figure 7a origin correspond iteration examining see figure 7b however sufficient examine adco order determine instances redundant example origin figure 4 corresponds iteration bottom iteration space figure 7c synchronization chain containing intermediate points region fco would invalid cover intermediate points iteration space loop xaxis executed mainly caused negative values second component corresponds inner loop dependence distance vectors section show sufficient condition followed necessary sufficient condition determine iteration space large enough contain alternative path synchronization chain particular dependence sufficient condition easier understand calculate necessary sufficient condition gives precise redundancy information assume rectangular 2d iteration space shown figure 7a results following lemma useful later theorems lemma 3 following relations true figure 4 h gamma b outer loop index inner loop index top middle bottom iteration space b redundant synchronization c nonredundant synchronization figure 7 2d iteration space h 0 proof value h h 0 theta obtained combining equations line 1 3 2 4 respectively figure 5 additionally 1 theta gamma b 0 therefore mm 0theorem 2 dependence distance vector da b 0 b 0 alternative path trapezoid adfo synchronization unnecessary source iteration middle bottom section iteration space figure 7a proof source instance middle bottom section iteration space figure 7a align origin figure 4 source iteration two possible cases arise sink iteration iteration space synchronization needed otherwise show trapezoid adfo entirely iteration space since h rows iteration top section h also rectangular iteration space finally since gamma b f also rectangular iteration space adfo trapezoid four corners inside rectangular iteration space entire trapezoid adfo iteration space since alternative path adfo conclude synchronization dependence unnecessary 2 theorem 3 dependence distance vector da b 0 b 0 alternative path trapezoid oedc synchronization unnecessary source iteration top middle section iteration space figure 7a proof source instance top middle section iteration space figure 7a align origin figure 4 source iteration two possible cases arise sink iteration iteration space synchronization needed otherwise show trapezoid oedc entirely iteration space since h 0 rows iterations bottom section h 0 c also rectangular iteration space finally since b e also rectangular iteration space oedc trapezoid four corners inside rectangular iteration space entire trapezoid oedc iteration space since alternative path oedc conclude synchronization dependence unnecessarytheorem 4 rectangular iteration space eg figure 7a least hh 0 rows dependence alternative paths trapezoids adfo oedc respectively synchronization redundant iterations including boundary iterations iteration space proof rectangular iteration space least h top bottom sections probably nonempty middle section figure 7a theorem 2 synchronization redundant middle bottom sections theorem 3 synchronization redundant top middle sections therefore synchronization redundant iterations 2 theorem 4 gives sufficient condition synchronization redundant large enough iteration space besides h h 0 easily determined equations 5 6 dimensions iteration space known compile time redundancy synchronizations determined compiler hand dimensions iteration space depend program input may generate multiple versions loop simple test placed loop dynamically determine version execute take advantage eliminating redundant synchronizations although precise information redundant synchronization determined applying dfs algorithm section 2 entire iteration space certainly quite time consuming impractical based results derived far actually find necessary sufficient condition synchronization redundant iteration space condition specified threshold height iteration space called critical height describe calculate critical height lemma 4 figure 4 alternative path rectangle corners 0 0 0 k k 0 k positive integer alternative path rectangle corners 0 0 0 proof easy see second rectangle enclosed entirely first rectangle therefore alternative path smaller rectangle must alternative path larger rectangle 2 basic idea finding critical height find trapezoid adfo smallest integer value k specifies rectangle containing alternative path similarly k 0 determined trapezoid oedc except rectangle grow downwards two corners fixed 0 b b based result lemma 4 search k k 0 done efficiently binary search interval b h 0 h 0 k found searched interval specifying rectangle alternative path redundant matter large iteration space critical height equals 1 otherwise critical height k theorem 5 doublynested loop synchronization dependence redundant iteration space height larger critical height proof first prove part iteration space height larger k use partition scheme similar figure 7a h h 0 replaced k k 0 respectively synchronization redundant top middle sections bottom section provides necessary room contain alternative path source iteration lowest row middle section similarly synchronization redundant middle bottom sections top section provides necessary room contain alternative path source iteration highest row middle section therefore synchronization redundant iterations prove part suppose contrary height iteration space less critical height critical height 1 synchronization redundant otherwise let height k r positive integer let rows beneath jth row definition k 0 rows large enough contain alternative path source iteration jth row similarly since k rows jth row definition k rows large enough contain alternative path source iteration jth row therefore synchronization source iteration jth row redundant implies synchronization redundant iterations 2 implementation issues h h 0 small theorem 4 satisfied loops used better efficiency two trapezoids adfo oedc figure 4 need examination integer loop bounds easy determine instead use rectangle corners 0 0 0 dhe dhe 0 adfo oedc use rectangle corners 0 b b bgammah 0 c 0 bgammah 0 c two rectangles actually similar size shown b dependence distance vector da b number iterations need examined approximately 2 theta theta theta theta b theta theta theta theta theta theta theta many dependences check trade precision efficiency calculating largest rectangle dependences check every dependence rectangle instead rectangles results one pair h h 0 set dependences thus obtained redundant iterations iteration space height larger h also simple optimizations done checking iteration space large enough contain source sink dependence synchronization needed exitloop control branches exitloop control branch loop implies execution later iterations depend branch context redundant synchronization elimination since assume statements iteration executed sequentially add dependence source conditional statement branch sink first statement next iteration use algorithm described section 2 higher dimension iteration spaces used doublynested loop example extend results section 3 ngammadimensional iteration space simply modify definition 2 define dependence slope dimension calculate maximum minimum slopes dimension ngammadimension region corresponding parallelogram adco figure 4 thus found higher dimensional version sufficient condition similar specified theorem 4 exception different hh 0 dimension obtain critical height necessary sufficient condition theorem 5 dimension also straightforward need examine n different dimensions one one search critical height critical heights found later dimensions also guarantee existence alternative path one order examination critical backtracking necessary previous works redundant synchronization elimination problem first described li abusufah 7 6 using dominant locks lock specifies dependence relation lock dominates another lock enforcing first lock ensures second lock preserved three conditions identifying dominant locks provided cover limited cases midkiff padua 10 9 described schemes generate synchronization instructions compiler using test testset similar await advance instructions used alliant minisupercomputers 1 also introduced control path graph cpg show ordering imposed synchronization control dependences mimd machine eliminate redundant synchronizations used transitive closure method check given synchronization whether transitive closure remaining synchronizations cover arcs previously determined redundant checked time complexity algorithm odn 3 number statements cpg number dependences bounded n 2 complexity also shown 5 single loop showed columns cpg needed dmax largest dependence distance shaffer 12 showed algorithm find transitive synchronization arcs tasks synchronization transitive successors synchronization source least one path sink algorithm time complexity 3 n number nodes task graph work done callahan et al 2 used data flow analysis algebraic formulations determine whether dependence properly covered synchronizations synchronization primitives used postwait handle general program constructs limited parallel loops hence time complexity potentially higher efficient algorithm finding redundant synchronization doacross loops uniform dependences proposed krothapalli sadayappan 4 5 works either single statement loops synchronization iteration level instead statement level dependences uniform iteration dependences first iteration need verified used variation depthfirst search dfs determine transitive synchronization arcs scheme extended multiplynested loops provided iteration space large enough dependences uniform even iterations boundaries given graph n nodes e edges depthfirst search algorithm time complexity oe equivalently 2 approach efficient finding redundant synchronizations iterations however synchronization iteration level often satisfactory parallelism provided overlapping loop iterations doacross loop execution lost recently scheme proposed midkiff padua 11 equivalent examining rectangle corner 0 0 0 b b 0 figure 4 alternative path dependence alternative path dependence rectangle must parallelogram oedf intersection two trapezoid adfo oedc satisfies theorems 2 3 synchronization redundant iterations case k exactly minimal size source sink iteration space uniform redundant synchronizationsthus found subset uniformredundant synchronizations foundusing scheme described previous section number iterations needed examined rectangle theta b theta 2 5 conclusion paper described algorithm detect redundant synchronization efficiently multiplynested loops multiple statements could also branches loop multiple control flows solve boundary problem multiplynested loops used doublynested loop example derived necessary sufficient condition synchronization redundant entire iteration space scheme significant improvement previous schemes sense efficiently identify redundant synchronization previous schemes either unable inefficient find results presented paper important parallelizing compiler generate efficient code doacross loops r alliant computer system corp analysis event synchronization parallel programming tool removal redundant dependences doacross loops constant dependences removal redundant dependences doacross loops constant dependences reducing data synchronization multiprocessed loops technique reducing synchronization overhead large scale multiprocessors automatic generation synchronization instructions parallel processors compiler algorithms synchronization compiler generated synchronization loops comparison four synchronization optimization techniques minimization interprocessor synchronization multiprocessors shared private memory tr ctr antonia zhai christopher b colohan j gregory steffan todd c mowry compiler optimization memoryresident value communication speculative threads proceedings international symposium code generation optimization feedbackdirected runtime optimization p39 march 2024 2004 palo alto california michiel ronsse koen de bosschere nonintrusive detection synchronization errors using execution replay automated software engineering v9 n1 p95121 january 2002 chengzhong xu vipin chaudhary time stamp algorithms runtime parallelization doacross loops dynamic dependences ieee transactions parallel distributed systems v12 n5 p433450 may 2001 long li bo huang jinquan dai luddy harrison automatic multithreading multiprocessing c programs ixp proceedings tenth acm sigplan symposium principles practice parallel programming june 1517 2005 chicago il usa
onthefly model checking fairness exploits symmetry onthefly algorithm model checking fairness presented algorithm utilizes symmetry program reduce state space employs novel techniques make onthefly model checking feasible algorithm uses state symmetry eliminates parallel edges reachability graph experimental results demonstrating dramatic reductions running time memory usage presented b introduction state explosion problem one major bottlenecks temporal logic model checking many techniques proposed literature 6 5 9 8 13 11 12 16 17 combating problem among symmetry based techniques proposed 5 9 13 methods state space program collapsed identifying states equivalent symmetry model checking performed reduced graph although initial methods 5 9 could handle limited set liveness properties generalized approach checking liveness properties various notions fairness proposed 10 method however facilitate early termination supplies answer construction required data structures complete many traditional model checking algorithms 3 11 12 17 use onthefly techniques avoid storing complete state space main memory however none techniques employ symmetry 13 uses onthefly techniques together symmetry model checking focus reasoning simple basic type correctness ie safety properties expressible temporal logic ctl assertion form agerror paper present onthefly model checking algorithm checks correctness weak fairness exploits symmetry computation said preliminary version paper appeared proceedings 9th international conference computer aided verification held haifa israel june 1997 work presented paper partially supported nsf grants ccr9623229 ccr9633536 weakly fair every process either infinitely often disabled executed infinitely often work extension work presented 10 develop additional theory leading novel techniques make onthe fly modelchecking feasible exploit symmetry different states also take advantage symmetric structure individual state allows us reduce size explored state space major improvement gained breaking sequential line algorithm original algorithm constructed three data structures reduced state space product graph threaded graph details given one performed test last one eliminated construction third data structure maintaining new dynamic information algorithm constructs parts first structure needed construction second finally store nodes second structure onthefly construction technique uptodate dynamic information maintenance facilitates early termination program satisfy correctness specification allows us construct minimal necessary portion state space program satisfies correctness specification onthefly model checking algorithm implemented experimental results indicate substantial improvement performance compared original method algorithm given 10 works follows assumes system consists set processes communicate shared variables variable associated subset called index set denotes set processes share variable clearly index set local variable consists single process state system mapping associates appropriate values variables permutation set processes extends naturally permutation set variables states system permutation automorphism system reachability graph system invariant specifically edge reachability graph also edge vice versa two states equivalent automorphism system maps one factoring equivalence relation compresses reachable state space original method consists three phases first constructs reduced state space computes product reduced state space finite state automaton represents set incorrect computations explores product graph checking existence fair final strongly connected components components correspond fair incorrect computations checking strongly connected component fair boils checking fair respect individual process done taking product component index set result called threaded graph resolution component path threaded graph corresponds computation system special attention one designated process fairness strongly connected component product graph checked verifying strongly connected components threaded graph fair respect designated process component onthefly algorithm two layers reduced state space product graph construction successors node reduced state space constructed product graph construction requests product graph construction engined modified algorithm computing strongly connected components scc using depth first search see 2 depth first search vertex stack maintains partition vector process set partition vector associated product state u captures information threaded graph strongly connected component u already explored part product graph intuitively processes j partition class indicates nodes u u scc threaded graph reveals infinite run system corresponding strongly connected component u already explored part product graph either fair respect processes j fair respect mentioned processes partition vectors updated whenever new node edge already constructed node explored correctness algorithm based new theory develop part paper thoery connects partition vectors algorithm strongly connected components threaded graph permutation 2 autm processes state symmetry state state symmetry originally introduced 9 suppose maps process j case transitions ignited process onetoone correspondence caused process j hence save space computation time considering belong process one forms state symmetry exploited algorithm another way initialization partition vector state symmetry partition maps process j threads corresponding process j certainly situation either fair none fair paper organized follows section 2 contains notation preliminaries sect 3 develop necessary theory present onthefly algorithm describe various modifications algorithm take state symmetry consideration section 4 presents experimental results showing effectiveness algorithm dramatic improvements time well memory usage section 5 contains concluding remarks 2 preliminaries 21 programs processes global state graph let set process indices consider system running parallel process k set transitions assume variables p indexed subset indicating processes share variable system p meets description called indexed transition system briefly program global state indexed transition system assignment values variables assume variable take finite number values assumption ensures number global states system also finite define indexed graph set global states captures behavior program indexed global state graph set global states 0 initial state r theta theta transition relation ie transition process enabled state execution leads state 22 strongly connected subgraphs weak fairness infinite paths starting initial state denote computations p infinite path p weakly fair process either disabled infinitely often p executed infinitely often p unless otherwise stated consider weak fairness throughout paper implementation however capable handling strong fairness infinite execution program strongly fair every process enabled infinitely often executed infinitely often strongly connected subgraph graph set nodes path every pair nodes passing nodes subgraph strongly connected component scc short maximal strongly connected subgraph set states appear infinitely often infinite computation finite state program p forms strongly connected subgraph many properties infinite computations fairness onetoone correspondence properties associated strongly connected components therefore efforts directed towards finding scc certain properties formulate weak fairness condition sccs definition 1 scc c weakly fair every process either disabled state c executed c process disabled state transitions disabled process executed c states c given program p interested checking absence fair incorrect computations assume incorrectness specified buchi automaton set computations accepted exactly set incorrect computations problem checking whether program p incorrect weakly fair computation decided looking product graph b 0 b 0 scc whose projection contains final automaton state whose projection weakly fair p weakly fair incorrect computation sufficient construct product reachable part 23 annotated quotient structure previously suggested method ie analyzing reachable part expensive since many systems reachable part huge systems exhibit high degree symmetry state space reduced identifying states equivalent symmetry constructing quotient structure given denote set permutations sym let 2 sym induces action set variables set global states following way every variable v image v course may variable program say respects set variables image every variable variable program assume property image global state defined global state satisfies value value v every variable v program say automorphism indexed global state graph respects exactly r set automorphisms denoted autm certainly autm subgroup sym given subgroup g autm define equivalence relation state equivalent 2 g using g compressed smaller structure called annotated quotient structure aqs follows ffl set representative states contains exactly one state equivalence class sg particular contains 0 0 class ffl r set triples gamma denoting edges representative states annotated permutations g process indices define r formally state 2 define rep unique representative state equivalence class also associate canonical permutation 2 g rg remark many cases useful allow multiple initial states capture nondeterminism program 10 defined set 0 initial states required every automorphism concept multiple initial state simulated system introducing new fully symmetric initial state 0 every 2 0 2 edge 0 24 checking fairness threaded graph briefly outline approach taken 10 checking given concurrent program p exhibits fair computation accepted automaton assume automaton refers variables whose index set involve processes specifies property executions processes processes called global tracked processes traverse compressed global tracked processes represented different sets state path formally local tracked processes state passing path p product permutations found edges p example first edge path 0 gamma since representative real successor state global tracked processes represented processes steps path may return state time encounter different set local tracked processes property makes feasible model checking purposes compact need less compressed version set local tracked processes given state depend path lead initial state need unwind partially threaded graph construction captures unwinding graph whose edges labeled permutations set possibly marks kthreaded graph h kthr corresponding h hv theta k consists edges form gamma k note h labels edges denoted previous line permutations h kthr inherits 1threaded graph corresponding h denoted h thr second component state h thr called designated process following simple example depicts concepts throughout paper id denotes identity permutation ij transposition interchanges j graph h graph h thr edge labels indicated 6 r gammapsi figure 1 threaded graph construction original algorithm first constructs annotated quotient structure corresponding p second step product graph theta constructed state product graph form edge b 0 gamma edge kthr automaton transition state 0 input consisting program state obtained simultaneously replacing index c l l l 2 k third step product graph b 0 checked existence fair strongly connected components called subtly fair sccs 10 checking done constructing threaded graph resolution every scc b 0 every scc threaded graph checked fair respect designated process sect 3 show using techniques based new deeper theoretical results method considerably enhanced oeae iii rii rrr oeae oe id 1idgamma gammapsi cri gammapsi crrid6 gammapsi figure 2 aqs simplified resource controller startingstate a0 finalstate true oe state1 c oeae ae oe true figure 3 automata 25 simplified resource controller example illuminate general concepts present instructive example simplified resource controller program consists server 3 client processes running parallel client either idle request r critical c state variable statec indicates status client c 3 clients freely move idle request state server may grant resource client moving critical state provided client request state client critical state yet simple example 20 states combinations values r c except contain one c contrast 7 states illustrated fig 2 initial state one marked iii lower left side figure three process idle state move request state r hence three successors state space rii iri iir states equivalent chose rii representative three edges departing iii correspond three enabled transitions edge iii 01 1 gamma rii example indicates process 1 enabled transition execution transition leads state gamma1 similarly state rri represents 3 states rir irr suppose want check obviously false property client 1 never gets critical state negation property captured automaton given figure 3 automaton states client 1 eventually gets critical state global tracked process 1 product graph b 0 states depth first search b 0 reveals strongly connected subgraph weakly fair contains final automaton state 3 utilizing state symmetry original algorithm briefly described subsection 24 constructed b together threaded graph b thr 0 method improved applying following three new ideas constructing kthr goal define less compressed version property visit state multiple times infinite path encounter set local tracked processes sense link set local tracked processes state kthreaded graph unwinding optimal solution define equivalence relation theta k usually results greater compression theta k still desired property smaller kthr cases program exhibits symmetry possible two states equivalent represented single state theta k second improvement application onthefly algorithm incrementally construct b simultaneously explore exploration analyze threaded graphs without constructing partially explored b contains required subgraph algorithm immediately exits saving computation time onthefly nature algorithm need store complete b specifically edges need stored finally third idea use symmetry single global state using state symmetry reduce number edges eliminating redundant parallel ones redundant parallel edges removed also results reduction memory usage keeping presentation simple assume tracking one process loose generality results presented apply obvious modifications case many tracked pro cesses actual implementation algorithm given used general case 31 compressing theta subsect 23 defined equivalence relation extend theta follows say equivalent permutation 2 g obviously equivalence relation partitions set theta set equivalence classes let aqsi set representative states contains exactly one state equivalence class ensure aqsi closely related adopt convention 2 aqsi implies 2 aqsi theta containment may strict possible two states form j equivalent annotated quotient structure tracked index aqsi gamma ig state local tracked process note indicated initial state 0 formaly element set states aqsi specific tracked process assigned seemingly unnatural definition adopted want encorporate information automaton definition theta theta considerably smaller thr best case may achieve reduction number nodes number edges factor n n 2 respectively n size simplified resource controller example thr 7 states calculate size aqsi note first state iii 3 processes local state hence iii 0 iii 1 iii 2 equivalent theta one needs included aqsi similarly one rrr 0 rrr 1 rrr 2 aqsi rii rri crr iic two 0 1 2 equivalent hence two need stored aqsi finally case cri processes different local state therefore 0 1 2 aqsi counting shows aqsi contains 13 representative states let b product theta formally 0 property 0 0 representative recall 0 process tracked automaton r pr consists edges l gamma j 0 aqsi l gamma automaton moves state 0 input gained replacing occurrences index 0 definition 2 let c scc b scc c thr weakly fair state u k process k disabled u edge type using slightly modified versions arguments found 10 deduce b contains information needed decide program p satisfies complement property given stated following theorem proved exactly lines theorem 33 lemma 38 10 using new definition b theorem 1 p satisfies complement property defined scc c b c contains final automaton state every scc c thr weakly fair 4 onthefly model checking main contribution present paper lies showing search scc b without requiring complete b previously constructed b explored constructing onthefly manner mentioned earlier b constructed product theta one first improvements construct theta smaller construction b implicitly create theta store part b based observation careful choice representative states theta threaded graph resolution construction nodes threaded graph checked equivalence nodes stored already implicitely part b new node stored first one equivalence class done command 6 algorithm presented implementation control way constructed default efficient case successors state together edges leading created stored first needed construction b want avoid storing edges use second option recreates temporarily time b state construction requires third possible option implementation allows us construct advance usefull program tested multiple correctness properties second component used construction b automaton representing correctness property small size compared data structures involved construction onthefly manner motivated general introductory lines let us turn presenting actual al gorithm explained earlier onthefly modelchecking algorithm explores simultaneously constructs process order analyze threaded graph without explicitly constructing maintain partition b node stack partition indicates processes known strongly connected component threaded graph 41 partitions first would like adopt following conventions concerning partitions identify equivalence relations corresponding partitions given set sense say partition contains another partition equivalence relation corresponding first partition superset equivalence relation corresponding second partition join two partitions smallest partition containing following two lemmas prove important properties sccs b c scc b following properties hold ffl nodes c path r r thr path r 0 j r well ffl sccs c thr disjoint ie two distinct sccs connected path c thr proof first part lemma proved follows assume nodes c path r r 0 c thr means exists path p r r 0 c product permutations path p since c scc exists path p 0 r 0 r c let 0 product permutations p 0 exists n 0 identity permutation consider path p path creates cycle c thr starting r back passing r obviously cycle contains path r 0 r second part lemma follows trivially first part state b c scc b contains r define equivalence relation r follows component c thr easy see class partition r identifies unique component thr every component c thr identified class r thus use partitions represent sccs c thr class r called weakly fair corresponding scc c thr weakly fair note tracked process l r always forms class size 1 suppose r r 0 nodes scc b partitions r equal cases fortunately one obtained permutation belonging g problem motivates use common referential base possible nominee initial state pr b assume explored b depth first manner starting initial state reachable states visited let resulting depth first spanning tree state u 2 b let u denote product permutations unique pr u path state r b define equivalence relation r follows r r nodes scc c b proof prove lemma enough show every implies vice versa show proving every r r scc c thr automatically imply following every j r j ie path c thr r r j also path r r 0 j hence show r r scc c thr take following approach let u root scc c ie u first node c visited depthfirst search induced forest f let tree f contains u r let initial state pr root shown unique path pr r passes u see 7 hence exists path c thr u gamma1 r hence lemma 1 see two nodes scc c thr similar argument see scc shows r scc intuitively indicates threads pr pr enter scc threaded graph passed r illustrate concepts consider subgraph simplified resource controller example depicted figure 4 tree edges denoted boldface arrows oeae pr oeae oeae oeae gammapsi figure 4 strongly connected subgraph product graph b nodes strongly connected subgraph u 1 immediate successor threaded graph hence u1 0 12 similarly u2 0 12 u3 1 02 using returning general argument show compute r exploring using depth first search edge gamma v b let e denote permutation u note e edge e identity permutation permutation e satisfies following property e edge scc c containing r e proof since depth first search tree enters scc graph unique vertex according lemma 2 scc therefore may assume r root scc contains e hence paths p 1 p 2 r endpoints u v e let products permutations paths p 1 p 2 respectively easy see r r demonstrate r j enough show path c thr r j r substituting u j replacing gamma1 r r let 00 denote permutation r hence gamma1 r r since r v scc exists path p 0 v path cycle exists n 0 p 2 also cycle product permutations cycle identity permutation big cycle written 2 path obvious product permutations p 0 finally consider cycle 2 c product permutations cycle equals 1 2 00 cycle creates path c thr r r r r follows path c thr r j r let ae permutation define orbit relation ae reflexive transitive closure binary relation ig obviously orbit relation ae equivalence relation define orbit partition ae partition induced orbit relation ae proposition 1 reformulated e edge scc r orbit partition e smaller equal ie subset r following stronger result characterizes r theorem 2 r join orbit partitions e e ranges edges strongly connected component r ie smallest equivalence relation containing orbit relation e edge e scc containing r proof need show r j implies processes edges e scc r ek k1 would indicate k k1 orbit relation ek hence j smallest equivalence relation containing orbit relations edges scc relationship r r j therefore r r j scc threaded graph let r r j path connects take k rk l k certainly permutation labeling edge e k note 0 different ek ek k1 k1 get ek k1 l substituting l l definition threaded graph get completes proof illustrating example figure 4 compute e 4 edges component g e gamma gamma u 3 tree edges gamma u 1 find similar way compute e gamma u 2 u2 orbit partition e4 1 02 join partitions 1 02 coincides next theorem follows immediately definition 2 necessary sufficient condition checking class r weakly fair let c scc r b theorem 3 class k partition r weakly fair disabled u executed edge gamma v c gathered together necessary tools present onthefly algorithm 42 algorithm algorithm modification strongly connected component computation using depth first search presented eg 2 vertex product graph b maintain following information ffl udfnum unique id depth first number node used strongly connected component computationq ffl ulowlink id reachable node lower u ffl uonstack flag indicating u still stack ffl uperm vector u defined previous subsection ffl upartition approximation u ffl ustatus vector flags indicate partition classes known weakly fair ffl ufinal flag indicates u scc contains final automaton state information propagated depth first tree variables udfnum ulowlink uonstack maintained algorithm given 2 uperm set u created upartition ustatus ufinal updated every time edge successor state u explored ontyefly model checking m1 set depthfirstcounter zero m2 set initial state b set uperm identity permutation conduct dfsearchu m3 exit answer dfsearchu note 1 push u stack set uonstack set udfnum ulowlink depthfirstcounter increase depthfirstcounter 2 initialize upartition identity partition 3 initialize ustatus information disabled processes stored aqs state ufinal final automaton state 4 idle command later modification use 5 aqs edge gamma 7 automaton transition aa 0 enabled 8 9 v already constructed vonstack set 10 compute join upartition orbit partition e store upartition update ustatus using process executed set ulowlink minimum ulowlink vlowlink 11 v constructed yet 12 13 conduct dfsearchv 14 vonstack still set 15 compute join upartition vpartition store upartition combine vstatus ustatus update ustatus using process executed set ulowlink minimum ulowlink vlowlink ufinal vfinal set 16 partition classes weakly fair use ustatus ufinal set exit yes answer 17 udfnum ulowlink 18 pop elements u inclusive stack mark popped vertices offstack command m2 construct initial state b invoke dfsearch vertex dfsearch algorithm may exit yes answer fair final scc discovered none recursively called invocations dfsearch exit yes answer algorithm outputs answer exits command m3 dfsearch works follows commands 13 initialize variables appropriately two loops commands 5 7 generate successors b state u command 6 invoke routine findequiv find equivalent representative gamma1 l aqsi returned l 0 ae property gamma1 l l 0 equivalent permutation ae later belongs aqsi equivalence test becomes easy store state symmetry partition underlying state definition details consult subsect 44 noted need equivalence checking since constructing b product theta automaton using however want construct b theta theta 10 need equivalence checking case may states resulting b command 6 needs changed set l 0 gamma1 l set ae identity permutation command 9 check u v nontree edge u v scc accomplished testing v already constructed ie visited v still stack test passed orbit partition e joined upartition result stored upartition commands 12 15 executed edge tree edge ie v constructed hence visited first time command 12 vperm set command 13 dfsearch invoked v v u scc indicated condition command 14 partitions joined ustatus updated updates carried processing edge u v command 16 check partially explored scc containing u weakly fair final state algorithm exits yes answer indicating fair computation accepted automaton found command 18 detecting scc pop states scc stack theorem 4 algorithm described outputs yes original program weakly fair computation accepted proof proof relies theory developed subsect 41 correctness strongly connected component algorithm 2 suppose algorithm halts yes answer termination stack contains strongly connected subgraph product graph subgraph weakly fair respect processes upartitions classes weakly fair upartition approximation smaller u yielding u weakly fair subgraph defines fair run program accepted automaton program terminates answer explored entire b graph found none strongly connected components satisfactory either lack final automaton state fair respect one processes hence original program fair run accepted automaton analyze complexity algorithm use following notation k graph automaton jkj denotes number nodes ek number edges transitions execution commands m1 m2 m3 together takes oji time commands 14 1215 17 executed node number b nodes jm theta j delta jaj single execution listed commands takes oji time thus commands contribute ojm theta j delta jaj delta ji j complexity consider execution commands 811 16 every time commands executed triple e l 0 different value hence commands executed em times execution commands 8 16 takes oji time implemented algorithm joining two partitions mentioned command 10 algorithm uses graph data structures complexity oji j commands 9 11 require checking node v already constructed implementation state maintain linked list b states whose first component obviously length list ji j delta jaj searching list takes oji j delta jaj thus see execution commands 811 complexity finally consider command 6 time executed triple e l different value hence number times executed bounded em delta ji j delta jaj thus command 6 contributes oem complexity x denotes complexity single execution command 6 analysis see complexity algorithm note general case checking state symmetry command 6 exponential complexity hence value x exponential however implementation checked restricted forms symmetries namely symmetries swap two processes also used state symmetry partitions generated construction see next subsections implementation complexity oji j hence implementation complexity algorithm oem delta ji noted invoke equivalence check command 6 explained earlier constructing b theta theta exploring case complexity also oem 43 state symmetry b partition initialization parallel edges subsection devoted showing equivalence relation u defined subsect 41 computed upartition computed efficiently presented basic algorithm improvements achieved sophisticated initialization u considering portion edges command 5 let vertex product graph b processes j called uequivalent denoted u j permutation ae 2 g u called local state symmetry partition u intuitively shows processes j interchangeable state u let u l edge b u aeffiael gamma v also edge yielding v gamma1 successor nodes u u j threaded graph b thr lemma 4 follows u u scc b thr hence u j proves next lemma lemma 3 partition u smaller u every state u product graph b fact allows improvement algorithm first need project u common referential base define j command 2 dfsearch changed initialize upartition u describe state symmetry used remove parallel edges let gamma v e gamma v edges b say e e 0 parallel permutation ae 2 g surely parallel equivalence relation edges let r r pr set representative edges contains least one edge parallel class partitions initialized presented command 2 0 orbit partition e 0 give new information orbit partition e considered reflected next lemma lemma 4 r scc b r smallest partition contains v initial value vpartition every v scc r well orbit partition e every edge e 2 r r pr proof let gamma v edge scc r whose representative gamma v r r pr suppose e show j contained join orbit partition e 0 u using definition e identity permutation let e 0 later implies ae j hence gamma1 l giving l u j summing e implies l l orbit partition e 0 l j u therefore orbit partition e contained join u orbit partition e 0 proves smallest partition contains v every v scc r well orbit partition e every edge e 2 r r pr actually contains orbit partition edges scc r using theorem 2 conclude contains r well direction follows proposition 1 lemma 3 ideas applied follows class u pick representative process call leader class put r r l leaderg since every edge parallel one caused leader pro cess r r pr satisfactory set representative edges introduce new vector uleader flags next improvement algorithm introduction command 4 modification command 5 4 initialize uleader 5 aqs edge gamma v uleaderi set 44 state symmetry subsection show state symmetry also used reduce number edges generated stored let state symmetry ie gamma edge ffij gamma also edge simple observation shows need store j gamma gamma provided efficiently computed idea employed first introducing aqs state equivalence called state equivalence relation among process indices defined follows 2 g note subsect 43 introduced local state symmetry partition b states local state symmetry partition b state denoted u note subscript distinguishes two notations recall 2 g j observe therefore local state symmetry partition b state usually smaller state equivalence relation underlying state caused fact state symmetry permutation b state fixes underlying state tracked processes well nevertheless hand u easily computed unfortunately problem computing difficult task since equivalent graph isomorphism problem given graph h associate program p state p straightforward way p many processes many nodes h pair processes v w p variable av w indexed v w av w takes value 1 v w edge h otherwise 0 v exactly h automorphism maps node v later problem equivalent graph isomorphism problem many important special cases symmetry detection performed efficiently general however approximating solutions available let j gamma edge gamma edge well simple observation shows need store j gamma ffij provided efficiently computed ready present last improvement algorithm construction shown algorithm following modifications new node created compute vector srepr defined every index j points representative class j construction edges store edges caused representative process j gamma stored original algorithm commands 5 12 changed 5 12 respectively 5 00 stored aqs edge gamma process uleaderi set compute 2 g pointed earlier general computing computationally hard however implemented method look state sym metries ie permutations interchange two process indices computing symmetries corresponding equivalence relation done ef ficiently approach employed computing state symmetries b also note step 5 algorithm enough find one permutation satisfying given property compute permutations since case state symmetry restricting class permutations interchange two process indices step 5 also implemented efficiently concluding section illustrate concept state symmetry redundant edges showing simplified resource controller deleting redundant edges oeae iii rii oeae oe id 1idgamma gammapsi gammapsi gammapsi figure 5 aqs without redundant edges consider figure 5 top row circle shows local states three processes bottom row lists representative processes compressed 16 edges original 27 5 implementation developed prototype onthefly model checker implementing presented algorithm used efficient approximation techniques check equivalence two states generating aqs also main algorithm check equivalence b states case complete symmetries resource controller readerswriters examples approximation algorithm indicate two states equivalent whenever equivalent types symmetry approximation methods may sometime indicate two states inequivalent although equivalent cases may get maximum possible reduction size state space however algorithm still correctly indicate concurrent system satisfies correctness specification used implemented system check correctness resource controller example readers writers example ethernet protocol various number users contrasted new system old model checker implements results presented 10 resource controller example checked many properties including liveness property every user process requests resource eventually access resource mutual exclusion property dramatic improvement detected performance measures indicated table product graphs constructed old new model checker referred b 0 b respectively statistic given ab b numbers corresponding old new model checker respectively table 1 statistics checking liveness property eventually access 10 50 100 aqs states 38 38 198 198 398 398 aqs transitions 235 107 6175 1567 24850 5642 explored total memory used kbyte 31 13 1219 216 6878 830 total cpu time used sec 0 0 37 6 481 42 table 2 statistics checking safety property mutual aqs states 38 38 198 198 398 398 aqs transitions 235 107 6175 1567 24850 5642 explored total memory used kbyte total cpu time used sec 0 0 liveness property checked satisfied resource controller model checkers found fair incorrect computation table see number aqs states number aqs transitions much smaller new model checker due use state symmetry number product states explored onthefly system much smaller since terminated early hand original model checker constructed checking incorrect fair computation mutual exclusion property model checkers indicated resource controller satisfies property case early termination come effect furthermore since track process mutual exclusion global property number states explored b 0 b however number transitions much smaller well b due effect state symmetry cpu time memory usage substantially smaller new model checker 6 conclusions paper presented onthefly model checking system exploits symmetry states well inside state checks correctness fairness symmetry based reduction shown powerful tool reducing size state space number contexts example techniques employed petrinet community 14 15 reduce size state space explored techniques also used protocol verification 1 16 hardware verification 13 temporal logic model checking 5 9 10 onthefly model checking techniques 3 11 12 17 employ traditional state enumeration methods 11 12 17 also use types state reduction techniques best knowledge first approach performs onthefly model checking fairness full range temporal properties exploits symmetry part future work plan explore techniques automatically detect symmetries integrate techniques model checker also algorithms checking equivalence global states types symmetry need explored r calculus protocol specification validation design analysis computer algorithms efficient onthefly modelchecking ctl automatic verification finite state concurrent programs using temporal logic practical approach exploiting symmetry temporal logic model check ing analyzing concurrent systems using concurrency workbench functional programming concurrency simulation automated reasoning introduction algorithms generation reduced models checking fragments ctl symmetry model checking utilizing symmetry model checking fairness assumptions automatatheoretic approach partialorder methods verification concurrent systems state spin better verification symmetry colored petri nets basic concepts analysis methods practical use highlevel petri nets theory application testing containment omegaregular languages computer aided verification coordinated processes automata theoretic approach tr ctr prasad sistla patrice godefroid symmetry reduced symmetry model checking acm transactions programming languages systems toplas v26 n4 p702734 july 2004 sharon barner orna grumberg combining symmetry reduction underapproximation symbolic model checking formal methods system design v27 n12 p2966 september 2005 alice miller alastair donaldson muffy calder symmetry temporal logic model checking acm computing surveys csur v38 n3 p8es 2006
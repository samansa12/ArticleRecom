fixpoint logics relational machines computational complexity establish general connection fixpoint logic complexity one side fixpoint logic parameterized choices 1storder operators inflationary noninflationary iteration constructs deterministic nondeterministic alternating side complexity classes p exptime parameterized fixpoint logics capture complexity classes p np pspace exptime equally achieved ordered structures however inherent mismatch complexity logicwhile computational devices work encodings problems logic applied directly underlying mathematical structures overcome mismatch use theory relational complexity bridges gap standard complexity fixpoint logic one hand show questions containments among standard complexity classes translated questions containments among relational complexity classes hand expressive power fixpoint logic precisely characterized terms relational complexity classes tight threeway relationship among fixpoint logics relational complexity standard complexity yields uniform way logical analogs containments among complexity classes p np pspace exptime logical formulation shows tantalizing questions complexity theory boil single question relative power inflationary vs noninflationary 1storder operators b introduction computational complexity problem amount resources time space required machine solves problem complexity theory traditionally focused computational complexity problems recent branch complexity theory started fagin fag74 fag75 developed 1980s focuses descriptive complexity problems complexity describing problems logical formalism imm87a one exciting developments complexity theory discovery intimate connection computational descriptive complexity intimate connection first discovered fagin showed complexity class np coincides class properties expressible existential 2ndorder logic fag74 cf js74 another demonstration connection shown immerman vardi discovered tight relationships complexity class p inflationary fixpoint logic imm86 var82 class pspace noninflationary fixpoint logic var82 see also imm82 1 tight connection descriptive computational complexity typically referred connection logic complexity proclaimed immerman imm87b studied many researchers com88 goe89 gra84 gra85 gur83 gur84 gur88 hp84 imm89 lei89a liv82 liv83 lyn82 saz80b although relationship descriptive computational complexity intimate without problems partners irreconcilable differences computational devices work encodings problems logic applied directly underlying mathematical structures result machines able enumerate objects logically unordered example typically think set nodes graph unordered become ordered encoded tape turing machine impedance mismatch pose difficulty identification np existential 2ndorder logic fag74 since logic simply assert existence desired order relationship class p inflationary fixpoint logic however complicated result mismatch although inflationary fixpoint logic describe pcomplete problems easy problems p expressible inflationary fixpoint logic eg checking whether cardinality structure even ch82 assume built inflationary noninflationary fixpoint logics defined section 2 vardi actually proved correspondence pspace query language rql abiteboul vianu av89 later proved equivalence rql noninflationary fixpoint logic 2 focus connection finitemodel theory complexity connection logic complexity also prooftheoretic aspect see bus86 gss90 lei91 order get p coincides class properties expressible inflationary fixpoint logic imm86 var82 similarly assume builtin order get pspace coincides class properties expressible noninflationary fixpoint logic var82 consequence fagins result npconp existential universal 2ndorder logic expressive power equivalence questions computational descriptive complexity one major features connection two branches complexity theory holds promise techniques one domain could brought bear questions domain unfortunately order issue complicates matters results immerman vardi show ppspace inflationary noninflationary fixpoint logics expressive power ordered structures would like however eliminate restriction ordered structures two reasons first reason technical questions logical expressiveness ordered structures typically much harder unordered counterparts see example dr84 sch94 second reason fundamental restriction ordered structures seems technical device rather intrinsic feature restriction equivalence provides translation p vs pspace question descriptive complexity question provide translation inflationary vs noninflationary question computational complexity question thus would like obtain orderfree correspondence questions computational descriptive complexity see also il90 discussion order issue another perspective order issue partially overcome recently abiteboul vianu av95 showed indeed ppspace inflationary noninflation ary fixpoint logics expressive power crux result description certain internal order inflationary fixpoint logic order much weaker total order available computational devices sufficient enable translation ppspace question logical one av95 although result goes long way overcoming order issue completely satisfying two different ways relate descriptive computational complexity fagins result extended later correspondence polynomial hierarchy 2ndorder logic sto77 enables us phrase questions polynomial hierarchy terms secondorder logic result av95 enables us phrase p vs pspace question terms fixpoint logic two formalisms different clear whether combined yield descriptivecomplexity analog pnp question goal paper extend results techniques av95 general connection fixpoint logics complexity classes p exptime results based several fundamental ideas heart framework view fixpoint logic 1storder logic augmented iteration traditionally fixpoint logic viewed extension 1storder logic recursion cf mos74 iteration proved general extension 1st order logic recursion av89 gs86 imm82 lei90 inflationary noninflationary fixpoint logics iteration applied simplest form sequential deterministic turns however order express certain problems fixpoint logic one seems require elaborate forms iteration nondeterministic alternating indeed part research motivated question whether pspacecomplete problems quantified boolean formulas nonuniversality finite automata gj79 described non inflationary fixpoint logic augmenting fixpoint logic nondeterministic alternating iteration find connection fixpoint logic computational complexity quite broad covers classes p pspace also classes np exptime example ordered structures np coincides class properties expressible nondeterministic inflationary fixpoint broad connection fixpoint logic computational complexity still suffers order mismatch discussed get around difficulty expand theory relational complexity initiated av91b av95 bridges gap standard complexity fixpoint logic relational complexity theory computations unordered structures modeled relational machines relational machines turing machines augmented relational store ability perform relational operations store idea extending 1storder logic general computational capability suggested ch80 pursued av95 3 unlike turing machines operate encodings problems relational machines operate directly underlying mathematical structures turing machines natural measure complexity terms size input measure natural one relational machines since machines cannot measure size input fact relational machines limited discerning power ie power distinguish different pieces input since able manipulate input relationally discerning power relational machines best understood viewing effective fragment certain infinitary logic studied recently kv92 kv95 view yields precise characterization discerning power relational machines terms certain infinite 2player pebble games characterization used relational machines order determine discerning power suggests natural measure size input relational machine respect discerning power machine new measure gives rise new notion computational complexity called relational complexity resulting classes p r relational polynomial time np r relational nondeterministic polynomial time relational complexity serve mediator logical complexity standard complexity one hand show questions containments among standard complexity classes translated questions containments among relational complexity classes hand expres 3 closely related idea generalizing turing machines operate general structures goes back fri71 investigated extensively lei89a lei89b sive power fixpoint logic precisely characterized terms relational complexity classes tight threeway relationship among fixpoint logics relational complexity standard complexity yields uniform way logical analogs containments among complexity classes p np pspace exptime also enables us translate known relationships among complexity classes equality pspace npspace apspace results expressive power fixpoint logics fulfills promise applying results one domain another domain shows tantalizing questions complexity theory p vs pspace np vs pspace pspace vs exptime boil one fundamental issue understanding relative power inflationary vs noninflationary 1storder operators fixpoint logics 1storder formula nary relation symbol included vocabulary oe let structure vocabulary oe formula gives rise operator phis nary relations universe nary relations phit every nary relation every operator phis generates sequence stages obtained iterating phis stages phi also denoted phi defined induction phi intuitively one would like associate operator phis limit stages possible sequence phi 1 stages converges ie case phi 0 fixpoint phis since phi sequence stages may converge particular happen formula x fixpoints 21 inflationary fixpoint logic inflationary phit nary relation particular inflationary form sx inflationary sequence phi 1 stages increasing thus must limit precisely finite structure elements integer 0 n phi sequence stages x converges phi 0 write denote fixpoint phi 0 inflationary fixpoint logic ifp 1storder logic augmented inflationary fixpoint formation rule inflationary formulas 4 canonical example formula inflationary fixpoint logic 4 following assume wlog inflationary formula form provided inflationary fixpoint 1 x 1storder formula case 1 x defines transitive closure tc edge relation e follows connectivity property expressible inflationary fixpoint logic well known cf fag75 au79 1storder logic remark 21 fixpoints also guaranteed exist formula positive namely every occurrence governed even number negations case sequence phi 1 stages also increasing consequently limit fixpoint fact limit least fixpoint positive fixpoint logic 1storder logic augmented least fixpoint formation rule positive formulas easy see ifp least expressive positive fixpoint logic gurevich shelah showed fact two logics expressive power gs86 see also lei90 complexitytheoretic aspects ifp studied ch82 imm86 var82 papers actually focused positive fixpoint logic observed positive fixpoint logic ifp expressive power known ifp captures complexity class p logic l said capture complexity class c following holds 1 problems expressible l c 2 ordered structures l express problems c natural definition would require problem c iff expressible l order mismatch requirement would stringent note however problems p eg checking whether cardinality structure even expressible ifp ch82 22 noninflationary fixpoint logic obtain logics iteration constructs expressive inflationary fixpoint logic powerful logic results one iterates general 1storder operators fixpoint reached may never happen case may nonterminating computations unlike inflationary fixpoint logic iteration guaranteed converge let phi 1 sequence stages operator phis associated formula x integer 0 phi otherwise set noninflationary fixpoint noninflationary fixpoint logic nfp 1storder logic augmented noninflationary fixpoint formation rule arbitrary 1storder formulas note nfp fixpoint logic extension ifp ifp formulas evaluated 5 actually shown av90 loss generality restricting attention converging 1storder operators polynomial time nfp express pspacecomplete problems network convergence problem fed91 noninflationary fixpoint logic introduced abiteboul vianu av91a called partial fixpoint logic particular observed noninfla tionary fixpoint logic coincides query language rql introduced ch82 studied var82 follows nfp captures complexity class pspace var82 problem even cardinality expressible nfp ch82 clearly ifp nfp expressive power ppspace clear however converse holds ifp nfp need order fully capture p pspace respectively nevertheless ppspace ifp nfp expressive power av95 23 nondeterministic fixpoint logics ifp nfp obtained iterating inflationary noninflationary 1st order operators respectively cases however iteration sequential deterministic certain problems however seem defy description iterations example consider nonuniversality finite automata binary al phabet known pspacecomplete gj79 given finite automaton alphabet f0 1g want know whether word rejected automaton instance problem viewed structure set states 0 set initial states f set accepting states ae 0 2 transition relation symbol 0 transition relation symbol 1 check whether word rejected automaton one simply guess word check rejected automaton easily described nondeterministic iteration 1storder operators let us define nondeterministic iteration let phi 1 phi 2 1storder operators pair operators generates convergent sequences stages obtained successively applying convergence reached phi 1 phi 2 pair generates sequences form convergent sequence stages call sm local nondeterministic fixpoint pair phi 1 phi 2 note pair phi 1 phi 2 one local nondeterministic fixpoint none define nondeterministic fixpoint pair phi 1 phi 2 union local nondeterministic fixpoints pair phi 1 phi 2 local nondeterministic fixpoint exists define nondeterministic fixpoint empty set underlying intuition outcome nondeterministic computation defined disjunction outcomes possible computations number stages nondeterministic fixpoint taken maximum convergent sequences nondeterministic fixpoint logics obtained augmenting 1storder logic nondeterministic inflationary noninflationary fixpoint formation rules restriction negation cannot applied nondeterministic fixpoints readers convince nonuniversality problem expressed nondeterministic fixpoint noninflationary operators phi 1 corresponding next input symbol 0 1 problem however seem expressible deterministic iteration savitchs theorem sav80 tells us convert nondeterministic polynomialspace algorithm deterministic polynomialspace algorithm construction assumes builtin order obvious deterministic iteration follow later results problem expressible deterministic iteration nondeterminism described resides control ie choice formula applied stage contrasted data nondeterminism av91a allows nondeterministically choose arbitrary tuple relation data nondeterminism strictly stronger control nondeterminism instance data nondeterminism one nondeterministically order domain elements use constructed order compute parity set domain elements 24 alternating fixpoint logics example motivates another extension fixpoint logic consider truth quantified boolean formulas also known pspacecomplete gj79 problem trivially solved alternating polynomial algorithm cks81 naturally expressed alternating iteration 1storder oper ators let us define alternating iteration let phi psi 1storder operators pair operators generates convergent trees stages obtained successively applying convergence reached either one phi psi phi psi formally convergent tree labeled binary tree 1 root labeled empty relation 2 node x label x odd level tree x one child labeled phis x psis x 3 node x label x even level tree x two children x 1 x 2 labeled phis x psis x respectively 4 x leaf label x phis x take intersection labels leaves convergent stage tree local alternating fixpoint pair phi psi instance convergent stage tree represented figure 1 local fixpoint underlying intuition computation tree alternating machine existential choices already factored thus one needs take f figure 1 convergent stage tree conjunction universal choices take disjunction computation trees number stages convergent tree length longest branch note pair phi psi one local alternating fixpoint none define alternating fixpoint pair phi psi union local alternating fixpoints pair phi psi union essentially disjunction existential choices factored convergent tree local alternating fixpoint exists define alternating fixpoint empty set number stages nondeterministic fixpoint taken maximum convergent trees discussion far shows fixpoint logics parameterized along two dimensions power iteration construct deterministic vs nondeterministic vs alternating power 1storder operators inflationary vs non inflationary gives rise six fixpoint logics use notation fp ff fi refer fixpoint logic iteration type ff operators type fi thus logics ifp nfp denoted fp fp n respectively alternating noninflationary fixpoint logic let ff fi formulas fp ff fi obtained starting atoms repeated applications firstorder operators 9 8 fixpoint op erator fixpoint formation rule fp ff fi ff familiar one ff fn ag formation rule follows let 1 2 formulas fp ff fi nary predicate formula sequence n variables constants assume 1 2 inflationary require negation applied formula containing fixpoint semantics formulas defined inductively described obvious containments among logics described following diagram one prove various fixpoint logics standard results closure composition complement except collapse nesting fixpoints words one fixpoint operator per formula suffices simultaneous induction one carrier suffices hold cases results shown fp gs86 fp n av91a proof essentially new logics 25 fixpoint logics standard complexity let us examine complexitytheoretic aspects family fixpoint logics already know fp captures p fp n captures pspace one would expect nondeterministic alternating iterations capture nondeterministic alternating computations indeed case recall capturing complexity class c language l two aspects first problems expressible l c second ordered structures l expresses problems c next consider aspects separately lemma 24 x fd n ag 1 fp x xptime 2 fp x n xpspace proof illustration show fp n apspace show compute alternating fixpoint pair arbitrary firstorder formulas alternating polynomial space suppose variables since number kary tuples domain polynomial fixed k suffices show check alternating polynomial space whether given tuple alternating fixpoint algorithm stores kary relation r initially empty algorithm alternates existential universal states existential state algorithm branches existentially choosing computing phir computing psir universal state algorithm branches universally computing phir psir algorithm terminates accepts note computing phir psir done polynomial space thus whole computation done polynomial space see fixpoint logics express ordered structures problems corresponding complexity classes first show number stages polynomialy bounded noninflationary computation simulated inflationary manner ordered structures technique use essentially generalizes timestamping technique av91a fd n ag f fp x n ordered structure number stages f bounded polynomial size structure exists f 0 fp x equivalent f ordered structures proof prove statement cases simpler let oe input type including binary predicate suppose exists integer p ordered structure oe depths converging stage trees bounded jdj p construct equivalent fixpoint formula fp let structure oe ordered since ordered use ptuples denote integers 0 jdj carrier induction b arity b use inflationary formulas defined follows new distinct variables ffl u vector free variables obtained replacing atom sv b ffl current first order formula stating tuple hy 0 largest ptuple ordering ptuples induced belonging projection b last p coordinates ffl next first order formula stating tuple hy ordering ptuples induced intuitively timestamping technique value stage fixpoint identified timestamp stage p tuple f fp new distinct variables clearly b f equivalent f lemma 26 x dna ordered structures 1 xptime fp x 2 xpspace fp x n proof first consider 1 result known let oe input type including binary predicate let f boolean function structures oe ordered f aptime exists alternating turing machine aptime given encoding ordered structure oe accepts iff fd first show simulate fp n use lemma 25 simulation similar used imm86 var82 show fp n simulate polynomialspace time turing machines configurations moves represented similarly difference lies simulation control elaborate aspect assume wlog move always takes universal state existential one conversely state q tape symbol u two possible moves say moves 2 imm86 var82 construct 1storder formula 1 defining transitions corresponding moves 1 another 1storder formula 2 moves 2 suffices alternatingly iterate 1 2 polynomial number times done fp n however wish simulate inflationary manner see done observe convergent stage trees since apt ime depth trees bounded polynomial size input thus lemma 25 f expressed fp demonstrates aptime fp suffices assume alternative universal state 2 proof similar theorem 27 1 fp n captures np 2 fp b fp n n capture pspace 3 fp n captures exptime proof result immediate using 1 lemmas 24 26 1 2a lemmas 24 26 1 2b lemmas 24 26 2 3 lemmas 24 26 2 theorem 27 says connection fixpoint logics classes p pspace discovered imm86 var82 one half picture complete picture broad connection fixpoint logics complexity classes p exptime theorem 27 strong enough yield separation fp fp n follows fact p strictly contained exptime broad connection fixpoint logic computational complexity still suffers order mismatch thus cannot translate containments complexity classes containments fixpoint logics example fact fp n fp n n fp n capture pspace infer expressive power ordered structures tell us anything relationship logics general get around difficulty use theory relational complexity mediates standard complexity fixpoint logics 31 model relational machine turing machine augmented relational store relational store consists set relations certain arities relations designated input relations designated output relations type relational machine sequence arities relations arity machine maximal arity relations store tape machine work tape initially empty transitions depend current state content current tape cell test emptiness relation relational store transitions involve following actions move right left tape overwrite current tape cell tape symbol replace relation store result algebraic operation relations store algebraic operations boolean operations gamma project tuples relation coordinates 1 specified order theta cross product two relations oe ij oe ia resp select relation tuples whose ith coordinate coincides jth one select tuples whose ith coordinate coincides domain element see ull89 example machine instructions machine state 3 head reading symbol 1 relation r 1 empty change state 4 replace symbol 1 0 move head right replace r 2 r 2 r 3 configuration relational machine consists state tape content head position content relational store configuration l denote lstore content store configuration l formal definitions relational machine configuration move straightforward lengthy omitted relational machines model embedding relational database query language cod72 general purpose programming language 6 essentially loosely coupled generic machines gm loose introduced av95 negligible difference unlike relational machines gm loose apply general 1storder transformations relational store however transformations simulated algebraic operations constant number steps see ull89 unlike turing machines get input spread input tape relational machines get input natural way example input graph input machine set nodes set edges type machine h1 2i arity machine 2 thus order issue come relational machines fixpoint logics come back later connection relational machines fixpoint logics 6 relational machines closely related 2ndorder pointer machines lei89a pointer machine manipulate store means tagging untagging operations relational machines manipulate store means relational operations relational machines give rise three types computational devices first think relational machine acceptor relational language ie set structures case assume single 0ary output relation machine accepts output relation consists 0ary tuple rejects output relation empty also think relational machine relational function computing output structure given input structure finally think relational machine mixed function ie function structures strings output written machines tape analogy nondeterministic alternating turing machines define nondeterministic alternating relational machines use nondeterministic alternating relational machines viewed acceptors relational functions mixed functions deterministic machines used acceptors definitions completely analogous turing machines machines viewed relational functions slightly com plicated output nondeterministic relational machine defined follows tuple output relation r belongs r end computation machine input intuition result nondeterministic computation taken relationwise union results possible com putations output alternating relational machine defined follows finite computation tree tree whose nodes configurations machine 1 root start configuration 2 state configuration tree existential single child one possible next configurations 3 state configuration tree universal children possible next configurations 4 leaves halting configurations let tm set finite computation trees alternating relational machine input output l leaf tg union intersection relationwise intuition take union existential choices term union take intersection universal choices 32 discerning power relational complexity would like define complexity classes using relational machines noted av95 using measure input size appropriate relational machines unlike turing machines relational machines limited access input particular cannot generally compute size indeed relational machines less discerning turing machines av95 say relational machine cannot discern ktuples u v input kary relation r store throughout computation u r precisely v r example automorphism maps u v u v cannot discerned discerning power relational machines best understood viewing effective fragment logic l 1 infinitary logic finite number variables studied recently kv92 kv95 connection relational machines l 1 developed avv95 suffices say yields characterization discerning power relational machines terms certain infinite 2player pebble games kpebble game spoiler duplicator ltuples l structure following rules players pebbles say respectively game starts spoiler choosing one tuples u v placing l elements chosen tuple ie u placing pebbles p elements duplicator responds placing pebbles q elements tuple placing pebbles q elements following round game spoiler moves pebble another element duplicator responds moving corresponding pebble q p let elements pebbles p resp k end round game mapping h ha isomorphism substructures universes respectively spoiler wins game duplicator wins game continue playing forever ie spoiler never win game duplicator wins kpebble game tuple u v structure say u v kequivalent denoted u j k v relation characterizes discerning power kary relational machines proposition 31 tuples u v kequivalent structure kary relational machine discern u v proof ba77 imm82 u v kequivalent respect iff l k 1 equivalent ie 2 l k 1 v kv92 finite structures l k 1 equivalence denotes set firstorder formulas k variables suppose u v l k equivalent respect exists j u 6j v easily seen exists kary relational machine evaluates thus u v distinguished conversely suppose u v distinguished kary relational machine input easy induction number steps computation shows content relation store time computation defined formula l k thus u v distinguished formula l k since kary relational machines cannot discern among kequivalent tuples cannot measure size input instead computations kary relational machines determined kequivalence classes intuitively relational machines complete equivalence classes tuples distinguish best understood looking extremes shown av95 relational machines complete ordered inputs distinct tuples distinguished collapse firstorder logic unordered sets number kequivalence classes bounded constant independent size input thus seems natural measure input size respect j k let ksize structure denoted size k number ktuples spirit 7 av95 propose measure time space complexity kary relational machines function ksize input measure however reasonably serve basis measuring complexity calculated relational machines techniques av95 used show relational machines measure ksize use following result 8 av95 lemma 32 av95 input type oe k 0 exists ifp formula oe input type oe defines partial order oe ktuples x 1 x k incomparable via oe words exists ifp query computing order equivalence classes j k proposition 33 k 0 input type oe relational machine outputs tape input structure type oe string length size k time polynomial size k proof lemma exists ifp formula oe defining input type oe equivalence classes j k order considering proof lemma one see number stages polynomial size k since evaluation firstorder formula simulated relational machine constant number steps evaluated machine time still polynomial size k suppose result placed 2kary relation r k oe finally produce string length size k tape sufficient step kequivalence classes order given r k oe write symbol tape equivalence class clearly entire computation takes number steps polynomial size k measure complexity kary relational machines terms ksize input define relational complexity classes 7 av95 measure input based equivalence classes tightly connected particular machine contrast ksize used uniform relational machines arity k 8 alternate proof result makes explicit connection pebble games recently given dlw95 terms deterministic resp nondeterministic alternating relational time relational space eg dtime r fn nspace r fn thus define relational complexity class p r relational polynomial time npspace r etc proposition 33 guarantees effective enumerability classes contrast clear get effective enumerability define relational complexity terms actual size input note obvious whether known relationships deterministic nondeterministic alternating complexity classes pspacenpspaceaptime hold also relational complexity classes since relationships typically result simulations use order although show hold simplify references complexity classes use notation classresource control bound class r resource control bound resource time space control deterministic nondeterministic alternating bound bounding function family functions thus classtime nondetermin istic poly np class r space deterministic poly pspace r always assume bounds least linear typically bound polynomialy closed set functions ie set functions contains linear functions contains pfn whenever contains fn polynomials px furthermore assume bounds fully time space constructible note commonly used functions including logarithmic linear polynomial exponential bounds fully time space constructible see hu79 also fully time space constructible functions polynomialy closed 4 relational vs standard complexity relationship relational standard complexity easy see ksize structure always bounded polynomial size k 0 furthermore relational machines strictly weaker turing machines cannot check cardinality input even latter follows fact logic l 1 01 law cannot express evenness property kv92 thus obtain following proposition 41 let phi polynomialy closed set functions class r resource control phi ae classresource control phi resource control proof standard complexity class classresource control phi phi polynomialy closed contains evenness property relational complexity class class r resource control phi relational machines sense weaker standard machines weakness due lack order weakness disappears presence order let w string say alphabet f0 1g length n encode w structure relw consisting total order elements unary predicate elements giving positions 1s string note ksize relw bounded n k language l let lg since relw ordered w relational machine simulate machine l proposition 42 resource control polynomialy closed bound language l classresource control bound relational language rell class r resource control bound proof let oe type rell binary unary relation given input oe kary deterministic relational machine k 1 check constant time form relw w form relw machine rejects otherwise machine write w tape time polynomial size k equals jwj k lastly relational machine runs turing machine recognizing l takes timespace bounded fjwj fsize k function f 2 bound thus relational machine recognize rell specified control using resource c fsize k constant c follows rell class r resource control bound combining propositions 41 42 get corollary 43 let phi 1 phi 2 polynomialy closed sets functions let resources controls respectively proof suppose let l classresource 1 42 rell 41 class r resource follows exists turing machine rell accepts standard encoding relw control control 2 resource resource 2 bounded function phi iff w 2 l since standard encoding relw obviously obtained w timespace polynomial jwj follows exists turing machine ml accepts l control resource bound rell thus classresource contains l follows corollary 43 separation results among standard complexity classes translate separation results among relational complexity classes example follows p r strictly contained exptime r understand relationship standard relational com plexity introduce notion reduction relational language standard language say relational language l type oe relationally reducible polynomial time standard language l 0 exists deterministic polynomialtime relational machine acting mixed function oestructures strings structure type oe 2 l one technical results 9 paper every relational language reduced standard language need notation definition let kary relational machine k let j k denote k equivalence mtuples proposition 31 easily follows time computation input content mary relation store union classes j k consider action algebraic operations store would like summarize effect terms equivalence classes alone boolean operations problem consider relational algebraic operations theta oe operations distribute union therefore effects determined effects individual equivalence classes appropriate arity described action tables defined next analog algebraic operations action tables conjunctive queries defined av95 definition 44 let operation among f theta oeg arguments r 1 r n arities result arity n1 k action table structure relation r arity class j j ready show relational language polynomialy reducible standard language theorem 45 let phi polynomialy closed set fully timespace constructible functions let l relational language class r ae phi resource ae control bound phi l relationally reducible polynomial time language l 0 classae phi proof suppose l accepted relational machine arity k class r ae phi reduction relational input type oe word proceeds follows let oe oe type consisting relations r oe k r relational operation among f theta oeg used normal form av95 first map structure oe oe oe viewed ordered structure first classes j computed order stored relations r oe lemma 32 follows r oe computed ifp formula number stages polynomial size k deterministic relational machine time polynomial size k next action tables 9 result implicit av95 dlw95 relational algebraic operations used relational machine produced construction involves stepping sequences equivalence classes lexicographic order induced r oe takes number steps polynomial size k structure oe viewed ordered structure follows let absoe oe type obtained oe oe replacing relation r oe binary relation name r operation n arguments n 2 relation arity n 1 let absd oe ordered structure absoe oe obtained oe follows tuple hx replaced hi ji ranks hx partial order mtuples given r tuple hx arguments arities result arity n1 x j arity replaced rank x j partial oe note absd oe ordered structure number elements absd oe size k putting together clear relational machine produce standard encoding absd oe tape number steps polynomial size k let encabsd oe denote standard encoding uses alphabet sigma phi class r ae ffg technique used showing normal form av95 seen exists turing machine 0 control accepts encabsd oe accepts resource ae bounded polynomial fsize k basically 0 simulates moves one one using information provided encabsd oe content relation r arity store represented integers corresponding classes j k currently r algebraic operations store simulated using action tables thus step simulated 0 number steps polynomial jwj size k define language l 0 let 00 turing machine control input w 2 sigma 1 construct string length fjwj simulate 0 w long 0 uses fjwj resource exhausts resource latter case reject otherwise accept reject 0 note 1 done without exceeding bound resource ae f fully aeconstructible let l 0 consist words sigma accepted 00 l oe accepted iff 2 l 0 thus l relationally reducible polynomial time l 0 according proof theorem reduction l l 0 depends type oe l arity k relational acceptor denote relational machine reduction type oe arity k oek call relational reduction machine input type oe arity k combining propositions 41 42 corollary 43 theorem 45 get relationships among relational complexity classes analogous relationships among standard complexity classes corollary 46 let phi 1 phi 2 polynomialy closed sets fully timespace constructible functions let resource 1 resource 2 control 1 control 2 kinds resources controls respectively proof part corollary 43 onlyif part suppose let l relational language type oe class r resource 1 accepted relational machine arity k consider relational reduction machine oek theorem 45 exists language l 0 classresource 1 type oe relational machine input computes oek time polynomial size k runs oek turing machine accepts l 0 control control 2 using resource resource 2 bounded function phi 0 accepts l uses control control 2 resource resource 2 bounded function phi thus l class r resource particular follows corollary 46 known relationships deterministic nondeterministic alternating complexity classes pspacenpspaceaptime hold relational complexity classes ie pspace r npspace r aptime r also open questions standard complexity classes translate questions relational complexity classes eg pnp p r np r insight relationship standard relational complexity obtained closer look relationship size ksize since ksize much smaller size relational complexity much higher standard complexity result relational complexity sense orthogonal standard complexity understand better let us reexamine translation strings structures one hand mapping rel maps strings structures easy see w string ksize relw polynomialy related size w hand according theorem 45 mappings structures strings let oek relational reduction machine mapping structures type oe relw strings checked given string w size oek relw polynomialy related size w turns however using result lindell ksize trees lin91 encode strings structures way blows size without blowing ksize mapping rel f strings structures 1 w string length n rel f w size fn n 2 ksize rel f w polynomial n string f0 1g length n let rel f w structure type h2 1i binary relation complete tree depth n fanout fn unary relation contains nodes tree level x size rel f w fn 1 consider ksize rel f w ktuple elements rel f w identified automorphism sequence levels tree least upper bound pairs j lin91 thus number automorphism classes ktuples bounded n k 2 follows ksize rel f w polynomial n example taking 2 blow size exponentially denote encoding rel 2 proposition 47 implies find languages different relational complexity standard complexity particular get following consequences corollary 48 1 2 3 p r ae exptime r p proof consider 1 suppose conversely suppose first note rel 2 l np r indeed consider relational machine given structure type h2 1i 1 check form rel 2 w w reject 2 output w tape 10 equivalence p shown av95 3 run nondeterministic turing machine 0 recognizing l np accept reject 0 clearly 1 done ifp query relational machine p r translation rel 2 w w also p r lastly 3 np r follows rel 2 l np r next recall word w rel 2 w size exponential length w thus rel 2 l p rel 2 l np r p p r shown av95 p finally result lindell lin91 states rel 2 l definable ifp l p follows proven proof 2 similar done av95 consider 3 technique shown p exptime however time hierarchy says p ae exptime follows corollary 48 tells us questions separation among standard complexity classes expressed questions relational complexity classes standard complexity first clause says p np separate iff p r np r separate inside p similarly second clause says p pspace separate p r pspace r separate inside p third clause corollary says exptime r stronger p r exptime r contains problems cannot solved polynomial time also contains problems cannot solved relational polynomial time even though solved standard polynomial time see dlw95 related results 5 relational machines fixpoint logics fixpoint logics involve iterations 1storder formulas since relational algebra expressive power 1storder logic clear relational machines appropriate control simulate fixpoint logics example fp p r fp n apspace r find precise relationship fixpoint logics relational machines consider theorem 45 according theorem every relational language certain relational complexity reduced relational polynomial time standard language analogous standard complexity example relational language np r reduced relational polynomial time language np according theorem 27 fixpoint logic fp n captures np thus gap np r fp n relational polynomial time reduction gap bridged following theorem uses normalform theorem av95 theorem 51 let oek relational reduction machine input type oe arity k fixpoint formula oek fp oek proof let structure type oe using notation proof theorem 45 recall exists fp formula 1 defining oe type oe oe clearly query mapping absd oe relt oek p since absd oe ordered structure fp expresses p ordered structures imm86 var82 follows exists fp formula 2 defining mapping fp mapping oe relt oek obtained replacing variables representing class j k corresponding tuple variables equality test equivalence mtuples finally composition 1 0 2 yields desired fp formula oek theorem 51 supplies missing link relational machines fixpoint logics combining theorem 45 get 11 theorem 52 1 fp 2 fp n 3 fp 4 fp proof simulate relational machine fixpoint logic one first uses oek obtain relt oek uses logic simulate standard machine possible relt oek ordered structure theorem 27 fixpoint logics express corresponding standard complexity classes ordered structures theorem 52 contrasted theorem 27 theorem 27 talks fixpoint logic capturing complexity classes theorem 52 provides precise characterization expressive power fixpoint logics terms relational complexity classes immediate consequence theorem 52 fp fp n fp n n expressive power follows noninflationary fixpoint logic express problems nonuniversality finite automata truth quantified boolean formula albeit nonstraightforward fashion recall theorem 27 yielded separation fp fp n results demonstrate first time complexity theory yield unconditional results expressive power logics unordered structures 12 wish use relational complexity mediator fixpoint logic standard complexity corollary 46 relates standard complexity relational com plexity theorem 52 relates relational complexity fixpoint logic together 11 equalities fp shown av95 12 example complexity theory yields conditional results expressive power logics unordered structures appeared fag74 fagin showed existential universal secondorder logics coincide iff hamiltonicity expressible universal secondorder logic examples complexity theory yields unconditional results expressive powers logics ordered structures appeared imm82 imm87b immerman showed ordered structures logarithmic iteration firstorder formulas weaker exponential iteration firstorder formulas see also str94 bridge gap standard complexity fixpoint logic open questions complexity classes p exptime translated questions fixpoint logic 13 corollary 53 1 2 3 4 thus last three equivalences tantalizing questions complexity theory boil one fundamental issue relative power inflationary vs noninflationary 1storder operators 6 concluding remarks established general connection fixpoint logic complexity classes p exptime one side fixpoint logic parameterized choices 1storder operators iteration constructs side complexity classes p exptime connection intimate hampered order mismatch parameterized fixpoint logics capture complexity classes p exptime equality achieved ordered structures bridge mismatch used expanded theory relational com plexity bridges gap standard complexity fixpoint logic one hand show questions containments among standard complexity classes translated questions containments among relational complexity classes hand expressive power fixpoint logic precisely characterized terms relational complexity classes tight threeway relationship among fixpoint logics relational complexity standard complexity yields uniform way logical analogs containments among complexity classes p np pspace exptime logical formulation shows tantalizing questions complexity theory boil single question relative power inflationary vs noninflationary 1storder operators important note framework extend complexity classes p since construction order j k classes takes polynomial time results gro96 seems unavoidable fact many logics capture complexity classes p separated see imm87a gm92 gm92a 13 equivalence ppspace fp shown av95 r universality data retrieval languages fixpoint extensions firstorder logic dataloglike languages extensions database queries updates generic computation complexity computing firstorder logic computing infinitary logic moschovakis closure ordinals bounded arithmetics computable queries relational databases structure complexity relational queries journal acm relational completeness data base sublanguages algebra logic nc 1 infinitary logic inductive definability finite structures uniform definability finite structures succes sor generalized firstorder spectra polynomialtime recognizable sets monadic generalized spectra stable networks product graphs axiomatic recursive function theory computers intractability guide theory npcompleteness characterizing complexity classes highertype primitive recursive definitions spectra firstorder sentences computational complexity universal quantifiers time complexity random access machines deterministic versus nondeterministic transitive closure logic hierarchies transitive closure logic appear bounded linear logic modular approach polynomial time computability algebras feasible functions toward logic tailored computational complexity logic challenge computer science static logics introduction automata theory describing graphs firstorder approach graph canonization upper lower bounds firstorder expressibility relational queries computable polynomial time expressibility complexity measure results di rections languages capture complexity classes descriptive computational complexity turing machines spectra firstorder formulas infinitary logics 01 laws expressive power data log tools case study descriptive characterization computational complexity monotonic use space computational complexity abstract structures inductive definitions finite structures foundational delineation computational feasibility analysis fixed point queries binary trees relational model systems automatic testing relational model process control complexity classes theories finite models elementary induction abstract structures relational nondeterministic deterministic tape complexity logical approach problem p polynomial computability recursivity finite mains graph connectivity monadic np polynomialtime hierarchy finite automata relationships logic programs complexity theory database knowledgebase systems complexity relational query languages tr relational queries computable polynomial time languages capture complexity classes principles database knowledgebase systems vol relationships logics programs complexity theory descriptive characterizations computational complexity fixpoint extensions firstorder logic dataloglike languages characterizing complexity classes higher type primitive recursive definitions inductive definitions finite structures generic computation complexity extensions database queries updates analysis fixedpoint queries binary trees stable networks product graphs infinitary logics 0myampersandndash1 laws finite automata formal logic circuit complexity foundational delineation polytime infinitary logic inductive definability finite structures computing firstorder logic computing infinitary logic expressive power datalog nondeterministic languages express deterministic transformations alternation universality data retrieval languages introduction automata theory languages computation computers intractability logical approach problem pnp complexity relational query languages extended abstract uniform definability finite structures successor equivalence finitevariable logics complete polynomial time ctr jos mara turull torres study homogeneity relational databases annals mathematics artificial intelligence v33 n24 p379414 december 2001 jos mara turull torres relational databases homogeneity logics counting acta cybernetica v17 n3 p485511 january 2006 alexander leontjev vladimir sazonov settheoretic query language capturing logspace annals mathematics artificial intelligence v33 n24 p309345 december 2001 flavio ferrarotti jos turulltorres computation approximations database queries proceedings fifteenth australasian database conference p2737 january 01 2004 dunedin new zealand evgeny dantsin thomas eiter georg gottlob andrei voronkov complexity expressive power logic programming acm computing surveys csur v33 n3 p374425 september 2001 zhang baowen xu survey semantic description frameworks programming languages acm sigplan notices v39 n3 march 2004
assigning confidence conditional branch predictions many high performance processors predict conditional branches consume processor resources based prediction situations resource allocation better optimized confidence level assigned branch prediction ie quantity resources allocated function confidence level support optimizations consider hardware mechanisms partition conditional branch predictions two sets accurate relatively high percentage time accurate relatively low percentage time objective concentrate many mispredictions practical relatively small set low confidence dynamic branches first study ideal method profiles branch predictions sorts static branches high low confidence sets depending accuracy dynamically predicted find 63 percent mispredictions localized set static branches account 20 percent dynamic branches study idealized dynamic confidence methods using one two levels branch correctness history find single level method performs least well complex two level method able isolate 89 percent mispredictions set containing 20 percent dynamic branches finally study practical less expensive implementations find achieve performance idealized methods b introduction becoming common practice high performance processors predict conditional branches 4 7 9 13 speculatively execute instructions based prediction 2 8 typically speculation used branch predictions acted upon low penalty speculating incorrectly ie resources available speculative instructions would unused anyway average branch prediction correct high percentage time however processors become advanced envision implementations penalty incorrect speculation may high enough may better speculate instances likelihood branch misprediction relatively high may desirable vary behavior depending likelihood misprediction consequently would like develop hardware methods assessing likelihood conditional branch prediction correct refer branch prediction confidence mechan isms consider following potential applications selective dual path execution resources may made available simultaneously executing instructions paths following conditional branch ever likely expensive follow paths branches especially several conditional branches may unresolved given time conse quently may desirable set limit two threads given time fork second execution thread nonpredicted path instances branch prediction made relatively low confidence predicted branches predicted path would speculatively followed occasionally paths would followed guiding instruction fetching simultaneous multithreading smt instruction fetching identified critical resource 10 resource efficiently used fetching instructions predicted paths high likelihood correctly predicted threads predicted high confidence given priority low confidence reduce number wasted instruction fetches caused following wrong speculative path dynamic selector hybrid branch predictor hybrid branch predictors 1 5 use one predictor select prediction made one based history prediction accuracies constituent predictors methods proposed 1 5 basically ad hoc confidence mechanisms developed specific application studying confidence mechanisms gen eral may able arrive accurate hybrid selectors branch prediction reverser confidence branch prediction determined less 50 prediction reversed hence confidence mechanism could used generate reverse prediction signal branch predictions less 50 accuracy theory one could focus developing hardware computes probabilities individual branch predictions correct incorrect however practice could rather complex division implied computed probability branch really wanted anyway rather attempt divide branch predictions two sets high confidence low confidence binary signal generated simultaneously branch prediction indicate confidence set prediction belongs pair prediction confidence signals illustrated fig 1 see confidence signal could used consider four applications listed 1 selective dual path execution confidence signal used trigger forking second thread low confidence branch predictions 2 smt instruction fetching application confidence signal used enable instruction fetching speculative threads high confidence designing hybrid prediction selector confidence signals multiple predictors compared select prediction used reverser application confidence threshold set approximately 50 accuracy confidence signal used reverse prediction applications would like divide predictions high low confidence sets concentrate many mispredicted branches branch taken taken execution pipelines highlow confidence mechanism confidence instruction fetch unit fig 1 generic speculative processor containing branch prediction signal paired highlow confidence signal possible low confidence set time keeping low confidence set relatively small note general one could divide branches multiple sets range confidence levels date pursued generalization consider two confidence sets paper generate signal separates two confidence sets propose using benchmarks collect prediction accuracy data data used design logic high low confidence sets characteristics desire note logic designed using data selected benchmarks ever implemented confidence logic used programs simplify hardware design dynamically adjust criteria determining high low confidence sets 11 previous work 9 proposal assigning confidence levels different counter values predictors based saturating counters also relatively abstract example optimizing performance speculating different degrees based confidence level 12 authors use branch probability levels guide disjoint eager execution forking multiple threads multiple threads forked probable forked first difficulties dynamically computing probabilities static profilebased probabilities used suggested implementation regarding specific application reversing predictions processors static prediction bits livermore s1 3 made static branch prediction dynamic reverse bit instruction cache used reverse static prediction found incorrect recent makes prediction based opcode direction branch allows compiler place reverse bit instruction change default prediction 12 simulation methodology collected branch prediction accuracy data using tracedriven simulation benchmarks used mach version ibs benchmark suite 11 chosen accurately represent branch characteristics real programs commonly used spec benchmarks include kernel code arrive composite data collection benchmarks averaging weighting results benchmark effect executes number conditional branches important part study underlying branch predictor simulations use fairly aggressive predictor gshare predictor 5 2 saturating 2bit counter counter array addressed exclusiveor bits 17 2 program counter recent 16 branch outcomes held branch history register bhr section 5 consider performance using less expensive predictors 13 paper overview focus methods assigning confidence branch predictions applications confidence methods currently investigating interesting applications goal establish set base confidence methods use starting point studies section 2 collect branch prediction accuracy statistics relate static branches exercise establishes general method use display confidence results suggests optimal static confidence method use baseline comparing dynamic methods fol low section 3 look number general dynamic confidence methods using one two levels tables section 4 give experimental results dynamic methods using ibs benchmark suite section 5 consider practical implementation issues dynamic confidence methods goal reducing logic complexity cost section 6 concludes paper 2 analysis static branches first consider idealized method static branches assigned either high low confidence levels based accuracy predicted begin relatively powerful gshare dynamic predictor described section 12 collect statistics static branch 1 number times branch executed 2 number incorrect predictions consequently misprediction rate static branch generated combine branches benchmarks normalize benchmark effectively contributes number dynamic branches next sort static branches according misprediction rates highest rate first concentrates difficult predict static branches top sorted list sorted list used divide predicted branches low high confidence sets course many sets possible depending define low high thus far vague point understand range possibilities go sorted list branch statistics plot accumulated fractions mispredicted branches versus accumulated fractions executed branches produce ibs benchmarks fig 2 resulting plot note graph discrete data points although run together plotted corresponding2060100 mispredicts dynamic branches static fig 2 cumulative mispredictions versus cumulative dynamic branches static branch occurs sorted list point defines pair high low confidence branch prediction sets interpret graph consider data point 252706 marked graph point 252 percent dynamic branches accumulated time reach static branch question 706 mispredictions included separate branches 252 percent executed branches placed low confidence set account 706 percent mispredictions general shape curve steep rise rounds knee nearly horizontal line particular curve static branches rather gentle knee dynamic methods given next section much sharper knees steeper initial slope farther left knee occurs better curve shape mispredictions concentrated within smaller set low confidence predic tions words branches lower confidence set higher misprediction rate con versely branches higher confidence set lower misprediction rate ideal low confidence set would consist solely mispredicted branches corresponding graph would straight line parallel yaxis shifted right origin mispredict rate one could develop static branch confidence method based procedure followed one could profile branches done threshold misprediction rate could set static branches threshold tagged one way low confidence tagged another high confidence alternatively fraction mispredictions could chosen corresponding set static branches could selected low confidence ones static confidence method described graph fig 2 provides optimistic estimate per formance method optimistic represents perfect profiling executing programs exactly data profile nevertheless use results optimistic static method comparison dynamic methods consider following sections minimum would like dynamic methods exceed performance static method 3 dynamic confidence mechanisms previous section partitioned static branches high low confidence sets dynamic predictions static branch assigned confidence set however also partition branches dynamic predictions static branch assigned different confidence sets partitioning done based dynamic history refer dynamic confidence mechanisms large number dynamic confidence mechanisms available first cousins dynamic branch predictors many branch predictors proposed years 4 7 9 13 paper cannot explore entire design space select representative confidence methods preliminary experiments indicated interesting variations begin generic confidence mechanisms somewhat idealized section 5 refine practical implementations 31 onelevel confidence methods one level dynamic confidence methods sonamed use single level table lookup illustrated fig 3 table contains n recent correctincorrect indications given table entry nbit entries essentially shift registers call correctincorrect register cir pronounced sir refer entire table table ct use convention 1 cir indicates incorrect prediction 0 indicates correct prediction example prediction correct 3 times followed incorrect prediction followed 4 correct predictions 8bit cir contains 00010000 number possibilities accessing table one truncated program counter branch instruction used index ct alter natively one could keep track global branch outcomes branch history register bhr use index ct third alternative maintain global cir ie correctincorrect status collected recent dynamic branches use index ct beginning three basic methods indexing ct pc global bhr global cir one construct number others concatenating portions program counter bits global bhr cir history table 2m entries n bit entries reduction function confidence highlow signal fig 3 one level dynamic confidence mechanisms exclusiveoring preliminary studies done indicate exclusiveoring effective concatenating subfields however influenced table size deserves study preliminary studies also indicate indexing global cir little value gives low performance used alone typically reduces performance added others consequently report results implementations using pc global bhr leads three variations indexing ct pc alone global bhr alone pc xor bhr divide branches two sets take cir accessed table reduce single binary signal general passing cir combinational logic block named reduction function fig 3 example reduction function could perform ones count cir ones indicate higher number recent mispredictions would tend indicate lower accuracy section 5 consider ones count reduction function along others actual implementation complete cirs could kept ct separate logic block implementing reduction function exactly shown fig 3 however one might also use implementations maintain compressed form cirs ct along simplified reduction function discussed section 5 32 two level methods two level dynamic confidence methods index first level ct manner similar one level methods combine cir read table combination pc global bhr index second level ct second level table contains correctincorrect values p recent times first level cirpcbhr combination occurred finally cir read second level table passes combinational reduction function previous one level methods reduction function 2m entries cir history table level 1 level 2 n bit entries program counter bits global bhr cir history table 2n entries highlow confidence signal fig 4 two level dynamic confidence mechanisms several variations twolevel method refer fig 4 general one hash combination pc global bhr first table hash output first table combination pc global bhr leads 12 different possibilities two level structures could probably made one could consider using global cir computing index second level table example preliminary exploration settle three representative methods first variation pc alone used read first table cir alone used access second level table second variation pc xor bhr used read first level table cir read table used read second level table third variation like second except pc bhr exclusiveored cir read first level table indexing second level table 4 experimental results use tracedriven simulation study dynamic confidence methods outlined previous sec tion stated earlier underlying branch predictor gshare predictor using table 2 16 twobit counters prediction table accessed exclusiveor low order pc bits 16 bit global bhr one level confidence methods cir tables also entries contains simulate ibs benchmark suite results averaged weighting individual benchmarks contributes total number dynamic branches relatively large underlying branch predictor use overall misprediction rate 385 percent methods initialize branch predictor table weakly taken cir tables ones ones found give better results initial ct values studied additional information initial values given section 5 initially collect separate statistics cir value read ct second level ct case two level methods cir pattern keep track number times pattern appears fraction incorrect predictions occurred cir pattern read collecting data cir pattern sort construct graph similar used static method section 2 particular sort cir patterns according misprediction rates highest rate top sorted list used plot data points one per cir point x axis value fraction accumulated conditional branches corresponding cir higher list axis value fraction mispredictions conditional branches account point used define high low confidence prediction sets combinational reduction function detects sets selects cirs low confidence high confidence cir question cirs define minterms reduction function static method method determining confidence sets idealized reduction function tuned specific set data input values addition combinational reduction function could complicated ie could many prime implicants many could conceivably minterms section 5 look practical reduction functions 41 one level methods fig 5 gives performance graphs one level methods indexing pc alone global bhr alone pc xor bhr note order avoid data points running together fig 2 plot points differ previous point 25 percent best method one concentrates largest set mispredictions smallest set predictions uses pc xor bhr index table reason pc bhr together precisely establish context branch question either alone essen tially reasoning leads gshare predic tor close second performance indexes global bhr alone worst performance provided using pc alone consider points curves correspond low confidence set containing 20 percent branch predictions 20 percent chosen rather arbitrarily illustrative purposes indexing pc xor bhr concentrates 89 percent mispredictions low confidence set bhr alone concentrates 85 percent pc concentrates 72 percent also shown fig 5 graph curve static method given section 2 see dynamic methods capable performing much better optimistic static method comparison static method 20 percent branches concentrate 63 percent mispredictions dynamic methods zeros cir occurs frequently refer zeros ct entry zero bucket zero bucket corresponds case table entry seen correct prediction last times row surprising zero bucket accessed frequently given overall prediction accuracy 9615 percent large zero bucket explains long gap data points dynamic methods right side graph example two better dynamic methods 80 percent branch predictions lead zeros cir 1215 percent mispredictions occur zeros cir hence 20 100 percent dynamic branch region graph dynamic methods data points static method data points however points allow static curve arc interpolated curves dynamic methods region finally note dynamic results idealized way similar way static branches particular sort cirs worst best based performance ibs bench marks effectively use optimal reduction function resulting ct look practical reduction functions level optimism mitigated2060100 mispredicts dynamic branches static pc bhr bhrxorpc fig 5 cumulative mispredictions versus cumulative dynamic branches one level dynamic confidence methods 42 two level methods consider two level confidence methods results shown fig 6 best method accesses first level table pc xor bhr second level table accessed cir read first level table method accesses first level table pc xor bhr second level table first level cir xor pc xor bhr generally second best performer however region 5 10 percent range xaxis third method accessing first level cir second level slightly better otherwise third method worse two level methods chose simulate one level methods zeros ct entry large leads data points 1030 percent region 100 percent point xaxis fig 7 compare best one level method fig 5 best two level method fig static method fig 2 see one two level methods give similar performance anything two level method performs slightly worse main difference presence absence second level table first level tables identical consequently conclude extra hardware second level table worth cost least use ideal reduction functions additional studies realistic reduction functions tend reinforce conclu sion consider two level tables paper2060100 mispredicts dynamic branches static pccir bhrxorpccir bhrxorpcbhrxorcirxorpc fig 6 cumulative mispredictions versus cumulative dynamic branches two level dynamic confidence methods mispredicts dynamic branches static bhrxorpc bhrxorpccir fig 7 comparison best one level two lev el static methods 5 implementation issues section apply results previous section arrive actual implementations first look reduction functions consider call granularity issue cost considerations initialization issues 51 reduction functions propose simple reduction functions compare results provide relatively optimistic results previous section obvious reasons reducing cost andor logic complexity would like simple reduction functions arrived three inspection sorted lists cirs guided intuition already observed pc xor bhr indexing performs best one level methods studied consequently section focus method note occasionally refer method simply best even though best studied ones counting first consider counting ones cirs read table reasoning ones cir higher number recent mispredictions therefore likely future mispredict cirs length 16 study given 17 data points 0 ones ie mispredictions last 16 single one ie one mispredict etc 16 ones results ones counting reduction methods considered section plotted fig 8 graph plot optimistic reduction function trying approximate optimistic curve discrete data points plotted make points easier read note ones counting zero bucket lines optimistic zero bucket one level method ones counting falls short optimum data points however reason one level table significant time ordering cir recent predictions represented time sequence ever recent mispredictions eg recent correlate better older ones eg predictions ago yet ones counting given equal weight saturating counters second reduction function consider saturating ones count cir values expect method perform better ones counting however could lead less costly confidence method saturating counters embedded ct place cirs leading essentially logarithmic reduction table space using counters count 0 16 allow us compare directly ones counters preceding subsection although slightly less expensive implementation would count 0 15 count correct prediction incorrect one saturating extremes 0 16 17 data points plot fig 8 see saturating counters potential deficiency particular equivalent zero bucket maximum saturated counter becomes significantly larger ie contains mispredicted branches happens branches correctly predicted vast majority time usually access maximum saturated counter single misprediction followed correct prediction saturating count nonmaximum one branch hand full cir kept ones count used single misprediction lead to2060100 mispredicts dynamic branches bhrxorpc bhrxorpc1cnt bhrxorpcreset bhrxorpcsat fig 8 confidence graph one level method reduction via ones counting saturating counting resetting counting nonzero cir next 16 branches means many nonzero cirs containing single one con verted maximum saturated count value portions curves extreme left graph ie zero bucket region reached saturating counters behave well ones count ing consequently choose partition confidence sets region ie 10 percent fewer dynamic branches low confidence set containing 60 percent mispredictions saturating counters appear adequate however large maximum saturated counter region makes impossible partition larger low confidence set ie containing 60 percent mispred ictions consequently might like find better method costsaving saturating counters maintains zero bucket characteristics optimal curve resetting counters third algorithm arrived examining sorted lists cirs observed cir patterns account dynamic branches particular containing zeros single one reflects high accuracy underlying branch predictor suggests capture information fulllength cirs keeping track time recent misprediction occurred accomplished incrementing counter held ct time corresponding branch predicted correctly resetting counter zero misprediction counter saturates 16 match cir counter sizes used preceding subsections fig 8 shows results resetting counter compared ideal reduction function ones count ing saturating counters see resetting counter works quite well tracks ideal curve closely zero bucket addition observed earlier saturating counters resetting counters replace fulllength cirs ct yielding logarithmic cost savings conclude resetting counters probably best choice implementing confidence methods practical manner 52 threshold granularity producing confidence sets practice note mercy natural buckets result reduced cirs example using resetting counters establish confidence sets data points determined 17 resetting counter values table 1 contains 17 data points defined best single level method using resetting counters count 0 16 counters saturate 16 first column contains counter value second misprediction rate counter shown first column third fourth columns percentages references mispredictions occur table 1 statistics resetting counter values count mis cum cum pred refs mis mis rate preds refs preds 9 058 798 119 164 849 counter value fifth sixth columns cumulative reference misprediction percentages top table use count value 0 define low confidence set could isolate 417 percent mispredictions set 428 percent branch predictions course would need singlebit counter accomplish similarly use count 0 1 could isolate 579 percent mispredictions within set 685 percent branch predictions etc maximum count 16 equivalent zero bucket fulllength cirs consequently use counter values 0 15 isolate 893 percent mispredictions set 203 percent branches relatively large zero bucket region defined saturated counter achieve finer granularity could however use larger counters get somewhat better granularity approach limited finally note using tables reduction functions programs yet discussing confidence levels particular set bench marks variation confidence sets depending individual benchmark program considering ibs benchmarks fig 9 shows confidence curves best jpeg worst gcc performing ibs benchmarks using best single level method ideal reduction see considerable variation zero buckets appear contain approximately fractions mispredictions total number branches zero bucket varies considerably importance characteristic depend application confidence mispredicts dynamic branches gcc jpeg fig 9 confidence graphs best jpeg worst gcc performing benchmarks best one level confidence method ideal reduction used mechanism applied 53 cost considerations study thus far assumed fairly large relatively expensive predictors confidence methods reduce aliasing effects could get idea pure implementation might per form however also consider smaller less expensive implementations fully explore design space rather choose particular small predictor investigate performance single level confidence method aliasing present use series small confidence history tables illustrate falloff performance reduce table size smaller underlying branch predictor use gshare branch predictor 4k entries consisting saturating 2bit counters predictor accessed exclusiveor bits 132 branch program counter 12 bits global branch history misprediction rate predictor ibs benchmarks 86 percent implemented confidence mechanism uses best single level method accessed way gshare predictor resetting counters held ct simulate tables size predictor 4k entries 128 entries results plotted fig 10 see case confidence table size predictor relative performance somewhat less larger table studied note zero bucket regions ie counters maximum values contain fraction mispredictions fewer overall branches region put another way low confidence sets contain fraction mispredictions larger sets occurs aliasing takes place branch accessing table entry suffers misprediction counter resets take least 16 correct predictions counter reenter saturated state hence aliased counters likely spend time nonsaturated state nevertheless performance still fairly good 75 percent mispredictions identified 20 percent conditional branches suggests confidence method applied smaller less costly predictors used case prediction confidence tables number entries cost confidence method twice underlying predictor 4bit resetting counters versus 2bit saturating counters fig 10 also see performance diminishes wellbehaved manner confidence table reduced size loss doubt due alias ing make definite statement one table size costeffective another however would require knowledge application confidence method used performancesimulation model application using confidence method would used determine actual performance impact confidence sets 54 effect initial state course study found initial state cirs held ct important it2060100 mispredicts dynamic branches 4096 2048 1024 512 256 128 fig 10 performance small cir tables tables hold resetting counters accessed pc xor bhr takes long time tables build history number possibilities initializing cirs example one could initialize cirs 0s 1s random another alternative initialize cirs context switches study alternative fig 11 shows results ideal one level method using ct 2 16 entries see 1s random perform similarly 0s perform nearly well mentioned differences ct fairly deep memory initial state effects still appear even benchmarks run full length 0s initialization increases number branches zero bucket benchmark begins startup likely higher number mispredictions initially zero cirs assign high confidence hand nonzero initial value tend assign lower confidence however exactly nonzero initial value used seem make much difference better performance provided avoiding zeros reasonable alternative initialize oldest bit cir 1 others zero refer lastbit results shown fig along initial values see performance essentially nonzero methods experiment conjecture one could probably leave cirs current values time context switch except oldest bit initialized 1 would tend simplify initialization hardware provide good performance mispredicts dynamic branches one zero lastbit random fig 11 effect different ct initializa tions best one level confidence method ideal reduction used 6 conclusions implementing confidence methods large design space probably large branch pred iction many branch prediction methods proposed studied years consequently methods proposed means comprehensive goal introduce concept assigning confidence branch predictions look characteristics methods doubt many possible methods explored looking static branches indicates predicted higher confidence others better separate low high confidence predictions one must look dynamic information similar case branch prediction predictors taking dynamic context account perform better static predictors dynamic confidence methods indeed better static ones even ideal static method general appears single level dynamic methods work well two level methods less expensive reduction functions found resetting counters work well counters embedded cir table reduce cost study large 64k predictors confidence tables using smaller 4k predictors smaller confidence tables 4k smaller found confidence methods performed relatively worse reason use resetting counters tends amplify negative effects aliasing applications mentioned currently researching three four studying potential performance benefits selective dual thread forking well aspects implementation application data single level methods indicate fork dual thread following 20 percent conditional branch predictions capture 80 percent mispredictions conjecture adequate provide worthwhile performance gains also studies reverser hybrid prediction selector underway reverser application looks promising key issue whether costperformance predictor plus reverser better costperformance powerful predictor indeed predictorreverser model could considered method decomposing design powerful pred ictor study hybrid prediction selector begun optimistic work branch confidence lead systematic way developing nearoptimal selectors acknowledgements work supported part nsf grant mip9505853 us army intelligence center fort huachuca contract dabt6395c0127 arpa order d346 views conclusions contained herein authors interpreted necessarily representing official policies endorsements either expressed implied us army intelligence center fort huachuca us government eric rotenberg funded ibm graduate fellowship erik jacobsen funded wisconsinhilldale undergraduate research scholarship authors would like thank joel emer helpful discussions work progress suggesting potential applications r using hybrid branch predictors improve branch prediction accuracy presence context switches mips r10000 uses decoupled architecture s1 architecture manual branch prediction strategies branch target buffer design combining branch predictors improving accuracy dynamic branch prediction using branch correlation amds k5 designed outrun pentium study branch prediction stra tegies exploiting choice instruction fetch issue implementable simultaneous multithreading processor instruction fetching coping code bloat disjoint eager execu tion optimal form speculative execution twolevel adaptive branch prediction tr twolevel adaptive training branch prediction improving accuracy dynamic branch prediction using branch correlation instruction fetching disjoint eager execution using hybrid branch predictors improve branch prediction accuracy presence context switches exploiting choice study branch prediction strategies architecture manual ctr artur klauser srilatha manne dirk grunwald selective branch inversion confidence estimation branch predictors international journal parallel programming v29 n1 p81110 february 2001 james e smith retrospective study branch prediction strategies 25 years international symposia computer architecture selected papers p2223 june 27july 02 1998 barcelona spain amirali baniasadi andreas moshovos instruction flowbased frontend throttling poweraware highperformance processors proceedings 2001 international symposium low power electronics design p1621 august 2001 huntington beach california united states steven wallace brad calder dean tullsen threaded multiple path execution acm sigarch computer architecture news v26 n3 p238249 june 1998 yuan chou jason fung john paul shen reducing branch misprediction penalties via dynamic control independence detection proceedings 13th international conference supercomputing p109118 june 2025 1999 rhodes greece jinson j koppanalil eric rotenberg simple mechanism detecting ineffectual instructions slipstream processors ieee transactions computers v53 n4 p399413 april 2004 gary tyson todd austin memory renaming fast early accurate processing memory communication international journal parallel programming v27 n5 p357380 oct 1999 robert chappell francis tseng adi yoaz yale n patt microarchitectural support precomputation microthreads proceedings 35th annual acmieee international symposium microarchitecture november 1822 2002 istanbul turkey gregory muthler david crowe sanjay j patel steven lumetta instruction fetch deferral using static slack proceedings 35th annual acmieee international symposium microarchitecture november 1822 2002 istanbul turkey pritpal ahuja kevin skadron margaret martonosi douglas w clark multipath execution opportunities limits proceedings 12th international conference supercomputing p101108 july 1998 melbourne australia takashi yokota kanemitsu ootsu takanobu baba introducing entropies representing program behaviors branch predictor performances experimental computer science experimental computer science p1818 june 1314 2007 san diego j adam butts guri sohi dynamic deadinstruction detection elimination acm sigops operating systems review v36 n5 december 2002 chienming chen chungta king walktime address adjustment improving accuracy dynamic branch prediction ieee transactions computers v48 n5 p457469 may 1999 artur klauser abhijit paithankar dirk grunwald selective eager execution polypath architecture acm sigarch computer architecture news v26 n3 p250259 june 1998 daniel holmes friendly sanjay jeram patel yale n patt alternative fetch issue policies trace cache fetch mechanism proceedings 30th annual acmieee international symposium microarchitecture p2433 december 0103 1997 research triangle park north carolina united states enric musoll predicting usefulness block result microarchitectural technique highperformance lowpower processors proceedings 32nd annual acmieee international symposium microarchitecture p238247 november 1618 1999 haifa israel ayose falcon jared stark alex ramirez konrad lai mateo valero better branch prediction prophetcritic hybrids ieee micro v25 n1 p8089 january 2005 dirk grunwald artur klauser srilatha manne andrew pleszkun confidence estimation speculation control acm sigarch computer architecture news v26 n3 p122131 june 1998 srilatha manne artur klauser dirk grunwald pipeline gating speculation control energy reduction acm sigarch computer architecture news v26 n3 p132141 june 1998 andreas moshovos checkpointing alternatives high performance poweraware processors proceedings international symposium low power electronics design august 2527 2003 seoul korea tanaus ramrez alex pajuelo oliverio j santana mateo valero simple speculative load control mechanism energy saving proceedings 2006 workshop memory performance dealing applications systems architectures p2936 september 1620 2006 seattle washington craig zilles gurindar sohi executionbased prediction using speculative slices acm sigarch computer architecture news v29 n2 p213 may 2001 yiannakis sazeides james e smith modeling program predictability acm sigarch computer architecture news v26 n3 p7384 june 1998 eduardo quiones joanmanuel parcerisa antonio gonzalez selective predicate prediction outoforder processors proceedings 20th annual international conference supercomputing june 28july 01 2006 cairns queensland australia artur klauser dirk grunwald instruction fetch mechanisms multipath execution processors proceedings 32nd annual acmieee international symposium microarchitecture p3847 november 1618 1999 haifa israel haitham akkary ravi rajwar srikanth srinivasan checkpoint processing recovery towards scalable large instruction window processors proceedings 36th annual ieeeacm international symposium microarchitecture p423 december 0305 glenn reinman brad calder dean tullsen gary tyson todd austin classifying load store instructions memory renaming proceedings 13th international conference supercomputing p399407 june 2025 1999 rhodes greece matthew c chidester alan george matthew radlinski multiplepath execution chip multiprocessors journal systems architecture euromicro journal v49 n12 p3352 july david n armstrong hyesoon kim onur mutlu yale n patt wrong path events exploiting unusual illegal program behavior early misprediction detection recovery proceedings 37th annual ieeeacm international symposium microarchitecture p119128 december 0408 2004 portland oregon chenyong cher n vijaykumar skipper microarchitecture exploiting controlflow independence proceedings 34th annual acmieee international symposium microarchitecture december 0105 2001 austin texas hyesoon kim jos joao onur mutlu yale n patt profileassisted compiler support dynamic predication divergemerge processors proceedings international symposium code generation optimization p367378 march 1114 2007 robert chappell francis tseng adi yoaz yale n patt difficultpath branch prediction using subordinate microthreads acm sigarch computer architecture news v30 n2 may 2002 zach purser karthik sundaramoorthy eric rotenberg study slipstream processors proceedings 33rd annual acmieee international symposium microarchitecture p269280 december 2000 monterey california united states andrew hilton amir roth ginger control independence using tag rewriting acm sigarch computer architecture news v35 n2 may 2007 tejas karkhanis james e smith pradip bose saving energy time instruction delivery proceedings 2002 international symposium low power electronics design august 1214 2002 monterey california usa satish narayanasamy ayse k coskun brad calder transient fault prediction based anomalies processor events proceedings conference design automation test europe april 1620 2007 nice france nikolaos bellas ibrahim hajj constantine polychronopoulos using dynamic cache management techniques reduce energy highperformance processor proceedings 1999 international symposium low power electronics design p6469 august 1617 1999 san diego california united states enric musoll speculating reduce unnecessary power consumption acm transactions embedded computing systems tecs v2 n4 p509536 november patrick akl andreas moshovos branchtap improving performance checkpoints adaptive speculation control proceedings 20th annual international conference supercomputing june 28july 01 2006 cairns queensland australia craig b zilles gurindar sohi understanding backward slices performance degrading instructions acm sigarch computer architecture news v28 n2 p172181 may 2000 karthik sundaramoorthy zach purser eric rotenburg slipstream processors improving performance fault tolerance acm sigarch computer architecture news v28 n5 p257268 dec 2000 srinivas mantripragada alexandru nicolau using profiling reduce branch misprediction costs dynamically scheduled processor proceedings 14th international conference supercomputing p206214 may 0811 2000 santa fe new mexico united states rakefet kol ran ginosar kin karthik sundaramoorthy zach purser eric rotenberg slipstream processors improving performance fault tolerance acm sigplan notices v35 n11 p257268 nov 2000 ayose falcon jared stark alex ramirez konrad lai mateo valero prophetcritic hybrid branch prediction acm sigarch computer architecture news v32 n2 p250 march 2004 veerle desmet lieven eeckhout koen de bosschere improved composite confidence mechanisms perceptron branch predictor journal systems architecture euromicro journal v52 n3 p143151 march 2006 timothy sherwood brad calder automated design finite state machine predictors customized processors acm sigarch computer architecture news v29 n2 p8697 may 2001 daniel jimnez calvin lin neural methods dynamic branch prediction acm transactions computer systems tocs v20 n4 p369397 november 2002 hyesoon kim onur mutlu jared stark yale n patt wish branches combining conditional branching predication adaptive predicated execution proceedings 38th annual ieeeacm international symposium microarchitecture p4354 november 1216 2005 barcelona spain haitham akkary ravi rajwar srikanth srinivasan analysis resource efficient checkpoint architecture acm transactions architecture code optimization taco v1 n4 p418444 december 2004 steven swanson luke k mcdowell michael swift susan j eggers henry levy evaluation speculative instruction execution simultaneous multithreaded processors acm transactions computer systems tocs v21 n3 p314340 august dirk grunwald microarchitecture design control speculation energy reduction power aware computing kluwer academic publishers norwell 2002 juan l aragn jos gonzlez antonio gonzlez james e smith dual path instruction processing proceedings 16th international conference supercomputing june 2226 2002 new york new york usa glenn reinman brad calder predictive techniques aggressive load speculation proceedings 31st annual acmieee international symposium microarchitecture p127137 november 1998 dallas texas united states alper buyuktosunoglu tejas karkhanis david h albonesi pradip bose energy efficient coadaptive instruction fetch issue acm sigarch computer architecture news v31 n2 may brad calder glenn reinman dean tullsen selective value prediction acm sigarch computer architecture news v27 n2 p6474 may 1999 kevin skadron pritpal ahuja margaret martonosi douglas w clark improving prediction procedure returns returnaddressstack repair mechanisms proceedings 31st annual acmieee international symposium microarchitecture p259271 november 1998 dallas texas united states hyesoon kim jose joao onur mutlu yale n patt divergemerge processor dmp dynamic predicated execution complex controlflow graphs based frequently executed paths proceedings 39th annual ieeeacm international symposium microarchitecture p5364 december 0913 2006 trace processors proceedings 30th annual acmieee international symposium microarchitecture p138148 december 0103 1997 research triangle park north carolina united states chunrong lai shihlien lu yurong chen trista chen improving branch prediction accuracy parallel conservative correctors proceedings 2nd conference computing frontiers may 0406 2005 ischia italy yiannakis sazeides james e smith limits data value predictability international journal parallel programming v27 n4 p229256 aug 1999 zhijian lu john lach mircea r stan kevin skadron alloyed branch history combining global local branch history robust performance international journal parallel programming v31 n2 p137177 april
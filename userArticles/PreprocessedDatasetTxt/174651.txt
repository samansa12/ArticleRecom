really temporal logic introduce temporal logic specification realtime systems logic tptl employs novel quantifier construct referencing time freeze quantifier binds variable time local temporal context tptl natural language specification suitable formalism verification present tableaubased decision procedure modelchecking algorithm tptl several generalizations tptl shown highly undecidable b introduction linear temporal logic widely accepted language specifying properties reactive systems behavior time pnu77 ol82 mp92 tableaubased satisfiability algorithm propositional version ptl forms basis automatic verification synthesis finitestate systems lp84 mw84 ptl interpreted models abstract away actual times events occur retaining temporal ordering information states system analysis systems hard realtime requirements bounded response time calls however development formalisms explicit time several attempts made introduce time explicitly ptl interpret models associate time every system state bh81 ph88 koy90 ost90 logics allow specification typical realtime requirements important decidability complexity questions answered particular understood timing constraints may permitted ptl without sacrificing decidability verification problem objective development realtime extension ptl admits generalization ptlbased tools algorithmic verification begin notational extension ptl must capable relating times different system states one commonly proposed method research supported part ibm graduate fellowship second author national science foundation grants ccr8812595 ccr9200794 defense advanced research projects agency contract n0003984c0211 united states air force office scientific research contracts afosr 880281 f496209310056 preliminary version paper appeared proceedings 30th ieee symposium foundations computer science focs 1989 pp 164169 extended version appeared journal acm 41 1994 pp 181204 employs firstorder temporal logic one state variables representing time ph88 ost90 la92 claim unconstrained quantification time variables allowed approach restrict user reasonable readable specifications instead propose novel restricted form quantification call freeze quantification every variable bound time particular state freeze quantification identifies argue precisely subclass intended specifications leads concise readable notation instance typical timebounded response requirement every request p followed response q within asserted formula read whenever request p variable x frozen current time request followed response q time x secondly need identify expressive theory time may added fashion ptl without sacrificing elementary complexity main results twofold develop nearoptimal decision procedure modelchecking algorithm realtime ptl restricting syntax timing constraints precision time model show restrictions cannot relaxed without losing decidability particular adding ptl theory natural numbers successor ordering congruence operations yields expspacecomplete realtime temporal logic tptl tableau method ptl generalized tptl however allowing either addition time dense time domain results highly undecidable pi 1 logics thus lay theoretical basis automatic verification finitestate realtime systems simultaneously identify boundary decidability undecidability finitestate formalisms explicit time alternative approaches automatic verification realtime systems using temporal logic include work branchingtime logic rtctl emss89 explicitclock logic xctl hlp90 rtctl makes simplifying assumption modeling synchronous realtime systems whose events occur ticks global clock case xctl formulas quantifierfree variables implicitly universally quantified makes difficult compose requirements like asserting implementation implies specification find restrictions unnecessary since earlier version paper published ah89 many new results concerning realtime temporal logics obtained acd90 ah90 afh91 wme92 point hen90 complete axiomatization tptl ah92 survey recent results timed temporal logic define timed propositional temporal logic tptl demonstrate adequacy realtime specification language 21 timed state sequences formulas tptl interpreted timed state sequences let p set proposition let n set nonnegative integers state interpretation propositions p timed state sequence infinite sequence states labeled time discrete time domain timed state sequence state sequence oe infinite sequence states oe infinite sequence times 2 0 monotonicity progress 2 0 timed state sequence ae oe pair consisting state sequence oe time sequence oe denote state time sequence results state sequence oe time sequence deleting first elements let ae use convention point words model time order time discrete state counter rather time successive states timed state sequence may remain may increase arbitrary amount state counter would suffice model synchronous realtime systems events asynchronous processes take place dense time domain reasoning dense time hand may prohibitively difficult see section 4 compromise fictitiousclock digitalclock assumption realtime systems enjoyed increasing popularity ah92 hmp92 true dense times events recorded finite precision discrete clock definition timed state sequences chosen sufficiently general accommodate fictitiousclock assumption states successive clock ticks labeled identical times 22 syntax semantics tptl given infinite supply v variables x formulas tptl built proposition symbols timing constraints boolean connectives temporal operators freeze quantifiers tptl terms formulas oe tptl inductively defined follows constants c 2 n 6 0 timing constraints timing constraints tptl form 1 2 congruent time 2 modulo constant abbreviations x defined usual term formula oe contains variable say oe contains absolute time references hand term formula may contain one variable logical point view restriction confines tptl successor operation time define terms using unary successor rather determining length formula assume constants given reasonably succinct eg binary encoding size formula important locating computational complexity problems whose input includes formulas tptl temporal operators tptl based two temporal operators ptl gpss80 next formula flp asserts timed state sequence second state sequence satisfies proposition p formula p u q asserts timed state sequence state satisfying proposition q states qstate satisfy proposition p additional temporal operators defined usual particular eventually operator 3oe stands true u oe always operator 2oe stands 3oe freeze quantifier variable x bound freeze quantifier x freezes x time local temporal context let oex formula variable x occurs freely x oex asserts timed state sequence ae oe oe 0 satisfied ae formula oe 0 obtained oex replacing free occurrences variable x constant 0 example formula variable x bound time state proposition p eventually satisfied asserts p satisfied state time 10 similarly formula asserts whenever proposition p satisfied state time 10 ie p satisfied time 10 intuition captured formally following definition definition 3 semantics tptl let ae oe timed state sequence let interpretation environment variables pair ae e satisfies tptlformula satisfaction relation j inductively defined follows ae ae ae ae ae ae ae ae ex denotes environment agrees environment e variables except x maps x 2 tptlformula closed every occurrence variable x within scope freeze quantifier x shall henceforth consider closed formulas tptl truth value closed formula completely determined timed state sequence alone timed state sequence ae model closed tptlformula oe denoted ae e satisfies oe environment e formula oe satisfiable valid every timed state sequence ae two formulas equivalent models 23 tptl specification language compare tptl alternative extensions ptl explicit time references particular show freeze quantification viewed constrained form classical ie universal existential quantification versus firstorder temporal logic freeze quantifier allows us relate times different states typical realtime requirement reactive system multivalued switch must turned position p position q tptl condition expressed formula using standard firstorder temporal logic state variable assumes value current time every state may attempt write condition 1 closer resemblance tptlformula 1 meaning formulas ie truth values timed state sequences depends interpretation variables x explicit quantification variables however typically omitted firstorder temporal specifications ph88 ost90 moreover specification languages often restricted formulas implicit explicit quantifier prefixes har88 hlp90 condition 2 example choice quantifiers provides intended meaning may obvious indeed may correspond prefix particular following quantification 2 yields formula equivalent 1 precise timed state sequence ae environment e satisfy formula 9x oe iff ae oe 2 hand quantifier prefix makes formula 2 equivalent 1 example 1 imply stronger condition difference subtle formula 1 asserts every pstate time x followed pstates eventually qstate time demands pstate time x time every pstate time x followed pstates eventually qstate time instance timed state sequence presented sequence statetime pairs satisfies 1 4 general tptl identifies fragment firstorder temporal logic state variable tptl includes precisely firstorder temporal formulas variable v immediately upon introduction frozen time local temporal context ie value tptlformula x oe equivalent firstorder temporal formula equivalently formula words tptl restricts time references times states rather permitting quantification entire time domain precisely restriction allows limits us express timing constraints states concise readable specifications compare 1 3 also restriction leads generalization ptlbased tableau algorithms verification tableau method tptl developed section 3 validity problem tptl unconstrained classical quantification recently shown nonelementary ah90 versus bounded temporal operators several researchers proposed add infinite supply realtime modalities 3ffi eventually within ffi time units ptl ph88 koy90 branchingtime logics emss89 bounded temporal operators definable tptl instance boundedeventuality operator 3ffi oe expressed tptlformula bounded temporal operators always relate times adjacent temporal contexts tptl admits constraints distant contexts example formula asserts every pstate followed qstate later rstate time difference pstate corresponding rstate 10 reasoning synchronous realtime systems next state identified next time timing constraints may expressed ptl using next operator case bounded temporal operators abbreviations nested next formulas emss89 restrict tptl synchronous case postulating 3 timed tableaux present tableaubased decision procedure tptl justify doublyexponential time cost decision procedure showing validity problem tptl expspace complete finally demonstrate tableau techniques applied verify tptl properties realtime systems 31 decision procedure tptl first observe solve validity problem formula suffices check negation satisfiable throughout subsection given formula oe tptl wish determine oe satisfiable tableau method searches systematically model oe originated propositional calculus smu68 first applied obtain decision procedure modal logic computation case dynamic logic pra80 follow standard presentation tableaubased decision procedure ptl bmp81 wol83 begin constructing initial tableau oe checking satisfiability oe reduced checking finite initial tableau oe contains certain infinite paths tableau method ptl fact subsumed procedure special case oe contains timing constraints preliminary assumptions moment assume 1 oe contains absolute time references every term oe contains variable thus may perform simple arithmetic manipulations timing constraints oe nonnegative integers c 0 2 oe contains temporal operators fl 2 first argument every occurrence operator u oe true neither two restrictions essential simplify exposition decision pro cedure later accommodate absolute time references operators also assume oe form z oe 0 easily achieved necessary prefixing oe variable z occur freely oe timed state sequence ae oe deltabounded constant time initial state deltabounded timed state sequence delta time increases state successor state delta begin restrict deltabounded models checking satisfiability case finitestate character times associated states modeled finitely many new timedifference propositions prev represent initial state initial time ffi states time increase ffi predecessor state formally capture state time information timed state sequence ae oe state sequence oe 0 reduction timed state sequences state sequences allows us adopt tableau techniques ptl conclusion section show find appropriate constant delta given formula oe updating timing constraints key observation underlying tableau method ptl formula split two conditions nontemporal present requirement initial state temporal future requirement rest model ie successor state example eventuality 3 satisfied either fl3 true initial state state sequence since number conditions generated way finite checking satisfiability reducible checking satisfiability finite structure initial tableau splitting tptlformulas present future nextstate condition demands care obtain requirement successor state timing constraints need updated appropriately account time increase ffi initial state successor consider example formula x 3y x recall free occurrences x references initial time eventuality satisfied either initial state satisfy free occurrences x replaced next state satisfy updated eventuality x 3y naive replacement x however successively generate infinitely many new conditions fortunately monotonicity time exploited keep tableau finite observation always instantiated future value greater equal initial time x allows us simplify timing assertions form x x true false respectively define therefore formula x x ffi results updating references initial time x time difference ffi instance x formula x 1 x 5 x 6 following formulas general given tptlformula x ffi 2 n tptlformula x ffi defined inductively follows results x ffi replacing every term form x every subformula form x x j respectively provided occurrence x specified terms formulas free ffi following lemma confirms transformation intended effect updates time references correctly formula x x ffi expresses condition x timed state sequence let e environment proof lemma 1 proof proceeds straightforward induction structure closure tptlformula collect conditions may arise recursively splitting formula oe present future parts closure oe suffices define closure formulas whose outermost symbol freeze quantifier closure set closurez oe 0 tptlformula z oe 0 smallest set formulas containing z oe 0 closed following operation sub formula x z results replacing free occurrences x z note formulas closure set form z constant c 0 occurs tptlformula oe oe contains subformula form oe contains predicate symbol j c let c largest constant occurs formula oe closure set oe finite formulas z closureoe z ffi z c size closure set oe depends structure oe constants occur oe define k oe product constants occur tptlformula oe inductively follows k x lemma 2 size closure let number boolean temporal freeze operators tptlformula oe let k product constants occur oe jclosureoej 2nk proof lemma 2 given formula z oe 0 define induction structure oe 0 set formulas contains oe 0 closed updating timing constraints set c oe 0 addition closed subformulas set e formulas operators applied sets analogous fashion case formulas form x treated similarly timing constraints x observe c straightforward show induction structure oe 0 2 oe 0 closed sub 1 3 follows closurez oe 0 oe 0 thus suffices show jd oe jc oe 0 j 2nk may done induction structure oe 0 initial tableau tptlformula tableaux tptl finite directed state graphs kripke structures unlike states timed state sequence determine truth values propositions vertices tableau labeled arbitrary formulas tptl formulas label vertex tableau express conditions annotated state successor states addition every vertex labeled timedifference proposition prev denotes time increase predecessor states formally vertices tableau oe maximally consistent subsets finite universe closure deltag tptlformulas subset phi closure oe maximally consistent satisfies following conditions formulas range finite set closure oe phi precisely one referred ffi phi c phi iff 0 c holds n one j ffl z false phi phi iff either z 1 phi z 2 phi ffl z 2 phi iff z z fl 2 phi ffl z x phi iff z x z phi initial tableau oe tptlformula oe directed graph whose vertices consistent subsets closure oe contains edge phi psi iff formulas z fl closure oe definition ensures global consistency temporal realtime constraints initial tableau significance finite initial tableau oe formula oe every model oe corresponds infinite path oe along eventualities satisfied time vice versa implies finitemodel property tptl sense every satisfiable tptlformula oe satisfied model whose state part extended timedifference propositions prev ffi eventually periodic precise infinite path tableau oepath satisfies following three conditions initiality oe 2 phi 0 fairness eventualities satisfied along phi time equivalently missing invariances violated along phi time z 2 2 closure oe 0 progress every oepath initial tableau oe reduced oepath eventually periodic moreover length period bounded following lemma prove important obtaining upper bound complexity tptl lemma 3 length oepaths suppose initial tableau oe tptlformula oe consists vertices oe contains oepath contains oepath form l 2nk number temporal operators oe k product constants occur oe proof lemma 3 consider infinite oepath choose smallest j phi j occurs infinitely often phi nk invariances closure oe hence phi lacks nk invariances z 2 l one violated vertex psi l infinite suffix phi phi finite segments phi contain ie inner occurrences phi delete loops every segment phi j thus obtaining finite sequences 2nk length 1 hard see result deleting duplicated vertices ie phi oepath desired form tableau decision procedure following main lemma suggests decision procedure tptl determine tptl formula oe satisfiable construct initial tableau oe check contains oepaths lemma 4 initial tableau tptl 1 correctness initial tableau oe tptlformula oe contains oepath oe satisfiable 2 completeness oe deltabounded model oe contains oepath proof lemma 4 proof makes essential use directions timestep lemma lemma 1 let e environment 1 given oepath initial tableau oe define timed state sequence note time sequence satisfies progress condition phi show induction structure 2 phi iff ae ae model oe proposition z p 2 closure oe z one negation consistency phi z z z completes base cases consistency phi z induction hypothesis case iff either ae 6j z 1 ae assume z fl 2 closure oe let induction hypothesis case iff ae i1 case iff ae i1 case z 2 2 closure oe first prove z 2 2 phi iff z note choice use induction j show z 2 2 phi implies z 2 suppose z 2 arbitrary j consistency phi j also z invoking consistency phi j conclude z hand suppose z 2 62 phi since phi oepath induction hypothesis follows z 2 2 phi iff ae j case iff ae j finally consider case z x 2 closure oe case z x 2 phi iff z x z 2 induction hypothesis case iff ae deltabounded model oe subsets phi 0 closure oe defined follows prev gamma show oepath initial tableau oe inspecting consistency rules evident every phi maximally consistent prove phi infinite path oe also show edge phi phi i1 0 suppose z fl 2 closure oe let case iff ae i1 initial tableau oe contains edge phi phi i1 show infinite path phi indeed oepath satisfies progress condition time sequence see oe 2 phi 0 observe ae model oe remains established eventualities phi satisfied time suppose z 2 2 closure oe z 2 62 phi ae thus ae j 6j z ffi lemma 1 implies z ffi 62 phi j constructing initial tableau oe formula oe delete vertices oepath achieved straightforward modification standard techniques marking vertices graph lie infinite path along eventualities satisfied wol83 remaining state graph called final tableau oe follows tptlformula oe deltabounded model iff final tableau empty procedure finding final tableau polynomial size initial tableau contains vertices size onk number operators oe k product constants occur oe thus provided delta dominated 2 nk initial oe constructed checked oepaths deterministic time exponential nk show next delta indeed bounded k bounding time stepwidth given formula oe finally determine bound delta time increase two successive states satisfiability oe affected choose constant delta 2 n oe satisfiable iff deltabounded model let c largest constant oe occurs subformula form x let j c 1 cm congruence predicates occur oe time increase ffi two states greater equal c obviously suffices know residues order update tableau timing constraints correctly indeed checking satisfiability oe arbitrary stepwidth ffi bounded taking smallest representative finitely many congruence classes lemma 5 bounded time increase tptlformula oe satisfiable k product constants occur oe oe kbounded model proof lemma 5 fact derive tighter bound c k 0 k least common multiple k 0 c 1 given model ae oe oe let time sequence 0 smallest easy see ae model oe combining result tableau method developed arrive conclusion satisfiability tptlformula oe decidable deterministic time exponential nk moreover lemma 3 implies every satisfiable formula oe satisfiable model whose size sense mentioned exponential nk remember restricted oe contain operators absolute time refer ences show assumptions relaxed operators first let us address formulas include operators take closure formula oe operators closed operation add following condition consistency set phi closure oe formulas phi iff either z 2 phi z 1 z fl 1 u phi finally fairness requirement oepath phi 0 phi 1 generalized 0 hard check lemmas 2 3 4 5 allow addition operators way absolute time references secondly let us accommodate absolute time references instead generalizing tableau method constant terms contain variable use simple observation suppose test formula oe satisfiability let x variable occur oe replace every variablefree term c oe term xc thus obtaining new formula oe r may contain free occurrences x following lemma allows us reduce satisfiability problem oe satisfiability problem formula x fl oe r contains absolute time references lemma 6 absolute time references tptlformula oe satisfiable iff formula x floe r satisfiable x occur oe proof lemma 6 1 let ae oe timed state sequence define timed state sequence ae ae 0 timed state sequence define timed state sequence ae oe 0 note transformation oe oe r increase number operators oe product constants occur oe following theorem summarizes results tableau method theorem 1 deciding tptl validity problem closed tptlformula oe decided deterministic time exponential nk number boolean temporal freeze operators oe k product constants occur oe note length formula oe whose constants presented logarithmic eg binary encoding within constant factors n log k thus decision procedure tptl doubly exponential although singly exponential n untimed part therefore singly exponential ptl algorithm outlined course improved many ways particular may avoid construction entire initial tableau starting initial state contains oe successively adding new states needed wol83 stepwise procedure however lower doubly exponential deterministictime bound show following subsection decision problem tptl expspacehard also point monotonicity condition timed state sequences essential tableau method work progress condition timed state sequences oepaths omitted 32 complexity tptl following theorem establishes tptl exponentially harder decide untimed base ptl pspacecomplete decision problem sc85 extra exponential caused succinct representation time constants tptl typical many realtime specification languages ah90 theorem 2 complexity tptl validity problem tptl expspacecomplete respect polynomialtime reduction proof theorem 2 proof proceeds two parts first show tptl expspace expspacehard first part follows argument ptl pspace builds nondeterministic version tableaubased decision procedure wol83 hardness part patterned proof universality problem regular expressions exponentiation expspacehard hu79 suffices show complementary problem checking satisfiability tptlformula nondeterministic expspace hence savitchs theorem deterministic expspace particular checked nondeterministic singly exponential space initial tableau contains oepath form stated lemma 3 trying construct oepath nondeterministically stage current vertex loopback vertex vertex counter retained order construct successor vertex loop back vertex counter exceeds maximal length loop fail since size vertex length loop lemma 2 lemma 3 respectively singly exponential representations length oe follows nondeterministic procedure requires exponential space expspacehardness consider deterministic 2 n spacebounded turing machine input x length n construct tptlformula oe x length delta log n valid accepts x standard complexitytheoretic argument using hierarchy theorem space follows constant c 0 every turing machine solves validity problem formulas oe length takes space infinitely often thus suffices construct given initial tape contents x 1 sufficiently succinct formula oe x describes unique computation x infinite sequence propositions 2 sufficiently succinct formula oe accept characterizes computation x accepting implication valid iff machine accepts input x use proposition p proposition q j every tape symbol machine state j respectively particular p 0 q 0 correspond special tape symbol blank initial state use following abbreviations formulas represent configurations pstate sequences length 2 n separated sstates position readwrite head marked rstate computation x completely determined following two conditions 1 starts initial configuration 2 every configuration follows previous one move conditions expressed tptl take oe x consist 2x fl resemble state counter following two conjuncts correspond requirements 1 2 respectively p q r range propositions refers transition function instance writes state j input 0 symbol k onto tape moves right enters state j 0 f p computation x accepting iff contains accepting state f expressible tptl formula lengths oe initial oe move oe accept delta log n o1 respectively recall constants represented binary thus implying desired delta log nbound oe x 33 realtime verification researchers proposed variety different languages defining realtime systems ah92 instead siding particular syntax represent finitestate realtime systems abstract state graphs timing information typically difficult compile given concrete syntax timed state graphs consult example hen91 translation timed transition systems timed state graphs model checking algorithmic verification technique compares temporallogic specification system stategraph description system suppose system represented finite state graph possible runs correspond infinite paths meet certain fairness conditions furthermore suppose specification given formula oe linear temporal logic verification problem asks possible runs system satisfy specification oe case ptl tableau construction used solve verification problem lp84 initial tableau oe negated specification oe captures precisely models formula oe hence system meets specification oe iff infinite path common finite state graphs oe corresponds possible run model oe question answered constructing product two state graphs oe checking contains infinite path meets certain fairness conditions generalize ptlalgorithm check timed state graph meets tptlspecification show problem checking tptlformula oe satisfied paths given structure expspacecomplete thus general equally hard deciding oe satisfied timed state sequences practitioner note complexity model checking problem doubly exponential size formula typically much smaller size structure timed state graphs represent finitestate realtime systems finite directed state graphs kripke structures whose vertices locations labeled sets propositions location labeled state timedifference proposition prev ffi prev 0 indicates time difference predecessor location either exactly ffi time units unspecified respectively definition 4 timed state graph timed state graph consists ffl finite set l locations ffl state labeling function labels every location 2 l state ffl time labeling function labels every location 2 l timedifference proposition either prev ffi ffl set l 0 l initial locations ffl set l 2 transitions timed state sequence ae oe computation timed state graph infinite path 0 oe tptlformula oe satisfied valid timed state graph computations models oe problem model checking determine formula valid timed state graph model checking given timed state graph tptlformula oe let k product constants oe recall k largest constant ffi initial tableau oe oe contains timedifference proposition prev ffi define product two structures oe finite directed graph whose vertices pairs vertices oevertices vertex phi consists location vertex phi oe ffl state information phi compatible propositions ffl time information phi compatible either product contains edge vertex vertex contains edge 1 2 oe contains edge phi 1 phi 2 size product theta oe clearly linear product sizes oe infinite path product theta oe oepath second projection oepath oe initialized oepath addition starts vertex whose first projection initial vertex following lemma follows immediately lemma 4 proof theorem 1 confirms product construction intended effect lemma 7 tableau product timed state graph satisfies tptlformula oe iff product contains initialized oepath lemma suggests model checking algorithm see runs finitestate realtime system satisfy tptlformula oe 1 construct timed state graph 2 construct initial tableau oe negated formula oe 3 construct tableau product 4 check contains initialized oepath system meets specification oe iff case according different notions system fairness various variants computations timed state graphs defined checked untimed case lp84 since structure checked oepaths polynomial time running time model checking algorithm determined size tableau product contains ojt vertices size typically exponentially larger description hen91 seen size oe two exponentials larger oe theorem 3 model checking problem tptlformula oe valid timed state graph decided deterministic time linear size doubly exponential length oe complexity model checking theorem 4 complexity model checking problem deciding tptlformula valid timed state graph expspacecomplete proof theorem 4 expspace given timed state graph satisfies tptlformula oe iff product theta oe contains initialized oepath easy see nondeterministic singly exponential space suffices check desired oepath expspace bound follows reduce validity problems tptl model checking suffices give timed state graph constant size formula oe valid iff oe valid simply choose complete graph subsets p label locations timedifference proposition prev 0 4 undecidable realtime properties last let us justify decisions restrict semantics tptl discrete time domain n restrict syntax timing constraints successor ordering congruence operations indeed decisions seem overly limiting realtime specification languages example without addition time values property time difference subsequent pstates increases forever cannot defined show however restrictions necessary obtain verification algorithms consider two natural extensions tptl syntactic one allowing addition time semantic one interpreting tptlformulas dense time domain extensions shown pi 1 1 complete reducing sigma 1 hard problem 2counter machines respective satisfiability problems follows cannot even recursively axiomatized exposition analytical hierarchy consult rog67 41 sigma 1complete problem nondeterministic 2counter machine consists two counters c sequence n instructions may increment decrement one counters jump conditionally upon one counters zero execution nonjump instruction proceeds nondeterministically one two specified instructions represent configurations current values location counter two counters c respectively consecution relation configurations defined obvious way computation infinite sequence related configurations starting initial configuration h0 0 0i computation recurring contains infinitely many configurations value location counter 0 problem deciding nondeterministic turing machine empty tape computation starting state visited infinitely often shown sigma 1 hps83 along lines obtain following result lemma 8 complexity 2counter machines problem deciding given nondeterministic 2counter machine recurring computation sigma 1 proof lemma 8 every sigma 1formula equivalent sigma 1formula form recursive predicate g hps83 construct nondeterministic 2counter machine recurring computation iff true let start computing indefinitely nondeterministically guessing next value f stage checks whether fx fx 1 satisfy g jumps instruction 0 exists 2counter machines universal compute recursive predicate g executes instruction 0 infinitely often iff function f desired properties exists 42 encoding computations 2counter machines show satisfiability problem several extensions tptl sigma 1 complete first observe satisfiability formula oe cases phrased sigma 1 asserting existence model oe timed state sequence ae oe encoded firstorder arithmetic finitely many infinite sets natural numbers say one proposition p oe characterizing states p holds one encode pairs state numbers associated times routine matter express firstorder predicate oe holds ae conclude satisfiability sigma 1 1 show satisfiability problem logic sigma 1 1 hard suffices given nondeterministic 2counter machine construct formula oe oe satisfiable iff recurring computation demonstrate technique encoding recurring computations showing monotonicity constraint time necessary decidability tptl theorem 5 nonmonotonic time relaxing monotonicity condition time sequences renders satisfiability problem proof theorem 5 encode computation gamma time sequence kth configuration hi c di gamma sequence satisfies progress condition monotonicity condition difficult express tptlformula oe encodes recurring computation first specify initial configuration abbreviate sequence next operators fl ensure proper consecution adding 2conjunct oe every instruction instance instruction 1 increments counter c proceeds nondeterministically either instruction 2 3 contributes conjunct fly recurrence condition expressed 23formula clearly conjunction oe n2 formulas satisfiable iff recurring computation note proof require propositions follows firstorder temporal logic single state variable ranging natural numbers pi 1 complete provided underlying assertion language least successor addition equality primitive 43 presburger tptl show certain extremely modest relaxation syntax timing constraints leads highly undecidable logic consequently tptl addition time undecidable theorem 6 presburger tptl syntax tptl extended allow multiplication 2 satisfiability problem becomes sigma 1 proof theorem 6 encode computations use propositions precisely one true state hence may identify states propositions configuration hi c di represented finite sequence 2 states initial configuration p 0 well recurrence condition 23p 0 easily expressed ptl crucial property allows temporal logic specify consecution relation configurations thus set computations ability copy arbitrary number rstates realtime temporal logics times associated state sequence used copying availability multiplication 2 able kth configuration computation correspond k 0 finite sequence states mapped time interval 2 first force time increase strictly positive amount successive states 2x fly x ensure every state uniquely identifiable time copy groups rstates establishing onetoone correspondence clearly enough time gaps accommodate additional r j state required increment instruction instance instruction 1 increments counter c proceeds nondeterministically either instruction 2 3 expressed follows first conjunct 1 ensures proper progression one two specified instructions 2 3 second one 2 establishes onetoone correspondence states successive intervals representing configurations formula 3 r copies rstates last conjunct 4 adds finally r 1 state end successor configuration required increment operation modify proof reducing time state counter 2x fl letting propositions false resulting additional padding states thus satisfiability problem tptl multiplication 2 sigma 1 1 hard even time replaced state counter corollary infer firstorder theory natural numbers multiplication 2 monadic predicates pi 1 similar result obtained independently hal91 shown presburger arithmetic becomes pi 1 complete addition single unary predicate proof technique used show presburger tptl undecidable applied many realtime specification languages including logics rtl jm86 gctl har88 rttl ost90 mtl koy90 formalisms admit addition time primitive renders undecidable see ah90 44 dense tptl alternative way extending expressive power tptl relax semantics adopting dense time domain two given points time another time point show resulting logic highly undecidable theorem 7 dense tptl tptl interpreted rational numbers ie satisfiability problem becomes sigma 1 proof theorem 7 proof depends ability copy groups rstates time able kth configuration computation correspond 0 finite sequence states mapped time interval time allows us squeeze arbitrarily many states every interval length 1 identify every state unique time establish onetoone correspondence r j states fact may simply replace occurrences multiplication 2 presburgertptl formula encoding recurring computations successor operation order obtain desired densetptl formula oe proof goes time domain oe oe dense linear order unary function satisfies following two firstorder axioms show arbitrary dense time domains satisfiability problem sigma 1 1 standard lowenheimskolem argument necessary infer existence countable models acknowledgements thank zohar manna amir pnueli david dill guidance moshe vardi joe halpern gave us helpful advice refining undecidability results particular pointed us sigma 1completeness problem turing machines r model checking realtime systems benefits relaxing punctuality really temporal logic logics models real time survey temporal logic branching time quantitative temporal reason ing temporal analysis fairness presburger arithmetic unary predicates temporal analysis realtime systems temporal specification verification realtime systems good digital clocks propositional dynamic logic regular programs introduction automata theory safety analysis timing properties realtime systems specifying realtime properties metric temporal logic checking finitestate concurrent programs satisfy linear specification temporal logic reactive concurrent systems specification synthesis communicating processes temporallogic specifications proving liveness properties concurrent programs temporal logic realtime systems applications temporal logic specification realtime systems temporal logic programs complexity propositional linear temporal logics asynchronous propositional temporal logic temporal logic expressive tr complexity propositional linear temporal logics safety analysis timing properties realtime systems theory recursive functions effective computability applications temporal logic specification real time systems extended abstract temporal logic real time systems halforder modal logic prove realtime properties specifying realtime properties metric temporal logic benefits relaxing punctuality presburger arithmetic unary predicates inlineequation f gpgsup1supinf1inff inlineequation complete temporal logic reactive concurrent systems temporal specification verification realtime systems checking finite state concurrent programs satisfy linear specification proving liveness properties concurrent programs synthesis communicating processes temporal logic specifications temporal analysis fairness temporal logic branching time introduction automata theory languages computation good digital clocks quantitative temporal reasoning logics models real time oldfashioned recipe real time proving realtime properties programs temporal logic ctr gaoyan xie cheng li zhe dang linear reachability problems minimal solutions linear diophantine equation systems theoretical computer science v328 n12 p203219 29 november 2004 farn wang chiatien lo procedurelevel verification realtime concurrent systems realtime systems v16 n1 p81114 jan 1999 denis lugiez philippe schnoebelen decidable firstorder transition logics paprocesses information computation v203 n1 p75113 november 25 2005 roberto barbuti nicoletta de francesco antonella santone gigiola vaglini logic based abstractions realtime systems formal methods system design v17 n3 p201220 dec 2000 oscar h ibarra zhe dang pierluigi san pietro verification loosely synchronous queueconnected discrete timed automata theoretical computer science v290 n3 p17131735 3 january andreas schfer axiomatisation decidability multidimensional duration calculus information computation v205 n1 p2564 january 2007 carsten lutz dirk walther frank wolter quantitative temporal logics reals pspace information computation v205 n1 p99123 january 2007 zhe dang tevfik bultan oscar h ibarra richard kemmerer past pushdown timed automata safety verification theoretical computer science v313 n1 p5771 16 february 2004 zhe dang oscar h ibarra richard kemmerer generalized discrete timed automata decidable approximations safety verification theoretical computer science v296 n1 p5974 4 march kees van hee olivia oanea alexander serebrenik natalia sidorova marc voorhoeve loglogics logic historydependent business processes science computer programming v65 n1 p3040 march 2007 stphane demri deepak dsouza automatatheoretic approach constraint ltl information computation v205 n3 p380415 march 2007 stphane demri ltl integer periodicity constraints theoretical computer science v360 n1 p96123 21 august 2006 f laroussinie ph schnoebelen turuani expressivity complexity quantitative branchingtime temporal logics theoretical computer science v297 n13 p297315 17 march nicolas markey jeanfranois raskin model checking restricted sets timed paths theoretical computer science v358 n2 p273292 7 august 2006 sascha konrad betty h c cheng realtime specification patterns proceedings 27th international conference software engineering may 1521 2005 st louis mo usa roberto barbuti luca tesei decidable notion timed noninterference fundamenta informaticae v54 n23 p137150 february alur toms feder thomas henzinger benefits relaxing punctuality journal acm jacm v43 n1 p116146 jan 1996 roberto barbuti luca tesei decidable notion timed noninterference fundamenta informaticae v54 n23 p137150 april zhe dang pushdown timed automata binary reachability characterization safety verification theoretical computer science v302 n13 p93121 13 june alur thomas henzinger peihsin ho automatic symbolic verification embedded systems ieee transactions software engineering v22 n3 p181201 march 1996 zhe dang pierluigi san pietro richard kemmerer presburger liveness verification discrete timed automata theoretical computer science v299 n13 p413438 ruggero lanotte andrea maggioloschettini monotonic hybrid systems journal computer system sciences v71 n1 p3469 july 2005 ruggero lanotte andrea maggioloschettini simone tini information flow hybrid systems acm transactions embedded computing systems tecs v3 n4 p760799 november 2004 roberto barbuti nicoletta de francesco luca tesei timed automata noninstantaneous actions fundamenta informaticae v47 n34 p189200 august 2001 f laroussinie n markey ph schnoebelen efficient timed model checking discretetime systems theoretical computer science v353 n1 p249271 14 march 2006 stphane demri ranko lazi david nowak freeze quantifier constraint ltl decidability complexity information computation v205 n1 p224 january 2007
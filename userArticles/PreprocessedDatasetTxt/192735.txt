reducing memory traffic cregs array pointer references often ambiguous compile time analysis cannot always determine distinct references object ambiguously aliased objects allocated registers conventional compilers due cost loads stores required keep register copies consistent memory several hardware software strategies used solve ambiguous alias problem implemented one scheme called cregs compiler instruction level simulator present modification briggs optimistic coloring algorithm allows us allocate local parameter arrays cregs cregs register file operation instruction set modifications required implement scheme discussed underlying hardware issues pipeline impact chip area briefly discussed several benchmarks compared terms dynamic instructions executed two creg set sizes measured reduction memory operations significant averaging 23 benchmarks shown b introduction programs memory references significant fraction total number instructions executed total run time recent study spec benchmark suite showed average onethird dynamic instructions executed loads stores byp91 paper show simple hardware scheme combined small changes current compiler technology improve performance reducing memory traffic show techniques cleanly integrated current instruction set architecture implementation retaining objectcode compatibility providing register file aliased objects efficiently allocated ambiguous alias occurs two names may may refer memory location example shown figure 1 relationship j known compile time varies denoted j references may depend load line 3 required relationship j determined load load r2ai load r2ai load r2ai store ajr3 store ajr3 store ajr3 load r4ai use r2 use r3 figure 1 ambiguous alias example eliminated ai allocated register general ambiguously aliased objects allocated register file loads stores required maintain correctness cregs hardware scheme performs run time consistency check effective addresses 1 manner aliases detected values propagated ambiguously aliased objects cregs dic88 creg hardware maintaining addresses register file compiler allocate pointer values arrays cregs safely without fear using stale data reaping benefits fast local memory objects performance gain expected due associated reduction memory bandwidth creg register additional address field used perform associative matches cregs capable updating cregs certain circumstances datum address name figure 2 creg scope associativity limited creg set size underlying hardware must capable writing value fields matching cregs set simultaneously values different sets updated even addresses match alias sets used group live ranges allocation creg sets alias set composed live ranges ambiguously aliased point live range asu86 assumed virtual addresses used virtual memory supported names always aliased appropriately renamed objects never aliased placed different alias sets formal parameters analyzed aliasing placed alias sets using algorithm developed cooper coo85 many solutions ambiguous alias problem hss94 dgs93 chi91 cck90 hes90 nic89 chd89 focus creg hardware compiler techniques paper remainder paper covers creg instruction set modifications hardware design section 2 creg compilation techniques section 3 experimental results analysis section 4 summary section 5 section explain basic creg operation propose modifications typical loadstore instruction set architecture support cregs addition show integrated existing superscalar microprocessor design creg address matching value update occurs loads stores instructions primary means maintaining mapping memory registers nonmemory instructions clear address field destination creg address bound value value loaded stored creg load store range address matching limited creg set set responsible propagating values cregs whose addresses match give coloring algorithm freedom allow efficient allocation sets large possible ideally size register file call maximal creg set 21 instruction set architecture section detail changes instruction set architecture necessary support cregs focus loadstore instruction set typical current risc microprocessors 211 original instruction set original load store instructions remain unchanged except clear address field creg loading storing hence compiler unaware cregs safely use existing loads stores effectively treating cregs registers compiler uses instructions address matching value update required eg saving restoring registers subroutine boundaries 212 creg matching instructions load match address instruction added instruction set load aliased objects cregs calculates effective address normal load performs associative search creg addresses within set match found memory operation squashed ie performed copy matching creg made load still takes time processor pipeline memory operation initiated store match address instruction complements creg load calculates effective address associatively searches cregs address finds copies value stored cregs unlike load store always performs memory operation keeping objects memory updated current value multiple writes occur within register file potentially cregs set may need written practice rarely two cregs updated within set live range defined creates new value register object spilled ambiguously aliased store match follows update memory new value store required keep memory consistent values currently cregs case ambiguously aliased objects fit creg set two variants store match address instruction first updates matching cregs write address creg stored compiler uses left hand side assignment statement aliased spilled therefore store address written source register second form store updates address creg stored well values matching cregs overwrites address effectively allocating object creg compiler uses def start live range aliased object allocated creg 213 address clear instructions care must taken live ranges live across subroutine boundaries identify two cases first case cregs containing values one subroutines stack frame could cause inadvertent squashed loads following subroutines stack frames occupy memory space different times second case involves object may involved subroutine call creg allocated another set used subroutine force break live range objects clear address fields isolates caller callee making ambiguously aliased objects reload first use following subroutine call alternatively address value field could saved restored subroutine boundary 214 context switching aggressive register isolation required context switches exceptions interrupts creg register file must contain contents event accomplished special stores loads move value address field creg memory context switching represented data presented paper however operating system overhead system calls included 215 code size effects static code size cregs often smaller generated conventional register file cregs objects allocated resulting reduction spill loads however loads stores required provide isolation subroutine boundaries simply cregs utilized experience small routines large numbers array references increased amount subroutine isolation code significant production compiler routines could candidates inlining 22 example figures 3 4 illustrate creg operation values cregs memory referred name r5 ai addresses referred prefix r5 ai address field creg f4 written f4 loads stores involving creg updates memory operations depicted figure 3 simple code example copy r4 cregs matching ai store store r4 ai load ai allocated r4 else load r5 ak load copy r6 cregs matching aj creg store r6 aj store figure 4 underlying operations box surrounding operations perform example j known compile time array references ambiguously aliased assume live ranges ai ak allocated live range aj spilled furthermore assume live range ak starts use line 4 line 2 example shows def array element store follows def allocates ai r4 writing address ai address field r4 also copies value r4 cregs set matching addresses writes value memory load required ai line 4 note code line 3 changed value ai r4 would updated via cregs address matching load ak line 4 necessary start live range ak may may result memory operation effective address ak matches address field creg set value copied creg instead loaded memory example k equal r4 r5 creg set value r4 would copied r5 address match found memory read occurs finally store aj writes new value r6 memory cregs address update address field r6 address field r6 remains null set null add instruction line aj spilled 23 cregs implementation section illustrate cregs may integrated pipelined superscalar processor implementation earlier study showed cregs could integrated simple risc processor pipeline using cachelike circuitry small chip area increase clock cycle time impact noo92 sketch implementation dec alpha 21064 deeplypipelined superscalar processor pipeline stages alpha 21064 shown figure 5 unlike risc micro processors integer pipeline divided two pipelines one dedicated loadsstores integer alu operations operation pipeline stages respective fetch swap decode issue b write figure 5 alpha 21064 pipeline stages creg operations follows note fetch swap decode issue stages unchanged fetch instruction cache accessed two instructions fetched swap two instructions inspected see require integer floatingpoint pipeline branches predicted decode instructions decoded issue instructions issued operands read stage one integer computes effective address load store instructions loads address written destination creg address field stores address written source creg address field object stored allocated creg 2 stage two integer reads data cache tags cache data loads stores hardware checks address match effective address cregs set match instruction load matching creg read memory read performed value sent write stage stores source value sent stage write write result register file loads write value matching cregs load squashed memory read 3 load squashed stores write source value matching cregs write buffer pipeline operation unchanged creg match occurs dual issue possible 21064 cregs one additional dual issue restriction necessary integer creg stores cannot dualissued following integer alu operation since store may write source register integer alu instruction latter instruction must wait issue store instruction clock ticks however source register resides creg set different store source register instructions may dualissued dual issue conditions unaffected consist floatingpoint integer instruction pairs register files split additional forwarding logic needed pipeline stage b example load followed store creg needs loaded value write memory without stalling recovery schemes reorder history buffers smp88 modified without undue overhead allow cregs implementation decision made compiler chooses store instruction use 3 read first level cache hit otherwise second level cache main memory creg implementation require additional hazard detection register file read ports addition creg requires address field mask field approximately doubling size register file given increasing chip sizes small area required registers relative caches functional units rest data path increased chip area may problem allocating objects cregs graph coloring register allocators use nodes represent live ranges values arcs nodes specify two live ranges cannot allocated register nodes interference graph colored representing allocation live ranges specific registers section describes live range construction alias analysis compiler performs building interference graph describe changes briggs optimistic coloring algorithm allow ambiguously aliased objects allocated cregs 31 live range construction variety objects eligible allocation cregs following simple rules describe live range strategy first organize local formal parameter array references according name array index calculation involved variables index calculation encoded value number annotate reference uniquely live ranges built array elements manner scalars treating unique index given array different element live ranges combined alias analysis described next live ranges allow coloring algorithm correctly allocate ambiguously aliased object cregs globals allocated prespilled means usedef spill code responsible loadingstoring value live ranges scalar locals formal parameters created described briggs bri92 32 alias analysis section describes group objects alias sets preparation allocating creg sets ambiguously aliased objects grouped alias sets might allocated across multiple creg sets stale data could occur cregs alias analysis use local variables minimally simple asu86 object ambiguously aliased object b point program put b alias set another object c aliased b later point also placed alias set set implies c aliased may may true conservatively assumed true obviously room improvement construction sets note however b c must allocated creg set enhanced alias analysis may improve allocation process alias set represented interference graph circularly linked list live range nodes local arrays alias set consists live ranges elements array 4 formal parameter arrays interprocedural alias analysis used group live ranges alias sets coo85 scalars null pointer alias set 4 conservative two local array live ranges conflict placed different alias sets two basic operations alias sets find range cregs allowed color selection alias set member colored creg set remaining alias set members limited colors within creg set members alias set colors creg set chosen roundrobin manner first operation finding color member alias set given uncolored member set find alias colornode members set colored yet color creg set chosen roundrobin manner node member alias set illegal color returned second basic operation uses resulting color finds first last creg corresponding creg set find first lastcolor color given valid color returns first last creg entire register file target architecture supports maximal creg set find first lastcolor always returns entire register file range 33 modifications briggs optimistic coloring algorithm section illustrates changes briggs optimistic coloring algorithm bck89 enable color interference graph augmented alias sets maximal creg set find routines described cause allocator revert briggs original algorithm briggs optimistic algorithm delays spill decisions knows colors available color selection phase control selection colors nodes alias set limited cregs one creg set color selection stage scans range colors checking colors nodes neighbors loop originally limited available colors limit based creg set node colored scalar objects limits remain entire register file node cannot colored within range colors specified spill code inserted algorithm iterates color selection originally found several alias sets frequently one member allocated single creg set remaining members alias sets often allocated creg set full find alias colornode returns colors creg sets roundrobin manner alias set fixed creg set yet allows alias sets better chance completely allocated creg set multiple alias sets still allocated one creg set fit augmentation briggs optimistic coloring independent cost function making compatible improvements bgg89 chaitinstyle allocators including briggs heuristics limit insertion spill code example uses live range close 5 def live range spill code inserted override case defs ambiguously aliased objects store always follows keep memory updated small register files register pressure high spill code may generated cases cregs different spill decisions made interference graph nodes edges due array live ranges heuristic coloring algorithm may make different decisions based interference graph topology weights 34 dependence pointer analysis creg hardware complementary compile time techniques reduce ambiguous aliasing dependence pointer analysis techniques powerful cannot always succeed 5 two mentions live range close live range goes dead cha82 disambiguating relevant references static techniques fail creg hardware provides mechanism detect aliasing run time retaining advantages register storage aliased objects study dependence pointer analysis implemented maximal creg set pointer values allocated without analysis cregs divided sets analysis required group references alias sets 4 experimental results 41 test test suite consists several floating point spec 89 92 benchmarks livermore loops hydrodynamics code 6 benchmarks shown figure 6 used compare dynamic maximal creg set set size 4 benchmark subr lines loads stores instrs loads stores instrs tomcatv 200 2106 000 711 1924 000 609 doduc debico1 220 4756 031 290 4902 038 286 doduc debico2 220 7444 012 1375 7533 012 1349 doduc dcoera 287 900 000 061 438 179 151 doduc dyeh 253 421 000 000 105 000 000 doduc yeh 372 1122 003 000 408 000 000 livermore loops 862 839 002 145 792 007 123 ppm 1096 2117 142 445 1965 157 429 figure percent reduction summary register file size instruction counts allocation objects conventional register file allocating objects creg register file compiler generates code conventional creg register files simulator simulate conventional register file creg register file optimizing compiler known ccc developed university minnesota simulator support conventional creg register file alpha architecture dec92 dec93 instruction level simulator capable giving dynamic instructions counts simulate processor pipeline cache cannot give actual cycle counts calculate number loads reduced cregs two compilations simulations performed set criteria tested first compilation targeted toward conventional register file simulated conventional architecture certain number instructions executed counted categories loadsstoresall instructions baseline comparison second compile allocates objects cregs simulated creg register file dynamic instruction counts compared get reduction percentage xaxis plots number registers available coloring algorithm user variables register files floatingpoint integer number registers simulated machine integer multiple creg set size last creg set fewer 6 ppm code obtained dr paul woodward university minnesota reduction registers dynamic instruction reduction loads stores instrs figure 7 vpenta maximal creg set reduction registers dynamic instruction reduction loads stores instrs figure 8 vpenta set size 451525 reduction registers dynamic instruction reduction loads stores instrs figure 9 tomcatv maximal creg set51525 reduction registers dynamic instruction reduction loads stores instrs figure 10 tomcatv set size 4 reduction registers dynamic instruction reduction loads stores instrs figure 11 l loops maximal creg set reduction registers dynamic instruction reduction loads stores instrs figure 12 l loops set size 4 reduction registers dynamic instruction reduction loads stores instrs figure 13 ppm maximal creg set reduction registers dynamic instruction reduction loads stores instrs figure 14 ppm set size 4 members two plots shown benchmark one maximal creg set one creg set size four 42 analysis observed following benchmarks shown ffl dynamic load reduction ranged 0 75 ffl average reduction memory operations cregs 2338 ffl small creg sets cause slight increase memory operations compared maximal creg set ffl dynamic instruction count reduction varied 06 1375 increased register pressure presents fewer opportunities reduce loads dynamic load reduction due squashed loads direct removal spill loads squashed loads memory operation occur ie counted load instruction still counts total instructions executed fewer loads occur creg code objects allocated data shows maximal creg set gives slightly better reduction loads reduction total instructions executed slightly positive meaning reduction loads objects allocated cregs offsets increased subroutine isolation code data creg set sizes eight sixteen similar size four shown similarity due low number simultaneously live ambiguously aliased objects ste86 maximum number writes matches measured simulator test cases never exceeded two benchmarks shown theoretically could large set size register pressure artificially increased compilersimulator system reducing number registers available effect register pressure shown graphs generally cregs allow larger percentage loads removed obviously effect levels scalar aliased objects allocated figure 7 example program path cregs performance results affected input data ran debico two different data sets results figure 6 show subroutine frequent reuse array values cregs accounting large load reduction data sets performance improvement due cregs depends cache hit miss penalties cache miss rates whether memory operations removed hit miss cache squashed removed loads data available earlier pipeline reducing effective access latency cregs implementation execution time reduced following reasons ffl generally fewer instructions executed ffl fewer memory operations executed ffl overall data access latencies reduced since references directly registers 5 summary future work register file composed cregs one solution ambiguous alias problem shown instruction level implementation explained operation memory operations involved creg compiler works conjunction creg hardware produce code contains fewer load instructions squashes memory references dynamically live ranges constructed local formal parameter array elements similar scalars live ranges grouped alias sets using interprocedural alias analysis local alias information simple modification briggs optimistic coloring algorithm allows interference graph augmented alias information allocated cregs change involves limiting colors available node color selection phase algorithm roundrobin scheme helps distribute alias sets among creg sets averts deadlock situations spill alias set members combined hardware compiler strategy significantly reduce dynamic instruction counts memory traffic becoming increasingly important gap processor memory speed increases processor clock speeds increase memory accesses complete later pipeline cregs provides mechanism reduce data access latency currently exploring creg hardware integrated implementation features register renaming wide instruction issue vliw superscalar intend add pipeline cache behavior simulator effect cregs execution time may measured directly future implementing better alias analysis aggressive algorithms keep alias set size small pointer values allocated without causing significant increases spill code complexity pointer analysis may limit solution architecture maximal creg set one way would add alias edges interference graph alias edge present two nodes nodes must allocated cregs creg set experimenting criteria briggs algorithm uses choosing trivially colorable nodes namely degree k k number colors available creg set size c may make sense add term degree c criteria degree number neighboring nodes alias set zero scalars also intend improve spill code heuristic remove stores certain circumstances members alias set allocated acknowledgments would like thank john mejia help alpha simulator terence parr assistance pccts compiler construction tool peter bergner help graph coloring algorithms live range analysis james smith cray research feedback early draft paper r coloring heuristics register allo cation spill code minimization techniques optimizing compilers register allocation via graph coloring single instruction stream parallelism greater two improving register allocation subscripted vari ables register allocation spilling via graph coloring unified management registers cache using liveness cache bypass integrated memory management scheme dynamic alias resolution analyzing aliases reference formal parameters practical data flow framework array reference analysis use optimizations cregs new kind memory referencing arrays pointers architectural support register allocation presence aliasing speculative disambiguation compilation technique dynamic memory disambiguation cregs implementation study based mipsx risc microprocessor implementing precise interrupts pipelined processors refined c compiler status report tr compilers principles techniques tools cregs new kind memory referencing arrays pointers spill code minimization techniques optimizing compliers coloring heuristics register allocation unified management registers cache using liveness cache bypass architectural support register allocation presence aliasing integrated memory management scheme dynamic alias resolution register allocation via graph coloring analyzing aliases reference formal parameters cregs implementation study based mipsx risc processor register allocation myampersandamp spilling via graph coloring ctr gary tyson todd austin improving accuracy performance memory communication renaming proceedings 30th annual acmieee international symposium microarchitecture p218227 december 0103 1997 research triangle park north carolina united states gary tyson todd austin memory renaming fast early accurate processing memory communication international journal parallel programming v27 n5 p357380 oct 1999 jin lin tong chen weichung hsu penchung yew speculative register promotion using advanced load address table alat proceedings international symposium code generation optimization feedbackdirected runtime optimization march 2326 2003 san francisco california matthew postiff david greene trevor mudge storeload address table speculative register promotion proceedings 33rd annual acmieee international symposium microarchitecture p235244 december 2000 monterey california united states
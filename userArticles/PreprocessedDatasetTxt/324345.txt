armada middleware communication services realtime embedded systems evolved past several decades small customdesigned digital hardware large distributed processing systems systems become complex interoperability evolvability costeffectiveness requirements motivate use commercialofftheshelf components raises challenge constructing dependable predictable realtime services application developers top inexpensive hardware software components minimal support timeliness dependability guarantees addressing challenge armada projectarmada set communication middleware services provide support faulttolerance endtoend guarantees embedded realtime distributed applications since realtime performance applications depends heavily communication subsystem first thrust project develop predictable communication service architecture ensure qossensitive message delivery faulttolerance paramount importance embedded safetycritical systems second thrust armada aims offload complexity developing faulttolerant applications application programmer focusing collection modular composable middleware faulttolerant group communication replication timing constraints finally develop tools testing validating behavior services give overview armada project describing architecture presenting implementation status b introduction armada collaborative project realtime computing laboratory rtcl university michigan honeywell technology center goal project develop demonstrate integrated set communication middleware services tools necessary realize embedded faulttolerant realtime services distributed evolving computing platforms techniques tools together compose environment capabilities designing implementing modifying integrating realtime distributed systems key challenges addressed armada project include timely delivery services endtoend softhard realtime constraints dependability services presence hardware software failures scalability computation communication resources exploitation open systems emerging standards operating systems communication services armada communication middleware services motivated requirements large embedded applications command control automated flight shipboard work supported part research grant defense advanced research projects agency monitored us air force rome laboratory grant f306029510044 api applications services tools evaluation channels microkernel figure 1 overview armada environment computing radar data processing traditionally embedded applications constructed specialpurpose hardware software approach results high production cost poor interoperability making system less evolvable prone local failures recent trend therefore build embedded systems using commercialofftheshelf cots components pc boards ethernet links pcbased realtime operating systems makes possible take advantage available development tools leverage mass production costs make better use component interoperability realtime application developers point view approach creates need generic highlevel software services facilitate building embedded distributed realtime applications top inexpensive widely available hard ware realtime operating systems typically implement elementary subsets realtime services however monolithically embedding higherlevel support operating system kernel advisable different applications different realtime faulttolerance requirements thus catering possible requirement ranges single operating system would neither practical efficient instead believe composable set services developed subset may need exist given application philosophy advocates use realtime microkernel equipped basic realtime support prioritybased scheduling realtime communication addition reconfigurable set composable middleware layered top ker nel appropriate testing validation tools independently developed verify required timeliness faulttolerance properties distributed middleware armada project therefore divided three complementary thrust areas lowlevel realtime communication support ii middleware services group communication faulttolerance iii dependability evaluation validation tools figure 1 summarizes structuring armada environment first thrust focused design development realtime communication services microkernel generic architecture introduced designing communication subsystem hosts predictability qos guarantees maintained architecture independent particular communication service illustrated paper context presenting design realtime channel lowlevel communication service implements simplex ordered virtual connection two networked hosts provides deterministic statistical endtoend delay guarantees senderreceiver pair second thrust project focused collection modular composable middleware services building blocks constructing embedded applications layered openarchitecture supports modular insertion new service implementation requirements evolve lifespan system armada middleware services include suite faulttolerant group communication services realtime guarantees called rtcast support embedded applications faulttolerance timeliness quirements rtcast consists collection middleware includinga group membership service timed atomic multicast service admission control schedulability module clock synchronization service armada middleware services also include realtime primarybackup replication service called rtpb ensures temporally consistent replicated objects redundant nodes third thrust project build toolset validating evaluating timeliness faulttolerance capabilities target system tools development include fault injectors different levels eg operating system communication protocol application synthetic realtime workload generator dependabilityperformance monitoring visualization tool focus toolset research portability flexibility usability figure 2 gives overview prospective application illustrate utility services embedded realtime faulttolerant systems application developed honeywell subset command control facility consider radar installation set sensors used detect incoming threats eg enemy planes missiles battle scenario hypotheses formed regarding identity positions threats flight trajectories computed accordingly trajectories extrapolated future deadlines imposed intercept time intervals estimated threat trajectories reachable various ground defense bases estimated appropriate resources weapons committed handle threats eventually weapons released intercept threats services required support writing applications come naturally operating requirements example anticipated system load communication different system components different boxes figure 2 must occur bounded time ensure bounded endtoend response threat detection weapon release realtime communication services compute enforce predictable deterministic bounds message delays given application traffic specification critical system components hypothesis testing threat identification high dependability requirements best met using active replication components rtcast exports multicast membership primitives facilitate fault detection fault handling consistency management actively replicated tasks similarly extrapolated trajectories identified threats trajectory extrapolation plotting impact time estimation computing bases accessibility risk assessment masking surveillance intelligence route optimization scheduling assignment weapon sensory input hypothesis threat testing compute positions weapon base release weapon figure 2 command control application represent critical system state backup state needs maintained continually updated represent current state within tolerable consistency error margin primarybackup replication service implemented meet temporal consistency requirements finally testing tools decrease development debugging costs distributed application rest paper organized follows section 2 describes general approach integrating armada services microkernel framework also presents experimental testbed implementation environment project subsequent sections focus architecture design implementation key communication middleware services armada section 3 introduces realtime communication service section 4 presents rtcast suite group communication faulttolerance services section 5 describes rtpb realtime primarybackup replication service section 6 briefly discusses dependability evaluation validation tools developed project section 7 concludes paper 2 platform services developed context armada project augment essential capabilities realtime microkernel introducing composable collection communication faulttolerance testing tools provide integrated framework developing executing realtime applications tools implemented separate multithreaded servers describe experimental testbed implementation environment common aforementioned services detailed description implementation approach adopted various services given context particular service 21 general service implementation approach one common aspect different middleware services distributed realtime system need use intermachine communication armada services either include layered top communication layer provides features required correct operation service clients example rtcast implements communication protocols perform multicast integrate failure detection handling communication subsystem similarly realtime channels service implements signaling data transfer protocols reserve resources transmit realtime data along communication path since communication seemed warrant particular attention context project developed generic realtime communication subsystem architecture architecture viewed way structuring design communicationoriented services predictability opposed service architecture described detail section 3 illustrated example service realtime channel armada communication services generally layered top ip udpip use tcp main focus reliability opposed predictability timeliness realtime communication protocols hand sensitive timeliness guarantees perhaps overriding reliability requirement example video conferencing process control occasional loss individual data items preferred receiving reliable streams stale data facilitate development communicationoriented services communication subsystem implemented using xkernel objectoriented networking framework originally developed university arizona hutchinson peterson 1991 extensions controlled allocation system resources travostino et al 1996 advantage using xkernel ease composing protocol stacks xkernel communication subsystem implemented configurable graph protocol objects allows easy reconfiguration protocol stack adding removing protocols details xkernel found hutchinson peterson 1991 following microkernel philosophy argued section 1 services designed userlevel multithreaded servers clients service separate processes communicate server via kernel using user library library exports desired middleware api communicationoriented services generally implement protocol stack lies top kernellevel communication driver xkernel framework permits migration multithreaded protocol stack execution operating system kernel use feature implement server colocation microkernel colocation improves performance eliminating extra context switches note advantages server colocation defeat purpose choosing microkernel monolithic operating system development platform microkernel colocated servers developed user space greatly reduces development maintenance cost ii selectively included needed user network application application device driver protocol stack server microkernel library library stub stub user application application device driver server colocated microkernel network library library stub stub userlevel server configuration b colocated server figure 3 service implementation kernel accordance application requirements efficient sensitive particular application needs microkernel support kernel threads priority threads executing kernel space default higher threads executing user space result threads run much predictable manner service get starved overload furthermore inkernel implementation xkernel platform replaces threads device driver code running interrupt context feature reduces communication latencies makes server less preemptable migrated microkernel however since code executing interrupt context kept minimum reduction preeptability concern experiences colocated code figure 3a 3b illustrate configurations userlevel servers colocated servers respectively example server migration kernel given context rtcast service section 4 rtcast server developed user space figure 3a reconfigured integrated kernel figure 3b whether server runs user space colocated microkernel client processes use service api communicate service colocated kernel extra context switch tofrom userlevel server process saved automaticallygenerated stubs interface user library implementing service api microkernel server process stubs hide details kernels local communication mechanism programmer realtime service thus making service code independent specifics underlying microkernel 22 testbed implementation environment followingsections describe implementationof individual service provide common context description outline specifics underlying implementation platform testbed comprises several pentiumbased pcs 133 mhz connected cisco 2900 ethernet switch 10100 mbs pc connected switch via 10 mbs ethernet chosen mk 72 microkernel operating system open group og 1 research institute provide essential underlying realtime support services mk microkernel originally based release 25 mach operating system cmu fullfledged realtime os mk 72 supports kernel threads prioritybased scheduling includes several important features facilitate provision qos guarantees example mk 72 supports xkernel provides unified framework allocation management communication resources framework known cords communication objects realtime dependable sys tems travostino et al 1996 found particularly useful implementing realtime communication services implementation approach utilize functionality facilities provided ogs environment augment support necessary standpoint portability although mk72 research operating system cords support also available mainstream operating systems windows nt thus software developed cords environment easily ported nt fact port currently underway porting operating systems linux difficult time presented services developed linux support kernel threads thus impossible implement multithreaded protocol stacks inside linux kernel linux 22 however expected full thread support cords support may replaced appropriate packet filters classify incoming traffic thus modifications services may ported future versions linux well multithreaded operating systems solaris 3 armada realtime communication architecture armada provides applications witha communication architecture service request utilize guaranteedqos connections two hosts section hilight architectural components communication service together set userspecified policies implement several realtime communication models common qossensitive communication service models following three architectural requirements performance isolation connections sets connections malicious behavior overload one starve resources others ii service differentiation assigning different priorities connections classes connections iii graceful degradation presence overload developed communication library implementing priority semantics clips provides resourcemanagement mechanisms satisfy aforementioned requirements exports abstraction guaranteedrate communication endpoints endpoint called clip guarantees certain throughput terms number packets sent via per period implements configurable buffer accommodate bursty sources one connections 8or sockets may bound clip case clip sets aside enough processor bandwidth memory resources endsystem guarantee aggregate specified throughput entire connection set different clips may different priorities allow higher priority traffic proceed first overload conditions example traffic particular application middleware service bound high priority clip thereby allowing application service receive precedence services clip associated deadline parameter deadline specifies maximum communication subsystem response time handling packets via particular clip clips library implements traffic policing mechanism well default admission control policy disabled revert pure prioritydriven scheduling overridden userspecified alternate admission control policy details clips given present armada realtime communication service developed unicast communication 31 realtime communication service used clips implement guaranteedqos communication service called realtime channel ferrari verma 1990 kandlur et al 1994 realtime channel unicast virtual connection source destination host associated performance guarantees message delay available bandwidth satisfies three primary architectural requirements guaranteedqos communication mehra et al 1996 maintenance perconnection qos guarantees ii overload protection via perconnection traffic enforcement iii fairness besteffort traffic realtime communication via realtime channels performed three phases first phase source host sender creates channel destination host receiver specifying channels traffic parameters qos requirements signaling requests sent via one intermediate nodes replies delivered reverse direction successfully established send messages channel constitutes second phase sender done using channel must close channel third phase resources allocated channel released figure 4 illustrates highlevel software architecture guaranteedqos service endhosts core functionalityof communication service realized via three distinct components interact provide guaranteedqos communication applications use service via realtime communication application programming interface rtc api rtcop coordinates endtoend signaling resource reservation reclamation connection setup teardown clips performs runtime management resources qossensitive data transfer since platformspecific overheads must characterized qos guarantees ensured execution profiling component added measure parameterize overheads incurred communication service particular platform make parameters available admission control decisions control path taken architecture connection setup shown figure 4 dashed lines data transferred via rtc api clips indicated solid lines discuss salient features architectural component service along interaction components provide qos guarantees also describe components used realize particular service model reservation applications video resource rtcop clips rt control audio signalling data transfer realtime communication api lower protocol stack layers resource requirements parameters 1 memory buffer 2 pkts per period resource management mechanisms policies qos model overheads execution queryreply clips qos model translation local resources execution profiling admission control policy figure 4 realtime communication service architecture implementation consists four primary architectural components application programming interface rtc api signaling resource reservation protocol rtcop support resource management runtime data transfer clips execution profiling support dashed lines indicate interactions control path data path denoted solid lines 32 rtc application interface programming interface exported applications comprises routines connection establishment teardown message transmission reception data transfer established connections initialization support routines table 1 lists main routines currently available rtc api api two parts top half interfaces applications responsible validating application requests creating internal state bottom half interfaces rtcop signaling ie connection setup teardown clips qossensitive data transfer design rtc api based large part wellknown socket api bsd unix connection endpoint pair ipaddr port formed ip address host ipaddr unsigned 16bit port port unique host similar inet domain socket endpoint addition unique endpoints data transfer application may use several endpoints receive signaling requests applications applications willing receivers realtime traffic register signaling ports name service use wellknown ports applications wishing create connections must first locate corresponding receiver endpoints signaling initiated signaling data transfer routines table 1 counterpart socket api example routinertcregisterport corresponds invocationof bind listen succession rtcacceptconnection corresponds accept similarly routines rtccreateconnection rtcdestroyconnection correspond connect close respectively key aspect distinguishes rtc api socket api receiving application explicitly approves connection establishment teardown registering table 1 routines comprising rtc api table shows utility signaling data transfer functions constitute application interface table shows function name parameters endpoint invokes brief description operation performed routines parameters invoked function performed rtcinit none service initialization rtcgetparameter chan id param type query parameter specified realtime connection rtcregisterport local port agent function receiver register local port agent signaling rtcunregisterport local port receiver unregister local signaling port rtccreateconnection remote hostport qos sender create connection given burst size parameters remote delay endpoint return connection id rtcacceptconnection local port chan id receiver obtain next connection remote hostport already established specified local port rtcdestroyconnection chan id sender destroy specified realtime connection rtcsendmessage chan id buf ptr sender send message specified realtime connection rtcrecvmessage chand id buf ptr receiver receive message specified realtime connection intent receive signaling requests application specifies agent function invoked response connection requests function implemented receiving application determines whether sufficient applicationlevel resources available connection reserves necessary resources eg cpu capacity buffers etc new connection may also perform authentication checks based requesting endpoint specified signaling request unlike establishment tcp connection example completely transparent peer applications qosparameters passed rtccreateconnection connection establishment describe linear bounded arrival traffic generation process cruz 1987 anderson et al 1990 specify maximum message size mmax bytes maximum message rate rmax mes sagessecond maximum burst size bmax messages parameters mmax rmax used create clip corresponding guaranteed throughput burst size bmax determines buffer size required clip following describe endtoend signaling phase coordinates endtoend resource reservation 33 signaling resource reservation rtcop requests create destroy connections initiate realtime connection ordination protocol rtcop distributed endtoend signaling protocol illustrated figure 5a rtcop composed primarily two relatively independent modules request reply handlers manage signaling state interface admission control policy communication module handles tasks reliably forwarding signaling messages separation allows simpler replacement admission control policies connection state management algorithms without affecting communication functions note signaling connection establishment nonrealtime reliable functions qos guarantees apply data sent established connection signaling requests sent besteffort traffic request reply handlers generate process signaling messages interface rtc api clips reserve reclaim resources needed processing new signaling request request handler invokes multistep admission control procedure decide whether sufficient resources available new request new connection request traverses node route source destination request handler invokes admission control decides new connection locally admitted upon successful admission handler passes request next hop connection admitted nodes route reply handler destination node reserves required endsystem resources creating clip new realtime channel generates positive acknowledgment reverse path source notification received hop underlying networklevel protocol commits network resources link bandwidth using assumed local router support acknowledgement received source reply handler notifies application connection establishment creates source clip communication module handles basic tasks sending receiving signaling messages well forwarding data packets applications protocol processing performed communication module control path processing signaling messages data path functions simple transport pro 2realtime communication api handler reply request handler data transfer clips system interface resource requestsreplies routing engine lower protocol layers request message data module communication admission control module connection link allocation comm threads message buffers fragments clips link scheduler realtime communication api transmissionreception system interface resource messages lower passive resources comm thread scheduler yieldblock packets cpu allocation rtcop structure b clips structure figure 5 internal structures interfaces figure show internal functional structure rtcop clips along respective interfaces components data control paths represented solid dashed lines respectively tocol forwarding data packets behalf applications much like udp noted earlier signaling messages transported besteffort traffic delivered reliably using sourcebased retransmissions reliable signaling ensures connection considered established connection state successfully installed sufficient resources reserved nodes along route communication module implements duplicate suppression ensure multiple reservations installed connection establishment request similar considerations apply connection teardown nodes along route must release resources free connection state consistent connection state management nodes essential function rtcop rtcop exports interface rtc api specification connection establishment teardown requests replies selection logical ports connection endpoints rtc api uses latter reserve signaling port response request application example rtcop also interfaces underlying routing engine query appropriate route initiating signaling new connection general routing engine find route support desired qos requirements however simplicity use static fixed routes connections since suffices demonstrate capabilities architecture implementation 34 clipsbased resource scheduling data transfer clips implements necessary endsystem resourcemanagement mechanisms realize qossensitive realtime data transfer established connection separate clip created two endpoints realtime channel internal clip message queue buffer messages generated received corresponding channel communication handler thread process messages packet queue stage packets waiting transmitted received clips library implements endsystem key functional components illustrated figure 5b qossensitive cpu scheduling communication handler thread clip executes continuous loop either dequeuing outgoing messages clips message queue fragmenting source host dequeuing incoming packets clips packet queue reassembling messages destination host message must sent within given local delay bound deadline achieve best schedulable utilization communication handlers scheduled based earliestdeadlinefirst edf policy since operating systems provide edf scheduling clips implements userlevel scheduler layered top operating system scheduler userlevel scheduler runs static priority maintains list threads registered sorted increasing deadline given time clips scheduler blocks registered threads using kernel semaphores except one earliest deadline considers running state running thread allowed execute explicitly terminates yields using primitive exported clips scheduler blocks thread kernel semaphore signals thread next earliest deadline preemption implemented via clips primitive invoked upon sending packet primitive yields execution urgent thread one pending arrangement implements edf scheduling within single protection domain resource reservation communication handlers implemented clips execute userdefined protocol stack return clips code processing message packet ideally clip assigned cpu budget prevent communication client monopolizing cpu since processor capacity reserves available operating systems budget indirectly expressed terms maximum number packets processed within given period handler blocks processing maximum number packets allowed within stated time period policing associating budget connection handler facilitates traffic enforcement handler scheduled execution budget nonzero budget replenished next periodic invocation handler mechanism ensures misbehaving connections policed traffic specification qossensitive link bandwidth allocation modern operating systems typically implement fifo packet transmission communication link cannot avoid fifo queuing kernels network device clips implements dynamic prioritybased link scheduler bottom userlevel protocol stack schedule outgoing packets prioritized fashion link scheduler implements edf scheduling policy using priority heap outgoing packets prevent fifo accumulation outgoing packets kernel eg link busy clips link scheduler release new packet notified completion previous packet transmission besteffort packets maintained separate packet heap within userlevel link scheduler serviced lower priority realtime clips figure 6 demonstrate traffic policing traffic isolation performance differentiation realtime channels detailed evaluation found mehra et al 1998 offered load channel 1 kbs50150250delivered throughput kbs measured throughput ch 1 measured throughput ch 2 specified throughput ch 1 specified throughput ch 2 50 100 150 200 250 300 350 offered load besteffort channel kbs50150250delivered throughput kbs isolation realtime channels b isolation besteffort realtime figure 6 traffic isolation left graph shows real time channel 1 policed traffic specification disallowing violation specification traffic realtime channel 1 affect qos realtime channel 2 right graph shows increasing besteffort load interfere realtime channel throughput 4 rtcast group communication services previoussection introduced architecture armada realtime communication service architecture sets ground implementing realtime services qossensitive communication second thrust project focused collection services provide modular composable middleware constructingembedded applications armada middleware divided two relatively independent suites services ffl rtcast group communication services ffl rtpb realtime primaryback replication service section presents rtcast suite group communication faulttolerance ser vices section 5 describes rtpb realtime primarybackup replication service 41 rtcast protocols qossensitive communication service described section 3 support multicast channels multicast important eg efficient data dissemination set destinations maintaining replicated state faulttolerant systems consistency replicated state desired membership algorithm also needed rtcast complements aforementioned unicast communication services mulitcast membership services realtime faulttolerant applications rtcast based around process groups paradigm process groups widelystudied paradigm designing distributed systems asynchronous birman 1993 amir et al 1992 van renesse et al 1994 mishra 1993 synchronous kopetz grunsteidl 1994 amir et al 1995 cristian et al 1990 en vironments approach distributed system structured group cooperating processes provide service application process group may used example provide active replication system state rapidly disseminate information application collection processes two key primitives supporting process groups distributed environment faulttolerant multicast communication group membership coordination process group must address several subtle issues including delivering messages group reliable fashion maintaining consistent views group membership detecting handling process communication failures multicast messages atomic globally ordered consistency replicated state guaranteed rtcast especially designed realtime applications realtime application timing failures may damaging processor failures thus membership algorithm aggressive ensuring timely progress process group example ensuring atomicity message delivery rtcast require acknowledgments every message message delivery immediate without needing additional rounds message transmissions ensure message received consistently des tinations rtcast designed support hard realtime guarantees without requiring static schedule computed priori application tasks messages instead online schedulability analysis component performs admission control multicast mes sages envision proposed multicast membership protocols part larger suite middleware group communication services form composable architecture development embedded realtime applications illustrated figure 7 rtcast suite services include timed atomic multicast group membership service admission control service first two tightly coupled thus considered single service clock synchronization typically required realtime protocols enforced clock synchronization service support portability virtual network interface layer exports uniform network abstraction ideally interface would transparently handle different network topologies different connectivity timing bandwidth characteristics exporting generic network abstraction upper layers network assumed support unicast datagram service finally top layer provides application programming interface realtime process group rtcast supports boundedtime message transport atomicity order multicasts within group communicating processes presence processor crashes communication failures guarantees agreement membership among communicating processors ensures membership changes eg resulting processor joins departures atomic ordered respect multicast messages rtcast assumes processes communicate environment sending messages thus failed process example cannot adversely affect environment via hidden channel rtcast proceeds senders logical ring take turns multicasting messages network processors turn comes logical token arrives times waiting last message sender multicasts heartbeat used crash detection heartbeat received immediate predecessor also serves logical token destinations detect missed messages using sequence numbers unreliable unicast communication virtual network interface realtime process groups api admission control schedulability analysis timed atomic multicast communication group membership service clock synchronization figure 7 software architecture rtcast middleware services processor detects receive omission crashes processor turn comes checks missing heartbeats eliminates crashed members group membership multicasting membership change message token ring sent messages natural order defined token rotation reconstruct message order receivers using protocol layer rtcast detects outoforder arrival messages swaps thus forwarding rtcast correct order rtcast ensures correct members reach agreement replicated state formulating problem one group membership since state process determined sequence messages receives processor detects message receive omission takes group thus maintaining agreement among remaining ones realtime system one may argue processes waiting message arrive miss deadlines anyway acceptable eliminate suffered receive omissions 2 distinctive feature rtcast processors omit messages deliver messages soon arrive without compromising protocol semantics thus example reliable multicast used disseminate critical message replicated server one replicas suffers receive omission rtcast eliminate replica group delivering message remaining replicas immediately contrast delaying delivery message replicas received approach motivated observation realtime system may better sacrifice one replica group delay message delivery potentially causing replicas miss hard timing constraint finally membership changes communicated exclusively membership change messages using multicast mechanism since message multicast atomic ordered membership changes guarantees agreement membership view architectural standpoint rtcast operation triggered two different event types namely message reception token reception timeout therefore logically 1 msg reception handler 2 state running 3 msgs member 4 missed msgs crash else 5 deliver msg 6 else msg different member 7 missed msgs crash else 8 check missed msgs processors current last senders 9 missing msgs 10 deliver current msg 11 else crash 12 else join msg nonmember 13 handle join request 14 state joining msg valid join ack 15 need join acks 16 wait additional join acks 17 else state running 18 end figure 8 message reception handler structured two event handlers one event type message reception handler figure detects receive omissions delivers messages order application services protocol control messages token handler figure invoked token received token timeout expires detects processor crashes sends membership change notifications well lets client processes send messages processors finite token hold time 42 rtcast design implementation section describes major issues design implementation rt representative group communication service thorough performance evaluation service reported abdelzaher et al 1996 abdelzaher et al 1997 rtcast application implemented tested local ethernet ethernet normally unsuitable realtime applications due packet collisions subsequent retransmissions make impossible impose deterministic bounds communication delay however since use private ethernet ie rtcast protocol exclusive access medium one machine send messages given time namely token holder prevents collisions guarantees ethernet driver always succeeds transmitting packet first attempt making message communication delays deterministic admission control service described previously take 1 token handler 2 state running 3 processor p current membership view 4 heartbeat seen predecessors incl p 5 remove p group view 6 multicast new group view 7 send queued messages 8 mark last msg 9 send heartbeat msg 10 state joining 11 send join msg 12 end figure 9 token handler advantage predictability eg creating appropriate clips manage endsystem resources host make realtime guarantees messages sent rtcast 421 protocol stack design rtcast protocol designed modular individual services could added changed removed without affecting rest protocol service designed separate protocol layer within xkernel hutchinson peterson 1991 protocol framework xkernel ideal choice implementing rtcast middleware services application requirements easily met simply reconfiguring protocol stack add remove services necessary rtcast implementation uses following protocol layers admission control admission control schedulability analysis acsa layer distributed protocol keeps track communication resources entire process group protocol transparently creates clip host runs process group ensure communication throughput guarantees timebounded message processing support multiple either prioritized performance isolated process groups machine creating clips corresponding priority corresponding minimum throughput specification realtime guarantees needed layer omitted protocol stack reduce overhead communication proceed besteffort basis rtcast rtcast protocol layer encompasses membership logical token ring atomic ordering services described section 4 multicast transport protocol implements unreliable multicast abstraction independent underlying network rtcast uses multicast transport layer send messages group without worry whether physical medium provides unicast broadcast true multicast support details messages actually sent network hidden higher layers multicast transport user kernel user kernel kernel ethernet driver kernel ethernet driver ip acsa rtcast mcast rtcast mcast ip asca cords userlevel server b split inkernel cords server application application figure 10 rtcast protocol stack implemented protocol layer must modified rtcast run different types networks figure shows full protocol stack implemented platform 422 integration mach kernel figure 10 shows protocol stack representing core service migrated mach kernel actual rtcast development took place user space facilitate debugging final colocation within mach kernel several performance advantages first group communication protocol high amount cpu overhead maintain group state enforce message semantics running kernel rtcast protocol run highest priority minimize communication latency due processing time second current implementation mk 72 operating system support realtime scheduling capacity reserve experience shows processes running user level starved cpu time periods seconds would disastrous rtcasts predictable communication running kernel protocol threads get starved significantly scheduled much predictable manner operating system finally problem mk 72 implementation xkernel threads shepherding messages protocol stack queued run different order messages arrive network results outoforder messages must buffered reordered maintain total ordering guarantees provided protocol buffer reorder messages also delays crash detection since way knowing missing message queued somewhere protocol stack sender suffered failure running protocol kernel message threads interrupt driven run immediately arriving network message reordering problem occur protocol performance improved 0almost order magnitude executed kernel example executed userlevel minimum token rotation time average 26 ms 57 ms 96 ms groups one two three members respectively running kernel measurement yielded token rotation times 043 ms 102 ms 155 ms found improvement extended aspects protocol performance note figures suggest potential scalability problem larger group sizes hundreds nodes problem attributed need software token passing integration hardware token passing schemes fddi yield much better performance alternatively improve scalability currently investigating approach based group composition larger process groups formed composition smaller ones research presently underway initial results show composite process groups scale much better monolithic ones another important focus developing group communication middleware designing robust api would allow application developers take advantage services quickly easily rtcast api includes bandwidth reservation calls ii process group membership manipulation functions iii besteffort multicast communication primitives iv reliable realtime multicast bandwidth reservation used hosts ensure multicast connection dedicated cpu capacity network bandwidth ie minimum token hold time token hold time token rotation period specify communication bandwidth allotted node node set aside enough endsystem resources utilize allotted communication bandwidth creating clip acsa layer corresponding throughput thereby providing schedulability guarantees membership manipulation functions allow processes join leave multicast group query current group membership create groups etc two types group communication realtime multicast communication guarantees endtoend response time besteffort advantages using besteffort connection optimized throughput opposed meeting individual message deadlines thus service protocol stack faster average eg permessage admission control variance queuing delays higher collaborated group researchers honeywell technology center implement subset faulttolerant realtime distributed applicationdescribed section 1 using rtcast protocol using insights gained motivating application able refine api provide required functionality maintaining simple interface easy program based experience applications use protocol also designed higherlevel service library linked application uses rtcast api 3 concerned resource management faulttolerant system providing higherlevel abstractions protocol communication primitives service library provides logical processing nodes resource pools transparently utilize rtcast group communication services abstractions provide convenient way application developers reason structure redundancy management failure handling policies rtcast actual work maintaining replica consistency 5 realtime primarybackup rtpb replication service previous section introduced middleware service active replication section present overall architecture armada realtime primarybackup replication service first give introduction rtpb system describe service framework finally discuss implementation service believe meets objectives 51 introduction rtpb keeping large amounts application state consistent distributed system state machine approach may involve significant overhead many realtime applications however tolerate minor inconsistencies replicated state thus reduce redundancy management overhead primarybackup replication exploits application data semantics allowing backup maintain less current copy data resides primary application may distinct tolerances staleness different data objects sufficiently recent data backup safely supplant failed primary backup reconstruct consistent system state extrapolating previous values new sensor readings however system must ensure distance primary backup data bounded within predefined time window data objects may distinct tolerances far backup lag behind object state becomes stale challenge bound distance primary backup consistency compromised minimizing overhead exchanging messages primary backup 52 service framework important issue designing replication service consistency semantics one category consistency semantics particular relevant primarybackup replication realtime environment temporal consistency consistency view seen perspective time continuum two types temporal consistency often needed ensure proper operation primarybackup replicated realtime data services system one external temporal consistency object external world image servers interobject temporal consistency different objects events primarybackup system said satisfy external temporal consistency object timestamp server later predetermined time timestamp client real data words order provide meaningful correct service state primary server must closely reflect actual world consistency also needed backup backup successfully replace primary primary fails consistency restriction placed backup may tight primary must within tolerable range intended applications interobject temporal consistency maintained object pair temporal temporal distance two neighboring updates object j respectively observed primary backup although usefulness practical application external temporal consistency concept easy see true interobject temporal consistency illustrate notion interobject temporal consistency considering airplane taking time bound accelerating plane lifting plane air runway limited length airplane keep accelerating runway indefinitely without lifting primarybackup replicated realtime data service interobject temporal consistency constraint object pair placed backup different placed primary 53 rtpb implementation temporal consistency model realtime primarybackup rtpb replication service developed zou jahanian 1998 practical version system implements models built following composability model rtpb service implemented independent userlevel xkernel based server mk 72 based platform system includes primary server backup server client application resides machine primary client continuously senses environment periodically sends updates primary client accesses server using library utilizes mach ipcbased interface primary responsible backing data backup site limiting inconsistency data two sites within required window following assumptions made implementation ffl link failures handled using physical redundancy network partitions avoided ffl upper bound exists communication delay primary backup missed message deadlines treated communication performance failures ffl servers assumed suffer crash failures figure shows system architecture xkernelprotocol stack replication server bottom five layers rtpb ethdrv make xkernel protocol stack top level stack realtime primarybackup rtpb protocol serves anchor protocol xkernel protocol stack provides interface xkernel based server connects rest protocol stack xkernel uniform protocol interface underlying transport protocol udp since udp provide reliable delivery messages need use explicit acknowledgments necessary top two layers primarybackup hosts client applications primary host interacts backup host underlying rtpb protocol two identical versions client application residing primary backup hosts respectively normally client version primary running osf mach kernel osf mach kernel ethernet backup rtpb api udp ip primary rtpb api udp ip xkernel paths rtpb server rtpb server figure 11 rtpb architecture server protocol stack backup takes case primary failure also activates backup client version bring recent state client application interacts rtpb system mach api interface developed system interface enables client create destroy manipulate query reliable objects ie backedup server specifically rtpb create destroy creates objects destroys objects rtpb system rtpb register register objects system rtpb update rtpb query update query objects finally list return list objects already registered rtpb system detail admission control update scheduling failure detection recovery appears recent report zou jahanian 1998 54 rtpb performance following graph shows rtpb response time client request temporal distance primary backup graphs depicted function number objects admitted system four different client write rates 100 300 700 1000 milliseconds graph shows fast response time client request range 200 400 mi croseconds mainly due decoupling client request process updates backups graph b shows rtpb keeps backup close primary terms temporal distance corresponding data copies replicated objects graph distance ranges 10 110 milliseconds well within range tolerable realtime applications two graphs show rtpb indeeds provide fast response client requests maintain backups close primary system state number object accepted primary10003000client response time microseconds window ms window ms window ms window ms 1000 2000 3000 4000 5000 number objects accepted primary5001500average maximum distance response time client b primarybackup distance figure 12 rtpb performance graphs 6 evaluation tools third thrust armada project provide tools validating evaluating timeliness fault tolerance capabilities target system two tools developed date orchestra messagelevel fault injection tool validation evaluation communication middleware protocols cogent network traffic workload generator following two subsections describe two tools briefly 61 orchestra armada project primarily concerned developing realtime distributed middleware protocols communication services ensuring distributed system communication protocol meets prescribed specification growing challenge confronts software developers system engineers meeting challenge particularly important applications strict dependability timeliness constraints orchestra fault injection environment used perform fault injection communication protocols distributed applications orchestra based simple yet powerful framework called scriptdriven probing fault injection emphasis approach experimental techniques intended identify specific problems protocol implementation rather evaluation system dependability statistical metrics fault coverage eg arlat et al 1990 hence focus developing fault injection techniques employed studying three aspects target protocol detecting design implementation errors ii identifying violations protocol specifications iii obtaining insights design decisions made implementors orchestra approach fault injection layer inserted communication protocol stack protocol tested messages exchanged protocol participants pass fault injection layer path tofrom network time message sent orchestra runs script called send filter message manner receive filter invoked message received network destined target protocol scripts perform three types operations messages ffl message filtering intercepting examining message ffl message manipulation dropping delaying reordering duplicating modifying message ffl message injection probing participant introducing new message system orchestra toolset mk 72 platform based portable fault injection core developed cordsbased xkernel framework provided opengroup tool implemented xkernel protocol layer placed level xkernel protocol stack tool used perform experiments group interprocess communication gipc services open group middleware realtime channel services developed part armada project details orchestra found several recent reports eg dawson et al 1996 dawson et al 1997 62 cogent controlled generation network traffic order demonstrate utility armada services necessary evaluate range operating conditions many protocols developed rely communication subsystem important evaluate range realistic background traffic generating traffic fairly difficult since traffic characteristics vary widely depending environment services deployed end weve developed cogent controlled generation network traffic cogent networked synthetic workload generator evaluating system network performance controlled reproducible fashion based simple clientserver model allows user flexibly model network sources order evaluate various aspects network distributed computing implemented c lexyacc front end current version tool takes high level specification distributed workload generates highly portable c code clients servers specified user select number distributions used model variety network sources poisson paxson floyd 1994 paxson 1994 log normal paxson floyd 1994 pareto leland et al 1994 crovella bestavros 1996 garret willinger 1994 log extreme paxson 1994 tool generates necessary compilation distribution scripts building running distributed workload cogent also implemented java generator generated code java based portability java implementation simplifies compilation distribution workload considerably also plan addressing cpu issues order model common activities end hosts well another feature added ability client server run tracedriven mode run web server tcpdump mccanne jacobson 1993 log file finally implementing additional source models order keep current literature 7 conclusions paper presented architecture current status armada project conducted university michigan collaboration honeywell technology center described number communication middleware services developed context project illustrated general methodology adopted design integrate services modularity composability armada middleware realized set servers top microkernelbased operating system special attention given communication subsystem since common resource middleware services developed proposed general architecture qos sensitive communication also described communication service implements architecture currently redesigning existing command control application benefit armada middleware application requires bounded time endtoend communication delays guaranteed communication subsystemas well faulttolerant replication backup services provided rtcast group communication membership support primarybackup replication service testing tools orchestra help assess communication performance verify required communication semantics controlled workload generation using cogent assist creating load conditions interest may difficult exercise via regular operation application services tools designed independently underlying microkernel communication subsystem choice experimentation platform based largely rich protocol development environment provided xkernel cords better portability extending communication subsystem provide socketlike api also investigating scalability services developed scaling large embedded systems may depend way system constructed smaller units looking appropriate ways defining generic structural system components composing large architectures components certain desirable properties globally preserved developing tokens operators system composition enable building predictable analytical semantic models larger systems properties individual constituents notes 1 open group formerly known open software foundation osf 2 lower communication layer may support bounded number retransmissions 3 apis service library rtcast protocol available httpwwweecsumichedurtclarmadartcastapihtml r lightweight multicast realtime process groups tr xkernel process group approach reliable distributed computing ttpa protocol faulttolerant realtime systems selfsimilar nature ethernet traffic extended version empirically derived analytic models widearea tcp connections analysis modeling generation selfsimilar vbr video traffic totem singlering ordering membership protocol selfsimilarity world wide web traffic experiments six commercial tcp implementations using software fault injection tool faulttolerance advanced automation system realtime communication multihop networks testing faulttolerant realtime distributed systems via protocol fault injection rtcast structuring communication software qualityofservice guarantees realizing services guaranteedqos communication microkernel operating system realtime primarybackup rtpb replication temporal consistency guarantees design performance horus lightweight group communications system
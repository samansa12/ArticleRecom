communicationbased prevention useless checkpoints distributed computations useless checkpoint local checkpoint cannot part consistent global checkpoint paper addresses following problem given set processes take basic local checkpoints independent unknown way problem design communicationinduced checkpointing protocols direct processes take additional local forced checkpoints ensure local checkpoint useless paper first proves two properties related integer timestamps associated local checkpoint first property necessary sufficient condition timestamps must satisfy checkpoint useless second property provides easy timestampbased determination consistent global checkpoints general communicationinduced checkpointing protocol proposed protocol derived two previous properties actually defines family timestampbased communicationinduced checkpointing protocols shown several existing checkpointing protocols problem particular instances general protocol design general protocol motivated use communicationinduced checkpointing protocols consistent global checkpointbased distributed applications detection stable unstable properties determination distributed breakpoints b introduction local checkpoint snapshot local state process global checkpoint set local checkpoints one process consistent global checkpoint global checkpoint message sent process local checkpoint received another process local checkpoint consistency global checkpoints strongly depends flow messages exchanged processes determination consistent global checkpoints fundamental problem distributed computing arise many applications detection stable properties 5 12 17 determination breakpoints 7 10 20 detection unstable properties 2 6 11 13 rollback recovery upon failure occurences 8 14 22 etc processes independently take local checkpoints risk consistent global checkpoint ever formed except first one composed initial states caused wellknown unbounded domino effect 22 even consistent global checkpoints formed still possible local checkpoints never included consistent global checkpoint local checkpoints called useless prevent useless checkpoints thus safely prevent domino effect coordination taking local checkpoints required family coordinated protocols 5 15 processes use additional control messages synchronize checkpointing activities additional synchronization may result reduced process autonomy degraded performance underlying application drawbacks given rise development family communicationinduced checkpointing protocols family coordination achieved piggybacking control information application messages control messages synchronization added application 8 precisely processes take local checkpoints independently 1 called basic checkpoints protocol directs take additional local checkpoints called forced checkpoints ensure local checkpoint becomes useless taking forced checkpoint message delivery safe strategy prevent useless checkpoints inefficient given set basic checkpoints fewer forced checkpoints taken communicationinduced checkpointing protocol better pro tocol process decides whether take forced checkpoint message received evaluating predicate predicate based local control variables receiving process control values carried message local control variables managed process coding causal dependencies appearing past distinct semantics control variables distinct definitions predicate give rise different protocols 1 3 4 14 19 23 24 26 paper present new communicationinduced checkpointing protocol takes forced checkpoints possible ensuring local checkpoint useless protocol based zpath zcycle theory introduced netxer xu 21 showed useless checkpoint exactly corresponds existence zcycle distributed computation model level protocol prevents zcycles 2 operational level sequence number lamport timestamp associated local checkpoint moreover message piggybacks integer lamport clock value vector integers checkpoint sequence numbers two boolean vectors size vector n number processes protocol efficient 3 past dominofree communicationinduced checkpointing protocols interesting feature proposed protocol following one local checkpoint easy determination consistent global checkpoint belongs moreover proposed protocol enjoys nice genericity property reduce size control information even eliminate altogether protocol 1 example detection unstable properties conjunctions local predicates process takes basic checkpoint time local predicate becomes true 13 2 manivannansinghals classification 18 protocol belongs zcf zcyclefree family 3 considering number forced local checkpoints taken processes 4 jm helary mostefaoui r netzer raynal reduces already known protocols 1 19 23 result protocol offers general efficient framework family dominofree communicationinduced checkpointing protocols paper divided seven sections section 2 presents model distributed computations provides definition consistent global checkpoints defines zpaths section 3 presents design principles protocol section 4 describes first version protocol proves main property namely given local checkpoint c easy determination consistent global checkpoint c belongs section 5 reduces size data structures used protocol presents improved version finally section 6 discusses protocol shows reduces existing protocols reducing control information section 7 concludes paper distributed computations checkpoints zpaths 21 distributed computations distributed computation consists finite set p n processes fp communicate synchronize exchanging messages assume ordered pair processes connected asynchronous reliable directed logical channel whose transmission delays unpredictable finite note channels required fifo process runs different processor processors share common memory bound relative speeds also fail according failstop model process execute internal send 4 delivery statements internal statement involve communication p executes statement sendm puts message channel p p j p executes statement deliverm blocked least one message directed p arrived message withdrawn one input channels delivered p executions internal send delivery statements modeled internal sending delivery events processes distributed computation sequential words process p produces sequence events e sequence finite infinite every process p initial local state denoted oe i0 local state oe 0 results execution sequence applied intial state oe i0 precisely event e moves p local state oe isgamma1 local state oe definition say e ix belongs oe js sometimes denoted let h set events produced distributed computation computation modeled partially ordered set b hb denotes wellknown lamports happenedbefore relation 16 22 local global checkpoints local checkpoints local checkpoint c recorded state snapshot process every local state necessarily recorded local checkpoint set local checkpoints subset set local states definition 21 communication checkpoint pattern pair b h distributed computation c b h set local checkpoints defined b c ix represents xth local checkpoint process p local checkpoint c ix corresponds local state oe x figure 1 shows example checkpoint communication 4 assume process send messages irisa communicationbased prevention useless checkpoints distributed computations 5 pattern 5 assume process p takes initial local checkpoint c i0 corresponding oe i0 event checkpoint eventually taken ik1 ik2 ik3 j1 figure 1 checkpoint communication pattern message sent process p process p j called orphan respect ordered pair local checkpoints c ix c jy iff delivery belongs c jy deliverm 2 c jy sending event belong c ix sendm 62 c ix ordered pair local checkpoints consistent iff orphan messages respect pair example figure 1 shows pair c k1 c j1 consistent pair c i2 c j2 inconsistent orphan message 5 global checkpoints global checkpoint set local checkpoints one process example two global checkpoints depicted figure 1 definition 22 global checkpoint consistent iff pairs local checkpoints consistent example figure 1 shows fc i1 c consistent global checkpoint due inconsistent pair c i2 c j2 global checkpoint fc consistent 23 zpaths zcycles sequence events occurring p c called checkpoint interval denoted ix see figure 1 zpath notion introduced first time netzer xu 21 generalizes notion causal path messages defined lamports happenedbefore relation precisely definition 23 zpath exists local checkpoint local checkpoint b precedes b process sequence messages exists 1 precedes sendm 1 process 2 erlier interval sendm i1 3 deliverym q precedes b process figure zpath c k0 c i2 two zpaths c i2 c k2 definition 24 zpath two consecutive messages ff ff1 form zpattern 5 figure uses usual spacetime diagram local checkpoints indicated black rectangular boxes local states explicitly indicated 6 jm helary mostefaoui r netzer raynal figure 1 see two zpatterns definition 25 zpath causal iff include zpatterns ie delivery event message except last occurs send event next message sequence zpath noncausal iff causal zpath one message trivially causal every noncausal zpath concatenation shorter causal zpaths figure 1 noncausal zpath concatenation causal zpaths 3 definition 26 zpath local checkpoint c ix local checkpoint c ix called zcycle say involves local checkpoint c ix zpath zcycle involves local checkpoint c k2 observe zcycle always includes zpattern 24 useless checkpoints definition 27 local checkpoint c ix useless iff cannot belong consistent global checkpoint following important characterization useless checkpoints stated 21 theorem 21 netzerxu 1995 local checkpoint c ix useless iff involved zcycle example figure 1 c k2 useless zpath zcycle including c k2 includes zpattern interested reader find proof theorem 21 25 3 design principles protocol set c b checkpoints taken execution computation b h composed basic checkpoints forced checkpoints indicated introduction basic checkpoint taken depends application property detection protocol rollbackrecovery protocol forced checkpoints taken communicationinduced checkpointing protocol ensure checkpoint useless aim protocol wish design keep low number forced checkpoints protocol works evaluating predicate upon every message reception possibly taking forced checkpoint hence name communicationinduced checkpointing pro tocol predicate based past knowledge communication checkpointing patterns forced checkpoints taken prevent zcycles forming 31 basic idea checkpoint timestamping mechanism checkpoint c let us associate timestamp denoted ct consider following domain timestamp values set positive integers protocol based following theorem theorem 31 pair checkpoints c jy c kz zpath c jy zcycle irisa communicationbased prevention useless checkpoints distributed computations 7 proof part suppose zcycle exists c ix c ix zcycle zpath c ix c ix assumption theorem would imply c ix c ix part zcycle zgraph whose vertices local checkpoints paths zpaths partially ordered follows topological sort local checkpoints required property 2 theorem 31 idea underlying theorem design protocol manages timestamps takes forced checkpoints way timestamps always increase along zpath zcycles possibly form checkpoints useless assume process p local logical clock lc managed following classical way 16 ffl takes basic forced checkpoint p increases 1 local clock associates new value checkpoint ffl every message timestamped value sender clock let mt timestamp associated ffl process p receives message updates local clock lc maxlc follows classical mechanism causal zpath c jy c kz c jy c kz examine case noncausal zpaths 32 checkpoint checkpoint given previous timestamping mechanism let us consider situation depicted figure 2a c jy local checkpoint taken p j sending 1 c kz first checkpoint p k taken delivery 2 sending 2 delivery 1 belong interval constitutes zpattern c jy c kz ckz b figure 2 must p take forced checkpoint two cases occur case c jy hence zpattern consistent assumption theorem 31 case safe strategy prevent zcycle formation consists directing p take forced checkpoint c ix delivering 1 shown figure 2b breaks longer zpattern strategy implemented following way process p manages boolean array sent 1n order know whether reception message creates zpattern 8 jm helary mostefaoui r netzer raynal sent k value true iff p sent message p k since last checkpoint moreover manages array integers min 1n min k keeps timestamp first message sent p k since p last checkpoint condition expressed sent takes forced checkpoint c true next section shows safe strategy improved sharpening predicate cause fewer forced checkpoints taken 33 reducing number forced checkpoints previous strategy utilize information p could concerning values local clocks processes k1 k n let us denote cl k value p k local clock perceived p p obtain knowledge classical piggybacking technique shown section 41 obviously cl perception local clock p approximation cl k lc k consider situation depicted figure 2a message 1 arrives p j creating zpattern message 2 sent 6 p k following property holds cl zpattern consistent assumption theorem 31 let us consider property p case 1 carries value lc j 1 sent first relation c jy necessarily holds 1 received property p violated 1 received 1 cl k cl k c kz follows prevent formation zpattern would violate property p consequently could possibly inconsistent assumptions theorem 31 protocol requires p take forced checkpoint delivering 1 application 1 cl k cl question determine value cl k approximation cl k refers let us examine two possible cases ckz ckz b figure 3 cl k lower bound c kz value cl k brought p causal zpath started p k c kz situation illustrated figure 3 precisely cl k brought p 1 figure 3a 2 delta 1 figure 3b case cl consequently p take forced checkpoint 1 cl k 6 recall ckz first checkpoint taken pk delivery m2 irisa communicationbased prevention useless checkpoints distributed computations 9 ii value cl k brought p causal zpath started p k c kz situation illustrated figure 4 precisely relevant causal zpath 1 figure 4a figure 4b note figures redrawn indicated figure 5 causal zpath brings p last value p k local clock 1 2 delta 1 case cl k c kz exactly corresponds pattern described figure 5 problem p recognize pattern take forced checkpoint occurs let c 1 predicate describing pattern occurrence b figure 4 cl k lower bound c kz ckz figure 5 causal zpath discussion follows previous condition c p tests know take forced checkpoint receives message 1 refined c 0 sent k cl next section shows express predicate appropriate data structures evaluated online process 4 first version protocol section presents first version protocol directly obtained previous analysis version theorems section 5 provide less costly version protocol 41 data structures addition arrays sent 1n min 1n previuosly described every process p maintains following data structures array clock process p manages array clock 1n following meaning clock highest value lc k known p note clock lc require lc following array initialized managed 7 note clock vector containing lamport timestamps jm helary mostefaoui r netzer raynal ffl takes basic forced checkpoint p increments clock 1 definition lc sends message current value clock appended let mclock receives p j performs following updates lamport clock statement updates clock using data structure p receives message 1 cl thus elements c 0 rewritten sent k next two arrays provide way evaluate c 1 array ckpt array vector clock counts many checkpoints taken process ckpt number checkpoints taken p k p knowledge vector clock managed usual way 9 let mckpt value appended sender p ie value array ckpt sending time array taken boolean array used conjunction ckpt evaluate c 1 following meaning taken k true iff causal zpath last checkpoint p k known p next checkpoint p causal zpath includes checkpoint managed following way p takes checkpoint sets true entries except ith one taken always remains ffl sends message p appends current value taken let mtaken value ffl receives p updates taken following way order maintain meaning docase data structures condition c 1 expressed following way considering figure 5 first part condition c 1 states causal zpath namely starting c ix arriving p c ix1 second part c 1 indicates process taken checkpoint along causal zpath irisa communicationbased prevention useless checkpoints distributed computations 11 42 protocol protocol executed process p described figure 6 s0 s1 s2 describe initialization statements executed p sends message statements executes receives message respectively procedure take checkpoint called time p takes checkpoint basic forced indicated previously basic checkpoint taken part protocol procedure take checkpoint 8k sent k false enddo 8k min k 1 enddo clock save current local state copy clock ix checkpoint c ix initialization 8k clock k 0 ckpt k 0 enddo taken false take checkpoint sends message pk sent k sent k true min k clock endif receives clock ckpt taken p j mclockj lamports timestamp ie mt sent k take checkpoint forced checkpoint clock update scalar clock lc clock case case figure first version protocol 43 property protocol following theorem shows consistent global checkpoint c associated lamport timestamp follows given local checkpoint c ix timestamped ie c ix easily associated consistent global checkpoint belongs theorem 41 let lamport timestamp 0 let c global checkpoint c 1x defined following way 8k c kx k last checkpoint p k c kx k c consistent global checkpoint proof suppose c consistent c contains pair checkpoints c ix c kz exists message 2 sent p p k sendm 2 12 jm helary mostefaoui r netzer raynal assumption c kz p1 construction timestamps c ix consequently ckz ix1 figure 7 message 2 orphan respect c ix c kz let c ix1 first checkpoint taken p c ix let c kz gamma1 last checkpoint taken c kz see figure 7 assumption c ix1 assumption combined p2 gives p3 moreover assumption combined p1 gives c kz c ix1 p4 ckz ckz b ikz figure 8 causal noncausal zpaths p3 implies two consecutive local checkpoints c ix c ix1 clock p namely clock incremented least two assumption local checkpoint taken p c ix c ix1 incrementation occur interval ix1 p receives least one message whose timestamp equal c ix1 gamma 1 let 1 first message deliverm 1 figure 8a c kz contradicts p4 thus situation depicted figure 8b 1 arrives ffl 2 sent ffl min p4 p j sender conclude 1 clockj min k p6 recall condition c 0 tested p know take forced checkpoint receives sent k arrives shown p5 p6 first two lines condition satisfied show case analysis checkpoint necessarily taken p c ix c ix1 contradicts hypothesis ffl case clock case 1 received maxclock combining p4 get maxclock irisa communicationbased prevention useless checkpoints distributed computations 13 p5 p6 p7 follows p take checkpoint c ix c ix1 contradicts hypothesis ffl case clock exists causal zpath c kz c ix1 zpath figure 4b case 1 received 1 p8 p5 p6 p8 follows p take checkpoint c ix c ix1 contradicts hypothesis ffl case clock case causal zpath 1 starting c kz arriving p c ix situation described figure 4a let 0 message ending 1 received p note message 0 received p sending 2 case would c kz reception 0 see discussion section 33 sent receiving 0 lamport clocks strictly increase along causal zpath namely 2 checkpoint taken pattern described figure 5 detected condition c 1 follows p taken checkpoint c ix c ix1 received 0 contradicts hypothesis theorem 41 5 improved version protocol section first proves invariant protocol invariant used simplify condition c 0 consequently derive less costly version protocol 51 invariant theorem 51 following assertion invariant sent k proof let k two given process numbers must show property ii sent k execution p end show 1 property holds p initialization base case 2 property holds event still holds execution induction events considered modify values variables involved property namely taking checkpoint sending reception message denoted take checkpoint s1 s2 figure 6 respectively remind lamport clocks property relation clock clock k always true consequently message sent p j mclockj mclockk event triggers actions modifying value variable x denote x value event x 0 value event 14 jm helary mostefaoui r netzer raynal base case sent k initialized value false property initially holds induction taking checkpoint property holds beginning checkpoint interval since array sent reset false sending message p p k note array clock modified s1 ffl sent k value false first sending p k s1 min thus s1 min k clock k clock s1 follows holds s1 ffl sent k value true first sending p k arrays clock min modified sending follows still holds s1 reception p message sent p j modify values clock clock k arrival forces p take checkpoint ii trivially holds s2 sent reset false examine case arrival force p take checkpoint means condition c 0 protocol satisfied ie sent k false s2 s2 modify variable ii still holds s2 thus examine case one two last terms satisfied note implies ease proof use following notations ck following assumptions ag holds event ck ck 0 property lamport clocks mck property lamport clocks checkpoint taken must prove relation r c remains true s2 two cases considered according two terms assumption g irisa communicationbased prevention useless checkpoints distributed computations 15 first case g1 mcj get c thus c mcj b reduces c c get maxck 0 maxck thus using successively e get maxck conclude replacing b c mcj values defined 1 respectively get due mcj maxck mck g2 reduces due c reduces c theorem 51 52 simplifying condition condition used process p decide whether take forced checkpoint receives message sent k mclockj min k following theorem shows condition simplified theorem 52 sent k c 0 j proof let us consider following set predicates j sent k ffl first show c 1 condition c 1 introduced section 32 characterizes situation depicted figure 9 message sent p j terminates causal zpath 0 delta 1 delta 2 deltam 1 starts 0 arrive p c ix1 3 along zpath process p l taken checkpoint c lz mtakeni true lamport timestamps decrease increase checkpoint taken jm helary mostefaoui r netzer raynal figure 9 c 1 characterizes follows c 1 sent k min k mclockj previous notations ffl using classical logic rules definition c 0 definition due invariant e c 1 e independent definition theorem 52 53 reducing size data structures theorem 52 shows array min 1n used condition consequently suppressed finer analysis shows array clock 1n replaced single integer lc plus boolean array greater 1n comes following two observations consider see ffl element array clock used clock ie lamport clock p ffl mclockj mclockk always true remind mclockj highest clock value known p j sends follows subcondition mclockj mclockk equivalent mclockj 6 mclockk follows process p array clock 1n replaced single lamport clock lc whose value equal clock plus boolean array greater 1n whose meaning new data structures condition rewritten consequently messages piggyback lamport clock value boolean array instead array lamport clock values resulting protocol described figure 10 update integer array clock replaced update boolean array greater process manages clock n checkpoint sequence numbers 3 n booleans message piggybacks booleans irisa communicationbased prevention useless checkpoints distributed computations 17 procedure take checkpoint 8k sent k false enddo save current local state copy lc ix checkpoint c ix initialization 8k ckpt k 0 enddo taken false greater false take checkpoint sends message pk sent k true receives lc greaterckpt taken p j mlc lamports timestamp take checkpoint forced checkpoint case case docase enddocase figure 10 final protocol 6 discussion section discusses protocol shows provides general framework existing protocols obtained ffl let us suppress data structures except array sent 1n replaced single boolean sent following meaning sent sent k ie sent true iff message sent p since last checkpoint protocol becomes drastically simplified reduces wellknown russell protocol 23 8 shown figure 11 russels protocol characterized following property considering deliver send checkpoint events behavior process corresponds following regular language deliver send checkpoint words deliver event follow immediately send event course protocol may take forced checkpoints never less proposed protocol ffl another protocol obtained considering subset data structures example eliminate arrays ckpt 1n taken 1n obtain protocol characterized following condition c 00 8 protocol adapted context mobile computing 1 jm helary mostefaoui r netzer raynal procedure take checkpoint sent false enddo save current local state local checkpoint initialization take checkpoint sends message pk sent true sendm pk receives p j sent take checkpoint forced checkpoint endif figure 11 russells protocol may take forced checkpoints never less proposed protocol requires messages piggyback one integer namely mlc value lc j time p j sent ffl simplify protocol eliminating array sent 1n get following condition c 000 simplications result protocol shown figure 12 variant protocol described 4 quasisynchronous version proposed manivannan singhal 19 9 procedure take checkpoint save current local state copy lc initialization take checkpoint sends message pk receives lc p j take checkpoint forced checkpoint figure 12 variant manivannansinghals quasisynchronous protocol 9 original quasisynchronous protocol proposed 19 differs variant following way 1 process takes basic checkpoints according local logical periodicity 2 s2 lc update done part calling take checkpoint 3 within procedure take checkpoint variable lc increased checkpoint basic irisa communicationbased prevention useless checkpoints distributed computations 19 new protocols designed considering simplifications basic protocol discussion shows tradeoff number forced checkpoints taken size control information piggybacked application messages general smaller control information greater number forced checkpoints raises interesting question proposed protocol optimal one ie communicationinduced checkpointing protocol without priori knowledge basic checkpoints taken takes fewest number forced checkpoints ensure checkpoint useless optimality question remains open problem communicationinduced checkpointing protocols use heuristic approach prevent useless checkpoints protocols condition tested message reception safe sense basic checkpoints may remain useless protocol family described 26 using experimental results authors show protocol reduces rollback distance less one checkpoint interval per process number forced checkpoints 4 number basic checkpoints proposed protocol encompasses heuristicbased protocols easy show heuristics used 26 weakening condition used proposed protocol 7 conclusion useless checkpoint local checkpoint cannot part consistent global checkpoint paper addressed following important problem given set processes take basic local checkpoints independent unknown way designed communicationinduced checkpointing protocol directs processes take possible additional local forced checkpoints ensure local checkpoint useless protocol general efficient also shown take fewer forced checkpoints existing protocols solving problem improvements obtained using control information composed booleans n number processes also shown size control information reduced even eliminated price additional forced checkpoints protocol easily tuned desired control informationoverhead performance tradeoff design protocol motivated wide use communicationinduced checkpointing protocols applications require consistent global checkpoints detection stable unstable properties rollbackrecovery determination distributed breakpoints r checkpointing distributed application mobile computers independent checkpointing concurrent rollback recovery optimistic approach distributed dominoeffect free recovery algorithm determining global states distributed sys tems consistent detection global predicates distributed checkpoint detection messagepassing programs survey rollbackrecovery protocols messagepassing systems logical time distributed computing systems proc 10th ieee int detection strong unstable predicates distributed programs detection stable properties distributed ap plications efficient distributed detection conjunction local predicates asynchronous computations scheme coordinated execution independently designed recoverable distributed processes checkpointing rollbackrecovery distributed systems information processing letters low overhead recovery technique using quasisynchronous check pointing breakpoint halting distributed programs necessary sufficient conditions consistent global snapshots system structure software faulttolerance state restoration systems communicating processes lazy checkpoint coordination bounding rollback propagation consistent global checkpoints contain given set local checkpoints adaptive independent checkpointing reducing rollback propagation tr checkpointing rollbackrecovery distributed systems distributed snapshots detection stable properties distributed applications logical time distributed computing systems consistent detection global predicates necessary sufficient conditions consistent global snapshots distributed snapshots unified framework specification runtime detection dynamic properties distributed computations adaptive recovery mobile environments detection strong unstable predicates distributed programs distributed breakpoint detection messagepassing programs consistent global checkpoints contain given set local checkpoints theoretical analysis communicationinduced checkpointing protocols rollbackdependency trackability rollbackdependency trackability evaluations dominofree communicationinduced checkpointing protocols time clocks ordering events distributed system checkpointing distributed applications mobile computers communicationinduced determination consistent snapshots onthefly detection conjunctions local predicates distributed computations lowoverhead recovery technique using quasisynchronous checkpointing ctr jiang wu yi luo manivannan enhanced modelbased checkpointing protocol proceedings 25th conference proceedings 25th iasted international multiconference parallel distributed computing networks p332337 february 1315 2007 innsbruck austria gyungleen park hee youn yong new approach high performance computing systems various checkpointing schemes journal supercomputing v33 n1 p6578 july 2005 emmanuelle anceaume jeanmichel hlary michel raynal tracking immediate predecessors distributed computations proceedings fourteenth annual acm symposium parallel algorithms architectures august 1013 2002 winnipeg manitoba canada adnan agbaria hagit attiya roy friedman roman vitenberg quantifying rollback propagation distributed checkpointing journal parallel distributed computing v64 n3 p370384 march 2004 j hlary mostefaoui raynal interval consistency asynchronous distributed computations journal computer system sciences v64 n2 p329349 march 2002 b gupta k banerjee rollforward recovery scheme solving problem coasting forward distributed systems acm sigops operating systems review v35 n3 p5566 july 1 2001 jichiang tsai properties rdt communicationinduced checkpointing protocols ieee transactions parallel distributed systems v14 n8 p755764 august
ldl system prototype logic data language ldl system provides declarative logicbased language integrates relational database logic programming technologies support advanced data knowledgebased applications comprehensive overview system description ldl language compilation techniques employed translate ldl queries target query execution plans stored data presented architecture runtime environment system optimization techniques employed order improve performance assure safety compiled queries given experience gained far system application areas ldl approach appears particularly effective discussed b introduction objective logic data language ldl system develop technology new generation database systems support rapid development sophisticated applicationssuch expert systems advanced scientific engineering applications objective new since considerable interest database languages babu proposed vehicle facilitating development complex data intensive applications bridging gap database programming languagethis gap often described bell communication research morristown nj 07960 impedance mismatch coma yet approach favored previous researchers interfacing relational dbmss traditional languages rigel sch77 recently major efforts made integrate databases programming languages objectoriented paradigm kilo approaches tend abandon relational databases favor objectoriented oneoften supporting limited query capability navigational query style prerelational systems contradistinction approaches ldl research taken viewpoint full programming capabilities achieved extensions relational query languages technology advances provide efficient support integral part database management system also believed system represents important waystation toward future knowledge management systems combine efficient inference mechanisms logic efficient secure management large information banks database systems toward goal ldl project began 1984 produced new language new techniques compilation query optimization efficient portable prototype paper recounts experience various lessons learned effort 11 overview beginning ldl designed rulebased extension relational domain calculus based languages domain calculus variables stand values rather tuples tupleoriented calculus largely due influence prolog also qbe inline version felt expressive power former ease use latter provided desirable beacons endeavor straight extension sql yet domain calculus tuple calculus known equivalent ull overall techniques used implementing ldl easily applied suitable sql extensions basic research challenge faced provide system combined expressive power prolog functionality facilities data base management systems dbmss support trans actions recovery schemabased integrity efficient management secondary storage soon became clear approach based coupling prolog relational databases boc cegw kuyo li jacv would support level functionality performance ease use seeking realized fully integrated system required distinction query language application language arduous research challenges stood way realizing goal first issue came focus users responsibility execution control 70s early 80s database field witnessed dramatic evolution navigational systems relational ones navigational systems codasylcompliant dbmss programmer must explicitly navigate maze database records paying careful attention sequential order records visitedthe key efficiency relational dbmss instead user responsible formulation correct query using logicbased languages limited expressive power sql quel ull special system module called query optimizer compiles query efficient execution plan contrast prolog programmer must carefully order rules goals ensure efficient execution termination basic mismatch systems coupling prolog relational dbmss suffer also challenged ldls quest harmonious integration leaving two alternative paths open zan1 one consisted adding navigational database facilities prologlike language rejecting navigational procedural semantics prolog favor purely declarative one whereby order goals rules program becomes immaterial fall 1984 critical decision taken pursue second solution expectation would provide better usability suitability massive parallelism lead exciting research problems technology breakthroughs described following paragraphs early decision profound repercussions design language implementation prolog programmer must keenly aware sequential execution model sldresolution leftmost goal first rule selected veko llo termination performance program depend also semantics many nonhorn constructs primarily cuts updates also negation setof predicates based execution model nonhorn constructs introduced prolog obtain expressive power needed application development decided divorce execution order rules goals program first technical challenge facing ldl research provide clean design formal declarative semantics nonhorn constructs needed language reasons expressive power result language different prolog terms constructs programming style entails design choices regarding ldl implementation approach dictated need supporting database applications efficiently thus ldl rules compiled fact base described compile time schema updated freely run time need program interpretation recompilation first difference prolog systems facts rules treated way thus requiring interpretation facts changed furthermore concluded implementation technology prolog systems based backwardchaining based efficient implementations sldresolution unification llo war dependent main memory different approach needed obtain maximum performance secondarystorage resident data thus simpler execution model selected based upon operations matching computation least fixpoints iterations benefit approach matching operators sets facts implemented using simple extensions relational algebra zan2 zan3 used many relational databases second advantage since recursion replaced iteration use simpler static environment execution chosen simpler target language ldl designers faced challenge designing sophisticated compiler support full functionality source language approach chosen built two pillars ffl use global analysis infer bindings induced specific query rules goals ffl compilation methods rewrite recursive programs efficient safe implement fixpoint computations equivalent programs first ldl implementation completed 1987 based compiler using early version language called fad target language interpreter language dakv fad language based relational algebra supported massively parallel database machine designed mcc experiment produced fully functional system fad dropped target language following reasons fad interpreter available robust fast enough support serious experimentation furthermore fad implementation made available large expensive parallel systemhardly affordable portable vehicle release ldl led decision designing developing saladan efficient portable ldl system unix implementation assumed singletuple getnext interface compiled ldl program underlying fact manager singletuple framework created opportunity refinements optimization available framework relational algebra implementation included fact manager database residing virtual memory supported efficient access complex variable record structures available ldl completion salad prototype 1988 made possible start developing interesting applications ldl various extensions improvements added system result experience system improved expanded domain applications beyond traditional database applications owing open architecture compiling c salad finds applications rulebased system rapid prototyping applications c environment incipient understanding paradigm programming ldl also emerged experience along various ideas desirable improvements 12 structure paper section 2 summarizes key techniques concepts implemented system novel untried techniques developed ldl researchers parallel efforts meta thus section 21 gives brief survey novel features language 22 summarizes rule compilation techniques constant pushing efficient implementation recursion section 23 describes various execution schemes supported system 24 describes optimizer compile time selects safe efficient execution given query section 3 describes architecture implementation salad including discussion main modules section 31 various techniques peephole optimization section 32 fact manager section 33 section 4 recounts experience ldl salad using novel application areas enabling technology 21 language design language designed combine declarative style relational languages expressive power prolog concretely meant using horn clauses prolog rejecting remaining prolog constructs negation set updates cuts etc constructs added prolog obtain expressive power necessary writing general applications horn clauses welldefined declarative semantics additional constructs operational semantics based prologs execution model thus first challenge work design language proper constructs negation sets updates nondeterminism give formal semantics extends horn clauses semantics formally defined using notion minimal model alternative equivalent definition based notion least fixpoint also possible veko llo detailed discussion ldl design outside scope paper focuses implementation issues thus provide brief discussion main constructs illustrate richness language complexity compilation optimization issues posed implementation reader interested detailed discussion ldl formal semantics referred nats languages datalog support rules recursion full horn clause language also supports complex terms use function symbols thus instance record employee could following employeenamejoe doe admin educationhigh school 1967 along employee name find department works admin education admin simple term two complex terms entailing internal structure unrestricted complexity instance education field one may want keep detailed information school name level major people college degrees instance record following format employeenamejoe cool sales educationcollegeharvard bs math 1971 subargument refined detailed descrip tion thus enabling modeling objects arbitrarily complex structure including recursive structures lists trees ldl enhanced complex term capability providing set terms nested rela tions thus complete education record person follows employeenamejoe smart mts educationfhigh school 1967 collegeharvard bs math 1971 collegeharvard ms engr 1973 g set terms ldl first class citizens wellknown properties sets commutativity idempotence associativity bnst shtz addition nested relations ldl provides simple constructs nesting unnesting relations problem negated goals recursive rules represents one main research challenges defining declarative semantics ldl problem resolved introduction rather natural concept stratification apbw naq prz informally speaking result disallows circular definition predicate using negation similar constraints must also observed defining nesting sets bnst shna updates defined allow full use constructs rules support notion database transactions nakr difficult problem formalizing semantics solved use dynamic logic har semantics defined reduces first order logic absence updates finally notion functional dependencies used support nondeterminism construct called choice krn1 22 compilation problem ldl compiler performs several functions beginning parsing rules predicate connection graph pcg keot ending code generation phase details complex process discussed section 3 others beyond scope paper section describe rule rewriting phase conceptual kernel compiler objective specialize refine original program one specialized particular constraints resulting query rules hand large extent process viewed generalization wellknown principle pushing selection projection operations relational expressions compilation phase begins query form given ie query mode declarations specifying arguments given ground actual query time constant migration step nonrecursive predicates performed instance consider query form grandmaxy x denotes value supplied actual query time following set rules constant migration step actually insert x since value known run time treated constant compiler corresponding arguments variables rules yielding grandmaxy set rules simplified dropping first argument grandma parent grandmay thus original program specialized given query form furthermore since x migrated query form database predicates father mother corresponding selection operation pushed root relational algebra tree representing query leaf nodes selection applied database tuples ull selection pushing operation linchpin query processing strategy relational systems krza ull implemented simple rule transformation techniques treatment recursive predicates general complex program specialization approach described works simple cases recursive predicates instance following query ancmarc z ancx z ancx parenty z supported specializing anc rules ancmarc z ancmarc parenty z ancmarc marc personmarc dropping constant argument anc yield ancmarc personmarc single fixpoint iteration computes transitive closure efficiently original query condition applied directly datum parent relation derived anc relation ie selection pushed inside recursion furthermore refinement fixpoint known seminaive fixpoint used solve problem ban bar ull saz4 seminaive fixpoint iteration basically begin computing parents marc parents parents new ancestor found complex rewriting required however following query mapped single fixpoint ancx brian recursive rule must first rewritten rightlinear form follows ancx z parentxy ancx z specialization approach applied resulting linear transitive closure kind rules easily mapped single seminaive fixpoint frequency simple transitiveclosure type rules encountered ldl compiler performs sophisticated analysis recognize cases recursion supported efficiently single fixpoint computation however many situations constants cannot pushed recursion ahul therefore recursive goal bound arguments cannot computed efficiently safely single fixpoint computation problem detecting constants pushed recursion general undecidable bet2 thus complex rewriting techniques used handle general case take instance wellknown generation example two individuals generation parents everyone generation himherself sgxx query sgmarc x cannot supported rules obtained replacing x marc bottomup computation impossible since exit rule sgxx could qualify infinite number tuples similar problems occur computational procedures listappend taking advantage bound arguments essential safe efficient implementation considerable amount research devoted key problem reader referred bara overview techniques ldl compiler uses magic set method bmsu saz2 generalized counting method saz3 expressible rule rewriting scripts lead efficient implementations using fixpoint computations nutshell methods take recursive clique given query cannot supported well means fixpoint computation recast pair connected recursive cliques amenable efficient fixpoint implementation transformation illustrated example people generation marc sought one alternative way find people consists ffl deriving ancestors marc counting levels go marc zero level ancestor ffl ancestor marc say x found descendants x computed levels counted descendants level counter zero generation marc express previous computations follows j1 j1 denote respective successor predecessor integer j sgup0 marc sgdown0x thus initial recursive clique reformulated pair recursive cliques connected via index j recursive clique implemented efficiently safely using fixpoint computation indeed basically transitive closure operation equivalence preserving transformation introduced using intuitive semantics ancestry performed full generality purely syntactic basis indeed observe succession recursive calls generated goal sgmarc x x xp bound whereas yp thus recursive sgdown rule basically constructed dropping bound arguments retaining others new argument added perform countdown recursive rule sgup instead built retaining bound arguments exchanging recursive predicate head tail rule indeed want simulate topdown computation bottomup one adding countup indexes also observe original exit rule used glue together computations finally bound part query goal becomes new exit rule sgup unbound part becomes new query goal generalized formal expression rule rewriting techniques known generalized counting method given saz3 counting method efficient acyclic databases loop forever prolog cyclic databases eg samegeneration example parent relation cycles magic set method used solve cycle problem also complex recursive situations bmsu saz2 function symbols present previous examples compilation techniques described apply present entails manipulation trees lists complex structures another area considerable innovation ldl compiler support set terms set terms treated complex terms commutativity idempotence properties properties supported via compile time rule transformation techniques use sorting various optimization techniques eliminate blind runtime searches commutative idempotent matches shtz 23 modes execution even though ldls semantics defined bottomup fashion fashion eg via stratification implementor use execution faithful declarative semantics particular execution bottomup topdown well hybrid executions incorporate memoing mi68 choices enable optimizercompiler selective customizing appropriate mode given program first approximation easy view ldl execution bottom computation using relational algebra instance let p query following rule p1 p2 either database derived predicates query answered first computing relations representing p1 p2 computing join followed projection actuality ldl optimizer compiler select implement rule using four different execution modes follows ffl pipelined execution computes tuples p2 join tuples p1 pipelined fashion avoids computation tuple p2 join p1 ie superfluous work whereas tuple p2 joins many tuples p1 computed many times ffl lazy pipelined execution pipelined execution tuples generated p2 stored temporary relation say rp2 subsequent use therefore tuple p2 computed exactly even used many times ie amortized work well superfluous work pipelined execution pipelined executions compute p2tuples one time possible avoid residual computation case intelligent backtrackingthis called backtrackable advantage ffl lazy materialized execution proceeds lazy pipelined case except given zvalue tuples p2 join tuple p1 computed stored relation proceeding main advantage execution execution reentrant property important context recursion whereas two pipelined execution compute tuples p2 one time hand execution backtrackable advantage materialized execution computes tuples p2 stores relation say rp2 computation proceeds using tuples rp2 note amortized work reentrant advantages lacks backtrackable superfluous work advantage note discussion generalized ornode possibly empty set bound arguments conclusion pipelined execution useful joining column p1 whereas materialized execution best zvalues p2 joined p1 tuple note cases respective lazy evaluation incurs overhead due checking needed p1 tuple reentrant property especially useful predicate scope recursive query computed top therefore cases lazy materialized execution preferred lazy pipelined execution otherwise lazy pipelined execution preferred exploit backtrackable property even though limited discussion single nonrecursive rule generalized include arbitrary rules recursion presented detail cgk89b 24 optimization problem query optimizer delegated responsibility choosing optimal execution function similar optimizer relational database system optimizer uses knowledge storage structures information database statistics estimation cost etc predict cost various execution schemes chosen predefined search space select minimum cost execution compared relational queries ldl queries pose new set problems stem following observations first model data enhanced include complex objects eg hierarchies heterogeneous data allowed attribute secondly new operators needed operate complex data also handle new operations recursion negation etc thus complexity data well set operations emphasize need new database statistics new estimations cost finally use evaluable functions ie external procedures function symbols conjunction recursion provide ability state queries unsafe ie terminate unsafe executions limiting case poor executions optimizer guarantees choice safe execution formally define optimization problem follows given query q execution space e cost model defined e find execution e minimum cost discuss advances context formulation problem solution problem described along three main coordinates 1 execution space 2 search strategy 3 cost model 241 search space strategies search space optimal executions defined set allowable executions turn defined set execution graphs ii graph set allowable annotations associated nodes execution graph basically structure nested andor graphs representation similar predicate connection graph keot rule graph ull except give specific semantics internal nodes described andor graph corresponding nonrecursive program obvious graph andor nodes onetoone correspondence head rule predicate occurrence recursive predicate occurrence p subtrees whose roots correspond rules predicate also rules recursive clique containing p intuitively fixpoint rules node ie predicate occurrence p need computed compute p annotation provides information needed model execution intuitively parameter property modeled annotation given structure execution graph optimal choice information greedily chosen example given ordering ie structure joins conjunctive query choice access methods creation indices pushing selection examples choices greedily decided hand pushing selection recursive clique property greedily chosen instance annotations define four execution methods previously described used predicate occurrence ie node annotated execution method addition annotations describe indexes used whether duplicate elimination performed particular node much effort devoted devising efficient search strategies enabling optimizer use alternative strategies including exhaustive search stochastic search polynomial algorithms traditional dbms approach using exhaustive search use dynamic programming algorithm proposed seta well known even rendered useless join 15 relations krza propose exhaustive search optimizing ldl programs execution space approach feasible long number arguments number predicate occurrences body reasonably small ie 10 stochastic approaches provide effective means find nearoptimal solution intuitively nearoptimal executions found picking ran domly large subset executions execution space choosing minimum cost execution simulated annealing iowo variation thereof sg88 effective limiting subset must searched reasonable approximation found polynomial search algorithms obtained making simplifying assumptions nature cost functions krbz presented time algorithm computes optimal ordering conjunctive queries query acyclic cost function satisfies linearity property called adjacent sequence interchange asi property algorithm extended include cyclic queries cost models 242 cost estimates safety cost model assigns cost execution thereby ordering intuitively cost execution sum cost individual operations therefore cost function must capable computing cost operation based descriptors operands three major problems faced devising cost functions 1 computation descriptors 2 estimating cost external predicates 3 safety recursive queries presence nested views especially recursion complex objects estimating descriptor relation corresponding predicate difficult problem complicated fact logic based languages allow union nonhomogeneous sets objects net effect estimation descriptor predicate effect computing query algebraic fashion program executed abstract domain instead concrete domain instance age attribute may take values 16 concrete domain whereas abstract domain takes values integer 16 65 obviously computation domain difficult approximations computation devised efficient also effective ldl external procedures eg c programs treated interchangeable manner predicate intuitively external procedure viewed infinite relation satisfying constraints therefore concise descriptor infinite relation must declared schema cost functions operations infinite relations must devised abstraction approach taken ldl presented cgk89c approach integrates traditional optimization framework seamless fashion cost model must associate infinite cost execution computes infinite answer never completes unsafe queries detected optimizer avoid choosing example consider following definition integers zero given integer k intended program unsafe arguments free let us discuss safety predicate first argument bound second free note iteration recursive rule value j increasing upper bound value given value k thus concluded number iterations finite iteration produces finite tuples consequently rule safe general problem checking safety undecidable safety checking algorithm proposed krrs find wellfounded formula used sufficient condition guarantee safety algorithm enumerative algorithm exhausts exponential number cases ensure existence wellfounded formula recursive cycle enumerative algorithm guesses wellfounded formulae checks one one found satisfied 3 system architecture figure 1 shows conceptual architecture current ldl prototype 1 six basic components modules current prototype user interface fact manager schema manager query manager rule manager query form manager section 31 provides brief overview functionality different modules section 32 discusses details pertaining system architecture relevant compilation process 31 main modules user interface receives processes user commands ie invokes various procedures appropriate manager modules commands available user interface described cg89 fact manager responsible maintaining various data structures associated extensional database well providing runtime support ldl queries fact manager data structures collectively referred internal fact base schema manager receives schema definition file user interface records information internal form type index key constraints subsequently used fact manager verify database base relation specifications used rule 1 current implementation contains approximately 70000 lines code half prolog half c figure 1 conceptual architecture manager verify consistency query manager receives queries user interface determines compiled query form appropriate query invokes corresponding c program passing constants query arguments rule manager responsible processing intentional database ie rule base initial processing rules parsed various syntactic consistency checks performed parsed rule stored internal rule base sent global pcg generator responsible transforming rule set predicate connection graph pcg global pcg tabular data structure entries specifying rulegoal index predicates occurring rule base provides efficient means accessing rules subsequent query form pro cessing rules processed recursive clique analyzer invoked identify maximal recursive cliques detect cliques exit rules create necessary internal structures represent cliques rcboxes strongly connected components predicates pcg define recursive cliques additional data structures representing ldl modules externals cgk89a also produced rule manager query form manager embodies bulk ldl compilation technology receives query form user interface responsible producing compiled version query form figure2 shows organization query form manager relevant pcg generator generates relevant pcg rpcg andor graph containing rules relevant query form data structure generated actually tree instead graph since common subexpression elimination currently part compiler design rpcg extraction process constant migration ie process substituting deferred constants query form constants relevant rules variables wherever possible also performed note constants migrated recursive rules optimizer transforms rpcg associated recursive cliques necessary choose optimal execution performs safety analysis reorders goals nodes pcg appropriately nodes pcg annotated optimizer reflect among things adornment preselection postselection execution strategies employed transformed rpcg termed controlled pcg cpcg preenhancer responsible providing program adornment optimizer used asis compilation miscellaneous rewriting optimizations eg choice also handled preenhancer enhancer responsible rewriting recursive rules figure 2 query form manager architecture cursive cliques recast form guarantees efficient execution via fixpoint operators various recursive query processing strategies supported including stack based implementation generalized counting method magic set method seminaive fixpoint method output enhancer enhanced pcg epcg set rewriter uses rule transformation techniques produce revised equivalent pcg set objects mapped first order terms order avoid set unification runtime set properties commutativity idempotence supported via rule rewriting process context rule used constrain set alternatives must explored shtz finally code generator traverses pcg generating c code ultimately resulting complete c program compiled linked form final compiled query form code generator actually quite sophisticated performs various peephole optimizations eg intelligent backtracking existential query optimization provides default annotations case asis compilation supports various execution strategies fly code generated 32 compilation techniques addition rule transformations described section 22 ldl compiler applies number techniques improve efficiency runtime code 321 pruning execution graph much unification required support complex terms performed compiletime consider instance following rules compiletime rewriting rules result function fxy migrated rules p replace occurrences v subsequently first rule p deemed false thrown relevant rule set furthermore second rule p result unification x substitution throughout rule x u compiletime determined whether assignment value x assigned check value x value required based whether given variables bound note code generator would choose entry rule p appropriate place check order detect early failure whereas assignment would placed success rule order avoid unnecessary assignment rule fail thus runtime effort reduced eliminating rules performing compiletime unification simple matching assignments necessary runtime philosophy employed set unification set objects mapped first order terms compiletime ordinary matching required runtime 322 static variables one goals rewriting performed system rename variables scope variable global respect program purpose rewriting runtime efficiency making variable global space variables allocated statically opposed dynamically offsets frame pointer moreover assigning variable done efficiently global framework parameter passing becomes unnecessary hand nonrecursive rules invoked one predicate duplicated thus resulting larger object code 323 adornment query form compiler constructs adorned program using notion sideways information passing sip defined ull marking argument predicate either bound instantiated particular constant value runtime free current predicate occurrence instantiate runtime existential appear elsewhere rule except possibly head existential argument note rules cases duplicated renamed different adornments predicate occurrence referred stability transformation saz2 thus predicate adorned program associated unique binding pattern every occurrence predicate conforms binding pattern program segment generated predicate exploit boundexistential arguments generate efficient code approach generating code particular predicate respect given binding pattern important deviation approach taken prolog results improved performance 324 intelligent backtracking nestedloop join operation implied pipelined execution presents significant opportunities avoiding computation cannot generate new results literature know intelligent backtracking problem two types intelligent backtracking addressed com piler getnext getfirst consider ldl rules given let us assume rules compiled query rxy computing tuple r backtracking get next tuple b2 unnecessary since yield new tuples r compiler choose predicate p getnext backtrack point rule since variable bound 2 illustrate getfirst intelligent backtracking consider predicate b2 attempt get first tuple b2 fails unnecessary backtrack p since change bound argument b2 therefore tuples found b2 backtrack point b1 since variable x bound hence compiletime analysis intelligent backtracking implemented little overhead incurred runtime results elimination unnecessary runtime processing rule r also serves illustrate additional optimization utilized compiler respect existential arguments predicate b2 variable z dont care existential variable therefore assignment value z unnecessary might seem inconsequential optimization experience shown avoidance single assignment innermost loop great influence execution time compiletime analysis avoided unnecessary overhead runtime 325 implementation recursion updates choice discussed backtracking assuming pipelined execution ala prolog order efficiently compile advanced constructs ldl additional execution strategies ie materialized lazy materialized lazy pipelined snapshot stackbased executions must used different execution methods along respective advantages disadvantages described detail cgk89b ldl code generator capable selectively applying execution strategy chosen op interesting note query rx variable existential respect rule r getnext backtrack point rule would predicate b1 timizer predicate rule set moreover language features dictate appropriate execution strategy must applied set grouping recursion examples materialization essential correct execution full materialization however allow selection pushing therefore inefficient presence bound arguments therefore lazy materialized execution applied bindings utilized additionally recursion rewriting strategies employed compiletime recast recursion form guarantees efficient execution via fixpoint operators magic set rewriting method uses lazy materialized execution strategy applied possibility cyclic data user compile option states need detect cycles case compiler choose stackbased implementation counting method better performance approach pipelined lazypipelined execution strategy employed hence appropriate execution strategy chosen context compiletime ensure efficient runtime execution semantics ldl ascribe dynamic logic interpretation updatesnakr snapshot may required every update operation compiler however recognize instances snapshots necessary thus sequences updates collapsed implementation ldls nondeterministic choice construct requires materialization store functional dependencies following rules table x values materialized due choice construct chosen value particular x committed however success query rule r possible goal x resulting backtracking rule p obtaining new choice ie value may contrasted prolog cut bad choice result failure query 3 values committed materialized table used avoid unnecessary recomputation thus binding x obtained predicate b check performed determine value already committed remainder rule need executed compiletime techniques used reduce computation effort runtime 3 prolog cut also provide functional dependencies expressed 33 fact manager fact manager provides runtime environment ldl program supports ldl objects atoms sets lists well database objects tuples base derived relations current im plementation objects kept virtual memory ldl data types directly supported fact manager implements c abstract data types fact manager provides definitions well set routines operate objects types level abstraction maintained translator fact manager hand free take advantage data representation sake efficiency example complex objects stored onedimensional arrays first zeroth c component functor name function fm get functor argobjecti used translator select th component complex object fact manager implements inline ie preprocessor array lookup objecti similarly fact manager stores sets sorted arrays set operations union intersection implemented efficiently efficient support base derived relations provided tuple level calls fm get first fm get next key consideration design fact manager number operations performed innermost loop execution ie nested join example getting next tuple base relation postselecting bound arguments thus relations stored call fm get next reduced following linked list hence suitable inline implementation possible database kept inmemory thus never necessary access next tuple disk order speed equality comparisons used postselection example object database assigned unique representation compared using hardware integer compare instruction case numeric constants unique representation quite natural strings complex objects memory address actual object used unique representation whenever new complex object created fact manager guarantees address unique first checking whether object already exists efficient operation since objects kept memory unique representation also used fact manager perform database operations efficiently example index used hash function operates directly unique representation rather ldl object substantial savings since ldl objects arbitrarily complex moreover bucket selected searching find matching tuples involves equality comparison unique representation exploited well intuitively unique representation allows fact manager reduce cost subsequent index lookups partially hashing object created derived relations used translator support ldl language features recursion grouping recursion implemented using seminaive fixpoint operation rewriting magic sets etc taken place thus efficient execution recursion depends efficient implementation seminaive operation therefore fact manager supports operation directly partitioning recursive relations delta cumulative components returning tuples component seminaive scan desired since tuples inserted sequentially delta component implemented easily maintaining highwater mark similarly fact manager provides efficient support grouping converting relation set given pattern describing specific groupby operation desired experience 41 experience using language since ldl designed query language rulebased application language need evaluate functionality usability starting two domains independent comparison ldl database query language suggested simplest queries easier express ldl sql hardly represents endorsement ldl since inordinate difficulty expressing sophisticated queries sql wellknown yet experience suggests even complex queries readily expressed short ldl programs consistent experience ldl distinction complex queries simple applications arbitrary blurred found easy develop rapidly complex database applications including computer science genealogy nats programs parts explosion inventory control shop scheduling side coin involves comparing ldl rulebased systems reader may noticed coarse description ldl compiler maps functionality backward chaining system topdown mechanisms forward chaining bottomup indeed felt former conducive expressive powerful languages second conducive efficient implementations database context thus programming ldl similar programming prolog ops5 yet differences ldl prolog significant often baffling experienced prolog programmers prolog powerful ldl many respects builtin predicates including metapredicates moreover prolog variables instantiated dynamic fashioneg different goals instantiate variables complex term ldl restrictive since although goals reordered compile time execution goal assumed bind variables also fact prolog streams one answer time provides programmer opportunities fine control ldl hand ldl provides structured programming para digm cleaner syntax semantics optimizer excuses user thinking hard execution sequence benefits become apparent challenging areas nondeterminism recursion instance recursive procedure generate integers zero given integer k expressed follows ldl represents natural rendering peanos inductive definition integers augmented condition k second rule ensure termination one first rule ensure answer returned negative k second formulation also possible ldl follows less clear intuitive definition one handled prolog equal signs would also replaced also writing recursive predicate traverse graph possible cycles prolog programmer must make provisions termination eg carrying around bag answers produced far cycles easily handled ldl compiler specific option finally ability storing efficiently partial results retrieved later computations major plus ldl ease dealing externals modules therefore plausible argument made easeofuse ldl prolog hardly reason jubilation much work needed bring system level usability easeofuse entice nonprofessional programmers develop complex applications analogy many 4gl users simple applications currently working two major extensions directed toward enhancing ease use one debugger given nature system tantamount answer justification capability traditional debugger retraces execution program would little help unsophisticated user since compiler optimizer completely transform original program instead planned answer justification capability capable carrying dialogue user asking questions return answer dialogue directing user incorrect rule missing fact source problem also plan add visual interfaces data entry display program visualization procedural languages focus visualization changes program state declarative language ldl focus displaying static relationships defined rules briefly describe aspects affect performance current implementation ldl one important feature ldl elimination duplicate results processing recursionthat answers opposed proofs approach duplicates need eliminated certain cases guarantee termination traversing cyclic graph moreover elimination duplicates speed execution many cases example computation generation query discovered removing duplicates resulted major performance improvement since siblings database two ways prove relation father mother becomes even significant distant relations eg greatgrandparents explored timing comparison using database 500 tuples showed system computed generation roughly 4 seconds whereas quintus prolog needed 2 minutes resulting ratio 130 hand also recursive queries duplicates ever generated example appending two lists queries overhead duplicate elimination wasted hence ldl implementation compare favorably say prolog particular list append found ratio 61 101 favor prolog another factor contributing result uniqueness check performed creation new object ie temporary list check removed ratio reduced 21 42 ldl applications section report experience gained ldl system far recognized way utility new technology assessed application development process useful distinguish two classes applications ffl old applications database ones traditionally implemented procedural application program embedded query calls underlying database ffl new applications applications thus far never implemented implemented accomplished without use database technology described previous section experience traditional database applications positive concentrate two new promising application area data dredging harnessing software 421 data dredging class applications source data typically exclusively large set empirical observations measurements organized one base relations additional data may added time existing data seldom updated fact updated found erroneous typical sources measurement data empirical processes data recorded simulation experiments problem interpret data ie use verification certain hypotheses use formulation new concepts cases hypotheses concepts may conceptually far removed level recorded data crystalization definition entails interactive humansystem process follows 1 formulate hypothesis concept 2 translate 1 ldl ruleset query 3 execute query given data observe results 4 results verify deny 1 reformulate goto 2 otherwise exit obviously decision exit process entirely subjective decided programmer stage heshe may either decided concept properly defined data support concept abandoned tried different data process could carried using programming language use ldl advantage formulation done abstract level hence iteration time process significantly shortened compared traditional way iteration involves usual programmingcompiledebug cycle experimented data dredging two different application mains computer system performance evaluation scientific data analysis area microbiology first application nats involved formulation convoy concept distributed computing system tuitively convoy subset system entities processes tasks move together time one node network processors queues recorded data lowlevel consists ar rivaldeparture records individual entities certain nodes concept defined ldl using small set rules actual instances detected simulation data used second instance data dredging involves identification dna sequences lowlevel digitized autoradiographs record results experiments performed sequencing ecoli bacteria gene88 task extract definitions four dna bases acgt lowlevel noisy often imperfect data large number heuristics need applied case use ldl additional advantage simple add special definitions need used within narrow contexts general definitions thus relatively simple add smarts system experience use increases 422 harnessing software mentioned external c procedures used definition ldl programs ldl context regarded evaluable predicates normally expect use external code exception rather rule reserved special purposes eg graphical routines think situations lay extreme bulk software written standard procedural code small fraction rulebased encoded ldl situation ruleset forms harness around bulk code implemented rule portion forms knowledge base contains 1 definition cmodule types used system 2 rule set defines various ways modules combined exportimport relationships modules constraints combinations etc advantage organization knowledge base used decisions pertain reuse software subsets instances existing module types recombined subject rule restrictions support different taskspecifications added advantage individual moduletypes verified using existing verification methods global behavior controlled ruleset currently experimenting application type domain banking software 5 conclusion perhaps significant result ldl experience proving technical feasibility building logicbased application language extension relational databases technology realization objective required solving technical challenges many frontslanguage design formal definition compilation optimization system implementa tion five years since beginning project problems solved trough combined efforts group six eight people perhaps encouraging aspect whole experience wide spectrum interests backgroundsfrom theoretical one applied onewas represented group effort remained foucused generated remarkable degree synergism result system supports theoretical declarative semantics language completely efficiently experience suggests reasonably easy develop applications using ldl programming paradigm conclusion based small sample forwardlooking programmers leaning toward declarative languages logic programming whether language incorporating concepts recursion attract large throngs mainstream practitioners still seen also clear ldl much offer current sqlbased 4gls widely used rapid prototyping dm89 thus ldl shows real potential powerful rulebased language rapid development data intensive applications applications c environment main thrust current efforts improve usability system supporting interfaces visual programming answer justification acknowledgments authors would like recognize contribution following persons brijesh agarwal francois bancilhon catriel beeri charles kellogg paris kanellakis tony ohare kayliang ong arshad matin raghu ramakrish nan domenico sacca oded shmueli leona slepetis peter song emilia villarreal carolyn west r universality data retrieval lan guages towards theory declarative knowledge workshop database programming languages naive evaluation recursively defined relations differential approach query optimization recursive deductive databases amateurs introduction recursive query processing strategies sets negation logic data language ldl1 bound propagation selection logic pro grams bound propagation selection logic programs set constructors logic database language magic sets strange ways implement logic programs evaluation strategy educe interfacing relational databases prolog efficiently overview ldl system salad cookbook users guide using modules externals ldl abstract machine ldl towards open architecture ldl making smalltalk database sys tem fada database programming language rev 2 rapid prototyping conundrum modelling queries updates deductive databases logic databases deductive approach mapping genes genome projects big fast firstorder dynamic logic query optimization simulated annealing optimizing prolog front end relational query system optimizing rule data interface kms prolog relational databases 5th generation computer systems optimization nonrecursive queries nondeterministic choice data log towards real horn clause lan guage framework testing safety effective computability optimization logic based language knowledge data intensive applications prolog database system foundations logic programming semantics updates logic pro gramming logic negation database systems logical language data knowledge bases semantics stratified deductive databases logic programs optimizing existential datalog queries data abstraction views updates rigel implementation simple class logic queries databases implementation recursive queries data language based pure horn logic generalized counting method recursive logic queries differential fixpoint methods stratification logic programs high level language constructs data type relations access path selection relational database management system set grouping layering horn clause programs rewriting rules containing set terms logic data language ldl optimization large join queries ldl logicbased data language database knowledgebased systems semantics predicate logic programming language abstract prolog instruction set prolog database query language seasons representation deductive retrieval complex objects safety compilation nonrecursive horn clauses tr implementation simple class logic queries databases naive evaluation recursively defined relations magic sets strange ways implement logic programs extended abstract amateurs introduction recursive query processing strategies evaluation strategy educe prolog database query language seasons bounds propagation selection logic programs generalization differential approach recursive query evaluation query optimization simulated annealing foundations logic programming 2nd extended ed optimization large join queries framework testing safety effective computability extended datalog towards theory declarative knowledge declarative semantics deductive databases logic programs parallelism bubba objectoriented concepts databases applications logical language data knowledge bases towards open architecture ldl set constructors logic database language rewriting rules containing set terms logic data language ldl optimizing existential datalog queries database updates logic programming high level language constructs data type relation semantics predicate logic programming language logic databases deductive approach prolog database system universality data retrieval languages access path selection relational database management system data abstraction views updates rigel making smalltalk database system optimization logic based language knowledge data intensive applications optimizing ruledata interface kms optimization nonrecursive queries towards real horn clause language ctr arie segev j leon zhao framework join pattern indexing intelligent database systems ieee transactions knowledge data engineering v7 n6 p941947 december 1995 qing zhou ligong long sedatalog set extension datalog intelligent information processing ii springerverlag london 2004 raghu ramakrishnan divesh srivastava sudarshan praveen seshadri implementation coral deductive database system acm sigmod record v22 n2 p167176 june 1 1993 arie segev j leon zhao efficient maintenance rulederived data join pattern indexing proceedings second international conference information knowledge management p194205 november 0105 1993 washington dc united states raghu ramakrishnan divesh srivastava sudarshan coral control relations logic proceedings 18th international conference large data bases p238250 august 2327 1992 linda sirounian william grosky knowledge model unifying deductive nondeductive heterogeneous databases ieee transactions knowledge data engineering v7 n1 p82105 february 1995 jeffrey ullman carlo zaniolo deductive databases achievements future directions acm sigmod record v19 n4 p7582 dec 1990 jiawei han chainsplit evaluation deductive databases ieee transactions knowledge data engineering v7 n2 p261273 april 1995 alanoly j andrews nematollaah shiri laks v lakshmanan iyer n subramanian implementing schemalog arie segev j leon zhao data management large rule systems proceedings 17th international conference large data bases p297307 september 0306 1991 r g g cattell nextgeneration database systems communications acm v34 n10 p3033 oct 1991 jiawei han ling liu zhaohui xie logicbase deductive database system prototype proceedings third international conference information knowledge management p226233 november 29december 02 1994 gaithersburg maryland united states michael stonebraker jim frew kenn gardels jeff meredith sequoia 2000 storage benchmark acm sigmod record v22 n2 p211 june 1 1993 haixun wang carlo zaniolo nonmonotonic reasoning ldl logicbased artificial intelligence kluwer academic publishers norwell 2000 r ramesh weidong chen implementation tabled evaluation delaying prolog ieee transactions knowledge data engineering v9 n4 p559574 july 1997 konstantinos sagonas terrance swift david warren xsb efficient deductive database engine acm sigmod record v23 n2 p442453 june 1994 carlo zaniolo data knowledge database systems deductive databases handbook data mining knowledge discovery oxford university press inc new york ny 2002 stonebraker integration rule systems database systems ieee transactions knowledge data engineering v4 n5 p415423 october 1992 f nihan kesim marek sergot logic programming framework modeling temporal objects ieee transactions knowledge data engineering v8 n5 p724741 october 1996 hasan jamil belief reasoning mls deductive databases acm sigmod record v28 n2 p109120 june 1999 mengchi liu design implementation rol deductive objectoriented database system journal intelligent information systems v15 n2 p121146 septoct 2000 vincenzo ambriola giovanni cignoni distributed virtual machine support software process acm sigsoft software engineering notes v20 n1 p8589 jan 1995 antonella guzzo domenico saccaff1n2 semiinflationary datalog declarative database language procedural features ai communications v18 n2 p7992 april 2005 jess almendrosjimnez antonio becerratern database query languages functional logic programming new generation computing v24 n2 p129184 january 2006 raghu ramakrishnan divesh srivastava sudarshan praveen seshadri coral deductive system vldb journal international journal large data bases v3 n2 april 1994 alexandra poulovassilis carol small domaintheoretic approach integrating functional logic database languages proceedings 19th international conference large data bases p416428 august 2427 1993 nicola leone pasquale rullo antonella mecchia giuseppe rossi deductive environment dealing objects nonmonotonic reasoning ieee transactions knowledge data engineering v9 n4 p539558 july 1997 paolo ciancarini coordinating rulebased software processes esp acm transactions software engineering methodology tosem v2 n3 p203227 july 1993 alexandra poulovassilis carol small functional programming approach deductive databases proceedings 17th international conference large data bases p491500 september 0306 1991 yuhming shyy javier arroyo stanley yw su herman lam design implementation k highlevel knowledgebase programming language osamkbms vldb journal international journal large data bases v5 n3 p181195 august 1996 vincenzo ambriola reidar conradi alfonso fuggetta assessing processcentered software engineering environments acm transactions software engineering methodology tosem v6 n3 p283328 july 1997 barbara catania elisa bertino static analysis logical languages deferred update semantics ieee transactions knowledge data engineering v15 n2 p386404 february guy lohman bruce lindsay hamid pirahesh k bernhard schiefer extensions starburst objects types functions rules communications acm v34 n10 p94109 oct 1991 shalom tsur deductive databases action proceedings tenth acm sigactsigmodsigart symposium principles database systems p142153 may 2931 1991 denver colorado united states using deductive objectrelational databases cad softwarepractice experience v33 n2 p143172 1 february mengchi liu deductive database languages problems solutions acm computing surveys csur v31 n1 p2762 march 1999 mihalis yannakakis perspectives database theory acm sigact news v27 n3 p2549 sept 1996
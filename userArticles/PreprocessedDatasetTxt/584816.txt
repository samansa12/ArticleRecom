query processing streamed xml data addressing efficient processing continuous xml streams server broadcasts xml data multiple clients concurrently multicast data stream client fully responsible processing stream framework server may disseminate xml fragments multiple documents stream repeat replace fragments introduce new fragments delete invalid ones client uses lightweight database based proposed xml algebra cache stream data evaluate xml queries data synchronization clients servers achieved annotations punctuations transmitted along data streams presenting framework processing xml queries xquery form continuous xml streams framework based novel xml algebra new algebraic optimization framework based query decorrelation essential nonblocking stream processing b introduction 11 motivation xml 31 emerged leading textual language representing exchanging data web even though html still dominant format publishing documents web xml become prevalent exchange format businesstobusiness transactions enterprise intranets expected near future internet populated vast number webaccessible xml les one reasons popularity supporting simple nested structures tagged elements xml format able represent structure content complex data eectively take advantage structure xml documents new query languages invented go beyond simple keywordbased boolean formulas supported current web search engines several recent proposals xml query languages 17 none adopted standard yet nevertheless recent working draft xml query language released worldwide web consortium w3c called xquery 7 may become standard near future basic features xquery illustrated following query taken w3c web page 31 f b documenthttpwwwbncombibbook return book yearf byear g f btitle g lists books published addisonwesley 1991 including year title documenturl expression returns entry point xml data contained xml document located specied url address xquery uses path expressions navigate xml data example tag selection bpublisher returns children b tag name publisher wildcard selection btitle returns descendants b possibly including b tag name title uenced modern database query languages oql language odmg standard 6 xquery allows complex queries composed simpler ones supports many advanced features navigating restructuring xml data xml data construction aggregations universal existential quantication sorting many commercial products recently take advantage already established database management technology storing retrieving xml data although none fully supports xquery yet fact nearly relational database vendors provide functionality storing handling xml data systems systems support automatic insertion canonically structured xml data tables rather utilizing xml schemas generating applicationspecic database schemas also provide methods exporting database data xml form well querying transforming forms html eective processing xml data requires storage access functionality provided modern database systems query processing optimization concurrency control integrity recovery distribution security unlike conventional databases xml data may stored various forms native form text documents semistructured database conforming standard schema applicationspecic database exports data xml form may disseminated servers clients various ways broadcasting data multiple clients xml streams making available upon request based previous experience traditional databases queries optimized eectively rst translated suitable internal form clear semantics algebra calculus xml data stored applicationspecic database schema xml queries data translated native query language supported database system turn compiled native algebraic form major research issue related approach addressed previous work 14 automatic generation database schema well automatic translation xml queries database queries generated schema hand xml data stored semistructured data processed xml streams new algebra needed captures heterogeneity irregularities intrinsic xml data 4 fact already algebras semistructured data including algebra based structural recursion 4 yatl 10 8 sal 3 xalgebra 16 xscan 22 none algebras used emerging xml query languages yet little work algebraic query optimization based algebras paper focused ecient processing continuous xml streams current web servers adopt pullbased processing technology client submits query server server evaluates query local database sends result back client alternative approach pushbased processing server broadcasts parts entire local database multiple clients multicast data stream usually acknowledge handshaking client fully responsible processing stream 1 pushing data multiple clients highly desirable large number similar queries submitted server query results large 2 requesting region geographical database furthermore distributing processing clients reduce server workload increasing availability hand stream client acknowledge correct receipt transmitted data means case noise burst cannot request server resubmit data packet correct errors stream data may innite transmitted continuous stream measurement sensor data transmitted realtime monitoring system continuously would like support combination processing technologies pull push framework unit transmission xml stream xml fragment corresponds one xml element transmitted document framework server may prune fragments document xml tree called llers replace holes hole simply reference ller unique id fillers turn may pruned llers replaced holes result sequence small fragments assembled client side lling holes llers server may choose disseminate xml fragments multiple documents stream repeat fragments critical high demand replace change sending delta changes introduce new fragments delete invalid ones client responsible caching reconstructing parts original xml data limited memory necessary evaluating xml queries data like relational database data stream data processed relational operators unlike stored database data though may provide fast access paths stream content accessed sequentially nevertheless would like utilize database technology used pulling data server pushing data clients processing data client side lightweight database management system example server may broadcast stock prices client may evaluate continuous query wireless mobile device checks warns activating trigger rapid changes selected stock prices within time period since stock prices may change time client must able cache main memory secondary storage old prices another example processing mpeg7 24 streams extract query video context information mpeg7 standard developed mpeg moving picture experts group combines multimedia data various forms including content description representation perceivable information since xml fragments processed client side become available query processing system resembles mainmemory database rather traditional secondarystoragebased database although mainmemory database dierent backend secondarystorage database mainmemory queries mapped similar algebraic forms optimized similar way traditional queries one dicult problem processing algebraic operators continuous streams presence blocking operators sorting groupby require processing entire stream generating rst result processing operators eectively requires server passes hints called punctuations 29 along data indicate properties data one example punctuation indication prices stocks starting already transmitted valuable information client performs groupby stock names complete ush memory groups correspond stock names extending query processor make eective use punctuations yet investigated others 12 approach paper addresses ecient processing continuous xml streams server broadcasts xml data multiple clients concurrently framework server may disseminate xml fragments multiple documents stream repeat replace fragments introduce new fragments delete invalid ones approach client uses lightweight inmemory database cache stream data physical algorithms based xml algebra evaluate xml queries data synchronization clients servers achieved annotations punctuations transmitted along data streams necessary information needed client structure transmitted xml document called tag structure server periodically disseminates tag structure special annotation xml form example following tag structure streamstructure tag namebib id1 tag namevendor id2 attributesid tag namename id3 tag nameemail id4 tag namebook id5 attributesisbn relatedto tag nametitle id6 tag namepublisher id7 tag nameyear id8 tag nameprice id9 tag nameauthor id10 tag namefirstname id11 tag namelastname id12 streamstructure corresponds following partial dtd element bib vendor element vendor name email book query processing performed client side help lightweight query optimizer major component query optimizer eective algebra would serve intermediate form translation abstract queries concrete evaluation algorithms presenting new xml algebra query optimization framework based query normalization query unnesting also known query decorrelation many proposals query optimization focused unnesting nested queries 23 18 26 11 12 9 28 nested queries appear often xml queries relational queries xml query languages including xquery allow complex expressions point query current commercial database systems typically evaluate nested queries nestedloop fashion unacceptable online stream processing leave many opportunities optimization proposed unnesting techniques require use outerjoins prevent loss data grouping accumulate data remove null values introduced outerjoins considered isolation query unnesting result performance improvement instead makes possible opti mizations otherwise would possible specically without unnesting choice evaluating nested queries naive nestedloop method step outer query steps inner query need executed query unnesting promotes operators inner query operators outer query operator mixing allows optimization techniques take place rearrangement operators minimize cost free movement selection predicates inner outer operators enables operators selective xml query unnesting method uenced query unnesting method oodb queries presented earlier work 15 data stream nite size smaller client buer size obvious way answer xqueries xml stream reconstruct entire xml document memory evaluate query cached document realistic assumption even nite streams client computers often mobile typically limited resources computing power xqueries translated xml algebra algebraic operator assigned streambased evaluation algorithm require consume entire stream produces output even data stream nite operations sorting groupby aggregation may take long complete however clients may simply satised partial results average values small sample data rather entire database online aggregation 20 21 addressed problem displaying progress point time along accuracy result allowing client interrupt aggregation process approach based annotations pred pred vpath pred pred grouppred f figure 1 semantics xml algebra data content called punctuations 29 punctuation hint sent server indicate property data already transmitted hint takes form predicate compares path expression uses tsids rather tag names constant value follows streampunctuation propertypath cmp constant example following punctuation streampunctuation property1235isbn 1000 according tag structure path 1235isbn corresponds xpath bibvendor3bookisbn punctuation indicates server already transmitted books published 3rd vendor whose isbn less equal 1000 presenting set streambased evaluation algorithms xml algebraic operators make use punctuations reduce amount resources needed clients process streamed data example suppose client joins stream data books stream book prices provided amazoncom using isbn crossreference one way evaluate join using inmemory hash join 30 build probe tables reside memory isbn punctuations received streams hash buckets hash tables ushed memory since according punctuations received used framework punctuations stored central repository client side consulted demand local buer space evaluation operator ows rest paper organized follows section 2 presents new xml algebra new algebraic optimization framework based query decorrelation also presents translation rules compiling xquery algebraic form xml algebra used generically processing xml data section 3 adapts algebra handle xml streams presents various inmemory nonblocking evaluation algorithms process operators algebra query optimization 21 xml algebra proposing new algebra new algebraic optimization framework wellsuited xml structures stream processing section presenting xml algebra without taking account fragmentation reconstruction xml data issues addressed detail section 3 algebraic bulk operators along semantics given figure 1 inputs output operator streams captured lists records concatenated list append nonbulk operators boolean comparisons listed semantics given terms record concatenation list comprehensions f e unlike set former notation preserve order multiplicity elements form f g reduces elements resulted list comprehension using associative binary operator monoid etc nonbulk monoid fa 1 bulk monoid fa 1 g sorting captured special bulk monoid sortf merges two sorted sequences f one sorted sequence f example returns f3 2 1g environment current stream record used nested queries nested queries mapped algebraic form algebraic operators predicates headers etc contain algebraic operators specically record stream passing outer operator nested query inner query evaluated concatenating record inner query stream unnest path operator predicates may contain path expression vpath v stream record attribute path simple xpath form patha patha pathn pathtext pathdata n integer algebraic form path forms contain wildcard selections patha predicate selections pathe unnest operation mechanism traversing xml tree structure function p dened paths follows extraction operator gets xml data source returns singleton stream whose unique element contains entire xml tree selection projection merging join similar relational algebra counterparts unnest nest based nested relational algebra reduce operator used producing nal result querysubquery aggregations existentialuniversal quantications example xml universal quanti cation every v xa satises vadata5 captured operator vadata5 like xquery predicates predicates used xml algebraic operators implicit existential semantics related potentially multiple values returned path expres sions example predicate vadata5 used previous example implicit semantics since path vadata may return one value finally even though selections projections expressed terms convenience treated separate operations 22 translation xquery xml algebra xqueries translated xml algebra paths wildcard selections ea instantiated concrete paths may accomplished absence type information help tag structure xpath expression xquery may contain wildcard selections expanded concatenation concrete xpath expressions example xpath expression ax expanded abcx adx two concrete paths pair valid paths tag structure match wildcard selection translation scheme xquery xml algebra consists two phases first xqueries translated list comprehensions similar figure 1 algebraic forms derived list comprehensions using denitions figure 1 according xquery semantics 7 results nearly xquery terms mapped sequences values means xquery term returns value sequence value lifted singleton sequence contains value notable exception boolean value mapped boolean value following rules e maps xquery terms algebraic forms first translate xpath terms simple paths without path predicates adopting semantics xpath implicit reference current node path predicate path ab path predicate xyab1 captured variable dot bound current element xyab1 equivalent xydotab1 assumption path predicates removed straightforward way ei complete translation scheme xquery terms mapped xml algebra function element takes tag name sequence xml elements constructs new xml element e 2 1 replaces free occurrences variable v term e 2 term e 1 note boolean predicates equality last rule mapped one boolean value implied existential semantics xquery predicates 7 list comprehensions translated algebraic forms generator domains comprehensions normalized simple path expressions possible task straightforward addressed earlier work 5 15 following examples normalization rules sequence terms separated commas ve2 terms sequence replacing occurrences v e 2 rst rule applies domain comprehension generator another comprehension reduced case caught second rule second rule applies domain comprehension generator singleton sequence last rule distributes tag selection header comprehension fourth rule may look counterintuitive consequence ambiguous semantics xquery nonsequence values lifted singleton sequences according mapping rules normalization simple path vabc mapped vabc example following xquery b documenthttpwwwbncombibbook return f btitle g translated following comprehension using mapping rules normalized following comprehension opr opr head head z q g pred pred q z figure 2 algebraic query unnesting second phase translation scheme maps normalized term e consists list comprehensions exclusively algebraic form dened following rules e e doc shorthand document addition since predicates used xml algebraic operators existential semantics similar semantics xquery predicates move existentially quantied variables ranged paths predicate iself making implicit existential quantication achieved following rules example f bpublisher g reduced bpublisher addisonwesley implicit existential semantics rules normalized list comprehension derived example query mapped h 23 algebraic optimization many algebraic transformation rules used optimizing xml algebra already used successfully relational algebra evaluating selections early possible concentrating query unnesting query decorrelation important processing streamed data without query unnesting nested queries must evaluated nestedloop fashion requires multiple passes stream inner query unacceptable performance requirements stream processing unnesting algorithm shown figure 2a box q corresponds nested query converts reduction top q nest blocking joinsunnests lay inputoutput path box q outerjoinsouterunnests box q 0 shown example figure 2b time embeds resulting box q 0 point immediately used simple explanation algorithm correct nested query q figure 2a consumes input stream embedding operation opr computes value used component f embedding query want splice box onto stream embedding query need guarantee two things first q block input stream removing tuples stream condition achieved converting blocking joins outerjoins blocking unnests outerunnests box q 0 second need extend stream new value v q used f manipulation done converting reduction top q nest since main dierence nest reduce reduce returns value reduction stream values nest embeds value input stream time nest operator convert null values zeros stream comes output spliced box q 0 exactly splice 24 complete example subsection apply translation optimization scheme following xquery taken f u documentusersxmluser tuple return f uname g f b documentbidsxmlbid documentitemsxmlitem return f idescriptiontext g lists users alphabetic order name user includes descriptions items bid user alphabetic order recall sorting captured algebra using monoid sortf sorts sequence f algebraic form query header h 1 xml construction contains nested algebraic query unnesting resulting decorrelated query da x leftouter join outer unnest respectively processing continuous xml streams framework streamed xml data disseminated clients form streamxxx hidxml fragment streamxxx xxx tag name ller repeat replace remove hole id hid species location fragment reconstructed xml tree framework uses xml algebra processing xml streams main modication needed algebra related evaluation simple path expressions used predicates unnest operator since evaluated document llers specically function p given section 2 must extended handle holes sstreamhole returned bottom value indicates path completely evaluated current fragment due hole fragment returned point path evaluation dened p xml fragment suspended client one central repository suspended xml fragments regardless number input streams called fragment repository indexed combination stream number hid hid stored ller addition operator local repository maps hole ids ller ids fragment repository suppose example ller hidm streamed xml algebraic operator operator cannot complete evaluation three paths due holes hids h 1 h 2 h 3 local repository operator extended three mappings later ller one holes arrives operator say ller h 2 hole h 2 inside ller hidm fragment repository replaced newly arrived ller h 2 mapping removed local repository operator resulting ller hid fragment repository evaluated operator may result hole mappings local repository operator finally blocking holes path evaluation operator paths completely evaluated ller processed operator removed fragment repository necessary holes blocking evaluation operator paths lled fragment processed released example paths selection predicate blocked holes one holes lled corresponding predicate false need wait second hole lled since fragment removed stream server sends repeat replace remove fragments client modies fragment repository may stream fragments algebraic operators repeat fragment hid already fragment repository ignored otherwise streamed query ller fragment since client may connected middle stream broadcast replace fragment hid already fragment repository stored fragment replaced otherwise streamed query ller fragment finally remove fragment fragment referenced hid removed fragment repository exists evaluation algorithms xml algebra based inmemory hashing blocking operators join nest require buers caching stream records evaluation algorithms operators hashbased possible possible nonequijoins example join x xabycde two hash tables memory number buckets one stream x hash function based path xab one stream based path ycde streams completed join evaluated joining associated buckets pairs nest operator evaluated using hashbased algorithm also hash key combination groupby paths mentioned cope continuous streams streams larger available memory make use punctuations sent server along data framework punctuations received client site stored central repository called punctuation repository indexed stream number blocking operation join nesting associated one unary two binary pairs stream numbershash keys hash key path identied tag structure id blocking operators evaluated continuously reading fragments input streams without producing output lling hash tables soon one hash tables full consult punctuation repository nd punctuations match stream number tag structure id perform blocking operation hashed fragments match retrieved punctuations may result production output last phase ushing hash tables performed pipeline fashion one output fragment time requested parent operation punctuation repository cleared punctuation stream entire stream repeated ie root fragment repeated sorting special case handled separately implemented inmemory sorting quicksort sort operator remembers largest key value data already ushed memory beginning course largest key null like blocking operators buer used sorting full punctuation repository consulted nd punctuations related sorting key punctuation indicates seen data largest key value null key value buered data smaller equal latter key value ushed value becomes new largest key 4 future plans described xml algebra assumed xpath paths used operator predicates unnest operators unnesting paths fully mapped concrete paths contain wildcard selections possible xml tag structure provided done server disseminates xml data clients stream processing framework absence information wildcard selections form ea evaluated transitive closure operator walks xml tree e nd branches tag transitive closures hard optimize general techniques proposed literature magic sets 25 address problem planning incorporate structural recursion tree types xml algebra starting point previous work structural recursion treelike data structures 13 satises eective optimization rules reminiscent loop fusion deforestation elimination intermediate data structures used functional programming languages operators optimization techniques also used optimizing queries xedpoint types supported directly dtds xml schemas partsubpart hierarchy xquery provide special language construct traversing structures simulate operations unrestricted recursion planning introduce language extensions xquery handle structural recursion directly mapping extensions structural recursion algebraic operators addition planning dene update language xquery give formal semantics optimize related query processing xml streams presented evaluation algorithms based inmemory hashing planning investigate evaluation algorithms xml algebraic operators alternative approach hashing sorting example alternative way implementing groupby operation sort input groupby attributes aggregate consecutive tuples sorted result belong group 19 sorting blocking operation requires availability entire stream produces output turned nonblocking operator punctuations related sorting attributes transmitted server supporting multiple evaluation algorithms algebraic operator poses new challenges good evaluation plan selected client side relational database systems use costbased dynamic programming plan selection algorithm rely heavily data statistics cost estimation 27 server sends sorted data stream may indicate sortbased algorithm requires order may faster may require less memory hashbased one valuable information client query optimizer transmitted another stream annotation server maybe frequently document tag structure another useful information needed client must transmitted server statistics streamed data still open problem form statistics take used client one possibility annotate node document tag structure total number xml elements document correspond node hence planning investigate costbased plan selection streamed data 5 conclusion presented framework processing streamed xml data based xml algebra algebraic optimization framework eectiveness framework depends available resources client site especially buer size ability client optimize evaluate queries eectively also willingness ability servers broadcast useful punctuations data stream help clients utilize resources better server must aware possible anticipated client queries disseminate punctuations reduce maximum average sizes client resources addition server disseminate fragmentationrepetition policy used splitting xml data well statistics data sent punctuations streaming actual data information may help clients allocate limited memory various query operations wisely planning address issues future work acknowledgments work supported part national science foundation grant iis9811525 texas higher education advanced research program grant 00365600431999 r broadcast disks data management asymmetric communications environments continuous queries data streams sal algebra semistructured data xml query language optimization techniques unstructured data comprehension syntax object data standard odmg 30 query language xml optimizing queries universal quanti mediators need data conversion nested queries object bases query engines webaccessible xml data optimizing object queries using e algebra xml query database techniques worldwide web survey optimization nested sql queries revisited query evaluation techniques large databases interactive data analysis control project online aggregation optimizing sqllike nested query overview mpeg7 standard version 50 magic relevant improved unnesting algorithms join aggregate sql queries access path selection relational database management system optimization nested queries complex object model punctuating continuous data streams data ow query execution parallel mainmemory environment world wide web consortium w3c tr comprehension syntax broadcast disks query language optimization techniques unstructured data online aggregation mediators need data conversion database techniques worldwide web wrapping query languages efficient xml integration optimizing object queries using effective calculus dataflow query execution parallel mainmemory environment continuous queries data streams query engines webaccessible xml data algebra xml query ctr christoph koch stefanie scherzinger nicole schweikardt bernhard stegmaier fluxquery optimizing xquery processor streaming xml data proceedings thirtieth international conference large data bases p13091312 august 31september 03 2004 toronto canada kevin beyer chambrlin latha colby fatma zcan hamid pirahesh yu xu extending xquery analytics proceedings 2005 acm sigmod international conference management data june 1416 2005 baltimore maryland christoph koch stefanie scherzinger nicole schweikardt bernhard stegmaier schemabased scheduling event processors buffer minimization queries structured data streams proceedings thirtieth international conference large data bases p228239 august 31september 03 2004 toronto canada peter tucker david maier tim sheard leonidas fegaras exploiting punctuation semantics continuous data streams ieee transactions knowledge data engineering v15 n3 p555568 march song wang elke rundensteiner murali mani optimization nested xquery expressions orderby clauses data knowledge engineering v60 n2 p303325 february 2007 sujoe bose leonidas fegaras data stream management historical xml data proceedings 2004 acm sigmod international conference management data june 1318 2004 paris france haifeng jiang howard ho lucian popa wookshin han mappingdriven xml transformation proceedings 16th international conference world wide web may 0812 2007 banff alberta canada sharma chakravarthy alp aslandogan ramez elmasri leonidas fegaras junghwan oh database research ut arlington acm sigmod record v32 n1 march christoph koch stefanie scherzinger attribute grammars scalable query processing xml streams vldb journal international journal large data bases v16 n3 p317342 july 2007 norman may sven helmer guido moerkotte strategies query unnesting xml databases acm transactions database systems tods v31 n3 p9681013 september 2006
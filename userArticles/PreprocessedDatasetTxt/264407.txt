strengths weaknesses quantum computing recently great deal attention focused quantum computation following sequence results bernstein vazirani proc 25th annual acm symposium theory comput 1993 pp 1120 siam j comput 26 1997 pp 12771339 simon proc 35th annual ieee symposium foundations comput sci 1994 pp 116123 siam j comput 26 1997 pp 13401349 shor proc 35th annual ieee symposium foundations comput sci 1994 pp 124134 suggesting quantum computers powerful classical probabilistic computers following shors result factoring extraction discrete logarithms solvable quantum polynomial time natural ask whether np efficiently solved quantum polynomial time paper address question proving relative oracle chosen uniformly random probability 1 class np cannot solved quantum turing machine qtm time o2n2 also show relative permutation oracle chosen uniformly random probability 1 class np cap conp cannot solved qtm time o2n3 former bound tight since recent work grover proc 28th annual acm symposium theory comput 1996 shows accept class np relative oracle quantum computer time o2n2 b introduction quantum computational complexity exciting new area touches upon foundations theoretical computer science quantum physics early eighties feynman 12 pointed straightforward simulations quantum mechanics classical computer appear require simulation overhead exponential size system simulated time asked whether inherent whether possible design universal quantum computer deutsch 9 defined general model quantum computation quantum turing machine bernstein vazirani 4 proved efficient universal quantum turing machine yao 17 extended proving quantum circuits introduced deutsch 10 polynomially equivalent quantum turing machines computational power quantum turing machines qtms explored several researchers early work deutsch jozsa 11 showed exploit inherently quantum mechanical features qtms results conjunction subsequent results berthiaume brassard 5 6 established existence oracles computational problems qtms solve polynomial time cer tainty whereas require classical probabilistic turing machine produce correct answer certainty must take exponential time inputs hand computational problems bpp 1 relative oracle therefore efficiently solvable classical sense quantum analogue class bpp 1 bpp class decision problems languages solved polynomial time probabilistic turing machines error probability bounded 13 inputs using standard boosting techniques error probability made exponentially small k iterating algorithm k times returning majority answer class bqp 2 5 bernstein vazirani 4 proved bpp bqp pspace thus establishing possible conclusively prove bqp 6 bpp without resolving major open problem p pspace also gave first evidence bqp 6 bpp polynomialtime quantum turing machines powerful polynomialtime probabilistic turing machines proving existence oracle relative problems bqp cannot solved small error probability probabilistic machines restricted running n olog n steps since bpp regarded class efficiently computable languages computational problems provided evidence quantum computers inherently powerful classical computers modelindependent way simon 16 strengthened evidence proving existence oracle relative bqp cannot even simulated probabilistic machines allowed run 2 n2 steps addition simons paper also introduced important new technique one ingredients remarkable result proved subsequently shor 15 shor gave polynomialtime quantum algorithms factoring discrete logarithm problems two problems wellstudied presumed intractability forms basis much modern cryptography view results natural ask whether np bqp ie quantum computers solve npcomplete problems polynomial time 3 paper address question proving relative oracle chosen uniformly random 3 probability 1 class np cannot solved quantum 2 bqp class decision problems languages solved polynomial time quantum turing machines error probability bounded 13 inputssee 4 formal definition prove section 4 paper case bpp error probability bqp machines made exponentially small 3 actually even clear whether bqp bpp np ie unclear whether nondeterminism together randomness sufficient simulate quantum turing machines fact bernstein vazi ranis 4 result stronger stated actually proved relative oracle recursive fourier sampling problem solved bqp cannot even solved arthurmerlin games 1 time bound n olog n thus giving evidence nondeterminism top probabilism help conjecture recursive fourier sampling cannot even solved unrelativized polynomialtime hierarchy turing machine time o2 n2 also show relative permutation oracle chosen uniformly random probability 1 class np conp cannot solved quantum turing machine time o2 n3 former bound tight since recent work grover 13 shows accept class np relative oracle quantum computer time o2 n2 see 7 detailed analysis grovers algorithm relevance oracle results emphasize rule possibility np bqp results establish blackbox approach solving npcomplete problems using uniquely quantummechanical features qtms real possibility clear grovers 13 result gives blackbox approach solving npcomplete problems squareroot much time required classically one way think oracle special subroutine call whose invocation costs unit time context qtms subroutine calls pose special problem classical counterpart problem subroutine must leave around bits beyond computed answer otherwise computational paths different residual information interfere easily achieved deterministic subroutines since classical deterministic computation carried reversibly input answer remain however leaves open general question whether bqp machine used subroutine final result paper show bqp machine modified tidy bqp machine whose final superposition consists almost entirely tape configuration containing input single bit answer since tidy bqp machines safely used subroutines allows us show bqp bqp result also justifies definition oracle quantum machines give oracle quantum turing machines section next shall assume without loss generality turing machine alphabet track tape f0 1 g denotes blank symbol initially tapes blank except input tape contains actual input surrounded blanks shall use sigma denote f0 1g classical setting oracle may described informally device evaluating boolean function sigma sigma arbitrary arguments unit cost per evaluation allows formulate questions efficiently computable turing machine functions languages could efficiently computed turing machines quantum setting equivalent question asked provided define oracle quantum turing machines appropriatelywhich sectionand turing machines composedwhich show section 4 paper oracle qtm special query tape track whose cells blank except single block nonblank cells wellformed oracle qtm turing machine rules may allow region grow shrink prevent fragmenting noncontiguous blocks 4 oracle qtms two distinguished internal states prequery state q q postquery state q query executed whenever machine enters prequery state query string empty noop occurs machine passes directly post query state change query string nonempty written form denotes concatenation case result call oracle internal control passes postquery state contents 4 restriction made without loss generality verified syntactically allowing machines make sure break rule writing query tape query tape changes jx ffi bi jx ffi b phi axi phi denotes exclusiveor addition modulo 2 except query tape internal control parts oracle qtm change query target bit jbi supplied initial state j0i final state jaxi classical oracle machine conversely target bit already state jaxi calling oracle reset j0i ability uncompute often prove essential allow proper interference among computation paths take place using fact also easy see definition oracle turing machines yields unitary evolutions restrict machines wellformed respects particular evolving unitarily enter prequery state leave postquery state power quantum computers comes ability follow coherent superposition computation paths similarly oracle quantum machines derive great power ability perform superpositions queries example oracle might called query tape state j ffi x ff x jx ffi 0i ff x complex coef ficients corresponding arbitrary superposition queries constant j0i target bit case query query string left entangled state x ff x jx ffi axi also useful able put target bit b superposition example conditional phase inversion used grovers algorithm achieved performing queries target bit b nonclassical superposition 2 readily verified oracle call query tape state x ffi fi leaves entire machine state including query tape unchanged leaves entire state unchanged introducing phase factor gamma1 often convenient think boolean oracle defining lengthpreserving function sigma easily accomplished interpreting oracle answer pair x th bit function value pair x encoded binary string using standard pairing function permutation oracle oracle interpreted lengthpreserving function acts n 0 permutation sigma n henceforth confusion may arise shall use ax denote lengthpreserving function associated oracle rather boolean function gives rise let us define bqtimet n sets languages accepted probability least 23 oracle qtm whose running time bounded n bound running time applies individual input average notice whether bqpmachine might depend upon oracle athus might bqpmachine b might one note definition quantum oracle arbitrary boolean function suffice purposes present paper ability quantum computers perform general unitary transformations suggests broader definition may useful contexts example oracles perform general nonboolean unitary operations considered computational learning theory 8 hiding information classical queries 14 broadly quantum oracle may defined device called applies fixed unitary transformation u current contents jzi query tape replacing u jzi oracle u must defined countably infinitedimensional hilbert space spanned binary basis vectors jffli j0i j1i j00i j01i j10i ffl denotes empty string clearly use general unitary oracles still yields unitary evolution wellformed oracle turing machines naturally oracles map inputs onto superpositions outputs vice versa need even lengthpreserving however order obey dictum single machine cycle ought make infinite changes tape one might require u jzi amplitude zero finitely many basis vectors one could even insist uniform effective version restriction another natural restriction one may wish impose upon u involution u effect oracle call undone call oracle may crucial allow proper interference take place note special case unitary transformation considered paper corresponds evaluating classical boolean function involution 3 difficulty simulating nondeterminism qtms computational power qtms lies ability maintain compute exponentially large superpositions tempting try use exponential parallelism simulate nondeterminism however inherent constraints scope parallelism imposed formalism quantum mechanics 5 section explore constraints see quantum interference speed np problems quadratically exponentially consider problem distinguishing empty oracle oracle containing single random unknown string known length n ie ay1 8 x6y ax0 require computer never answer yes empty oracle seek maximize success probability answering yes nonempty oracle classical computer better query distinct nbit strings random giving success probability 12 n one query k2 n k queries quantum computer 5 superficial similarity exponential parallelism quantum computation fact probabilistic computations yield probability distributions exponentially large domains difference probabilistic case computational path chosen making sequence random choicesone step quantummechanical case possible several computational paths interfere destructively therefore necessary keep track entire superposition step accurately simulate system better respecting rule overall evolution unitary computation nonempty oracle computation paths querying empty locations evolve exactly would empty oracle direct quantum analog classical algorithm would start equallyweighted superposition 2 n computation paths query different string path finally collapse superposition asking whether query found nonempty location yields success probability 12 n classical computer however best way exploit quantum parallelism goal maximize separation state vector j k k interactions empty oracle state vector j k yi k interactions oracle nonempty unknown location starting uniform superposition x easily seen separation one query maximized unitary evolution x phase inversion term corresponding nonempty location testing whether postquery state agrees j 0 obtain success probability approximately four times better classical value thus allowed one query quantum parallelism gives modest improvement still overwhelmingly likely fail state vector interaction nonempty oracle almost interaction empty oracle way producing large difference one query would concentrate much initial superposition term query cannot done location unknown achieved maximum separation one query best separation increased subsequent queries various strategies imagined good one called inversion average grover 13 perform oracleindependent unitary transformation change phase difference amplitude difference leaving term sign terms magnitude approximately threefold larger subsequent phaseinverting interactions oracle alternating oracleindependent phasetoamplitude conversions cause distance j 0 j k yi grow linearly k approximately 2k n2 results quadratic growth success probability approximately 4k 2 2 n small k proof theorem 35 shows approach essentially optimal quantum algorithm gain quadratic factor success probability compared classical algorithms attempting answer nptype questions formulated relative random oracle 31 lower bounds quantum search sometimes find convenient measure accuracy simulation calculating euclidean distance 6 target simulation superpositions following theorem 4 shows simulation accuracy 4 times worse euclidean distance theorem 31 two unitlength superpositions within euclidean distance observing two superpositions gives samples distributions within total variation distance 7 4 6 euclidean distance x ff x jxi x fijxi defined x 7 total variation distance two distributions 0 x definition 32 let joe superposition input x time denote sum squared magnitudes joe configurations querying oracle string refer q joe query magnitude joe theorem 33 let joe superposition input x time set timestrings pairs suppose answer query 2 f modified arbitrary fixed iy answers need consistent oracle let joe 0 time superposition input x oracle modified stated jjoe proof let u unitary time evolution operator let denote oracle 2 f unitary time evolution operator let joe superposition input x time define je error th step caused replacing oracle since u unitary ju sum squared magnitudes e equal iy2f q joe therefore 2 worst case u could interfere constructively however squared magnitude sum times sum squared magnitudes corollary 34 let oracle alphabet sigma 2 sigma let oracle 8x 6 time superposition input x time superposition ay input x every 0 set cardinality 2t 2 proof since joe unit length q joe let set strings therefore theorem 33 theorem 35 n o2 n2 relative random oracle probability contain np proof recall section 2 oracle thought lengthpreserving function mean ax let yg clearly language contained np let show boundederror oracle qtm running time n probability 1 accept language la probability taken choice random lengthpreserving oracle since countable number qtms intersection countable number probability 1 events still probability 1 conclude probability 1 bounded error oracle qtm accepts la time bounded n pick n large enough n 2 n2 show probability gives wrong answer input 1 n least 18 every way fixing oracle answers inputs length equal n probability taken random choices oracle inputs length n let us fix arbitrary lengthpreserving function strings lengths n alphabet sigma let c denote set oracles consistent arbitrary function let set oracles c 1 n inverse belong la oracle answers length n strings chosen uniformly random probability oracle least 14 probability 1 n inverse least 14 n sufficiently large let b set oracles c 1 n unique inverse probability randomly chosen oracle b least 1e given oracle modify answer single input say 1 n therefore get oracle b show choices acceptance probability input 1 n almost equal acceptance probability ay input 1 n hand must reject 1 n ay must accept 1 n therefore cannot accept la lay working details carefully easy show fails input 1 n probability least 18 oracle uniformly random function strings length n arbitrary function strings let oracle 34 set 338t 2 n strings difference th superposition ay input 1 n input 1 n norm 113 using theorem 31 conclude difference acceptance probabilities ay input 1 n input 1 n 113 theta 4 13 since ay accept probability least 23 reject 1 n probability least 23 conclude fails accept either la lay oracle 2 correctly decides whether 1 n 2 la changing single answer 1 n mapped least 2 different oracles fails correctly decide whether 1 n 2 la f moreover particular image mapping 2 since answers 1 n must given one possible answers therefore number oracles b fails must least 12 number oracles succeeds calling number oracles fails must fail least therefore fails correctly decide whether probability least 12p 18 easy conclude decides membership la probability 0 uniformly chosen oracle 2 note theorem 33 corollary 34 isolate constraints quantum parallelism imposed unitary evolution rest proof theorem similar spirit standard techniques used separate bpp np relative random oracle 3 example techniques used show relative random oracle classical probabilistic machine recognize la time o2 n however quantum machines recognize language quadratically faster time using grovers algorithm 13 explains substantial modification standard technique required prove theorem next result np conp relative random permutation oracle requires subtle argument ideally would like apply theorem 33 asserting total query magnitude gamma1 1 n probed small however precisely trying prove first place theorem 36 n o2 n3 relative random permutation oracle probability 1 bqtimet n contain np conp proof permutation oracle let first bit gamma1 1g clearly language contained np conp let show boundederror oracle qtm running time n probability 1 accept language la probability taken choice random permutation oracle since countable number qtms intersection countable number probability 1 events still probability 1 conclude probability 1 bounded error oracle qtm accepts la time bounded n pick n large enough n 2 n3 show probability gives wrong answer input 1 n least 18 every way fixing oracle answers inputs length equal n probability taken random choices permutation oracle inputs length n consider following method defining random permutations f0 1g sequence strings chosen uniformly random f0 1g n pick 0 uniformly random among permutations x 0 transposition random permutation f0 1g n consider sequence permutation oracles denote joe time superposition n input 1 n joe 0 time superposition ngamma1 input 1 n construction probability exactly 12 string 1 n member exactly one two languages la show e expectation taken random choice oracles markovs bound p 34 applying theorem 31 conclude acceptance probability n ngamma1 differ 825 13 hence either machines accept input 1 n reject input therefore n give answers input 1 n probability least 34 construction probability string 1 n belongs exactly one two languages la n equal p first bit x first bit x n therefore conclude probability least 14 either n ngamma1 gives wrong answer input 1 n since n ngamma1 chosen distribution conclude n gives wrong answer input 1 n probability least 18 bound e show joe n joe 0 close certain superposition j n define superposition run input 1 n different oracle step step use answer oracle queries denote j time superposition results consider set timestring pairs tg easily checked oracle queries computation described n n1 differ set claim expected query magnitude pair set 12 n since j may think x j randomly chosen step j superposition oracle queries performed already written oracle tape let ff sum query magnitudes timestring pairs random variable n theorem 33 showed e therefore e e finally easy conclude decides membership la probability 0 uniformly random permutation oracle 2 note view grovers algorithm 13 know constant 12 statement theorem 35 cannot improved hand evidence constant 13 statement theorem 36 fundamental may well theorem 36 would still hold albeit current proof 12 substituted 13 corollary 37 relative random permutation oracle probability 1 exists quantum oneway permutation given oracle permutation computed efficiently even classical deterministic machine yet requires exponential time invert even quantum machine proof given arbitrary permutation oracle gamma1 computed time n3 quantum turing machine easy decide la defined proof theorem 36 follows proof happens probability 0 uniformly random permutation oracle 2 4 using boundederror qtm subroutine notion subroutine call oracle invocation provides simple useful abstraction context classical computation making abstraction context quantum computation subtle considerations must thought example subroutine computes function f would like think invocation subroutine string x magically writing fx designated spot actually xoring ensure unitarity context quantum algorithms abstraction valid subroutine cleans traces intermediate calculations leaves final answer tape subroutine invoked superposition xs different values x would result different scratchwork tape would prevent different computational paths interfering since erasing unitary operation scratchwork cannot general erased postfacto special case f efficiently computed deterministically easy design subroutine reversibly erases scratchworksimply compute fx copy fx safe storage uncompute fx get rid scratch work 2 however case f computed bqp machine situation complicated computational paths machine lead correct answer fx therefore copy fx safe storage uncompute fx computational paths different values fx longer interfere reverse first phase computation show nonetheless boost success probability bqp machine copying fx safe storage uncomputing fx weight final superposition clean tape input x answer fx since tidy bqp machines safely used subroutines allows us show bqp bqp result also justifies definition oracle quantum machines correctness boosting procedure proved theorems 413 414 proof follows outline classical case except much careful simple programming constructs looping etc therefore borrow machinery developed 4 purpose present statements relevant lemmas theorems first part section main new contribution section proofs theorems 413 414 reader may therefore wish skip directly ahead proofs 41 programming primitives qtms subsection present several definitions lemmas theorems 4 recall qtm defined triplet sigma q ffi sigma finite alphabet identified blank symbol q finite set states identified initial state q 0 final state q f 6 q 0 ffi quantum transition function function c set complex numbers whose real imaginary parts approximated within 2 gamman time polynomial n definition 41 final configuration qtm configuration state q f qtm run input x time superposition contains final configurations time less superposition contains final configuration halts running time input x superposition time called final superposition run input x polynomialtime qtm wellformed qtm every input x halts time polynomial length x definition 42 qtm called wellbehaved halts input strings final superposition configuration tape head cell cell always start cell call qtm stationary say qtm normal form transitions distinguished state q f lead distinguished state q 0 symbol scanned cell left unchanged head moves right say formally definition 43 qtm normal form theorem 44 f function mapping strings strings computed deterministic polynomial time length fx depends length x polynomialtime stationary normal form qtm given input x produces output x fx whose running time depends length x f onetoone function strings strings f f gamma1 computed deterministic polynomial time length fx depends length x polynomialtime stationary normal form qtm given input x produces output fx whose running time depends length x definition 45 multitrack turing machine k tracks turing machine whose alphabet sigma form sigma 1 theta sigma 2 theta delta delta delta theta sigma k special blank symbol sigma blank sigma specify input specifying string track separated optionally specifying alignment contents tracks lemma 46 given qtm set sigma 0 qtm behaves exactly leaving second track unchanged lemma 47 given qtm qtm 0 behaves exactly except tracks permuted according lemma 48 1 2 wellbehaved normal form qtms alphabet normal form qtm carries computation 1 followed computation 2 lemma 49 suppose wellbehaved normal form qtm normal input x k k 0 machine 0 runs k iterations first track definition 410 qtms 1 2 alphabet say computation 1 following holds input x 1 halts let c x oe x initial configuration final superposition 1 input x 2 input superposition oe x halts final superposition consisting entirely configuration c x note 2 reverse 1 final state 2 must equal initial state 1 vice versa lemma 411 normal form qtm halts inputs normal reverses computation slowdown factor 5 finally recall definition class bqp definition 412 let stationary normal form multitrack qtm whose last track alphabet f 0 1g say accepts x halts 1 last track start cell otherwise say rejects x qtm accepts language l sigma gamma probability accepts probability least p every string x 2 l rejects probability least p every string define class bqp boundederror quantum polynomial time set languages accepted probability 23 polynomialtime qtm generally define class bqtimet n set languages accepted probability 23 qtm whose running time input length n bounded n 42 boosting subroutine calls theorem 413 qtm accepts language l probability 23 time n n n timeconstructible 0 qtm 0 accepts l polynomial log 1 independent n proof let stationary qtm accepts language l time n build machine runs k independent copies takes majority vote k answers input x final superposition strings call set x correct answer mx running separate copies input k times produce probability seeing jx majority correct answer mx sum jff 1 2 majority lie like taking majority k independent coin flips probability least 23 heads therefore constant b log 1 probability seeing correct answer least 1 gamma build machine carry following steps 1 compute 2 write k copies input x spaced 2n blank cells write k n tracks 3 loop k times machine runs steps n times right 4 calculate majority k answers write back start cell construct desired qtm building qtm four steps dovetailing together since steps 1 2 4 require easily computable functions whose output length depend k length x carry using wellbehaved normal form qtms constructed using theorem 44 whose running times also depend k length x complete proof constructing qtm run given machine k times first using theorem 44 construct stationary normal form qtm drags integers k n one square right work track add single step right end qtm apply lemma 49 build wellbehaved normal form qtm moves n squares right dragging k n along dovetailing machine applying lemma 49 gives normal form qtm runs k copies input finally dovetail machine return k n start cell using lemma 49 two times around qtm carries k n one step left 2 extra information output tape qtm erased copying desired output another track running reverse qtm output every configuration final superposition reversal exactly recover input unfortunately output differs different configurations saving output prevent configurations interfering machine reversed input recovered show final superposition reversal must lead us close input theorem 414 language l contained class bqtimet n n n n timeconstructible 0 qtm 0 accepts l following property run input x length n runs time bounded ct n c polynomial log 1 produces final superposition jxijlxi otherwise squared magnitude least 1 gamma proof let stationary normal form qtm accepts language l time bounded n according theorem 413 expense slowdown factor polynomial log 1 independent n assume accepts l probability every input construct desired 0 running copying answer another track running reverse copy easily accomplished simple twostep machine steps left back right writing answer clean track using lemma 411 construct normal form qtm r reverses finally appropriate use lemmas 46 47 construct desired stationary qtm dovetailing machines r around copying machine see 0 desired properties consider running 0 input x length n 0 first run x producing final superposition configurations ff jyi input x write 0 1 extra track start cell configuration run r superposition ff jyijb instead run r superposition joe ff jyijmxi would n steps superposition consisting entirely final configuration output x mx clearly hoejoe 0 real since success probability least therefore since time evolution r unitary hence preserves inner product final superposition 0 must inner product jxijmxi real least 1 gamma 2 therefore squared magnitude final superposition 0 final configuration output x mx must least 1 gamma corollary 415 bqp acknowledgement wish thank bob solovay several useful discussions r arthur merlin games randomized proof system hierarchy complexity classes logical reversibility computation relative random oracle p 6 np 6 conp probability 1 quantum complexity theory quantum challenge structural complexity theory oracle quantum computing tight bounds quantum searching learning dnf uniform distribution using quantum example oracle quantum theory churchturing principle universal quantum computer quantum computational networks rapid solution problems quantum computation simulating physics computers fast quantum mechanical algorithm database search phase information quantum oracle computing algorithms quantum computation discrete logarithms factoring power quantum computation quantum circuit complexity tr ctr feng lu dan c marinescu r cmax quantum scheduling algorithm quantum information processing v6 n3 p159178 june 2007 peter w shor havent quantum algorithms found journal acm jacm v50 n1 p8790 january marcello frixione tractable competence minds machines v11 n3 p379397 august 2001 alp atici rocco servedio improved bounds quantum learning algorithms quantum information processing v4 n5 p355386 november 2005 lov k grover jaikumar radhakrishnan partial quantum search database easier proceedings seventeenth annual acm symposium parallelism algorithms architectures july 1820 2005 las vegas nevada usa alex fabrikant tad hogg graph coloring quantum heuristics eighteenth national conference artificial intelligence p2227 july 28august 01 2002 edmonton alberta canada george f viamontes igor l markov john p hayes quantum search practical computing science engineering v7 n3 p6270 may 2005 mika hirvensalo quantum computing facts folklore natural computing international journal v1 n1 p135155 may 2002 mark adcock richard cleve kazuo iwama raymond putra shigeru yamashita quantum lower bounds goldreichlevin problem information processing letters v97 n5 p208211 march 2006 akinori kawachi hirotada kobayashi takeshi koshiba raymond h putra universal test quantum oneway permutations theoretical computer science v345 n23 p370385 22 november 2005 maciej gowin complexity searching maximum function quantum computer quantum information processing v5 n1 p3141 february 2006 dorit aharonov alexei kitaev noam nisan quantum circuits mixed states proceedings thirtieth annual acm symposium theory computing p2030 may 2426 1998 dallas texas united states harry buhrman richard cleve avi wigderson quantum vs classical communication computation proceedings thirtieth annual acm symposium theory computing p6368 may 2426 1998 dallas texas united states damien woods thomas j naughton optical model computation theoretical computer science v334 n13 p227258 11 april 2005 ashwin nayak felix wu quantum query complexity approximating median related statistics proceedings thirtyfirst annual acm symposium theory computing p384393 may 0104 1999 atlanta georgia united states stephen fenner lance fortnow stuart kurtz lide li oracle builders toolkit information computation v182 n2 p95136 01 may andris ambainis ashwin nayak ammon tashma umesh vazirani dense quantum coding lower bound 1way quantum automata proceedings thirtyfirst annual acm symposium theory computing p376383 may 0104 1999 atlanta georgia united states michele mosca counting quantum eigenvalue estimation theoretical computer science v264 n1 p139153 08062001 papageorgiou h woniakowski sturmliouville eigenvalue problem npcomplete problems quantum setting queries quantum information processing v6 n2 p101120 april 2007 tetsuro nishino mathematical models quantum computation new generation computing v20 n4 p317337 october 2002 introduction quantum computing nonphysicists acm computing surveys csur v32 n3 p300335 sept 2000 andris ambainis quantum lower bounds quantum arguments journal computer system sciences v64 n4 p750767 june 2002 andris ambainis quantum lower bounds quantum arguments proceedings thirtysecond annual acm symposium theory computing p636643 may 2123 2000 portland oregon united states lov k grover framework fast quantum mechanical algorithms proceedings thirtieth annual acm symposium theory computing p5362 may 2426 1998 dallas texas united states howard barnum michael saks lower bound quantum query complexity readonce functions journal computer system sciences v69 n2 p244258 september 2004 markus hunziker david meyer quantum algorithms highly structured search problems quantum information processing v1 n3 p145154 june 2002 scott aaronson quantum lower bound collision problem proceedings thiryfourth annual acm symposium theory computing may 1921 2002 montreal quebec canada umesh vazirani fourier transforms quantum computation theoretical aspects computer science advanced lectures springerverlag new york inc new york ny 2002 tarsem purewal jr revisiting limit efficient quantum computation proceedings 44th annual southeast regional conference march 1012 2006 melbourne florida van dam sean hallgren lawrence ip quantum algorithms hidden shift problems proceedings fourteenth annual acmsiam symposium discrete algorithms january 1214 2003 baltimore maryland sean hallgren cristopher moore martin rtteler alexander russell pranab sen limitations quantum coset states graph isomorphism proceedings thirtyeighth annual acm symposium theory computing may 2123 2006 seattle wa usa andrew chichih yao graph entropy quantum sorting problems proceedings thirtysixth annual acm symposium theory computing june 1316 2004 chicago il usa hartmut klauck quantum timespace tradeoffs sorting proceedings thirtyfifth annual acm symposium theory computing june 0911 2003 san diego ca usa yaoyun shi quantum classical tradeoffs theoretical computer science v344 n23 p335345 17 november 2005 mika hirvensalo computing quantaimpacts quantum theory computation theoretical computer science v287 n1 p267298 25 september 2002 marco carpentieri simulation quantum turing machines theoretical computer science v304 n13 p103128 28 july harry buhrman lance fortnow ilan newman hein rhrig quantum property testing proceedings fourteenth annual acmsiam symposium discrete algorithms january 1214 2003 baltimore maryland harumichi nishimura masanao ozawa computational complexity uniform quantum circuit families quantum turing machines theoretical computer science v276 n12 p147181 april 6 2002 robert beals harry buhrman richard cleve michele mosca ronald de wolf quantum lower bounds polynomials journal acm jacm v48 n4 p778797 july 2001 holger spakowski mayur thakur rahul tripathi quantum classical complexity classes separations collapses closure properties information computation v200 n1 p134 1 july 2005 scott aaronson yaoyun shi quantum lower bounds collision element distinctness problems journal acm jacm v51 n4 p595605 july 2004 colin p williams quantum search algorithms science engineering ieee multimedia v3 n2 p4451 march 1996 hirotada kobayashi keiji matsumoto quantum multiprover interactive proof systems limited prior entanglement journal computer system sciences v66 n3 p429450 may miklos santha mario szegedy quantum classical query complexities local search polynomially related proceedings thirtysixth annual acm symposium theory computing june 1316 2004 chicago il usa scott aaronson lower bounds local search quantum arguments proceedings thirtysixth annual acm symposium theory computing p465474 june 1316 2004 chicago il usa ambainis quantum search algorithms acm sigact news v35 n2 june 2004 frederic magniez ashwin nayak jeremie roland miklos santha search via quantum walk proceedings thirtyninth annual acm symposium theory computing june 1113 2007 san diego california usa andris ambainis polynomial degree vs quantum query complexity journal computer system sciences v72 n2 p220238 march 2006 lance fortnow one complexity theorists view quantum computing theoretical computer science v292 n3 p597610 31 january ronald de wolf quantum communication complexity theoretical computer science v287 n1 p337353 25 september 2002 peter w shor progress quantum algorithms quantum information processing v3 n15 p513 october 2004 marco lanzagorta jeffrey k uhlmann hybrid quantumclassical computing applications computer graphics acm siggraph 2005 courses july 31august scott aaronson guest column npcomplete problems physical reality acm sigact news v36 n1 march 2005
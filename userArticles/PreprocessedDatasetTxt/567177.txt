tracking mobile units dependable message delivery computing components get smaller people become accustomed computational power disposal time mobile computing developing important research area one fundamental problems mobility maintaining connectivity message passing user moves network approach single home node constantly track current location mobile unit forward messages location one problem approach update home agent movement messages often dropped especially case frequent movement paper present new algorithm uses home agent maintains information regarding subnet within mobile unit must present also present reliable message delivery algorithm superimposed region maintenance algorithm strategy based ideas diffusing computations first proposed dijkstra scholten finally present second algorithm limits size subnet keeping path home node mobile unit b introduction mobile computing reflects prevailing societal technological trend towards ubiquitous access computational communication resources wireless technology decreasing size computer components allow users travel within office building office home around country computer side locationtransparent contextdependent services desired decoupled computing becoming norm disconnection longer network fault common event intentionally caused user order conserve power consequence movement tethered connectivity making way opportunistic transient connections via radio infrared transmitters focus paper message delivery mobile units fixed network message delivery relies established routes network although faults render parts network inoperational even inaccessible assumed faults infrequent system able stabilize despite changes mobility changing connectivity mobile components fault rather feature mobile unit moves network accessibility point changes base station model mobility similar cellular telephone system mobile unit connected network single point base station base station either wired wireless connectivity changes greater frequency typical network faults goal able get message mobile unit moving among cells environment mobile units multiple points connection short period time mobile units disconnect completely network movement necessarily predictable tracking current location mobile unit multiple places network expensive one proposed solution delivering message mobile unit mobile ip 6 every mobile unit assigned single home agent responsible forwarding messages packets mobile user time mobile unit moves must provide home agent new location solution simple require infrastructure changes network encapsulation endpoint specific software used accomplish location transparency distributed approaches update routers forwarding information keeping information closer mobile unit 5 potentially long path message originating near current location mobile unit short circuited sending way home agent however neither solution provides reliable delivery possible packet sent home agent toward mobile agent mobile agent move packet delivered mobile ip higher layer network protocol stack responsible reliability retransmission necessary eventually packets delivered reasonable probability cellular telephones system similar mobile ip employed users roam outside home region 9 telephone activated user registers home indicating essentially new area code redirecting calls registration process occurs infrequently common case user remain within single region within region another approach must taken locate mobile time call arrives handovers used maintain connectivity user crosses cell boundary session cases mobile moves rapidly among cells information home agent reflect old location messages sent location dropped clearly forwarding mechanism added foreign locations send otherwise lost messages mobile units next location however rapid movement messages continue chasing mobile without delivery following trail forwarding pointers time amount forwarding information increase dramatically although rapid movement may seem unlikely one trends mobility reduce size cell eg nanocells increase frequency reuse cell sizes decrease time takes traverse cell similarly decreases another possible application characterized rapid mobile movement mobile code physical component moves rather program traverses fixed network computation various network nodes rather connecting foreign agent wireless mechanism mobile code agents actually execute foreign host ability move rapidly one host another may register new location home therefore delivering message mobile code agent becomes interesting application area rapid movement feasible common case technological trends pose following interesting question devise efficient protocols guarantee delivery node set nodes move arbitrary speeds across fixed network clearly trivial solutions exist broadcast message nodes store message nodes mobile arrives contrast efficient solutions limit broadcast range andor amount storage required paper start idea employing diffusing computations proposed dijkstra scholten 3 adapt message delivery equating root node computation concept home agent mobile ip replacing messages computation mobile units result algorithm instead tracking computation messages passed system processing nodes tracks movement mobile unit visits various base stations system essentially graph dijkstra scholten algorithm defines region within mobile unit always located although directly message delivery algorithm propagating message throughout region achieve message delivery algorithm readily adapted purpose optimized message delivery eg solution prunes unnecessary portions graph reducing area message must propagated approach algorithm development involves application new paradigm adapts algorithms traditional distributed computing mobile environment paradigm treats mobile units messages travel across network examines adaptations standard distributed algorithms mobility case dijkstrascholten tracking algorithm one assumptions often made distributed computing fifo channel behavior algorithms developed rely ability ensure property mobile environment particular mobile units messages move along channel may seem unrealistic considering mobile units move slowly comparison transmission messages along wires remainder paper organized follows section 2 presents model moblity offers precise formulation problem presents algorithm ensuring fifo behavior mobile units messages section 3 explores details message delivery algorithm derived directly dijkstrascholten model diffusing computations section 4 presents another algorithm inspired first reduces message delivery overhead algorithm provide formal verification properties finally section 6 contains analysis conclusions problem definition message delivery problem interested delivery messages rapidly moving mobile units acceptable solution guarantee least delivery message minimize storage requirements across network leave trace message system within bounded time delivery mobile units communicate directly one another network must provide support deliver messages cellular telephone design provides foundation model mobility adopt paper figure 1a shows typical cellular telephone model single mobile support center msc cell msc responsible communication mobile units within region serves manager handover requests mobile moves mscs figure 1b shows cellular telephone model transformed graph nodes channels nodes represent individual cells channels represent ability mobile unit move one cell another assume resulting network connected words path exists every pair nodes21 cellular system b graph model figure 1 cellular system one msc per cell mscs assumed connected wired network b abstract model cellular system graph nodes channels solid lines form spanning tree mobile unit moving across border two cells may miss simple broadcast along spanning tree instance handover occurs broadcast msc 2 broadcast msc 1 also assume mobile unit moving two mscs modeled channel identical messages transit manner longer differentiate physical movement wired commu nication reasonable ask happens messages mobile units found channel make assumption channels preserve message ordering ie fifo channels appears require mobile units travel space reconnect next support center fast faster messages transmitted across network although flush primitives 2 used make traditional nonfifo channels fifo separate channels used mobile units messages makes flush primitives inapplicable mobility fifo behavior however realized integrating handover protocol message passing instance amps standard cellular communication 9 describes handover protocol defines sequence wired messages source destination mscs well wireless communications root signal 1 message 2 figure 2 dijkstrascholten detecting termination diffusing computation shaded nodes idle white nodes active mobile unit introducing single additional wired message protocol coordinate wireless transfer mobile unit mscs wired transfer messages including data messages minor adjustments must made sender receiver achieve result eg buffering messages mobile unit announces arrival destination changes forced behavior mobile unit details approach available 4 emphasize achieving fifo behavior mobile units messages requires trivial changes existing handover protocols therefore assumed network property remainder paper 3 applying diffusing computations mobile unit tracking diffusing computations property computation initiates single root node nodes idle computation spreads messages sent active nodes dijkstra scholten 3 describe algorithm detecting termination computations basic idea maintaining spanning tree includes active nodes shown figure 2 message sent active node idle node message 1 figure adds latter tree child former messages sent among tree nodes effect structure may activate idle nodes still tree idle leaf node leave tree time notifying parent signal 2 figure 2 termination detected idle root remains tree adapt tree maintenance algorithm mobile environment node seen active mobile unit present resulting algorithm maintains tree identical figure 2 mobile unit active node channel leaving tree node enables us guarantee continued existence path root mobile unit along tree edges use property develop guaranteed message delivery algorithm latter superimposed top graph maintenance algorithm maintain distinction data messages delivered control messages used effect delivery refer data message announcement section first describe details graph maintenance algorithm present guaranteed data message ie announcement delivery algorithm short discussion possible extensions 31 mobile tracking although dijkstrascholten algorithm easily described understood distributed message passing nature algorithm leads subtle complexities details algorithm found figure 3 action one atomic step assume weak fairness action selection purposes discussion e mobileat boolean true mobile unit initially false except root parenta parent node initially null multiset children node initially actions mobilearrivesa b arrival b effect mobileat true parenta 6 null send signala b else arrival b effect mobile moves b preconditions mobileat channel ab exists effect mobileat false node tree preconditions effect send signala b figure 3 diffusing computations adapted tracking mobile unit assume mobile unit initially located root moves nondeterministically throughout graph figure 3 operation sendmobilea b introduction section described algorithm maintains tree structure edges parent child distributed nature environment sender message cannot know whether destination node already tree cannot know whether add destination child therefore tree structure maintained edges child parent recorded parenta figure 3 detecting termination removing nodes tree node must able detect idle leaf node done tracking message sent node dijkstrascholten algorithm requires every message acknowledged destination signal message arrives destination node already part tree spanning tree topology change signal sent immediately otherwise signal delayed sent destination node removes tree source node tracks messages destination multiset bag nodes bag indicate children nodes spanning tree nodes message arrived nodes signal sent yet received bag empty node children remove tree signaling parent detecting termination diffusing computation necessary keep count number successors intend use information announcement delivery must maintain bag children similar processing must occur mobile setting movement mobile unit tracked multiset eg childrena element removed multiset node receives signal figure 3 operation signalarrives signal sent immediately mobile unit arrives node already part tree figure 3 mobilearrives delayed otherwise delayed signal released node becomes leaf removed tree figure 3 cleanup 32 superimposing announcement delivery described graph maintenance algorithm present algorithm guarantee atleastonce delivery announcement details shown figure 4 actions superimposed graph maintenance actions figure 3 actions label execute parallel new actions fairly interleaved e hsame beforei announcementata boolean true announcement stored initially false everywhere started boolean true delivery started initially false actions mobilearrivesa b arrival b effect hsame beforei announcementata deliver announcement send ack parenta childrena arrival b hsame beforei moves b hsame beforei announcementarrivesa b arrival b effect mobileat deliver announcement send ack b else announcementata true save ann send announcements childrena node tree preconditions hsame beforei effect hsame beforei announcementata false delete ann arrival b effect announcementata announcementata false delete ann send acks childrena except b announcementstart root sends announcement preconditions effect started true moibleat root true deliver announcement else announcementat root true send announcement childrenroot figure 4 announcement delivery top diffusing computations existing actions announcement delivery assume announcement originates root rely property always path root mobile unit alongedges tree note reverse edges tree parent child subset edges parent child maintained successors parent eg childrena necessary send announcement along edges spanning tree tree maintained pointers child parent announcement must propagated along successor edges parent child announcement arrives source parent announcement rejected figure 4 announcementarrives manner announcement processed along tree paths effectively frontier announcements sweeps spanning tree announcement mobile unit colocated node announcement delivered figure 4 announcementarrives mobilearrives stable environment mobile unit move announcement passing sufficient guarantee delivery however mobile unit moves node tree frontier node frontier delivery may fail therefore node stores copy announcement delivery complete node removed tree figure 4 announcementarrives storing announcement manner ensures mobile unit cannot move region frontier without receiving copy announcement always path root mobile unit must announcement frontier traversing path announcement eventually reach mobile unit thus leading delivery figure 4 mobilearrives path may change mobile unit moves one region tree another however existence path guaranteed graph maintenance algorithm presented previous section existence announcement path guaranteed delivery algorithm section worst case possible mobile unit continuously travel announcement channel exactly one step behind eventually mobile unit must either stop moving maximum length path reached equal number nodes system mobile unit return previously visited tree node mobile unit returns tree node assumptions must frontier announcements receive announcement stored storing announcement requires additional cleanup phase remove copies mobile unit receives announcement acknowledgement generated sent along successor parent edges ure 4 announcementarrives mobilearrives acknowledgment rejected along paths part tree figure 4 ackarrives connectivity tree ensures acknowledgement propagate nodes holding copies announcement leaf nodes removed tree must also delete copy announcement figure 4 cleanup algorithm ensures atleastonce delivery announcement announcement copies remain graph acknowledgment received possible mobile unit move region acknowledgments propagated region occurs mobile unit receive additional copy announcement reject based sequence numbers important note time delivery occurs new set acknowledgments generated shown acknowledgments inhibit clean process rather lead faster clean set acknowledgments spreads independently tree removing announcement copies terminates region without announcement copies reached 33 discussion superimposing delivery actions top graph maintenance result algorithm guarantees least delivery announcement actively maintaining graph system nodes mobile unit recently traveled necessary spanning tree pruned soon idle leaf node exists instead processing delayed period low bandwidth utilization application may benefit allowing construction wide spanning tree within mobile units travels tradeoffs include shorter paths root mobile unit versus increase number nodes involved announcement delivery constructing graph based movement mobile unit path root mobile unit may optimal therefore possible extension run optimization protocol reduce length path optimization must take consideration continued movement mobile unit well announcement deliveries progress tradeoff approach benefit shorter route root mobile unit additional bandwidth complexity required run optimization although algorithm one mobile unit present graph maintenance algorithm requires extensions track group mobile units resulting spanning tree used unicast announcement delivery without modifications multicast announcement delivery changing announcement clean mechanism presented delivery announcement triggers propagation acknowledgments multicast case possible announcement reach mobile units cleanup starts one practical solution eliminate cleanup rules entirely assign timeout announcement timeout proportional time takes announcement traverse diameter network 4 backbone introduce new tracking delivery algorithm inspired previous investigation diffusing computations goal reduce number nodes announcement propagates accomplish note path root mobile unit necessary delivery previous approach although parts graph path root mobile unit eliminated remove messages announcements still propagate unnecessarily subtrees node deletion occurs avoid algorithm presented section maintains graph one path leading away root terminating mobile unit path referred backbone nodes remainder graph form structures referred tails actively removed graph rather relying idle leaf nodes remove maintenance new structure requires additional information carried mobile unit regarding path root well addition delete message remove tail nodes announcement delivery mechanism remains essentially simpler graph reduces number announcement copies stored delivery understand backbone kept independent tails examine graph changes mobile unit moves important note definition backbone mobile unit always either last node backbone channel leading away figure 5a backbone composed nodes b c dashed arrow shows movement mobile unit node c part graph straightforwared case backbone extended include adding child pointer c shown parent pointer reverse direction solid arrow figure 5b figure 5b mobile moves node b node already backbone nonnull parent pointer clear figure backbone shortened include b without changing parent pointers c deleted explicitly remove tail created c delete message sent child b c receives delete parent nullify parent pointer propagate delete child nullify child pointer point mobile moves b onto arrival delete see figure 5c still root root del root root backbone extended b backbone shortened c tail node added movement completes figure 5 parent pointers backbone change mobile moves node backbone b node higher backbone c tail node shows state channels cleared root tail backbone home covered backbone del tail del sample diffusing computation b modified graph showing new structure figure adapting diffusing computations mobility construct graph reflecting movement mobile order deliver announcement part graph need path root mobile backbone therefore adapt dijkstrascholten algorithm maintain graph segment delete others parent pointer c cannot distinguish case previous case b also non null parent pointer previous case parent node mobile unit arrived change case wish ds parent set b node mobile unit arriving backbone maintained distinguish two cases require mobile unit carry sequence identities nodes backbone first case mobile unit arrives b b list backbone nodes maintained mobile unit therefore b keeps parent pointer unchanged prunes backbone list remove c however mobile arrives b backbone list therefore parent pointer changed point b happens delete message moving c c longer ds parent delete arrives simply dropped backbone affected delivery algorithm superimposed top generated graph sufficient send announcement spanning tree created backbone without keeping copies nodes along path mobile free move region announcement one figure 5b assuming announcement propagated c therefore guarantee delivery announcement propagates backbone copy stored node delivery complete refer portion backbone announcement covered backbone see figure 6b delivery occur mobile unit moving location covered backbone announcement catching mobile unit node either case acknowledgment generated sent via parent pointers toward root announcement delivered mobile unit moving covered backbone delete generated toward child acknowledgment generated toward parent therefore extra copies announcement newly created tail deleted nodes 41 details details tracking algorithm shown figure 7 model arbitrary movement mobile action called sendmobilea b allows mobile node move nondeterministically onto outgoing channel mobilearrives shows bulk processing relates closely actions described figure 5 mobile unit arrives node changes backbone must determined mobile doubling back onto backbone parent pointers remain unchanged path carried mobile shortened reflect new backbone figure 5b node backbone figure 5a part tail figure 5c parent pointers must change add node backbone node must appended backbone list carried mobile case children node longer necessary announcement delivery therefore delete message sent child child pointer cleared addition maintaining graph must also address announcement delivery previous al gorithms mobile unit arrives node announcement stored delivery occurs yielding atleastonce semantics delivery algorithm introduce sequence number ensure exactlyonce delivery semantics therefore mobile arrives node announcement delivery attempted sequence number last announcement received mobile less sequence number waiting announcement cases whether delivery accomplished point announcement delivered mobile unit acknowledgment generated along path toward root clean announcement copies acknowledgment needs generated toward tails announcement copies tails removed time tail node removed graph propagating announcement arrives node announcementarrives either arriving parent node announcement arrives node parent discarded guarantee delivery announcement need propagate along backbone however announcement arrives parent must processed mobile present delivery attempted restrictions respect sequence number acknowledgment started toward root mobile present node stores copy announcement case mobile arrives later time additionally announcement propagated child link ackarrives enables cleanup announcements propagating acks along backbone toward root via parent pointers acks also present tail links essentially redundant delete messages affect correctness algorithm purpose delete messages remove tail segments graph recall tail created backbone node sending delete child therefore delete arrive parent node accept delete nonparent node delete c figure 5c could destroy backbone however delete arrives parent assured node longer resides backbone deleted therefore arrival delete parent triggers deletion stored announcement propagation delete child clearing child parent pointers state announcementata boolean true announcement stored initially false everywhere mobileat boolean true mobile unit initially false except root parenta parent node initially null childa child node initially null started boolean true delivery started initially false mlist list nodes carried mobile initially contains root actions announcementarrivesa b arrival b effect parentab mobileat deliver announcement send ack b else announcementata true save ann send announcement childa arrival b effect childab announcementata announcementata false delete ann send ack parenta arrival b effect parentab announcementata announcementata false delete ann send delete childa parentanull childanull mobilearrivesa b arrival b effect mobileat true keeps old parent mlist truncated end announcementata deliver announcement send ack parenta announcementata false delete ann else parentab window protocols announcements associated acknowledgments would marked sequence numbers interfere delivery mechanism uses graph therefore rules governing expansion shrinking graph affected proofs garbage collection acknowledgment delivery delicate 43 correctness algorithm deviates significantly original dijkstrascholten model diffusing computations essential properties necessary announcement delivery proven section 1 announcement delivery guaranteed delivery announcement copies eventually removed system tail node eventually cleared although third property essential announcement delivery necessary show announcement cleanup approaching proof formalize several useful definitions figure 8 important backbone covered backbone tails intuitively backbone sequence nodes starting root terminating either node holding mobile unit node mobile unit left channel covered backbone sequence backbone nodes announcement copies tails path segments backbone 431 announcement delivery guarantee overall goal show atleastonce delivery announcement mobile unit therefore first property prove state announcement exists system predelivery eventually state reached mobile unit copy predelivery 7 postdelivery although possible make transition single step executing announcementstart mobile unit root common system move intermediate state delivery progress a1 must show state delivery either announcement delivered worst case covered backbone increase length include every node system a2 occurs delivery guaranteed take place mobile unit arrives node a3 predelivery ensures delivery postdelivery a1 delivery 7 postdelivery delivery h9ff coveredboneff postdelivery a3 progress properties expressed using unity relations 7 read leadsto ensures predicate relation p 7 q expresses progress requiring point execution predicate p satisfied later state q satisfied similarly p ensures q states program state satisfying p remains state unless q established addition remain forever state satisfying p q d1 reachablem n node n reachable node path n every channel path parent child pointers channel endpoints pointing toward one another d2 path p includes node n acyclic sequence reachable nodes d3 maxpathp n r j pathp n path p maximal length path including node n satisfies predicate r extending p either direction concatenation ffi either violates path relationship condition r d4 path p backbone ie path maximal length includes root include mobile unit channel constant mob used identify mobile unit path p covered backbone ie maximal length path including root backbone nodes storing announcement copies tail maximal length path node n node path part backbone figure 8 useful definitions approach properties turn first showing predelivery either delivery postde livery must follow a1 action announcementstart fires system remains predelivery announcementstart remains enabled trivially fires either announcement delivered mobile unit present root announcement begin propagate system delivery state reached must show covered backbone increase length include nodes announcement delivered a2 strengthen progress property a2 state covered backbone cannot decrease length delivery delivery coveredboneff jffj postdelivery a21 order formally make assertion must first show delivery covered backbone ex ists showing existence covered backbone independent system attributes possi ble therefore prove stronger invariant establishes existence covered backbone also existence backbone relationship two definition covered backbone subset backbone assert covered backbone shorter back bone announcement leaving last node covered backbone lastff returns final element path ff alternately covered backbone backbone equivalent mobile unit must precede announcement indicated constant ann channel leaving last node delivery invariant proven showing holds initially well statements program throughout proof use several supporting properties appear appendix specifically inv i11 integrity backbone inv i12 backbone always exists inv i13 one announcement channel inv i14 announcements predelivery inv i15 acknowledgments delivery show proof top level property concerning existence covered backbone delivery i1 ffl trivial show initial conditions i1 initially delivery false ffl mobilearrivesa b assume integrity backbone inv i11 first consider case system delivery right hand side invariant i1 holds covered backbone affected mobile unit arrives nonbackbone node backbone node covered backbone mobile unit arrives covered backbone node announcement delivered invariant trivially true falsifying left hand side next consider system delivery system predelivery assume announcements predelivery inv i14 movement mobile unit cannot affect delivery status system postdelivery cannot return delivery invariant remains true ffl announcementarrivesa b assume one announcement channel system i13 therefore system delivery assume invariant true announcement arrives announcement must leaving covered backbone since announcement head channel cannot case mobile unit announcement channel covered backbone must proper subsequence backbone therefore definitions covered backbone backbone node announcement arrives backbone either announcement delivered propagated delivery occurs invariant trivially satisfied falsifying delivery condition announcement propagated next channel covered backbone extended one node already shown part backbone announcement put onto child link node backbone definition must channel backbone backbone extension announcement must follow mobile unit mobile unit channel system delivery delivery status system cannot change execution execution statement statement executes mobile unit must node otherwise statement skip since assume invariant true must case covered backbone proper subsequence backbone therefore mobile unit leaves node backbone changed include new backbone extension covered backbone affected invariant remains true ffl announcementstart assume system predelivery announcements system inv i14 therefore statement executes either delivery occurs inv i1 invariant trivially true announcement placed root outgoing link establishing right hand side invariant system delivery postdelivery statement skip ffl ackarrivesa b assume acknowledgments system delivery inv i15 therefore statement essentially skip delivery statement cannot change delivery status therefore system predelivery postdelivery invariant trivially true ffl deletearrivesa b assume delete messages affect backbone inv i11 therefore affect covered backbone invariant remain true statement cannot change delivery status concludes proof delivery covered backbone exists show covered backbone must grow defined property a21 note two specific cases system respect mobile unit announcement show either covered backbone must increase delivery occur first case mobile unit announcement channel since system delivery cannot acknowledgment channel inv i15 since announcement backbone channel cannot delete channel inv i11 assumption mobile unit channel covers possible message types could precede announcement channel therefore announcement must head channel case progress property a21 concerns growth covered backbone becomes ensures announcement remain head channel processed lengthening covered backbone mobile unit arrive node causing delivery either case condition right hand side becomes true second case mobile unit announcement channel invariant i1 mobile unit precedes announcement channel state trivial progress property mobile unit head channel ensured arrive destination node mobileatheadm n ensures mobileatn a211 one mobile unit mobile unit removed channel either system taken delivery mobile unit receiving announcement system reduced first case mobile unit announcement channel previous discussion effectively shows property a21 namely covered backbone must grow nodes system part covered backbone delivery occurred complete proof delivery guaranteed need show nodes part covered backbone delivery must occur definitions covered backbone backbone nodes part covered backbone two equivalent mobile unit must channel nodes announcement copies mobile unit node must received announcement copy either mobile unit arrived announcement arrived destination channel mobile unit must part backbone nodes part backbone delete front mobile unit effect backbone inv i11 cannot acknowledgment channel inv i15 announcement must behind mobile unit inv i11 therefore delete processed mobile unit head channel mobilearrivesa b action cause delivery therefore announcement delivery guaranteed initial state system 432 backbone announcements cleaned announcement delivered show eventually stored announcement copies removed two cases address announcements nodes backbone backbone next section show nodes part backbone cleaned section focuses cleanup backbone nodes particular wish show announcement delivered eventually announcement copies backbone deleted postdelivery 7 h8m introduce safety property describing state backbone postdelivery namely backbone covered backbone exist b acknowledgment channel heading toward last node covered backbone c nodes backbone covered backbone announcement copies announcement copies backbone channels backbone extension e acknowledgments channels covered backbone intuitively invariant shows one segment backbone announcement copies nodes segment poised receive acknowledgment postdelivery show proof statement showing holds execution statement must hold execution statement ffl mobilearrivesa b mobile unit arrives nonbackbone node backbone extended include node channel traversed become part backbone announcement last part invariant covered backbone change announcement node removed still announcement copies nodes covered backbone mobile unit arrives backbone node part covered backbone covered backbone change still announcements backbone nodes covered backbone new channels added backbone announcement copies channels covered backbone mobile unit arrives backbone node part covered backbone covered backbone shortened nodes new location mobile unit nodes must announcement copy part covered backbone mobile unit arrived also acknowledgment generated channel heading toward new covered backbone invariant established new channels backbone still announcements backbone channels must also consider case postdelivery condition established arrival mobile unit components invariant established announcement system end covered backbone must downstream mobile unit arrived announcements backbone channels remainder invariant established manner similar case system postdelivery mobile unit arrives covered backbone node ffl announcementarrivesa b system delivery arrival announcement could establish postdelivery case components invariant established nodes mobile unit part covered backbone acknowledgment put channel mobile unit end covered backbone announcement copy node mobile unit deleted system postdelivery announcement arrives announcement could arrive backbone node nonbackbone channel dropped therefore invariant affected neither backbone nodes links affected ffl sendmobilea b mobile unit leaves node covered backbone change also mobile unit end channel announcements channel must mobile unit ffl deletearrivesa b arrival delete backbone node affect backbone covered backbone arrival delete elsewhere system affect invariant ffl ackarrivesa b acknowledgment arrives covered backbone node must end covered backbone therefore processing acknowledgment shrink covered backbone one node put acknowledgment farther backbone alternately root could receive acknowledgment would longer covered backbone acknowledgment arrives nonbackbone node accepted put onto backbone accepted nothing changes covered backbone backbone therefore invariant maintained ffl announcementstart statement effect postdelivery predelivery statement could establish invariant delivering announcement node root case covered backbone exist invariant true goal show progress cleanup announcements covered backbone use progress metric measures reduction length covered backbone nodes backbone announcement copies must covered backbone invariant i2 covered backbone length zero announcements backbone deleted postdelivery coveredboneff prove statement note previous invariants established acknowledgment channel heading toward covered backbone acknowledgment head channel must something else front cannot delete channel would mean delete backbone allowed invariant i11 announcement would effect arriving parent link mobile unit channel arrival mobile unit would cause delivery announcement must last node covered backbone covered backbone would change either mobile unit arrive channel acknowledgment another channel cause covered backbone shrink acknowledgment processed cause covered backbone shrink since finite number messages channel front acknowledgment processed eventually either acknowledgment reach head channel covered backbone shrink another way arrival mobile unit covered backbone node covered backbone shrinks zero length announcement copies backbone nodes accomplishing backbone cleanup 433 tail cleanup addition backbone cleanup must also ensure announcement copies backbone eventually deleted precisely node tail eventually cleared put backbone c clearn indicates ns parent child pointers null shown imply announcement longer stored since node accept announcement parent implies nodes nonnull parent pointers could announcement copies since node clear pointers time clears storage way node root copy announcement nonnull pointers cannot guarantee mobile unit eventually arrive node thereby adding node backbone must prove delete message eventually arrive node remains tail show every tail delete message channel heading toward first node tail i3 first node tail defined node whose parent pointer points toward node point toward child delete message eventually processed shrinking length tail c1 tail contains node tail guaranteed cleared c2 tail n 7 clearn show tail shrink must guarantee existence delete message end tail assuming invariant statement execution showing holds statement execution ffl mobilearrivesa b mobile unit arrives backbone node one zero tails created tails created invariant trivially holds tail created consists nodes removed backbone nodes definition point toward one another parent child making tail affected new tail definition first node first node new tail node formerly pointed child node mobile unit currently delete put onto channel establishing invariant mobile unit arrives node backbone tail new tails created deletes sent old tails affected mobile unit arrives tail node tail cut two segments around mobile unit nodes mobile unit affected first node tail still delete affected nodes mobile unit similar first case delete generated old child pointer establishes invariant ffl deletearrivesa b delete arrives node link parent delete could critical tail therefore dropping effect invariant delete arrives first node tail along parent link delete propagated new first node tail node removed tail ffl announcementarrivesa b sendmobilea b ackarrivesa b announcementstart affect invariant invariant clear delete processed node removed tail tail shrinks property c1 delete head channel messages ahead must processed neither acknowledgment announcement affect progress mobile unit arrives node added backbone satisfying progress condition finally formally define clear d7 show node clear announcement copies i31 invariant easily shown every statement intuitively node sets parent child pointers null deletearrivesa b announcement copies node deleted since possible set child parent pointers null way announcement accepted nonnull parent link cannot announcement node null pointers therefore node either clear put back backbone announcement copy tails shrink guaranteed announcements backbone removed system described two algorithms guarantee delivery announcement mobile unit assumptions regarding speed movement section compare approach tracking based delivery schemes designed mobile environment including mobile ip scheme sony another sanders et al finally multicast scheme badrinath et al algorithms uses notion home node toward announcement initially sent mobile ip 6 home node tracks closely possible current location mobile unit data sent home directly location information updated time mobile unit moves introducing discrepancy actual location stored location movement data sent mobile unit update dropped mobile ip mechanism recover data rather assumes higher layer protocols tcp handle buffering retransmitting lost data one proposal within mobile ip allow previous location mobile unit cache new location forward data rather dropping reduce number dropped announcements still guarantee delivery mobile unit continue move always one step ahead forwarded announcement one proposal increase amount correct location information system distributing information multiple routers tree backbone maintenance algorithms sony 5 approach keeps home node date possible also makes system routers active components caching mobile unit locations packet forwarded router uses information determine next hop packet movement updating routing information routers closer mobile unit date information fewer packets lost mobile ip approach approach still provide delivery guarantees details given concerning updates router caches one benefit announcements need sent way home node forwarded toward mobile unit instead intermediate router caching location mobile unit reroute packet toward mobile unit sanders approach 8 advantage allowing intermediate routers forward announcement sanders describes precisely intermediate routers updated hop hop path kept home node last known location mobile unit mobile unit moves path shortened one node time common node shortest path old location shortest path new location reached path extended one node time announcements encountering hop hop path forwarded toward last node path updating path announcements move update message changing path eventually reach next known location mobile unit however mobile unit may moved update case data messages continue travel next update message although messages dropped slow update time ability mobile unit keep moving could prevent delivery approaches single copy announcement kept system approach stores multiple copies throughout system delivery complete believe sacrificing storage limited times algorithms require worthwhile provide guaranteed delivery announcement weaken requirements approaches modified reduce storage first algorithm announcement sent spanning tree wave announcement arrives node mobile unit present delivered otherwise sent outgoing spanning tree channels although multiple copies generated stored simply passed next hop announcement reaches leaf node dropped mobile unit remains region graph announcement propagation receive message however transit moves region message propagation announcement delivered second approach single announcement copy sent backbone path even announcement ends tail continue toward mobile unit path define mobile unit based movement pattern rather shortest path sanders algorithm one pathological movement pattern figure eight crossing backbone mobile unit continue avoid delivery another approach keeps multiple announcement copies badrinaths guaranteed multicast algorithm 1 stores announcement copies system nodes mobile units multicast group received announcement information gathered announcement initiator nodes actually delivered announcement disadvantage algorithm recipients must known advance property always known multicast first algorithm trivially extended track movement multiple mobile units based actual movement mobile units reduce number nodes involved multicast delivery respect badrinath approach 6 conclusions primary contribution work introduction new approach study mobility one based model whose mechanics borrowed directly established literature distributed computing treating mobile units messages provides effective means transferring results classical distributed algorithm literature emerging field mobile computing secondary contribution development two algorithms message delivery mobile units first direct derivative diffusing computations distributed algorithm second optimizing refinement first based careful study problem solution algorithm applicable variety settings mobile computing components used reliable communication essential r ip multicast extensions mobile internetworking flush primitives asynchronous distributed systems termination detection diffusing computations distributed snapshot algorithm adapted message delivery mobile units comparing four ip based mobile host protocols ip mobility support border gateway protocol 4 bgp4 derivation algorithm location management mobile communication devices routing communication networks tr flush primitives asynchronous distributed systems comparing four ip based mobile host protocols routing communications networks framework delivering multicast message networks mobile hosts understanding code mobility reliable communication highly mobile agents
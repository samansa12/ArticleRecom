embedding complete binary trees butterfly networks authors present embeddings complete binary trees butterfly networks without wraparound connections let even integer qmlog m1 authors show embed 2sup q11node complete binary tree tq m12sup m1node wraparound butterfly bsub wm1 dilation 4 embed tq m22sup m2node wraparound butterfly bsub wm2 optimal dilation 2 also present embedding wraparound butterfly bsub wm m12sup mnode nowraparound butterfly bm dilation 3 using embedding shown tq embedded nowrap butterfly bm1 resp bm2 dilation 8 resp 5 b introduction important issue parallel processing 2 3 4 5 6 7 8 10 12 paper study relationship complete binary tree network butterfly network b present embeddings b let q 2 q1 gamma 1node complete binary tree even integer let bw resp bm m2 node resp butterfly resp without wraparound connections 4 bhatt et al showed embed q bw m3 dilation 4 embedding constant expansion uses butterfly 8 times 1 many nodes necessary paper first present two improved embeddings q one embeds q bw dilation 4 another one embeds q optimal dilation 2 two embeddings one presented 4 use wraparound connections butterfly heavily show butterfly wraparound connections constant factor powerful one without wraparound connections precisely show embed bw wraparound butterfly network bm dilation 3 using embedding able embed q bm 1 dilation 8 bm 2 dilation 5 next give definitions notation used throughout paper embedding f g b defined bijective mapping f nodes nodes b together mapping g maps every edge onto path ge connecting fv fw refer f assignment two commonly extensively studied cost measures embedding dilation expansion 1 4 9 11 dilation defined maximum distance b two adjacent nodes expansion defined ratio number nodes b number nodes let q complete binary tree 2 q numbered 0 1 q let bw butterfly network 1 simplicity omit lower order terms wraparound connections consisting levels numbered 0 level 2 nodes every node bw identified l indicates level node resides fi 0 fi 1 fi mgamma1 pwl posi tion within level string 1 nodes bw connected follows node connected straight edge node l cross edge node l l fi nodes level connected nodes level 0 representing wraparound edges let bm butterfly wraparound connections difference bm bw bm contains additional level level wraparound edges level level 0 bw replaced edges level gamma 1 level section 2 describe embedding tree q butterfly bw 1 dilation 4 embedding achieves dilation one 4 expansion 2 versus expansion 8 note straight forward modify embedding 4 uses bw m2 instead bw m3 section 3 contains embedding q bw m2 dilation 2 respect dilation embedding optimal since embedding o1 expansion achieve dilation less 2 4 section 4 shows embed bw bm dilation 3 use result obtain embeddings q butterflies wraparound connections embeddings sections 2 3 use general approach described 4 precisely also use notion signatory 1 serial number pwl strings concepts ensure two nodes q assigned node butterfly embeddings well embedding presented 4 crucial point nodes level q assigned different levels butterfly achieved 4 embedding described section 2 subtrees grow upwards downwards butterfly varying number levels results dilation 4 embedding described section 3 uses different technique achieve assigning nodes level tree different levels butterfly thus achieves dilation 2 embedding q b w section describe embed q bw dilation 4 embedding viewed finetuning strategy used 4 embedding presented 4 tree q embedded three stages first stage embeds levels 0 log second stage embeds levels log mlog third stage embeds remaining levels q order avoid collisions among embeddings three stages stage simply embedded different copy bw embedding uses bit positions way different stages embedding share subbutterfly networks much possible left half bw m1 b 2 right half bw m1 shown figure 2 clarity reasons henceforth refer nodes q pes processing elements nodes butterfly nodes embed q bw 1 four stages stage 1 embeds first log levels q dilation 2 pes level log assigned nodes level uses oddnumbered levels k th tree rooted pe level log embeds first dilation 4 pe level 0 k remains assigned node stage 1 pes level m2 k assigned nodes level b 2 stage 2 uses oddnumbered levels b 1 addition even level even level b 2 last m2 levels k embedded two stages stage 3 assign next k levels k dilation 4 pes level m2 assigned nodes level 3 uses oddnumbered levels b 2 stage 4 assigns remaining k dilation 2 stage 4 uses evennumbered levels b 1 b 2 use levels summarized table 1 embedding assigns two pes node bw 1 two adjacent pes distance 4 apart levels used b 1 levels used b 2 stage 2 oddnumbered level level stage 3 oddnumbered stage 4 evennumbered evennumbered table 1 use levels four stages description embedding given next assume power two result holds however even describe necessary changes end section 2 unarystraight branching branching node level l node level using straight edge unarycross branching branching node level l node level l using cross edge finally binary branching branching node level l two nodes level l using straight cross edge stage 1 embedding first log levels q assign root q node use unarystraight binary branching assign two pes level 1 q two nodes note binary branching generates pwl string unarystraight branching keeps 0 1 continuing fashion assign 2 pes level q nodes thus m2 pes level log assigned nodes figure 2 show first steps embedding stage easy see two pes assigned node ie collisions occurrences x ff 0 occurrence x ff 0 3 denotes wild card character indicating 0 1 stage 2 embedding levels log m2 already defined k k th tree rooted pe level log assigns pes levels 1 m2 pes levels 1 assigned oddnumbered levels b 1 pes levels m2 gamma 1 m2 assigned evennumbered levels treated differently order keep dilation 4 embedding level m2 goal stage 2 assign pes level m2 k nodes lambda0 1 position pwl strings called signatory 1 4 purpose keep nodes pes k assigned different nodes pes leftmost rightmost pwl string head resp tail pwl string consider node get pe assigned stage 1 head consists alternating 0s 1s tail consists alternating 0s additional 0 rightmost position trees k positioned head pwl string observe position signatory 1 already contains 1 trees k positioned tail pwl strings beginning stage 2 position contains 0 first describe embedding signatory 1 positioned head stage 1 assigned root k node using two unarystraight branchings binary branching assign two pes level 1 k two nodes results dilation 3 pes level 0 level 1 k assign 2 l pes level l k 2 l nodes level 2l gamma 1 b 1 using unary cross binary branching exception occurs pes level k order keep signatory 1 use unarystraight instead 4 string k string k k k denotes binary representation k k r th position left k k k k position 2r k 0 k 0 k 0 2 level k nodes bw l l table 2 assignments stage 2 section 2 k log unarycross branching figure 3 shows first steps handled bits head pwl string use unarystraight keeps 0s binary branchings assign levels placed pes level nodes level change strategy remaining two levels follows unarystraight binary unarystraight branching assigns pes level m2 gamma 1 nodes level finally binary unarystraight unarycross level 0 b 2 unarystraight branching level assigns pes level m2 k nodes level strategy results dilation 2 levels l l dilation table 2 shows assignment pes k k log gamma 1 first line table states position root second line covers levels point position signatory 1 encountered line 3 covers remaining position head line 4 covers tail excluding last two levels handled differently given lines 5 6 obviously lines meaningful situations corresponds last position head line 3 thus meaningless lines 2 3 4 meaningless case pes level 1 1 4 assigned nodes level 2 using line 5 pes level 2 assigned nodes level 4 using line 6 branchings done somewhat different dilation 4 next consider case signatory 1 positioned tail overall strategy table 3 shows assignments ones briefly discuss table 3 line 1 states position root line 2 covers assignments pes bits head pwl string changed line 3 covers tail positions 0 changed signatory 1 line 4 covers remaining assignments including level b 1 assignments last two levels stated lines 5 6 lines meaningful line 3 covers levels level line 4 meaningless since bits set two final levels line 3 covers levels level 2 table 4 shows assignments tree order consistent tables 2 3 show 0 table 4 however every 0 corresponds 0 situation tree 0 similar situation described tree 1 4 whose assignments given table 2 pes level 1 0 4 assigned nodes level 2 using line 4 table 4 pes level 2 0 4 assigned nodes level 4 using line 5 next show collisions within stage 2 obviously node gets two pes assigned must come different k ms let x k x j two pes k j respectively assigned nodes level r let k j pwl strings nodes respectively show k 6 loss generality j k consider two cases depending value k case 1 k log case 11 1 pwl strings k j differ tail pwl string k k rightmost 2 log rightmost 2 log case 12 differ signatory 1 pwl string k 1 position pwl string j 0 position case 2 case 21 case similar case 11 level k nodes bw l l table 3 assignments stage 2 section 2 level 0 nodes bw l l table 4 assignments stage 2 section 2 case 22 1 pwl strings k j log differ least one rightmost blog kc bits case 23 pwl string k 1 position position pwl string j 0 complete discussion stage 2 showing collisions stage 1 stage 2 cannot collisions since 0 4 1 4 use evennumbered levels stage 2 hence assume r level b 1 pes assigned stage 1 stage 2 since stage 1 places root level largest oddnumbered level used stage 2 pwl string node containing pe stage 1 starts 0101 ie contains 1 position 1 3 node assigned pe stage 2 starts either lambda0 0 lambda0 1 lambda1 0 thus cannot collisions stage 1 stage 2 occur level 3 case stage 2 handles four trees namely trees 0 8 pwl strings nodes level 3 get pes k 8 k 2 assigned stage 2 form lambda0 1 k 0 k 00 hence cannot collisions pwl strings nodes level 3 get pes 3 8 assigned stage 2 form lambda1 1 3 0 3 00 3 assigns one pe namely root q level 3 assigned node pwl string 010100000 hence collision possible completes description stage 2 embedded levels 1 m2 k embedding last m2 levels k similar stage 3 4 however purpose divide embedding last m2 levels k two stages namely stages 3 4 embed levels m2 k respectively division shows precisely use right half full bw 1 stages 3 4 respectively stage 3 embedding levels m2 th subtree height rooted pe level m2 k shown figure 4 subtrees 0 consists one pe pes already assigned stage 2 hence stage 3 embeds ks k 1 stage 2 root k assigned node 4 refer positions fi 0 fi 2 fi serial number k embed k stage 3 serial number signatory 1 remain fixed serial number helps keep subtrees k 0 helps keep k embed first dk2e levels k growing upwards ie towards lower numbered levels b 2 right half bw b 2 embed remaining levels k leaves k placed nodes upwards downwards use every fourth level b 2 hence embedding incurs dilation 4 precise process embedding k described next assign pes level l k nodes level root k assigned stage 2 node using binary two unarystraight branchings assign 2 pes level 1 k two nodes successively use unarystraight binary two unary straight branchings assign 2 l pes level l k l 2 nodes k odd assign 2 dk2e pes level dk2e k using unarystraight binary branching nodes exception occurs 1 leaves 1 level 1 1 assigned level making binary branching node level 5 denotes 0 1 depending binary representation grow k downwards assign 2 l pes level l nodes dilation root k two pes level 1 3 1 1 dilation remaining levels k 4 exception occurs levels bk2c dk2e k odd levels bk2c bk2c even cases dilation 2 since signatory 1 changed stage 3 argument similar one stage 2 combined observation serial number kept fixed stage 3 shows collisions within stage 3 stage 3 uses oddnumbered levels b 2 since stages 1 2 use oddnumbered levels b 1 even level level collisions among stages 3 completes description stage 3 describing stage 4 briefly explain last two levels k embedded stage 2 ie levels m2 gamma 1 m2 handled differently levels stage 2 places pes level 3 places pes level m2 order keep dilation 4 pes level placed level pes level m2 placed level b 2 resulting different strategy last two levels k stage 2 addition placing pes level allows us set signatory 1 correctly 0 stage 4 embedding levels m2 subtree k rooted root k height m2 let r k forest formed k shown figure 4 stage 4 embeds trees r k dilation 2 using even levels b 1 b 2 every tree r k m2 gamma k levels need embedded recall roots trees ie leaves k assigned k 1 stage 3 nodes stage 2 nodes make necessary branchings need positions pwl strings stage 4 uses positions containing 0 left signatory 1 rightmost position 1 start stage 4 assigns pes first level tree r k nodes 0 done unarystraight binary branching k 1 simply binary branching trees r 0 successively use unarystraight binary branching embed remaining levels r k thus pes level l r k assigned nodes since serial number signatory 1 remain fixed stage easy see collisions within stage 4 stage 4 uses evennumbered levels since stages 1 3 use oddnumbered levels collisions stage 4 stages 1 3 see table 1 note level used stage 2 b 2 stage 4 use level hence possible collisions stage 2 stage 4 occur level stage 4 leaves 0 assigned level thus pwl strings nodes pes assigned level strings nodes level pes assigned stage 2 lambda0 position 0 stage 2 position 1 stage 4 collision possible completes stage 4 hence embedding q bw 1 conclude section showing modify embedding even power 2 recall stage 1 embed first blog mc levels q assigning root q node embedded every occurrence log replaced blog mc stage 1 dont m2 pes embedded level three stages embed remaining levels q stage 2 embeds next m2 levels levels blog mc m2 embed final m2 levels q since trees k rooted pes level blog mc gamma 1 q range k 0 2 blog reflecting change throughout stages 2 3 4 using blog mc instead log obtain desired embedding q bw 1 argument correctness carries straightforward way proof collisions different stages must consider interaction stage 1 stage 2 case however case stage 1 uses levels 3 5 whereas stage 2 uses levels 1 4 6 collisions occur embedding q b w section 2 described embed q bw dilation 4 naturally question arises whether exists embedding achieves smaller dilation yet know embed q bw 1 dilation less 4 next show embed q bw 2 dilation 2 embedding achieves optimal dilation since embedding o1 expansion achieve dilation less 2 4 purposes description assume power two results hold however even integer necessary changes described end section 3 th quarter bw shown figure 5 embed q bw 2 three stages stage 1 use embed first log levels q pes level log assigned nodes level 1 k th tree rooted pe level log embeds levels 1 m2 pes level m2 assigned nodes either level stage 3 embed remaining levels k b 3 main difference embedding one described previous section stage 2 previous embedding one 4 achieve assigning pes level q different levels butterfly growing subtrees upwards downwards varying number levels embedding section achieves effect different subtrees grow different number levels already stage 2 right signatory 1 placed avoiding upwards downwards growth together modifications allows us reduce dilation 4 2 describe stage embedding section detail stage 1 embedding first log levels q stage could use embedding stage 1 given section 2 however since using bw instead bw 1 use simpler embedding similar one 4 allows us simplify remaining stages use version stage 1 embedding section 2 since would result collisions stages 1 2 sake clarity completeness describe stage 1 detail assign root q node using binary branchings assign done 4 2 l pes level l q nodes 2 finally using binary unarycross branching assign m2 pes level log nodes figure 5 show steps embedding stage observe stage use b 1 level 1 dilation levels l l log straightforward see collisions stage stage 2 embedding levels 1 m2 done section 2 partition pwl string head tail head consists leftmost bits tail consists rightmost log pwl string section 2 head even tail odd length either even odd reason using ds following description observe node pe assigned stage 1 head consisting 0s tail consisting lambdas 10 two rightmost positions goal stage assign dilation 2 pes level m2 k pes level m2 0 nodes tree k k 1 pwl strings get signatory l l table 5 assignments stage 2 section 3 k log mgamma1e set position set first describe embedding signatory 1 placed head ie k log stage 1 assigned root k node assign 2 l pes level l k nodes level 2l gamma 1 using unarystraight binary branching place signatory 1 making unarycross branching use binary branching assign pes level nodes level signatory 1 placed use binary branchings assign pes level l k nodes level shows precise assignment k k log mgamma1e first line table shows assignment root second line covers assignments point position signatory 1 encountered third line covers remaining positions head fourth line covers tail section 2 lines meaningful situations e line 3 meaningless case signatory 1 corresponds rightmost position head case log odd second rightmost position case log even embedding case signatory 1 positioned tail similar order place 0s oddnumbered positions placement signatory 1 make unarycross unarystraight branching depending value show assignments log mgamma1e table 6 assignments tree shown table 7 0 stop level assigning leaves 0 nodes already stated signatory 1 set l table assignments stage 2 section 3 e level 0 nodes bw log l b mgammalog m1 table 7 assignments stage 2 section 3 0 position signatory 1 0 would position pwl strings setting 1 would require use unarycross edges level thus place pes level m2 0 level would result dilation 3 since pes level assigned level signatory 1 set 0 requires stage 3 handle 0 somewhat differently easy see dilation 2 stage 2 argument show collisions within stage similar one given stage 2 section 2 omitted stage 1 uses b 1 level level hence collisions stage 1 stage 2 stage 3 embedding levels m2 stage similar stage 4 section 2 however since pes level m2 0 assigned nodes level differently let r th subtree rooted pe level m2 k first describe embedding last m2 levels 0 ie embedding r m2 describe embeddings r recall stage 2 assigned root r m2 node using binary branching next assign two pes level 1 two nodes assign pes level 2 using binary unarycross branching ie pes level 2 placed level 0 b 3 b 4 use unarystraight binary branching successively assign remaining levels r m2 general l pes level l r m2 assigned nodes 3 l m2 leaves r m2 thus assigned level stage 2 assigned root r assign pes level 1 r using binary unarycross branching use unarystraight binary branching assign 2 l pes level l r leaves r thus assigned level 2 show collisions within stage 3 since serial number denoted pwl strings kept fixed collisions changed stage 3 hence collisions r 1 signatory 1 position also avoids possibility collision r m2 r seen follows assume level pes r m2 r assigned node containing pe r signatory 1 position pwl string leaves r placed level 2 node containing pe r m2 starts 0 position changed 1 binary branching going level level never changed hence cannot exist node assigned pe r m2 r finally easy see collisions stages 1 2 stage 3 stages 1 2 use also uses level b 2 stage 3 however signatory 1s keep nodes level pes k assigned stage 2 k 1 distinct nodes pes 0 assigned stage 3 completes stage 3 hence second embedding conclude section showing modify embedding section even integer power two stage 1 embed pes levels 0 blog mc gamma 2 q nodes levels pes level blog assigned nodes level every occurrence log replaced blog mc stage 1 2 blog mgamma1c pes embedded level 1 b 2 hence 2 blog mgamma1c trees k ms range k 0 reflecting change throughout stages 2 3 using blog mc instead log obtain desired embedding q bw 4 embeddings using wraparound previous two sections described two embeddings complete binary trees butterflies wraparound connections embeddings make heavy use wraparound connections section first show wraparound connections convenient make butterfly powerful asymptotic sense precisely next describe embedding bw bm dilation 3 best knowledge useful result documented literature making use result show q embedded dilation 8 resp 5 clarity henceforth refer nodes bw pes nodes bm nodes embedding bw bm achieves expansion m12 2 optimal since bm smallest butterfly wraparound consisting least m2 nodes embedding bw bm must achieve dilation least 2 show assume sake contradiction exists embedding ae dilation 1 ae every node bm assigned one pe bw furthermore edge bm assigned edge bw since number nodes bm greater number pes bw exists node v bm pe bw assigned edge incident v edge bw assigned otherwise dilation would 1 since v least 2 incident edges m2 edges bm edges bw assigned ae since bw consists m2 m1 edges every edge bm assigned 1 edge bw ae dilation 1 assign pes level 0 bw nodes level 0 bm remaining pes assigned two pes adjacent levels bw 2 levels apart bm pes level assigned nodes level 3 furthermore nodes level 1 bm get pe assigned formally let p pe assigned node fl ff 0 ff 1 ff example string fi 0 fi 1 fi 2 fi 3 fi 4 fi 5 fi 6 fi 7 assigned node pwl string ff levels 0 1 2 3 4 assigned nodes levels 0 2 4 6 8 respectively pes levels 5 6 7 assigned nodes levels 7 5 3 respectively easy see two pes assigned node hence embedding bw bm next show dilation 3 assume even integer argument odd ms analogous let p cross edge bw l fi 1 depending value l distinguish four cases case 1 assigned nodes v 1 2l fi 0 fi connected v 2 path consisting cross straight edge resulting dilation 2 case 2 assigned node v 1 fi 0 fi assigned node v connected cross edge dilation p 1 p 2 1 case 3 2 assigned node v 1 pe p 2 assigned node v 2 l fi hence v 1 v 2 connected path consists straight cross edge dilation 2 case 4 assigned node v 1 3 fi 0 fi assigned node v 2 0 fi 0 connected v 2 path consisting straight cross straight edge hence dilation p 1 p 2 3 embedding wraparound edges ones dilation 3 level l bw chosen edges level l l dilation 3 completes embedding bw bm dilation 3 next briefly describe embedding q wraparound butterfly first embedding q bw dilation 4 using embedding section 2 embedding bw dilation 3 immediately follows q embedded dilation 4 similarly q embedded dilation 2 however since wraparound edges incur dilation 3 remaining edges incur dilation 2 better every edge q maps onto path length 4 bw 1 every path contains one wraparound edge hence dilation every edge q 3 similar arguments used embed q bm 2 dilation 5 order obtain claimed dilation 8 embedding q bm 1 change embedding bw edges level 1 2 bw 1 dilation 3 bm 1 remaining edges dilation 2 edges q using edge level 1 2 bw 1 dilation 2 thus dilation 3 dilation 4 bw 1 incur dilation 4 conclusions paper described two embeddings complete binary tree wraparound butterfly bw two embeddings wraparound butterfly b first embedding embeds q bw dilation 4 1 second one embeds q bw 2 dilation 2 first embedding achieves expansion 2 second one achieves expansion 4 optimal dilation embedding optimizing dilation expansion would embed q bw dilation 2 even 4 feel technique different one using signatory 1s needed achieve bound third resp fourth embedding embeds q bm dilation 8 resp 5 6 acknowledgements would like thank anonymous referee helpful suggestions comments r embedding rectangular grids square grids multidimensional arrays processors embedding grids hypercubes optimal simulations butterfly networks optimal simulations tree machines embedding rectangular grids hypercubes quotient networks embedding large tree machines small ones cost tradeoffs graph embeddings optimal simulations mesh connected array processors preserving proximity arrays topological properties hypercubes tr optimal simulations meshconnected arrays processors topological properties hypercubes embedding rectangular grids hypercubes multidimensional arrays processors optimal simulations butterfly networks embedding large tree machines small ones cost tradeoffs graph embeddings applications embedding grids hypercubes ctr xiaojun shen weifa liang qing hu embedding 2d meshes size ieee transactions computers v46 n8 p880889 august 1997
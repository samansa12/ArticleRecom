scalable session locking distributed file system file systems provide interface applications obtain exclusive access files process holds privileges file cannot preempted restrict capabilities processes local file systems maintaining information privileges current file sessions checking subsequent sessions compatibility implementing exclusive access manner distributed file systems degrades performance requiring every new file session registered lock server maintains global session state present two techniques improving performance session management distributed environment introduce distributed lock managing file access called isemipreemptible lock allows clients cache privileges semipreemptible lock file system creates new sessions without messages lock manager improves performance exploiting locality affinity files clients also present data structures algorithms idynamic evaluation locks allow distributed file system efficiently manage arbitrarily complex locking case complex means object locked large number unique modes combination techniques results distributed locking scheme supports finegrained concurrency control low memory message overhead assurance locking system correct avoids unnecessary deadlocks b introduction distributed file systems become principal method sharing data distributed applications programmers understand file system semantics well use easily gain access shared data exactly reason distributed file systems easy use difficult implement distributed file system takes responsibility providing synchronized access consistent views shared data shielding application programmer tasks moving complexity file system distributed clientserver file system presents local file system interface remote shared data file system client takes responsibility implementing semantics local file system translating local interface onto clientserver network protocol heterogeneous distributed file systems many client operating systems system may translating semantics several different local file systems onto single network protocol work present locking construct called file session locks implement sessions files defined open close calls application file sessions enforce concurrency constraints eg one client opens file exclusive writing permitting concurrent readers opens read clients must forbidden locks designed provide data consistency cache coherency suitable cache coherency protocol required addition file session locking instead locks allow clients choose among many exclusive access sharing options available native file system interface semantics local open enforced throughout distributed system help encode enforce sessions distributed environment contribute semipreemptible lock allows file system client cache session privileges client holding semipreemptible lock file right access file modes specified held lock clients maintain file open session state locally need transact file system server opening closing file clients may continue hold lock even open instances way client cache access privileges right open file service subsequent open requests without message server mechanism reduces server traffic eliminating open close messages consequently reduces latency avoiding message round trip time clients cache access privileges file belief file used locally used another client semipreemptible locks also reduce distributed lock state clients often hold multiple open instances single file concurrently clients locally create concrete locks session held context distributed lock open instances granted single semipreemptible lock rather holding separate lock every open single semipreemptible lock summarizes clients open state distributed system semipreemptible locks combine two concepts lock management first clients manage locks hierarchically separate session state lock state second clients use semipreemptibility also called lazyrevocation sticky locks 24 retain privileges files absence active sessions use term hierarchical differently locking literature generally term hierarchical describes locks held concurrently different levels abstraction data object achieve granular locking 12 27 instead use term describe two levels locking higher level abstract summarizing client lock state server lower level concrete representing sessions interface open file create session many options allow application specify intended actions restrict concurrent actions clients express options locks data generally multiple locking modes unique semantics number different possible locking modes increases exponentially number access methods locking complex data object using existing methods quickly becomes unmanageable take windowsnt interface example establish point file system takes six binary arguments opening file requires 64 unique locking modes describe sessions considering locking modes pairwise compatibility 4096 combinations locks compatible held concurrently furthermore large number modes interface fully specify possible access modes example address concurrent exclusive access file system metadata existing methods lock management fall short either fail scale well number locking modes become large ad hoc systems poorly specified database systems employ static data structure called lock compatibility table 12 describes relationships locking modes pairwise data structure fully specifies interactions locking modes grows quadratically size respect number locking modes alternatively modern file systems use ad hoc rulebased methods evaluate locks efficient compact 16 however without formally specified semantics interactions locking modes difficult reason implement correctly present formal specification locking modes derive data structure algorithms management distributed locks called dynamic evaluation methods advantage scaling well number locking modes addition specify fully interactions among locking modes eases implementation correct locking protocol system obviates need static data structures lock compatibility tables used database systems require memory respect number legal locking modes system lock compatibility evaluated algorithmically based small static lock structures require memory olog n distributed file system provides good example complex locking system feel dynamic lock evaluation wide applicability distributed systems 2 storage area network file system brief digression file system architecture implement file session locking helps motivate performance advantages storage tank project ibm research building distributed file system storage area network san figure 1 san high speed network storage area network control network tape server server server client client client server cluster figure 1 schematic storage tank distributed file system storage area network san gives computers shared access storage devices currently sans constructed fibre channel networks 4 future expect network attached storage devices available general purpose data networks sans constructed networks gigabit ethernet 9 distributed file system built san removes server bottleneck io requests giving clients direct data path disks file system clients san access data directly storage area network contrast traditional clientserver file systems 26 14 16 7 store data servers private disks clients function ship data requests server performs io behalf unlike traditional file systems storage tank clients perform io directly shared storage devices direct data access model similar file system network attached secure disks nasd 11 using shared disks ip network global file system 21 san attached storage devices clients communicate storage tank servers general purpose network obtain file metadata addition serving file system metadata servers manage cache coherency protocols authentication allocation file data managing data placement free space unlike file systems metadata data stored separately metadata including location blocks file shared storage kept server san storage devices contain blocks data files way shared devices san optimized data traffic block transfer data server private storage optimized metadata workload frequent small reads writes san environment simplifies distributed file system server removing data tasks radically changes servers performance characteristics previously server performance measured data rate performance occasionally limited network bandwidth often limited servers ability read data storage write network san environment servers performance properly measured transactions per second analogous database server without data read write storage tank server performs many transactions traditional file server equal processing power without relatively slow process shipping data client server hide protocol head minimizing message traffic file system operations becomes important protocol overhead network server resources added latency used clientserver messages traditional clientserver file systems clients go server obtain data shipping data client takes significantly longer uses many resources single server message overhead associated messages opening closing file hidden cost shipping data storage tank protocol overhead limits performance semipreemptible lock allows client open file without contacting server message avoided time saved critical path 3 semipreemptible file locks distributed files systems little data sharing occurs practice 2 17 data sharing indicates two clients concurrently accessing file additionally clients often access data recently used claims supported effectiveness data caching environment 19 15 mature distributed file systems 14 7 24 16 1 13 19 23 take advantage observation cache file data clients even process actively uses data design decision cache file data file closed improves performance subsequent open system likely request another client access data subsequent accesses caching improves performance avoiding server message data read disk however another client attempts access data sees additional latency file system server invalidates cache client holds data granting access new client reasons caching improves performance data access semipreemptible lock improves performance file open local process requests open file lock held client obtains semipreemptible lock granting open local process closes file client records open file instances currently using lock holds onto lock awaiting future opens file analogous data caching holding access locks past close decreases latency avoiding server message subsequent opens caching locks adds latency opens clients server must revoke lock granting access client server client client b open instance locks held open files client semipreemptible demand messages open state clients client b figure 2 demands semipreemptible lock accepted denied depending upon client file system open state recording open instances associated access lock client differentiates locks held protect open files therefore cannot released locks held improve performance subsequent opens consider second client wishes obtain exclusive access file already locked first client server processes second clients request demanding 1 lock first client sending message requests release held lock first client holds open instance file requires held lock protect instance denies demand requests server figure 2 however process holds open instance client longer utilizes held lock releases safely access locks called semipreemptible server must demand preemptible locks however client refuse demand request semipreemptible locking system particularly appropriate sanbased distributed file sys tem data obtained server lock held client directly access data shared storage need interact server without direct access storage clients must interact servers data file systems cannot save message semipreemptible locking use term demand consistency existing terminology despite fact clients refuse demand term like request would appropriately describe servers action request often used describe clients process acquiring locks server managing complexity lock management includes locking protocol lock evaluation protocol describes locks obtained released system use semipreemptible protocol lock evaluation enforcement semantics locks semantics encoded lock mode file session locks mode defines actions allowed lock actions restricted concurrent sessions file system large number possible locking modes describing possible combinations actions restrictions evaluation locks becomes difficult number locking modes grows large techniques reduce number locking modes explored alternative implementing full complement possible modes although techniques reduce complexity negatively affect concurrency reduce performance storage tank implement possible locking modes greatest degree concurrency application correctness however describe techniques comparison 41 implementing subsets implementing chosen subset possible locking modes systems trade reduced complexity minor semantic violations file systems often select set distributed locks file access simpler semantics underlying file open system call 7 15 mismatch open semantics locking results either concurrent opens allowed violate open semantics concurrent opens disallowed open semantics would permit file systems opt disallow legal opens policy impinges concurrency rather correctness extreme example subset protect object single exclusive lock lock easy reason implement manage one client holds time gives client total control locked object however lock allows concurrent action clients sessions would mean one open instance file time single exclusive locks operate reasonably data consistency protocol locks preempted however nonpreemptible locks concurrency restrictions intolerable 42 multiple simple locks breaking single complex lock multiple locks simpler semantics another technique reducing complexity strategy desirable individual lock modes therefore easy manage introduces either deadlock livelock ultimately limits performance problems arise locks truly independent applications require multiple locks held concurrently operation application semantics tie seemingly independent locks together complex set locking modes single lock implemented multiple locks simple semantics obtained individually example lock protects data file writing data updating metadata broken two separate locks one writing one metadata update however locks cannot obtained atomically example clients need obtain multiple preemptible locks conduct operation experience livelock guarantee ever make progress consider two clients trying obtain set locks clients hold locks currently request remaining locks client obtains locks locks revoked neither client ever guarantee get full complement locks needed continue increases number clients resource contention number locking modes exacerbate livelock techniques eliminate livelock introduce deadlock eliminate livelock clients need multiple locks deny ignore revocation currently held locks awaiting locks requires two clients livelock example requesting set locks would impasse ignored revocation neither client releases locks holds neither client obtains locks needs deadlock generally handled either avoidance detection 12 regardless chosen technique dealing deadlock always incurs performance penalty protecting accesses using single lock complex semantics rather multiple individual locks avoids deadlock livelock associated inefficiencies rather needing obtain multiple locks applications atomically obtain single lock request evaluated immediately server granted denied application lock state always progress 5 compatibility tables comparison system dynamic evaluation present compatibility table developed manage distributed concurrency databases 12 key criticism structure scale well number locking modes becomes large fair databases number locking modes tends small contrast file systems static data structures adequate compatibility table determines whether incoming lock requests granted conjunction currently outstanding locks system defines set locks fills data structure defines symbol name description r read reader lock w write reader writer lock shared reader lock writers update writer lock writers exclusive readers writers held requested none r w u x table 1 locking modes compatibility table file system open mode locks locks managed opening file clients select locking mode best matches semantics open requests corresponding lock locking server server uses compatibility table evaluate whether incoming request serviced present example based locking modes compatibility table table 1 subset possible locks table consists rows index mode incoming lock request columns index locks currently held clients table cells hold plus indicate request compatible outstanding lock minus indicating requested held lock conflict example server receives request w write lock file outstanding locks r read shared evaluates locks follows first looks cell requested mode w held mode r sees lock modes compatible continues evaluate w seeing incompatible w lock cannot immediately granted given current lock state server demands lock grants w lock demand succeeds n locking modes compatibility table contains n 2 entries databases systems locks programming compatibility table presents problems however looked implementing structure possible locks distributed file system amount state daunting concerned correctness maintenance implementation 6 dynamic lock evaluation reduce memory used static locking data structures define simple algorithms evaluating compatibility lock requests algorithms require client server store number allowable access methods k need record every lock mode associated compatibility table algorithms support possible locking modes given set access modes unlike systems implement subset possible locks limit complexity algorithms use following quantities l set locking modes set valid access modes permitted access modes disallowed sharing modes lock x appropriately thought ordered pair hp x dx access modes permits access modes disallows permitted modes access methods lock holder perform disallowed modes access methods lock holder forbids clients performing concurrently permitted disallowed access modes vary possible subsets set thus containing k different access modes 2 2k different potential locks number distinct subsets equals 2 k develop algorithms evaluating lock state begin casting definition lock compatibility set theoretic terms definition create simple algorithms evaluating lock requests server processing local open requests server lock demands client lock compatibility evaluated dynamic fashion ie compatibility need precomputed stored tables definition 61 compatibility lock x compatible iff px two locks compatible forbid access modes lock protects compatibility must symmetric lock state distributed system dependence order locks acquired helps avoid nondeterministic behavior due race conditions illustration consider compatibility symmetric could two locks x x compatible vice versa two clients obtaining locks lock x obtained first another client could get lock hand obtained first x would unavailable final lock state would vary depending upon order lock requests arrive addition lock compatibility used evaluate lock requests clients require concepts lock strength weakness manage locks hierarchically determine lock transitions strength weakness used clients either upgrading held lock service local file open request downgrading lock response servers demand definition 62 strength lock x stronger lock iff p px definition 63 weakness lock x weaker iff stronger x stronger lock permits access methods restricts sharing compared weaker lock strength weakness definitions include identical locks ie two identical locks mutually stronger weaker although abstraction seems incongruous simplifies locking algorithms addressing boundary conditions following theorems help show definitions match intuition file access locking semantics identical compatibility strength weakness static locking data structures first lock hierarchy valid strength weakness relations transitive required conditions ordering theorem 61 x stronger stronger z implies x stronger z proof x stronger implies p px dx also stronger z implies observe p z px dz dx exactly condition x stronger z corollary 1 x weaker weaker z implies x weaker z lock strength closely related compatibility used help determine transitions among locking modes system next theorems express key concepts clients use summarize locks evaluate lock transitions theorem 62 x weaker locks compatible compatible x proof x weaker px p dx also lock z compatible implies px conclude x compatible z constrained z x compatible lock compatible corollary 2 x compatible locks stronger x also incompatible proof sake contradiction conjecture z stronger x compatible theorem 62 z compatible implies x compatible establishes contradiction z exist presented description locks defines semantics must implemented lock evaluation algorithms algorithms dynamic lock evaluation compare lock requests transitions definitions rather performing look preset data structure eliminates memory required store lock tables l1 l2 l3 l4 l3 l3 l2 l3 l4 l4 summary bitlocks bit 1 bit 2 bit 3 bit 4 bit 5 bit bit 7 bit 8 outstanding figure 3 lock management data structure 7 summarizing data structure lock evaluation addition formal definition lock semantics require data structures lock requester client lock granter server fully specify algorithms lock evaluation server task receiving incoming lock requests evaluating compatibility requests currently outstanding locks obvious implementations might elect data structure enumerates outstanding locks receiving new lock request server iterates existing locks comparing compatibility requested lock implementations based lock tables work exactly fashion performing table look compares requested lock currently outstanding lock define data structure allows algorithms evaluate lock compatibility directly without iteration fundamental concept data structure summarize sharing restrictions permitted access modes outstanding locks single location evaluate incoming lock requests summary data structure also allows server find locks need demanded directly without searching concept summarizing lock state similar general using strongest outstanding lock representative outstanding locks 12 however system makes provisions locks compatible yet strengthrelated occurs possible combinations access modes allowed lock summary data structure contains list outstanding locks addition summary indexes list locks figure 3 allows data structure evaluate new lock requests summary also permits contribution individual lock summary calculated removed lock released lock summary data structure use bit vector represent individual lock locking system k unique access modes bit vector contains 2k bits first k bits correspond set access modes lock permits next k bits indicate set access modes lock disallows example locking system metadata read metadata write read write access modes r bit vector h1011 0001i describes lock permits metadata read data read write disallowing clients holding write privilege punctuate bit vector colon indicate semantic differences first second k bits data structure contains list called outstanding list individual locks currently held clients list holds description lock 2k bits describing permitted access concurrently disallowed locking modes h indexed lock identifier l stands bit vector representation set p server picks lock identifiers incoming lock requests subsequent lock operations conducted lock identifier since clientserver lock operations conducted context lock identifier server always look entries list quickly possible maintain list ordered index locks looked name o1 engineering restrictions 2 often require unique nondecreasing lock identifiers lock identifiers maintained using extendible hashing 8 scalability fast look time olog n n outstanding locks data structure also contains summary outstanding locks lock summary consists union permitted access modes union disallowed concurrently held modes system locks l outstanding summary 1 data structure represent summary using bit vectors sets single lock set operations union intersection computed using logical operators bit vectors bitwise union bitwise intersection bit operators legally applied two vectors length operate pairwise bits vector producing result bit vector length implementation encodes two unions summary terms bit operations whose bit components expanded arrive equivalent logical expression maintaining union permitted disallowed lock modes times server implicitly evaluate compatibility incoming lock request locks evaluating request summary requested lock disallow access modes permitted recovery 3 benefit unique nondecreasing lock identifiers summary summary disallow permitted modes accesses ie intuition behind summary lock state system represented equivalent single lock constructed union permitted concurrently prohibited access modes addition summary outstanding lists require additional lists aid processing lock requests efficiently maintaining summary bit lock summary keep bitlocks structure contains list locks outstanding set bit high bitlocks list describes set locks contribute setting individual bit summary high algorithms lock management use list efficiently determine locks need revoked requested lock compatible current lock state lock outstanding also references pointers locations bitlocks lists lock appears lock released lock management algorithms use references quickly remove released lock bitlocks lists references actually point entry outstanding list actual entry bitlocks list head list diagram might indicate allows algorithm look entry bitlocks list unit time 71 correctness establish evaluating lock requests based summary equation 3 correct show summary expression derived logical simplification compatibility criteria requested lock compatible outstanding lock state granted compatible definition 61 outstanding locks system locks l outstanding requested lock must evaluated compatibility locks l transformation shows evaluation summary equivalent evaluation outstanding locks original motivation summarizing data structure first developed formalism locking presented section 6 upon seeing expression evaluating compatibility single requested lock set compatible outstanding locks determined simplified summarizing data structure lock evaluation merely captures logical simplification 8 algorithms lock management based dynamic lock evaluation semipreemptible protocol develop set algorithms managing distributed set locks algorithms based summarizing data structure logical rules lock evaluation also capture design goal eliminating lock state using hierarchical locking storage tanks semipreemptible protocol restrict clients lock holdings single distributed session lock file clients may many local open instances given file protected single lock clients must able modify currently held lock change protected access sharing without releasing lock need arises two instances 1 client holds semipreemptible lock protecting local open instances another client requests lock file conflict open instances incompatible held semipreemptible lock 2 client holding semipreemptible lock protects open instances local process request another open instance compatible current open instances access sharing requirements semipreemptible lock cannot provide first case held lock strong client must convert weaker compatible lock still protects open instances process lock downgrade client cannot release lock outright obtain weaker lock current open instances protect downgrades lock demands received server must contain type file access lock requested clients resolve compatibility appropriate downgrade second case held lock cannot provide access sharing requirements new request held lock weak client attempts obtain stronger lock protect current open instances new request obtaining stronger lock continuing hold old lock called lock upgrade concepts strength weakness help system determine action take ie change lock state service local open requests server demand messages note upgrade lead deadlock file session locks databases term upgrade sometimes used interchangeably term promotion 12 describes process reading data object one lock promoting lock writing type promotion leads deadlock example two processes reading object hold weaker lock require stronger lock writing neither receive promoted lock neither release weaker lock protects contents object read contrast file session locks upgrade changes abstract distributed lock modify mode actual session ie upgrades promotions conflicting upgrades session locks result deadlock semipreemptible protocol allows server deny conflicting lock requests 81 server algorithm server acts central management authority granting revoking locks takes incoming lock requests clients takes action revoking outstanding locks make requested lock compatible grants request possible perform actions server uses summarizing locking data structure server receives lock requests multiple clients concurrently processes requests seri ally distributed locking requires lock state changes occur atomically reason server considers one lock operation time multiple requests lock queued server executed serially processing one lock request may result multiple changes lock state granting lock server may demand multiple locks reflect many state changes summary ever serverdriven state changes rather client requests therefore conducted context single clientinitiated lock request upon receiving incoming lock request server must evaluate requested lock compatibility demand incompatible locks granting request server follows steps figure 4 evaluatelockrequest inputs requested lock dr lock summary data structure evaluate compatibility requested lock 1 0 lock compatible proceed step 5 grant lock 2 else demand incompatible locks nonzero bits demand locks summary disallow access modes desired requested locks ie demand locks bitlocksi b similarly nonzero bits dr demand locks summary permit access bit requested lock disallows ie dr demand locks bitlocksi 3 receive process responses demand requests using function releaselock downgrading lock 4 lock holder refuses demand deny lock request return 5 grant requested lock reflect change lock state summary data structure using grantlock return figure 4 server routine evaluating incoming lock requests determine compatibility incoming lock request respect current system state server first evaluates lock summary step 1 determine lock compatible outstanding locks granted immediately request cannot immediately fulfilled one currently outstanding locks conflict request must demanded server determines demands set conflicting locks step 2 outstanding locks incompatible disallow one access modes required requested lock step 2a alternatively outstanding locks incompatible permit access mode requested lock disallows step 2b routine evaluates conflicting access modes using requested lock summary high bits dr routine demands locks set bits remainder routine implements semipreemptible lock protocol clientserver interactions client denies demand requested lock refused otherwise demands succeed server grants lock request step 5 routine evaluate lock requests results outstanding locks released new lock granted changes global lock state server updates locking data structure reflect changes using subroutines granting lock figure 5 clients release locks figure 6 granting lock server updates locking data structures reflect new outstanding lock figure 5 new lock added list outstanding locks step 1 summary modified reflect change lock state step 2 finally every access mode permitted disallowed new lock must added bitlocks list references added lock entry outstanding entries bitlocks grantlock inputs lock granted dg lock summary data structure 1 register lock granted list outstanding locks create entry list outstanding 2 calculate contribution lock granted summary pg b dg 3 add reference g bitlocks data structures bit permits disal lows entry add link og bitlocks list b bitlocksi figure 5 server routine updating summarizing data structure granting lock clients release locks server updates data structure using routine figure 6 releasing lock consists removing lock list outstanding locks step 3 updating summary reflect change state step 2 removing references lock step 1 present algorithms processing upgrade requests downgrade requests operations treated combinations release request important difference upgrade releaselock inputs lock released dr lock summary data structure 1 look references find remove occurences r bitlocks lists 2 bitlocks lists become empty set corresponding bits low summary ie 3 remove outstanding list figure server routine processing released locks summary client 1 client 2 client 3 23 summary held summary held summary server client 1 client 2 client 3 held figure 7 hierarchical lock management among client servers downgrade combination simpler operations upgrade downgrade must performed atomically atomicity multiple operations achieved server allowing single process access locking data structure time however unlike server algorithms clientserver protocol must contain upgrade downgrade primitives protocol atomicity guarantee across multiple operations 82 client algorithms semipreemptible locking protocol allows clients hold locks even use holding locks use caching locks client optimistically retains privileges premise last client lock resource likely lock design aims minimize changes lock state associated messaging transactional overhead client uses two techniques manage distributed locks local processes operate locks first client allows local processes use subset access modes allowed locked ie client required use full strength held lock also client allows multiple local processes operate distributed lock implement techniques client manages held lock local processes hierarchically client holds distributed lock h server figure 7 h encapsulates actions local processes take locked resource local processes access data using modes specified lock prohibit concurrent access modes encoded h held lock client maps access modes sharing limitations local process local lock local lock local management abstraction visible clients server client holds many local locks uses summarizing data structure server figure 3 evaluate manage local locks client summary describes inuse access modes disallowed modes local processes accessing data summary restricted always weaker distributed held lock allows held lock protect concurrency guarantees expressed summary therefore needed local locks management clients summarizing data structure different servers many ways management simpler local locks held local processes nonpreemptible eliminates demands revocations held locks ways management complex client changes local lock state must consider distributed system state encapsulated held distributed lock h main principle management multiple local locks single distributed lock theorem 62 states lock compatible outstanding locks distributed system locks weaker lock also compatible ensures remainder distributed system acts accord held lock permitted access sharing local locks respected locking clients respond several stimuli requests obtain release local locks local pro cesses demand requests lock server clients obtain upgrade distributed locks behalf local processes require stronger local locks downgrade release locks response server demands effect client acts server locks local processes constraint client holds suitable distributed lock reason lock acquisition release upgrade grant operations client use routines much like servers owing similarities omit detailed descriptions operations remaining client action process demand requests server figure 8 demands initiated server attempting alter distributed lock state order grant lock another client lock mode requested client included servers demand message requested lock evaluated current open state step 1 client evaluates whether requested lock granted given local lock state clients know local state must evaluate request determine conflicting outstanding locks clients make final determination compatibility request current system state comparing requested lock current local lock state clients compatible local locks downgrade distributed lock choosing locking mode downgrade many possible choices present two extreme choices possible heuris tics first client elect retain strong lock possible minimum downgrade heuristic processdemand inputs remotely requested lock included demand message dr client lock summary data structure 1 evaluate whether requested lock compatible currently held local locks 0 proceed step 2 else deny demand return 2 determine downgraded lock mode required protect currently held locks requested lock using one two following heuristics maximum downgrade heuristic b minimum downgrade heuristic 3 inform server downgrade return figure 8 client routine determine needed lock downgrade client reduces holding little possible lock strength sense make lock compatible requested lock choice would perform well future access object likely occur locally clients however interest object moved clients policy may result future demands alternative downgrade lock holding much possible maximum downgrade heuristic downgraded locking mode exactly lock summarythe fewest permitted access modes disallowed modes needed local locks 9 comparing dynamic evaluation traditional locking present execution time memory usage bounds lock evaluation algorithms illustrate dynamic evaluation asymptotically outperforms evaluation based static data structures locking systems complex amount space used locking system divided static dynamically used space static space contains information system needs know locking modes properly run locking protocol dynamic space contains information current outstanding locks conventional wisdom holds dynamic costs dominate static costs however locking systems become complex assertion always true static space costs grow exponentially number access modes static data structures k different access modes results 2 2k unique locks locking traditional data structures requires space 4k 2 4k entries lock compatibility table 2 2k locks dynamic lock evaluation algorithms need know different locking modes uses space ok dynamic space usage locking using traditional data structures nk n outstanding locks system stores list k modes n outstanding locks dynamic evaluation uses summarizing data structure hold dynamic lock state nk data structure outstanding list n entries size k k different bitlocks lists total n entries lists n incoming pointers referring entries execution time look long operations take respect amount outstanding lock state n amount static state k lock evaluation static data structures takes time n request must checked outstanding locks dynamic lock evaluation uses execution time ok evaluate lock update lock summary fill bitlocks outstanding lists similarly releasing lock takes time ok concurrency high many outstanding locks dominates k dynamic evaluation operates efficiently total space required dynamic evaluation locks always asymptotically less equal required evaluation based static data structures however dynamic space requirements dynamic evaluation locks larger constant factor list locks used static evaluation equivalent size content outstanding list portions summarizing data structure overhead true space savings realized static data structures become important k grows large perhaps important space time savings improvement manageability ease implementation implementer using lock compatibility table must reason pair locks complete entry table task difficult even 64 locks windows nt additionally locking modes must preprogrammed dynamic evaluation implementer need identify object accessed dynamic evaluation algorithms manage concurrency compatibility related research many distributed file systems clients transact server every open close file synchronization 25 5 26 simplest technique implement local file system open semantics distributed environment however file open file close requests require network operation andrew file system 15 interacts server every open close uses open close points synchronize cached data andrew implement data cache hold data past close general callback demand mechanism however callbacks apply preemptible data locks like storage tank calypso file system 7 uses open mode synchronization locks called tokens implement local file system semantics calypso tokens fully preemptible client cannot held past close every file system open close generates token request release file system open state token request conflicts managed completely server calypso uses simple lock hierarchy data locks hierarchy apply open mode synchronization tokens dfs file system 16 describes token mechanism similar semipreemptible locks management data metadata open state like semipreemptible locks client refuse permit revocation token depending upon local state token management dfs differs elements system locking including file access locks data locks byterange locks managed single token mechanism dfs treatment token management less concrete discussion locking address mapping local file system semantics distributed locking system work omits discussion synchronization presence failure distributed file system presents local file system interface remote shared storage must continue components fail many modern file systems 24 21 18 storage tank uses leasebased 6 protocol ensure operational safety high availability presence client server failures network partitions conclusions distributed file systems need manage open state referential integrity synchronized access files existing distributed systems address problem either relaxing local file system semantics sending every file open request server introduced locking construct semipreemptible lock permits file system clients grant file open requests locally without server transaction avoiding server messages open client improves performance exploiting locality access files file system client semipreemptible locks used summarize open state many open files may granted protection single semipreemptible lock reduces global lock state reduces clientserver messages also presented set algorithms data structures dynamic evaluation locks dynamic evaluation provides formal compact framework evaluating lock compatibility runtime dynamic evaluation obviates lock compatibility tables exponentially reducing space requirements describe locking system also obviates ad hoc systems lock evaluation providing formalism manages locks correctly without deadlock r serverless network file systems measurements distributed file system fast crash recovery distributed file systems fibre channel gigabit communication io computer networks universal file server analytical study opportunistic lease renewal recovery calypso file system extendible hashing fast access method dynamic files gigabit ethernet 100 1 file server scaling networkattached secure disks filesystems networkattach secure disks transaction processing concepts techniques design multicastbased distributed file system scale performance distributed file system synchronization caching issues andrew file system decorum file system architectural overview disconnected operation coda file system coherent distributed file cache directory write behind caching sprite network file system authentication service computer networks authenticating network attached storage highly available file system distributed workstation environment scalable distributed file system locus distributed operating system overview sun network file system tr
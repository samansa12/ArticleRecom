timed asynchronous distributed system model abstractwe propose formal definition thetimed asynchronous distributed system model present extensive measurements actual message process scheduling delays hardware clock drifts measurements confirm model adequately describes current distributed systems network workstations also give explanation practically needed services consensus leader election implementable timefree model implementable timed asynchronous system model b introduction depending whether underlying communication process management services provide certain com munication distributed systems classified either synchronous asynchronous 7 certain communication mean 1 time minimum number correct processes 2 message sent correct process correct destination process received processed destination within known amount time ie probability received processed time negligible authors 28 5 explain means failures negligible synchronous system guarantees certain communication systems asynchronous achieve certain communication one assumes frequency failures occur system bounded bounded failure frequency assumption allows system designers use space 8 time redundancy 32 mask lower level communication failures provide abstraction certain communication however almost distributed systems reasonable assume failure frequency bounded dependable systems characterized strict stochastic specifications 5 hence even one tries fix unpredictability system achieve certain communication eg admission control resource allocation redundant communication channels etc probability communication failures might still negligible many dependable systems therefore necessarily reasonable assume communication certain paper define asynchronous system model makes much simpler assumptions synchronous sys department computer science uc san diego la jolla ca 92093gamma0114 email flaviucsucsdedu cfetzercsucsdedu short version paper appeared proceedings proceedings 28th annual international symposium faulttolerant computing 1998 research supported grants f4962093 f4962096 air force office scientific search information timed model available http wwwcsucsdeducfetzermodel model hence probability one assumptions violated much smaller probability violation assumptions synchronous sys tem nevertheless asynchronous system model still strong enough serve foundation construction dependable applications published research asynchronous systems based timefree model 21 model characterized following properties 1 services time free ie specification describes outputs state transitions occur response inputs without placing bounds time takes outputs state transitions occur 2 interprocess communication reliable researchers relax condition ie message sent two noncrashed processes eventually delivered destination process crash failure semantics ie processes fail crash ing 4 processes access hardware clocks timefree model process cannot distinguish noncrashed slow crashed process services importance practice consensus election membership therefore implementable 21 2 timed asynchronous distributed system model shorter timed model define formally paper assumes 1 services timed specification prescribes outputs state transitions occur response inputs also time intervals within client expect outputs transitions occur 2 interprocess communication via unreliable datagram service omis sionperformance failure semantics failures messages suffer omission message dropped performance failures message delivered late crashperformance failure semantics failures process suffer crash performance fail ures access hardware clocks proceed within linear envelope realtime 5 bound exists frequency communication process failures occur system feel model adequately describes existing distributed systems built networked workstations contrast timefree model timed model allows practically needed distributed services clock synchronization mem bership consensus election atomic broadcast implemented 4 10 14 6 13 since assume existence hardware clocks timed services timefree model may appear general timed model however workstations currently market highprecision quartz ieee transactions parallel distributed systems appear 1999 clocks presence clocks timed model practical restriction moreover true many services encountered practice unix processes udp make responsetime promises also true services become de facto timed whenever higher level abstraction depends highest level human user fixes timeout decide failed therefore practical point view requirements services timed processes access hardware clocks make timed model less general timefree model fact failure semantics interprocess communication timefree model defined 21 much stronger timed model timefree model cannot exist system runs correct processes disconnected entire run timed model allows runs correct processes permanently dis connected thus timefree model excludes possibility correct processes partitioned timed model allows partitioning naturally modeled occurrence sufficiently many message omission performance failures characteristic timed model reflects situations communication partitions observed hours even days real sys tems especially based wide area networks like internet thus practical point view timed model general timefree one allows partitions modeled naturally assumptions services timed processes access hardware clocks restrictive practical point view goals paper 1 propose formal definition timed asynchronous distributed system model extensive measurements actual message process scheduling delays clock drifts confirm model adequately describes current runofthemill distributed systems built networked workstations give intuitive explanation practically important services consensus leader election implementable timefree asynchronous system model implementable timed model ii related work distributed system models classified according assume network topology synchrony failure model message buffering 23 according taxonomy timed asynchronous model characterized follows ffl network topology process knows complete set processes send messages process problem routing messages irregular topologies assumed solved lower level routing protocol ffl synchrony services timed processes access local hardware clocks whose drift rates realtime bounded timed service specifications allow definition timeout delays message transmission process scheduling delays ffl failure model processes suffer crash performance failures communication service suffer omission performance failures ffl message buffering finite message buffers nonfifo delivery messages buffer overflows block senders result message omission failures important difference timed model timefree model 21 existence local hardware clocks many distributed applications specified using realtime constraints example component fails within x time units application perform action hardware clocks allow one implement application level timeouts timed asynchronous system model introduced without named 4 refined 10 renamed avoid confusion timefree model 21 particular 10 introduces system stability predicates conditional timeliness properties capture intuition long system stable number failures affecting system certain threshold system make progress within bounded time welltuned systems expected alternate long periods stability short periods instability failure frequency increases beyond assumed threshold 14 formalized progress assump tions progress assumption optional extension core timed asynchronous system model see section iv progress assumption states unstable period always exists time interval given minimum length system stable progress assumptions allow one solve problems like consensus originally specified using unconditional termination conditions defined section via opposed use conditional timeliness properties see section via one view progress assumption formal way require parameters timed model oneway timeout delay section iiib scheduling timeout delay section iiic2 well chosen progress assumptions similar global stabilization requirement 11 postulates eventually system must permanently stabilize sense must exist time beyond messages noncrashed processes become timely however progress assumption require infinitely often exists majority set processes certain minimum amount time timely communicate timely manner progress assumptions also certain similarity failure detectors 3 mechanisms strengthen timefree model certain failure detector classes provide desired behavior based observation system eventually stabilizes main differences model 3 timed model follow ing 1 timed model allows messages dropped processes recover crash 2 timed model provides processes access hardware clocks model 3 provides processes access failure de tector note hardware clocks used detect cristian fetzer timed asynchronous distributed system model 3 failures highlight similarities differences exist synchronous timed asynchronous system models 7 compares properties fundamental synchronous asynchronous services membership atomic broadcast sketch section vi certain problems implementable synchronous systems implementable timed asynchronous systems previously authors addressed possibility issues example 24 27 address issue problems simulated asynchronous system section vi however address simulation issues example concerned one ensure two leaders point realtime interested solutions two leaders virtual time difference important realtime systems interact external processes 15 introduced notion failawareness systematic means transforming synchronous service specifications failaware specifications become implementable timed asynchronous systems idea processes provide synchronous prop erties long failure frequency given bound whenever property cannot guaranteed detectable timely manner correct clients depend property claim weakened failaware specification still useful implementable timed system failawareness depends timely detection message performance failures introduced 19 mechanism allows receiver r message detect suffered performance failure basic idea 1 one use local hardware clocks measure transmission delay message roundtrip 2 one use duration roundtrip contains upper bound tranmission delay introduced 19 several optimizations provide better upper bound 12 describes use timed model failaware datagram service fully automated train control system quasisynchronous model 31 another approach define model synchronous systems timefree asynchronous systems requires p1 bounded known processing speeds p2 bounded known message delivery times p3 bounded known drift rates correct clocks p4 bounded known load pat terns p5 bounded known deviations among local clocks model allows least one properties px incomplete assumption coverage nonzero probability bound postulated px violated runtime 28 comparison timed asynchronous system model assumes coverage p3 1 coverage p1 p2 value make assumptions load patterns deviation local clocks iii model timed asynchronous distributed system consists finite set processes p communicate via datagram service processes run computer nodes network see figure 1 lower level software nodes network implements datagram service two processes said remote run separate nodes otherwise local process p access local hardware clock process management service runs node uses clock manage alarm clocks allow local processes request awakened whenever desired use p q r denote processes u v denote realtimes u v denote clock times n denote messages node 724 hardware c lock r process networkfig 1 processes timed asynchronous system access local hardware clocks communicate via datagram messages across network hardware clocks processes run node access nodes hardware clock simplest hardware clock consists oscillator counting register incremented ticks oscillator tick increments clock value positive constant g called clock granular ity hardware clock implementations described 26 correct clocks display strictly monotonically increasing values denote set realtime values rt set clock values ct clock h p process p represented function h p realtime clocktime denotes value displayed clock p realtime local processes access clock remote processes access different clocks thus processes p q running node h due imprecision oscillator temperature changes aging hardware clock drifts apart realtime intuitively drift rate hardware clock indicates many microseconds hardware clock drifts apart realtime per second example drift rate 2 means clock increases value 1sec every second assume existence constant maximum drift rate ae 1 bounds absolute value drift rate correct clock thus drift rate correct clock least gammaae ae see figure 2 constant ae known processes correct clock measures duration time interval error within gammaaetgamma g g term g accounts error due granularity clock factor ae error due drift clock define predicate correct u hp true iff ps hardware clock h p correct time u definition based intuition h p measure duration time interval u absolute error correct u ae bound drift rate causes correct clock within narrow linear envelope realtime see figure 2 r dt dt dt dt dt r realtime clocktimet fig 2 point time drift rate correct hardware clock hp within aeae note drift rate constant since change time assume value within aeae one analyzes drift error clock possible distinguish 1 systematic drift error due imprecision oscillator 2 drift errors due reasons aging changes environment speed calibrated hardware clock changed constant factor c reduce systematic drift error relation uncalibrated clock h p calibrated counterpart h calibrated p expressed follows calibrated hardware clock calibration done automatically systems internet access local access external time provider gps receiver clocks externally synchronized instant deviation correct clock realtime bounded known constant clocks internally synchronized deviation two correct clocks bound known constant correct clocks system externally synchronized known ffl clocks also internally synchronized 2ffl clock calibration done lifetime system however account aging clock makes sense recalibrate clock occasionally internal external clock synchronization needs performed periodically account ongoing drift clocks timed asynchronous system model require clocks calibrated externally internally synchronized drift rate bounded ae however advantageous calibrate hardware clocks since allows reduction maximum drift rate see a1 measurements common operating systems provide processes access realtime clock realtime clock less synchronized realtime eg utc universal time gps time many unix domains one tries maintain good synchronization realtime using time services like ntp 25 however processes always know good synchronization realtime might even exist upper bound drift rate realtime clock operator change speed realtime clock 1 recent operating systems provide processes access hardware clocks subject adjustments ie neither software operator change speed clock example solaris provides c library function gethrtime get highresolution realtime returns clock value expressed nanoseconds highresolution realtime clocks example hardware clocks provided operating system also ideally suited implement calibrated hardware clocks current workstation technology granularity hardware clock order 1ns 1s constant ae order 10 gamma4 10 gamma6 measured drift rate uncalibrated unsynchronized hardware clocks several sun workstations running solaris 25 period several weeks figure 3 shows drift rate four hardware clocks measured drift rate using nist timeserver clocks externally synchronized via ntp average drift rate four hardware clocks stayed almost constant measured period computers located airconditioned rooms computers subject higher temperature changes one expect higher variance clock drift note assume clock drift constant assume clock drift within gammaae ae interval chosen large enough account unsteady environmental conditions days rate uss fig 3 measured drift rate four hardware clocks period 70 days drift rate determined every hour using externally synchronized clocks measured relative drift rate two calibrated hardware clocks interval several days ie mea cristian fetzer timed asynchronous distributed system model 5 sured many two calibrated hardware clocks drift apart every second calibrated clocks implemented top highresolution realtime clocks solaris variations message transmission delays introduce errors reading remote clocks distributed system read remote clocks using failaware datagram service 19 calculates upper bound transmission delay message delivers 1 allowed us calculate lower upper bounds remote clock reading errors bounds calculated lower upper bounds drift rate minimize measurement error measured every minute average relative drift rate last 100 minutes figure 4 shows lower upper bound relative drift rate two calibrated hardware clocks period 2 days summary calibrating hardware clock allows us decrease maximum drift rate two orders magni tude 10 gamma4 10 gamma6 example clock calibration allowed us reduce measured average drift one clock 155 0 use protocols calibrated hardware clocks use maximum drift rate ae 2 instead ae 200 since ae small quantity ignore terms ae 2 example equate 1 ae also assume clock granularity g negligible 04 03 02 010103 time hour relative drift rate lower bound upper bound fig 4 relative drift rate two calibrated hardware clocks stayed within 1 measurements a2 clock failure assumption assume noncrashed process access correct hardware clock ie access hardware clock drift rate ae assumption simplifies applications since deal crash failures anyhow deal faulty clocks like fast slow clocks let predicate crashed p true iff process p crashed realtime formally express clock assumption ca follows hp 1 service requires upper bound drift rate clock chose constant based measurements absolute drift rate calibrated clocks using externally synchronized clock hence circularity measurement practice one actually weaken assumption following sense hardware clock h p fails time process p tries read clock p crashes incorrect clock value returned p since p read incorrect clock information relaxed assumption actually equivalent ca particular process determine h p failed one implement relaxed assumption detecting clock failures lower protocol levels transparent application processes transform process crash failures two basic realtime clock implementations operating systems 1 oscillator increments long hardware counter typically 64 bit long value realtime clock current value hardware counter 2 periodic timer used increment software counter value realtime clock first case properties clock determined physical properties oscillator second case interrupt priorities might affect properties realtime clock systems timer interrupt highest priority systems loose timer interrupts however exist systems interrupt sources eg serial line higher priority timer interrupt systems might loose timer interrupts ie clocks go slower many interrupts higher priority systems one find reasonable ae probability hardware clock fails ie drift rate bounded ae low whether probability classified negligible depends stochastic requirements application see 28 5 explanation failures neglected probability negligible one even detect clock fail ures however requirements application stringent neglect probability single hardware clock fails one use redundant hardware clocks make sure clock failure assumption valid showed 20 one use commercial shelf components build faulttolerant clocks make clock failures negligible example one use two redundant hardware clocks two 64 bit counters connected separate oscillators available pc cards detect single hardware clock failure detection even masking clock failures least three hardware clocks used localized one clock reading procedure becomes transparent higher level pro cesses whenever process wants read hardware clock process calls clock reading procedure procedure reads two redundant clocks procedure uses two values determine relative drift rate two clocks within acceptable range failures hardware clocks independent one detect failure clock high probability thus stochastic application requirements stringent redundant clocks allow detection clock failures probability process reads faulty clock becomes negligible 6 ieee transactions parallel distributed systems appear 1999 b datagram service datagram service provides primitives transmitting unicast see figure 5 broadcast messages see figure 6 primitives ffl sendmq send unicast message process q ffl broadcastm broadcast processes including sender initiated datagram service deliver message sent process p time clock real time td send mq deliver mp fig 5 process p sends unicast message q realtime q receives realtime transmission delay tdq simplify specification datagram service assume datagram message uniquely identified words two messages different even sent process two different points time contents let msg denote set messages use following predicates denote datagram related events q mp datagram service delivers message sent p q realtime say process q receives unicast message q realtime invoking primitive sendmq broadcast broadcast message realtime invoking primitive broadcastm time clock real time r r broadcast td td deliver deliver r fig 6 process p sends broadcast message q receives r receives u transmission delays let message p sends see figure 5 broadcasts see figure 6 let q receive call send receive times denote stm rt q respectively transmission delay td q defined td q function senderm returns sender sendermp 9sq send mqbroadcast destination destm message set processes sent mqbroadcast requirements datagram service validity duplication mindelay defined follows ffl validity datagram service delivers p identifies q ms sender q indeed sent broadcast q ffl noduplication message unique sender delivered destination process ffl mindelay assume message sent two remote processes p q transmission delay least td q ffi min mindelay requirement restrict minimum transmission delay message n sent two local processes transmission delay n smaller ffi min intuition ffi min knowing minimum message size maximum network band width one knows lower bound message transmission delay one use ffi min improve calculated posteriori upper bound transmission delay remote messages tighter ffi min real minimum transmission delay tighter posteriori upper bound gets see 19 details however ffi min chosen big ie remote messages transmission delays less calculate bound small since network configuration system might change lifetime safest choice assume datagram service ensure existence upper bound transmission delay messages since services model timed define oneway timeout delay ffi chosen actual messages sent broadcasted likely 5 delivered within ffi message transmission delay less ffi min called early see figure 7 timed model assume early messages ie ffi min well chosen see mindelay requirement message whose transmission delay ffi ie ffi min td q ffi called timely ms transmission delay greater ffi ie td q ffi say suffers performance failure late message never delivered say suffered omission failure dropped realt ime timely late dropped sdm sd fig 7 timed model message either timely late dropped timed model assumes message early cristian fetzer timed asynchronous distributed system model 7 b1 measurements timed model assumes existence oneway timeout delay ffi used define message performance failures choice ffi determines frequency message performance failures timed model put upper bound frequency failures hence choice ffi affect correctness protocols designed timed model described 17 several techniques allow timely detection message process performance failures able detect certain application properties hold anymore 19 describe mechanism allows receiver detect message timely good selection ffi might system application dependent first applications choice ffi naturally derived application quirements example 1 application might achieve something good within time units 2 protocol used implement application achieve something good within say kffi time units case failure frequency within given bound case makes sense define ffi ffi delta k second applications might constrain ffi practical point view applications good choice ffi crucial protocol stability speed 1 choosing small ffi increase frequency message performance failures hence quality service might degrade often 2 choosing large ffi might increase response time service since service timeouts take longer choice good ffi always easy since message transmission delays increase message size see figure 8 network load see figure 9 also depend message transmission pattern used protocol see figure 10 determination good ffi ensures likely stability progress might require measurement protocol specific transmission delays233343 bytes ms fig 8 measured minimum delay roundtrip message pairs different message sizes used 20000 roundtrips 156 measured message sizes performed measurements cluster 9 sun ipx workstations connected 10mbit ethernet dependable systems laboratory ucsd seven computers run sunos 412 2 machines run solaris 25 measurement programs use different services provided fortress toolkit 18 fortress uses udp interprocess communication model dependence message transmission times message size see figure 8 could replace constants two functions increase size message actually use 19 function increases size message tighter lower bound allowed receiver calculate better upper bound transmission delay received message simplicity however assume timed model ffi ffi min constant 70 75 80 85 90 95 100 message delayms 704 kbytes 580kbytes 232kbytes fig 9 transmission delay messages increases network load network load 232 kbytesec 99 messages delivered within 60ms 580 kbytesec within 74 ms network load 704 kbytesec less 99 messages delivered measured distribution message transmission times different network loads measurements used 8 sun ipx workstations connected 10mbit ethernet workstations grouped 4 pairs two processes pair sent pingpong messages size 1448bytes without udp header estimated network load average number bytes 8 workstations sent per second expected likelihood message delivered within given time decreases network load see figure 9 measurement showed minimum experienced message transmission delay slightly decrease increase network load explained decrease cache misses network protocol code increase network traffic demonstrate transmission delays protocol dependent measured transmission times experienced local leadership service 13 measurement involved one process p periodically broadcasting messages five processes sending immediate replies message p receiving reply p spends time processing receiving next reply hence transmission delays successive replies increase processing time preceding replies distribution transmission delays therefore shows five peaks five replying processes see figure 10 8 ieee transactions parallel distributed systems appear 199950015002500350011 21 31 41 ms nomessages fig 10 distribution transmission delays unicast messages sent local leader election protocol distribution based 500000 replies0011300 500 700 900 1100 network load kbytesec dropped fig 11 likelihood message dropped respect network load network operating system drop mes sages example ethernet based systems message dropped message collision cable checksum error however likely operating system drops messages buffer overruns occur cannot deliver messages fast enough receiving processes measured likelihood udp packet dropped different network loads used setup network load measurements 8 sun ipx workstations grouped 4 pairs measurement processes pair send pingpong unicast messages fixed scheduled wait time sending messages changed network load changing scheduled wait time network load 1090 kbytesec approximately 35 messages dropped load 300 kbytesec decreased 0003 see figure 11 also performed experiments test communication omission failures independent used 8 computers setup note omission failures independent probability two consecutive messages dropped square probability message suffers omission failure sent 3000000 messages 8 processes high network load 1000 kbytesec 29 these051525 length dropsequence dropseq length measured independent fig 12 message omission failures independent messages suffered omission failures measure ment one process experienced drop 53 consecutive messages sent process figure 12 shows measured likelihood message part sequence x 2 f1 20g consecutively dropped messages also plotted curve would look omission failures independent shows message omission failures independent b2 datagram failure assumption various experiments test system detects message corruption far sent 10 8 messages known random contents system delivered corrupted messages also tested message duplications none messages delivered probability undetected message corruption duplication might negligible systems however one use additional software layer reduce probability degree becomes negligible software layer transparent processes ie processes need know existence source address spoofing occurs process p sends message process q makes q believe different process r 6 p sent validity assumption implies assume probability source address spoofing negligible one cannot neglect probability one use message authentication 30 reduce probability becomes negligible done manner transparent processes note message authentication increase transmission time substantially special hardware assistance summary asynchronous datagram service assumed omissionperformance failure semantics 5 drop messages fail deliver messages timely manner one neglect probability source address spoofing message delivered system corrupted delivered multiple times broadcast messages allow asymmetric performanceomission failures sense processes might receive broadcast message timely manner processes cristian fetzer timed asynchronous distributed system model 9 might receive late since ae ffi min ffi small quantities equate c process management service c1 process modes process p one following three modes see figure ffl p executing standard program code ffl crashed process stopped executing code ie take next step algorithm lost previous state recovering p executing state initialization code 1 creation 2 restarts crash process either crashed recovering said following events cause process p transition modes specified see figure 13 ffl start p created starts recovering mode crash time example underlying operating system crashes ffl ready p transitions mode finished initializing state ffl recover p restarts crash covering mode define predicate crashed p true iff p crashed time p crashed cannot execute step algorithm define predicate recovering p true iff p recovering time process recovering consequence start recover event occurrence crash ready crashed crashed recov ering recov ering crash recover start fig 13 process modes transitions c2 alarm clocks process p set alarm clock awakened specified future clock time 2 p requests awakened clock time process management service awake p h p shows value least call alarm time process p take step sets alarm clock unless 1 awakened alarm time 2 receives message awakened time assume process p sets alarm clock awakened previous alarm time assume process signaled error case requests awakened time already passed avoid process define positive alarm time relative current time instead specifying absolute alarm time happen receives message awakened alarm time overwritten ie p awakened alarm time words time process p one active alarm time ie alarm time overwritten p awakened note process maintain multiple alarm times based alarm clock provided timed asynchronous system model use following predicates specify behavior alarm clock requests realtime awakened future realtime u h p u ie p wants take next step hardware clock shows least value unless receives message ffl wakeup u p process management service wakes p realtime u alarm clock time process p crashes process management service forgets active alarm time p set crash ing p never crashes assume eventually awakened active alarm times behavior alarm clock constrained following requirement process p awakened alarm clock time realtime u 1 hardware clock shows least u 2 p requested previous awakened u process p crashed overwritten alarm time awakened since formally ac requirement expressed follows 8pust wakeup u scrashed v let earliest realtime ie smallest value h p tt call real alarm time specified setalarm event consider process management awakes process p alarm time realtime u ie wakeup u holds delay called scheduling delay experienced process p process management service ensure existence upper bound scheduling delays however timed service define scheduling timeout delay oe actual scheduling delays likely 5 smaller oe since ae oe small quantities equate say noncrashed process p suffers performance failure awakened within oe last time specified see figure 14 ie awakened local hardware clock h p shows already value greater oe case say p late otherwise p awakened hardware clock shows value said timely p awakened h p shows p said early since easy avoid early timing failures checking h p going sleep h timed model assumes processes suffer early timing failures formally process p suffers performance failure realtime u exists alarm time caused wakeup event u pfail u tcrashed v define predicate timely u p true iff p timely u timely u extend notion process p timely time interval follows timely timely note include processing time messages definition timely process reason conceptually protocols timed model add processing time message transmission delay messages sent processing see 17 detailed description slow processing messages therefore transformed message performance failures clocktime timely late alarm time fig 14 process p timely awakened within oe ticks alarm time process p suffers performance failure late awakened oe timed model excludes early timing failures ie process never awakened time c3 measurements implement alarm clocks unix family operating systems one use select system call call allows specification maximum interval process waits specified io events kernel returns unix tries awake process specified time interval expires using internal timer sunos timer resolution 10ms thus scheduling delay timeout oe chosen least 10ms figure 15 shows distribution scheduling delays experienced process executing membership protocol 16 measurements performed normal daytime use system low load c4 process failure asssumption timed model assumes processes crashperformance failure semantics 5 however execution process might stop prematurely crash failure process might awakened within oe time units active alarm time performance failure processes recover crashes applications probability processor executes program process incorrectly negligible systems probability cannot neglected one use redundancy lower protocol levels guarantee crashperformance process failure semantics example consider processors suffer measurements fig 15 distribution shows difference time process awakened time requested awakened based 350000 measurements failures case one use processor pair execute program process lock step two processors disagree result instruction processors stop executing way processor failures transformed crash failures dual processor approach transparent processes thus assumption processes crashperformance failure semantics reasonable iv extensions core timed asynchronous system model assumes datagram service process management ser vice local hardware clocks introduce two optional extensions model stable storage progress assumptions extensions reasonable network workstations however systems might need actually access stable storage progress assumption states infinitely often majority processes stable ie behave like synchronous sys tem bounded amount time progress assumptions valid local area network based sys tems necessarily valid large scale systems connected wide area networks moreover service specifications need progress assumption enable implementation timed asynchronous sys tems sometimes use terms core model ex tended models distinguish models include assumptions stable storage progress assumptions addition core assumptions datagram ser vice process management service local hardware clocks stable storage lose memory state crash allow processes store information crashes introduce extension timed asynchronous system model local stable storage service service provides following two primitives local process p asks value val stored address addr cristian fetzer timed asynchronous distributed system model 11 asks read recent value stored address addr p yet stored value addr value undefined returned predicates denote invocation primitives realtime store addrval read addrval respectively stable storage service guarantees address process p reads returns recent value p stored address read 8utvstore u 9ststore av stable storage service implemented top unix using unix file system implementation service performance described 9 b stability progress assumptions timeliness requirements encountered specification protocols designed timed asynchronous system model often conditional sense system stability predicate true system achieve something good see eg 7 conditional timeliness requirements express set processes sp p stable ie behaves like synchronous system failures affecting sp communication bounded frequency occurrence servers sp guarantee progress within bounded amount time call set sp stable partition 13 iff ffl processes sp timely ffl bounded number messages sent processes sp delivered timely ffl partition either message late messages arrive sp concept stable partition formalized stability predicate defines set processes sp forms stable partition given time interval multiple reasonable definitions stability predicates examples stable predicate 10 majority stable predicate 14 paper formally define stability predicate deltafpartition introduced informally 17 first formalize generalize notions connectedness disconnectedness introduced 10 deltafpartitions two processes p q fconnected time interval iff 1 p q timely 2 f messages sent two processes delivered within ffi time units denote fact p q fconnected predicate timely u timely u process p deltadisconnected process q iff message delivered p q transmission delay units common situation two processes delta disconnected network overloaded least one processes slow one use failaware datagram service 19 detect message transmission delay delta guaranteeing message transmission delay ffi wrongly suspected transmission delay delta use predicate deltadisconnectedpqst denote p deltadisconnected q deltadisconnectedpqst delta deliver u say nonempty set processes deltafpartition interval iff processes fconnected processes delta disconnected processes deltafpartitions 8p2s8r2ps deltadisconnectedprst example utility stability pred icate consider atomic broadcast protocol designed achieve group agreement semantics 6 messages possibly lost late resent f times group processes forms deltafpartition sufficiently long time group make progress successfully broadcasting messages time b2 progress assumptions lifetime distributed systems based local area network characterized long periods exists majority processes stable stability periods alternate short instability periods explained bursty behavior network traffic cause temporary instabilities exam ple traffic bursts caused occasional core dumps file transfers via network based observa tion introduced concept progress assumptions 14 show classical services consensus originally specified using unconditional termination require ments implementable extended timed model progress assumption states system infinitely often stable exists constant j time exists majority processes sp sp forms stable partition b3 measurements first measurement shows transmission delays distributed time see figure 16 used experiment 4 processes process receives sends 36 udp messages per second hence sent 144 messages every second ethernet message contains payload 1448 bytes ie induced network load 208 kbytesec also measured behavior six processes running sun workstation dependable systems lab period day normal load conditions see figure 17 set six pro realtime transmission time fig 16 graph shows transmission delay messages received one process period 100 seconds transmission delay messages stayed long periods time well 10ms however sporadically delay increased well 10ms cesses average delta1stable 218s ie six processes formed deltafpartition 30ms average distance two delta1stable periods 340ms typical behavior experienced unstable phase one six processes slow measurement used modified membership service 16 whenever process declared cannot keep membership upto date six processes stayed membership knew fp 1 p 6 g delta1stable theoretical point view one cannot determine perfectly system delta1stable however one determine system looks processes like delta1stable practical point view equivalent system delta1stable note membership service allows fast processes continue make progress even system delta1stable temporarily remove slow processes membership words system instabilities might result removal slow disconnected processes experience almost cases remaining processes still provide safety timeliness properties v communication time synchronous systems communication time ie communication information achieved measuring passage time important example correct process p hear time iamalive message q p knows q crashed communication uncertainty characterizes timed asynchronous systems makes communication time difficult restricted form still possible example timed model p hear q time iam alive message q p know q crashed however p knows q iamalive suffered failure many applications sufficient since p103050700 200 400 600 800 1000 ms unstability phases fig 17 observed time two delta1stable periods six pro cesses 30ms period 24 hours typical failure behavior observed consecutive stability periods one process slow cares communicate q timely manner example leader election pro process p might support election q long p communicate q timely manner otherwise might try support election another process communicate timely man ner however leader election example make sure one leader time synchronous systems enforcing property straight forward since processes detect perfectly current leader crashed hence replace new leader asynchronous systems enforcing property easy since one cannot decide current leader l crash slow communication l slow illustrate two processes p q use communication time ensure time one leader use locking mechanism 17 viewed leases mechanism 22 systems without synchronized clocks mechanism enables communication time even local clocks synchronized mechanism works follows sends information message process q p says information valid certain amount time ffl q receives calculates upper bound transmission delay determine long use ffl p determine consulting local hardware clock time beyond q longer make use information contained concreteness consider pseudocode figure 18 example use communication time enforce one correct process p eventually leader ensuring one leader time even though q might leader bounded amount time concentrate main aspect ie p detect q leader cristian fetzer timed asynchronous distributed system model 13 anymore q gets one chance become leader p sending q message saying q leader certain amount time complete leader election protocol using time locking mechanism found 13 process p sends message q informing q become leader duration clock time units transmission delay delta realtime units process q calculate upper bound transmission delay determine use failaware datagram service introduced 19 calculates upper bound transmission delay messages delivers fast transmission delay delta process q uses fast sets variable expira tiontime qs leadership expires exactly duration time units reception local clock time rt process p waits duration12aedelta1ae clock time units becomes leader 1 factor 1 2ae necessary ps qs hardware clocks drift apart 2ae 2 factor 1ae since ps clock drift apart realtime deltaae maximum transmission delay delta fast message process r 2 fp qg leader iff function leader evaluates true called value rs hardware clock argument ie leader r process p q never leader time since 1 q leader transmission delay delta leader duration local clock time units receiving 2 p sent waits least duration12aedelta1ae local clock time units becoming leader note leader implicitly demoted advancement hardware clock since process might delayed immediately checking leader demoted process might immediately detect demoted however leader used proper way processes detect messages demoted leader following way ffl process r first reads hardware clock h r shows value ffl r determines leader querying function leader time r leader processing sends message n sets send timestamp n ffl process receiving n calculate transmission time n based ie delays r added transmission time n example r swapped reading leader sending n delay swap added transmission delay n receivers n reject n transmission delay n slow summary typically transform delays demoted leader message performance failures detected receivers messages const time duration delta boolean leadertime expirationtime return true return false process p begin leader q select event wakeupt select process q begin select event fagammadeliverm p fast rt fast endif select fig 18 pseudocode uses communication time enforce correct p eventually leader ensuring one leader time even though q might leader bounded amount time vi possibility impossibility issues address section issue problems like election consensus implementable actual distributed computing systems allow deterministic solution 1 timefree model 2 extent core timed model fix ideas use election problem illustrate issues whether leader problem deterministic solution depends 1 exact specification problem 2 use progress assumptions whether underlying system model allows communication time main intuition 1 one weaken problem one solve problem system well behaved 2 one require instead system well behaved time time hence one solve problem system well behaved one use communication time circumvent impossibility one cannot decide perfectly remote process crashed eg one use local hardware clock decide time quantum remote process expired termination vs conditional timeliness conditions commonly agreedupon rigorous specification election problem example 29 specifies election problem timefree system model follows realtime exists one leader 14 ieee transactions parallel distributed systems appear 1999 infinitely often exists leader ie realtime exists realtime process p becomes leader typically problems specified timed systems use strong unconditional termination conditions like requiring something good eventually hap pens instead use conditional timeliness conditions require system stabilizes priori known duration something good happen within bounded time introduction deltafstable predicate earlier generalize specifications given 13 election highly available leadership problem timed asynchronous systems follows realtime exists one leader tt majority processes deltafstable time interval exists process p becomes leader specification tf implementable timefree systems even one process allowed crash 29 tt implementable timed systems 10 13 explain consider timefree system contains least two processes p q implement one solve following problem process p becomes leader realtime stays leader crashes later time remaining processes detect p crashed elect new leader time u satisfy requirement tf since processes communicate messages one find run indistinguishable remaining processes p crashed still leader u words one find run least one two requirements stf violated implementability tt timed asynchronous system explained follows first ensure property processes decide current leader crashed slow process leader bounded amount time demoted see section v processes therefore wait certain amount time without exchanging messages make sure leader demoted particular processes able decide remote process crashed impossible timefree timed asynchronous system models second system stable majority processes timely communicate timely fashion sufficient elect one processes leader bounded amount time ensure timeliness requirement also satisfied 13 note specification tf implementable core timed model even one process allowed crash explain consider run r process communicate process cause datagram service drops messages one process l r leader construct run r 0 l always crashed r 0 r 0 indistinguishable r remaining processes therefore r 0 otherwise exist least two processes q r become leaders times respectively construct run r 00 indistinguishable r processes p q leaders point realtime since p q cannot communicate process r b communication time important fault tolerance one interesting question tt could implemented timefree systems since notion stability defined timefree systems sketch following alternative result instead tt implementable timed system hardware clocks removed even one process crash omission failures occur note processes access local hardware clocks cannot determine upper bound transmission delay messages leader enforce demotes within bounded time also known processes particu lar means interprocess communication like timefree model explicit messages thus proof sketched tf implementable timefree model also applies tt timed system model without hardware clocks thus essential understand access local clocks run within linear envelope realtime enables communication time processes allows us circumvent timed model impossibility result 29 stated timefree model c progress assumptions another observation tf deterministic solution core timed model implementable practical network workstations reason timed asynchronous system model allows principle runs system never stable actual systems one encounters practice make behavior extremely unlikely ffi oe well chosen mentioned earlier system likely alternate long stability periods relatively short instability periods describe systems therefore reasonable use progress assumption see section ivb2 assume existence j system infinitely often stable least j time units j progress assumption ensures solution tt elects leader infinitely often thus introduction progress assumption implies solution tt also solution tf service specifications defined asynchronous services implementable timed model always use conditional timeliness conditions never use termination conditions like tf general need progress assumptions enable implementation services conditional timeliness conditions timed asynchronous systems ie services implementable core timed system model furthermore progress assumptions reasonable local area systems necessarily valid wide area systems frequently partition long time thus included progress assumptions part cristian fetzer timed asynchronous distributed system model 15 core timed asynchronous system model vii conclusion given rigorous definition timed asynchronous system model based measurements reported previously performed network workstations dependable systems laboratory unpublished measurements labs aware believe timed asynchronous system model accurate description actual distributed computing systems particular believe set problems solvable timed model extended progress assumptions close approximation set problems solvable systems workstations linked reliable possibly local area based networks realworld applications soft realtime con straints hence applications need notion time neither original timefree model 21 extension failure detectors 3 provides models therefore necessarily adequate foundation construction applications soft realtime constraints timed model instead provides applications sufficiently strong notion time timed model also good foundation construction failsafe hard realtime applications see 17 12 r evaluating quorum systems internet impossibility group membership unreliable failure detectors asynchronous systems probabilistic clock synchronization understanding faulttolerant distributed systems synchronous asynchronous group communica tion atomic broad cast simple message diffusion byzantine agreement implementation performance stable storage service unix agreeing processorgroup membership asynchronous distributed systems consensus presence partial synchrony padre protocol asymmetric duplex redundancy highly available local leader service possibility consensus asynchronous systems approach construct failsafe applications system support fail aware realtime applications building faulttolerant hardware clocks impossibility distributed consensus one faulty process efficient faulttolerant mechanism distributed file cache consistency distributed computing models methods simulating synchronous processors time synchronization network time protocol modelling analysis computer network clocks simulating synchronized clocks common knowledge distributed systems failure mode assumptions assumption coverage election vs consensus asynchronous systems applied cryptography quasisynchronism step away traditional faulttolerant realtime system models highly parallel atomic multicast protocol tr ctr jeanfranois hermant grard le lann fast asynchronous uniform consensus realtime distributed systems ieee transactions computers v51 n8 p931944 august 2002 christof fetzer flaviu cristian failawareness approach construct failsafe systems realtime systems v24 n2 p203238 march robert miller anand tripathi guardian model primitives exception handling distributed systems ieee transactions software engineering v30 n12 p10081022 december 2004 roy friedman achour mostefaoui michel raynal asynchronous bounded lifetime failure detectors information processing letters v94 n2 p8591 ying zhao wanlei zhou elicia j lanham shui yu mingjun lan selfadaptive clock synchronization based clock precision difference proceedings twentysixth australasian conference computer science research practice information technology p181187 february 01 2003 adelaide australia yun wang emmanuelle anceaume francisco brasileiro fabola greve michel hurfin solving group priority inversion problem timed asynchronous system ieee transactions computers v51 n8 p900915 august 2002 christof fetzer perfect failure detection timed asynchronous systems ieee transactions computers v52 n2 p99112 february keidar sergio rajsbaum cost faulttolerant consensus faults preliminary version acm sigact news v32 n2 june 2001 ittai abraham gregory v chockler idit keidar dahlia malkhi byzantine disk paxos optimal resilience byzantine shared memory proceedings twentythird annual acm symposium principles distributed computing july 2528 2004 st johns newfoundland canada taisuke izumi akinori saitoh toshimitsu masuzawa adaptive timeliness consensus presence crash timing faults journal parallel distributed computing v67 n6 p648658 june 2007 keidar alexander shraer timeliness failuredetectors consensus performance proceedings twentyfifth annual acm symposium principles distributed computing july 2326 2006 denver colorado usa p v van der stok h janssenraemaekers realtime atomic multicast algorithms implemented shared memory multiprocessor realtime systems v24 n1 p5591 january roberto baldoni carlo marchetti threetier replication ftcorba infrastructures softwarepractice experience v33 n8 p767797 10 july jian yin jeanphilippe martin arun venkataramani lorenzo alvisi mike dahlin separating agreement execution byzantine fault tolerant services proceedings nineteenth acm symposium operating systems principles october 1922 2003 bolton landing ny usa shivakant mishra christof fetzer flaviu cristian timewheel group communication system ieee transactions computers v51 n8 p883899 august 2002 gregory chockler dahlia malkhi lightweight leases storagecentric coordination international journal parallel programming v34 n2 p143170 april 2006 christof fetzer flaviu cristian highly available local leader election service ieee transactions software engineering v25 n5 p603618 september 1999 massimo franceschetti jehoshua bruck group membership algorithm practical specification ieee transactions parallel distributed systems v12 n11 p11901200 november 2001 sandeep kulkarni ravikant stabilizing causal deterministic merge journal high speed networks v14 n2 p155183 april 2005 p cicotti taufer andrew chien dgmonitor performance monitoring tool sandboxbased desktop grid platforms journal supercomputing v34 n2 p113133 november 2005 paul ezhilchelvan francisco v brasileiro neil speirs timeoutbased message ordering protocol lightweight software implementation tmr systems ieee transactions parallel distributed systems v15 n1 p5365 january 2004 gregory v chockler idid keidar roman vitenberg group communication specifications comprehensive study acm computing surveys csur v33 n4 p427469 december 2001 xavier dfago andr schiper pter urbn total order broadcast multicast algorithms taxonomy survey acm computing surveys csur v36 n4 p372421 december 2004
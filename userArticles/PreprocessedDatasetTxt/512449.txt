accurate garbage collection uncooperative environment previous attempts garbage collection uncooperative environments generally used conservative mostlyconservative approaches describe technique fully typeaccurate garbage collection uncooperative environment using shadow stack link structs pointercontaining variables together data code needed trace implemented mercury compiler generates c code present preliminary performance data overheads technique also show technique extended handle multithreaded applications b introduction new programming language implementations usually need support variety dierent hardware architectures programmers demand portability programmers also demand eciency new programming language implementations often need eventually generate native code whether compile time traditional compiler run time jit compiler however implementing compiler backends jits generate ecient native code variety dierent hardware architectures dicult timeconsuming task furthermore considerable amount ongoing maintenance required generate ecient code new chip dierent performance characteristics new architecture programming language implementors try implement nativecode generators instead many programming language implementors reuse one existing backend frameworks one several ways generating another moreorless highlevel language java c generating intermediate language c 16 java bytecode msil intermediate language net common language runtime interfacing directly reusable backend gcc gnu compiler collection backend mlrisc permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee ismm02 june 2021 2002 berlin germany unfortunately however systems especially mature popular direct support garbage collection ones java msil draw backs poor performance available restricted set platforms implementing garbage collection systems direct support poses dicult challenges particular hard garbage collector trace system stack one widelyused solution problem garbage collection uncooperative environments approach using conservative 4 mostlyconservative 1 22 collec tion approach often deliver good performance however conservative collection drawbacks significant probabilistic nature conservative collection makes unsuitable highreliability applications also requires small degree cooperation backend certain compiler optimizations safe presence conservative collection another solution used compiling c 20 entirely avoid storing data c stack done implementing virtual machine stack registers implemented eg c global variables source language compiled code manipulates virtual machine state procedure calls parameter passing handled explicitly manipulating virtual machine stack registers rather using c function calls approach collector needs trace virtual machine stack c stack since source language compiler full control virtual machine stack tracing stack relatively straightforward traditional techniques accurate garbage collection used approach also advantage overcome drawbacks c eg lack support proper tail recursion optimization 5 however approach discards many advantages compiling highlevel language 13 source language compiler must stack slot register allocation generated c code lowlevel make code ecient nonportable features must used 14 resulting system complex fragile furthermore use dierent calling convention makes interoperability dicult propose alternative approach allows fully type accurate livenessaccurate garbage collection thus allowing use normal copying collector without requiring support backend target language still generating code uses normal c function calling mechanism describe approach context compiling c although would also work equally well interfacing directly compiler backend framework gcc backend technique formulated transformation generated c code modifies c code way insert calls perform garbage collection nec essary provide garbage collector sucient information trace necessary update pointers c stack transformation entirely independent frontend language however requires information source language frontend compiler trace local variable implemented technique mercury com piler run number benchmarks implementation investigate overheads performance technique section 2 describes technique showing code transformed explaining avoids dicul ties compiler optimizations cause problems conservative collection section 3 describes technique extended support multithreaded applica tions section 4 evaluates performance technique section 5 discusses related work 2 gc transformation basic idea put local variables might contain pointers structs one struct stack frame chain structs together linked list keep global variable points start chain gc time traverse chain structs allows us accurately scan c stack function generate struct function struct starts substruct containing couple fixed fields allow gc traverse chain struct function nameframe struct stackchain fixedfields fixed fields follows struct stackchain struct stackchain prev void tracevoid locals prev field holds link entry functions caller trace field address function trace everything pointed stack frame ensure garbage collector try traverse uninitialized fields insert code zeroinitialize uninitialized fields struct inserting chain need keep link topmost frame stack two possible ways could handled one way pass parameter function would get extra parameter stack chain points callers struct alternative approach global variable stack chain points top stack extern void stackchain insert extra code set pointer entering returning functions make approach thread safe variable would actually need threadlocal rather global approach would probably work best variable gnu c global register variable would make ecient threadsafe gnu c extensions available function parameter approach probably best implementation mercury compiler currently using global variable simplicity 21 example function rettype fooarg1type arg1 arg2type arg2 local1type local1 bararg1 arg2 local1 local2 new object allocation primitive allocates garbage collected objects say arg1type local1type might contain pointers arg2type dont would transform follows struct fooframe stackchain fixedfields arg1type arg1 static void footracevoid frame struct fooframe code trace localsarg1 localslocal1 rettype fooarg1type arg1 arg2type arg2 struct fooframe locals localsfixedfieldstrace barlocalsarg1 arg2 localslocal1 local2 stackchainprev following goldbergs approach tagfree garbage collection strongly typed languages 11 trace arg1type trace local1type typespecific garbage collection routines generated frontend compiler however unlike goldberg primarily interested adapting approach uncooperative environment technique would apply equally well using tagged representation case single trace object function would needed instead one type using tabledriven approach 7 rather function per frame case trace field stackchain struct would data table rather function pointer finally code runtime system traverse stack frames follows void traversestackstruct stackchain stackchain stackchain null details new object depend particular garbage collection algorithm chosen implementation new object first checks heap exhaustion allocates memory incrementing global heap pointer extern byte heappointer define newobjecttypesize heappointer size type heappointer gc check compares global heap pointer another global variable points end heap calls garbage collect heap near exhaustion extern byte heapgcthreshold define gcchecksize heapgcthreshold well known possible reduce overhead checking heap exhaustion combining multiple checks single check however current implementation perform optimization garbage collect routine current implementation implements simple copying collector 21 byte fromheap byte toheap void garbagecollectvoid swap heap heap byte tmp reset heap copy live objects heap heap note keep separate list global roots used global variables might contain pointers addition stack chain list 22 safety might ask doesnt technique suer problems backend compiler optimization cause trouble conservative collection reason technique works going behind backend compilers back everything done strictly conforming c code conservative collectors use nonportable techniques trace stack approach collector trace stack traversing linked list structs although code contains pointer casts behaviour casts defined c standard backend compiler cannot unsafe optimizations pointer variables localsarg1 localslocal1 weve stored address locals global variable must assume call function whose body known might update fields locals course inhibiting optimizations way twoedged sword advantage ensures correct ness disadvantage hurts performance backend compiler free perform function inlining outlining matter shadow stack linked structs need direct relationship stack frames underlying machine code backend compiler whatever fancy optimizations wants nonpointer variables arg2 local2 cache values pointer variables localsarg1 localslocal1 registers function calls appropriate alias analysis general cannot cache values pointer variables registers across calls noninlined functions significant impact performance key contribution work measure impact performance transformation 23 improvements scheme described naive certain respects several ways scheme opti mized rather putting variables might contain pointers shadowstack structs sucient variables going live across point garbage collection could occur ie live across allocation function call another optimization bother allocating struct leaf functions contain functions calls memory allocations another possible optimization would use local variables cache fields shadowstack struct referenced multiple times sequence code garbage collection could occur c compiler could allocate local variables registers one optimizations implemented current implementation allocating structs functions pointercontaining variables 24 nested scopes livenessaccuracy issue yet discussed handle variables declared nested scopes within function one way handle ignore nesting put pointercontaining variables struct regardless scope requires first ensuring function contains two declarations variable name dierent types dierent scopes eg renaming apart needed approach one used current implementation two drawbacks first extending lifetime variables whole function may increase stack usage second since collector scan may turn also lead unnecessary heap retention second drawback could solved inserting code zero variables scope exited otherwise statically known dead would ensure collector livenessaccurate respect liveness local variables c code applying transformation note variables represented local variables final c code would case using conservative collector might help add code assign zero end lifetime since c compiler could optimize away assignments approach variables represented fields locals struct whose address taken stored global variable safe unwanted optimizations another way handle nested scopes would use unions ensure storage pointercontaining variables declared nonoverlapping scopes shared however order collector able trace unions would need store discriminant union recorded scope active trace function would know union element trace code would need inserted initialize discriminants function entry set corresponding discriminant entryexit nested scope third way handle nested scopes would treat nested scope separate stack frame pointer containing variables allocated separate struct nested scope would require adding code entry nested scope link corresponding struct stack chain list adding code exit points remove chain second third alternatives collector would degree livenessaccurate sense variables would definitely scanned scope exited however proper static livenessaccuracy desired pointercontaining variables statically known die scope exited additional code would need inserted zero variables point death last use variable function call argument implies copying variable stack frame struct local tempo rary zeroing stack frame struct field using local temporary call zeroing stack frame struct field call would late 3 multithreading system also extended support multithreading using stop world approach collection fairly straightforward manner little additional overhead stop world approach means garbage collection occurs every mutator thread must advance safe point stop executing program mutator threads stopped safe point garbage collection begin collector either sequential parallel single multithreaded important thing approach collector never runs parallel mutator case safe points calls garbage collect avoid need synchronization allocations separate area free heap space thread stack chain heap pointer heap gc threshold variables need made threadlocal one thread runs free heap space schedule garbage collection setting heap gc threshold variables every thread point sentinel value start heap cause threads enter garbage collection function next invoke gc check garbage collection function handle necessary synchronization threads ensure thread invoke gc check within bounded amount time compiler need insert additional call gc check body longrunning loops heap allocation operating systems calls block also need special handling space limits prevent us elaborating point mentioned earlier stack chain heap pointer gcc global register variables remains case even multithreading however heap gc threshold cannot put register needs addressable assigned threads addition modified threads needs declared volatile summarize changes required support multithreading extra synchronization code inside garbage collection volatile qualifier heap gc threshold variables extra calls gc check loops dont heap allocation special han program lines number execution time ratios seconds hlcgc hlcagc hlcagc code iterations hlc hlcgc hlcagc hlc hlc hlcgc cqueens 91 35000 070 129 128 184 183 099 crypt 132 20000 272 506 500 186 184 099 deriv 126 70000 015 075 079 500 527 105 poly 259 1200 057 289 337 507 591 117 primes 78 30000 112 203 258 181 230 127 qsort 64 100000 083 268 311 323 375 116 queens 85 100 231 478 455 207 197 095 query 96 30000 392 395 409 101 104 104 tak harmonic mean 199 208 106 figure 1 benchmark results dling os calls may block extra synchronization code garbage collection may somewhat costly collections frequent amortized cost small loops dont heap allocation also likely rare cases cost extra gc check per loop iteration relatively small loop small cost checking amortized multiple loop iterations performing loop unrolling prior inserting extra gc checks finally cost special handling needed blocking os calls likely small comparison cost system call hence expect overall technique little additional overhead compared singlethreaded version since c standard support multithread ing possible strictly conforming c addition functions creating synchronizing threads provided posix threads approach described also requires assignments volatile threadlocal pointer variables heap gc threshold atomic technically guaranteed c posix standards current platforms make assignments appropriately aligned pointers atomic pretty portable practice 4 performance benchmark machine gateway select 1200 pc 1200mhz amd athlon cpu 64kb l1 instruction cache 64kb l1 data cache 256k l2 cache 256mb ram running debian gnulinux woody testing gnu libc 21 gcc 2954 mercury rotd 20020419 benchmark compiled mmc o5 noreclaimheaponfailure nodeforestation times shown best three successive runs unloaded machine used set small benchmarks previously used benchmarking mercury implementations 18 since time many benchmarks small ran benchmark many iterations measured total time execute iterations ideally would better test larger benchmarks current implementation yet support full mercury language higherorder code type classes supported tracing closures yet im plemented makes dicult find large benchmark programs work implementation compared three variants grades mercury compiler hlc grade allocates memory incrementing heap pointer described paper code test heap overflow instead performing garbage collection memory reclaimed resetting heap pointer iteration benchmark realistic memory management strategy real applications represents useful baseline hlcgc grade uses boehm et al conservative collector 4 hlcagc uses accurate garbage collection technique described paper collector simple twospace copying collector heap size used 128k per space ie 256k total results shown figure 1 benchmarks conservative collector little faster accurate collector accurate collector slightly faster averaged benchmarks conservative collector 6 faster conservative collector accurate collector much slower version resets heap pointer benchmark iteration profiling indicates hlcagc grade little time less 1 spent garbage collection function slowdown compared hlc grade probably results decreased locality overhead storing local pointer variables stack rather registers given boehm collector years tweaking tuning whereas implementation yet well optimized eg yet use gcc global register variables consider reasonable result conjecture additional work optimization approach achieve performance good boehm collector benchmarks increased portability reliability approach make desirable uses regardless whether performance advantage one way current implementation yet obtained main benefit logic programming languages copying collector namely copying collectors allow cheap heap reclamation backtracking saving restoring heap pointer requires additional care garbage collector update saved heap pointers garbage collection yet implemented properly 5 related work accepted wisdom community conservative collection approach works uncooperative environments example highly experienced respected language implementor robert dewar wrote cant kind type accurate gc without information compiler back end noting tagged architectures cdc 6000 excep 6 similarly garbage collection faq 10 david chase states compiling c c relocation objects generally possible even active pointers registered compilergenerated temporaries may also reference objects however certainly problem technique explained section 22 section faq best misleading big part contribution paper dispute accepted wisdom demonstrating possible implement fully typeaccurate garbage collection within environment lot earlier work literature addresses issues quite close issues address using dierent techniques uses similar techniques dierent purpose boehm 4 bartlett 1 yip 22 address issue uncooperative environments use conservative mostlyconservative collection rather accurate collec tion boehm chase 2 3 address issue safety conservative garbage collection presence compiler optimizations shadow stacks used debugging berkeley sather 19 implementation cdb 12 systems use shadow stacks garbage collection berkeley sather uses boehm et al conservative collector shadow stacks used handcoded garbage collection several systems aware particular emacs gcc rt 8 9 17 systems unlike code register local variables inserted manually shadow stack list array individual variables rather list frames systems perhaps closest interested automating technique part programming language implementa tion rather using implement garbage collection library language manual memory management far know published work comparing performance handcoded shadow stack approaches conservative collection far aware none published work addresses multithreading tarditi et al 20 describe ml c compiler supports accurate garbage collection however compiler works emulating virtual machine rather using normal c calling convention drawbacks mentioned introduction glasgow haskell compiler 15 accurate garbage collection compile via gnu c relies highly nonportable techniques involve munging generated assembler file gnu c backend finished success techniques relies continued cooperation backend compiler c 16 portable assembly language supports garbage collection another approach relies cooperation backend compiler variety dierent garbage collection techniques marksweep collection copying collection address issue locate roots stack 6 conclusions presented scheme performing accurate garbage collection uncooperative environment simple transformation code passed uncooperative compiler backend framework implemented scheme mercury compiler measured per formance similar boehm al conservative collector 4 benchmarks even though several important optimizations yet implemented also described scheme extended handle multithreaded applications source code system freely available web httpwwwcsmuozaumercurydownload rotdhtml acknowledgments would like thank tom lord comments gcc mailing list advantages precise collection zoltan somogyi andreas rossberg tyson dowd ralph becket jon delloro anonymous referees comments earlier drafts paper microsoft australian research council financial support 7 r simple garbagecollectorsafety proposal garbagecollectorsafe c compilation garbage collection uncooperative environment proper tail recursion space e mail gcc mailing list david je copying collector c dynamic storage reclamation c machineindependent debugger compiling mercury highlevel c code compiling logic programs c using gnu c portable assembler peyton jones execution algorithm mercury sather revisited highperformance free alternative c assembly required compiling standard ml c uniprocessor garbage collection techniques tr garbage collection uncooperative environment tagfree garbage collection strongly typed programming languages simple garbagecollectorsafety machineindependent debugger proper tail recursion space efficiency uniprocessor garbage collection techniques run time type information mercury c compiling mercury highlevel c code dynamic storage reclamation c ms thesis ctr martin hirzel amer diwan johannes henkel usefulness type liveness accuracy garbage collection leak detection acm transactions programming languages systems toplas v24 n6 p593624 november 2002 andreas bauer creating portable programming language using open source software proceedings usenix annual technical conference 2004 usenix annual technical conference p4040 june 27july 02 2004 boston
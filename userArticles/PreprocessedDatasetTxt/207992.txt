complexity distribution hard problems measuretheoretic aspects leqrm prm mreducibility structure exponential time complexity classes edtime2rm linear e2rm dtime2rm polynomial investigated particular attention given complexity measured size complexity cores distribution abundance sense measure languages leqrm prm mhard e complexity classes tight upper lower bounds size complexity cores hard languages derived upper bound says leqrm prm mhard languages e unusually simple sense smaller complexity cores languages e follows leqrm prm mcomplete languages e form measure 0 subset e similarly e2 latter fact seen special case general theorem namely every pmrdegree eg degree pmrcomplete languages np measure 0 e ep b introduction decision problem ie language f0 1g said hard complexity class c every language c efficiently reducible also element c complete c common interpretation efficiently reducible polynomial time manyone reducible abbreviated p reducible see section 2 notation terminology used introduction example usages npcomplete means complete np completeness notion introduced karp 15 levin 16 research supported part national science foundation grants ccr8809238 ccr 9157382 matching funds rockwell international microware systems corporation part center discrete mathematics theoretical computer science dimacs second author visitor part work carried paper investigate complexity measured size complexity cores distribution ie abundance sense measure languages p equivalently classes including np measure mean resourcebounded measure developed lutz 17 described section 3 present paper give tight lower bound perhaps surprisingly tight upper bound sizes complexity cores hard languages generally analyze measuretheoretic aspects p reducibility structure exponential time complexity classes prove p hard problems rare sense form pmeasure 0 set also prove every p degree measure 0 exponential time complexity cores first introduced lynch 24 studied extensively 8 9 10 11 12 14 27 28 29 etc intuitively complexity core language fixed set k inputs every machine whose decisions consistent fails decide efficiently finitely many elements k meaning efficiently parameter definition varies according context see section 4 precise definition orponen schoning 28 established two lower bounds sizes complexity cores hard languages first every p hard language e dense pcomplexity core second p 6 np every p hard language np nonsparse polynomial complexity core section 4 extend first results languages weakly p hard e language p hard e every element e p reducible language weakly p hard e every element nonnegligible ie nonmeasure 0 set languages e reducible recently lutz 21 proven weakly hard general p specifically prove every language weakly p hard e e 2 dense exponential complexity core follows np measure 0 e e 2 every p hard language np dense exponential complexity core conclusion much stronger orponen schonings conclusion every language nonsparse polynomial complexity core though achieved cost stronger hypothesis hypothesis originally proposed lutz discussed length 20 22 23 section 5 investigate resourcebounded measure lower p spans spans p degrees languages e e 2 lower p span set languages p reducible upper p span set languages p reducible p degree intersection two spans prove small span theorem says e e 2 least one upper lower spans must resourcebounded measure 0 implies every p degree eg degree p complete languages np measure 0 e e 2 also implies p hard languages e form set pmeasure 0 noted section 7 proof latter fact holds p replaced p would imply e 6 bpp languages p hard e typically considered least complex element e early berman 6 established limits interpretation proving p complete language pimmune even though e contains pimmune languages fact mayordomo 25 recently shown almost every language e pbiimmune section 6 prove strong limitation complexity p hard languages e prove every p hard language e decidable steps dense set inputs also decidable 2 4n steps implies every dtime2 4n complexity core every p hard language e dense complement since almost every language e f0 1g dtime2 4n complexity core proven section 4 says p hard languages e unusually simple unusually small complexity cores intuitively interpret mean condition p hard e forces language high level organization thereby forcing unusually simple respects preliminaries present notation terminology use throughout paper begin write n set natural numbers z set integers z set positive integers deal primarily strings languages functions classes strings finite sequences characters alphabet f0 1g write f0 1g set strings languages sets strings functions usually map f0 1g f0 1g class either set languages set functions x 2 f0 1g string write jxj length x f0 1g language write c f0 1g gamma f0 1g n f0 1g n respectively sequence strings f0 1g referred standard enumeration f0 1g use stringpairing function hx bdx01y bdx x bit doubled eg define function say property oen natural numbers holds almost everywhere ae oen true finitely many n 2 n similarly oen holds infinitely often io oen true infinitely many n 2 n write boolean value condition oe finite set denote cardinality jaj language dense exists constant ffl 0 ae language sparse exists polynomial p js n j pn ae language cosparse c sparse machines deterministic turing machines language accepted machine denoted lm partial function computed machine denoted fixed machine function timem x represents number steps uses input x tn time bound write set languages decidable otn time similarly write set functions computable otntime classes polynomial time decidable languages polynomial time computable functions respectively especially interested classes languages decidable exponential time write classes languages decidable 2 linear time 2 polynomial time respectively complexity classes use np ph pspace etc completely standard definitions 2 3 b languages polynomial time manyone reduction briefly p reduction b function f 2 pf bg reduction function f 2 pf p reduction language b note f p reduction f p reduction ag say polynomial time manyone reducible briefly p reducible b b exists p reduction f b case also say language h p hard class c languages p language c p complete c c 2 c c p hard c usual notion npcompleteness13 paper especially concerned languages hard p 3 resourcebounded measure resourcebounded measure 17 19 general theory whose special cases include classical lebesgue measure measure structure class rec recursive languages measure various complexity classes paper interested measure e e 2 discussion measure specific classes interested reader may consult section 3 17 discussion examples throughout section identify every language f0 1g characteristic sequence 2 f0 1g 1 defined n recall section 2 standard enumeration f0 1g say x 2 f0 1g prefix partial specification f0 1g x prefix ie exists 2 f0 1g 1 xy case write x v set languages x partial specification cylinder specified string x 2 f0 1g say measure set c x 2 gammajxj note probability 2 c x f0 1g chosen probabilistically according random experiment independent toss fair coin used decide membership string x 2 f0 1g notation classes consisting functions f defined follows computable polynomial timeg computable n log n o1 timeg measure structures e e 2 developed terms classes p 2 definition density function function f0 1g 0 1 satisfying w 2 f0 1g global value density function set covered density function w2f01g density function covers set x f0 1g 1 x sd density functions paper equality actually holds 31 required consider random experiment language f0 1g chosen using independent toss fair coin decide whether string x 2 f0 1g taken together parts 31 32 definition imply pra 2 experiment intuitively regard density function detailed verification pra 2 x sets x sd generally interested uniform systems density functions computable within resource bound since density functions realvalued computations must employ finite approximations real numbers purpose let set dyadic rationals rational numbers finite binary expansions order uniform criteria computational complexity consider functions sets x n f0 1g cartesian product sets really map f0 1g f0 1g example function f n theta formally interpreted function interpretation means binary representations integer fractional parts q respectively moreover care values f arguments form h0 insist values form h0 k hu vii arguments ndimensional density system nds function k density function every k 2 n n sometimes convenient regard density function 0ds computation nds function k 2 n n r 2 n w 2 f0 1g computation nds computation computable exists nds n n theta f0 1g 2 p trivially computable fortunate circumstance need compute approxima tions occurs frequently practice applications typically involve approximations hidden invoking fundamental theorems whose proofs involve approxima tions come key idea resourcebounded measure theory definition null cover set x f0 1g 1 1ds k 2 n k covers x global value k 2 gammak x null cover x words null cover x uniform system density functions cover x rapidly vanishing global value easy show set x f0 1g 1 classical lebesgue measure 0 ie probability 0 cointossing experiment exists null cover x definition set x p measure 0 write exists p null cover x set x p measure 1 write p thus set x p measure 0 p provides sufficient computational resources compute uniformly good approximations system density functions cover x rapidly vanishing global value turn internal measure structures classes definition set x measure 0 e write x set x measure 1 e write x say almost every language e x indicate x measure 0 e note assert xje nonzero value following obvious useful fact 31 every set x f0 1g 1 probability pra 2 x computed according random experiment language f0 1g chosen probabilistically using independent toss fair coin decide whether string x 2 f0 1g shown 17 definitions endow e e 2 internal measure structure structure justifies intuition negligibly small subset e similarly e 2 next two results state aspects structure especially relevant present work theorem 32 17 cylinders cw cw je 6 0 cw particular next lemma used proving theorem 43 lemma 52 involves following computational restriction notion countable union union z j exists p computable 2ds j p null cover z j lemma 33 17 let 2 f1 2g let z z z p union 4 complexity cores lower bounds orponen schoning 28 shown every p hard language e dense polynomial complexity core section extend result proving every weakly p hard language e dense exponential complexity core begin explaining terminology given machine input x 2 f0 1g write accepts x rejects x case ie fails halt halts without deciding x mx 2 f0 1g write timem x number steps used computation mx partially order set f0 1 g machine consistent language f0 1g mx n time bound let k f0 1g k dtimetncomplexity core every c 2 n every machine consistent fast set definition timem x mx 2 f0 1g x 2 f thus f set strings decides efficiently remark definition quantifies machines consistent standard definition complexity cores cf 3 quantifies machines decide recursive languages timeconstructible bounds easy see definition exactly equivalent standard definition however definition stronger standard definition recursive example consider tally languages ie languages f0g definition every dtimencomplexity core k every tally language must satisfy 1 however standard definition complexity cores defined recursive sets 3 else every set k f0 1g vacuously complexity core every nonrecursive language tally otherwise thus quantifying machines consistent definition makes notion complexity core meaningful nonrecursive languages enables one eliminate extraneous hypothesis recursive several results cases improvement little interest however section 6 show every hard language h e unusually small complexity cores upper bound holds regardless whether h recursive note every subset dtimetncomplexity core dtimetn complexity core note also otn every dtimetncomplexity core dtimesncomplexity core 1 k polynomial complexity core briefly pcomplexity core k dtimen k complexity core k 2 n 2 k exponential complexity core real number ffl 0 k dtime2 n ffl complexity core much work uses languages incompressible manyone reductions idea originally exploited meyer 26 following definitions develop notion definition collision set function f f0 1g f0 1g using standard ordering note f onetoone c almost everywhere briefly onetoone ae collision set c f finite reduction b function f 2 dtimeft ie x 2 f0 1g x 2 iff reduction function f dtimet reduction fa easy see f dtimet reduction exists language b f dtimet reduction b language f0 1g incompressible dtimet reductions every dtimet reduction onetoone ae language f0 1g incompressible p reductions incompressible dtimeq reductions polynomials q intuitively f dtimet reduction b c f large f compresses many questions x 2 fewer questions f x 2 b incompressible p reductions little compression occur first observation obvious generalization result balcazar schoning 4 see corollary 42 relates incompressibility complexity cores lemma 41 n n time constructible every language incompressible dtimet reductions f0 1g dtimetcomplexity core proof let language f0 1g dtimetcomplexity core suffices prove incompressible dtimet reductions clear assume 6 6 f0 1g fix u 2 v 2 c since f0 1g dtimetcomplexity core exist c 2 n machine consistent fast set infinite define function f f0 1g f0 1g x otherwise since timeconstructible f 2 dtimeft since consistent f dtimet reduction since f infinite least one sets f collision set c f infinite thus incompressible dtimet reductions 2 corollary 42 let c 2 n 1 balcazar schoning 4 every language incompressible p reductions f0 1g pcomplexity core 2 every language incompressible dtime2 cn reductions f0 1g 3 every language incompressible dtime2 n c reductions f0 1g complexity core 2 prove e almost every language incompressible dtimet reductions exponential time bounds theorem 43 let c 2 z define sets incompressible dtime2 cn incompressible dtime2 n c almost every language e incompressible dtime2 cn reductions almost every language e 2 incompressible dtime2 n c reductions proof let c 2 z prove 1 proof p 2 analogous function universal dtimef2 cn sense 2 n define set z languages follows collision set c f finite infinite z set languages f reduction define function n theta n theta f0 1g 0 1 follows let 1g ik ik fix least j 2 n f ik clear 2ds since f 2 dtimef2 c1n computation ik w uses values f u strings u also clear 2 p pcomputable 2ds show z sd ik finite clear assume c f infinite let 2 z let w string consisting first l bits characteristic sequence lgamma1 k th element c f choice l ensures clause iii definition invoked exactly k times recursive computation ik w since f dtime2 cn reduction 2 z k invocations ik thus 2 cw sd ik confirms z sd ik follows easily 2 n pnull cover z implies punion pmeasure 0 sets whence corollary 44 almost every language e almost every language e 2 incompressible p reductions 2 corollary 45 meyer26 language 2 e incompressible p reductions 2 corollary 46 let c 2 z 1 almost every language e f0 1g dtime2 cn complexity core 2 almost every language e 2 f0 1g dtime2 n c complexity core 2 consider complexity cores p hard languages starting point following two known facts fact 47 orponen schoning 28 every language p hard e equivalently dense pcomplexity core fact 48 orponen schoning 28 p 6 np every language p hard np nonsparse pcomplexity core first extend fact 47 need definition lower p span language f0 1g ie set languages lying p reducibility structure set languages recall language p hard complexity class c c pm definition language f0 1g weakly p hard e respectively e language f0 1g weakly complete e respectively weakly thus language weakly p hard e nonnegligible subset languages p reducible recently lutz 21 established existence languages weakly p complete p complete e similarly although hard e p hard equivalent know relationship weakly p hard e weakly p recall language f0 1g dense real number ffl 0 ae theorem 49 every language weakly p hard e e 2 dense exponential complexity core proof prove e proof e 2 identical let h language weakly p hard e pm h measure 0 e theorem 43 language 2 pm h incompressible reductions let f p reduction h let q strictly increasing polynomial bound time required compute f let 3deltadegq language complexity core hlutz proposed investigation consequences strong hypotheses e 6 0 np regard following corollary 410 np j e 6 0 np hard language np dense exponential complexity core 2 thus example np small dense set k boolean formulas conjunctive normal form every machine consistent sat performs exponentially badly either running 2 jxj ffl steps failing decide finitely many inputs x 2 k note theorem 49 extends fact 47 corollary 410 stronger hypothesis stronger conclusion fact 48 note also corollary 410 holds np replaced ph pp pspace class whatsoever following result shows density bounds theorem 49 corollary 410 tight theorem 411 every ffl 0 classes np e e 2 p language every pcomplexity core k satisfies jkn ae proof let ffl 0 let c one classes np e e 2 let language complete c let ffl e define language b p complete c every pcomplexity core k b satisfies jkn ae5 measure degrees section prove p degrees measure 0 complexity classes e fact follow small span theorem prove first recall lower p span language f0 1g similarly define upper p span p degree deg p intersection upper lower spans main result section e e 2 least one spans small theorem 51small span theorem 1 every 2 e 2 every 2 first use following lemma prove theorem 51 prove lemma lemma 52 let language incompressible p reductions 1 2 e 2 proof theorem 51 prove 1 let 2 e let x set languages incompressible reductions two cases case us pm j e 0 case ii lemma 52 tells us b follows proves 1 proof 2 identical 2 proof lemma 52 prove 1 let 2 e incompressible p reductions let f 2 dtimef2 n function universal pf sense 2 n define set z languages follows collision set c f infinite finite note incompressible p reductions define function n theta n theta f0 1g 0 1 follows let 1g ik ii j 2jwj f iii exists j 2jwj f fix least j set ik clear 2ds also since f 2 dtimef2 n 2 e easy see whence pcomputable 2ds show z sd ik infinite clear assume jc f string consisting first l bits characteristic sequence b l large enough consider computation ik v clauses ii iii since p via f clause iii cause ik w 0 prefix w v let clause iii doubles density whenever jwj 2 also putting together whence shows z sd ik since pcomputable ik pnull cover z implies p gamma1 punion pmeasure 0 sets z follows lemma 33 completes proof 1 proof 2 identical one need note remark ambosspies 1 shown pm lebesgue measure 0 whenever 62 p lemma 52 obtains stronger conclusion resourcebounded measure 0 stronger hypothesis straightforward derive consequences results structure e first note p hard languages e extremely rare theorem 53 let set languages p hard e proof let corollary 45 lemma 52 tells us 0theorem 53 immediately yields alternate proof following result corollary 54 mayordomo25 let ce ce 2 sets languages p mayordomos proof corollary 54 used bermans result 6 p language e pimmune turns corollary 54 special case following general result degrees measure 0 e e 2 theorem 55 f0 1g deg p proof let f0 1g prove deg p proof deg p 0 identical fact simpler e 2 closed p deg p holds trivially assume deg p theorem 51 deg p deg p following two corollaries np corollary 56 let hnp set languages p hard np 1 np j e 6 0 hnp 2 np proof follows immediately theorem 51 corollary 57 let cnp set languages p complete np cnp proof since sat follows immediately theorem 55 2 interesting note corollary 57 unlike corollary 56 absolute result requiring unproven hypothesis price pay know holds example small span theorem tells us e hnp j e 0 np j e 0 tell us two different situations occurs note corollaries 56 57 also hold np replaced class whatsoever conclude section noting two respects small span theorem cannot improved first hypotheses 2 e 2 e 2 essential parts 1 2 respectively example prandom 18 p fag 6 0 none deg p second respect small span theorem cannot improved involves variety smallspan configurations e e 2 either one upper lower spans language fact small give examples e well known 26 language 2 e sparse incompressible p reductions fix language lemma 52 also since sparse main result 22 implies p pm b 2 e 6 0 c p complete e p gamma1 theorem 53 e 6 0 similar examples given 6 complexity cores upper bound section give explicit upper bound sizes complexity cores languages p hard e bound implies p complete languages e unusually small complexity cores languages e theorem 61 every p hard language h e exist bd 2 dtime2 4n dense proof corollary 45 language e incompressible p reductions fact meyers construction 26 shows language 2 dtime5 n incompressible p reductions fact 47 theorem 49 idea often used establish lower bounds complexities p languages use establish upper bound following simple notation useful nonreduced image language f0 1g function f f0 1g f0 1g note f let h p hard e p reduction f h let clear bd 2 fix polynomial q real number ffl 0 jfxj qjxj x 2 f0 1g qn 2ffl x sufficiently large n 2 n writing whence sufficiently large n thus dense finally note completes proof theorem 61 use theorem 61 prove upper bound size complexity cores hard languages theorem 62 every dtime2 4n complexity core every p hard language e dense complement proof let h p hard e let k dtime2 4n complexity core h choose bd h theorem 61 fix machines mb md decide b respectively timemb machine implements following algorithm begin input x md x accepts simulate mb x else run forever consistent h also constant c 2 n x 2 since k dtime2 4n complexity core h follows k finite dense implies gamma k dense whence k c dense 2 note theorem 53 follows corollary 46 theorem 62 theorem 62 tells us main construction 21 shows every c 2 n language h weakly p hard e f0 1g dtime2 cn complexity core thus contrast lower bound given theorem 49 upper bound given theorem 62 cannot extended weakly p languages finally note upper bound given theorem 62 tight theorem 63 let c 2 n 0 1 e p complete language dtime2 cn complexity core k satisfies ae 2 e 2 p complete language dtime2 n c complexity core k satisfies ae proof prove result e proof e 2 similar let language p e corollary 46 fix language f0 1g dtime2 cn complexity core let define languages clear c p complete e also sufficiently large n ae complete proof showing k dtime2 cn complexity core c let 2 n let machine consistent c define fast set suffices prove jk machine designed obvious way 2 f0 1g 62 consistent consistent c f0 1g dtime2 cn complexity core b fast set ag finite since k f finite follows jk completing proof 2 7 conclusion paper investigated measuretheoretic aspects p reducibility structure exponential time complexity classes e e 2 among things proven following simplicity consider class e every weakly p hard language e dense exponential complexity core orem 49 ii every language 2 e least one spans pm p resourcebounded theorem 51 small span theorem thus p languages e form pmeasure 0 set theorem 53 every p degree measure theorem 55 p complete languages np form set measure 0 e corollary 57 iii every dtime2 4n complexity core every p hard language e dense complement theorem 62 since almost every language e f0 1g dtime2 4n complexity core corollary 46 says e p complete languages unusually simple sense unusually small complexity cores reasonable conjecture results hold p replaced p investigating may difficult example consider theorem 53 bennett gill 5 shown p gamma1 classical measure 1 2 bpp thus cannot prove p hard languages e form measure 0 set without also proving e 6 bpp r structural complexity structural complexity ii relative random oracle structure complete sets almost everywhere complexity infinitely often speedup isomorphism density np complete sets existence density generalized complexity cores generalized complexity cores levelability intractable sets inefficient special cases npcomplete problems hard core theorems complexity classes computers intractability guide theory npcompleteness solving hard problems polynomialsize circuits reducibility among combinatorial problems universal sequential search problems almost everywhere high nonuniform complexity intrinsically pseudorandom sequences quantitative structure exponential time weakly hard problems cook versus karplevin separating completeness notions np small reducibility complex sparse sets almost every set exponential time pbiimmune reported classification complexity core lattices density complexity polynomial cores intractable sets tr ctr olivier powell note measuring p theoretical computer science v320 n23 p229246 june 14 2004 klaus ambosspies wolfgang merkle jan reimann sebastiaan terwijn almost complete sets theoretical computer science v306 n13 p177194 5 september john hitchcock size spp theoretical computer science v320 n23 p495503 june 14 2004 christian glaer mitsunori ogihara pavan alan l selman liyu zhang autoreducibility mitoticity immunity journal computer system sciences v73 n5 p735754 august 2007 lane hemaspaandra sigact news complexity theory column 48 acm sigact news v36 n3 september 2005
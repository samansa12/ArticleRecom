safe metaclass programming system classes treated first class objects classes defined instances classes called metaclasses important benefit using metaclasses ability assign properties classes eg abstract final tracing particular messages supporting multiple inheritance independently baselevel code however inheritance instantiation explicitly simultaneously involved communication classes instances raises metaclass compatibility issue languages smalltalk address issue easily allow assignment specific properties classes contrast languages clos allow assignment specific properties classes tackle compatibility issue wellin paper describe new model metalevel organization called compatibility model overcomes difficulty allows safe metaclass programming since makes possible assign specific properties classes ensuring metaclass compatibility therefore take advantage expressive power metaclasses build reliable software extend compatibility model order enable safe reuse composition class specific properties extension implemented neoclasstalk fully reflective smalltalk b introduction shown programming metaclasses great benefit kaj interesting use metaclasses assignment specific properties classes example class abstract unique instance trace messages received instances define prepost conditions methods forbid redefinition particular methods properties implemented using metaclasses allowing thereby customization classes behavior lc96 architectural point view using metaclasses organizes applications abstraction levels level describes controls level immediately causally connected mae87 reified classes communicate objects including instances thus classes send messages instances instances send messages classes message sending named interlevel communication mmc95 however careless inheritance one level may break interlevel communication resulting issue called compatibility issue bslr96 identified two symmetrical kinds compatibility issues first one upward compatibility issue named metaclass compatibility nicolas graube gra89 second one downward compatibility issue kinds compatibility issues important impediments metaclass programming one always aware currently none existing languages dealing metaclasses allow assignment specific properties classes ensuring compatibility clos kdrb91 allows one assign property classes ensure compatibility hand som som93 smalltalk gr83 address compatibility issue introduce class property propagation problem indeed property assigned class automatically propagated subclasses therefore som small talk class cannot specific property example assigning abstractness property given smalltalk class subclasses become abstract bc89 follows users face dilemma using language allows assignment specific class properties without ensuring compatibility using language ensures compatibility suffers class property propagation problem paper present model compatibility model allows safe metaclass program ming ie makes possible assign specific properties classes without compromising compatibility addition ensuring compatibility compatibility model avoids class property propagation class assigned specific properties without sideeffect subclasses implemented compatibility model neoclasstalk smalltalk extension introduces many features including explicit metaclasses riv96 experiments led98riv97 showed compatibility model allows programmers fully take advantage expressive power metaclasses effort resulted tool permits programmer unfamiliar metaclasses transparently deal class specific properties ii approach allowing reuse composition class properties paper organized follows section 2 presents compatibility issue give examples show significance section 3 shows existing programming languages address compatibility issue deal property propagation problem section 4 describes solution illustrates example section 5 deal reuse composition class specific properties within compatibility model sketch use compatibility model baselevel metalevel programmers last section contains concluding summary interlevel communication compatibility define interlevel communication message sending classes instances see figure 1 indeed class objects interact objects sending receiving messages particular instance send message class class send message instances use smalltalk example illustrate issue 1 message sending class level instance level figure 1 interlevel communication two methods allow interlevel communication smalltalk new class one used involved objects belong different levels abstraction ffl object receiving class message returns class class method makes possible go one level following two instance methods excerpted visual works smalltalk include message sending receivers class message name sent class objectaeprinton astream title self class name message daysinyear sent class dateaedaysinyear answer number days year represented receiver self class daysinyear self year ffl class receiving new message returns new instance therefore new method makes possible go one level following two class methods include message sending newly created instances message atput sent new instance arrayedcollection anobject newcollection j newcollection self new 1 newcollection 1 put anobject newcollection message sent new instance browser classaeopenon anorganizer self openon self new anorganizer textstate nil thus interlevel communication smalltalk materialized sending messages new class languages classes reified clos som also allow similar message sending since interlevel communication messages embedded methods inherited whenever methods inherited ensuring compatibility means making sure methods induce failure subclasses ie sent messages always understood identified two kinds compatibility upward compatibility 3 downward compatibility use smalltalk syntax terminology throughout paper measures made visual works smalltalk image show interlevel communication frequent 25 classes include instance methods referencing class 24 metaclasses define methods referencing instance 3 nicolas graube named issue metaclass compatibility gra89 ifoo cbar inheritance instantiation self class cbar figure 2 compatibility need ensured higher level 21 upward compatibility suppose implements method ifoo sends cbar message class receiver see figure 2 b subclass ifoo sent instance b b class receives cbar message order avoid failure b understand cbar message ie metab implement inherit method cbar definition upward compatibility let b subclass class metab metaclass b metaa metaclass upward compatibility ensured metab metaa iff every possible message lead error instance lead error instance b 22 downward compatibility suppose implements method cfoo sends ibar message newly created instance see figure 3 metab created subclass metaa cfoo sent b instance metab b create instance receive ibar message order avoid failure instances b understand ibar message ie b implement inherit ibar method ibar cfoo inheritance instantiation self new ibar figure 3 compatibility need ensured lower level definition downward compatibility let metab subclass metaclass metaa downward compatibility ensured two classes b instance metab instance every possible message lead error lead error b 3 existing models show none known models allow assignment specific properties classes ensuring compatibility 31 redefining class clos validatesuperclass generic function called direct stored kdrb91 default validatesuperclass returns true metaclass new class metaclass superclass 4 ie classes subclasses must metaclass therefore incompatibilities avoided metaclass programming constrained inheritance instantiation b figure 4 default clos subclasses must share metaclass superclass figure 4 shows hierarchy two classes illustrates clos default compatibility management policy since class b inherits b must metaclass order allow definition classes different behaviors programmers usually redefine validatesuperclass method make always return true thus clos programmers total freedom use specific metaclass class assign specific properties classes tradeoff need always aware compatibility issue 32 som som ibm corba compliant product based metaclass architecture df94b som kernel follows objvlisp model coi87 som metaclasses explicit many instances therefore users complete freedom organize metaclass hierarchies 321 compatibility issue som som encourages definition use explicit metaclasses introducing unique concept named derived metaclasses deals upward compatibility issue df94a compiletime som automatically determines appropriate metaclass ensures upward compatibility needed som automatically creates new metaclass named derived metaclass ensure upward compatibility instantiation inheritance self class cbar aifoo class parent metaclass metab derived cbar ifoo figure 5 som ensures upward compatibility using derived metaclasses fact also returns true superclass class named metaclass one argument standardclass metaclass funcallablestandardclass suppose want create class b instance metab subclass som detect upward compatibility problem since metab inherit metaclass metaa therefore automatically creates derived metaclass derived using multiple inheritance order support necessary class methods variables 5 figure 5 shows resulting construction instance b receives ifoo goes one level higher sends cbar b class b understands cbar message since metaclass ie derived derived metaclass inherits metab metaa inheritance instantiation self new ibar somobject ibar cfoo somclass figure example som provide policy mechanism handle downward compatibility suppose metab created subclass metaa see figure 6 cfoo method inherited metab sends ibar message new instance b class receives cfoo message runtime error occur instances understand ibar message 322 class property propagation som som allow assignment property given class without making subclasses assigned property name defect class property propagation problem following example illustrate derived metaclasses implicitly cause undesirable propagation class properties inheritance instantiation class parent metaclass soleinstance derived soleinstance released figure 7 class property propagation som suppose class figure 7 released class ie modified property useful multiprogrammer development environments versionning purposes order avoid change instance released metaclass let b class unique instance b instance soleinstance metaclass b subclass som creates b instance automatically created derived metaclass inherits soleinstance released thus soon b created automatically locked acts like released class cannot define new method 5 semantics derived metaclasses guarantees declared metaclass takes precedence resolution multiple inheritance ambiguities ie metab metaa besides ensures instance variables class correctly initialized use complex mechanism 33 smalltalk80 smalltalk metaclasses partially hidden automatically created system metaclass nonsharable strongly coupled sole instance metaclass hierarchy parallel class hierarchy implicitly generated classes created 331 compatibility issue smalltalk80 using parallel inheritance hierarchies smalltalk model ensures upward downward com patibility indeed code dealing new class methods inherited works properly instantiation inheritance class cbar cfoo ifoo classcfoo self new ibar self class cbar aifoo class ibar figure 8 smalltalk ensures upward downward compatibilities one creates b class subclass see figure 8 smalltalk automatically generates metaclass b b class 6 subclass class metaclass suppose implements method ifoo sends cbar class receiver ifoo sent instance b b class receives cbar message thanks parallel hierarchies b class understands cbar message upward compatibility ensured similar manner downward compatibility ensured thanks parallel hierarchy 332 class property propagation smalltalk80 since metaclasses automatically implicitly managed system smalltalk drastically reduces opportunity change class behaviors making metaclass programming anecdotal som smalltalk allow assignment property class without propagating subclasses inheritance class class classnew self error abstract instantiation figure 9 class property propagation smalltalk figure 9 class abstract since subclasses must implement methods complete instance behavior b concrete class implements whole set methods suppose want enforce property abstractness order forbid instantiating define class method classaenew raises error unfortunately b class inherits method new class result attempting create instance b raises error 7 6 name smalltalk metaclass name unique instance postfixed word class 7 example deliberately simple one could avoid problem redefining new b class solution 4 compatibility model among previous models smalltalk one parallel hierarchies ensures full compati bility however allow assignment specific properties classes hand clos model allows assignment specific properties classes unfortunately ensure compatibility believe two goals achieved new model makes clear separation compatibility class specific properties inheritance instantiation abstract classnew self error abstract class class abstract class figure 10 avoiding propagation abstractness illustrate idea separation concerns refactoring example figure 9 create new metaclass named abstract class subclass class see figure 10 class redefined instance new metaclass abstract class redefines new method raise error cannot instance however since b class subclass abstract b class remains concrete generalization scheme solution named compatibility model remainder paper names metaclasses defining class property denoted concatenation property name symbol superclass name example abstract class subclass class defines property abstractness named abstract 41 description compatibility model compatibility model extends smalltalk model separating two concerns compatibility specific class properties metaclass hierarchy parallel class hierarchy ensures upward downward compatibility like smalltalk extra metaclass layer introduced order locally assign property classes classes instances metaclasses belonging layer compatibility model based two layers metaclasses one addressing unique concern compatibility concern issue addressed metaclasses organized hierarchy parallel class hierarchy name metaclasses compatibility metaclasses define behavior must propagated subclasses class methods send messages instances defined metaclasses besides messages sent classes instances defined metaclasses specific class properties concern issue addressed metaclasses define class specific properties name metaclasses property metaclasses class specific property instance property metaclass inherits corresponding compatibility metaclass property metaclass joined property metaclasses since defines property specific class kind inheritance anomaly my93 increases maintenance costs aclass bclass metaclasses compatibility metaclasses property ifoo ibar aifoo self new ibar aclasscfoo self class cbar inheritance instantiation cfoo bproperty cbar aproperty bclass figure 11 compatibility model figure shows 8 compatibility model applied hierarchy consisting two classes b respectively instances aproperty metaclasses aproperty properties specific class bproperty properties specific class b aproperty aclass bproperty bclass joined link class property propagation occur thus b distinct properties subclasses aclass bclass meta classes upward downward compatibility guaranteed suppose defines two instance methods ifoo ibar ifoo method sends cbar message class receiver ibar method sent new instance cfoo method aclass bclass metaclass hierarchy parallel b class hierarchy interlevel communication failure avoided 42 example refactoring smalltalk80 boolean hierarchy boolean hierarchy smalltalk 9 depicted figure 12 boolean abstract class defines protocol shared true false true false concrete classes cannot one instance properties ie abstractness sole instance implicit smalltalk using compatibility model refactor boolean hierarchy emphasize instantiation inheritance boolean class false class boolean true class true false figure 12 boolean hierarchy smalltalk first create boolean class compatibility metaclass second step consists creating property metaclass abstract boolean class enforces boolean class abstract finally build boolean class instantiating abstract metaclass refactor false class first create false class metaclass subclass boolean class ensure compatibility second step consists creating property metaclass soleinstance compatibility metaclasses surrounded dashed line property metaclasses drawn inside grey shape 9 prefer academic example emphasize ideas rather complex example require detailed presentation false class enforces false class one instance last create false class instantiating soleinstance false class metaclass true class refactored way result rebuilding whole hierarchy boolean shown figure 13 abstract boolean class soleinstance false class instantiation inheritance false class boolean boolean class false true class soleinstance class true figure 13 boolean hierarchy refactoring 5 reuse composition within compatibility model experimented compatibility model neoclasstalk 10 riv97 fully reflective smalltalk quickly faced need class property reuse composition indeed unrelated classes belonging different hierarchies properties given class many properties previous section true class false class property unique instance besides assigned one property class boolean hierarchy class need assigned many properties example false class must unique instance also subclassed class final java terminology reuse compose class properties respect compatibility model section propose extension compatibility model deals reuse composition class properties language classes treated regular objects may integrate extended compatibility model neoclasstalk used first experimentation platform 51 reuse class properties smalltalk since metaclasses behave different way classes defined instances particular class metametaclass called metaclass metaclass defines behavior metaclasses smalltalk example name metaclass name sole instance postfixed word class metaclassaename thisclass name class take advantage concept metametaclasses reuse class properties since metaclasses implementing different properties different behaviors need one metametaclass class property property metaclasses defining class property instances metametaclass property metaclass created metametaclass initializes definition corresponding class property thus code instance variables methods corresponding definition neoclasstalk related papers downloaded httpwwwemnfrcsobjecttoolsneoclasstalkneoclasstalkhtml class property automatically generated reuse achieved creating property metaclasses defining class property instances metametaclass ie initialized class property definition example initialization given section 542 root metametaclass hierarchy named propertymetaclass describes default structure behavior property metaclasses example name property metaclass built property name superclass name propertymetaclassaename self class name self superclass name refactored boolean hierarchy section 42 soleinstance false class soleinstance true class define property unique instance reuse achieved defining soleinstance false class soleinstance true class instances soleinstance subclass propertymetaclass see figure 14 soleinstance false class abstract boolean class metaclass level class level metametaclass level false class boolean instantiation inheritance boolean class false true class soleinstance class abstract soleinstance true propertymetaclass figure 14 reuse properties boolean hierarchy 52 composition class properties since given class many properties model must support composition class proper ties chose use many property metaclasses organized single inheritance hierarchy metaclass implements one specific class property illustrate idea modify instantiation link false class see figure 15 define two property metaclasses one property first property metaclass soleinstance inherits compatibility metaclass false class second one final false class class false defined subclass soleinstance false class resulting scheme respects compatibility model allows assignment two specific properties false class still ensures compatibility 521 conflict management solution property metaclasses composition issue trivial indeed necessary deal conflicts arise composing different property metaclasses using inheritance compose property metaclasses two kinds conflicts arise name conflicts value conflicts dhh soleinstance false class boolean class abstract boolean class false class soleinstance false class final false boolean instantiation inheritance figure 15 assigning two properties false name conflicts happen orthogonal property metaclasses define instance variables methods name two property metaclasses orthogonal define unrelated class properties name conflicts instance variables methods avoided adapting definition new property metaclass according superclasses example although two property metaclasses soleinstance false class soleinstance true class define property respective instances classes false true may use different instance variable names method names value conflicts happen nonorthogonal property metaclasses define methods name conflicts avoided making property metaclass hierarchy act cooperation chain ie property metaclass explicitly refer overridden methods defined superclasses 11 therefore property metaclass acts like mixin bc90 522 example cooperation property metaclasses suppose want assign two specific properties false class figure 16 tracing messages trace ii breakpoints particular methods breakpoint two properties deal message handling based neoclasstalk technique method wrappers described duc98 bfjr98 executemethodreceiverarguments method entry point handle messages neoclasstalk ie customizing executemethodreceiverarguments allows specialization message sending 12 thus object false receives message class false receives message executemethodreceiverarguments according inheritance hierarchy 1 trace first done 2 use super breakpoint performed 3 regular method application finally executed called using super ffl 3 standardclassaeexecutemethod method receiver rec arguments args ffl 2 breakpointfalse classaeexecutemethod method receiver rec arguments args method selector stopselector iftrue self halt breakpoint stopselector super executemethod method receiver rec arguments args ffl 1 tracebreakpointfalse classaeexecutemethod neoclasstalk smalltalk achieved using pseudovariable super executemethodreceiverarguments method provided standardclass root metaclasses neo applies method receiver arguments false class instantiation inheritance false trace breakpoint breakpoint false class trace breakpoint false class propertymetaclass metaclass level class level metametaclass level figure composition nonorthogonal properties method receiver rec arguments args self transcript show method selector cr super executemethod method receiver rec arguments args 53 extended compatibility model generalizing previous examples allows us define extended compatibility model see figure 17 enables reusing composing class properties property metaclass defines instance variables methods involved unique property property metaclasses specific given class organized single hierarchy root hierarchy subclass compatibility metaclass 13 property metaclass instance metametaclass describes specific class property allowing reuse metaclasses property bclass aclass metaclasses compatibility bclass aclass bclass bclass aclass aclass propertymetaclass figure 17 extended compatibility model 13 single hierarchy may compared explicit linearization property metaclasses composed using multiple inheritance dhhm94 metaclass creation composition deletion managed automatically respect extended compatibility model time new class created new compatibility metaclass automatically created done way smalltalk builds parallel metaclass hierarchy assignment property class results insertion new metaclass property metaclass hierarchy insertion made two steps 1 first new property metaclass becomes subclass last metaclass property metaclass 2 class becomes instance new property metaclass neoclasstalk provides protocols dynamically changing class object changeclass superclass class superclass riv97 thus implementation two steps immediate neoclasstalk provided composewithpropertiesof method aclass self superclass aclass class aclass changeclass self 54 programming within extended compatibility model distinguish two kinds programmers base level programmers implement applications using language development tools ii meta level programmers language application 541 base level programming make model easy use baselevel programmer neoclasstalk programming environment includes tool allows one assign different properties given class using smalltalklike browser see figure 18 properties added removed runtime metaclass level automatically built according selection baselevel programmer 542 meta level programming order introduce new class properties metalevel programmers must create subclass prop ertymetaclass metametaclass new metametaclass stores instance variables methods defined instances property metaclasses new metametaclass instan tiated previous instance variables added resulting property metaclass methods compiled 15 initialization time example evaluation following expression creates property metaclass instance metametaclass trace assigns trace property true class trace new composewithpropertiesof true 14 removal property metaclass done symmetrical way solution consists compilation resulting protomethods riv97 thus property metaclass gets initialized protomethods copied method dictionary property metaclass allowing fast instantiation metametaclasses assumes initialization part creation process true almost every language tradition nally achieved smalltalk redefinition new super new initialize skt96 figure properties assigned class using browser order achieve trace messages must captured logged text collector therefore property metaclasses instances trace must define instance variable named transcript corresponding text collector method handles messages message handling achieved using executemethodreceiverarguments method source code already presented 522 definitions generated property metaclasses initialized ie using initialize method trace metametaclass traceaeinitialize super initialize self instancevariablenames transcript self generateexecutemethodreceiverarguments 6 conclusion considering classes first class objects organizes applications different abstraction levels inevitably raises upward downward compatibility issues existing solutions addressing compatibility issues smalltalk allow assignment specific properties given class without propagating subclasses compatibility model proposed paper addresses compatibility issue allows assignment specific properties classes without propagating subclasses achieved thanks separation two involved concerns compatibility class properties upward downward compatibilities ensured using compatibility metaclass hierarchy parallel class hierar chy property metaclasses allowing assignment specific properties classes subclasses compatibility metaclasses therefore take advantage expressive power metaclasses define reuse compose class properties environment supports safe metaclass programming class properties improve readability reusability quality code increasing separation concerns allow better organization class libraries frameworks designing reliable software strongly convinced compatibility model enables separation concerns based metaclass paradigm therefore promotes building reliable software easy reuse maintain acknowledgments authors grateful mathias braux pierre cointe stephane ducasse nick edgar philippe mulet jacques noye nicolas revault mario sudholt valuable comments suggestions special thanks anonymous referees provided detailed thoughtprovoking comments r programming explicit metaclasses smalltalk wrappers rescue concurrency distribution object oriented programming noury bouraqadisaadani first class objvlisp model derived metaclasses som reflections metaclass programming som le point sur lheritage multiple proposal monotonic multiple inheritance linearization evaluating message passing control techniques smalltalk metaclass compatibility separation concerns objectoriented programming clos perspective art metaobject protocol explicit metaclasses tool improving design class libraries reflection distributed systems adaptive objectoriented software demeter method propagation patterns concepts experiments computational reflection towards methodology explicit composition metaobjects research directions concurrent objectoriented programming new smalltalk kernel allowing explicit implicit metalclass pro gramming object behavioral evolution within class based reflective languages smalltalk style advances objectoriented metalevel architectures reflec tion tr smalltalk80 language implementation concepts experiments computational reflection first class objvlisp model metaclass compatibility programming explicit metaclasses smalltalk80 mixinbased inheritance art metaobject protocol metaobject protocols analysis inheritance anomaly objectoriented concurrent programming languages proposal monotonic multiple inheritance linearization reflections metaclass programming som smalltalk style towards methodology explicit composition metaobjects concurrency distribution objectoriented programming advances objectoriented metalevel architectures reflection adaptive objectoriented software wrappers rescue explicit metaclasses tool improving design class libraries ctr stphane ducasse oscar nierstrasz nathanael schrli roel wuyts andrew p black traits mechanism finegrained reuse acm transactions programming languages systems toplas v28 n2 p331388 march 2006
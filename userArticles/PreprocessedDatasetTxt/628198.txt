highdimensional similarity joins abstractmany emerging data mining applications require similarity join points highdimensional domain present new algorithm utilizes new index structure called epsilon tree fast spatial similarity joins highdimensional points index structure reduces number neighboring leaf nodes considered join test well traversal cost finding appropriate branches internal nodes storage cost internal nodes independent number dimensions hence proposed index structure scales highdimensional data analyze cost join epsilon tree rtree family show epsilon tree perform better highdimensional joins empirical evaluation using synthetic reallife data sets shows similarity join using epsilon tree twice order magnitude faster r tree performance gap increasing number dimensions also discuss ideas epsilon tree applied rtree family biased rtrees perform better corresponding traditional rtrees highdimensional similarity joins match performance epsilon tree b introduction many emerging data mining applications require efficient processing similarity joins highdimensional points examples include applications timeseries databases1 2 multimedia databases 9 14 13 medical databases 3 21 scientific databases22 typical queries applications include 1 discover stocks similar price movements 2 find pairs similar images 3 retrieve music scores similar target music score queries often prelude clustering objects example given pairs similar images images clustered groups images group similar motivate need multidimensional indices applications consider problem finding pairs similar timesequences technique 2 solves problem breaking timesequences set contiguous subsequences finding subsequences similar two sequences enough similar currently bell laboratories murray hill nj subsequences considered similar find similar subsequences subsequence mapped point multidimensional space typically dimensionality space quite high problem finding similar subsequences reduced problem finding points close given point multidimensional space pair points considered close within ffl distance distance metric l 2 l1 norms involves dimensions ffl specified user multidimensional index structure r tree used finding pairs close points approach holds domains image data case image broken grid sub images key attributes subimage mapped point multidimensional space pair similar subimages found enough subimages two images match complex matching algorithm applied images closely related problem find objects similar given objects translates finding points close query point even direct mapping object point multidimensional space paradigm still used distance function objects available algorithm presented 7 generating mapping object multidimensional point given set objects distance function current spatial access methods see 18 8 overview mainly concentrated storing map infor mation 2dimensional 3dimensional space work well low dimensional data points time space indices grow rapidly dimen sionality moreover cpu cost high similarity joins existing indices designed reduction io cost primary goal discuss points later paper reviewing current multidimensional indices overcome shortcomings current indices highdimensional similarity joins propose structure called fflkdb tree mainmemory data structure optimized performing similarity joins fflkdb tree also small build time lets fflkdb tree use similarity distance limit ffl parameter building tree empirical evaluation shows build plus join time fflkdb tree typically 3 35 times less join time r tree 19 1 performance gap increasing number dimensions pure mainmemory data structure would useful since data many applications fit memory extend join algorithm handle large amount data still using fflkdb tree problem definition consider two versions spatial similarity join problem ffl selfjoin given set n highdimensional points distance metric find pairs points within ffl distance ffl nonselfjoin given two sets 1 2 highdimensional points distance metric find pairs points one 1 2 within ffl distance distance metric two n dimensional points x consider 2 familiar euclidean distance l 1 manhattan dis tance l1 corresponds maximum distance dimension paper organization section 2 give overview existing spatial indices describe shortcomings used highdimensional similarity joins section 3 describes fflkdb tree algorithm similarity joins give performance evaluation section 4 conclude section 5 current multidimensional index structure first discuss rtree family indices popular multidimensional indices describe use similarity joins also give brief overview indices discuss inadequacies current index structures experiments indicated r tree better r tree 8 r tree 4 tree highdimensional similarity joins space covered bounding rectangles b rtree figure 1 example rtree 21 rtree family rtree 8 balanced tree node represents rectangular region internal node rtree stores minimum bounding rectangle mbr children mbr covers space points child node mbrs siblings overlap decision whether traverse subtree internal node depends whether mbr overlaps space covered query node becomes full split total area two mbrs resulting split minimized splitting node figure 1 shows example rtree tree consists 4 leaf nodes 3 internal nodes mbrs n1n2l1l2l3 l4 root node two children whose mbrs n1 n2 r tree 4 added two major enhancements rtree first rather considering area node splitting heuristic r tree also minimizes perimeter overlap bounding regions second r tree introduced notion forced reinsert make shape tree less dependent order insertion node becomes full split immediately portion node reinserted top level two enhancements r tree generally outperforms rtree imposes constraint two bounding regions nonleaf node overlap thus except boundary surfaces one path every leaf region reduce search join costs xtree 6 avoids splits could result high degree overlap bounding regions r tree experiments show overlap bounding regions increases significantly high dimensional data resulting performance deterioration r tree instead allowing splits produce high degree overlaps nodes xtree extended usual block size resulting called supernodes experiments show xtree improves performance point query nearestneighbor query compared r tree tvtree described comparison r tree given 6 point data however since r tree overlap gains xtree obtained avoiding overlap one would expect xtree better r tree point data overlapping mbrs r tree r tree b nonoverlapping mbrs r figure 2 screening points join test similarity join join algorithm using rtree considers leaf node extends mbr ffldistance finds leaf nodes whose mbr intersects extended mbr algorithm performs nestedloop join sortmerge join points leaf nodes join condition distance points ffl sortmerge join points first sorted one dimensions reduce redundant comparisons points joining two leaf nodes could first screen points boundary leaf node extended ffl points lie within intersection two extended regions need joined figure 2 shows example rectangles solid lines represent mbrs two leaf nodes dotted lines illustrate extended bound aries shaded area contains screened points kdb tree 17 similar r tree main differ unlike mbrs r tree hbtree 12 similar kdb tree except bounding rectangles children internal node organized kd tree 5 rather list mbrs kdtree binary tree multidimensional points level kdtree one dimension chosen cyclically used decide subtree traversal fur ther bounding regions may rectangular holes figure 3 number neighboring leaf nodes reduces cost splitting node compared kdb tree tvtree 10 uses variable number dimensions indexing tvtree design parameter ff active dimen sion typically small integer 1 2 node ff dimensions used represent bounding regions split nodes nodes close root first ff dimensions used define bounding rectangles tree grows nodes may consist points value first say k dimensions since first k dimensions longer distinguish points nodes next ff dimensions k dimensions used store bounding regions splitting reduces storage traversal cost internal nodes gridfile 15 partitions kdimensional space grid multiple grid buckets may placed single disk page directory structure keeps track mapping grid buckets disk pages grid bucket must fit within leaf page bucket overflows grid split one dimensions 23 problems current indices index structures described suffer following inadequacies performing similarity joins highdimensional points number neighboring leaf nodes splitting algorithms rtree variants utilize every dimension equally splitting order minimize volume hyper rectangles causes number neighboring leaf nodes within ffldistance given leaf node increase dramatically number dimensions see happens assume rtree partitioned space dead region bounding rectangles uniform distribution 3dimensional space may get 8 leaf nodes shown figure 3 notice every leaf node within ffldistance every leaf node n dimensional space may o2 n leaf nodes within ffldistance every leaf node problem somewhat mitigated use mbrs however number neighbors within ffldistance still increases dramatically number dimensions problem also holds multidimensional structures except perhaps tvtree however tv tree suffers different problem use first k dimensions splitting consider others unless many points value first k dimensions enough data points leads problem rtree though opposite reason since tvtree uses first k dimensions splitting leaf node many neighboring leaf nodes within ffldistance note problem affects cpu io cost cpu cost affected traversal time well time screen neighboring pages io cost affected access neighboring pages storage utilization kdb tree rtree family including xtree represent bounding regions node rectangles bounding rectangles represented min max points hyperrectangle thus space needed store representation bounding rectangles increases linearly number dimen sions problem hbtree store mbrs tvtree uses dimensions time grid file traversal cost traversing rtree kdb tree examine bounding regions children node determine whether traverse subtree step requires checking ranges every dimension representation bounding rectangles thus cpu cost examining bounding rectangles increases proportionally number dimensions data points problem mitigated hbtree tvtree problem gridfile build time set objects participating spatial join may often pruned selection predicates 11 eg find similar international funds cases may faster perform nonspatial selection predicate first select international funds perform spatial join result thus sometimes necessary build spatial index onthefly current indices designed built cost building cost join 16 skewed data handling skewed data problem current indices except gridfile kdimensional space single data page overflow may result dimensional slice added gridfile directory gridfile n buckets split splitting dimension partitions nm new cells added grid split thus size directory structure grow rapidly skewed highdimensional points summary index good bad features similarity join highdimensional points would difficult design generalpurpose multidimensional index shortcomings listed ever designing specialpurpose index attack problems problem highdimensional similarity joins distance metric ffl parameter following properties ffl feature vector chosen similarity comparison high dimension every dimension feature vector mapped numeric value ffl distance function computed considering every dimension feature vector ffl similarity distance limit ffl large since indices effective selectivity similarity join large ie every point matches every point describe new index structure fflkdb tree specialpurpose index purpose 3 fflkdb tree introduce fflkdb tree section 31 discuss design rationale section 32 31 fflkdb tree definition first define fflkdb tree 2 describe perform similarity joins using fflkdb tree first case data fits memory case fflkdb tree assume without loss generality coordinates points dimension lie 0 1 start single leaf node better space utilization pointers data points stored leaf nodes whenever number points leaf node exceeds threshold leaf node split converted interior node leaf node level ith dimension used splitting node node split b1fflc parts width new leaf node ith dimension either ffl slightly greater ffl rest section assume without loss generality ffl exact divisor 1 example fflkdb tree two dimensional space shown figure 4 note interior node x points child x join points children x except 2 children adjacent holds l p distance metrics thus join code used metrics final test pair points metricdependent 2 really trie call tree since conceptually similar tree leaves root leaf leaf leaf figure 4 fflkdb tree similarity join using fflkdb tree let x internal node fflkdb tree use xi denote ith child x let f fanout tree note 5 describes join algorithm algorithm initially calls selfjoinroot selfjoin version joinroot1 root2 nonselfjoin version procedures leaf joinx leafselfjoinx perform sortmerge join leaf nodes highdimensional data fflkdb tree rarely use dimensions splitting instance 10 dimensions ffl 01 would points dimensions used thus usually use one free unsplit dimension common sort dimension points every leaf node kept sorted dimension rather sorted repeatedly join joining two leaf nodes algorithm sortmerge using dimension memory management value ffl often given runtime thus since value ffl parameter building index may possible build diskbased version index advance instead sort multidimensional points first splitting dimension keep external file first describe join algorithm assuming mainmemory hold points within 2 ffl distance first dimension generalize join algorithm first reads points whose values sorted dimension lie 0 2 ffl builds fflkdb tree points main memory performs similarity join memory algorithm deallocates space used points whose values sorted dimension 0 ffl reads points whose values 2 ffl 3 ffl build fflkdb tree points performs join procedure procedure continued points processed note read procedure joinx begin leafnodex leafnodey else leafnodex begin else leafnodey begin joinxi else begin joinxi joinxi joinxi1 joinxf procedure selfjoinx begin leafnodex else begin selfjoinxi xi joinxi xi1 selfjoinxf xf figure 5 join algorithm point disk procedure works build time ffl kdb tree extremely small generalized case 2 ffl chunk data fit memory basic idea partition data ffl 2 chunks using additional dimension join procedure ie read points memory build fflkdb perform join instead repeated 4 ffl 2 chunk data using additional dimension 32 design rationale two distinguishing features fflkdb tree ffl biased splitting dimension used previous split selected splitting long length dimension bounding rectangle resulting leaf node least ffl split node split node ffl sized chunks discuss features help fflkdb tree solve problems current indices outlined section 2 number neighboring leaf nodes recall current indices number neighboring leaf pages may increase exponentially number dimensions fflkdb solves problem biased splitting length bounding rectangle leaf nodes split dimension least ffl two neighboring leaf nodes need considered join test however length bounding rectangle split dimension becomes less ffl number neighbor leaf nodes join test increases hence split one dimension long length bounding rectangle resulting children least ffl start splitting next dimension leaf node becomes full split node several children size ffl split dimension rather gradually order reduce build time two alternatives choosing next splitting dimension global ordering local ordering global ordering uses split dimension nodes level local ordering chooses split dimension based distribution points node examples two cases shown figure 6 3 dimensional space orderings dimension d0 used splitting root node ie level 0 global d1 used splitting level 1 however local ordering d1 d2 chosen alternatively neighboring nodes level 1 consider leaf node labeled x global ordering 5 neighbor leaf nodes shaded figure number neighbors increases 9 local ordering notice space covered neighbors global order proper subset covered neighbors local ordering difference space covered two orderings increases ffl decreases hence chose global ordering splitting dimensions rather local ordering number points huge fflkdb tree forced split every dimension number neighbors comparable indices however till limit number neighbors depends number points distribution ffl independent number dimensions order dimensions chosen splitting significantly affect space utilization join cost correlations exist dimensions problem solved statistically analyzing sample data choosing next split dimension least correlation dimensions already used splitting choosing splitting dimension globally b choosing splitting dimension locally figure 6 global local ordering splitting dimensions space requirements internal node simply need array pointers children need store minimum bounding rectangles computed hence space required depends number points distribution independent number dimensions traversal cost since split nodes ffl sized chunks traversal cost extremely small join procedure never check bounding rectangles nodes decide whether may contain points within ffl distance build time build time small complex splitting algorithms splits propagate upwards skewed data since splitting node affect nodes fflkdb tree handle skewed data reasonably performance evaluation empirically compared performance fflkdb tree r tree sortmerge algorithm experiments performed ibm rs6000 250 workstation cpu clock rate 66 mhz 128 mb main memory running aix 325 data stored local disk measured throughput 15 mbsec first describe algorithms compared section 41 datasets used experiments section 42 next show performance algorithms synthetic reallife datasets sections 43 44 respectively 41 algorithms fflkdb tree implemented fflkdb tree algorithm described section 31 leaf node converted internal node ie split memory usage exceeded 4096 bytes however dimensions left split ting leaf node allowed exceed limit execution times fflkdb tree include io cost reading external sorted file containing data points well cost building index since external file generated reused different value ffl execution times include time sort external file tree experiments indicated r tree faster r tree similarity joins set highdimensional points recall difference r tree r tree r tree allow overlap minimum bounding rectangles hence reduces number overlapping leaf nodes considered spatial similarity join resulting faster execution time therefore used r tree experiments used page size 4096 bytes experiments ensured r tree always fit memory built r available memory join execution began thus execution time r tree include build time includes cpu time mainmemory join although gives r tree unfair advantage err conservative side 2level sortmerge consider simple sortmerge algo rithm reads data file sorted one dimensions performs join test pairs points whose values sort dimension closer ffl implemented sophisticated version algorithm reads 2ffl chunk sorted data memory sorts memory data second dimension performs join test pairs points whose values second sort dimension close ffl algorithm drops first ffl chunk memory reads next ffl chunk execution times reported algorithm also include external sort time table 1 summarizes costs included execution times algorithm 42 data sets performance metrics synthetic datasets generated two types synthetic datasets uniform gaussian values dimen join cost yes yes yes build cost sort cost first dim table 1 costs included execution times parameter default value range values number points 100000 10000 1 million number dimensions 10 4 28 ffl join distance 01 001 02 range points 1 1 distance metric l2norm l1 l2 l1 norms table 2 synthetic data parameters sion randomly generated range gamma10 10 either uniform gaussian distribution gaussian distribution mean standard deviation 0 025 respectively table 2 shows parameters datasets along default values range values conducted experiments distance functions used l 1 l 2 l1 distance functions experiments extended bounding rectangles obtained extending mbrs ffl differ slightly tree depending distance functions figure 7 shows extended bounding regions l 1 l 2 l1 norms rectangles solid line represents mbr leaf node dashed lines extended bounding regions difference regions covered extended regions may result slightly different number intersecting leaf nodes given leaf node however rtree family spatial indices selection query usually represented rectangles reduce cost traversing index thus extended bounding rectangles used traverse index l 1 l 2 become l1 43 results synthetic data distance metric first experimented varying ffl norms relative performance l1 b l2 c l1 figure 7 bounding regions extended ffl uniform distribution101000 execution time epsilon 2level sortmerge r tree ekdb tree gaussian execution time epsilon 2level sortmerge r tree ekdb tree figure 8 performance synthetic value algorithms almost identical three distance metrics see 20 show results l 2 norm remaining experiments ffl value figure 8 shows results varying ffl 001 02 uniform gaussian data distributions l 2 used distance metric explore behavior algorithms ffl greater 02 since join result becomes large meaningful note execution times shown log scale fflkdb tree algorithm typically around 2 20 times faster algo rithms low values ffl 001 2level sortmerge algorithm quite effective fact sortmerge algorithm fflkdb algorithm almost actions since fflkdb around 2 levels excluding root gaussian distribution performance gap fflkdb tree r tree narrows high values ffl join result large uniform 28 execution time dimension 2level sortmerge r tree ekdb tree gaussian distribution10010000 28 execution time dimension 2level sortmerge r tree ekdb tree figure 9 performance synthetic data number dimensions number dimensions figure 9 shows results increasing number dimensions 4 28 execution times shown using log scale fflkdb algorithm around 5 19 times faster sortmerge algorithm 8 dimensions higher around 3 47 times faster r tree performance gap increasing number dimensions 4 dimensions slightly faster since enough points fflkdb tree filled dimensions r tree increasing number dimensions increases overhead traversing index well number neighboring leaf nodes cost screening hence time increases dramatically going 4 28 dimensions 3 even sortmerge algorithm performs better r tree higher dimensions 3 dip r tree execution time going 4 8 dimension gaussian distribution decrease join result size effect also noticeable fflkdb tree distributions uniform distribution101000100000 execution time number points 000s 2level sortmerge r tree ekdb tree gaussian distribution101000100000 execution time number points 000s 2level sortmerge r tree ekdb tree figure 10 performance synthetic data number points contrast execution time fflkdb remains roughly constant number dimensions increases number points see scale fflkdb tree varied number points 10000 1000000 results shown figure 10 r tree show results 1000000 points tree longer fit main memory none algorithms linear scaleup sortmerge algorithms somewhat worse scaleup two algorithms gaussian distribution performance advantage fflkdb tree compared r tree remains fairly constant percentage uniform distribution relative performance advantage fflkdb tree varies since average depth fflkdb tree increase gradually number points creases rather jumps suddenly around 3 around 4 etc transitions occur 20000 50000 points 500000 750000 points uniform execution time ratio size two data set r tree ekdb tree gaussian execution time ratio size two data set r tree ekdb tree figure 11 nonselfjoins nonselfjoins figure 11 shows execution times similarity join two different datasets generated different random seeds size one datasets fixed 100000 points size dataset varied 100000 points 5000 points experiments second dataset 10000 points fewer experiment run 5 times different random seeds second dataset results averaged datasets 100000 points performance gap r tree fflkdb tree similar selfjoin 200000 points size second dataset decreases performance gap also decreases reason time build index included fflkdb tree r tree 44 experiment reallife data set experimented following reallife dataset similar time sequences consider problem finding similar time sequences algorithm proposed 2 first finds similar atomic subsequences stitches together atomic subsequence matches get similar subsequences similar sequences sequence broken atomic subsequences using sliding window size w atomic subsequences mapped points wdimensional space problem finding similar atomic subsequences corresponds problem finding pairs wdimensional points within ffl distance using l1 norm see 2 rationale behind approach10010000 execution time epsilon 2level sortmerge r tree execution time dimension 2level sortmerge r tree ekdb tree figure 12 performance mutual fund data time sequences experiment daily closing prices 795 us mutual funds jan 4 1993 march 3 1995 around 400000 points experiment since sequence broken using sliding window data obtained mit ai laboratories experimental stock market data server httpwwwaimitedustocksmfhtml varied window size ie dimension 8 16 ffl 005 02 figure 12 shows resulting execution times three algorithms results quite similar obtained synthetic dataset fflkdb tree outperforming two algorithms 45 summary fflkdb tree typically 2 47 times faster selfjoins performance gap increasing number dimensions typically 2 20 times faster sortmerge 2level sortmerge usually slower r tree high dimensions low values ffl 001 faster r tree nonselfjoins results similar datasets joined different sizes datasets different sizes eg 110 ratio fflkdb tree still faster r tree performance gap narrowed since include build time fflkdb tree r tree distance metric significantly affect sults relative performance algorithms almost identical l 1 l 2 l1 norms conclusions presented new algorithm index structure called fflkdb tree fast spatial similarity joins highdimensional points similarity joins needed many emerging data mining applications new index structure reduces number neighbor leaf nodes considered join test well traversal cost finding appropriate branches internal nodes storage cost internal nodes independent number dimensions hence scales highdimensional data studied performance fflkdb tree using synthetic reallife datasets join time fflkdb tree 2 order magnitude less join time r tree datasets performance gap increasing number dimensions also analyzed number join screen tests fflkdb tree r tree analysis showed fflkdb tree perform considerably better highdimensional points analysis found 20 given popularity rtree family index struc tures also studied ideas fflkdb tree grafted rtree family found resulting biased rtree performs much better rtree highdimensional similarity joins fflkdb tree still better details study found 20 r efficient similarity search sequence databases fast similarity search presence noise qbism prototype 3d medical image database system multidimensional binary search trees used associative searching fastmap fast algorithm indexing rtrees dynamic index structure spatial searching retrieval technique similar shapes spatial joins using seeded trees multimedia information systems unfolding reality qbic project querying images content using color grid file adaptable partition based spatialmerge join design analysis spatial data structures fflkdb tree fast index structure highdimensional similarity joins warping 3d models interbrain comparisons inputstate space approach prediction auroral geomagnetic activity solar wind variables tr
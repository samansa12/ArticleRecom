power analysis lowpower scheduling techniques embedded dsp software abstract paper describes application measurement based power analysis technique embedded dsp processor instructionlevel power model processor developed using technique significant points difference observed model ones developed earlier generalpurpose commercial microprocessors particular effect circuit state power cost instruction stream marked case dsp processor addition dsp processor special architectural feature allows instructions packed pairs energy reduction possible use feature studied onchip booth multiplier processor major source energy consumption dsp programs microarchitectural power model multiplier developed analyzed energy minimization scheduling algorithm incorporating new techniques proposed reduce energy consumed dsp software energy reductions varying 11 56 observed several example programs energy savings real verified physical measurement b introduction embedded computing systems characterized presence application specific software running specialized processors processors may shelf digital signal processors dsps application specific instructionset processors asips large fraction applications power critical however little available form design tools help embedded system designers evaluate designs terms power metric recently instructionlevel power model developed two generalpurpose commercial microprocessors 1 2 based base cost overhead cost instruction obtained physical current measurements base cost given instruction defined average current drawn processor repeated execution struction overhead cost needed account effect circuit state change instruction sequence consisting different instructions ever impact effect overall power cost programs found limited large generalpurpose microprocessors aim study analyze issues related software power consumption context smaller specialized processor fujitsu embedded dsp processor referred target processor used study processor used several fujitsu embedded applications representative large class dsp processors analysis results used paper develop instructionlevel power model makes possible evaluate power cost programs run target dsp processor observed effect circuit state marked processor suggests changing instruction order appropriate scheduling instructions lead reduction power cost program issue explored limited extent earlier works 3 4 3 study shows faster programs consume less energy optimizing software performance instruction scheduling minimize energy consumption 4 power consumed controller processor targeted minimization power cost different instruction schedules estimated counting transitions rtl level model controlpath well recognized estimation method rough measure actual power cost fur thermore increase energy cost due longer schedules considered scheduling approach propose overcomes limitations since based actual energy costs obtained physical measurements dsp processor special architectural feature allows instructions packed pairs energy reduction possible use feature studied well furthermore since onchip booth multiplier major source energy consumption dsp programs microarchitectural power model onchip booth multiplier developed analyzed power minimizations based microarchitecture model effective technique local code modification operand swapping proposed reduce power consumption lowpower code scheduling method presented automatically apply techniques given piece code experimental results several example dsp programs show energy reductions ranging 11 56 energy savings verified physical measurement also noted energy reduction essentially comes free obtained software modification thus entails hardware overhead addition loss performance since running times modified programs either improve remains unchanged target embedded dsp processor used study fujitsu 33v 05um 40mhz cmos proces sor special architectural features relevant rest paper 1 4 24bit data registers b c 2 fast mac multiplyandaccumulate unit using booth multiplier 3 latched operands booth multiplier reduce unnecessary switching 4 two onchip ram banks simultaneously reading two registers 5 instruction packing 3 current measurement applications target dsp processor run limited energy available battery thus energy consumption focus attention since v dd supply voltage cycle period known fixed energy proportional product average current n number cycles given n program need measure average current calculate e product n measure used compare energy cost programs paper target processor part personal computer evaluation board programmed monitor program running personal computer using monitor dsp instructions downloaded offchip instruction memory input data stored onchip ram dsp processor current drawn dsp processor measured standard offtheshell dualslope integrating digital ammeter way discussed detail 1 instruction packing low power special architectural feature target dsp processor capability packing alutype instruction data transfer instruction single instruction codeword simultaneous execution feature called instruction packing found using packed instruction always leads reduction energy reason average current packed instruction slightly average current sequence two unpacked instructions thus reduction one execution cycle offsets slight current increase leading large overall energy reduction graphically illustrated figure 1 certain set operands area solid dotted graphs proportional energy consumption packed unpacked instructions respec tively seen average current drawn packed instruction marginally higher unpacked instructions however since unpacked instructions complete twice number packed unpacked figure 1 comparison energy consumed packed unpacked instructions table 1 example sequence four instructions overhead cost 1 3 cannot ignored number instruction base cycles cycles packed instructions total energy consumed unpacked instructions much larger twice much packed instructions explanation observations may lie fact certain underlying current cost associated execution packed unpacked instruction independent functionality instruction cost associated fetching instruction pipeline control clocks etc cost gets shared two instructions packed addition circuitstate overhead current two adjacent unpacked instructions lab mspc eliminated since minimizing total energy consumption objective instructions packed packing rules much possible 5 effect circuit state overhead primary components models developed 1 2 base costs instructions overhead costs adjacent instructions base current instruction measured putting several instances target instruction infinite loop pair different instructions say j put infinite loop measurement current always larger average base costs j difference called overhead cost j considered measure change circuit state instruction j viceversa total energy consumed program sum total base costs total overhead costs instructions executed however overhead cost processors considers circuit state change caused adjacent instructions case target dsp processor underestimate current especially multiply instructions table 1 gives example program consisting sequence multiply instructions mullab followed nops associated base cost number execution cycles also shown overhead cost instruction pairs 12 184 23 184 13 139 sum measured current four instructions 2040 equals n sequence sum base costs 372 overhead costs adjacent instructions 184 underestimates actual cost 136 difference 278 two estimates actually comes circuit state overhead nonadjacent instructions 13 due special design inputs multiplier latch input operand put multiplier operand bus retain old values next multiply instruction executed therefore state change input latches cannot accounted overhead adjacent instructions 12 23 given overhead instructions 13 2 times overhead 13 2139ma compensate difference leading accurate estimate 1 result new power model needs include overhead caused nonadjacent multiply instruc tions overhead dependent previous current values input latches multiply operation values typically unknown runtime purpose program energy evaluation state input latches considered unknown average overhead current penalty added base cost multiply instruction average value determined 125ma mul mac instructions way effect handled using enhanced form base cost multiply instructions enhanced base cost base cost defined earlier plus average overhead penalty instructions instruction set show effect instructions involving alu datapath 6 power analysis dsp processor instructionlevel power modeling technique described section 5 suggests accurate current estimation program obtained table gives base cost instruction table gives overhead cost instruction pair derived tables empirically constructed appropriate experiments using measurement based power analysis technique ever practical issues considered regard first power cost instructions vary depending operand value extensive experimentation lead development accurate models variation practical approximation case use average costs instructions average costs tabu lated issue one table size processors rich instruction sets assigning power costs instructions instruction pairs lead large tables creation tables may require lot work however observed instructions arranged classes instructions given class similar power costs instructions similar functionality tend fall class assigning average cost instruction class lead compact tables thus greater detail resolution tables lead four instructions put infinite loop measurement overhead occur twice 1 3 well 3 1 table 2 six instruction classes class addressing immed reg load immediate data register transfer memory data registers b move data one register another mem reg reg mem move data memory register register memory asl reg specified implicitly addsub shift logic operations alu mac reg specified implicitly multiply accumulate alu table 3 average base cost unpacked instructions ldi lab mov1 range average base 194 365 198 mov2 asl mac range 176 192 158 172 170 174 average base 184 165 172 accurate cost estimation practical pur poses use compact tables suffices target dsp processor instructions commonly used dsp applications categorized classes six classes used unpacked structions shown table 2 principal packed instructions similarly classified extensive current measuring experiments conducted verify class characteristics current con sumption furthermore effect different operand values variation current consumption studied class average base overhead costs also assigned analysis results discussed detail remainder sec tion packed unpacked instructions discussed separately scheduling algorithm developed use information energy reduction described section 7 61 unpacked instruction table 3 gives unpacked instruction class range base costs different operand values exact operand values often unknown runtime thus average values used program energy evaluation also shown table 3 since range variation base costs class reasonably small less 10 classes ldi exception inaccuracy resulting use averages limited overhead costs instructions belonging different classes shown table 4 entry row column j gives overhead cost instruction belonging class j occurs instruction belonging class instruction belonging class occurs instruction belonging class j table symmetric since method used calculating overhead costs assumes costs two cases variation table 4 average overhead cost unpacked instructions ldi lab mov1 mov2 asl mac ldi 36 137 155 63 108 60 lab 25 19 122 209 150 mov1 40 183 105 38 mov2 256 267 222 asl 36 80 table 5 average base cost packed instructions instruction asllab aslmov1 aslmov2 range 345 387 157 174 187 204 average base 366 166 196 instruction maclab macmov1 macmov2 range average base 369 174 201 value entry different operands choice instructions class variation limited reasonable use average values entries table 4 represent determined average values value mac mac entry represents overhead occur even two instructions nonadjacent described section 5 alternative way look case use enhanced base costs section 5 base cost mac table 3 increased 125 mac mac entry table 4 changed important observation table 4 significant variation across various entries table suggests choosing appropriate order instructions lead energy reduction algorithm described section 7 62 packed instruction table 5 shows packed instruction class range base cost variation caused possible operand values variation reasonably small less 10 classes average value assigned base cost also shown table 5 overhead cost experiments showed except instructions packed mac packed instructions small ranges variation average value assigned overhead cost packed instructions results presented greater detail 5 overhead cost mac instructions mac packed data transfer instruction especially lab changes data values registers b used mac inputs significantly wide variation overhead cost observed 14 330ma wide variation mainly due complex booth multiplier implemented mac unit typical dsp application maclab instructions usually applied sequence data filter operations ideally pairwise overhead cost used arrange data ordering total overhead cost sum register product register recoding logic register shiftadd array figure 2 microarchitecture model booth multiplier individual pairwise overhead costs minimized problem x usually available execution time hence estimation purpose average value 172ma used overhead cost maclab instructions due unavailability executiontime operands however purpose minimization single overhead cost value cannot guide search procedure better schedule sequence maclab instructions case filter applications instruction scheduling existing code may best alternative reason arrival order operands x determined environment embedded processor control scheduler thus overall design system algorithm may changed produce favorable signal statistics may always possible therefore environmental constraints order still reduce energy consumption due macs effective technique local code modification proposed section 63 based exploiting architecture booth multiplier 63 operand swapping booth multiplier booth multiplier implemented mac unit takes data registers b operands fast multiplication fundamental idea behind booth multiplication recode b socalled skipping 1s technique 6 instance 7digit value 0011110 would need four additions shifted recoded 1 simplicity requires one addition one subtraction however worst case may alternating 1s 0s bit b selects shifted version add subtract order determine many additions subtractions needed booth multiplier define weight b value number nonzero digits recoded representation instance weight 0011110 4 weight 01000 10 2 simple model microarchitecture booth multiplier depicted figure 2 booth multiplier treat b symmetrically weight recoded b determines number times added subtracted generating prod uct weight smaller b reduce number additions subtractions swapping operands registers b potentially result current reduction table 6 gives three experiments swapping operands booth multiplier reduces current significantly observation points ef table variation measured current swapping operands op1 op2 registers b maclab instructions operands measured current saving 7fffff aaaaaa 589 469 204 7fffff aaaaaa 657 491 253 fective way reduce current mac instructions swap operands b simple power consumption model based microarchitecture model booth multiplier figure empirically derived validated extensive current measurement experiments power model switching activity multiplier characterized mainly contents registers b since circuit state significant factor multiplier pairs consecutive values registers considered register bit switching consecutive values considered determine complete switching activity register part activity shiftadd array register b two factors considered first bit switching consecutive values second weight booth recodings values determines number additions subtractions shiftadd array table 7 shows average current drawn maclab different characteristics pair consecutive values b index 1 10 shown square parentheses assigned entry identify data characteristics b entry represents example entry 8 represents case high switching pair consecutive values lot switching values b addition values b high booth recoding weights table 6 first pair data example characteristics seen table 7 average current entries b high recoding weights consistently higher corresponding entries moreover see entry 9 incurs highest average current case b switch significantly b high recoding weights second pair data table 6 example case swap two sets operands b characteristics changed one new possibilities still high switching b takes values originally stored high switching low booth recodings possible swapping values operands fall case represented entry 7 table 7 thus current drawn may sharply reduced filter operations value constants c usually known time instruction scheduling scheduler calculate weight booth recoding c decide load c register recoding weight high register b recoding weight low table 8 current reduction swapping b changes operand characteristics one entry another table 7 swapping saving saving decision placement operands made based knowledge value one operands thus sometimes wrong decision may made however average determining placement operands based knowledge even one operand lead current reduction systematic investigation conducted determine possible improvements results shown table 8 known operands initially assumed register b recoding weight value b high operands swapped means case initial data characteristics fall entries last 3 columns table 7 operands swapped table 8 gives average current reduction swapping changes operand characteristics one entry another columns heading show entries table 7 result operand swap column shows new cases arise operands b registers swapped average percentage reduction current operand swapping shown column labeled saving cases either current reduction minor increase great majority cases see operand swapping significantly reduce current thus average current drawn maclab instructions reduced even though one operand instance c known schedule time operand swapping easily achieved locally modifying given instruction eg mspclab x01x11 mspclab x11x01 ad dition performance code size penalty associated 7 lowpower instruction scheduling based power analysis discussed previous sections lowpower scheduling algorithm developed algorithm described greater detail 5 algorithm schedules one basic block dsp program time looks overhead cost tables table 7 swap operands given register allocation basic block data flow graph dfg obtained block greedy soonaspossible packing procedure applied pack instructions data dependency packing rules al low alutype instruction packed data transfer instruction soon operands instructions ready dfg updated well according instructions packed table 7 average current drawn maclab different characteristics consecutive values b lowlow weight highhigh weight highlow weight low high low high high switching switching switching switching switching low switching 409 1 581 4 561 5 high switching 446 6 644 10 table 9 comparison n 5 dsp programs different scheduling techniques benchmark un p p po pos goal reduce number execution cycles therefore total energy exact execution order packed unpacked instructions determined following scheduling step effect overhead cost considered instruction packing scheduler attempts construct execution order instructions obey data depen dency minimizing total overhead cost implementation step based popular list scheduling algorithm 7 overhead cost objective function minimized pipeline stall conditions due resource constraints data hazards also handled list scheduling avoid penalties due extra cycles finally code contains multiply operations least one operands known eg filter operations like available scheduler swap operands based table 7 reduce current 8 experimental results table 9 shows experimental results five dsp programs demonstrate energy reductions possible scheduling method column 1 lists name benchmark program remaining columns show energy comparisons applying different scheduling techniques p original unpacked code p packing alone po packing overhead cost reduction pos combined application packing overhead cost reduction operand swapping first two programs fjex1 fjex2 real fujitsu applications vector preprocessing mac instructions used operand swapping applicable third program lp f ir60 length60 linear phase fir filter fourth program iir4 fourthorder direct form iir filter fifth program fft2 radix2 decimalintime fft butterfly last three programs taken embedded dsp examples 8 translated native code target processor benchmark program product n proportional energy given values parentheses relative values products column un p normalized 1 results show 3 47 energy reduction achieved instruction packing alone reason fft2 3 reduction due certain data dependency imposed unpacked code prevents mov2 instruction packed preceding asl instruction asl instruction generates new register value mov2 transfer next cycle packing list scheduling algorithm based overhead cost reduction reduce energy 4 14 packed codes cases iir4 fft 2 operand swapping applicable additional 7 4 energy still saved respectively overall energy reduction seen 11 56 source code originally unpacked 8 17 originally packed acknowledgment authors would like thank fu miyasu hirose hirohisa gambe hirokazu fukui fujitsu ltd assistance experiment setup technical discussion r power analysis embedded software first step towards software power minimization power analysis 32bit embedded microcontroller compilation techniques low energy overview saving power control path embedded processors power analysis lowpower scheduling techniques embedded dsp software computer arithmetic principles superscalar microprocessor design digital signal processing applications theory tr power analysis embedded software power analysis 32bit embedded microcontroller computer arithmetic saving power control path embedded processors ctr sbastien lafond johan lilius energy consumption analysis two embedded java virtual machines journal systems architecture euromicro journal v53 n56 p328337 may 2007 naehyuck chang kwanho kim hyung gyu lee cycleaccurate energy consumption measurement analysis case study arm7tdmi proceedings 2000 international symposium low power electronics design p185190 july 2527 2000 rapallo italy huzefa mehta robert michael owens mary jane irwin rita chen debashree ghosh techniques low energy software proceedings 1997 international symposium low power electronics design p7275 august 1820 1997 monterey california united states naehyuck chang kwanho kim hyung gyu lee cycleaccurate energy measurement characterization case study arm7tdmi ieee transactions large scale integration vlsi systems v10 n2 p146154 april 2002
tla pictures predicateaction diagrams similar standard statetransition diagrams precisely defined formulas tla temporal logic actions explain diagrams used describe aspects specificationand descriptions proved correcteven complete specification cannot written diagram also use diagrams illustrate proofs b introduction pictures aid understanding simple flowchart easier understand equivalent programminglanguage text however complex pictures confusing large spaghettilike flowchart harder understand properly structured program text pictures inadequate specifying complex systems help us understand particular aspects system picture provide informal comment must formal connection complete specification picture assertion picture correct description aspect system must precise mathematical statement use tla temporal logic actions specify systems tla specification logical formula describing possible correct behaviors system aid understanding tla formulas introduce type picture called predicateaction diagram diagrams similar various kinds statetransition diagrams used years describe sys tems starting mealy moore machines 1 2 relate pictures tla specifications interpreting predicateaction diagram tla formula diagram denoting formula correct description system specification iff implies therefore provide precise statement means diagram describe specification use predicateaction diagrams three ways believe new precisely defined formal notation ffl describe aspects specification even feasible write complete specification diagram ffl draw different diagrams provide complementary views system ffl illustrate formal correctness proofs section ii brief review tla leisurely introduction tla appears 3 section iii describes predicateaction diagrams using ninput muller celement example shows diagrams used describe aspects complete specification provide complementary views system section iv gives another example predicateaction diagrams used describe system shows used illustrate proof ii tla describe syntax semantics tla description illustrated formulas defined figure 1 symbol delta means equals definition assume infinite set variables x class semantic values variables flexible variables temporal logic analogous variables programming language tla also includes rigid variables predicate logic analogous constant parameters program ignore class values includes numbers strings sets functions state assignment values variables behavior infinite sequence states semantically tla formula true false behavior syntactically tla formulas built state functions using boolean operators implication j equivalence operators 0 2 described tla also hiding operator 999 999 use state function nonboolean expression built variables constants constant operators semantically assigns value statefor example assigns state one plus value assigns variable x state predicate often called predicate boolean expression built variables constants constant operators semantically true false statefor example predicate init phi true state iff assigns value zero x action boolean expression containing primed unprimed variables semantically action true false pair states primed variables referring second statefor example action 1 true hs ti iff value state assigns x equals one plus value state assigns x values assigned states equal pair states satisfying action called step thus 1 step one increments x one leaves unchanged f state function state predicate write f 0 expression obtained priming variables f example phi equals 0 action state function v init phi fig 1 tla formula phi describing simple program repeatedly increments x define v equal v v step either step step leaves value v unchanged thus 1 step one increments x one leaves unchanged else leaves ordered pair hx yi unchanged since tuple unchanged iff component unchanged 1 step one increments x one leaves unchanged else leaves x unchanged define hai v equal v 0 6 v step 1 step changes x since unchanged hm 1 hxyi step step increments x 1 changes value x leaves unchanged say action enabled state iff exists state hs ti step example 1 enabled iff possible take step increments x one changes x leaves unchanged since natural number x action hm 1 hxyi enabled state x natural number enabled state x equals 1 tla formula true false behavior predicate true behavior iff true first state action true behavior iff true first pair states usual temporal logic f formula 2f formula meaning f always true thus 2init oe true behavior iff x equal zero every state behavior formula 2m hxyi true behavior iff step pair successive states behavior step using 2 enabled predicates define fairness operators wf sf asserts behavior infinitely many hai v steps infinitely many states hai v enabled words wf v asserts hai v becomes enabled forever infinitely many hai v steps occur strong fairness formula sf v asserts either infinitely many hai v steps finitely many states hai v enabled words asserts hai v enabled infinitely ten infinitely many hai v steps occur standard form tla specification init init predicate n action v state function l conjunction fairness con ditions formula asserts behavior init true initial state ii every step behavior n step leaves v unchanged iii l holds formula phi figure 1 form asserting initially x equal zero ii every step either increments x one leaves unchanged increments one leaves x unchanged leaves x unchanged iii fairness condition wf hx yi holds formula wf hx yi 1 asserts infinitely many steps hm 1 hxyi infinitely often enabled since ii imply x always natural number hm 1 hxyi always enabled hence wf hx yi 1 implies infinitely many steps x incremented infinitely often simi larly wf hx yi 2 implies incremented infinitely r e l e e fig 2 muller celement often putting together see phi true behavior iff x initially zero ii every step increments either x one leaves unchanged else leaves x unchanged iii x incremented infinitely many times formula init 2n v safety property 4 describes steps allowed require anything happen formula satisfied behavior satisfying initial condition variables ever change fairness conditions used specify something must happen iii predicateaction diagrams example take example muller celement 5 circuit n binary inputs one binary output shown figure 2 figure indicates considering closed system consisting celement together environment initially inputs output equal output becomes 0 inputs 0 becomes 1 inputs 1 input changes must remain stable output changes behavior 2input celement environment described predicateaction diagram figure 3a c defined short arrows originating node identify nodes labeled c0 0 0 c1 1 1 initial nodes indicate celement starts state satisfying 1 arrows connecting nodes indicate possible state transitions example state satisfying c1 1 1 possible system go state satisfying either c0 1 1 c1 0 1 precisely arrows indicate steps triple hin1 in2 outi changesthat transitions least one in1 in2 changes steps change variablesfor example variables representing circuit elements inside environmentbut leave hin1 in2 outi unchanged also possible predicateaction diagram figure 3a looks like standard statetransition diagram however interpret formally conventional state machine predicateaction diagram delta au au delta delta au au delta r r b corresponding tla formula fig 3 predicateaction diagram hin1 in2 outi 2input celement corresponding tla formula tla formula figure 3b 1 formula form init state predicate one conjunct f node predicate init f describes possible state changes starting state described node example formula f node labeled c1 1 0 predicateaction diagram represents safety property include fairness conditions figure 3a reasonable way describe 2input celement however corresponding diagram 3 input celement would quite complicated way draw diagram ninput circuit general specification written directly tla formula figure 4 array inputs represented formally variable whose value function domain brackets denote function applica tion formally n rigid variableone whose value constant throughout behavior introduce two pieces notation representing functions denotes function f domain f equals ei every ffl f except denotes function g f except gi equals e formulas defined figure 4 following interpretation init c state predicate asserting either 0 1 function domain ng ini equals domain inputi action enabled iff equals complements ini leaves j unchanged j 6 leaves unchanged symbol param eter output action enabled iff ini different complements leaves unchanged list formulas bulleted denotes conjunction disjunction also used ordinary infix operators init c ng 7 ng 6 next ng inputi wf hin outi output fig 4 tla specification ninput celement next action disjunction output input actions ng thus next step either output step inputi step input line pi c temporal formula specification celement together environment asserts init c holds initially ii every step either next step else leaves hin outi unchanged iii output cannot enabled forever without output step occurring fairness condition iii requires output change inputs inputs required change since predicateaction diagrams describe safety properties fairness condition irrelevant explanation dia grams specification pi c short precise however readerfriendly predicateaction diagram therefore use diagrams help explain specification beginning predicateaction diagram figure 5 diagram state function hin outi meaning describes transitions change hini outi diagram formula pi c meaning represents formula implied pi c diagram shows synchronization celements ith input output draw many different predicateaction diagrams oe ae oe ae oe ae oe ae omega omega omega oe j omega omega omega ae fig 5 predicateaction diagram hini outi specification pi c ninput celement 1 fig 6 another predicateactiondiagram hini outi pi c specification figure 6 shows another diagram hin outi pi c simpler one figure 5 contains less information indicate values ini always 0 1 show variable changed transition latter information added diagram figure 7a transition labeled action label input lefttoright arrow indicates transition state satisfying state satisfying ini 6 inputi step diagram represents tla formula figure 7b even information conveyed predicateaction diagram hin outi also shows transitions leave ini unchanged change inj j 6 diagram drawn figure 8a figure 8b gives corresponding tla formula innumerable predicateaction diagrams drawn specification figure 9 shows yet another diagram celement specification pi c since relying diagrams specification simply help explain specification show much little information wish predicateaction diagram hini outi output b corresponding tla formula fig 7 informative predicateaction diagram hini outi pi c corresponding tla formula predicateaction diagram hin outi 6 output u u b corresponding tla formula fig 8 predicateaction diagram hin outi pi c corresponding tla formula 1 6 u u fig 9 yet another predicateaction diagram hin outi pi c draw multiple diagrams illustrate different aspects system actual specifications written tla formulas much expressive pictures b formal treatment b1 definition first define precisely tla formula represented diagram formally predicateaction diagram consists directed graph subset nodes identified initial nodes node labeled state predicate edge labeled action assume given diagram state function v introduce following notation n set nodes set initial nodes en set edges originating node n de destination node edge e pn predicate labeling node n e action labeling edge e formula delta represented diagram defined follows init delta explicit label attached edge e take e true set initial nodes explicitly indicated take n usual convention quantification empty set defined equal false edges originating node n b2 another interpretation another possible interpretation predicateaction diagram formula b delta defined perhaps obvious interpretationespecially diagram viewed description nextstate relation show delta always implies b delta converse implication holds predicates labeling nodes disjoint delta simple invariance proof using rule inv1 3 figure 5 page 888 shows delta implies 29 n conjunction 8 equivalent predicate logic since b c implies 2bv holds n n 6 n implies delta propositional logic hypothesis implies result follows simple temporal reasoning essentially reverse string equivalences implication used prove usually label nodes predicateaction diagram disjoint predicates case b imply interpretations delta b equivalent diagrams nondisjoint node labels may occasionally useful delta convenient interpretation diagrams c proving predicateaction diagram saying diagram predicateaction diagram specification pi asserts pi implies formula delta represented diagram formula pi usually form init pi 2m u l l fairness condition prove pi delta prove 1 init pi 2 init pi 2m u node n first condition assertion predicates generally easy prove prove second condition one usually finds invariant inv init pi 2m u implies 2inv pi implies 2m inv u second condition proved showing inv u implies node n usually u v tuples every component v component u v case one need show minv implies p n n definition means proving node n formula asserts step starts pn inv true changes v em step ends state satisfying p dm edge originating node n iv illustrating proofs tla distinction specification property formulas verification means proving one formula implies another practical relatively complete set rules proving implications described 3 show predicateaction diagrams used illustrate proofs take example one treated 3 specification psi defined section iva implies specification phi defined section ii another specification define tla formula psi describing program two processes repeatedly loops sequence operations p sem increment v sem one process increments x one increments one p sem v sem denote usual operations semaphore sem describe program formally introduce variable pc indicates control state process three control points call b g quotes indicate string values motivate definition psi three predicate action diagrams psi figure 10 diagrams predicate pc p q asserts control p process 1 q process 2 figure 10a shows control state changes p sem v sem increment actions performed variables pc mentioned edge label left unchanged indicated stepsfor example steps described edge labeled leave sem unchangedbut asserted diagram nextstate action n written disjunction n 1 n 2 nextstate actions process n written disjunction figure 10b illustrates decomposition finally predicateaction diagram figure 10c describes semaphore variable sem changes write specification psi let pc function domain f1 2g pci indicating control resides process formula pc p q defined phi phi phi phi phi upsilon r b phi phi phi phi phi upsilon r c u fig 10 three predicateaction diagrams hx semaphore actions p v defined sem sem sem missing figure 10 specification initial values x take zero fairness con dition one could augment predicateaction diagrams notation indicating fairness conditions however conditions easy represent diagram expressive enough describe variety fairness requirements arise practice wf sf formu las expressive enough easy represent graphically attempted represent fairness diagrams take fairness condition specification psi strong fairness nextstate action n process complete definition psi appears figure 11 b illustrated proof proof psi phi broken proof three conditions 1 init psi init phi 2 init psi 2n 3 psi wf hxyi illustrate proofs conditions 2 3 predicateaction diagram hx psi figure 12 q defined nat set natural numbers first must show diagram figure 12 predicateaction diagram psi easy using definition section iiib1 invariant needed example condition proved node labeled n step starts true 1 step one increments x leaves unchanged makes q 0 g true follows easily definitions q n since n step starting pc b true must fi 1 step prove condition 2 suffices prove every step allowed diagram figure 12 hxyi step steps shown explicitly diagram ones leave w unchanged steps leave hx yi unchanged hxyi steps actions labeling edges diagram imply hxyi steps shown ex 7init psi sem sem fig 11 specification psi phi phi phi phi phi upsilon r fig 12 another predicateaction diagram hx plicitly diagram also hxyi steps proves condition 2 sketch proof condition 3 prove wf hxyi suffices show infinitely many steps occur first observe predicates labeling node diagram implies either enabled fairness condition psi implies behavior cannot remain forever node must keep moving diagram hence behavior must infinitely often pass node predicate q 1 implies hn 1 w hn 2 w enabled hence fairness condition implies infinitely many hn 1 w steps infinitely many hn 2 w steps must occur action hn 1 w enabled three nodes top loop taking infinitely many hn 1 w steps therefore possible going around top loop infinitely many times implies infinitely many 1 steps occur starting state q 0 b true since nat 1 step starting hm 1 hxyi step hence infinitely many hm 1 hxyi steps occur similarly taking infinitely many hn 2 w steps implies infinitely many steps occur completes proof condition 3 using predicateaction diagram simplify proof make argument given rigor ous would go precisely steps proof described 3 however diagram allow us visualize proof help us understand v conclusion described three uses diagrams believe new diagrams precise formal semantics ffl describe particular aspects complex specification simple diagram ninput celement cannot specified simple picture however explained specification diagrams describing synchronization output individual input ffl provide complementary views system diagrams b c figure 10 look quite different diagrams specification ffl illustrate proofs disjunction predicates labeling nodes figure 12 equals invariant proof section 72 3 diagram provides graphical representation invariance proof tla differs traditional specification methods two important ways first tla specifications interpreted set states instead assigning values variables appear specifica tion state assigns values infinite number variables appear specification second tla specifications invariant stuttering formula neither require rule finite sequences steps change variables mentioned formula statefunction subscripts tla formulas guarantee invariance stuttering two differences lead two major differences traditional statetransition diagrams predicate action diagrams traditional diagrams node represents single state states tla assign values infinite number variables impossible describe single state formula formula specify values finite number variables draw diagrams tla formulas let node represent predicate describes set states traditional di agrams every possible state change indicated edge tla formulas invariant stuttering draw diagrams particular state functionsusually tuples variables tla differs specification methods logic uses simple logical operations like implication conjunction instead complicated automatabased notions simulation composition 6 everything done predicateaction diagrams done statetransition diagrams purely statebased formalism however conventional formalisms must use notion homomorphism diagrams describe expressed tla logical implication formalisms employing statetransition diagrams purely statebased use states events nodes represent states edges describe input output events meaning diagram sequence events allows states effectively hidden tla states events systems described terms changes interface variables rather terms interface events variables describing internal state hidden existential quantifier 999 999 described 3 changes variable whether internal interface indicated node labels edge labels hence purely statebased approach like tla allows flexibility diagrams drawn method based states events r method synthesizing sequential circuits gedankenexperiments sequential machines temporal logic actions defining liveness introduction vlsi systems conjoining specifications tr ctr lusini e vicario engineering usability visual formalisms case study real time logics proceedings working conference advanced visual interfaces may 2427 1998 laquila italy harold thimbleby user interface design matrix algebra acm transactions computerhuman interaction tochi v11 n2 p181236 june 2004 jules desharnais marc frappier ridha khdri ali mili integration sequential scenarios acm sigsoft software engineering notes v22 n6 p310326 nov 1997 jules desharnais marc frappier ridha khdri ali mili integration sequential scenarios ieee transactions software engineering v24 n9 p695708 september 1998 l e moser ramakrishna g kutty p melliarsmith l k dillon graphical environment design concurrent realtime systems acm transactions software engineering methodology tosem v6 n1 p3179 jan 1997
optimistic register coalescing graphcoloring register allocators eliminate copies coalescing source target nodes copy interfere interference graph coalescing however harmful colorability graph tends yield graph nodes higher degrees unlike aggressive coalescing coalesces pair noninterfering copyrelated nodes conservative coalescing iterated coalescing perform safe coalescing preserves colorability unfortunately heuristics give coalescing early losing many opportunities coalescing would turn safe moreover ignore fact coalescing may even improve colorability graph reducing degree neighbor nodes interfering source target nodes coalesced article proposes new heuristic called optimistic coalescing optimistically performs aggressive coalescing thus exploiting positive impact coalescing aggressively coalesced node spilled split back separate nodes since better chance coloring one splits reduce overall spill amount b introduction many optimizing compilers take approach graph coloring global register allocation 1 graph coloring abstracts problem assigning registers live ranges program problem assigning colors nodes interference graph register allocator attempts color graph finite number machine registers one constraint two nodes connected interference edge must colored different registers allocator fails color graph nodes must spilled memory inserting loads stores graph coloring minimal number spills wellknown npcomplete problem many heuristic algorithms used 1 2 3 one important task register allocator copy propagation context graph coloring copy propagation achieved simply coloring source target node copy call copyrelated nodes single register interfere interference graph implemented coalescing two nodes single node interference edges unioned since many optimization phases register allocation including instruction scheduling 4 storetocopy promotion 5 static single assignment ssa translation 6 leave behind many copies slow program execution essential minimize copies coalescing may affect colorability interference graph since coalesced node union interference edges source target nodes coalesced might possible color coalesced node makes register allocation problem challenging need minimize spill cost maximizing number coalesced copies couple coalescing heuristics proposed handle optimization problem original chaitins register allocator uses aggressive coalescing coalesces pair non interfering copyrelated nodes 1 obviously achieves best result copy elimination yet might suffer worst spill briggs et al developed heuristic called conservative coalescing 2 performs coalescing colorability graph affected george appels iterated coalescing eliminates copies interleaving briggs heuristic coloring simplification phase increases chance conservative coalescing 7 conservative coalescing iterated coalescing attempt avoid negative impact coalescing often ignored coalescing may even improve colorability node x interferes source target nodes coalesced number edges x reduced one coa lescing may yield additional opportunities simplification graph improving overall col orability order fully exploit positive impact coalescing prefer use aggressive coalescing except spill must controlled somehow paper proposes new coalescing heuristic called optimistic coalescing optimistically coalesces pairs noninterfering nodes chaitins heuristic yet coalesced node needs spilled node split back two separate nodes giving coalescing since split node less number interference edges original coalesced node might possible color one without affecting rest coloring coloring one leads reduction spill cost rest paper organized follows section briefly reviews graphcoloring register allocation section 3 describes previous coalescing heuristics graphcoloring framework section 4 describes optimistic coalescing heuristic experimental results presented section 5 summary follows section 6 2 graphcoloring register allocation graph coloring problem assigning colors nodes given graph two nodes connected edge different colors graphcoloring register allocation node graph corresponds live range program number colors represents machine registers two overlapping live ranges said interfering corresponding nodes connected edge since coloring general graph g k colors npcomplete need heuristic algorithm chaitin et al implemented graphcoloring register allocation based following theorem 1 node x less k neighbors always colorable matter gfxg colored node x called lowdegree node node equal k neighbors called significantdegree node chaitins allocator repeatedly removes lowdegree nodes associated edges graph pushes nodes top stack simplify phase either graph empty every node graph significant graph empty allocator repeatedly takes nodes back top stack assigns machine registers according interference constraints select phase however every node significant allocator heuristically selects nodes store values memory marks spilling allocator inserts spill instructions defuse instruction marked live ranges spill phase allocation steps repeated scratch phase ordering chaitins coloring algorithm depicted figure 1 renumber phase build phase also shown allocator constructs live ranges builds interference graph respectively phase aggressive coalescing described next section build simplify chaitinstyle renumber potential renumber build coalesce select actual spill select aggressive conservative coalesce b simplify spill spill spill graph empty significant every node coalesce coalesce figure 1 phase ordering chaitins allocator b briggs optimistic allocator order reduce number spilled nodes briggs et al introduced optimistic coloring 2 every node significant instead marking node spilling allocator removes pushes stack called potentialspill select phase indeed color node actuallyspilled idea might chance color available significant degree node depending coloring neigh bors yet opportunity pessimistically given early chaitins algorithm figure 1 b shows phase ordering optimistic coloring 1 1 original flow graph briggs optimistic allocator 3 approaches copy coalescing coalescing includes negative positive impacts coloring interference graph two nodes coalesced coalesced node union edges coalesced might make kcolorable graph kcolorable hand node interferes nodes coalesced degree node reduced one may expose opportunities simplifying graph example consider interference graphs figure 2 solid line represents interference edge dotted line indicates copyrelated edge b coalesced figure 2 twocolorable graph becomes graph twocolorable figure b however graph cannot simplified two colors simplified coalescing making graph twocolorable chaitins coloring heuristic b c b c c c ad ab b figure 2 examples negative impact b positive impact coalescing two major heuristic approaches coalescing one eliminating coalescible copies causing side effect fully exploiting positive impact chaitins aggressive coalescing corresponds focuses reducing negative im pact basic idea employed conservative coalescing iterated coalescing 31 approach aggressive coalescing chaitins register allocator performs aggressive coalescing coalesces two noninterfering copy related nodes perspective copy elimi nation aggressive coalescing achieves best result perspective coloring graph fully exploits positive impact totally ignores negative impact unfortunately advantage positive impact aggressive coalescing never noted literature never cludes rematerialization phase 2 generates copies removed conservative coalescing see section 32 omitted version optimistic allocator evaluate conservative coalescing general coalescing heuristic bounded specific optimization questioned positive impact interacts negative impact affecting overall colorability graph aggressive coalescing employed briggs optimistic allocator experimental results indicate positive impact well outweigh negative impact coloring graph better conservative coalescing iterated coalescing see section 5 32 approach conservative coalescing briggs optimistic allocator includes optimization phase called rematerialization reduces spill cost live range value cheaply reproducible constant 2 finding rematerializable values involves ssa transformation yields many copies oenodes copies unlike copies coalesced aggressively must coalesced conser vatively reckless coalescing would completely restore transformation performed rematerial ization undesirable coalesce two nodes different rematerialization tags chance coalesced node spilled motivated heuristic conservative coalescing based following theorem 2 given two nodes x coalesced node xy less k significantdegree neigh bors xy change colorability interference graph every lowdegree node removed graph coalesced node xy certainly removed also since originally less k significantdegree neighbors consequently conservativelycoalesced node never spilled noted care taken counting number significantdegree neighbors xy since simple union significantdegree neighbors individual x might include node becomes lowdegree coalescing xy positive impact coalescing let x sets significantdegree neighbors x respectively number elements set significantdegree neighbors xy ns xy computed follows k coalescingg 2 order complement conservativeness co alescing biased coloring used select phase 2 biased coloring eliminates copies trying assign register copyrelated nodes appears iterated coalescing algorithm 7 ignores term computing number significantdegree neighbors failing perform conservative coalescing fully implementation include term fair comparison coalesced due conservativeness heuristic iterated coalescing proposed coalesce copies conservatively 7 performs conservative coalescing iteratively interleaved simplification phase exposes chances conservative coalescing figure 3 depicts phase ordering iterated coalescing top optimistic allocator build freeze potential renumber actual spill conservative coalesce select simplify chaitinstyle coalesce freeze freeze copy coalesce spill empty graph coalesce figure 3 phase ordering iterated coalescing top optimistic allocator iterated coalescing allocator maintains two groups nodes one group set copyrelated nodes complementary set non copyrelated nodes simplifying lowdegree noncopy related nodes decrease degree many copy related nodes yielding opportunities conservative coalescing coalesced node put group noncopyrelated nodes copy related neighbor edges noncopyrelated nodes significantdegree nodes two copy related nodes coalescible allocator freezes one lowdegree copyrelated nodes freezing copyrelated node means giving coalescing removing copyrelated edges marking noncopyrelated node frozen node may simplified next iteration nodes groups significantdegree nodes potential spill made iteration simplification coalescing continues 321 problems conservative coalescing problem heuristic conservative coalescing twofold first heuristic gives coalescing early considering coalescible node violates heuristic necessarily spilled somewhat similar motivating idea briggs optimistic allocator potentiallyspilled node necessarily actuallyspilled thus better delay spill decision later may also want delay spill concern later many coalesced nodes violate heuristic actuallyspilled spill cost held modest level case actuallyspilled section 53 includes experimental data justify delaying spill concern later secondly heuristic less exploits positive impact coalescing consider example interference graph figure 4 let us assume three colors available b lowest spill cost graph since conservative coalescing iterated coalescing fail coalesce b c b smallest spill cost potentially spilled pushed stack b removed graph nodes simplified pushed stack shown right select phase node assigned color shown right column stack except b must actuallyspilled e colored 2 1 every node would assigned color yet always guaranteed c e e d212spill c f e coloring stack223h f e bc b coloring stack bc figure 4 allocation conservative coalescing b aggressive coalescing however coalescing b c yields lowdegree node figure 4 b allows every node graph simplified legal coloring without spill shown right column stack question often opportunities arise real programs 4 optimistic register coalescing order fully exploit positive impact coa lescing optimistically perform aggressive coalescing simplification phase chaitins register allocator implement aggressive coalescing top briggs optimistic allocator reduce spill cost actual spill needs made coalesced node attempt reduce spill cost technique called live range splitting live range splitting spill cost reduction technique used many optimizing compilers 2 3 8 9 10 11 long live range split shorter ones copies loadstores inserted carefully selected places register allocator avoid spills live range splitting since shorter live range likely allocated registers longer one cost involved additional splitting instructions yet generally lower spill instructions even allocator cannot avoid spill completely spill cost lower live range splitting splits spilled others allocated registers unfortunately live range splitting global register allocation easy implement due several reasons 11 12 primary difficulty deciding insert splitting instructions context reducing spill cost coalesced node live range splitting straightforward insert splitting copy original location coalesced copy located context live range splitting undo coalescing coalesced node xy needs spilled selection phase split back x recovering original interference edges might possible color two split nodes degree node lower xy three possible cases coloring two split nodes first node colorable different color however assigning different colors point select phase might ruin rest coloring node xy stack simplified based fact x distinct eg common neighbor node x whose degree reduced coalescing thus simplified node might colorable colored neighbors conse quently better color one node preferably node higher spill cost without affecting rest coloring give coloring node though instead marking uncolored node actual spill moment try find color processing nodes left stack color available node point safe color second case x colored cannot vice versa case marked actual spill finally none x colored case mark actual spill equal spilling original node xy example consider loop figure 5 whose interference graph figure 5 b let us assume two colors available optimistic coalescing coalesce b aggressively shown figure 5 c since nodes simplified potential spill made coalesced node ab chosen potential spill simplification result stack figure 5 assigning two colors successfully c selection phase color available ab ab split back yields interference graph figure 5 b since b colorable stack empty nodes colored safely ab c c ab c b coalescing splitting ab c c0 goto l1 b c e figure 5 example live range splitting due live range splitting preferred choose coalesced node potentialspill figure 5 c chosen potential spill instead coalesced node ab stack would formed figure 5 e case ab c would assigned colors first makes actuallyspilled one candidate coalesced node potentialspill one ingredient nodes preferred better chance colored split eg coalesced node xyz composed three nodes preferred uv composed two nodes preference included estimation spill cost follows given node x let g n denote degree x number ingredient nodes x number usedef instructions x respectively addition usedef instruction spill cost loop nest denoted c l respectively spill cost computed 10dg split coalesced node xyz first split three individual nodes x z check colored individually nodes cannot colored spilled right away point remaining colorable nodes make every possible combination split test colored order testing based spill cost split example z colored individually spill costs 10 5 3 respectively test splits 3 example ab c one def two use instructions copy coalesced away assuming spill cost load store c loop nest level l one spill cost ab 300 smaller either c 300 consequently ab chosen potentialspill following z 3 neither xy xz colored x colored point z set aside later decision coloring nodes stack processed one following occurs z 1 colored single color 2 colored differently 3 one colored spilled 4 spilled x z colored different colors means coalescing completely undone copies recovered splitting coalesced node three nodes procedure applied phase ordering optimistic coalescing top optimistic register allocator shown figure 6 regarding spatial overhead optimistic coa lescing allocator keep information original interference edges nodes coalesced due possibility live range splitting freed right coalescing heuristics temporal overhead testing colorability every possible combination splits involves computational complexity o2 n n number nodes considered previous example splitting xyz n three experiments indicate n 187 average yet reaches 9 n large avoid unnecessary tests excluding redundant testing eg check xyz colorable already known xy colorable timing overhead live range splitting compensated eliminates actual spills obviating additional iterations allocation phases renumber build select actual spill coalesce aggressive split live range undo coalesce simplify chaitinstyle potential spill graph empty significant every node coalesce figure 6 phase ordering optimistic coalescing top optimistic allocator 5 experimental results order evaluate optimistic coalescing compared previous coalescing heuristics performed empirical study context instruction scheduling nonnumerical code register allocation problem context highly challenging aggressive code scheduling presence complex control flows generates many copies increases register pressure experimented four coalescing heuristics environment 51 experimental environment experiments performed sparcbased testbed 13 input c code compiled optimized sparc assembly code register windows gcc compiler sparcbased assembly code scheduled highperformance vliw code aggressive scheduling techniques software pipelining allpath code mo tion renaming 4 final vliw code simu lated producing execution results benchmarks composed seven nontrivial integer programs eqntott espresso li compress yacc sed gzip resource constraint vliw machine 16alus 8way branching machine generalpurpose registers 16 condition registers targeted scheduling register allocation aggressive scheduling compiler renames registers using copies asneeded basis parallelism opportunities arise example xx4 cannot moved due target register x eg x live target branch want move instruction speculatively branch target renamed x copy instruction copy xx left original place instruction copy later eliminated equivalent live range renaming represents general way get rid nontrue data dependences instruction scheduling context software pipelining copies generated circumvent crossiteration register overwrites 14 coalescible due interferences code order remove inter ferences unroll loop makes many copies coalescible 15 unrolling perform register allocation coalescing yields scheduled code less copies experiment context eliminating copies generated instruction scheduling 52 coalescing spill results oeooo f tmff sooo average fooo ooo ooo ooooooooof figure 7 ratio eliminated copies compared basecase allocator implemented four coalescing heuristics conservative iterated aggressive optimistic top optimistic allocator base case also implemented chaitins original register allocator based aggressive coalescing figure 7 depicts ratio number copies eliminated heuristic copies eliminated base case allocator ie 100 means copies eliminated chaitins allocator graph shows conservative iterated aggres sive optimistic coalescing remove average 629 760 960 956 copies removed chaitins respectively graph indicates optimistic coalescing removes almost number copies aggressive coalescing obviously difference 04 due undo coalescing live range splitting one thing note graph aggressive coalescing top briggs allocator removes average 4 less copies top chaitins al locator due fact chaitins allocator generates spills make otherwise un coalescible copies coalescible example consider copy xy coalescible first round chaitins briggs allocators live ranges x interfere eg definition right copy chaitins allocator spills x briggs chaitins might able coalesce copy second round x split smaller pieces making x xy interfere chaitins allocator eliminates copies briggs expense spills oeooo f tmff sooo average fooo ooo ooo ooooooooof figure 8 ratio spill instructions compared basecase allocator figure 8 shows ratio number spill instructions generated heuristic spill instructions generated chaitins 100 means spill instructions generated chaitins graph shows optimistic coalescing generates smallest number spill instructions benchmarks aggressive coalescing also better conservative coalescing iterated coalescing 4 except eqntott average difference aggressive coalescing optimistic coalescing 5 due advantage coloring caused live range splitting 53 evaluation spill results spill results indicate aggressive coalescing makes positive impact coalescing outweigh negative impact improving overall colorability graph order confirm analyzed experimental results detail estimate positive impact negative impact first estimate negative impact coalescing measuring many nodes coalesced violation conservativeness heuristic indeed actuallyspilled memory evaluate aggressive coalescing delays spill concern later justified avoid confusion following discussion use term node single primitive node created first build phase term chunk coalesced node composed several nodes compress conservative coalescing iterated coalescing generate spill instructions even chaitins allocator found positive impact coalescing well outweighs even benefit optimistic register allocation benchmark num nodes num nodes aggressive optimistic coalesced chunks violating chunks num spilled ratio num spilled ratio num chunks num chunks nodes chunks nodes chunks espresso 12731 4134 9659 2987 911 352 94 629 397 65 li 1478 492 compress sed average 56 32 table 1 numbers nodes coalesced chunks violating chunks actuallyspilled nodes benchmark num nodes spilled nodes colored nodes successful successful candidate chunks fully partially fully coloring split num chunks spilled spilledcolored colored ratio chunks chunks chunks li compress sed average 520 868 table 2 detailed data live range splitting table 1 first column shows number coalesced chunks pushed stack firstround optimistic register allocation aggressive optimistic coalescing see figure 6 number nodes chunks many chunks formed violation conservativeness heuristic number violating chunks number nodes violating chunks shown next column among nodes violating chunks number nodes actuallyspilled memory aggressive coalescing optimistic coalescing described number chunks third fourth columns respectively aggressive coalescing average 56 nodes among coalesced non conservatively actuallyspilled memory means remaining 944 nodes conservative coalescing misses coalescing opportunity even though colored successfully spill rate drops 32 optimistic coalescing help live range splitting analyzed detail table 2 among violating chunks table 1 first column table 2 shows number chunks candidate live range splitting number nodes chunks 5 candidate chunk belongs one following three categories live range splitting 5 noted set candidate chunks set potentiallyspilled chunks set violating chunks denoted p v respectively following relationship always holds ae p ae v ffl fullyspilled meaning splits spilled memory ffl fullycolored meaning splits colored successfully ffl partiallyspilledcolored meaning splits spilled rest colored table 2 shows number fullyspilled fullycolored partiallyspilledcolored chunks number nodes chunks 6 ratio successfully colored nodes split candidate nodes average 520 ratio successfully split chunks ie least one whose splits colored candidate chunks average 868 reason optimistic coloring spills less compared aggressive coalescing one thing note number actually spilled chunks aggressive coalescing table 1 equal number split candidate chunks fact actualspill candidate chunks optimistic coalescing table 2 reason compared spilling aggressive coalescing splitting optimistic coalescing imposes constraints subsequent coloring selection phase making chunks stack actualspill candidates results indicate negative impact coalescing alleviated optimistic allocation 6 noted number spilled nodes chunks optimistic coalescing table 1 sum partiallyspilled fullyspilled chunks table 2 live range splitting positive impact coalesc ing order analyze positive impact coa lescing need measure number successfully colored nodes due positive impact would otherwise spilled memory unfortunately number straightforward measure instead measured reduction interference edges due positive impact depicted table 3 benchmark first column shows number interference edges right first build phase rest table shows number edges removed due positive impact heuristic first selection phase table shows aggressive coalescing removes four times many interference edges iterated coalescing average bench num num deleted edges mark original conser iterated aggressive edges vative optimistic espresso 744637 7530 16818 103032 li 103457 1554 2311 6524 compress 9228 106 217 866 sed 71366 1399 3156 6614 table 3 number reduced interference edges due positive impact coalescing 6 summary paper proposed new coalescing heuristic fully exploits positive impact coalescing via aggressive coalescing top optimistic allocation never evaluated separately aggressive coalescing compared conservative coalescing context optimistic allocation whereas iterated coalescing recent research work coalescing focused improving conservative coalescing experimental results indicate aggressive coalescing actuality competitive optimistic allocation also shown negative impact aggressive coalescing mitigated live range splitting phase reverse problematic coalescing premature conclude approach optimistic coalescing always better approach conservative coalescing two approaches fundamentally different evaluated one context register allocation hand analysis scheduled code reveal special characteristics would make optimistic coalescing particularly useful register allocation left future work evaluate heuristic contexts leading general solution coalescing register allocation r register allocation spilling via graph coloring improvements graph coloring register allocation prioritybased coloring approach register allocation parallelizing nonnumerical code selective scheduling software pipelin ing register promotion c programs ferrante b iterated register coalesc ing loadstore range analysis global register allocation live range splitting graph coloring register allocation spill code minimization via interference region spilling register allocation via graph coloring software pipelining effective scheduling technique vliw machines tr software pipelining effective scheduling technique vliw machines prioritybased coloring approach register allocation efficiently computing static single assignment form control dependence graph loadstore range analysis global register allocation register allocation via graph coloring improvements graph coloring register allocation iterated register coalescing spill code minimization via interference region spilling callcost directed register allocation register promotion c programs parallelizing nonnumerical code selective scheduling software pipelining fusionbased register allocation using node merging enhance graph coloring optimal spilling cisc machines registers unrollbased copy elimination enhanced pipeline scheduling live range splitting graph coloring register allocator register allocation myampersandamp spilling via graph coloring ctr takuya nakaike tatsushi inagaki hideaki komatsu toshio nakatani profilebased global liverange splitting acm sigplan notices v41 n6 june 2006 christian wimmer hanspeter mssenbck optimized interval splitting linear scan register allocator proceedings 1st acmusenix international conference virtual execution environments june 1112 2005 chicago il usa florent bouchez alain darte fabrice rastello complexity register coalescing proceedings international symposium code generation optimization p102114 march 1114 2007
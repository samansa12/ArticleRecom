approximating minimum equivalent digraph meg minimum equivalent graph problem following given directed graph find smallest subset edges maintains reachability relations nodes problem nphard paper gives approximation algorithm achieving performance guarantee 164 polynomial time algorithm achieves performance guarantee 175 time required transitive closure heart meg problem minimum scss strongly connected spanning subgraph problem meg problem restricted strongly connected digraphs minimum scss problem paper gives practical nearly lineartime implementation achieving performance guarantee 175 algorithm analysis based simple idea contracting long cycles analysis applies directly 2exchange general local improvement algorithm showing performance guarantee 175 b introduction connectivity fundamental study graphs graph algorithms recently many approximation algorithms finding minimumsubgraphs meet given connectivity requirements developed 1 9 11 15 16 24 results provide practical approximation algorithms nphard networkdesign problems via increased understanding connectivity properties techniques developed applicable undirected graphs consider basic networkdesign problem directed graphs 2 12 13 18 follows given digraph find smallest subset edges forming minimum equivalent graph meg maintains reachability relations original graph meg problem restricted stronglyconnected graphs call minimum scss strongly connected spanning subgraph problem meg problem restricted acyclic graphs call acyclic meg problem problem reduces linear time 5 single acyclic problem given socalled strong component graph together one minimumscss problem strong component given subgraph induced component furthermore approximating meg problem lineartime equivalent approximating restricted versions moyles thompson 18 observe decomposition give exponentialtime algorithms restricted problems hsu 13 gives polynomialtime algorithm acyclic meg problem related problem finding transitive reduction digraph smallest set edges yielding reachability relations studied aho garey ullman 2 transitive reduction differs meg problem edges computer science department institute advanced computer studies university maryland college park md 20742 research supported nsf research initiation award ccr computer science department university texas dallas richardson z school operations research industrial engineering cornell university ithaca ny 148533801 part work done umiacs supported part nsf grants ccr8906949 ccr9111348 email neyoriecornelledu transitive reduction required original graph however transitive reduction problem decomposes like meg problem acyclic strongly connected instances strongly connected instance transitive reduction given hamilton cycle vertices acyclic instance transitive reduction unique aho et al observe equivalent meg problem consists edges u v alternate path u v fact aho garey ullman show transitive reduction problem equivalent transitive closure problem thus acyclic meg problem reduces transitive closure acyclic meg problem solved polynomial time whereas minimum scss problem nphard 8 consequently paper focuses approximation algorithms minimumscss problem observations preceding paragraphs performance guarantees obtained minimum scss problem carry general meg problem overhead solving single instance transitive closure 11 results given strongly connected graph basic algorithm finds long cycle contracts cycle recurses contracted graph remains strongly connected graph finally collapses single vertex algorithm returns set edges contracted course algorithm desired scss algorithm achieves performance guarantee constant greater polynomial time give nearly lineartime version achieves performance guarantee 175 give examples showing lower bounds performance guarantees algorithm general algorithm lower bounds slightly 15 nearly lineartime version lower bound 175 matching upper bound performance guarantee analysis extends directly simple local improve ment algorithm called 2exchange 2exchange starts given digraph performs following local improvement step long applicable find two edges current graph replaced one edge original graph maintaining strong connectivity similar localimprovement algorithms natural candidates many optimization problems often elude analysis prove performance guarantee 2exchange 175 natural improvement cyclecontraction algorithm modify algorithm solve problem optimally contracted graph cycles longer given length c instance modification improves performance guarantee 2 6 gamma 136 1617 use scss c denote minimum scss problem restricted digraphs cycle longer c minimumscss 2 problem trivial minimum scss 3 problem solved polynomial time shown khuller raghavachari young 14 however improvement direction limited show minimum scss 5 problem nphard fact show minimum scss 17 problem max snphard precludes possibility polynomialtime approximation scheme assuming p6np 4 12 related work union incoming branching outgoing branching root yields scss 2n gamma 2 edges n number vertices graph special case algorithm given frederickson jaja 6 uses minimumweight branchings achieve performance guarantee 2 weighted graphs since scss least n edges yields performance guarantee 2 scss problem minimal scss one edge deleted 2n gamma 2 edges also yields performance guarantee 2 problem efficiently finding minimal scss studied simon 21 gibbons karp ramachandran soroker tarjan 10 give parallel algorithm related problem undirected graphs find smallest subset edges forming biconnected respectively bridgeconnected ie 2edgeconnected spanning subgraph given graph problems nphard khuller vishkin 15 give dfsbased algorithm achieves factor 5for biconnectivity 3for bridgeconnectivity garg santosh singla 9 subsequently improve approximation factors using similar approach 3and 5 respectively none methods appear extend minimum scss problem undirected graphs bounded cycle length bounded tree width arn borg lagergren seese 3 shown many nphard problems including minimum biconnectedspanningsubgraph problem polynomialtime algorithms restricted graphs 2 preliminaries contract pair vertices u v digraph replace occurrence u v edge single new vertex delete subsequent selfloops multiedges edge resulting graph identified corresponding edge original graph case multi edges single remaining edge identified one corresponding edges original graph contract edge u v contract pair vertices u v contract set pairs vertices graph g contract pairs arbitrary order contracted graph denoted gs contracting edge also analogously extended contracting set edges let opt g minimum size subset edges strongly connects g general term cycle refers simple cycles 3 lower bounds opt g begin showing graph long cycles size scss large lemma 31 cycle lemma directed graph g n vertices longest cycle g length c proof starting minimumsize subset strongly connects graph repeatedly contract cycles subset cycles left observe maximum cycle length increase contractions consequently cycle contracted ratio number edges contracted decrease number vertices least c since total decrease number vertices least c contracted note lemma gives lower bound existentially tight values c exist graphs bound given lemma equal opt g also note c trivial upper bound n using get lower bound n opt g known trivial lower bound lemma 32 contraction lemma directed graph g set edges proof scss g contracted around treating edges pairs scss gs 4 cyclecontraction algorithm algorithm following fix k positive integer contractcycles k g 2 graph contains cycle least edges 3 contract edges cycle 4 return contracted edges section 6 show algorithm implemented run omffm n time case polynomial time fixed value k clear edge set returned algorithm strongly connects graph following theorem establishes upper bound number edges returned algorithm theorem 41 contractcycles k g returns c k delta opt g edges proof initially let graph n vertices let n vertices remain contracted graph contracting cycles edges many edges returned contracting cycles least k edges contributed solution contracting cycles contributed number edges returned thus vertices remain cycle edges lemmas 31 32 opt g 1 thus number edges returned divided opt g n using identity 17 p75 6 get desired standard techniques yield accurate estimates c k eg graph initially cycle longer k pointed anonymous referee analysis generalized show performance guarantee k instance graph cycle longer 5 analysis bounds performance guarantee 1464 table 1 gives lower upper bounds performance guarantee algorithm small values k limit k 1 lower bounds shown next subsection upper bound lower bound table bounds performance guarantee 41 lower bounds performance ratio section present lower bounds performance ratio contractcycles k g graph fig 1 n 2kgamma2 groups vertices group consists 2k gamma 2cycle threaded kcycle first iteration contractcycles k g contract kcycle within group leaving graph 2cycles algorithm subsequently must contract remaining edges thus 3k gamma returned scss graph contains hamilton cycle optimal solution thus n hence arbitrarily large lower bound performance guarantee contractcycles k g k approaches 1 lower bound tends 15 fig 1 bad example contractcycles k g 5 2exchange algorithm section use cyclecontraction analysis show 2exchange performance guarantee 175 2exchange special case kexchange defined follows 2 following improvement step possible 3 pick set e k k edges e 0 set e kgamma1 set edges forms scss note fixed k step performed polynomialtime reduces size e 0 kexchange runs polynomial time following theorem shows approximation factor achieved 2exchange 175 theorem 51 performance guarantee 2exchange 175 proof show edges output 2exchangeg could output contractcycles 3 g thus performance guarantee 175 contractcycles 3 carries 2exchange first show performance guarantee 175 let e 0 set edges returned contractcycles 3 graph h set edges contracted first iteration cycles least three edges contracted resulting graph g 0 h strongly connected 2cycles graph treelike structure particular edge u v present iff reverse edge v u present important observation gh equivalent g 0 h clearly g 0 h subgraph gh prove converse suppose edge u v gh g 0 h consider adding edge u v g 0 h structure g 0 h u v adjacent g 0 h edge path v u reverse edge also g 0 h u v added g 0 h least two reverse edges deleted g 0 h without destroying strong connectivity g 0 h consequently original edge g corresponding u v added g 0 original edges g 0 corresponding reverse edges deleted g 0 without destroying strong connectivity g 0 contradicts fact e 0 output 2exchangeg since e 0 eligible improvement step next consider executing contractcycles 3 g since gh equivalent g 0 h sequence cycles chosen first iteration contractcycles 3 could also chosen first iteration contractcycles 3 g similarly second iteration contractcycles 3 could mimicked contractcycles 3 g case contractcycles 3 g would return edge set contractcycles 3 g 0 since e 0 minimal otherwise improvement step applies edge set returned exactly e 0 thus upper bound performance guarantee contractcycles 3 theorem 41 inherited 2exchange lower bound performance guarantee given graph fig 2 2 exchange choose number edges arbitrarily close 175 times minimum n 4 groups 4 vertices group first observe graph directed hamilton cycle edges marked fig 2 form solution 2exchange could terminate solution clearly 7n 4 edges gives lower bound 175 performance algorithm 6 implementation fixed k contractcycles k implemented polynomial time using exhaustive search find long cycles instance cycle size least k exists one found polynomial time follows simple path p check whether path head p tail exists p internal vertices removed graph k even k2 paths k odd number nm kgamma12 takes edges returned 2exchange edges used 2exchange fig 2 worstcase example 2exchange om time decide path head p tail p first iteration loop may iterations loop since first iteration time consuming algorithm implemented 61 practical implementation yielding 175 next give practical near lineartime implementation contractcycles 3 performance guarantee achieved c consists two phases 1 repeatedly finding contracting cycles three edges called long cycles cycles exist 2 contracting remaining 2cycles highlevel description algorithm perform phase 1 algorithm depthfirst search dfs graph arbitrary root search algorithm identifies edges contraction adding set point search g 0 denotes subgraph edges vertices traversed far rule adding edges follows new edge traversed new edge creates long cycle g 0 algorithm adds edges cycle algorithm thus maintains g 0 long cycles dfs finishes g 0 2cycles edges 2cycles together desired scss g 0 long cycles fact original graph strongly connected g 0 maintains simple structure lemma 61 addition edge g 0 possible contraction cycle adding graph g 0 consists outward branching reverse edges ii reverse edges might present active path supervertex containing root supervertex containing current vertex dfs proof clearly invariant initially true show given step algorithm maintains invariant case u w denote vertices graph let u w denote vertices g 0 containing u w respectively dfs traverses edge u w visit new vertex w vertex w edge u w added g 0 vertex w becomes current vertex g 0 outward branching extended new vertex w addition edge u w edge added cycle created thus part invariant maintained supervertex containing current vertex w new active path contains old active path thus part ii invariant also maintained active active root inactive active u inactive inactive inactive fig 3 contracted graph g 0 dfs traverses edge u w w already visited u w edge u w already exists g 0 cycle created g 0 unchanged invariant clearly maintained otherwise edge u w added g 0 cycle simple structure illustrated fig 3 created g 0 cycle consists edge u w followed possibly empty path reverse edges w lowestcommonancestor lca u w followed possibly empty path branching edges lcau w u addition u w g 0 contraction cycle case long cycle maintains part invariant active path changed part contracted part ii invariant maintained dfs finishes visiting vertex w edge added cycle contracted part clearly maintained let u new current vertex ie ws parent dfs tree u w part ii clearly maintained otherwise consider set descendants w dfs tree since original graph strongly connected edge x original graph goes set complement vertices visited x g 0 part invariant vertex g 0 containing x must w vertex containing must u otherwise edge corresponding x g 0 would create long cycle algorithm maintains contracted graph g 0 using unionfind data structure 22 represent vertices standard way using three data structures maintain branching reverse edges discovered far active path cycle arises g 0 must form described proof lemma 61 illustrated fig 3 using data structures algorithm discovers long contracts number unionfind operations proportional length cycle yields omffm ntime algorithm vertices g 0 represented unionfind sets follows adds set fvg corresponding new vertex g 0 findv returns set g 0 contains vertex v joins single set two sets corresponding vertices vertices u v data structures representing branching reverse edges active paths respectively branching edge u w g 0 u w 2 u theta w torootu reverse edge u w g 0 torootu toactiveu vertex u active path g 0 toactiveu child u recursive dfs call currently executing unless recursive dfs executing case toactiveu current vertices toactiveu pseudocode algorithm given figures 4 5 contractcycles choose r 2 v 4 add 2cycles remaining g 0 5 return current 2 vertex w adjacent u traverse edge u w 3 w yet visited new vertex current 8 else edge creates cycle g 0 9 cycle length least 2 length two cycle parent u record edge parent else forward edge child therefore length cycle 3 fig 4 practical implementation contractcycles 3 preceding discussion algorithm implements contractcycles 3 straightforward show runs omffm n time hence following theorem theorem 62 omffm ntime approximation algorithm minimum scss problem achieving performance guarantee 175 medge nvertex graph ffm n inverseackermann function associated unionfind data structure 22 example illustrate algorithm example fig 6 algorithm begins dfs vertex 1 visits vertices 234 traverses reverse edge 4 2 since edge creates 3cycle 2 3 3 4 4 2 g 0 contracts cycle next 1 toactivefindw 6 current towards l c along reverse edges 4 toactivefindp go l c along active path 6 p c toactivefindw 7 toactivefindc contract parent p child c fig 5 subroutine contractcycle traverses reverse edge 3 1 contract since forms 2 cycle contracted graph continuing dfs visits vertices 5 6 traverses edge 6 4 discovers contracts cycle 3 1 1 5 5 6 6 4 next visits vertices 7 8 traversing reverse edges 8 7 7 6 traversing edge 6 8 discovers contracts 3cycle 8 7 7 6 6 8 example 2cycles remain returns contracted edges 7 potential improvement contractcycles k natural modification contractcycles k would stop contracted graph cycles length c somehow solve remaining problem optimally instance following proof theorem 41 one show would improve performance guarantee contractcycles k c k gamma 136 k 4 matching lower bound table 1 lower bound given holds modified algorithm leads us consider minimum scss c problem minimum scss problem restricted graphs cycle length bounded c following theorem shown 14 theorem 71 polynomialtime algorithm scss 3 problem make conjecture concerning sccs 4 problem however next show sccs 5 problem nphard scss 17 problem max snphard 71 nphardness scss 5 prove following theorem theorem 72 minimum scss 5 problem nphard proof proof reduction sat 8 fix arbitrary cnf formula f build rooted digraph scss contains edges root f satisfiable iff exists scss e 0 remaining nonroot vertices outdegree equal one thus formula satisfiable scss edges graph fixed root vertex r vertex clause f vertices shown fig 7 clause vertex return edge root variable f graph instance gadget illustrated fig 7 edges gadget come root edge present scss edges gadget alternately labeled gamma every clause graph g traversing edge 76 traversing edge 68 edges c traversing edge 31 traversing edge 647524752475243168 86148613fig 6 example illustrate execution algorithm positive instance variable one edges goes clause vertex every clause negative instance variable one gamma edges goes clause vertex unassigned edges go root gadget easily enlarged allow number occurrences key property gadget every nonroot vertex outdegree one scss either counterclockwise edges scss corresponding variable true clockwise edges scss corresponding variable false thus given scss edges outdegree root n number vertices digraph constructed easy construct satisfying assignment f conversely given satisfying assignment f easy construct scss size dn gamma 1 72 max snphardness scss 17 next consider max snphardness problem proof uses reduction vertexcover problem boundeddegree graphs scss problem since proof follows closely reduction vertex cover hamiltonian circuits see 8 suggested reader study reduction reading subsection known problem finding minimum vertex cover max snphard graphs whose maximum degree bounded seven 19 let g connected undirected graph whose maximum degree bounded seven let g edges n vertices construct digraph 2m variable gadget incoming edges root outgoing edges clause vertices root root edges scss variabletrue fig 7 variable gadget nphardness proof vertices cycle longer 17 vertex cover g size yield scss size 2ms vice versa show since g edges yields lreduction ie approximationpreserving reduction 19 721 construction applying vizings theorem 23 color edges g polynomial time eight colors two edges incident vertex share color let colors edges one f1 2 8g construction begins special root vertex r outgoing arcs n vertices corresponding vertices g arc r vertices form beginning path corresponding vertex g x fig 8 covertesting component construction proceeds vertex g current vertex initially start vertex edge u v order nondecreasing color add covertesting gadget illustrated fig 8 specifically add two new vertices x add two edges x first labeled u current vertex u second labeled similarly add two edges first labeled current vertex v second labeled v gamma x make new current vertex u make x new current vertex v finally edges g considered vertex v g add edge labeled v final current vertex root gadgets implicitly layered gadget assigned layer corresponding color associated edge g lemma 73 graph constructed cycle 17 edges proof first assign numbers vertices root r assigned number 0 construction proceeds order increasing color edges g considering edge u v color c add two new vertices x added vs path added us path assign vertices x number c consider cycle x length greater two clear cycle must pass r since layered hence cycle form r considered edges order increasing color numbers assigned vertices x increases least every two steps path including r words numbers assigned vertices x forms nondecreasing sequence three consecutive vertices get number since edges g colored 8 colors numbers assigned vertices range 0 8 r gets number 0 combining length cycle x 17 722 analysis show every vertex cover g corresponding scss proof similar corresponding proof reduction vertex cover hamiltonian circuits every vertex cover corresponding hamiltonian circuit consider arbitrary vertex cover g idea choose scss paths corresponding paths vertices yet connected since forms vertex cover vertices paths connected using covertesting components lemma 74 given vertex cover size g scss size 2m constructed proof construct subgraph h follows vertex u g let degree u g u vertex cover add h otherwise add edges labeled u gamma h easy verify h following properties 1 h 2m edges 2 h cycles length 2 3 every vertex h least one outgoing least one incoming edge mentioned earlier layered every cycle length greater 2 contains r therefore property 2 implies every cycle h passes r conditions h contains path r every vertex v another path v r therefore strongly connected obtain path v r start v keep traversing outgoing edge exists property 3 current vertex path must eventually reach r r contained every cycle h hence h satisfies lemma show every scss corresponds vertex cover g proof works showing scss converted canonical scss whose size larger corresponds vertex cover g lemma 75 given scss size 2m vertex cover g size constructed proof first long nonroot vertex incoming edges scss modify scss follows let x edge labeled v gamma v remove edge x add edge x already present alternatively nonroot vertex x outgoing edges scss remove edge x add edge repeat either modification long applicable layering modification maintains strong connectivity scss clearly none modifications increases size step reduces number edges labeled u gamma u scss 2m steps neither modification applies resulting scss every nonroot vertex exactly one incoming edge one outgoing edge scss easy induction layering shows vertex v g either edges labeled v scss none case edges labeled scss let c set vertices g former kind easy show size scss 2m jcj every edge u v g form gadget ensures least one two endpoints c hence c desired cover theorem 76 minimum scss 17 problem max snphard proof let g arbitrary undirected graph g whose maximum degree bounded seven let g edges n vertices construct digraph shown earlier lemma 73 cycles greater 17 lemma 74 vertex cover g size used obtain scss size 2m conversely lemma 75 scss size 2m used obtain vertex cover g size since degree g bounded easily verified yields lreduction degreebounded vertex cover minimum scss 17 problem 8 open problems obvious problem characterize various complexities minimum scss k problems interesting open problem obtain performance guarantee less 2 weighted strong connectivity problem mentioned earlier performance factor 2 due frederickson jaja 6 algorithm may implications weighted 2connectivity problem 15 undirected graphs well performance guarantee kexchange probably improves k increases proving would interesting similar local improvement algorithms applicable wide variety problems r approximation algorithm generalized steiner problem networks transitive reduction directed graph easy problems treedecomposable graphs proof verification hardness approximation problems introduction algorithms efficient algorithms finding minimum spanning trees undirected directed graphs computers intractability guide theory npcompleteness improved approximation algorithms biconnected subgraphs via better lower bounding techniques transitive compaction parallel via branchings general approximation technique constrained forest problems introduction theory directed graphs algorithm finding minimal equivalent graph digraph strongly connected digraphs bounded cycle length biconnectivity approximations graph carvings general approximation technique constrained twoconnectivity problems fundamental algorithms algorithm finding minimum equivalent graph digraph complexity classes siam journal computing finding minimal transitive reduction strongly connected digraph within linear time data structures network algorithms estimate chromatic class pgraph russian primaldual approximation algorithm generalized steiner network problems tr ctr adrian vetta approximating minimum strongly connected subgraph via matching lower bound proceedings twelfth annual acmsiam symposium discrete algorithms p417426 january 0709 2001 washington dc united states liang zhao hiroshi nagamochi toshihide ibaraki linear time 53approximation minimum stronglyconnected spanning subgraph problem information processing letters v86 n2 p6370 cristina g fernandes better approximation ratio minimum stphane bessy stphan thomass every strong digraph spanning strong subgraph n22 arcs journal combinatorial theory series b v87 n2 p289299 march harold n gabow special edges approximating smallest directed kedge connected spanning subgraph proceedings fifteenth annual acmsiam symposium discrete algorithms january 1114 2004 new orleans louisiana
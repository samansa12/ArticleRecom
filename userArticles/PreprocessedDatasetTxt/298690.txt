optimal parallel algorithms finding proximate points applications abstractconsider set p points plane sorted xcoordinate point p p said proximate point exists point q xaxis p closest point q points p proximate point problem determine proximate points p main contribution propose optimal parallel algorithms solving instances size n proximate points problem begin developing worktime optimal algorithm running olog log n time using n log log n commoncrcw processors go show algorithm implemented run olog n time using n log n erew processors addition worktime optimal erew algorithm turns also timeoptimal second main contribution show proximate points problem finds interesting quite unexpected applications digital geometry image processing first application present worktime optimal parallel algorithm finding convex hull set n points plane sorted xcoordinate algorithm runs olog log n time using n log log n commoncrcw processors show algorithm implemented run olog n time using n log n erew processors next show proximate points algorithms afford us worktime optimal resp timeoptimal parallel algorithms various fundamental digital geometry image processing problems specifically show voronoi map euclidean distance map maximal empty circles largest empty circles related problems involving binary image size nn solved olog log n time usingn2 log log ncommoncrcw processors olog n time using n2 log n erew processors b introduction consider parallel algorithm solves instance size n problem p n time using p processors traditionally main complexity measure assessing performance work supported part nsf grant ccr9522093 onr grant n000149710526 grantinaid encouragement young scientists 08780265 ministry education science sports culture japan dept electrical computer engineering nagoya institute technology showaku nagoya 466 japan z department computer science old dominion university norfolk virginia 23529 usa olariucsoduedu algorithm amount w n work performed algorithm defined product n algorithm termed workoptimal w n 2 thetat n n running time fastest sequential algorithm problem algorithm worktime optimal 20 workoptimal addition running time p n best possible among workoptimal algorithms model needless say one challenges parallel algorithm design produce workoptimal indeed whenever possible worktime optimal algorithms occasionally even stronger complexity metric used socalled timeoptimality specifically algorithm timeoptimal given model problem cannot solved faster model even unbounded number processors available paper assume parallel random access machine pram short consists synchronous processors access common memory refer interested reader 20 excellent discussion pram model let p set points plane sorted xcoordinate point p proximate point p exists point xaxis closer p point p proximate points problem asks determine proximate points p clearly proximate points problem solved using algorithm finding voronoi diagram however argued 16 computation voronoi diagram log n time even n points sorted xcoordinate thus naive approach yield optimal solution proximate points problem recently breu et al 6 proposed lineartime algorithm proximate points problem spite optimality algorithm breu et al 6 relies crucial ways stack operations notoriously hard parallelize first main contribution propose parallel algorithms solving instances size n proximate points problem specifically first exhibit algorithm running olog log n time using n log log n commoncrcw processors go show algorithm implemented run olog n time using n log n erew processors commoncrcw algorithm worktime optimal erew algorithm turns also timeoptimal establish worktime optimality commoncrcw algorithm reduction minimum finding problem timeoptimality erew algorithm follows reduction problem second main contribution show proximate points problem interesting quite unexpected applications digital geometry image processing begin present worktime optimal parallel algorithm computing convex hull set n points plane sorted xcoordinate algorithm runs olog log n time using n log log n common crcw processors olog n time using n log n erew processors show algorithm worktime optimal crcw model addition timeoptimal erew numerous parallel algorithms proposed computing convex hull sorted points plane 4 7 12 13 21 recently chen 7 presented olog ntime algorithm using n log n processors chen et al 12 presented workoptimal algorithms running olog ntime algorithm using n log n erew processors olog log ntime algorithm using n log log n commoncrcw processors quite recently berkman et al 3 presented olog log ntime algorithm using n log log n commoncrcw processors algorithm features performance 3 7 12 however algorithm much simpler intuitive best knowledge worktime optimality crcw version timeoptimality erew version algorithm solved yet given binary image voronoi map assigns pixel image position nearest black pixel euclidean distance map assigns pixel euclidean distance nearest black pixel empty circle image circle whose interior contains white pixels maximal empty circle empty circle contained empty circle largest empty circle empty circle largest radius refer reader figure 1 illustration largest square diamond ngon etc defined similarly computations known numerous applications ranging clustering shape analysis 2 17 handoff management cellular systems 26 image compression decomposition reconstruction 5 23 27 28 31 applications propose algorithms computing voronoi map euclidean distance map maximal empty circles largest empty circles binary image size n theta n begin presenting worktime optimal algorithm computes voronoi map euclidean distance map binary image size n theta n olog log n time using n 2 log log n commoncrcw processors olog n time using n 2 log n erew processors also show distance map various metrics including well known l k metrics k 1 also computed manner go show maximal empty circles largest empty circle n theta n binary image found olog log n time using n 2 log log n commoncrcw processors olog n time using n 2 log n erew processors turns minimal changes algorithm applicable various kinds empty figures including squares diamonds ngon etc recently chen et al 8 11 breu et al 6 presented 2 time sequential algorithms computing euclidean distance map roughly time hirata 19 presented simpler sequential algorithm compute distance map various distance metrics including euclidean 4neighbor 8neighbor chamfer octagonal number parallel algorithms computing euclidean distance map developed various parallel models 191014 particular following results reported recent literature lee et al 22 figure 1 illustrating euclidean distance map largest empty circle presented olog 2 ntime algorithm using n 2 erew processors pavel akl 24 presented algorithm running olog n time using n 2 erew processors clearly two algorithms workoptimal chen 8 presented workoptimal n 2 time algorithm using p p log p n erew processors yields log ntime algorithm using n log n erew processors fujiwara et al 18 presented workoptimal algorithm running olog n time using n 2 log n erew processors log n log log n time using n 2 log log n log n commoncrcw processors although fujiwara et al 18 claim algorithm applicable various distance maps closer analysis reveals applies distance metrics main problem seems algorithm uses geometric transform depends crucial way properties euclidean distance therefore seem generalize see euclidean distance map algorithm three major advantages fujiwaras algorithm first performance algorithm crcw superior second algorithm applies large array distance finally algorithm much simpler intuitive remainder paper organized follows section 2 introduces proximate points problem euclidean distance metric discusses number technicalities crucial ingredients subsequent algorithms section 3 presents parallel algorithms commoncrcw erew section 4 proves algorithms worktime respectively timeoptimal section 5 presents worktime optimal parallel algorithm computing convex hull sorted points plane section 6 uses proximate points algorithm computing voronoi map euclidean distance map maximal empty circles largest empty circles binary image section 7 offers concluding remarks open problems finally appendix discusses distance metrics algorithms presented section 3 apply 2 proximate points problem first look section introduce proximate points problem along number geometric results lay foundation subsequent algorithms throughout assume point p represented cartesian coordinates xp yp usual denote euclidean distance planar points p q dp consider collection n points sorted xcoordinate assume without loss generality points p distinct xcoordinates lie xaxis reader difficulty confirming assumptions made convenience impact complexity algorithms recall every point p p locus points plane closer point p referred voronoi polygon associated p denoted v collection voronoi polygons points p partitions plane voronoi diagram p see 25 p 204 let 1 n locus points q xaxis dq words q 2 q belongs intersection xaxis v illustrated figure 2 turn implies must interval xaxis intervals may empty point p p termed proximate point whenever interval nonempty thus voronoi diagram p partitions xaxis proximate intervals since points sorted xcoordinate corresponding proximate intervals ordered left right point q xaxis said boundary point p p j q equidistant p p j dp clear p boundary point proximate points p p j q intersection closed intervals j summarize previous discussion state following result proposition 21 following statements satisfied ffl interval xaxis ffl intervals 1 lie xaxis order nonempty j lies left 1 2 4 6 7 figure 2 illustrating proximate intervals 1 2 3 4 0 figure 3 illustrating addition p g ffl nonempty proximate intervals j adjacent boundary point referring figure 2 among seven points five points proximate points others note leftmost point p 1 rightmost point p n always proximate points given three points say dominated p p k whenever fails proximate point set consisting three points clearly p j dominated p p k boundary p p j right p j p k since boundary two points computed o1 time task deciding every triple p whether p j dominated p p k takes o1 time using single processor consider collection points plane sorted xcoordinate point p right p xp 1 xp interested updating proximate intervals p reflect addition p p illustrated figure 3 assume without loss generality points p proximate points let n corresponding proximate intervals let 0 p updated proximate intervals p fpg let p point 0 0 adjacent iii proposition 21 boundary point p p separates 0 0 consequence ii implies proximate intervals 0 n must empty furthermore addition p p affect proximate intervals j 1 words 1 0 empty points p dominated p p thus every point n dominated otherwise boundary would left p j p would imply nonempty interval two boundaries corresponds 0 j contradiction summarize following result lemma 22 exists unique point p p ffl proximate points p fpg ffl point p j dominated 0 ffl dominated interval 0 j empty 0 consecutive xaxis separated boundary point p collection proximate points sorted xcoordinate let p point left p xp xp 1 reference take note following companion result lemma 22 proof identical thus omitted lemma 23 exists unique point p p ffl proximate points p fpg ffl dominated p p j1 moreover 0 ffl point p j dominated p p j1 interval 0 j empty p 0 consecutive xaxis separated boundary point p unique point p whose existence guaranteed lemma 22 termed contact point p p second statement lemma 22 suggests task determining unique contact point p point p right left p reduces essentially binary search suppose set two subsets g interested updating proximate intervals process merging pl pr purpose let 2n proximate intervals pl pr respectively sume without loss generality proximate intervals nonempty let 0 proximate intervals position state prove next result turns key ingredient algorithms lemma 24 exists unique pair proximate points pr ffl proximate points pl pr empty 0 ffl proximity intervals 0 0 consecutive separated boundary point proof let smallest subscript p 2 pl contact point pl point pr similarly let j largest subscript point pr contact point pr point pl clearly point pl left p proximate point p likewise point pr left p j proximate point p finally lemma 22 every point pl left p must proximate point p similarly lemma 23 every point pr right p must proximate point p proof lemma complete points p p j whose existence guaranteed theorem 24 termed contact points pl pr refer reader figure 4 illustration contact points pl pr p 4 p 8 next discuss geometric property enables computation contact points p p j pl pr point p k pl let q k denote contact point p k pr specified lemma 23 following result lemma 25 point p k dominated p kgamma1 q k 2 k dominated otherwise 1 2 3 4 5 6 7 8 9 10 0 9 0 figure 4 illustrating contact points two sets points proof dominated p kgamma1 q k 0 k must empty thus lemma 24 guarantees p k 2 k dominated p kgamma1 q k suppose p k dominated p kgamma1 q k boundary point p k q k right p kgamma1 p k thus nonempty interval two boundaries corresponds 0 k contradiction therefore p k n dominated p kgamma1 q k completing proof lemma 25 suggests simple binary searchlike approach finding contact points p two sets pl pr fact using similar idea breu et al 6 proposed sequential algorithm computes proximate points npoint planar set time algorithm 6 uses stack store proximate points found consequently seems hard parallelize 3 parallel algorithms proximate points problem begin discussing parallel algorithm solving proximate points problem commoncrcw algorithm converted run erew rely part solution wellknown leftmostone problem given sequence b 1 determine smallest 1 n b lemma 31 20 instance size n leftmostone problem solved o1 time using n commoncrcw processors consider set points xp 1 capture neighboring proximate points point use three indices c l r defined follows nonproximate points proximate points figure 5 illustrating indices l c r point p 1 proximate pointg 2 l proximate pointg 3 r proximate pointg refer reader figure 5 illustration note must l proximate point p j l c next interested finding contact point set new point p xp n assume every 1 n c l r available n processors disposal algorithm essentially performing mary search using lemma 22 algorithm findcontactpointp p extract sample sp size consisting points p c p every k k 0 check whether point p c k n dominated p l k n p whether dominated p c k n p p c k n dominated p r k n dominated desired contact point point p r k n dominated p c k n p p c k1 n dominated p l k1 n p step 3 execute recursively algorithm set points p g find contact point 1 set p 0 contains l k1 n points hence depth recursion log n log notice algorithm findcontactpoint perform concurrent reading writing thus following result lemma 32 given set n points plane sorted xcoordinate point p xp n task finding contact point p p performed log n log using erew processors next consider two sets points plane xp 1 assume every indices c l r given processors available us following algorithm finds contact points pl pr mary search using lemma 25 algorithm findcontactpointsbetweensetspl pr sample points spl pl using algorithm findcontactpoint p processors available determine sample point 1 corresponding contact point q c k n pr step 2 k 0 k check whether point p c k n dominated p l k n q c k n whether point p r k n dominated p c k n q c k n p c k n dominated yet p r k n output q c k n desired contact points step 3 find k point p r k n dominated p c k n q c k n dominated p l k1 n q c k1 n step 4 execute recursively algorithm findcontactpointsbetweensets sets p 0 pr return desired contact points hard see algorithm findcontactpointsbetweensets involves concurrent reads several processors may access point concurrently involve concurrent operations lemma 32 step 1 takes log n log time crew model steps 2 3 run clearly o1 time since p 0 l contains n depth recursion log n log thus altogether algorithm findcontactpointsbetweensets runs log 2 n using crew processors lemma 33 given sets points plane xp 1 task finding contact points pl pr performed log 2 n using crew processors next interested designing algorithm compute proximate points set p n points plane sorted xcoordinate olog log n time commoncrcw assume n processors available us begin determining every indices c l r information available remains done retain points p c details follow algorithm findproximatepointsp partition set p n 13 subsets every k 0 k g every point p p k 0 k n 13 gamma 1 determine indices c l r local p k compute contact points pair sets p using n 13 processors available let q ij 2 p denote contact point p p j step 3 every p find rightmost contact point p rc among points q ij find leftmost contact point p lc points q ij j clearly xp rc ig step 4 set p proximate points lying rc lc inclusive proximate points p update c clear step 2 performed log n 23 log runs o1 time using lemma 31 moment reader may wonder updating indices performed efficiently fact turns update done o1 time since task updating l r essentially updating c focus c p points p j rc value c j changed points p j lc j value c j must changed lc points p j value c j changed lc proximate point however p contains proximate points find nearest subset contains proximate point first check whether p proximate point using n 23 processors thus totally processors used task next using lemma 31 determine k contains proximate pointg p since p n 13 groups task done o1 time n 13 processors totally n 13 delta n processors used thus step 4 done o1 time using n processors let tcrcw n running time algorithm find recurrence describing worst case running time algorithm findproximatepoints note step 1 executes recursively algorithm n 23 points steps 2 3 4 run o1 time thus confirming tcrcw n 2 olog log n thus lemma 34 instance size n proximate points problem solved olog log n time using n commoncrcw processors next show number processors reduced factor log log n without increasing running time idea follows begin partitioning set p n log log n subsets log log n size log log n next using algorithm sequentialproximatepoints find proximate points within subset olog log n sequential time process remove p points proximate points every 1 n log log n let proximate points set p moment execute algorithm findproximatepoint p 1 log log n since n processors required order update indices c l r o1 proceed slightly differently idea following executing algorithm currently proximate points cease proximate points maintain information efficiently use ranges log log n log log n p fp il current proximate points executing algorithm p may contain proximate points find neighboring proximate points use pointers l 0 log log n log log n set p j contains proximate pointg set p j contains proximate pointg using strategy find contact point point p log n log using processors discussed lemma 32 thus contact points two subsets found manner lemma 33 finally algorithm lemma 31 update step 4 o1 time using n log log n processors summarize following result theorem 35 instance size n proximate points problem solved olog log n time using n log log n commoncrcw processors close section pointing algorithm findproximatepoints implemented efficiently erew purpose rely part following well known result 20 lemma 36 single step execution mprocessor crcw simulated mprocessor erew olog time lemma 36 steps 2 3 4 algorithm performed olog n time using processors crcw performs steps o1 time using n processors let terew n worstcase running time erew recurrence describing confirming n 2 olog n consequently lemma 37 instance size n proximate points problem solved olog n time using n erew processors using essentially idea commoncrcw reduce number processors factor log n without increasing computing time specifically case erew n points partitioned n log n subsets size log n thus theorem 38 instance size n proximate points problem solved olog n time using n log n erew processors 4 lower bounds main goal section show running time commoncrcw algorithm proximate points problem developed section 3 cannot improved retaining work optimality effect prove commoncrcw algorithm worktime optimal show erew algorithm timeoptimal workoptimality algorithms obvious order solve proximate points problem every point must accessed least n work required algorithm solving problem lower bound arguments rely part following fundamental result valiant 30 lemma 41 task finding minimum maximum n real numbers log n time crcw provided n log o1 n processors available show lower bound lemma 41 holds even item nonnegative lemma 42 task finding minimum maximum n nonnegative nonpositive real numbers requires log n time crcw provided n log o1 n processors available proof assume minimum maximum n nonnegative numbers computed olog log n time using n log o1 n crcw processors assumption find minimum n real numbers olog log n time follows first o1 time check whether negative numbers input minimum input items computed olog log n time negative numbers exist replace every nonpositive number 0 find maximum absolute values resulting sequence olog log n time maximum thus computed corresponds minimum original input thus minimum n real numbers computed olog log n time contradicting lemma 41 rely following classic result cook et al 15 lemma 43 task finding minimum maximum n real numbers crew therefore also erew even infinitely many processors available shall reduce task finding minimum collection n nonnegative 1 proximate points problem plan show instance size n problem finding minimum collection nonnegative numbers converted o1 time instance size 2n proximate points problem involving sorted points plane purpose let set arbitrary nonnegative real numbers input minimum problem construct set points plane setting every 1 notice construction guarantees points p sorted xcoordinate every 1 n distance point p origin exactly intuitively construction places 2n points circles centered origin precisely every 1 n points p p ni placed circle c radius important note construction carried o1 time using n erew processors subsequent arguments find convenient rely next technical result lemma 44 p p proximate points minimum proof let minimum refer figure 6 clearly c circle smallest radius containing p p points lie outside c hence p p closest points p origin thus boundary lies left origin true p j would closer origin p following simple facts proved essentially way figure illustrating p lemma 44 1 boundary point p j p lies left origin 1 right 2 boundary point p j p lies left origin 1 right point n boundary p j p lies left p j p ni p j proximate point thus j 6 either p j p jn fails proximate point point p boundary lies left origin n lies right origin origin thus p proximate point fact p proximate point follows mirror argument completes proof lemma 44 guarantees minimum determined o1 time proximate points p known lemma 41 implies following important result theorem 45 algorithm solves instance size n proximate points problem crcw must take omegagammake log n time worst case provided n log o1 n processors available using exactly construction combination lemma 43 obtain following lower bound crew theorem 46 algorithm solves instance size n proximate points problem crew also erew must take omegagammake n time even infinite number processors available notice erew algorithm proximate points problem presented section 3 running olog n time using n log n processors features work time performance crewpram theorem 46 corresponding crew algorithm also timeoptimal straightforward extend previous arguments handle case l k metric specifically case every 1 n points allow us find minimum thus theorems 45 46 provide lower bounds solving proximate points problem distance metric l k 5 computing convex hull main goal section show proximate points algorithms developed section 3 yield worktime optimal resp timeoptimal algorithm computing convex hull set points plane sorted xcoordinate begin discussing details algorithm second subsection establish worktime resp time optimality 51 convex hull algorithm set n points plane xp 1 line segment partitions convex hull p lower hull lying segment upper hull lying focus computation lower hull computation upper hull similar sequence 1 items prefix maxima sequence 1 maxfa 1 g later reference state following result 20 29 lemma 51 task computing prefix maxima prefix minima nitem sequence performed olog n time using n log n erew processors olog log n time using n log log n commoncrcw processors set n points plane sorted xcoordinate xp 1 define set let n points setting every 1 n q important note points q figure 7 illustrating proof lemma 52 also sorted xcoordinate following surprising result captures relationship sets p q defined lemma 52 every j 1 j n p j extreme point lower hull p q j proximate point q proof extreme point p q j proximate point q thus lemma correct consider arbitrary j range arbitrary subscripts 1 boundaries q q j q j q k respectively refer figure 7 clearly thus similarly obtain easy see point q j dominated q q k xb notice slopes line segments 2xb 2xb k respectively thus point p j lies segment p p k 2xb consequently point lies segment p p k point q j dominated q q k words point p j extreme point lower hull p q j proximate point q lemma 52 suggests following algorithm determining extreme points lower hull g algorithm findlowerhullp construct set setting every 1 n determine proximate points q report p extreme point lower hull p whenever q proximate point q preprocessing step 0 amounts translating set p vertically way every affine transformation affect convex hull p correctness simple algorithm follows directly lemma 52 argue running time note lemma 51 step 0 takes olog log n time optimal work commoncrcw olog n time optimal work erew step 1 runs o1 time using optimal work either commoncrcw erew theorems 35 38 step 2 takes olog log n time optimal work commoncrcw olog n time optimal work erew thus proved following result theorem 53 task computing convex hull set n points sorted xcoordinate performed olog log n time using n log log n commoncrcw processors olog n time using n log n erew processors 52 optimality convex hull algorithm main goal subsection show convex hull algorithm described previous subsection worktime optimal commoncrcw addition timeoptimal crew erew clearly every point must read least solve proximate points problem thus ontime required solve problem convex hull algorithms commoncrcw workoptimal next show given set n nonnegative integers maximum determined using algorithm computing convex hull set sorted points plane purpose exhibit o1time reduction maximum problem convex hull problem proof technique similar one employed proximate points problem given construct set points plane setting every set point plane sorted xcoordinate following result relates sets p lemma 54 item maximum p p points upper hull p proof let maximum construction p p points upper hull p none points p belong upper hull p thus exist subscript j j 6 p j p ni belong upper hull p completes proof consequently find maximum need find index p p ni points upper hull therefore problem finding upper hull 2n sorted points plane least hard problem finding maximum n nonnegative numbers thus following important result theorem 55 task finding convex hull n points log n time crcw provided n log o1 n processors available similarly following companion result theorem 56 task finding convex hull n points n time crew even infinitely many processors available theorems 55 56 convex hull algorithms developed previous section worktime optimal addition erew algorithm worktime timeoptimal 6 applications image processing binary image size n theta n maintained array b ij 1 n customary refer pixel j black b rows image numbered bottom starting 1 likewise columns numbered left right column 1 leftmost notation pixel b 11 southwest corner image voronoi map associates every pixel closest black pixel euclidean metric formally voronoi map function every j euclidean distance pixels euclidean distance map image associates every pixel euclidean distance closest black pixel formally euclidean distance map function r every j 1 subsequent arguments find convenient rely solution nearestone problem given sequence 0s 1s determine closest 1 every item direct corollary lemma 51 lemma 61 instance size n nearestone problem solved olog log n time using n log log n commoncrcw processors olog n time using n log n erew processors assume binary image size n theta n discussed availability n 2 processors log n commoncrcw n erew outline basic idea algorithm computing voronoi map euclidean distance map image begin determining every pixel row j 1 j n nearest black pixel column subimage precisely every pixel j associate value next construct instance proximate points problem every row j 1 j n image involving set p j points plane defined p solved parallel instances proximate points problem determine every proximate point p ij p j corresponding proximity interval j fixed determine every pixel perceive point xaxis identity proximity interval belongs allows pixel j determine identity nearest pixel task executed rows parallel determine every pixel row j nearest black pixel details spelled following algorithm algorithm voronoiandeuclideandistancemapi step 1 pixel j compute distances ng nearest black pixel column j subimage step 2 every j 1 ng compute proximate points ep j p j step 3 every point p ep j determine proximity interval p j step 4 every 1 n determine proximate intervals p j point corresponding pixel j belongs correctness algorithm easy see turn complexity step 1 performed ot n time using processors available using lemma 61 theorem 35 38 guarantee step 2 takes ot using n processors lemma 61 steps 3 4 performed complexity thus following important result theorem 62 task computing voronoi map euclidean distance map binary image size n theta n performed olog log n time using n 2 log log n commoncrcw processors olog n time using n 2 log n erew processors recall empty circle image circle filled white pixels task computing largest empty circles image recurring theme pattern recognition robotics digital geometry 17 empty circle said maximal contained empty circle empty circle said maximum radius large possible clear maximum empty circle also maximal conversely turn task determining maximal resp maximum empty circles input image algorithm allmaximalemptycirclesi compute euclidean distance map step 2 pixel j 1 compute smallest distance u jg border image compute r largest radius every empty circle centered pixel j step 3 pixel check whether exists neighboring pixel 1 circle radius r ij origin j included circle radius r 0 j 0 origin circle exists label circle radius r ij centered maximal empty circle g every pixel r empty circle largest empty circle clearly steps simple algorithm performed olog log n time using n 2 log log n commoncrcw processors olog n time using n 2 log n erew processors thus corollary 63 task labeling maximal empty circles reporting maximum empty circle binary image size n theta n performed olog log n time using n 2 log log n commoncrcw olog n time using erew n 2 log n processors conclusions first main contribution propose optimal parallel algorithms solving instances size n proximate points problem first algorithm runs olog log n time uses n log log n commoncrcw processors algorithm fact implemented run olog n time using n log n erew processors commoncrcw algorithm worktime optimal erew algorithm addition timeoptimal also timeoptimal second main contribution show proximate points problem finds interesting quite unexpected applications digital geometry image processing first application presented worktime optimal parallel algorithm finding convex hull set n points plane sorted xcoordinate algorithm complexity proximate points algorithm next showed proximate points algorithms afford us worktime optimal resp timeoptimal parallel algorithms various fundamental digital geometry image processing problems specifically show voronoi map euclidean distance map maximal empty circles largest empty circles related problems proved worktime respectively time optimality proximate points convex hull algorithms however image processing problems discussed known whether algorithms developed optimal conjecture problemsomegagammaobl log n time lower bound crcw provided algorithms worktime optimal crew erew logicalor problem reduced image processing problems quite easily thereforeomegagammaher n time lower bound crew erew r euclidean distance transform polymorphic processor array computer vision fast parallel algorithm finding convex hull sorted point set centres maximal discs 5711 distance transform linear time euclidean distance transform algorithms efficient geometric algorithms erew pram optimal algorithm complete euclidean distance transform designing systolic architectures complete euclidean distance trans form efficient algorithm complete euclidean distance transform meshconnected simd fast algorithm euclidean distance maps 2d binary image optimal parallel algorithms computing convex hulls parallel method prefix convex hulls problem simd hypercube algorithm complete euclidean distance transform upper lower time bounds parallel random access machines without simultaneous writes computing voronoi diagrams sorted point sets pattern classification scene analysis optimal parallel algorithm euclidean distance maps unified lineartime algorithm computing distance maps introduction parallel algorithms efficient parallel geometric algorithms mesh trees parallel computation exact euclidean distance transform modified distance transform raster scanning value propagation efficient algorithms euclidean distance transform computational geometry introduction skeletonization algorithm maxima tracking euclidean distance transform finding maximum parallelism comparison problem generation skeletons discrete euclidean distance maps tr ctr ling chen yi pan xiaohua xu scalable efficient parallel algorithms euclidean distance transform larpbs model ieee transactions parallel distributed systems v15 n11 p975982 november 2004 amitava datta subbiah soundaralakshmi fast scalable algorithms euclidean distance transform linear array reconfigurable pipelined bus system journal parallel distributed computing v64 n3 p360369 march 2004
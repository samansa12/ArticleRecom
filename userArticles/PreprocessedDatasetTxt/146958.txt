estimation enhancement realtime software reliability mutation analysis simulationbased method obtaining numerical estimates reliability nversion realtime software proposed extended stochastic petri net used represent synchronization structure n versions software dependencies among versions modeled correlated sampling module execution times distributions execution times derived automatically generated test cases based mutation testing since test cases designed reveal software faults associated execution times reliability estimates likely conservative experimental results using specifications nasas planetary lander control software suggest mutationbased testing could hold greater potential enhancing reliability desirable perhaps unachievable goal independence among n versions nevertheless support nversion enhancement highquality mutationtested code also offered mutation analysis could also valuable design faulttolerant software systems b introduction use multiversion software improve computer system reliability remains topic vigorous debate 2 15 17 18 one cause concern easily seen considering simple model majority voting three voters independently votes yes meaning correct vote probability p probability majority yes decision 3p larger p p larger 12 however votes perfectly correlated probability majority yes decision p improvement thus issue readily identified version correlation meaning phrase software development environment elusive substantial clarification provided eckhardt lee 12 littlewood miller 19 using littlewoods notation 19 let random variable x represent input collection p programs designed perform task let thetax probability randomly chosen program p fails specific input x expected value random variable thetax probability randomly chosen program fails randomly chosen input key observation 12 19 independently developed programs necessarily fail indepen dently probability two independently chosen programs p fail randomly chosen input easily seen e thetax probability failing independently chosen inputs e thetax terms differ variance v thetax similarly theta x probability randomly selected program development methodology fails input x theta b x methodology b probability independently selected programs fail randomly chosen input e theta x theta b x differs independent failures e theta xe theta b x unless covariance cov theta x theta b x j x zero zero covariance clearly equivalent zero correlation aetheta x theta b x j cov theta x theta b x thus correlation deserves attention second major concern precludes lending precise quantification software reliability unknown operational distribution input space testing based random uniform sampling input space often carried reliability estimates based thereon usually regarded optimistic complementary technique obtaining nontrivial conservative estimates missing paper address concerns propose method estimating reliability multiversion realtime software incorporates nonzero correlation independent model parameter section 2 develop extended stochastic petri net 11 representation synchronization structure n software versions dependencies among version performances captured correlated sampling module execution times execution time distributions estimated executing modules test case sets automatically generated module source code automated test case generation based mutation testing described section 3 since test cases generated way designed reveal faults regarded stressful input thus suggest execution time profile derived reliability estimate regarded conservative section 4 describe results mttf applying proposed method 5version implementation accelerometer sensor processing module nasas planetary lander control software expect real benefit optimistic conservative pair reliability estimates provided random testing proposed method gauging relative merits techniques designed enhance reliability one technique providing programmers mutation generated io pairs examined section 5 second technique mutationdirected variation ammann knights data diversity 1 discussed section 6 conclusions follow section 7 2 synchronization model consider program module selfcontained piece software typically subroutine small program thus results impact unit testing rather integration testing restriction realtime software environment allows us focus reliability estimation execution time profiles module fails fails produce correct output within tightly specified time interval even welltested programs may fail meet timing constraints input major impact system reliability model combine timing failures output produced time functional failures output incorrect considering functional failure infinitetime response necessarily violates timing constraint recognize simplification representation functional failures longer able distinguish among different types functional failures however shown later two classes failures timing functional separated necessary analysis define module execution time time correct answer produced thus distribution module execution times points 1 represent functional failures represent synchronization nversion software system terms execution time distributions allow us represent correlation modules independent model parameter specify concurrent operation nversions timer voting mechanism special type extended stochastic petri net 11 petri net directed bipartite graph whose two vertex sets called places transitions places traditionally represented circles transitions rectangles places may contain one tokens represented small discs example shown figure 1 semantics attached nets rules simulation oeae gammapsi j figure 1 simple petri net ffl every input place transition contains one tokens transition enabled transition figure 1 enabled ffl enabled transitions may fire remove one token input place add one token output place ffl firing enabled transition would disable concurrently enabled transition conflict firing transition chosen random petri nets extensions 20 21 22 used many authors systems performance modeling 3 10 14 reliability modeling 23 26 augment petri nets two extensions first extension need nonzero firing time distributions specifically attach transition distribution firing times transition enabled randomly select firing time attached distribution selected time elapses transition fires still enabled model firing time distributions transitions representing program versions empirical execution time profiles obtained executing programs automatically selected test cases second extension require correlated firing since correlation interest degree programs perform relatively well relatively poorly given input rather linear relationship among real execution times implement correlated firing correlation firing time distribution percentiles two programs highly correlated wish choose execution time relative location distribution since distributions contain points 1 representing functional failures two programs correlation 1 exhibit functional behavior execution ie succeed fail implementation transitions grouped one group contain n transitions representing program versions transition becomes enabled locates concurrently enabled transitions group none random number r 2 0 1 used select firing time standard way firing distribution function transition however enabled transitions group one call j selected random recent value r j 2 0 1 used select time js distribution used together group correlation factor k determine new selection value r 2 0 1 probability k let r random 0 1 relationship selection values r r j easily expressed r j random variable uniform 01 density f r j r random variable whose dependence r j described conditional density r ffi denotes unit impulse function see 24 er thus correlation r r j graphical petri net simulation tool includes arbitrary firing time distributions correlated firing called xpsc developed clemson university used study multiversion software model shown figure 2 initial token assignment distribution attached transition represented thin rectangle instantaneous ie time probability 1 firing time attached timer transition deterministic parameter model execution 5version software represented transitions exec 1 exec 5 exec completes returns correct output deposits token place count causes one correct transitions fire timer completes vote taken token either deposited place success least three exec fired place failure two fewer exec fired place failure represents system failure token place success causes oeae r j j j j j gammapsi phi count ae ae ae ae ae z z z z z oeae 1correct 2correct theta theta theta theta thetafl 3correct 4correct 5correct timer timeout failure success restart hy gamma phi phi phi phi phi phi figure 2 multiversion software model special restart transition fire reinitializes net system clock process regeneration point restart transitions also available xpsc group exec transitions correlated group correlation factor k another parameter model thus long short firing time exec representing difficult trivial input cause others select relatively long short firing times correlation high measure interest mean time reach system failure state note correlations zero compute mttf analytically f distribution function exec evaluated fixed timeout interval probability reach place success first pass sum taken fn 3g number passes failure geometrically distributed parameter p provides convenient check xpsc simulation results converge value correlation k approaches 0 important observe case sample precisely relative performance levels corresponds natural synchronization exec versions identical inputs exec versions exhibit natural high correlation performance inputs giving rise exec distributions structure allows us use whatever natural correlation exists among versions still treat correlation independent model parameter distributions used exec transitions study measured execution times five independently developed implementations accelerometer sensor processing module nasas planetary lander control software described section 4 input cases module executed generated automated system based mutation testing 3 mutation testing generating test cases effective finding faults technically difficult task one important criterion generating test data relative adequacy defined demillo et al 7 p program implement function f pi collection programs test set adequate p relative pi ptft 8 t2t 8 qt6ft words test set adequate distinguishes program tested set incorrect programs mutation testing 7 testing technique based relative adequacy regarded software analogue hardware faultinjection experiment mutation testing systems apply collection mutation operators test program produces set executable variations called mutants original program test cases used cause mutants generate incorrect output mutant programs shown incorrect test case considered dead executed subsequent test cases mutants functionally equivalent original program cannot killed mutation score test set percentage nonequivalent mutants dead total number mutants number dead mutants number equivalent mutants e mutation score calculated e mutation score close approximation adequacy set test data test set relative adequate score 100 mutants killed goal mutation testing find test data kill mutants assumption test data provide strong test original program effectiveness approach based upon fundamental premise software contains fault likely mutant killed test case also reveals fault mutationadequate tests shown experimentally 4 13 analytically 5 high quality tests recent mutation system mothra 6 allows tester examine remaining live mutants design tests kill mutation operators used mothra 16 represent 10 years refinement several mutation systems operators explicitly require test data meet statement extended branch coverage criteria extremal values criteria domain perturbation mutation operators also directly model many types faults unfortunately generating mutationadequate tests laborintensive task solve problem offutt 9 devised adequacybased scheme automatically generating test data constraintbased testing cbt system constraintbased testing represent conditions mutant die mathematical constraints inputs generate test case satisfies constraint system implementation technique godzilla integrated mothra godzilla system develops test data detect classes faults mothra software testing system models godzilla generates test data posing question properties must program inputs kill mutant inputs must cause mutant incorrect program state execution mutated statement godzilla uses syntactic information mothra uses force syntactic change represented mutation making semantic difference execution since faults modeled simple faults single statements initial condition mutated statement must reached reachability condition mutated statement executed test case must cause mutant behave erroneously ie fault injected must result failure programs output godzilla describes conditions test cases mathematical systems constraints reachability condition described system constraints called path expression statement program path expression contains constraint system describes execution path program reach statement condition test case must cause erroneous state described constraint specific mutation operator general necessity constraint requires computation performed mutated statement create incorrect intermediate program state although incorrect intermediate program state necessary fault detection clearly sufficient guarantee detection order detect fault test case must cause mutant produce incorrect output case final state mutant differs original program although deriving test case meets sufficiency condition certainly desirable impractical determining sufficiency condition implies knowing complete path program take intractable thus partial solution relying necessity condition used generate test cases godzilla solves conjunction path expression constraint necessity constraint create test case consisting values input variables make constraints true godzilla consistently generates test cases kill 95 mutants 8 4 correlated sampling experiment nasas planetary lander control software designed nversion voting system five implementations accelerometer sensor processing module system independently constructed tested programmers separate version 0 written tested using mothra version 55 lines 3778 nonequivalent mutants godzilla generated test cases kill 3778 mutants correctness 0 cases verified hand 0 correct oracle version modules average execution time module test case measured module returned incorrect output test case execution time considered infinite empirical execution time distributions attached exec transitions petri net model described section 2 exec transitions placed single group correlation factor k since test data generated using godzilla generator empirical execution time distributions likely differ expected normal conditions input sets attempt maximize likelihood module failing produce correct output thus conservative reliability estimate suggested additionally allow multiple correct answers example differ inconsequential value limitation implementation specifically mothra system reliability model since means may label correct answers incorrect limitation contributes conservativeness reliability estimate software used experiment based specifications provided nasa 25 specifications quite thorough regard must accomplished module parameters must module selected tight timing requirements reasonable computational complexity module specifications summarized figure 3 module takes input accelerometer sensor removes natural electrical temperature bias steps 1 2 produces accelerations three physical body directions transforming accelerometer data accelerations timedependent operation must execute quickly possible function requires following steps 1 gain gain 2 acceleration bias 3 shift status acceleration right 1 column 4 acceleration alpha matrix acceleration 5 row status acceleration previous three values status unhealthy set statusi0 healthy otherwise three dimensions acceleration calculate mean standard deviation oe scaleoe set accelerationi0 set statusi0 unhealthy figure 3 asp specification summary 5 programmers given input data types ranges specific test data also told module must satisfy tight timing constraints 5 fortran77 versions module ranged 42 55 lines code run sun 350s sunos version 41 although monitor programmer debugging perform acceptance testing execution times correct output 5 versions ranged 89 151 milliseconds stated incorrect answers penalized effective time 1 yet test cases 5 versions 150 total responses 20 responses incorrect number functional failures per version 0 1 1 5 13 parameters synchronization model value timing constraint correlation among exec modules k figure 4 show mean time failure mttf function timing constraint range correlation factors curve spline 63 datapoints evenly spaced across range 89 151 ms since longest correct execution time 151 ms righthand endpoints curves figure 4 show reliability estimates functional errors considered figure also shows timing constraint tight versions software fail immediately ie one timer interval note extreme sensitivity mttf correlation range 0 k 03 see precipitous drop mttf wide range timing constraints trend holds software general cause concern since study causes us expect programs natural environment correlate least degree example use specific value figure 4 mttf correlated samples mutation test timing constraint transform execution time random variable binary success correct execution time measure sample correlation successfailure possible pairings programs sequence automatically generated test data choice ms yielded 92 successes 58 failures 30 test cases theta 5 versions average pairwise correlation 0200498 lend evidence conjecture reliability estimates conservative ran experiment using random test cases place godzillagenerated test cases assumed uniform distribution legal input space selected 100 test cases random five versions executed 100 test cases execution time time correct output distribution recorded synchronization model run using new execution time distributions results shown figure 5 see dramatic increase estimated mttf correlation timing constraint values indicating random testing find many faults mutation testing average pairwise sample correlation successfailure ms case 0157524 derived 284 successes 216 failures 100 test cases theta 5 versions two sets curves figures 4 5 serve estimated bounds reliability 5version voting system also provide gauge might judge effectiveness reliability enhancement techniques 5 enhancement programmers typically respond test results modifying code correct faults found testing naturally expected improve reliability second experiment five programmers provided automatically generated test cases including figure 5 mttf correlated samples random test correct outputs given opportunity improve module code modules changed sometimes extensively worked correctly test cases automated test case generator run provide alternative set test cases 100 mutation kill score new set also contained test cases although new set satisfied mutation criteria randomness inherent constraint satisfaction mechanism ensured different values five improved modules executed 30 new test cases execution time time correct output distribution recorded synchronization model executed using new distributions results shown figure 6 see dramatic improvement reliability mttf exhibited figure 4 control five original modules also executed new test cases synchronization model run resulting execution time distributions results similar figure 4 report slightly lower mttf indicates new test cases represent least stringent test original set well indicating mttf improvement figure 6 figure 4 genuinely indicates substantial improvement reliability note although relative effects correlation still visible figure 6 correlation curve figure 6 lies entirely correlation curve figure 4 since nversion system equivalent single version interpretation single version code specification includes matching mutationgenerated io pairs may reliable 5version voting system testing complete control individual unit developers results also suggest constraintbased testing could hold greater potential reliability enhancement desirable perhaps unachievable goal independence among n versions nevertheless alternative interpretation would lend support nversion programming may unfair compare higher quality code represented figure 6 represented figure 4 since testing latter case uncontrolled figure mttf improved code new mutation test focus higher quality code represented figure 6 see specific timing constraint within range 105 110 ms successful nversion programming k small offer substantial improvement single version case emphasize present experiment simple one complete case study needed attempt draw definitive conclusions example since random testing find many faults mutation testing see figure 5 conclude random testing unlikely hold much potential reliability enhancement however cannot conclude presenting programmers test cases generated alternative nonrandom scheme eg data flow testing functional testing would less effective using mutationgenerated cases 6 mutation gradient retry mutation analysis may also prove effective design faulttolerant software realtime environment sensor data often contains noise ammann knight 1 proposed retrying failures forced minor variations input data technique called data diversity could effective means providing software fault tolerance missing approach guidance direction data variation find minor variation caused us enter domain region lesser mutation kill potential identified constraints generated testing could reasonably expect less data sensitivity hence greater probability success retry explore possibility within present testing framework isolated particularly troublesome mutationgenerated test case 4 5 original versions exhibited functional failure single test case caused versions fail fixed input values point except values g1 g2 see specifications figure 3 randomly varying g1 g2 across legal ranges 50 50 obtained 15000 system failure points shown figure 7 points 3 versions exhibited functional failure diagram strikingly gamma5 gamma4 gamma3 gamma2 gamma1135 figure 7 failure points g1g2 space similar 1 suggesting high density failure regions form hyperplanes input space subjected 15000 failure points system retry forced variation g1 g2 varied point g1 g2 random direction per 1 direction downward mutation gradient determined mutation kill scores lattice points g1 g2 space process automated computationally expensive number failures surviving retry function distance moved shown figure 8 see random retry offered order magnitude reduction failures 15000 1500 mutation gradient retry fared significantly better also plotted figure 8 results retry direction upward mutation gradient mutation gradient generally points orthogonally failure hyperplanes upward gradient movement serve well downward certainly supported results test conclusions presented method obtaining numerical estimates reliability nversion realtime software method uses extended stochastic petri net represent synchronization p2up random distance changed failures figure 8 failures surviving retry structure n versions software modules net simulation used estimate system reliability different correlation assumptions module execution time distributions derived executing modules test cases generated mutation testing system since test cases designed reveal faults hence represent stressful input contend execution time distributions likely deliver conservative estimate system reliability major advantage approach allows us directly incorporate results software testing reliability measure conducted simple empirical investigation approach using five independently developed implementations accelerometer sensor processing module nasas planetary lander control software observed rapid decrease estimated reliability 5version system correlation increased narrow range 00 k 03 disturbing suggests even relatively low correlation among versions could prevent significant reliability enhancement nway voting alone also considered technique reliability enhancement programmers given mutationgenerated io pairs required match resulting dramatic improvement estimated system reliability suggests constraintbased testing may hold greater potential reliability enhancement achieving independence among n versions nevertheless find successful nversion programming k small applied improved modules offer additional significant reliability enhancement range tight timing constraints emphasize coding experiment simple one complete case study needed attempt draw definitive conclusions finally considered application mutation analysis design faulttolerant software modified ammann knights data diversity technique calls retry system failure forced minor random variation input data incorporate specific variation direction determined mutation kill gradient results show significant reduction system failures however study considered twodimensional cross section input space consider effects multiple retries extended study incorporates entire input domain well effects timing constraints limiting multiple retries warranted r data diversity approach software faulttolerance combining queueing networks generalized stochastic petri nets solution complex models system behavior mutation analysis program test two notions corrections relation testing extended overview mothra software testing environment hints test data selection help practicing programmer experimental results automatically generated adequate test sets design unified package solution stochastic petri net models extended stochastic petri nets applications analysis theoretical basis analysis multiversion software subject coincident errors experimental comparison error exposing ability program testing criteria generalized timed petri net model performance analysis specificationoriented multiversion software experiment fortran language system mutationbased software testing experimental evaluation assumption independence multiversion programming empirical study failure probabilities multiversion software conceptual model multiversion software class generalized stochastic petri nets performance evaluation multiprocessor systems performance analysis using stochastic petri nets petri net theory modeling systems modeling faulttolerant techniques hierarchical systems probability statistics reliability software requirements guidance control software development specification fast timing verification method based independence units tr class generalized stochastic petri nets performance evaluation multiprocessor systems experimental evaluation assumption independence multiversion programming generalized timed petri net model performance analysis combining queueing networks generalized stochastic petri nets solution complex models system behavior fortran language system mutationbased software testing constraintbased automatic test data generation probability statistics reliability queuing computer science applications petri net theory modeling systems extended stochastic petri nets design unified package solution stochastic petri net models mutation analysis program test data ctr evan martin automated test generation access control policies companion 21st acm sigplan conference objectoriented programming systems languages applications october 2226 2006 portland oregon usa evan martin tao xie fault model mutation testing access control policies proceedings 16th international conference world wide web may 0812 2007 banff alberta canada lorrie tomek jogesh k muppala kishor trivedi modeling correlation software recovery blocks ieee transactions software engineering v19 n11 p10711086 november 1993 peter popov lorenzo strigini john may silke kuball estimating bounds reliability diverse systems ieee transactions software engineering v29 n4 p345359 april
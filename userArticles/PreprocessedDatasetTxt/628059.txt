justification inclusion dependency normal form abstractfunctional dependencies fds inclusion dependencies inds fundamental integrity constraints arise practice relational databases paper address issue normalization presence fds inds particular semantic justification inclusion dependency normal form idnf normal form combines boycecodd normal form restriction inds noncircular keybased motivate formalize three goals database design presence fds inds noninteraction fds inds elimination redundancy update anomalies preservation entity integrity show fds presence inds free redundancy equivalent free update anomalies properties derive equivalent syntactic conditions database design individually syntactic conditions weaker idnf restriction fd embedded righthand side ind common three conditions however also show three goals database design satisfied simultaneously idnf necessary sufficient condition b introduction functional dependencies fds arm74 mai83 ull88 aa93 generalise notions entity integrity keys cod79 inclusion dependencies inds mit83 cfp84 generalise notions referential integrity foreign keys cod79 dat86 sense fds inds fundamental data dependencies arise practice relational database design presence fds established area database theory researched twenty years cod74 bb79 mai83 ull88 aa93 semantic justification normal forms presence fds wellunderstood terms eliminating called update anomalies redundancy problems arise relation satisfying set fds bg80 fag81 cha89 vin94 vin98 advice given result investigation semantics normal forms order eliminate mentioned problems design database schemas boycecodd normal form bcnf cod74 despite importance inds integrity constraints little research carried integrated normalisation process relational database integration fundamental success design since enforcement referential integrity simple matter ctf88 normal forms include fds inds considered ca84 mr86 lg92 mr92 bd93 necessary sufficient conditions terms removing update anomalies redundancy problems given goal paper fill gap providing sufficient necessary semantics inclusion dependency normal consider problems occur presence fds inds two examples first example illustrates situation attribute redundant due interaction fds inds example 11 let head relation schema attributes h h stands head department stands department let lect relation schema attributes l l stands lecturer stands department furthermore let dg set fds database schema stating head department manages unique department lecturer works unique department fheadhd lectldg set inds r stating head department also works lecturer department note logical implication pullback inference rule see proposition 21 thus fd head f redundant also note assumed head h f thus department may one head two problems arise respect r f firstly interaction f may lead logical implication data dependencies envisaged database designer may easy detect general implication problem fds inds intractable see discussion section 2 example pullback inference rule implies fd f redundant secondly ind headhd lectld combined fd lect imply attribute head redundant since department head inferred fact l key lect formally inference done aid relational algebra expression uses renaming join projection see mai83 ull88 aa93 details relational algebra thus headhd lectld replaced headh lectl attribute head removed without loss information second example illustrates situation propagation insertions due inds may result violation entity integrity example 12 let emp relation schema attributes e p e stands employee name p stands project title let proj relation schema attributes p l p stands project title l stands project location furthermore pg set fds database schema stating employee works unique project fempp projpg set inds r stating employees project one listed projects note project may situated several locations correspondingly location may associated several projects thus fp lg primary key proj problem arises respect r f righthand side p ind empp projp proper subset primary key proj let r 1 r 2 relations emp proj respectively suppose employee assigned new project yet allocated location thus yet recorded r 2 due ind insertion employee tuple r 1 new project propagated r 2 inserting r 2 tuple recording new project since location project still unknown due entity integrity possible propagate insertion r 2 summarise problems would like avoid designing relational databases presence fds inds firstly avoid redundant attributes secondly avoid violation entity integrity propagating insertions lastly avoid interaction fds inds due intractability joint implication problem fds inds main contributions paper formalisation design problems result database schema idnf problems eliminated also demonstrate robustness idnf showing bcnf removing redundancy database schema presence fds inds also equivalent eliminating update anomalies database schema layout rest paper follows section 2 formally define fds inds satisfaction introduce chase procedure means testing enforcing satisfaction set fds inds section 3 formalise notion interaction set fds inds give necessary sufficient condition fds noncircular inds interact section 4 characterise redundancy presence fds inds section 5 characterise insertion modification anomalies presence fds inds show equivalence free either insertion modification anomalies free redundancy section 6 characterise generalisation entity integrity presence fds inds section 7 define idnf present main result establishes semantics idnf terms either update anomalies redundancy problems satisfaction generalised entity integrity finally section 8 give concluding remarks indicate current research direction definition 11 notation denote cardinality set jsj size set defined cardinality standard encoding subset write proper subset write ae often denote singleton fag simply write 2 mean fag addition often denote union two sets ie simply st functional inclusion dependencies formalise notions fds inds satisfaction define useful subclasses fds inds also present chase procedure testing enforcing satisfaction set fds inds chase procedure instrumental proving main results definition 21 database schema database let u finite set attributes relation schema r finite sequence distinct attributes u database schema finite set g r 2 r relation schema assume countably infinite domain values without loss generality assume linearly ordered rtuple simply tuple whenever r understood context member cartesian product theta relation r r finite possibly empty set rtuples database r family n relations fr r 2 r 2 r given tuple r assuming r 2 relation r denote insertion r ftg deletion r gamma ftg let r database schema database r furthermore let r 2 relation relation schema r 2 r definition 22 projection projection rtuple onto set attributes r denoted ty also called yvalue restriction projection relation r onto denoted r defined rg definition 23 functional dependency functional dependency simply fd database schema r statement fd relation schema r r 2 r x r sets attributes fd said trivial x said standard x 6 satisfied denoted definition 24 inclusion dependency inclusion dependency simply ind database schema r statement form r x r j r sequences distinct attributes ind said trivial form rx rx ind rx sy said unary ind said typed form rx sx ind r x r j r satisfied denoted relations r r j respectively let f set fds r f set fds f r 2 r furthermore let set inds r let definition 25 logical implication sigma satisfied denoted logically implies fd ind oe written sigma whenever database r following condition true holds logically implies set gamma fds inds r written sigma denote set fds inds logically implied sigma definition 26 keys bcnf keybased inds set attributes x r superkey r respect f f key r respect f superkey r respect f proper subset ae x superkey r respect f let keysf set fds form x r x key r respect f ng database schema r boycecodd normal form simply bcnf respect f r 2 r nontrivial fds r superkey r respect f ind r x r j superkeybased respectively keybased superkey respectively key r j respect f j definition 27 circular noncircular sets inds set inds r circular either 1 contains nontrivial ind rx ry 2 exist distinct relation schemas r 1 contains inds r 1 set inds noncircular circular class proper circular inds imi91 defined includes class noncircular inds special case definition 28 proper circular sets inds set inds r proper circular either noncircular whenever exist distinct relation schemas r 1 contains inds r 1 well known armstrongs axiom system arm74 mai83 ull88 aa93 used compute f casanovas et al axiom system cfp84 used compute however consider fds inds together computing sigma shown undecidable mit83 cv85 hand noncircular mitchells axiom system mit83 used compute sigma ck86 moreover special case set unary inds cosmadakiss et al axiom system ckv90 used compute sigma implication problem problem deciding whether oe oe fd ind sigma set fds inds wellknow implication problem fds decidable linear time bb79 hand implication problem inds general pspacecomplete cfp84 implication problem noncircular inds npcomplete man84 ck86 typed inds polynomial time implication problem cv83 unary inds linear time implication problem ckv90 consider fds inds together implication problem undecidable mentioned implication problem fds noncircular inds exptimecomplete noncircular inds typed implication problem nphard ck86 fds unary inds polynomial time implication problem ckv90 next proposition describes pullback inference rule mit83 cfp84 allows us infer fd fd ind proposition 21 sigma definition 29 reduced set fds inds projection set fds f r onto set attributes r denoted f given f wz yg set attributes r said reduced respect r set fds f simply reduced respect f r understood context f contains trivial fds set fds inds said reduced 8 r x r j 2 reduced respect f j easily shown decided polynomial time size sigma whether sigma reduced chase procedure provides us algorithm forces database satisfy set fds inds definition 210 chase procedure inds chase respect sigma denoted chased sigma result applying following chase rules fd ind rules current state long possible current state prior first application chase rule state upon input chase procedure fd rule r occurrences larger values 1 2 smaller values 1 2 ind rule r x r j 2 9t 2 r tx 62 r j add tuple u r j r j assigned new value greater current value occurring tuples relations current state observe allow circular chase procedure always terminate jk84 chase respect sigma terminate chased sigma said violate set fds g r ie chased sigma 6j g finite number applications ind rule current state resulting 0 0 6j g special case class proper circular inds shown chase procedure always terminates imi91 following theorem consequence results mr92 chapter 10 theorem 22 let set fds proper circular inds database schema r following two statements true ii chased sigma terminates finite number applications ind rule current state 2 3 interaction fds inds demonstrated proposition 21 fds inds may interact sense may fds inds implied set fds inds implied fds inds taken separately point view database design interaction undesirable since database design may normalised respect set fds respect combined set fds inds illustrated following example example 31 consider database schema set sigma fds f inds r given sabg easily verified r bcnf respect f however augment f b logically implied sigma using proposition 21 r bcnf respect augmented set fds f since superkey r respect set fds bg major difficulty occurs database design set fds inds interact result fact noted earlier implication problem arbitrary set fds inds undecidable mit83 cv85 general cannot determined whether database design bcnf respect arbitrary set fds inds since set logically implied fds cannot effectively computed consequence desirable goal database design set fds inds interact formalise notion non interaction characterise proper circular inds special case non interaction occurs definition 31 interaction occurring fds inds set fds f r said interact set inds r 1 fds ff r subsets g f g inds fi r subsets j f j j following theorem proven ll95 see mr92 chapter 10 theorem 31 r bcnf respect set fds f r proper circular set inds r reduced f interact 2 next example shows cannot general extend theorem 31 case set inds proper circular particular proposition 21 sigma reduced necessary condition interaction occur f sufficient condition non interaction example 32 consider database schema set sigma fds f inds r given ag fra sa sb rbg easily verified sigma reduced circular using axiom system follows sigma thus f interact another example let easily verified sigma reduced circular f interact since using axiom system rag 4 attribute redundancy section investigate conditions database design ensure elimination redundancy goal long cited one principal motivations use normalisation database design mai83 ull88 mr92 aa93 however proven somewhat difficult formalise intuitive notion redundancy relatively recently notion formalised relationship classical normal forms established vin94 vin98 definition redundancy associated normal form guarantees redundancy elimination follows definition 41 value redundancy let database r satisfies f 2 r tuple r 2 relation relation schema r 2 r occurrence value ta 2 r attribute redundant respect f every replacement ta distinct value v 2 v 6 ta resulting database 0 0 6j f database schema r said value redundancy free normal form simply vrfnf respect set fds f r exist database r occurrence value ta redundant respect f illustrate definition simple example example 41 consider single relation scheme set f fds given bg r vrfnf since consider relation r r shown table 1 bvalue 2 present tuples redundant since r replacing value 2 either tuple another value results f violated table 1 relation r following result established vin94 vin98 shows given set fds f vrfnf equivalent bcnf sake completeness provide sketch proof theorem 41 database schema r bcnf respect f r vrfnf respect f proof part follows showing contrapositive r bcnf vrfnf result follows r bcnf exists nontrivial implied fd x x superkey using well known construction theorem 71 ull88 exists two tuple relation r tuples identical xa relation r vrfnf since changing either avalues results x violated part follows observation occurrence ta redundant relation r must exist r implies x cannot superkey hence r bcnf establishes part 2 vin98 shown presence multivalued dependencies 4nf fourth normal form fag77 also equivalent vrfnf somewhat surprisingly syntactic equivalent vrfnf general case join dependencies present new normal form weaker pjnf projectjoin normal form fag79 5nf fifth normal form mai83 vin98 concept value redundancy little use though evaluating database designs presence inds following result demonstrates design constraints involve nontrivial inds vrfnf respect set inds lemma 42 let set fds noncircular inds database schema r r vrfnf respect sigma nonempty contains least one nontrivial ind proof let r x r j nontrivial ind construct database relation r r single tuple containing zeros every relation r k empty let thus theorem 22 0 due noncircularity 0 r current state r 0 let r 0 j current state relation r j r j 0 yvalues tuple r 0 must contain zeros since thus zeros single tuple r 0 redundant since changing results r x r j violated 2 due lemma require design vrfnf respect fds respect inds however noted others sci86 lg92 mr92 even stronger form redundancy occur database presence inds refer attribute redundancy illustrated example 11 given introduction definition 42 attribute redundancy attribute relation schema r 2 r redundant respect sigma whenever database r satisfies sigma r 2 nonempty relation r every tuple 2 r ta replaced distinct value v 2 resulting database 0 0 6j sigma database schema r said attribute redundancy free normal form simply arfnf respect set fds inds sigma r exists attribute relation schema r 2 r redundant respect sigma next example shows arfnf weak sigma contains fds highlighting difference vrfnf arfnf example 42 consider relation r example 41 shown table 1 let r 0 result adding tuple 5 2 4 r easily verified although r vrfnf respect f r arfnf respect f since replace value distinct value resulting database still satisfies f combining definitions 41 42 define redundancy free normal form definition 43 redundancy free normal database schema r said redundancy free normal form simply rfnf respect set fds inds sigma r vrfnf respect f arfnf respect sigma next theorem shows set inds noncircular rfnf equivalent set fds inds reduced database schema bcnf theorem 43 let set fds noncircular inds database schema r r rfnf respect sigma sigma reduced r bcnf respect f proof theorem 41 r vrfnf respect f remains show r arfnf proof utilise directed graph representation g n e set inds constructed follows see sci86 relation schema r r separate node labelled r distinguish nodes labels arc r nontrivial ind rx sy 2 easily verified path g r ind rx sy since noncircular g acyclic let 2 r attribute r 2 r relation schema construct database nonempty relation r 2 exhibits fact nonredundant respect sigma first initialise database database 0 follows let r single tuple b relations r 0 r k initialised empty 0 therefore theorem 22 1 current state r theorem 31 r 1 current state r 1 k 1 relation r 0 k empty exist path g r r k single tuple 0 b 2 r including therefore theorem 22 3 current state r since 2 final state initialisation j f since 3 claim also case let us call nontrivial ind r x r j 2 source ind 2 x projection permutation inference rule inds cfp84 assume without loss generality source ind form r va r j wb due noncircularity current state r k relation r 3 k empty exist path g r r k therefore r k r arc r r j g ind r x r j two cases consider first 62 x contains zeros thus secondly 2 x r x r j source ind r va r j wb let r j current state r 3 therefore follows ind r x r j path r r j since 3 required part concluded since 3 differ replacement 0 theorem 41 r bcnf respect f vrfnf assuming sigma reduced remains show r arfnf assumption exists ind r x r j 2 nontrivial fd pullback inference rule nontrivial fd projection permutation inference rule inds cfp84 let 2 r tuple nonempty relation r assume j sigma follows redundant respect sigma since whenever replace ta distinct value resulting database 0 seen 0 contrary assumption 2 next construct two examples demonstrate conditions theorem 43 violated r arfnf example 43 let r database schema example 11 consider database overr shown tables 2 3 respectively verified set fds inds example reduced r bcnf respect set fds attribute relation schema head seen redundant since changing e 1 table 2 causes violated similar situation occurs every database defined r r arfnf table 2 relation head table 3 relation lect example 44 let r fstudent enrolg database schema student fstud id nameg addressg furthermore let addressg set fds r fenrolstud id studentstud idg set inds r verified set fds inds example reduced r bcnf respect set fds r rfnf vrfnf since occurrences 1 enrol redundant database shown tables 4 5 respectively stud id name table 4 relation student stud id course address table 5 relation enrol next example shows cannot extend theorem 43 case set inds circular example 45 consider database schema set sigma fds f inds r given ag fra sa rag verified sigma reduced r bcnf respect f proper circular unary typed also keybased let database r nonempty relation r let r tuple assume without loss generality 0 database resulting replacing distinct value 1 resulting tuple 0 0 1 order conclude example show 0 6j sigma assume contrary 0 sigma thus must tuple distinct 1 case 0 6j ra sa since follows thus contrary assumption therefore attribute 2 r must redundant respect sigma reader easily verify attribute 2 also redundant respect sigma even f empty appears example relation schema removed r without loss semantics 5 insertion modification anomalies section investigate conditions database design ensures elimination keybased update anomalies distinct types update anomalies investigated bg80 vin94 concept originally introduced fag81 deal insertion deletion tuples later extended vin92 vin94 include modifications tuples keybased update anomaly defined occur update relation either insertion deletion modification results new relation satisfying key uniqueness violating constraint relation reason considered undesirable enforcement key uniqueness implemented via relational database software much efficient manner enforcement general constraints fds mai83 ull88 aa93 satisfaction constraints relation result key uniqueness integrity relation update easily enforced whereas existence keybased update anomaly implies converse herein formalise concepts based approach difference presence inds allow update propagate relations chase procedure show free insertion anomalies equivalent free modification anomalies addition show inds noncircular free either insertion modification anomalies equivalent set fds inds reduced database schema bcnf respect set fds consider deletion anomalies since presence fds removing tuple relation satisfies set fds cause violation fd set definition 51 compatible tuple tuple r compatible respect set fds inds r simply compatible whenever sigma understood definition 52 free insertion anomalies database r insertion violation respect set fds inds simply insertion violation whenever sigma understood context 1 2 exists tuple r compatible chased ftg 6j sigma database schema r free insertion anomalies respect sigma simply r free insertion anomalies sigma understood context exist database r insertion violation note definition 52 utilised chase procedure enforce propagation insertions tuples due inds example insertion violation consider database schema r example 11 let database r 1 relation head empty r 2 relation lect contains single tuple 0 0 insertion violation tuple since applying chase procedure results added relation r 2 thus violating fd l next theorem shows assuming set inds noncircular bcnf set fds inds reduced equivalent free insertion anomalies theorem 51 let set fds noncircular inds database schema r r free insertion anomalies sigma reduced r bcnf respect f proof let database r tuple compatible remains show chased ftg first claim chased ftg holds due theorem 31 implying fd rule need never invoked computation chased ftg sigma moreover due fact r bcnf respect f compatible theorem 22 chased ftg sigma two cases consider case 1 r bcnf respect f r 2 r bcnf respect f thus nontrivial fd superkey r respect f assume x reduced respect r f otherwise replace x reduced subset w x w x follows x proper subset superkey r respect f let r r contain single tuple containing zeros let relations empty assume without loss generality j sigma otherwise let chased sigma due noncircular state r remains unchanged chased sigma let tuple whose xvalues zeros values ones compatible chased ftg 6j sigma since fd violated current state r therefore r free insertion anomalies case 2 sigma reduced r bcnf respect f ind r x proper superset key say w r j respect f j let r j r j contain single tuple say containing zeros let relations including r r empty assume without loss generality j sigma otherwise let chased sigma due noncircular state r remains unchanged chased sigma tuple agrees j wvalue disagrees j rest values compatible chased ftg 6j sigma since fd w violated resulting current state r j 2 illustrate theorem note firstly example given theorem 51 demonstrates case database schema insertion anomaly set dependencies reduced alternatively following example demonstrates case database schema bcnf insertion anomaly example 51 let r example 44 start database shown tables 6 7 respectively insert tuple compatible enrol enrol relation applying chase procedure results database 0 shown tables 8 9 respectively n 2 new value seen 0 violates sigma r free insertion anomalies next example show part theorem 51 general false even proper circular set inds stud id name table relation student stud id course address table 7 relation enrol stud id name table 8 relation 0 student stud id course address table 9 relation 0 enrol example 52 consider database schema set sigma fds f inds r given rabg easily verified proper circular r bcnf sigma reduced addition r free insertion anomalies since database fr sg relations r respectively due drop sab rab proof part theorem 51 r insertion violation next example illustrates cannot general extend theorem 51 case set inds circular even sigma reduced due possible interaction fds inds example 53 consider database schema set sigma fds f inds r given rbg verified sigma reduced circular shown example 32 although sigma reduced sigma thus f interact let database r relation r r contains single tuple let tuple insertion violation since chased ftg fact case chase procedure terminate since inserted r chase procedure modify tuples input database satisfy sigma see comment definition 210 formally define second type keybased update anomaly modification anomaly following approach vin92 vin94 difference chase procedure used propagate effects change relations definition 53 free modification anomalies database r modification violation respect set fds inds simply modification violation whenever sigma understood context 1 2 exists tuple u relation r tuple r compatible database schema r free modification anomalies respect sigma simply r free modification anomalies sigma understood context exist database r modification violation theorem 52 let set fds noncircular inds database schema r r free modification anomalies r free insertion anomalies proof let database r tuple compatible u 2 r tuple r 2 relation r follows compatible fug need show chased ftg sigma theorem 22 chase procedure chased remains show chased gamma fug ftg g definition 210 chase procedure follows chased since definition 52 chased ftg r free modification anomalies similar argument made part proof theorem 51 follows sigma reduced r bcnf first case add additional tuple u r contains ones original state r second case add additional tuple u r contains zeros original state r result follows part theorem 51 2 combining theorems 43 51 52 obtain next result corollary 53 let set fds noncircular inds database schema r following statements equivalent r free insertion anomalies ii r free modification anomalies iii r rfnf 2 6 generalised entity integrity section justify superkeybased inds basis cause propagation insertion tuples represent undefined entities thus causing violation entity integrity problem illustrated example 12 given introduction next definition view chase procedure mechanism enforces propagation insertions tuples due inds definition 61 generalised entity integrity let tuple added relation r current state database computation chased sigma entitybased exists least one key x r respect f 2 x ta new value assigned result invoking ind rule database schema r satisfies generalised entity integrity respect set fds inds r databases r tuples added relations current state computation chased sigma entitybased next theorem shows satisfaction generalised entity integrity equivalent set inds superkeybased theorem 61 database schema r satisfies generalised entity integrity respect set fds inds superkeybased proof superkeybased result immediately follows definition ind rule see definition 210 hand superkeybased ind r x superkey r j respect f j let database r relations apart r r empty relation r single tuple definition fd rule see definition 210 every key say k r j respect f j least one attribute say 2 k tuple j added r j r j assigned new avalue ind rule otherwise contrary assumption deduce superkey r j respect f j follows r satisfy generalised entity integrity concluding proof 2 7 inclusion dependency normal form database schema idnf respect set fds inds bcnf respect set fds set inds noncircular keybased show database schema idnf satisfies generalised entity integrity either free insertion anomalies free modification anomalies redundancy free normal form next formally define idnf cf mr86 mr92 definition 71 inclusion dependency normal form database schema r inclusion dependency normal form idnf respect set sigma fds f inds r simply idnf sigma understood context 1 r bcnf respect f 2 noncircular keybased set inds note set inds empty r idnf equivalent r bcnf note restricted fds f standard next result follows corollary 53 theorem 61 definition 71 theorem 71 let set fds noncircular inds database schema r following statements equivalent r idnf ii r free insertion anomalies satisfies generalised entity integrity iii r free modification anomalies satisfies generalised entity integrity iv r rfnf satisfies generalised entity integrity 2 concluding remarks identified three problems may arise designing databases presence fds inds apart update anomalies redundancy problems may arise relation due fds considered first problem attribute redundancy second problem potential violation entity integrity propagating insertions third problem concerns avoiding complex interaction may occur fds inds intractability determining interaction first problem formalised rfnf shown corollary 53 database schema rfnf respect set fds inds free insertion anomalies equivalently free modification anomalies result viewed extension similar result considering fds second problem formalised generalised entity integrity shown theorem 61 database schema satisfies generalised entity integrity respect set fds inds set inds superkeybased third problem formalised non interaction implication problem fds inds shown theorem 31 set fds inds interact set inds proper circular set fds inds reduced database schema bcnf combining result together obtained theorem 71 three equivalent semantic characterisations idnf theorem 71 justifies idnf robust normal form eliminates redundancy update anomalies database schema goal normalisation reduce redundancy seems apart r bcnf general must restrict set inds noncircular see example 45 nonetheless circular sets inds arise practice example want express pairwise consistency two relation schemas r consistent set inds includes two inds database schema r pairwise consistent every pair relation schemas consistent bfmy83 note pairwise consistency expressed set proper circular inds case need alternative semantics express goal normalisation minimal requirement fds inds interaction theorem 31 long set fds inds reduced r bcnf respect f set inds expresses pairwise consistency f interact since proper circular consider bcnf database schema r relation schemas empdnameg set inds expresses fact employees work departments exist departments least one employee first ind keybased second despite fact verified f interact moreover managers also employees could add ind deptmgr empename verified exhibiting appropriate counterexamples still true f interact although even proper circular database schema r seems reasonable design idnf research needs carried determine semantics normal forms fds inds conclude paper proposing normal form database schema r interaction free inclusion dependency normal form respect set sigma fds f inds r 1 r bcnf respect f 2 inds either keybased express pairwise consistency 3 f interact r relational database theory dependency structures data base relationships computational problems related design normal form relational schemas objects relational database schemes functional desirability acyclic database schemes boycecodd normal form proceedingsin proceedings international conference large data basesproceedings inclusion dependencies interaction functional dependencies design theory solving anomalies problem graph theoretic approach recent investigations relational data base systems extending database relational model capture meaning enforcing towards sound view integration methodology implication problem functional referential integrity multivalued dependencies new normal form relational databases normal forms relational database operators normal form relational databases based domains keys abstraction query processing testing containment conjunctive queries functional logical database design prevent interaction functional theory relational databases complexity inference problem subclasses implication problem functional comparing universal instance relational data models principles database knowledgebase systems modification anomalies boycecodd normal form semantic justification normal forms relational database design redudnancy elimination new normal form relational databases tr ctr fabien de marchi jeanmarc petit semantic sampling existing databases informative armstrong databases information systems v32 n3 p446457 may 2007 stphane lopes jeanmarc petit farouk toumani discovering interesting inclusion dependencies application logical database tuning information systems v27 n1 p119 march 2002 junhu wang binary equality implication constraints normal forms data redundancy information processing letters v101 n1 p2025 january 2007 junhu wang binary equality implication constraints normal forms data redundancy information processing letters v101 n1 p2025 january 2007 laura c rivero jorge h doorn viviana e ferraggine elicitation conversion hidden objects restrictions database schema proceedings 2002 acm symposium applied computing march 1114 2002 madrid spain millist w vincent jixue liu chengfei liu strong functional dependencies application normal forms xml acm transactions database systems tods v29 n3 p445462 september 2004 marcelo arenas leonid libkin informationtheoretic approach normal forms relational xml data journal acm jacm v52 n2 p246283 march 2005 marcelo arenas leonid libkin informationtheoretic approach normal forms relational xml data proceedings twentysecond acm sigmodsigactsigart symposium principles database systems p1526 june 0911 2003 san diego california marcelo arenas normalization theory xml acm sigmod record v35 n4 december 2006 solmaz kolahi leonid libkin redundancy vs dependency preservation normalization informationtheoretic study 3nf proceedings twentyfifth acm sigmodsigactsigart symposium principles database systems june 2628 2006 chicago il usa mark levene george loizou snowflake schema good data warehouse design information systems v28 n3 p225240 may
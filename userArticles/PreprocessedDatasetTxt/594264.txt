efficient algorithms detect restore minimality extension regular restriction resolution given binary resolution proof represented binary tree said iminimal resolutions cannot reordered generate irregular proof minimality extends tseitins regularity restriction still retains completeness lineartime algorithm introduced decide whether given proof minimal algorithm used deduction system avoids redundancy retaining minimal proofs thus lessens reliance subsumption general expensive techniqueany irregular binary resolution tree made strictly smaller operation called isurgery runs time linear size tree surgery result proved new tree nonstrictly general original result fewer violations regular restriction furthermore nonminimal tree made irregular linear time operation called isplay thus combination splaying surgery efficiently reduces nonminimal tree minimal onefinally close correspondence clause trees recently introduced authors binary resolution trees established sense work provides first lineartime algorithms detect minimality perform surgery clause trees b introduction regular restriction binary resolution 14 states resolution step resolving given literal used deduce clause containing literal words resolution step ancestor clause binary derivation tree extend restriction applies also reordering resolutions brings clause step use rotations edges binary tree reorder resolution steps require rotations neither weaken proved increase size tree binary resolution proof cannot made irregular rotations call minimal extension regularity depends sequences rotations thus appears expensive compute however characterize condition checked efficiently examining static tree condition stated terms history paths binary resolution tree history path tells story given literal tail history path leaf tree tells literal introduced input clause history path said close node literal resolved away one history path closes node occurs another history path two paths disjoint say first history path directly precedes precedes relation history paths reflexive transitive closure directly precedes history paths precedes relation basic understanding binary resolution trees behave rotations performed provide simple conditions history paths characterize one node rotated another say visible one node cannot rotated another say supports examining history paths static tree decide much cannot accomplished sequences rotations particular say whether rotations convert regular tree irregular one theorem prover use ability screen proofs builds retain minimal ones since every clause nonminimal proof subsumed clause minimal proof theorem prover uses minimality lessen reliance sub sumption runtime full subsumption grows number retained clauses may become large detecting minimality depends linearly size proof tree typically much smaller instead using minimality simply filter theorem prover convert nonminimal proof minimal one using operations defined paper consider branch irregular derivation tree makes irregular branch contains node given literal resolved contains clause literal occurs resolve literal away reappear later remove resolution otherwise reconstruct branch closely possible original literal appearing additionally clauses constructed tree smaller result proves least general original one call operation surgery define second operation splay rearranges nonminimal tree irregular operations run time linear size tree combination operations eventually reduce nonminimal tree minimal one first section presents regular restriction binary resolution trees section introduce surgery operation irregular binary resolution trees minimal binary resolution trees introduced section also discusses rotations set rotation equivalent trees trees generated given tree sequence rotations following sec tion discuss precedes relation history paths use define holds relation nodes relate holds visibility showing nearest common descendant two given nodes holds one one seen ie cannot rotated based condition give efficient algorithm deciding visibility show theorem prover restricted retain minimal proofs disregard nonminimal ones decreasing number proofs must considered show splay operation efficiently converting nonminimal proof irregular one surgery convert minimal one thus another theorem prover efficiently convert nonminimal results minimal ones desired next section use history paths characterize support condition one node binary resolution tree must descendant another sequence rotations minimality surgery first developed clause trees 5 clause tree tool developing ideas automated reasoning binary resolution tree efficient compact data structure implement clause trees second last section show close relation binary resolution trees clause trees thus paper provides first efficient algorithm surgery clause trees close remarks relation clause trees binary resolution trees related work paper extension 13 2 binary resolution trees use standard definitions 2 atom literal substitution unifier general unifier following clause unordered disjunction literals use set notation want multiple occurrences literal collapse single literal automat ically thus clauses viewed multisets atom occurs clause c either one disjuncts clause clause c subsumes clause exists substitution c sets multisets variable renaming substitution one every replacement variable maps another variable two variables map variable two clauses c equal variable renaming exists variable renaming substitution two clauses standardized apart variable occurs given two parent clauses standardized apart variable renaming substitution may required resolvent clause c 1 c 2 general unifier g atom resolved upon 1 set resolved literals g convenient define mapping ae literals resolution operation used later define history paths resolution mapping resolution operation define resolution mapping ae occurrence literal c parent clause either atom resolved upon c resolved literal otherwise occurrence c resolvent reader may missing usual factoring operation clause consists applying substitution unifies two literals sign removing one literals operation needed binary resolution trees however since clause contains two identical unifiable literals resolved upon whenever clause used resolution allowing several literals resolved instead merging resolu tion one type internal node binary resolution tree instead two de nivelle uses resolution nodes factorization nodes 3 moreover implementation free merge factor literals desired factoring may seen optimization factored clause used several resolution steps since factoring done binary resolution derivation commonly represented binary tree drawn root bottom edge joins parent node drawn edge child node drawn ancestors descendants node defined reflexive transitive closure parent child relation proper ancestors proper descendants node ancestors descendants equal node h nodes tree patht h unique path h called tail h head definition 2 binary resolution tree set input clauses labeled binary tree node n tree labeled clause label denoted cln node either two parents clause label result resolution operation clause labels parents parents labeled instance input clause case resolution atom resolved upon used another label node atom label denoted aln substitution generated resolution applied labels tree clause label root binary resolution tree called result tree resultt binary resolution tree closed result empty clause 2 ad abde dbce ebcfg ca bbfg bbfg bfg abe cd efg abc ha b g ah h figure 1 irregular binary resolution tree binary resolution tree figure 1 gg labels node n displayed beside name node separated colon eg node n 4 atom label c clause label b b f g order parents node defined instead labelling internal nodes atoms one labels edge complement literal resolved upon binary resolution tree would become semantic tree leaves binary resolution tree would become failure nodes semantic tree using resolution mapping ae resolution operation tree trace happens literal occurrence clause label leaf tree resolved away clearly literals eventually mapped atom label internal node clause label root empty case soundness resolution clause labels leaves b ad dac caab ab cd abc b ah h figure 2 surgery operation 5 figure 1 unsatisfiable set thus primarily concerned tracing history literal starting appearance leaf definition 3 history path let nodes n occur binary resolution tree n 0 leaf whose clause label contains literal parent n let ae resolution mapping parents n n let occur cln suppose n n either root child n ae mapped resolution n atom resolved upon n n history path history path said close n n exists n written closep node n n head leaf n 0 tail literal p written headp tailp literalp respectively example figure 1 c closes n 4 two history paths b figure 1 corresponding two occurrences b 3 close n 6 close one f definition 4 regular binary resolution tree regular exist node n descendant n aln occurs clm tree figure 1 irregular aln 1 occurs cln 4 irregular trees never necessary resolve away twice one could choose leave resolution n 1 leaving clause resolutions necessary necessary later resolve away done n 5 operation 5 makes idea formal new binary resolution tree 0 constructed 0 ancestors possibly removed however leaves 0 also leaves thus every history path 0 corresponding history path converse cannot true since history paths 0 exist 0 new sequence n 0 n defined either n 0 removed n 0 corresponds n operation 5 surgery irregular trees let irregular binary resolution tree path nodes n 1 root n n first node path whose clause label contains let n igamma1 igamma1 parents n parents occurs clause label n 0 sign cln procedure ancestors n 0 0 0 ancestors removed let n k node history path p n j closes k exists history path 0 containing n 0 corresponding history path closes n put igamma1 ancestors 0 new node 0 child n 0 let resolution n 0 defined history paths close n 0 correspond history paths close let history path corresponding p also close n 0 k literals far possible resolved n 0 n one possible addition else history path containing n 0 corresponds path closes n igamma1 ancestors removed endif endfor note occurrence n j never resolved away ie history path continues root two literals corresponding may occur root 0 however least general figure 2 shows effect surgery figure 1 surgery performed using n 4 n j needed 0 insisting occurrences closed node ensure result thus n 0 5 closes history paths n 0 theorem 6 let irregular binary resolution tree set clauses 0 constructed operation 5 0 also binary resolution tree 0 smaller result 0 subsumes result proof use following lemma clauses c 1 c resolve give clause c 2 subsumes c 1 either resolution c 2 c possible c 2 subsumes r 1 possible result assumes literals c resolved first resolution also resolved second furthermore literals c 2 resolved second resolution correspond subsumption literals c 1 resolved first resolution leaf 0 label leaf therefore 0 defined also internal node defined resolution parents 0 binary resolution tree note cln 0 subsumes cln 1 cln 1 contains literals cln 0 except possibly using repeated applications lemma follows cln 0 cln j since occurs cln j cln 0 result 0 subsumes since 0 0 since nodes 0 taken follows 0 fewer nodes 2 theorem 7 completeness 14 unsatisfiable exists closed regular binary resolution tree furthermore smallest closed binary resolution tree regular proof unsatisfiable exists closed binary resolution tree 11 irregular apply operation 5 repeatedly regular process must terminate since tree smaller step smallest closed binary resolution tree regular surgery applied making smaller closed tree 2 figure 3 binary tree rotation 3 minimal binary resolution trees rotation edge binary tree common operation example avl trees 1 apply binary resolution trees review operation binary trees given binary tree fragment left figure 3 rotation reassignment edges tree right figure 3 produced parent c becomes child e parent b c becomes parent e e child c takes child 0 words edges b c c e e f exists replaced edges b e e c c f necessary operation 8 edge rotation let binary resolution tree edge c e internal nodes c parent e c two parents b suppose history path closes e result rotation edge binary resolution tree 0 defined resolving clb cld ale giving cle 0 resolving cle cla alc giving clc 0 history path closed c closed c similarly history path closed e closed e 0 also child e exists child c 0 rotation may introduce tautologies clause labels internal nodes instance alc occurs cld cle 0 may tautological however clause label root changed corollary 11 prove slightly general result first also used later definition 9 let 1 2 two binary resolution trees defined set input clauses 1 2 close history paths similarly onetoone onto mapping nodes 1 2 1 n leaf n leaf labeled instances input clause thus natural one one cor respondence literals cln cln moreover mapping literals provides mapping history paths 1 2 defined start literal input clause variable renaming represent two mappings also require history paths p 1 tailp variable renaming 2 every history path p 1 p closes node n closes n thus two binary resolution trees close history paths similarly resolve literals albeit possibly different order lemma 10 two binary resolution trees 1 2 close history paths similarly result 1 result 2 variable renaming proof note resultt 1 resultt 2 composed entirely literals history paths close since history paths closed literals resolved away also composition mgus 1 2 unique variable renaming since given node n literals unified n n variable renaming 2 corollary 11 given binary resolution tree internal node c child e operation 8 generates new binary resolution tree cle variable renaming proof observe operation 8 produces tree closes history paths similarly 2 rotation changes order two resolutions tree rotations invertible rotation history path closes c another rotation e c done generates original tree say two binary resolution trees rotation equivalent one generated sequence rotations instance first binary resolution tree figure 4 produced rotating edge n 4 n 5 figure 1 second tree figure 4 figure 1 rotate figure 4 produced rotating edge 4 n 5 thus trees rotation equivalent figure 1 rotation equivalent equivalence relation surprising rotation equivalent binary resolution trees must close history paths similarly converse true well theorem 12 two binary resolution trees 1 2 rotation equivalent close history paths similarly proof since one rotation 1 creates binary resolution tree closes history paths similarly sequence rotations creating 2 converse proved induction number internal nodes suppose 1 2 close history paths similarly must number n internal nodes since number leaves rotation possible theorem holds let n node 1 parents l 1 l 2 leaves 2 n proper ancestors l 1 l 2 also leaves n closes history paths tails l 1 l 2 create 0 2 rotating edges l 1 l 2 parents n already case let c either parent n let b parents c l 1 l 2 ancestors c neither ancestor parent n n must close history path parent contradiction thus edge c n rotated since b contain history path closing n rotation reduces total number nonleaf ancestors n finite number rotations parents n leaves call tree 0 let 1 1 leaves l 1 l 2 deleted let 2 0 2 leaves close history paths similarly since 1 0 close history paths similarly induction rotation equivalent sequence rotations convert 1 also convert 1 0 2 rotation equivalent 2 focus set rotation equivalent trees contain irregular binary resolution tree tree set said minimal since surgery cannot applied make smaller definition 13 binary resolution tree minimal sequence rotations edges generates tree 0 irregular theorem 14 binary resolution tree nonminimal exists minimal binary resolution tree 0 smaller result 0 subsumes result proof minimal apply operation 8 operation 5 regular tree produced tree minimal let 0 tree otherwise repeat beginning 0 defined process must terminate tree getting smaller application operation 5 also old result subsumed new result step 2 thus smallest binary resolution tree minimal goerdt shown 4 smallest regular binary resolution directed acyclic graph dag may exponentially larger irregular binary resolution dag thus considering regular minimal binary resolution dags theorem prover may find smallest proof hence may require inferences prove given theorem however cases believe space minimal binary resolution dags much smaller space binary resolution dags considerable time saved restricting minimal ones similar arguments made restrictions resolution including setofsupport hyperresolution 4 checking minimality determining whether given binary resolution tree minimal seems labourious since straightforward application definition done proof theorem 14 checks every possible sequence rotations exponentially many section give efficient algorithm determining visibility nodes rotated deciding minimality efficient definition 15 visible given binary resolution tree internal nodes n say visible n n see exists sequence rotations descendant n otherwise invisible n thus node see nodes rotated although property defined terms rotations possible inspect static tree without rotations determine visibility visibility computed linear time static property holds defined one concept precedes definition directly precedes history path q p q nodes common p closes node q write p oe q moreover say p precedes q sequence history paths p directly precedes p i1 history path p precedes node n n closes history path q p oe q precedes relation reflexive transitive closure directly precedes particular history path precedes even though directly precede also note precedes defines partial order set history paths cases rotation change precedes relation history paths lemma 17 let history path p precede history path q binary resolution tree let p images respectively rotation edge c e definition 8 suppose head q c p 0 precedes q 0 proof let td subtrees rooted b c respectively closep headq one subtrees rotation effect whether p q know headq proper descendant closep also headq c headq must descendant e tailp tailq subtree rotation affect p oe q node q p precedes also subtree let p 1 path closing node thus p oe p 1 oe q cases illustrated figure 5 1 tailq tailp closes c rotation 1 one node longer closes c 0 p 0 oe otherwise tailp td let p 0 denote path b closing c rotation p 0 oe p 0 2 tailq tb tailp rotation p 0 oe otherwise tailp td rotation p 0 oe p 0 3 tailq td since path closes e know tailp thus tailp tb rotation directly hold internal node binary resolution tree first node occurs p 1 q 1 ie parent occur say p q hold exist history paths p 1 directly hold node n holds p q hold p q close n also p q hold set history paths say set holds following theorem relates invisible property depends rotation equivalent trees held property checked examining one tree interest figure 5 cases lemma 17 theorem 19 nearest common descendant n holds invisible n proof show nearest common descendant holds rotation possibly new nearest common descendant n holds thus never descendant n nearest common descendant would node cannot hold cases proof forward direction figure 6 let f nearest common descendant n let rotated edge c e let nodes b adjacent defined operation 8 let p q hold close f p 1 directly hold p 1 oe p q 1 oe q consider case f 6 e rotation f still nearest common descendant n lemma 17 p 0 suppose 6 e rotation still first common node p 0 1 f still holds suppose without loss generality assume p 1 contains c q 1 contains case 1a p 1 contains b rotation p 0 hold e f holds case 1b p 1 contains consider path closing c rotation p 0 p 0 hold e f holds suppose consider case case 2 ancestor c n either e ancestor since history path contain c close e 6 c reason p q contain b close e case 2a ancestor paths directly precede p q close c hold thus c holds rotation nearest common descendant n c c still holds case 2b otherwise ancestor b rotation nearest common descendant n e e still holds finally consider case case ancestor case 3a n either e ancestor b rotation holds still nearest common descendant n case 3b n c ancestor consider path r head b closes c rotation nearest common descendant n c r 0 directly precedes rotation conversely suppose held nearest common descendant f n descendant n therefore visible f child edge rotated making descendant f therefore n assume exists path n case 3a case r r q q q case case 1a case r r case 2a figure 6 cases theorem 19 n igamma1 k igamma1 parents n use induction n without loss generality n 0 chosen aln 2 occurs cln 0 thus history path n 0 closes n 2 exists ng history path n igamma2 closes n edge n rotated shown rotation 1 figure 7 say n rotated side pathm f closer f theorem holds induction thus path n igamma2 closes n j ng n j held f particular n ngamma1 held edge n rotated distance nearest common descendant n theorem holds induction choose smallest j ng n j held f note j 6 1 assumption history path k j gamma2 closing n j path path n j gamma2 closing n j directly hold thus held f contradicting definition j therefore path k j gamma2 exists edge rotated illustrated rotation 2 figure 7 closer f rotation say n j rotated top pathm f theorem holds induction otherwise consider history paths n j gamma2 closing n j one includes another includes k j gamma3 n j gamma2 held f rotation means n j gamma2 held f rotation contradicting definition j thus edge n j gamma2 n j rotated result rotation n j rotated either side pathm f closer second induction distance n j n eventually rotated top side thus distance f decrease constructed sequence rotations 2 sequence rotations constructed proof theorem 19 rotates visible node node n see thus tree regular nonminimal rotations would make irregular exposing nonminimal parts using surgery remove nonminimal sections tree reconstruct minimal tree pieces left behind unfortunately number rotations required expose non minimality may quadratic length path tree since trees balanced quadratic size tree worst case later give linear time operation called splaying bring visible node descendant next section however detect avoid nonminimal trees rotation 1 side f f rotation 2 top f f figure 7 rotations proof theorem 19 5 minimality restriction turn attention theorem prover keeps minimal binary resolution trees since every nonminimal tree subsumed minimal tree strategy uses minimal criteria reduce redundancy lessening reliance subsumption definition 20 let binary resolution tree atomst falnjn node tgis called set atoms subbrt binary resolution tree whose node set consists node called root subbrt ancestors subbrt 0 node 0 visible root tg called set visible atoms 0 theorem 21 let binary resolution tree consist root node r two subbrts 1 2 minimal 1 1 2 minimal 2 atom clr atomst 3 4 proof assume minimal 1 2 minimal would sequence edgerotations would make subbrt irregular sequence performed would make irregular well hence first condition true second condition false would irregular immediately assume third condition false two nodes whose atom labels visible r hence rotated r without rotating edges 2 descendant n making irregular fourth condition symmetric third conversely assume minimal sequence rotations create irregular tree 0 node n descendant 1 0 aln occurs clm 1 since rotations change clr aln occurs result 0 occurs clr violates second condition thus aln occur clr descendant n n violates first condition assume n different since rotated visible n theorem 19 held nearest common descendant r n thus visible r therefore alm vist aln atomst 3gammai 2 theorem prover based binary resolution keeps minimal trees already satisfied first condition theorem 21 newly constructed tree since minimal trees used construction easy check new result contain atom atomst left find easy way calculate atoms subbrt visible root idea procedure 22 node visible subbrt held root theorem 19 node n need calculate history paths going precede root paths go one parent n go n held root otherwise n visible root procedure call visiblen pn first argument n node tree want know whether held root initially one parents root traverse upward becomes instantiated ancestor parent invariant maintain second argument pn set paths include n precede root paths parent root precede root simply whose heads parent invariant easy establish first place suppose n parents b calculate paths pb b precede root start pn remove paths go none pb pn path pn need add pb path head b since paths precede path thus precede root since know paths pn must go least one parents n assume b parent procedure 22 visible given node n binary resolution tree set pn history paths precede root tree visn pn returns atoms labels nodes n visible root procedure visn pn n leaf return oe let b parents n partition pn pa pb sets paths go b respectively assume without loss generality b chosen pb nonempty let ca cb history paths head b respectively pa nonempty n held return else n held visible return endif third fourth conditions theorem 21 require us calculate done calling visr root binary resolution tree r 1 r 2 parents r r set paths heads r procedure 22 runs number set union calculations proportional number nodes tree hashing operations principle performed time proportional size clauses hence vis linear time algorithm fast one could expect implemented prototype theorem prover propositional logic resembles otter9 retains minimal binary resolution trees recursive calls first condition theorem 21 needed whereas proofs built otter correspond nonminimal trees cases implementation actually builds binary resolution dags instead trees save space important bottomup theorem provers limited space well time note procedure 22 traverses entire implicit tree may visit single stored node thus runtime guaranteed linear size dag prototype includes another restriction discussed 6 ensures set rotation equivalent binary resolution trees exactly one found 6 restoring minimality two basic ways restore minimality binary resolution tree irregular surgery operation remove non minimality binary resolution tree regular nonminimal rotations need done make irregular call exposing nonminimality irregularity involves two internal nodes n resolve upon atom neither descendant least one visible suppose visible n rotated n one parent becomes descendant n since occurs parents clause label surgery n done proof converse theorem 19 gave quadratic length sequence operations moving visible nodes become descendants operation 24 called splaying performs linear number rotations related splay operation 12 binary trees brings node closer root case splay binary resolution tree divide descendants two sets observers see nonobservers cannot rearrange tree nodes ancestors leaving nodes descendants thus brought close root possible done way guarantees n ancestor surgery accomplished first step splay determine descendants see computed procedure 23 procedure 23 obs given node binary resolution tree p 1 complete set history paths containing one parent p 2 paths containing returns set proper descendants see called observers procedure obsm root return oe else let child k parent let c 1 paths p 1 close c 2 paths p 2 close let k paths contain k holds return else c return fdg obsd k else endif endif invariant procedure 23 every pair paths one p 1 p 2 holds ever find descendant closes member holds cannot see otherwise see maintain invariant go closes paths p need add p paths k come k one paths precedes path contains close path p nothing add p either case remove p path closes since contain operation 24 uses code procedure 23 procedure decide resolutions reordered new tree parents 1 2 considered stubs built upon observers put one two queues q 1 q 2 nonobservers put q 3 along node put queue also put subtree rooted parent node resolution reconstructed later put q 1 become descendants 1 q 2 become descendants 2 done two subtrees joined resolution corresponding finally nodes q 3 made descendants resolutions done history paths closed node given tree closed node constructed tree thus resulting tree closes history paths similarly given tree operation 24 splay splay internal node binary resolution tree produces new binary resolution tree 0 descendants cannot see 0 operation initially three empty queues initially p 1 set history paths one parent 1 p 2 set history paths parent 2 call splay1m return processq procedure splay1m root return else let child let k parent let c 1 paths p 1 close c 2 paths p 2 close let k paths contain k holds enqueue subtree rooted k q 3 else c enqueue subtree rooted k else enqueue subtree rooted k endif endif resolutions must done resulting binary resolution tree closes history paths similary procedure processqt q q empty return else dequeue 1 n q leaving q 1 construct 2 resolving 1 making parents n return endif example binary resolution tree figure 8 shows result performing splay node n 5 second tree figure 4 subtrees 1 2 leaves labelled b c h respectively descendants n 5 4 n 3 n 4 put q 1 4 put q 2 end n 5 resulting tree nonobserver n 6 put q 3 ends n 5 lemma 25 binary resolution tree internal node result 0 splayt binary resolution tree 0 defined set clauses size result proof 0 closes history paths similarly 2 operation 26 splay surgery let binary resolution tree containing pair mn nodes alm aln n see procedure descendant n return surgeryn else return endif see splay actually brings n surgery possible suppose nearest common descendant n thus either n nearest common descendant n different branches n either ancestor k point splay1 also know n see must put one queues q 1 q 2 cannot part q 3 thus tree ad abde dbce ebcfg abe cd efg abc bbf b g bbf g ca bbfg ha ah figure 8 result operation 24 n5 figure 4 rebuilt n put processing either q 1 q 2 put q 1 q 2 empty n returning example splay node n 5 figure 8 n 1 surgery n 1 done result surgery shown figure 2 notice example also option splay n 1 surgery n 5 since n 1 also visible n 5 resulting tree would different would require leaf h h result would f thus surgery always produce general result always produces smaller tree splay surgery linear number set operations since n resolution steps n length branch performs surgery number resolutions limited length branch thus effectively linear time algorithm 7 support often node visible another rotated descendant sometimes sequence rotations bring node another case say node supports since always beneath support like visibity property depends entire set rotation equivalent trees section characterize support terms history paths checked examining static tree definition 27 support node n binary resolution tree supports node every sequence rotations ancestor n definition 28 tightly holds two history paths tightly hold node n exist two sequences history paths directly holds pair head p equal head q j node n tightly holds p q close n tightly holds special case holds two paths sequences head except bottom two turns exact condition one node another every sequence rotations theorem 29 node n tightly holds n supports proof show n tightly holds rotation also afterwards thus must descendant consider rotation edge c e nodes b c e defined definition 8 indicate image history path p rotation p 0 first assume fc eg disjoint fmng rotation heads paths sequences distinct must distinct rotation unless new path either sequences one case new path occurs lemma 17 new path introduced tailq case head new history path pathm n thus heads paths new sequences p 0 distinct except headp 0 also still directly held 1 n tightly holds suppose fc eg disjoint fmng case 1 without loss generality let p 1 contain q 1 contain b know p 1 close e since rotation possible suppose first q 1 close e figure 91a rotation c directly held p 0 1 tightly held n suppose q 1 closes e figure 91b note must exist q 2 since otherwise e holds n q 1 p 1 close rotation possible cn qm pn qn case 2b case 3a case case 1a case 1b cn pm qn qn case 2a figure 9 cases showing tightly hold invariant rotations case 1 case 2 figure 10 cases showing support implies tightly holds rotation c directly held p 0 2 still tightly held n case close n either include figure 92a include b figure 92b either case rotation n tightly holds sequences p 0 case assume without loss generality c p 1 q 1 also p 1 figure 93a path head b p 0 oe p 1 rotation sequences ensure n tightly holds b p 1 figure 93b rotation paths p 0 q 0 tightly holds case finally either pm q n contain c contain contain c note contain parent b c else rotation possible rotation b parent e although p 0 one node shorter n tightly holds paths p 0 contain rotation change history paths thus n tightly holds induct length pathm parent n i1 1 parent n rotation edge n possible unless exist history paths tightly hold close n suppose k 2 first assume case 1 n k support first half theorem n k tightly hold edge n rotated since must remain ancestor n must ancestor b rotation shown figure 101 thus path n shorter induction tightly holds new binary resolution tree rotating edge back one sees n tightly holds tightly holds invariant rotation case covered assume n k supports n kgamma1 next assume case 2 n k support n kgamma2 n support n kgamma2 otherwise n k supports n kgamma1 supports n kgamma2 transitivity support contradiction first half theorem may rotate edge n kgamma2 n kgamma1 may rotate edge n kgamma2 n k since n k tightly hold n kgamma2 second rotation n k must remain descendant n kgamma1 must shown third binary resolution tree figure 102 thus pathm n shorter induction n tightly holds tightly holds invariant rotation n tightly holds also assume n k supports n kgamma2 similar arguments assume n k supports n case edge n 2 rotated pathm n shorter resulting tree 0 induction n tightly holds 0 since tightly holds invariant rotation n tightly holds finally edge n 2 cannot rotated paths parent closing n 2 know induction tightly holds n 2 assume p paths make assume without loss generality includes q 1 must include parent n 2 since n 2 first node p 1 q 1 common matter parent p 1 path closing n 2 containing parent call path q 0 since head q 0 distinct heads p q j sequences thus tightly holds paths q final theorem relate notions visibility support theorem 30 binary resolution tree node invisible node n iff support pathm n proof let nearest common descendant n consider path sequences holds consider least j headp let node p q j close j must exist since headpm heads paths distinct tightly holds thus supports sequences paths tightly holds since pathm n descendant must ancestor nearest common descendant n thus paths r r 1 r k closes thus holds via sequences 8 relation clause trees results paper developed understood clause trees 5 primarily means implement clause trees eventually found ideas clause trees could expressed binary resolution trees binary resolution trees simpler ways since easier implement often clause trees easier use exploring new ideas particular visibility support read almost directly clause tree whereas properties held tightly held somewhat harder see binary resolution trees use whichever appropriate section relate two refering example rotation equivalent binary resolution trees figures 1 4 8 correspond first clause tree figure 11 binary resolution tree figure 2 corresponds second clause tree figure 11 reader familiar clause trees note second clause tree figure 11 constructed directly first adding merge path atom nodes surgery remove subtree beyond tail new merge path correspondences binary resolution trees clause trees obvious leaves binary resolution tree clause nodes clause tree labeled instance input clause internal nodes binary resolution tree atom nodes clause tree history path binary resolution tree associate literal corresponds labeled edge clause tree also associated literal history path closed corresponds edge incident atom node leaf closed history path corresponds edge incident closed atom node c e f c figure 11 clause trees corresponding figures 1 4 8 figure 2 minimal clause trees correspond minimal binary resolution trees whose result contain two identical atoms minimal condition clause trees allow legal unchosen merge path legal tautology path including leaf leaf paths minimal binary resolution tree may correspond clause tree legal unchosen leaf leaf merge path legal leaf leaf tautology path regularity condition binary resolution trees requires one nodes internal finally visibility resp support internal nodes binary resolution tree correspond visibility resp support closed atom nodes clause tree table shows number corresponding notions table corresponding notions clause trees binary resolution trees clause node leaf node internal atom node internal node edge history path open leaf atom node literal result clt internaltointernal surgery splay surgery internaltoleaf surgery surgery merge path two history paths closing together equivalence classes reversal equivalent equivalence classes rotation equivalent minimal leaftoleaf minimal visible internal atom nodes visible support internal atom nodes support path reversal structural change structural change rotation change derivation merge set history paths closing given node 9 related past future work regularity one important restrictions form used many theorem proving methods related resolution including tableau 10 variants model elimination8 permuting inference steps investigated kleene 7 context gentzens sequence calculus classical intuitionistic kleenes permutations sometimes increase size proof interesting note defines ancestor relation instances formulas inference allowing state instances formulas deduction belong given instance end sequent analagous notion history paths context binary resolution derivations de nivelle 3 two types nodes resolution nodes two parents factoring nodes one defines four types edge rotations depending type nodes incident edge disallow rotation factorization node parent resolution node case size derivation must increased application construct resolution games used show various completeness results restrictions resolution based ordering literals de nivelles paper show basic properties resolution may exposed considering set trees equivalent modulo permutations main contribution paper present minimal restriction resolution originally developed terms clause trees using well known proof format binary resolution derivations original motivation implement bottom algorithms constructing minimal clause trees direct implementation based structural definition clause trees done new tree needed storage space visibility algorithm cumber remedy problems used notion binary resolution derivations implemented new clause tree single storage cell two parent clause trees propositional logic solves space problem since tree used part trees surprising result visibility expressed easi ly requires linear algorithm using data structure determined explain much clause tree work could using binary resolution trees make accessible readers familiar resolution task turned difficult discovered edge rotations history paths precedes relation history paths fundamental concepts needed related visibility support history paths using holds tightly holds relations retrospect authors still believe easier work conceptually clause trees anecdotal evi dence graduate course automated reasoning given two times second author clause trees binary resolution trees followed clause trees intuitions support visibility quite understandable using either data structure presently developing full theorem provers described one use minimality restriction another use splay surgery improve proofs constructed resolution redundancy elimination subsumption always important consideration theorem provers unfortunately minimal restriction complete full subsumption instance one refute minimal binary resolution tree one resolves p pq generating q uses back subsumption remove resolution p q p q done latter resolution part minimal binary resolution refutation clauses former resolution step leads binary resolution tree p resolved two different nodes one branch however discovered 6 one retain completeness giving power minimality without giving power subsumption space minimal binary resolution trees interesting following reasons 1 refutationally complete 2 extends well known regularity restriction resolution 3 contains smallest binary resolution tree 4 nonminimal subtrees identified time linear size tree 5 nonminimal trees reduced minimal ones efficiently r algorithm organizaton information symbolic logic mechanical theorem proving resolution games nonliftable resolution orderings regular resolution versus unrestricted resolution clause trees tool understanding implementing resolution automated reasoning bottom procedures construct minimal clause tree permutability inferences mechanical theorem proving model elimination otter 30 users guide machineoriented logic based resolution principle extending regular restriction resolution nonlinear subdeductions complexity derivation propositional calculus tr
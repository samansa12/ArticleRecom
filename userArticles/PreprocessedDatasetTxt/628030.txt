data consistency intermittently connected distributed systems abstractmobile computing introduces new form distributed computation communication often intermittent lowbandwidth expensive thus providing weak connectivity paper present replication scheme tailored environments bounded inconsistency defined allowing controlled deviation among copies located weakly connected sites dual database interface proposed addition read write operations usual semantics supports weak read write operations contrast usual read write operations read consistent values perform permanent updates weak operations access local potentially inconsistent copies perform updates conditionally committed exploiting weak operations supports disconnected operation since mobile clients employ continue operate even disconnected extended database interface coupled bounded inconsistency offers flexible mechanism adapting replica consistency networking conditions appropriately balancing use weak normal operations adjusting degree divergence among copies provides additional support adaptivity present transactionoriented correctness criteria proposed schemes introduce corresponding serializabilitybased methods outline protocols implementation practical examples applicability provided performance scheme evaluated range networking conditions varying percentages weak transactions using analytical model developed purpose b introduction advances telecommunications development portable computers provided wireless communications permit users actively participate distributed computing even relocating one support environment another resulting distributed environment subject restrictions imposed nature networking environment provides varying intermittent weak connectivity particular mobile clients encounter wide variations connectivity ranging high bandwidth low latency communications wired networks total lack connectivity 7 11 23 two extremes connectivity frequently provided wireless networks characterized low bandwidth high latency high cost overcome availability latency barriers reduce cost power consumption mobile clients often deliberately avoid use network thus operate switching connected disconnected modes opera tion support behavior disconnected operation ability operate disconnected essential mobile clients 11 12 26 addition disconnected operation operation exploits weak connectivity connectivity provided intermittent lowbandwidth expensive networks also desirable 18 9 besides mobile computing weak intermittent connectivity also applies computing using portable laptops paradigm clients operate disconnected time connect occasionally wired telephone line upon returning back working environment private corporate databases stored mobile well static hosts mobile users query update databases wired wireless networks databases reasons reliability performance cost distributed replicated many sites paper propose replication schema supports weak connectivity disconnected operation balancing network availability consistency guarantees proposed schema data located strongly connected sites grouped together form clusters mutual consistency required copies located cluster degrees inconsistency tolerated copies different clusters interface offered database management system enhanced operations providing weaker consistency guarantees operations allow access locally ie cluster available data weak reads access bounded inconsistent copies weak writes make conditional updates usual operations called strict also supported offer access consistent data perform permanent updates schema supports disconnected operation since users operate even disconnected using weak operations cases weak connectivity balanced use weak strict operations provides better bandwidth utilization latency cost cases strong connectivity using strict operations makes schema reduce usual onecopy semantics additional support adaptability possible tuning degree inconsistency among copies based networking conditions sense weak operations offer form applicationaware adaptation 19 applicationaware adaptation characterizes design space two extremes ways providing adapt ability one extreme adaptivity entirely responsibility application system support standard way providing adaptivity extreme adaptivity subsumed system database management system since general system aware application semantics cannot provide single adequate form adaptation weak strict operations lie intermediate point two extremes serving middleware database system application tools offered database system applications application discretion use weak strict transactions based semantics implementation consistency control underlying transactional support job database management system remainder paper organized follows section 2 introduce replication model along outline possible implementation based distinguishing data copies core quasi sections 3 4 define correctness criteria prove corresponding serializabilitybased theorems present protocols maintaining weak consistency concurrent execution weak strict transactions reconciling divergent copies respec tively examples schema used outlined section 5 section 6 develop analytical model evaluate performance schema interplay among various parameters model used demonstrate percentage weak transactions effectively tuned attain desired performance performance parameters considered system throughput number messages response time study performed range networking conditions different values bandwidth varying disconnection intervals section 7 provide estimation reconciliation cost estimation used instance determine appropriate frequency reconciliation events section 8 compare work related research conclude section 9 summarizing 2 consistency model support autonomous operation disconnections improve performance data distributed mobile stationary sites transactions initiated mobile stationary hosts 21 data correctness usually database state defined mapping every data item value domain data related number restrictions called integrity constraints express relationships among values database state consistent integrity constraints satisfied 20 consistency maintenance traditional distributed environments relies assumption sites normally connected assumption however longer valid mobile computing maximum number updates per data item reflected copies range acceptable values data item take maximum number transactions operate inconsistent data maximum number data items divergent copies maximum number divergent copies per data item table 1 divergence among copies since distributed sites intermittently connected similar considerations also hold widely distributed systems computing using portable laptops thus instead requiring maintenance integrity constraints define units consistency called clusters data items partitioned clusters cl based location data strongly connected sites belong cluster particular data located neighbor strongly connected sites belong cluster data residing remote weakly connected sites belong separate clusters example let mobile host cluster fixed hosts belong cluster configurations also possible instance wide area distributed environment hosts nearby locations constitute one cluster relax consistency follows cluster state consistent iff intracluster integrity constraints hold database state boundedconsistent iff cluster states consistent intercluster integrity constraints boundedconsistent bounding inconsistency integrity constraint depends type constraint paper focus replication constraints copies x data item x value replicated data bounded inconsistency means mutual consistency copies cluster bounded divergence 27 1 among copies located different clusters bounded divergence quantified positive integer called degree divergence possible definitions listed table 1 replication constraint x called consistent data copies occasionally reconciled obtain mutual consistent value degree divergence tuned based strength connection among clusters keeping divergence small instances high bandwidth availability allowing greater deviation instances low bandwidth availability 22 extended database operation interface increase availability reduce network usage allow direct access locally eg cluster available dconsistent copies introducing weak read weak write operations call standard read write operations strict read strict write operations particular read operation data item x wrx reads locally available value x weak write operation ww x writes locally available copies becomes permanent reconciliation strict read operation srx reads value written last strict write operation finally strict write operation sw x writes one copies x permanent upon end issuing transaction definition 2 transaction partial order op op set weak wr strict read sr weak ww strict write sw operations executed transaction represents execution order partial order must specify order conflicting data operations contains exactly one abort commit operation last order two weak strict data operations conflict access copy data item least one weak strict write operation two types transactions supported weak strict upon submission user transaction decomposed number weak strict subtransactions units according semantics degree consistency required application weak transaction wt transaction op include strict operations strict transaction st transaction op include weak operations weak transactions access data copies belong cluster thus local cluster two commit events associated weak transaction local commit associated cluster implicit global commit reconciliation local commitment expressed explicit commit operation c updates made locally committed weak transactions visible weak transactions cluster updates become permanent visible strict transactions reconciliation local transactions become globally committed 23 realizing extended database interface divide copies core quasi core copies copies uptodate permanent values quasi copies copies potentially obsolete values conditionally committed quasi copies cluster mutually consistent boundedinconsistent respect core copies core copies mutually consistent efficient distribution core quasi copies may accomplished using appropriate algorithms replica placement proposed 10 process operations transaction database management system translates operations data items operations copies data items formalize procedure translation function h function h maps read operation number read operations copies x returns one value eg date value value read read operation assume h applied read operation returns one value rather set values particular h maps srx operation number read operations core copies x returns one values value read operation depending weak read operation translated define two types translation functions besteffort translation function maps wrx operation number read operations locally available core quasi copies x returns uptodate value conservative translation function maps weak read number read operations core quasi local copies conservative variations eventual immediate corresponding clusters writes core copies reads local quasi copies variations writes core quasi copies reads local copies returns value read recent value reads core copies returns value read recent value writes local quasi copies strict read sr strict write sw weak read wr weak write ww table 2 variations translation function locally available quasi copies returns uptodate value based time propagation updates core copies quasi define two types translation functions eventual translation function maps sw x writes core copies immediate translation function updates well quasi copies corresponding cluster immediate h conservative besteffort result ww x operation translated h number write operations local quasi copies x table 2 summarizes semantics operations many core quasi copies actually read written database operation issued data item depends coherency algorithm used eg quorum consensus rowa 3 without loss generality assume one quasi copy per cluster assumption easily lifted significant complication notation since quasi copies cluster value single copy regarded representative immediate translation consistency handle integrity constraints besides replication case immediate translation function h h defined integrity constraints quasi copies cluster violated following example example 1 simplicity consider one cluster assume two data items x related integrity constraint x consistent database state x gamma4 subscripts c q denote core quasi copies respectively consider transaction program program executed strict transaction sw x sry c get database state gamma4 integrity constraint quasi copies x violated 2 problem arises fact quasi copies updated current value core copy without taking consideration integrity constraints among similar problems occur refreshing individual copies cache 1 possible solutions include 1 time quasi copy updated result strict write quasi copies data related integrity constraint also updated either prior execution transaction update done following reconciliation procedure merging core quasi copies section 4 example core quasi copies x reconciled prior execution transaction producing instance database state 2 execution transaction would result database state x consistent 2 strict transaction updates quasi copy cluster read operations also mapped reads quasi copies cluster cases incompatibilities reconciliation procedure initiated similar result 3 updating quasi copies postponed deferring updates quasi copies result writes corresponding core copies log weak writes resulting strict writes kept scenario execution transaction results database state x consistent first two approaches force immediate reconciliation among copies third approach defers reconciliation preferable cases low connectivity among clusters 3 weak connectivity operation section provide serializabilitybased criteria graphbased tests locking protocol correct executions exploit weak connectivity use terms read write refer operations data copies operation subscript j denotes belongs transaction j subscript data copy identifies cluster complete intracluster schedule ias observation interleaved execution transactions given cluster configuration includes locally committed weak transactions globally committed strict transactions formally set transactions complete intracluster schedule ias pair op partial ordering relation 1 2 operations op k op l op k op l every operation hop k related every operation hop l 3 pairs conflicting operations related two operations conflict access copy one write operation 4 read operations read j x least one write k x write k x read 5 sw j x sr j x read j written j 2 cl x quasi copy h conservative quasi core copy h best effort condition 1 states transaction managers translate operation data item appropriate operations data copies condition 2 states intracluster schedule preserves ordering stipulated transaction condition 3 also records execution order conflicting operations condition 4 states transaction cannot read copy unless previously initialized condition 5 states transaction writes data item x reads x must write copy x subsequently reads finally condition 6 indicates strict transaction write translated write data copy cluster cl writes transaction may possibly read weak transaction must also write corresponding copies cluster cl condition necessary ensuring weak transactions see partial results strict transaction read operation data item x readsxfrom transaction reads ie returns value read copy x written transaction writes copy say transaction readsfrom relationship schedule 1 schedule 2 data item x readsxfrom j 1 readsxfrom j 2 given schedule projection strict transactions schedule obtained deleting weak operations projection cluster cl k schedule obtained deleting operations access cl k schedule onecopy serializable view equivalent serial onecopy schedule 3 31 correctness criterion correct concurrent execution weak strict transactions must maintain dconsistency among clusters strict consistency inside cluster definition 4 ias weak correctness intracluster schedule ias weakly correct iff 1 transactions consistent view ie constraints evaluated using data read valid 2 one copy serial schedule set strict transactions operations b strict transactions readsfrom relationship ias c set final writes core copies ias 3 maintains ddegree relationship among copies next discuss enforce first two conditions protocols bounding divergence among copies outlined end section following theorem defines correctness terms equivalence serial executions theorem 1 given dconsistency maintained intracluster schedule weakly correct projection strict transactions onecopy serializable projections cluster conflictequivalent serial schedule proof first condition definition correctness guaranteed strict transactions requirement onecopy serializability since strict transaction get view onecopy serial schedule read core copies weak transactions cluster condition provided requirement serializability projection schedule cluster given projection transaction cluster maintains consistency executed alone thus suffices prove projections maintain consistency trivially holds weak transactions since local cluster condition also holds strict transactions since strict transaction maintains dconsistency projection cluster also maintains dconsistency consequence condition 6 definition ias schedule finally one copy serializability projection strict transactions suffices guarantee 2b 2c since strict transactions read core copies weak transactions write core copies respectively 2 note intercluster constraints replication constraints among quasi copies data items different sites may violated weak transactions however unaffected violations since read local data although correctness criterion suffices ensure weak transaction gets consistent view suffice ensure weak transactions different clusters get view even absence intercluster constraints following example illustrative example 2 assume two clusters quasi core copies corresponding data items following two strict transactions st addition cluster cl 1 weak transaction cluster cl 2 weak transactions wt simplicity show transaction initializes data copies consider immediate best effort h execution transactions produces weakly correct schedule projection strict transactions equivalent 1sr schedule projection serializable projection thus weak correctness guarantee serial schedule equivalent intracluster schedule whole including weak strict transactions following stronger correctness criterion ensures weak transactions get consistent view obviously strong correctness implies weak correctness definition 5 ias strong correctness intracluster schedule strongly correct iff serial schedule 1 conflictequivalent 2 strict transactions readsfrom relationship b set final writes core copies one copy serial schedule lemma 1 intracluster schedule strongly correct conflictequivalent serial schedule projection strict transactions equivalent onecopy serial schedule 1c order transactions consistent order transactions 1c proof need prove 1c strict transactions readfrom final writes straightforward since strict transaction read data produced strict transactions core copies written strict transactions 2 since weak transactions directly conflict weak transactions clusters following equivalent statement lemma corollary 1 intracluster schedule strongly correct projection strict transactions equivalent onecopy serial schedule 1c projections cluster cl conflictequivalent serial schedule order transactions consistent order transactions 1c weak ias correctness used correctness criterion transaction managers cluster must synchronize projections cluster global control required synchronizing strict transactions therefore control messages necessary transaction managers different clusters synchronizing weak transactions proposed schema flexible coherency control method guarantees onecopy serializability eg quorum consensus primary copy used synchronizing core copies schema reduces onecopy serializability strict transactions used 32 serialization graph determine whether ias schedule correct modified serialization graph used call intracluster serialization graph iasg ias schedule construct iasg replicated data serialization graph sg built represent conflicts strict transactions sg 3 serialization graph augmented additional edges take account fact operations different copies data item may also cause conflicts acyclicity sg implies onecopy serializability corresponding schedule sg augmented additional edges represent conflicts weak transactions cluster conflicts weak strict transactions add edge two transactions edge called dependency edge represents fact transaction reads value produced another transaction precedence edge represents fact transaction reads value later changed another transaction easy see iasg edges weak transactions different clusters since weak transactions different clusters read different copies data item addition weak transaction cluster cl st strict transaction iasg graph induced ias may include following edges ffl dependency edge st wt ffl precedence edge wt st proof straightforward conflict relation since conflicts weak strict transactions due strict writes weak reads copy data item 2 theorem 2 let ias intracluster schedule ias acyclic iasg ias strongly correct proof graph acyclic subgraphs acyclic thus sg acyclic acyclicity sg implies onecopy serializability strict transactions since strict transactions read values written strict transactions let 1 2 n transactions ias thus nodes iasg since iasg acyclic topologically sorted let n topological sort edges iasg straightforward application serializability theorem 3 ias conflict equivalent serial schedule order consistent partial order induced topological sorting sg let 1c corresponding serial schedule thus order transactions consistent order transactions 1c 2 33 protocols serializability distinguish coherency concurrency control protocols coherency control ensures copies data item value must maintain property globally core locally quasi copies concurrency control ensures main tanance integrity constraints intracluster constraints coherency control assume generic quorumbased schema 3 strict transaction reads q r core copies writes q w core copies per strict read write operation values q r q w data item wr ww sr sw x x x wr ww sr sw x x x wr ww sr sw x x x wr ww sr sw x x x b x x c x x figure 1 lock compatibility matrices x entry indicates lock modes compatible eventual conservative h b eventual best effort c immediate conservative immediate best effort h x q r qw n n number available core copies x concurrency control use strict two phase locking transaction releases locks upon commitment 3 weak transactions release locks upon local commitment strict transactions upon global commitment four lock modes wr ww sr sw corresponding four data operations execution operation corresponding lock requested lock granted data copy locked incompatible lock mode figure 1 depicts compatibility locks various types translation functions presented demonstrate interference operations items differences compatibility stem fact operations access different kinds copies basic overhead imposed protocols performance weak transactions caused weak transactions cluster overhead small since weak transactions access slow network strict transactions block weak transaction access quasi copies interference limited controlled eg letting cases disconnections strict transactions access core copies weak quasi bounded inconsistency among copies cluster degree data item expresses divergence local quasi copy value core copy difference may result either globally uncommitted weak writes updates core copies yet reported cluster consequence degree may bounded either limiting number weak writes pending commitment controlling h function table 3 outline ways maintaining dconsistency different ways defining 4 consistency restoration schema execution number weak strict transactions core copies data item value quasi copies may many different values number clusters section first provide criteria characterizing correctness protocols reconciling different values copies describe protocol exact point reconciliation depends application requirements distributed system characteristics appropriately bound number weak transactions distribution weak transactions cluster must operate inconsistent data take copies data item bound number clusters divergent quasi per data item maximum number data items strict write modifies quasi copies disconnected clusters since way notifying cluster least updates canot ensured remote updates bound number data items quasi copies item reflected copies maximum number updates per data adjusted allow weak writes values inside acceptable range defined applicable method cluster case dynamic cluster reconfiguration maximum number transactions range acceptable values data item divergent copies maximum number divergent copies table 3 maintaining bounded inconsistency reconciliation may forced keep inconsistency inside required limits alternatively may initiated periodically demand upon occurrence specific events example values may reconciled network connection reestablished instance palmtop pluggedback stationary network mobile host enters cell provides good connectivity 41 correctness criterion approaches reconciling copies vary purely syntactic purely semantic ones 5 adopt purely syntactic applicationindependent approach correctness criterion based following principle core copy written strict transaction read value core copy value selected otherwise value quasi copy may chosen transactions wrote value selected may need undonecompensated redone may lead rollback weak transactions read values written transaction however transaction rollback limited never crosses boundaries cluster complete intercluster schedule ies models execution reconciliation global transaction become aware local writes ie local transaction become globally committed schedule must add additional conflicts weak strict operations definition 6 intercluster schedule intercluster schedule ies ies based intracluster schedule pair op 0 1 op 0 2 op op j ffl op 0 addition 3 pair weak write ww x strict read sr j x operations either ww 4 pair weak write ww x strict write sw j x operations either ww extend readsfrom relationship strict transactions follows strict read operation data item x readsxfrom transaction ies schedule reads copy x written copy quasi copy x transaction wrote quasi copy accept many weak writes possible without violating onecopy serializability strict transactions specifically weak write accepted violate extended readfrom relationship strict transactions definition 7 ies correctness intercluster schedule correct iff 1 based correct ias schedule ias 2 readsfrom relationship strict transactions readsfrom relation ias 42 serialization graph determine correct ies schedules define modified serialization graph call intercluster serialization graph iesg construct iesg augment serialization graph iasg underlying intracluster schedule force conflicts among weak strict transactions read different copies data item induce ffl first write order follows weak writes k strict writes copy item x either ffl strict read order follows strict transaction st j readsxfrom st ias weak transaction wt follows st add edge st j wt theorem 3 let ies ies schedule based ias schedule ias ies acyclic iesg ies correct proof clearly iesg graph acyclic corresponding graph ias acyclic since get iesg add edges iasg show graph acyclic readfrom relation strict transactions intercluster schedule ies underlying intracluster schedule ias assume st j readsxfrom st ias assume purposes contradiction st j readsxfrom weak transaction wt wt writes x ies since st also writes x either st b wt st case definition iesg get st j wt contradiction since st j readsxfrom wt case b wt st wt precedes st precedes st j contradicts assumption st j readsxfrom wt 2 cycles iesg rollback weak transaction wt cycle unroll exact transactions related dependency edge wt per data item final write core copy propagate value quasi copies else choose value quasi copy propagate value core quasi copies table 4 reconciliation steps 43 protocol get correct schedule need break potential cycles ies graph since construct iesg start acyclic graph add edges weak strict transaction always least one weak transaction cycle rollback weak transactions undoing transaction may result cascading aborts transactions read values written transaction transactions related dependency edge transaction undone since weak transactions write quasi copies cluster since transactions cluster read quasi copies get following lemma weak transactions cluster read values written weak transactions cluster lemma ensures weak transactions cluster affected weak transaction aborted resolve conflicts intercluster schedule practice fewer transactions ever need aborted particular need abort weak transactions whose output depends exact values data items read call transactions exact weak transactions exact since definition weak transactions transactions read local dconsistent data thus even value read produced transaction later aborted value inside acceptable range inconsistency probably sufficient guarantee correctness detecting cycles iesg hard difficulties raise fact transactions wrote data item edge direction thus resulting polygraphs 20 polynomial tests acyclicity possible made assumption transactions read data item writing get ies graph ias graph need ffl induce read order follows strict transaction st reads item written weak transaction wt add precedence edge sr wt table 4 outlines reconciliation steps proposed hybrid schema weak strict transactions coexist weak transactions let users process local data thus avoiding overhead long network accesses strict transactions need access network guarantee consistency updates weak reads provide users choice reading approximately accurate value datum particular cases total partial disconnections value appropriate variety applications require exact values applications include gathering information statistical purposes making highlevel decisions reasoning expert systems tolerate bounded uncertainty input data weak writes allow users update local data without confirming updates immediately update validation delayed till clusters connected delayed updates performed periods low network activity reduce demand peaks furthermore grouping together weak updates transmitting block rather one time improve bandwidth usage example salesperson locally update many data items till updates finally confirmed machine plugged back network end day however since weak writes may finally accepted must used compensating transactions available likelihood conflicts low example users employ weak transactions update mostly private data strict transactions update frequently used heavily shared data cluster configuration dynamic clusters data may explicitly created merged upon forthcoming disconnection connection associated mobile client accommodate migrating locality mobile host may move different cluster upon entering new support environment besides defining clusters based physical location data definitions also possible clusters may defined based semantics data applications information access patterns instance form users profile includes data describing users typical behavior may utilized determining clusters examples follow example 1 cooperative environment consider case users working common project using mobile hosts groups formed consist users work similar topics project clusters correspond data used people group need maintain consistency among interactions consider data frequently accessed group data belonging group group copies data items belonging group core copies copies data items belonging groups quasi data item may belong one group one group frequently accesses case core copies data item exist clusters cluster operations items belong group weak operations data belong group strict weak updates data item accepted conflict updates owners data item example 2 caching clustering used model caching clientserver architecture setting mobile host acts client interacting server fixed host data cached client performance availability cached data considered quasi copies data fixed host core copies transactions initiated server always strict transactions initiated client invoke updates always weak readonly client transactions strict strict consistency required reconciliation weak writes accepted conflict strict transactions server frequency reconciliation depends user consistency requirements networking conditions example 3 location data mobile computing data representing location mobile user fastchanging data frequently accessed locate host thus location data must replicated many sites reduce overhead searching location copies considered quasi core copies always updated reflect changes location 6 quantitative evaluation weak consistency quantify improvement performance attained sacrificing strict consistency weakly connected environments understand interplay among various parameters developed analytical model analysis follows iterationbased methodology coupling standard hardware resource data contention 35 data contention result concurrency coherency control resources include network processing units generalize previous results take account nonuniform access data takes consideration hotspots changing locality b weak strict transaction types c various forms data access indicated compatibility matrix table 1 innovative feature analysis employment vacation system model disconnections wireless medium performance parameters consideration system throughput number messages sent response time weak strict transactions study performed range networking conditions different values bandwidth varying disconnection intervals 61 performance model assume cluster configuration n clusters poisson arrival rate queries updates let q u respectively average arrival rate queries updates data items initiated cluster assume fixed length transactions n operations data items queries n updates thus transaction rate ie rate transactions initiated cluster let c consistency factor application consideration c fraction arrived operations strict model hotspots divide data cluster hot cold data sets let number data items per cluster c cold h hot capture locality assume fraction transactions exhibit locality access data hot set probability h data cold set probability remaining transactions access hot cold data uniformly due mobility transaction may move different cluster data accesses may longer belong hot data new cluster modeled letting diminish locality taken advantage replication schema assuming probability hot data core copy cluster l cold data core copy l 0 normally l l probability operation cluster accesses data item core copy cluster simplicity assume one quasi copy data item cluster let q r read q w write quorum n mean number operations data copies per strict transaction transaction model consists nl states nl random variable items accessed transaction nl mean without loss generality assume nl equal number operations transaction initial setup phase state 0 progress states order successful end state nl transaction enters commit phase state nl1 transaction response time r trans expressed nw number lock waits run transaction r w j waiting time jth lock contention r e sum execution times states excluding lock waiting times r inlp execution time state 0 commit commit time reflect updates database resource contention analysis model clusters mg1 systems average service time various types requests exponentially distributed determined following parameters q processing time query data copy u time install update data copy b overhead time propagate update query another cluster mg1 server requests processed priority firstcome firstserved basis clusters connected later reconnected capture disconnections model connection among two clusters mm1 system vacations vacation system system server becomes unavailable occasional intervals time w available bandwidth two clusters assume exponentially distributed packet lengths messages average size service rate r equal wm let r network transmission time number messages total number messages transmitted per second amongst clusters first term corresponds query traffic second update traffic execution time simplicity ignore communication overhead inside cluster assuming either cluster consists single node communication among nodes inside cluster relatively fast without taking account data contention average response time weak read data item r w weak update r w w average wait time cluster let b r 0 q strict read data item r strict write r w computation w given appendix average transmission time average transmission time r equals service time plus network link arrival rate r link poisson mean mnn gamma 1 computation w r given appendix throughput transaction throughput ie input rate bounded processing time cluster since ex arrival rate requests cluster ex mean service time b available bandwidth since r r c disconnection intervals since r ev ev mean duration disconnection data contention analysis assume eventual best effort h following op stands one wr ww sr sw using formula response time strict weak transactions strict n q p q r sr n u p u r sw p op probability transaction contents op operation data copy r op average time spent waiting get op lock given lock contention occurs p q p u respectively probability least one operation data copy per strict read conflicts specifically p outline estimation p op r op given appendix detailed description model see 21 62 performance evaluation following performance results show percentage weak strict transactions effectively tuned based prevailing networking conditions available bandwidth duration disconnections attain desired throughput latency table 5 depicts realistic values input parameters bandwidth depends type technology used infrared typical value 1 mbps packet radio 2 mbps cellular phone 914 kbps 7 parameter description value n number clusters 5 q query arrival rate 12 queriessec u update arrival rate 3 updatessec c consistency factor ranges 0 1 q r read quorum ranges 1 n quorum ranges 1 n local transactions accessing hot data ranges 0 1 h probability local transaction access hot data ranges 0 1 l probability hot data core copy given cluster ranges 0 1 l 0 probability cold data core copy given cluster ranges 0 1 u processing time update 002 sec processing time query 0005 sec propagation overhead 000007 sec vacation interval ranges available bandwidth ranges average size message 512 bits c number cold data items per cluster 800 h number hot data items per cluster 200 average number operations per transaction 10 table 5 input parameters18220 c consistency factor maximum allowable input rate c maximum allowable input rate updates consistency factor figure 2 maximum allowable input rate updates various values consistency factor left limits imposed processing rate cluster ex right limits imposed bandwidth restrictions r r c consistency factor maximum allowable rate updates c maximum allowable rate updates consistency factor figure 3 maximum allowable input rate updates various values consistency factor limits imposed disconnections duration r ev system throughput figures 2left 2right 3 show maximum transaction input system throughput bounded processing time available bandwidth disconnection intervals respectively assume queries four times common updates shown figure 2left allowable input rate transactions almost double rate transactions strict 1 result increase workload c caused fact strict operations data items may translated one operation data copies percentage weak transactions effectively tuned attain desired throughput based networking conditions duration disconnections available bandwidth indicated figure 2right get instance throughput 200bps 1000bps must lower consistency factor 01 duration disconnections may vary seconds caused hand offs 17 minutes instance voluntary figure 3 depicts effect duration disconnection system throughput short durations figure longer ones figure 3right long disconnections figure 3right small percentage strict transactions initiated disconnected sites keep throughput comparable shorter disconnections figure 3left consistency factor must drop around three orders magnitude communication cost estimate communication cost number messages sent number messages depends following parameters replication schema 1 consistency factor c 2 data distribution l hot l 0 cold data 3 locality factor 4 quorums q r q w coherency schema assume rowa schema otherwise stated shown figure 4left number messages increases linearly consistency factor expected number messages decreases percentage transactions access hot data since local copies frequently available balance increase communication cost caused diminishing locality may need appropriately decrease consistency factor figure 4middle number number messages consistency factor c20601000 number messages locality number messages relication hot copies l figure 4 number messages left various values c middle locality right different replication hot core copies unless otherwise stated number messages replication cold core data l150150250 number messages read quorum equal rates 4 times queries 4 times updates figure 5 number messages left different replication cold core copies right different values read quorum unless otherwise stated messages decreases replication factor hot core copies increases figure 4right decrease evident since operations queries coherency schema rowa thus operations messages sent decrease rapid transactions exhibit locality access hot data frequently contrary number messages increases replication factor cold core copies additional writes caused coherency control figure 5left finally relationship read quorum number messages depends relative number queries updates figure 5right transaction response time response time weak strict transactions various values c depicted figure 6 larger values response times 200bps bandwidth faster response times result higher network availability set 2mbps values input parameters indicated table 5 additional parameters set follows 1 locality parameters 09 2 data replication parameters l disconnection parameters vacation intervals exponentially distributed sec model disconnection intervals correspond short involuntary disconnections caused hand offs 17 4 coherency response time secs consistency factor c strict 200bps strict 2mbps figure comparison response times weak strict transactions various values consistency factor consistency time sec response time processing time lock wait consistency factor005015025time sec response time processing time lock wait figure 7 left response time distribution strict transactions right response time distribution weak transactions control schema rowa latency weak transactions 50 times greater strict transactions however tradeoff involved using weak transactions since updates may aborted later time propagate updates reconciliation counted c increases response time weak strict transactions increase since conflicts occur increase dramatic smaller values bandwidth figure 7left right show response time distribution strict weak transactions respectively 2mbps bandwidth strict transactions important overhead network transmission times increase c increases weak transactions increase response time result longer waits acquiring locks since weak transactions want read uptodate data conflict strict transactions write 7 reconciliation cost provide estimation cost restoring consistency terms number weak transactions need rolled back focus conflicts among strict weak transactions outlined reconciliation protocol consider conflicts among weak transactions different clusters similar analysis applicable case also weak transaction rolled back writes conflict read strict transaction follows iasg let p 1 probability weak transaction wt writes data item read strict transaction st p 2 probability st follows wt serialization graph probability probability weak transaction rolled back assume reconciliation occurs n r transactions r strict weak simplicity assume uniform access distribution although reasonable assume granule access requests different transactions independent independence cannot hold within transaction transactions granule accesses distinct however probability accessing particular granule small eg number granules large access distribution uniform approximation accurate let p kl probability iasg edge given transaction type k given transaction type l let p 0 probability iasg strict 0 weak transactions edge given transaction type k transaction type l formulas p kl p 0 given appendix probability acyclic path length ie path distinct nodes given weak transaction given strict transaction iasg strict 0 weak transactions values pk k computed following recursive relations first term probability path whose first edge weak transactions second path whose first edge weak strict transaction includes least one weak transaction last path whose first edge weak strict transaction include weak transactions thus actual number weak transaction need undone compensated writes cannot become probability abort times consistency factor c trans trans trans trans probability abort times number transactions figure 8 probability abort 3000 data items001003005007 probability abort times consistency factor c 1000 items 2000 items 3000 items 4000 items 5000 items001003005007 1000 1500 2000 2500 3000 3500 4000 4500 5000 probability abort times number data items figure 9 probability abort permanent n also need roll back exact weak transactions read value written transaction aborted let e percentage weak transactions exact n roll figure 8left depicts probability weak transaction cannot accepted conflict strict transaction reconciliation events occurring varying number transactions different values consistency factor figure 9left shows probability varying database sizes accurate estimations achieved specific applications access patterns transactions known results used determine appropriate reconciliation point balance frequency reconciliations number weak transactions may aborted instance given c 05 keep probability threshold say 000003 reconciliation events must take place often every 85 transactions figure 8right 8 related work onecopy serializability 3 hides user fact multiple copies data item ensures strict consistency whereas onecopy serializability may acceptable criterion strict transactions restrictive applications tolerate bounded inconsistency causes unbearable overheads cases weak connectivity weak transaction model described paper first introduced 24 preliminary performance results presented 22 network partitioning partitioning database clusters resembles network partition problem 5 site link failures fragment network database sites isolated subnetworks called partitions clustering conceptually different partitioning electively done increase performance whereas partitions isolated clusters may weakly connected clients may operate physically disconnected even remaining physically connected strategies network partition face similar competing goals availability correctness strategies range optimistic transaction allowed executed partition pessimistic transactions partition restricted making worstcase assumptions transactions partitions model offers hybrid approach strict transactions may performed onecopy serializability ensured pessimistic manner weak transactions may performed locally optimistic manner merge updates performed weak transactions adopt purely syntactic approach readonly transactions readonly transactions modify database state thus execution cannot lead inconsistent database states framework readonly transactions weaker consistency requirements considered special case weak transactions 8 two requirements readonly transactions introduced consistency currency requirements consistency requirements specify degree consistency needed readonly transaction framework readonly transaction may consistency require ments b weak consistency requirements requires consistent view consistency constraints fully evaluated data read transaction must true c strong consistency requirements schedule update transactions together strong consistency queries must consistent model strict readonly transactions always strong consistency requirements weak readonly transactions tailored degrees based criterion used ias correctness weak readonly transactions may consistency requirement ignored ias schedule weak consistency part weakly correct ias schedule strong consistency part strongly correct schedule currency requirements specify update transactions reflected data read terms currency requirements strict readonly transactions read mostuptodate data item available ie committed weak readonly transactions may read older versions data depending definition ddegree epsilonserializability esr 25 allows temporary bounded inconsistencies copies seen queries period among asynchronous updates various copies data item readonly transactions framework similar weak readonly transactions consistency requirements esr bounds inconsistency directly bounding number updates 34 generalization esr proposed highlevel type specific operations abstract data types contrast approach deals lowlevel read write operations nignorant system transaction need see results n prior transactions would seen execution serial 13 strict transactions 0ignorant weak transactions 0ignorant weak transactions cluster weak transactions ignorant strict weak transactions clusters techniques supporting nignorance incorporating proposed model define ignorance factor n weak transactions mobile database systems effect mobility replication schemas discussed 2 need management cached copies tuned according available bandwidth currency requirements applications stressed respect ddegree consistency weak transactions realize requirements restrictive nature onecopy serializability mobile applications also pointed 14 relaxed criterion proposed criterion although sufficient aggregate data appropriate general applications distinguishable data furthermore criterion support form adaptability current network conditions bayou system 6 31 platform replicated highly available variableconsistency mobile databases build collaborative applications readanywriteany weaklyconsistent replication schema employed bayou database one distinguished server primary responsible committing writes secondary servers tentatively accept writes propagate towards primary server maintains two views database copy reflects committed data another full copy also reflects tentative writes currently known server applications may choose committed tentative data tentative data similar quasi data committed data similar core data correctness defined terms session rather serializability proposed model session abstraction sequence read writes application four types guarantees requested per session read writes b monotonic reads successive reads reflect nondecreasing set writes c writes follow read writes propagated reads depend monotonic writes writes propagated writes logically precede reconcile copies bayou adopts application based approach opposed syntactic based procedure used detection mechanism based dependency checks perwrite conflict resolution method based client provided merge procedures 32 mobile file systems coda 12 treats disconnections network partitions follows optimistic strategy elaborate reconciliation algorithm used merging file updates sites connected fixed network degrees consistency defined transaction support provided 15 16 extend coda new transaction service called isolationonly transactions iot iots sequences file accesses unlike traditional transactions isolation property iots guarantee failure atomicity conditionally guarantee permanence iots similar weak transactions methods refining consistency semantics cached files allow mobile client select mode appropriate current networking conditions discussed 9 proposed techniques delayed writes optimistic replication failing instead fetching data cases cache misses idea using different kinds operations access data also adopted 28 29 weak read operation added file service interface semantics operations different weak write provided since transaction support correctness criterion based onecopy serializability 9 summary overcome bandwidth cost latency barriers clients mobile information systems switch connected disconnected modes operation paper propose replication schema appropriate operation data located strongly connected sites grouped clusters bounded inconsistency defined requiring mutual consistency among copies located cluster controlled deviation among copies different clusters database interface extended weak operations weak operations query local potentially inconsistent copies perform tentative updates usual operations called strict framework contradistinction weak also supported strict operations access consistent data perform permanent updates disconnected operation supported using weak operations accommodate weak connectivity mobile client selects appropriate combination weak strict transactions based consistency requirements applications prevailing networking conditions adjusting degree divergence provides additional support adaptability idea providing weak operations applied type constraints besides replication constraints vertical horizontal partitions arithmetic constraints 27 another way defining semantics weak operations exploiting semantics data 33 data fragmented later merged based object semantics r data caching issues information retrieval system replicated data management mobile environments anything new sun concurrency control recovery database systems data networks consistency partitioned networks bayou architecture support data sharing among mobile users challenges mobile computing communication consistency mobile file systems data replication mobile computers mobile computing challenges data management disconnected operation coda file system bounded ingnorance technique increasing concurrency replicated system protocols maintaining inventory databases user profiles mobile sales applications improving data consistency mobile computing using isolationonly transactions cellular essentials wireless data transmission exploiting weak connectivity mobile file access programming interface applicationaware adaptation mobile computing theory database concurrency control transaction management mobile heterogeneous environments replication schema support weak connectivity mobile information systems building information systems mobile environments maintaining consistency data mobile distributed environments replica control distributed systems asynchronous approach experience disconnected operation mobile computing environment management interdependent data specifying dependency consistency requirements service interface replica management algorithm mobile file system clients efficient variableconsistency replicated file service queueing analysis session guarantees weakly consistent replicated data managing update conflicts bayou supporting semanticsbased transaction processing mobile database applications tolerating bounded inconsistency increasing concurrency database systems analytical modeling database concurrency control tr ctr luis veiga paulo ferreira poliper policies mobile pervasive environments proceedings 3rd workshop adaptive reflective middleware p238243 october 1919 2004 toronto ontario canada paolo bellavista antonio corradi rebecca montanari cesare stefanelli dynamic binding mobile applications middleware approach ieee internet computing v7 n2 p3442 march joanne holliday divyakant agrawal amr el abbadi disconnection modes mobile databases wireless networks v8 n4 p391402 july 2002 victor c lee kwokwa lam sang h son eddie chan transaction processing partial validation timestamp ordering mobile broadcast environments ieee transactions computers v51 n10 p11961211 october 2002 wenchih peng mingsyan chen design performance studies adaptive cache retrieval scheme mobile computing environment ieee transactions mobile computing v4 n1 p2940 january 2005 nadia nouali anne doucet habiba drias twophase commit protocol mobile wireless environment proceedings sixteenth australasian database conference p135143 january 01 2005 newcastle australia guy bernard jalel benothman luc bouganim grme canals sophie chabridon bruno defude jean ferri stphane ganarski rachid guerraoui pascal molli philippe pucheral claudia roncancio patricia serranoalvarado patrick valduriez mobile databases selection open issues research directions acm sigmod record v33 n2 june 2004 wanlei zhou li wang weijia jia analysis update ordering distributed replication systems future generation computer systems v20 n4 p565590 may 2004 paolo bellavista antonio corradi rebecca montanari cesare stefanelli mobile computing middleware location contextaware internet data services acm transactions internet technology toit v6 n4 p356380 november 2006 patricia serranoalvarado claudia roncancio michel adiba survey mobile transactions distributed parallel databases v16 n2 p193230 september 2004 srikumar venugopal rajkumar buyya kotagiri ramamohanarao taxonomy data grids distributed data sharing management processing acm computing surveys csur v38 n1 p3es 2006
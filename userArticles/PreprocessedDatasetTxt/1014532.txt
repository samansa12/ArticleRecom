using simulated execution verifying distributed algorithms paper presents methodology using simulated execution assist theorem prover verifying safety properties distributed systems executionbased techniques testing increase confidence implementation provide intuition behavior detect simple errors quickly cannot demonstrate correctness however aid theorem provers suggesting necessary lemmas providing tactics structure proofs paper describes use techniques machinechecked proof correctness paxos algorithm distributed consensus b introduction traditionally execution serves prelude formal verication testing reveals departures desired behavior corrected either code specication behavior attempting prove code correct testing via simulated execution even absence complete implementation paper discusses additional ways execution simulated execution assist formal verication describes use producing machinechecked proof distributed algorithm first execution serve powerful way prelude formal veri cation tools dynamic program analysis extract descriptions program behavior executions programmers match extracted descriptions expectations unlike traditional use execution test behavior use reveal unexpected behaviors departures anticipated behaviors second execution help produce lemmas required successful proofs correctness unlike human proofs peppered phrases like obvious machinechecked proofs often require many explicit lemmas avoid tedium enumerating lemmas hand veriers discover using execution dynamic program analysis third information directs simulated execution examine interesting aspects programs behavior also used direct proof correctness example programmers may ensure executions cover entire range expected behaviors formulating case splits distinguish normal unusual behaviors case splits also provide helpful ways organizing proof illustrate uses execution constructing formal proof correctness paxos distributed algorithm consensus lam98pll00 paper concerned primarily general methodology verifying distributed algorithms role execution automated tools play methodology details paxos algorithm methodology based inputoutput io automaton framework lt89 modeling verifying distributed algorithms component system represented automaton whose external behavior dened simple mathematical object called trace paper organized follows section 2 introduces io automaton model discusses ioa language toolkit support use model contrasts toolkit related tools use runtime techniques aid formal verication remainder paper presents executionbased methodology detail using proof paxos algorithm running example section 3 formulates specications implementations io au tomata section 4 describes automata executed section 5 shows dynamically detected invariants reveal properties automaton section 6 describes two automata one specication one imple mentation executed lockstep section 7 shows paired execution used construct machineveried proof preliminaries methodology uses io automaton model ioa language three tools ioa toolkit gl98 ioa interpreter lp theoremprover daikon dynamic invariant detector 21 io automata ioa language io automaton simple state machine transitions states associated named actions classied either input output internal inputs outputs external actions used communication automatons environment internal actions visible automaton automaton controls output internal actions performs input actions control io automaton consists signature lists actions set states distinguished start states statetransition relation contains triples form state action state optional set tasks considered paper action enabled state state 0 0 transition automaton input actions enabled every state operation io automaton described executions alternating sequences states actions traces externally visible behavior occurring executions one automaton implements another traces also traces denition 1 forward simulation forward simulation automaton automaton b relation f statesa statesb following two properties 1 every start state start state b b fa b 2 reachable state b reachable state b fa b 0 state b 0 b fa execution fragment b b theorem 1 forward simulation relation b every trace trace b lyn96 ioa language provides notations describing io automata stating properties uses larch shared language ghg specications axiomatize semantics io automata data types used describe algorithms ioa transition relations dened terms preconditions eects written either imperative style sequence assignment conditional loop statements declarative style predicate relating state variables pre poststates transition param eters nondeterministically chosen parameters also possible use combination two styles nondeterminism appears ioa two ways explicitly form choose constructs state variable initializations eects transition denitions implicitly form action scheduling uncertainty nondeterminism allows systems described general forms veried considering possible behaviors without tied particular implementation system design sample programs paper exploit full generality language dene primitive ie composite automata imperative style explicit nondeterminism 22 tools used ioa toolkit ioa interpreter ioa interpreter kcd users formulating checking properties automata interpreter simulate execution either single automaton isolation checking stated assertions displaying logging automatons execution two automata running lockstep latter case user presents interpreter two automata candidate simulation relation mapping called step correspondence actions lowerlevel automaton sequences actions higherlevel one interpreter simulates execution lowlevel automaton generates simulated execution highlevel automaton induced step correspondence checks two executions trace checks candidate simulation relation holds throughout executions ioa interpreter also known ioa simulator called interpreter paper avoid confusion notions forward backward simulation larch prover larch prover gg91 lp interactive theorem proving system multisorted rstorder logic admits specications theories larch shared language lsl ioa toolkit includes tool called ioa2lsl bog01 translates ioa denitions automata lsl theories describe operation automaton also generates proof obligations invariants simulation relations automaton daikon invariant detector daikon invariant detector ecgn01 proposes program properties likely true operates dynamically examining values computed execution postulating checking prop erties reporting pass battery statistical tests technique unsound guarantee test suite fully characterizes execution environment however reported properties often true generally helpful explicating system test andor test suite achieve soundness using lp check proofs 23 related work toolkits asml gsv01 mocha ahm tlc ly01 support execution verication concurrent distributed systems execution used mainly debugging understanding behavior system ioa toolkit uses execution purposes also automatically discovering program properties used lemmas formal proofs moreover facility executing pairs automata together matching actions one helps users organizing formal proofs correctness based simulation relations mocha smv tlc use model checking verication method model checking attractive requires relatively less expertise theoremproving provides counterexamples falsied properties however model checkers provide intuition true properties analyze nite state space theoremprovers apply nite innite systems alike invisible invariants method prz01 facilitates automated verication parameterized nitestate systems method uses modelchecking techniques calculating candidate invariants checking inductiveness proving verication conditions generated standard invariance rule deductive verication key characteristic method invariants proved automatically need shown human con trast regard invariants means inform users interesting program properties might overlooked invariants detected daikon intended simple easily readable properties additionally methodology limited nitestate systems inductively provable properties tuple value int automaton cons signature input faili node initi node v value output decidei node v value internal choosevalv value states failed transitions input initi v initiated initiated proposed proposed v internal choosevalv pre output decidei v pre input faili failed failed fig 1 specication consensus ioa specifying automata ioa rst step verifying implementation correct respect specication dene specication implementation automata ioa io automaton version paxos denes hierarchy four automata achieving consensus highestlevel automaton cons provides specication consensus lowestlevel automaton paxos provides distributed imple mentation intermediatelevel automaton global1 although nondistributed captures paxos uses ballots quorums achieve consensus correctness proof involves showing existence series forward simulations pair successive levels hierarchy case study examines forward simulation cons global1 31 specication automaton paxos implements distributed consensus asynchronous system individual processes fail suppose nite set nodes representing processes system v set possible consensus values processes may propose values v consensus service allowed return decisions processes proposed values must satisfy two conditions nodes must receive value agreement value must proposed process validity signature specication automaton cons figure 1 contains input action initiv representing proposal value v process internal action choosevalv representing choice consensus value v output action decideiv representing report consensus value process input action faili representing failure process automaton provides required agreement validity guarantees single consensus value chosen value must previously proposed 32 implementation automaton automaton global1 figure 2 species algorithm implements consensus nondistributed setting automaton uses totally ordered set ballots values one may eventually chosen consensus value sucient approval collected processes system addition external actions automaton cons signature global1 includes internal actions making ballots assigning values voting abstaining ballots automaton global1 determines fate ballot considering actions quorums nite subsets ballot global1 allows ballot succeed every node quorum voted simulating execution automaton ioa toolkit second step verifying correctness implementation using ioa toolkit test behavior simulating execution ioa interpreter simulates execution io automaton single machine allowing user help select executions propose invariants interpreter check interpreter requires ioa programs transformed form suitable execution example quorums paxos initialized opera tionally whereas specied declaratively original io automaton model aside bookkeeping issues crucial problem transformation resolving nondeterminism ioa interpreter solves problem requiring user supply program called ndr program source nondeterminism automaton kcd case study wrote several ndr programs execute global1 dierent interleavings actions causing nodes fail abstain ballot example ndr program statement output decide 4 1 causes ioa interpreter execute decide action given argu ments use structured test generation methods eg code coverage produce ndr programs instead simply selected executions exhibited felt normal behavior automaton exercised every action experience intuitive scheduling adequate purpose dynamic invariant detection however noted section 52 automaton global1 signature input faili node initi node v value output decidei node v value internal startthenodes setnode makeballotb ballot abstain node b setballot assignvalb ballot vvalue votei node b ballot internaldecideb ballot states val arrayballot nullvalue voted abstained arraynode setballot transitions internal startthenodes quorums delete 1 thenodes node thenodes votedi abstainedi od input initi v cons figure 1 input fail failed failed internal makeballotb pre internal assignvalb v pre proposed ballot b 0 ordering bordering internal votei b pre internal abstain b pre aballot ballot b dead insert aballot dead internal internaldecideb pre output decidei v pre fig 2 ballotbased implementation consensus ioa preliminary test run reported unexpected invariant indicated sub sequently corrected deciency test data another case study involving peterson mutual exclusion algorithm use ioa simulator uncovered bug ioa transcription implementation dynamically detecting likely invariants proof simulation relation often depends invariants auxiliary lemmas machine verication requires bookkeeping details made explicit parts proof usually interesting parts also tend relatively simple thus automating holds promise attempt automatically generate invariants lemmas use dynamic invariant detection daikon invariant detector runtime tool proposes invariants based program executions ecgn01 examines values program computes generalizes reports generalizations form ioa invariants daikons heuristics analyses result output form formal specication often matches human would written ne02 three potential problems technique unsound incomplete reported properties guaranteed useful discuss daikons output cope potential problems 51 daikon results case study paxos daikon analysis produced 23 invariants four helpful simulation relation proof section 7 four two invariants outside daikons grammar neither checked reported daikon report invariants existential quantiers report given number subterms 52 discussion dynamically detected invariants discuss cope potential problems invariant detector output first dynamic invariant detection unsound reported properties true test suite executionbased techniques guarantee test suite fully characterizes execution environment program hinder us two reasons first use daikons output help proposing understanding verifying program properties soundness provided theorem prover second output case study correct false facts daikon produced easilycorrected artifacts test suite execution scheduling example one set exe cutions daikon reported size failed variable constant corrected randomizing failures ndr program thereby improving quality test suite use section 6 general however simply covering every action seems adequate second dynamic invariant detection incomplete proposed invariants may insucient verication true invariants reported daikon restricts set invariants checks two reasons conserve runtime reduce number false positives reports properties checks larger number false properties report case study add inv4 inv6 set proposed daikon nd hindrance methodology aim completely automatic verication rather aim reduce human eort particularly nonimaginative eort qualitatively believe output providing four six required invariants assistance better none even though work remained notable inv3 true necessary proof provable isolation establishing required use inv6 words daikon able postulate simple property complicated proof prompting user nd proof addition nicely decomposing proof parts demonstrates strength technique easy dynamically check properties may quite complicated static proofs thus likely beyond capabilities static tools third reported properties may true useful example daikon reported decided initiated number properties use fact proof daikon uses heuristics prune useless facts instance limiting output based variable types however impossible tool know human nd desirable given situation found although dozen true irrelevant invariants easy pass uninteresting ones examining helped us solidify understanding algorithm implementation thus moderate amount extra information distract disable users finally reported properties may needed proof proof accepted theoremprover may use invariants strictly necessary thus obscuring essential argument believe better rst obtain working machineveried proof reduce fact automating task possibly following rintanen rin00 future work perform reduction case study forward simulation global1 cons 8 vvalue v 2 conschosen 9 bballot b 2 global1 succeeded global1 proof internal starts setnode b setballot ignore input initi node v value f input initi v od input faili node f input faili od output decidei node v value f output decidei v od internal makeballotb ballot ignore internal abstain node b setballot ignore internal votei node b ballot ignore internal assignvalb ballot v value e l se else f internal choosevalv internal internaldecideb ballot e l se f global1 e l se else f internal choosevalglobal1 valbval fig 3 forward simulation relation step correspondence proof block global1 cons 6 paired execution noted section 22 users also exploit ioa interpreter formulating checking validity forward simulation relation work toward goal proving correctness implementation respect specication forward simulation relation predicate relates states two automata see denition 1 figure 3 contains candidate forward simulation relation global1 cons simulation relation predicate relating states two automata specify step implementation global1 corresponds sequence steps specication cons general might multiple step correspondences preserve simulation relation even one dicult nd hence figure 3 also contains proof block describes step correspondence use attempted proof simulation relation proof block paired interpreter execute specication automaton lockstep implementation automaton proof block contains two subblocks corresponding two properties needed show simulation relation denition 1 rst subblock started initially shows start specication automaton 1 second sub 1 set legal start states specication automaton determined states block code usual initially block picks particular start state may depend start state implementing automaton block contains entry action lowlevel automaton entry provides algorithm producing highlevel execution fragment proof section may also contain third subblock declares auxiliary variables used step correspondence figure 3 proposed simulation relation identity state variables cons except chosen state variable global1 simulation relation denes chosen cons contain value v successful ballot global1 value v proof block straightforward start state external actions external action lowlevel execution matched action name highlevel automaton internal actions start makeballot abstain vote matched empty execution sequence automaton cons ioa interpreter reveals need careful treatment internal actions assignval internaldecide figure 3 given naive treatment internal assignvalb ballot v value ignore internal internaldecideb ballot f internal choosevalglobal1 valbval od actions proof block interpreter catches two problems purported step correspondence first given legal schedule executes internaldecide twice global1 interpreter discovers precondition chooseval fails second time executed lockstep execution cons second assignval needs chooseval ballot decided internally yet value assigned hence must chooseval ring assignval ballot global1succeeded nonnil value case analysis necessary global1 allows ballots voted succeed assigned values nondeterminism makes algorithm exible proof bit longer 7 verifying simulation relation lp since paired execution provides empirical evidence correctness simulation relation desirable supplement evidence proof ideally proof checked automated tool lp uses simulated executions described sections 5 6 assist lp user constructing proof purported forward simulation relation figure 3 required properties first proof block paired execution provides outline proof second invariants suggested daikon provide insight save user time nding auxiliary invariants needed verication lp proof purported simulation relation satises property 1 denition 1 straightforward interaction required user supply start state cons specied initially section figure 3 witness existential quantier prove startastatesglobal1 resume specializing b given witness lp automatically rewrites conjecture nds startb fa b true thereby completing proof lp proof purported simulation relation satises property 2 denition 1 lengthier benets greater extent results earlier sections proof proceeds cases one action implementation automaton global1 case user must supply execution fragment cons readily available statements proof block figure 3 action referred statement element witness execution ignore statement represents null execution init fail makeballot abstain vote actions user need supply nothing lp nishes proof automatically example guide proof init action suces type resume specializing beta initn v trivial amount additional guidance telling lp work harder needed decide action cases assignval internaldecide actions divided subcases accordance statements actions proof block addition proof cases uses invariants inv1 inv5 invariant inv2 used chooseval witness execution internaldecide show value chosen belongs consproposed four show ballots global1dead identical nil values help show changes global1succeeded global1val preserve simulation relation course invariants used establish simulation relation must veried interpreter daikon provide help first invariants sometimes require invariants proofs case study inv3 required auxiliary invariants inv1 inv6 daikon detected one second statement complicated invariants inv6 tested via simulated execution stated properly proof invariant rather simple techniques completely eliminate need human guidance proving invariants simulation relations automatically discover prove little human assistance invariants inv1 inv2 inv5 cannot yet discover invariants inv4 inv6 even though proofs simple although discover invariant inv3 simple proof invariant using lp requires moderate human guidance 8 conclusion theorem provers tools soundly reason general innite state systems leading guarantees correctness properties machinechecked proof provides assurance hand proof also carries cost terms human interaction propose methodology reduces eliminate human eort required formally proving properties programs particular methodology partially automates tedious lowlevel aspects using theorem prover freeing user focus proof methodology integrates simulated execution running distributed algorithm test suite uniprocessor theorem proving exploratory analysis experimenting system wellknown technique building intuition performing inexpensive sanity checks extend use runtime techniques two ways first use dynamic invariant detector generalize observed ex ecutions reporting logical properties likely true imple mentation technique reies properties would otherwise synthesized person properties reveal unexpected properties implementation buttress understanding eectively merely examining execution traces provide invariants lemmas simplify proofs reduce theoremproving eort second observe eort build good test suites reused theoremprover scripts proof scripts often mirror form scripts driving paired executions pays get scripts right investing eort attempting formal proof illustrated use methodology toolset supports methodology means case study formally proves correctness implementation consensus based lamports paxos protocol r exploiting modularity model checking formal veri dynamically discovering likely program invariants support program evolution guide lp languages tools formal speci ioa language toolset support designing toward industrial strength abstract state machines dilsun k dilsun k parttime parliament introduction inputoutput au tomata distributed algorithms smv language automatic generation program speci fundamental study revisiting paxos algorithm automatic deductive veri iterative algorithm synthesizing invariants tr ctr jeff h perkins michael ernst efficient incremental algorithms dynamic detection likely invariants acm sigsoft software engineering notes v29 n6 november 2004
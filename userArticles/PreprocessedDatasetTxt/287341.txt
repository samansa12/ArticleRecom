deterministic voting distributed systems using errorcorrecting codes abstractdistributed voting important problem reliable computing n modular redundant nmr system n computational modules execute identical tasks need periodically vote current states paper propose deterministic majority voting algorithm nmr systems voting algorithm uses errorcorrecting codes drastically reduce average case communication complexity particular show efficiency voting algorithm improved choosing parameters errorcorrecting code match probability computational faults example consider nmr system 31 modules state bits module independent computational error probability 103 nmr system algorithm reduce average case communication complexity approximately 10825m compared communication complexity 31m naive algorithm every module broadcasts local result modules also implemented voting algorithm network workstations experimental performance results match well theoretical predictions b introduction distributed voting important problem creation faulttolerant computing systems eg used keep distributed data consistent provide mutual exclusion distributed systems n modular redundant nmr system n computational modules execute identical tasks need synchronized periodically voting current computation state result used interchangeably hereafter modules set current computation state majority one majority result computations needed eg modules recompute previous result technique also essential tool taskduplicationbased checkpointing 12 distributed storage systems voting also used keep replicated data consistent many aspects voting algorithms studied eg data approximation reconfigurable voting dynamic modification vote weights metadatabased dynamic voting359 paper focus communication complexity voting problem several voting algorithms proposed reduce communication complexity 47 algorithms nondeterministic perform voting signatures local computation results recently noubir et al 8 proposed majority voting scheme based errorcontrol codes module first encodes local result codeword designed errordetecting code sends part codeword using errordetecting code discrepancies local results detected probability retransmission full local results majority voting decision made though scheme drastically reduces average case communication complexity still fail detect discrepancies local results might reach false voting result ie algorithm still probabilistic one addition scheme using error detecting capabilities codes paper show general using errordetecting codes edc help reduce communication complexity deterministic voting algorithm though used many applications reliable distributed data replication 1 errorcorrecting codes ecc applied voting problem many applications12 deterministic voting schemes needed provide accurate voting results paper propose novel deterministic voting scheme uses error correctingdetecting codes voting scheme generalizes known simple deterministic voting algorithms main contributions related voting scheme include using correcting addition detecting capability codes detection used known schemes drastically reduce chances retransmission whole local result node thus communication complexity voting ii proof scheme provably reaches voting result naive voting algorithm every module broadcasts local result modules iii tuning scheme optimal average case communication complexity choosing parameters errorcorrectingdetecting code thus making voting scheme adaptive various application environments different error rates paper organized follows section 2 describe majority voting problem nmr systems voting algorithm together correctness proof described section 3 section 4 analyzes worst case average case communication complexity algorithm section 5 presents experimental results performances proposed voting algorithm well two simple voting algorithms comparison section 6 concludes paper 2 problem definition section define model nmr system communication complexity address voting problem terms communication complexity 21 nmr system model nmr system consists n computational modules connected via communication medium given computational task module executes set instructions independent computational error probability p communication medium could bus shared memory pointtopoint network broadcast network consider communication medium reliable broadcast network ie module send computation result modules one errorfree communication operation system evolution considered synchronous ie voting process roundbased 22 communication complexity communication complexity task nmr system defined total number bits sent communication medium whole execution procedure task broadcast network let ij number bits ith module sends jth round execution task communication complexity task number modules system k number rounds needed complete task 23 voting problem consider voting function nmr system nmr system order get final result given task module completes computation separately needs synchronized modules voting result denote x local computational result ith module majority function defined follows oe otherwise general n odd natural number oe predefined value different possible computing results example 1 changes 0010 x 0 result voting nmr system module gets majorityx final result x local computation result ith module one obvious algorithm voting problem module computes task broadcasts result modules module receives modules results simply performs majority voting locally get result algorithm described follows algorithm 1 sendall voting module wait receive algorithm simple module needs one communication ie broadcast oper ation apparently communication complexity high result task bits communication complexity algorithm nm bits cases probability module computational error rather low namely times modules shall result thus module needs broadcast part result results identical module shall agree result modules use algorithm 1 namely get another simple improved voting algorithm follows algorithm 2 simple sendpart voting module partition local result x n symbols x wait receive else wait receive algorithm concatenation operation strings eg equality evaluation false otherwise padding may needed local result exact multiple n following example demonstrates rough comparison two algorithms round communication needed total 25 bits transmitted hand algorithm broadcast 0 majority voting result case 2 rounds communication done 10 bits 5 bits x 5 bits f transmitted results else part algorithm executed finally majority voting result obtained voting x ie rounds communication needed total bits 25 bits x 5 bits f transmitted 2 example observed 1 algorithm 1 always requires 1 round communication algorithm 2 requires 2 3 rounds communication 2 else part algorithm 2 actually algorithm 3 communication complexity algorithm 1 always nm communication complexity algorithm 2 may mn nmn depending x 4 algorithm 2 broadcasting voting voting flags ie f chance getting false voting result eliminated else part algorithm 2 ie algorithm 1 executed often communication complexity reduced mn nm cases ae n thus key idea used reduce communication complexity reduce chance execute algorithm 1 computing environments module low computational error probability p thus probably modules either 1 get result 2 get different results others case 1 algorithm 2 low communication complexity case 2 algorithm 1 actually used communication complexity high ie nmn detect correct discrepancies minor modules results else part algorithm 2 need executed communication complexity still low detecting correcting capability achieved using errorcorrecting codes 3 solution based errorcorrecting codes errorcorrecting codes ecc used voting problem reduce communication complexity basic idea instead broadcasting computation result x di rectly p ith module first encodes result x codeword code broadcasts one symbol codeword modules receiving symbols codeword reassembles vector modules result ie equal received vector codeword result thus decoded result majority result exists ie majorityx oe c modules whose results different majority result x symbols modules regarded error symbols respect majority result long code designed correct errors error symbols corrected get codeword corresponding majority result thus algorithm 1 need executed code length less nm communication complexity reduced compared algorithm 1 hand errordetecting codes used error results detected algorithm 1 still needs executed thus increases whole communication complexity voting thus errorcorrecting codes preferable errordetecting codes voting properly choosing errorcorrecting codes communication complexity always lowered algorithm 1 possible majority result exist ie majorityx vector module gets still decoded result observed example introduction voting flags avoid false result 31 voting algorithm ecc properly designed errorcorrecting code detect correct error voting algorithm using code follows algorithm 3 ecc voting module wait receive undecodable execute algorithm else else execute algorithm notice execute algorithm 1 module p need send whole result needs send additional codeword since code designed detect correct symbols correct unsent dt symbols regarded erasures recovered hence original x decoded see algorithm clearly flow chart algorithm given fig 1 following example shows algorithm works example 3 5 modules nmr system task result 6 bits ie evenodd code 2 used divides 6bit information 3 symbols reassembled vector n symbols broadcasty wait get execute sendall voting majorityf f figure 1 flow chart algorithm 3 encode information symbols 5symbol codeword code correct 1 error symbol evenodd code module broadcasts 1 symbol ie 2 bits codewords reassembled vector y0000000001 since 1 error symbol decoded x000000 flow chart algorithm see majority voting result case 2 rounds communication communication complexity 15 bits comparison algorithm 1 needs 1 round communication communication complexity 30 bits hand algorithm needs 3 rounds communication communication complexity case 35 bits example evenodd code used actually code affect communication complexity long properties evenodd code namely mds code flow chart algorithm introduction voting f ensures reach false voting result going sendall voting worst case guarantees fail reach majority result exists thus algorithm give correct majority voting result rigorous correctness proof algorithm follows 32 correctness algorithm theorem 1 algorithm 3 gives majorityx set local computational results proof flow chart algorithm easy see algorithm terminates following two cases 1 executing sendall voting algorithm correct majority voting result certainly reached 2 returning x case since majorityf equal x x majority result 2 see algorithm works various cases local results x give two stronger observations algorithm also help analyze communication complexity algorithm outputs oe ie algorithm 3 never gives false voting result proof easy see flow chart first round communication module gets vote vector according decodability two cases 1 undecodable sendall voting algorithm executed output oe 2 decodable decoded result x used reference result since exist majority voting result majority x equal x ie sendall voting algorithm executed output oe 2 output exactly x ie algorithm 3 miss majority voting result proof suppose e modules whose local results different majority result x e 1 e e error symbols vote vector respect corresponding codeword majority result x correctly decoded x majority equal x ie majority f 1 hence correct majority result x outputted 2 e either undecodable incorrectly decoded another x 0 x 0 6 x either case sendall voting algorithm executed correct majority result x reached 2 33 proper code design order reduce communication complexity need errorcorrecting code used practice algorithm 3 consider block code length symmetry among n modules needs multiple n ie codeword consists n symbols symbol k bits thus nk minimum distance code min 2 c since code able detect error symbols correct error symbols6 recall final voting result bits code design nk get smallest value k singleton bound coding theory6 get 2 equality holds mds codes6 given designed smallest value k e integer mds codes achieve lower bound k one class commonly used mds codes arbitrary distances reedsolomon code6 integer nk tk 1 block code used e one examples bch code also arbitrary distances6 exact parameters k obtained shortening setting information symbols zeros puncturing deleting parity symbols notice applications n thus n bits f neglected k approximately number bits module needs send get final voting result communication complexity algorithm 3 always lower algorithm 1 paper communication complexity voting considered since many systems computations encoding decoding individual nodes much faster reliable communications among nodes need rather complicated data management different communication stacks retransmission packets distributed nodes packet loss happens however real applications design proper codes also make encoding decoding codes computationally efficient possible distances codes relatively small case applications error probability p relatively low computationefficient mds codes exist codes 2 10 11 require bitwise exclusive operations communication complexity analysis 41 main results flow chart algorithm 3 see algorithm terminates branch 1 ie algorithm gets majority result communication complexity nk1 terminates branch 2 communication complexity nm1 finally algorithm terminates branch 3 communication complexity nm thus worst case communication complexity cw nm denote c average case communication complexity algorithm 3 define average reduction factor ff ratio c communication complexity sendall voting algorithm ie nm namely nm following theorem gives relation ff parameters nmr system corresponding code theorem 2 nmr system n modules executes identical task mbit result computational error probability p independent modules activities algorithm 3 uses ecc detect correct error symbols holds average reduction factor algorithm 3 proof get average case communication complexity c algorithm 3 need analyze probability p algorithm terminating branch 3 first assume module erroneous result x contributes error symbol voting vector proof observation 2 algorithm terminates branch 1 modules computational errors thus probability event exactly p 1 event algorithm reaches branch 2 corresponds decoder error event code minimum distance dt1 thus 6 b dt fa g weight distribution code used p ik probability received vector exactly hamming distance k weighti binary codeword code precisely weight distribution code unknown p 2 approximately bounded b dt since second term right side inequality probability event correctable errors happen finally p 3 probability decoder failure event notice fact module erroneous result also contribute correct symbol voting vector average case communication complexity average reduction factor notice e get result ff eq 3 2 remarks theorem eq 3 see relation average reduction factor ff branch algorithm 3 first term relates first branch whose reduction factor k 1 large enough relative n roundoff error partition neglected p 1 probability branch one would expect term dominant one ff since properly designed code tuned system algorithm supposed terminate branch 1 cases second term simply probability algorithm terminates either branch 2 branch 3 reduction factor 1 ie communication reduction since local results transmitted considering 1 bit f branch 2 last term due 1 bit voting f local result size large enough ie ae 1 1 bit neglected model thus applications result theorem simplified since assumption ae 1 quite reasonable theorem proof seen given nmr system ie n p p 1 function chosen eq 3 eq 11 easy see ff monotonically decreases decreases recall 0 thus chosen setting make ff minimum ae 1 even though straight forward get closed form minimize ff almost trivial get optimal numerical calculation fig 2 shows relations ff p n fig 2a fig 2b show ff using eq change setup n p easy see small p reasonable n small eg 2 n 51 achieve minimal ff results show quite good nmr system eg p 001 putting small amount redundancy local results apply errorcorrecting codes communication complexity majority voting drastically reduced since majority result bits module shall get identical result voting communication complexity voting problem least bits thus ff 1 lower bound ff fig 2c shows closeness theoretical lower bound ff minimum ff algorithm 3 achieve setup nmr systems 42 observations results see communication complexity algorithm 3 determined code design parameters nmr system n modules need consider case b n modules different local results majority ff vs different p fixed vs different n fixed p1 alpha alpha lower bound figure 2 relations ff p n result thus constraints dt 2 c specific values dt algorithm reduces following cases 1 repetition code used algorithm becomes algorithm 1 since repetition code always worst code terms redundancy always avoided reducing communication complexity voting hand dt0 algorithm becomes algorithm 2 fig 2 see small enough p reasonable n eg actually best solution majority voting problem terms communication complexity besides algorithm 2 low computational complexity since need complex encoding decoding operations thus ecc voting algorithm generalized voting algorithm communication complexity determined code chosen 2 code detecting capability ae n analysis increasing actually makes ff increasing thus good put redundancy local results detecting capability ae n ie using edc error detecting code help reduce communication complexity voting scheme proposed 8 class 3 2 c analyzed general good terms ff since increase increase ff fixed case algorithm 3 special property branch 2 algorithm directly come declare majority result without executing sendall voting algorithm simply code detect b nc errors majority result refer fig 1 b n erroneous modules since decodable majority local results agree decoded result x ie majorityf contradicts actual majority result setting b n 3 always 2 rounds communication worst case communication complexity thus nm instead nm 1 general case achieves lower bound worst case communication complexity distributed majority voting problem 8 5 experimental results section show experimental results three voting algorithms discussed experiments performed cluster intel pentiumlinux207 nodes connected via 100 mbps ethernet reliable communication implemented simple improved udp scheme whenever packet loss voting operation considered failure redone beginning choosing suitable packet size virtually packet loss using udp examine real performances three voting algorithms n nodes vote result length using three voting algorithms ecc voting algorithm evenodd code used corrects 1 error symbol ie ecc voting algorithm random errors added local computing results preassigned error probability p independent results nodes nmr system performances evaluated two parameters algorithm total time complete voting operation communication time voting operation c among local cs maximum c chosen c whole nmr system since voting operation considered collective operation systems performance determined worst local performance system set nmr system parameters n nodes error probability voting operation done 200 times random computation errors run independent runs arithmetic average cs regarded performance parameters tested nmr system experimental results shown figures 3 5 fig 3 compares experimental average reduction factors voting algorithms theoretical results analyzed previous section applied nmr system 5 nodes fig 4 shows performances c voting algorithms detailed communication patterns voting algorithms shown fig 5 provide deeper insight voting algorithms fig 3a fig 3b show experimental average reduction factors voting communication simple sendpart voting algorithm ecc voting algorithm fig 3a fig 3b also show theoretical average reduction factors algorithm 2 3 computed eq 11 notice average communication time reduction factors ff algorithm 2 algorithm 3 1 computing result size increases reduction factor approaches theoretical bound exception smallest computing result size 1 kbyte fig 4 shows performances voting algorithm applied nmr system 5 nodes fig 4ab show total voting time fig 4cd show communication time c voting different parameter nmr systems related figures symmetrically c error probability p figures c figures b easy see figures voting algorithm 1 voting c since besides communication additional local computation fig 4ab show algorithm 2 simple sendpart voting 3 ecc voting perform better algorithm 1 sendall voting terms total voting time hand fig 4cd show terms c ie communication complexity ecc voting algorithm better simple sendpart voting algorithm error error probability computing result size kbyte average reduction factor b error probability computing result size kbtye average reduction factor figure 3 average reduction factors ci experimental average reduction factor communication time voting using algorithm ffi theoretical bound average communication reduction factor using algorithm probability relatively large fig 4c worse simple sendpart voting algorithm error probability relatively small fig 4d consistent analysis results previous section analysis previous section size local computing result show variable average reduction factor function ff since communication complexity considered proportional size messages need broadcasted practically communication time proportional message size since startup time communication also needs included specially ethernet environment since maximum packet size physical send broadcast operation also limited physical ethernet communication completion time becomes complicated function message size thus experimental results seen computing result small size eg 1 kbyte sendall voting algorithm actually performs best terms c since startup time dominates performance communication also communication time broadcasting 1bit voting flags cannot neglected analyzed previous section particularly small size computing result also seen detailed voting communication time pattern fig 5ab round 2 communication 1bit voting flag even though finishes much shorter time round 1 still negligibly small explains fact small size computing results average communication time reduction factors algorithm 2 algorithm 3 quite apart theoretical bound examination detailed communication time pattern voting provides deeper insight algorithm 3 fig 5cd easy see first round communication algorithm 2 needs less time algorithm 3 since size message broadcasted smaller algorithm 2 besides first round communication time vary error probability p varies algorithms real difference two algorithms lies third round communication fig 5c time small algorithms since error probability p small 001 error probability p increases 01 shown fig 5d algorithm 2 time also increases bigger first round time since errorcorrecting capability full message needs broadcasted size much bigger first round hand algorithm 3 though also increases communication time third round still much smaller first round comes errorcorrecting codes algorithm 3 uses since code correct errors one computing node frequent error pattern happens thus even though error probability high cases expensive third round communication still avoided algorithm 3 performs better terms communication complexity time algorithm 2 high error probability systems predicted analysis previous section 6 conclusions proposed deterministic distributed voting algorithm using errorcorrecting codes reduce communication complexity voting problem nmr systems also given detailed theoretical analysis algorithm choosing design parameters errorcorrecting code ie algorithm achieve low communication complexity quite close theoretical lower bound also implemented voting algorithm network workstations experimental performance results match well theoretical analysis algorithm proposed needs 2 3 rounds communication left open problem whether algorithm distributed majority voting problem average case communication complexity less nm using 1 round communication r optimal strategy computing file copies evenodd efficient scheme tolerating double disk failures raid architectures voting using predispositions faultmasking reduced redundant communication voting without version numbers theory error correcting codes parallel data compression fault tolerance using codes reduce communication complexity voting nmr systems voting algorithms xcode mds array codes optimal encoding checkpointing parallel distributed systems tr
model checking safety properties special interest formal verification safety properties assert system always stays within allowed region proof rules verification safety properties developed proofbased approach verification making verification safety properties simpler verification general properties paper consider model checking safety properties computation violates general linear property reaches bad cycle witnesses violation property accordingly current methods tools model checking linear properties based search bad cycles symbolic implementation search involves calculation nested fixedpoint expression systems state space often infeasible every computation violates safety property finite prefix along property violated use fact order base model checking safety properties search finite bad prefixes search performed using simple forward backward symbolic reachability check naive methodology based search involves construction automaton tableau doubly exponential property present analysis safety properties enables us prevent doublyexponential blow use automaton used model checking general properties replacing search bad cycles search bad prefixes b introduction todays rapid development complex safetycritical systems requires reliable verication methods formal verication verify system meets desired property checking mathematical model system meets formal specication describes property special interest properties asserting observed behavior system always stays within allowed set nite behaviors nothing bad happens example reasearch supported bsf grant 9800096 address school computer science engineering jerusalem 91904 israel email ornacshujiacil z address department computer science houston part nsf grant ccr9700061 grant intel corporation may want assert every message received previously sent properties systems called safety properties intuitively property safety property every violation occurs nite execution system example computation system message received without previously sent occurs nite execution system order formally dene safety properties refer computations nonterminating system innite words alphabet typically set systems atomic propositions consider language l innite words nite word x bad prex l innite words concatenation x x l thus bad prex l nite word cannot extended innite word l language l safety language every word l nite bad prex example safety language see note every word l contains either sequence 01 sequence 10 prex ends one sequences cannot extended word l denition safety consider given as85 coincides denition limit closure dened eme83 dierent denition lam85 also refers property closed stuttering linear properties nonterminating systems often specied using buchi automata innite words linear temporal logic ltl formulas say automaton safety automaton recognizes safety language similarly ltl formula safety formula set computations satisfy form safety language sistla shows problem determining whether nondeterministic buchi automaton ltl formula safety pspacecomplete sis94 see also as87 hand buchi automaton deterministic problem solved linear time mp92 sistla also describes sucient syntactic requirements safe ltl formulas example formula positive normal whose temporal operators g always x next safety formula sis94 suppose want verify correctness system respect safety property use fact property known safety property order improve general verication methods positive answer question subject paper much previous work verication safety properties follow proofbased approach verication fra92 proofbased approach system annotated assertions proof rules used verify assertions particular manna pnueli consider verication reactive systems respect safety properties mp92 mp95 denition safety formulas considered mp92 mp95 syntactic safety formula formula form g past formula syntactic denition equivalent denition discussed mp92 proofbased methods also known verication liveness properties ol82 assert system eventually reaches good set states proof rule approaches less sensitive size state space system require heavy user support work considers stateexploration approach verication automatic model checking ce81 qs81 performed order verify correctness system respect specication previous work subject considers special cases safety liveness properties invariance checking gw91 mcm92 val93 mr97 assume general safety property given set bad prexes gw91 general methods model checking linear properties based construction tableau automaton accepts exactly innite computations violate property lp85 vw94 given system property verication respect reduced checking emptiness product vw86a check performed onthe symbolically cvwy92 gpvw95 tbk95 ltl formula size exponential length complexity verication follows pspace matching lower bound sc85 consider safety property let pref denote set bad prexes exam ple pref gp contains nite words position p hold recall every computation violates prex pref say automaton nite words tight safety property recognizes pref since every system violates computation prex pref automaton tight practically helpful indeed reasoning automata nite words easier reasoning automata innite words cf hksv97 particular words nite use backward forward symbolic reachability analysis bcm addition using automaton bad prexes return user nite error trace bad prex often helpful innite error trace given safety property construct automaton tight show construction involves exponential blowup case given nondeterministic buchi automaton involves doublyexponential blowup case given ltl results surprising indicate detection bad prexes nondeterministic automaton avor determinization tight automata construct indeed deterministic nevertheless construction avoids dicult determinization buchi automaton cf saf88 uses subset construction construction tight automata reduces problem verication safety properties problem invariance checking fra92 mp92 indeed take product tight automaton system check never reach accepting state tight automaton invariance checking amenable model checking techniques deductive verication techniques bm83 sor93 mab 94 practice veried systems often large even clever symbolic methods cannot cope stateexplosion problem model checking faces way construct tight automata also enables case bdds constructed symbolic reachability test get large analysis intermediate data collected analysis lead conclusion system satisfy property without traversal system view discouraging blowups described release requirement tight automata seek instead automaton need accept bad prexes yet must accept least one bad prex every computation satisfy say automaton ne example automaton recognizes p p p p accept words pref gp yet ne gp practice almost benet one obtain tight automaton also obtained ne automaton show natural safety formulas construction automaton ne easy construction formalize notion natural safety formulas consider safety gp xq xq single state p hold bad prex nevertheless prex tell whole story violation indeed latter depends fact xq xq unsatisable especially complicated examples may trivially noticed user bad prexes informative namely tell whole violation story bad prexes may informative user intelligence required order understand bad prexes formal denition informative prexes similar semantics ltl nite computations xtrue hold nal position notion informative prexes base classication safety properties three distinct safety levels property intentionally safe bad prexes informative example formula gp intentionally safe property accidentally safe every computation violates informative bad prex example formula gpxq xq accidentally safe finally property pathologically safe computation violates informative bad prex example formula gq gfp gr gfp gq gr pathologically safe intentionally safe properties natural accidentally safe especially pathologically safe properties contain redundancy expect see often practice show automaton accepts exactly innite computations violate easily blowup modied automaton true nite words tight intentionally safe ne accidentally safe suggest verication methodology based observations given system safety formula rst construct automaton true regardless type intersection true empty get error trace since true runs nite words nonemptiness checked using forward reachability symbolic methods product empty true tight intentionally safe formulas ne accidentally safe formulas may two reasons one satises second pathologically safe distinguish two cases check whether pathologically safe check requires space polynomial length pathologically safe turn users attention fact specication needlessly complicated according users preference either construct automaton tight proceed usual ltl verication wait alternative specication far discussed safety properties linear paradigm one also dene safety branching paradigm property describes trees safety property every tree violates nite prex whose extensions violate property well dene safety branching paradigm show problems determining whether ctl universal ctl formula safety exptimecomplete pspacecomplete respectively given linear complexity ctl model checking clear yet whether safety helpful notion branching paradigm hand show safety helpful notion assumeguarantee paradigm safety either assumption guarantee sucient improve general verication methods preliminaries 21 linear temporal logic logic ltl linear temporal logic formulas ltl constructed set ap atomic propositions using usual boolean operators temporal operators x next time u v duality formally given set ap ltl formula positive normal form dened follows true false p p p 2 ap ltl formulas ltl formula use cl denote closure namely set subformulas dene semantics ltl respect computation every j 0 j subset ap denoting set atomic propositions hold js position denote sux j use j indicate ltl formula holds path relation j inductively dened follows j true 6j false atomic proposition p 2 ap 0 k often interpret linear temporal logic formulas system many computations formally system set states r w w total transition relation every w 2 w least one w 0 rw w 0 set w 0 set initial states l maps state sets atomic propositions hold computation sequence w 0 rw modelchecking problem ltl determine given ltl formula system whether computations satisfy problem known pspacecomplete sc85 22 safety languages formulas consider language l innite words alphabet nite word x 2 bad prex l 2 x 62 l thus bad prex nite word cannot extended innite word l note x bad prex nite extensions x also bad prexes say bad prex x minimal strict prexes x bad language l safety language every w 62 l nite bad prex safety language l denote pref l set bad prexes l say set pref l trap safety language l every word w 62 l least one bad prex x thus x need contain bad prexes l must contain suciently many prexes trap words l denote traps l trapl language l use compl denote complement l ie say language l cosafety language compl safety language term used mp92 guarantee language equivalently l cosafety every w 2 l good prex x 2 2 x 2 l cosafety language l denote copref l set good prexes l note copref ltl formula set ap atomic propositions let k k denote set computations 2 ap satisfy say safety formula k k safety language also cosafety formula k k cosafety language equivalently k k safety language 23 word automata given alphabet innite word innite sequence letters denote w l sux l l1 l2 w given set x let x set positive boolean formulas x ie boolean formulas built elements x using also allow formulas true false x say truth assignment assigns true members assigns false members x n satises example sets fq satisfy formula q 1 q set fq 1 satisfy formula transition function nondeterministic automaton state space q alphabet represented using q example transition q written q transitions nondeterministic automata correspond disjunctions transitions alternating automata arbitrary formulas b q instance transition q meaning automaton accepts state q sux w l starting w accepts w l1 q 1 q 2 q 3 q 4 transition combines existential universal choices formally alternating automaton innite words input alphabet q nite set states set initial states f q set accepting states run nondeterministic automaton word w viewed function r q run alternating automaton w tree whose nodes labeled states q formally tree nonempty set every x c 2 x 2 c 2 x 2 elements called nodes empty word root every x 2 nodes x c 2 children x node children leaf path tree set 2 every x 2 either x leaf exists unique c 2 x c 2 given nite set labeled tree pair ht v tree maps node letter run innite word qlabeled tree ht r ri r r 2 q 0 every node x 2 r possibly empty set satises 1 c k x c 2 r rx c q c example q 0 possible runs w root labeled q one node level 1 labeled q 1 q 2 another node level 1 labeled q 3 q 4 note function value true need successors also never value false run run r innite path r let infrj denote set states r visits innitely often along innitely many x 2 q nite guaranteed infrj 6 buchi automaton innite words run r accepting infrj f 6 innite path r every path run visits least one state f innitely often automaton also run nite words run nite word qlabeled tree ht r ri r n n set words length n alphabet run proceeds exactly like run innite word nodes level n r leaves run ht r ri accepting nodes level n visit accepting states thus nodes x 2 r n rx 2 f word either nite innite accepted exists accepting run note conjunctions transition function ected branches ht r ri disjunctions ected fact many runs word language denoted la set words accepts already mentioned deterministic nondeterministic automata viewed special cases alternating automata formally alternating automaton deterministic q q nondeterministic q always disjunction q dene size alternating automaton sum jqj jj jj sum lengths formulas say automaton innite words safety cosafety automaton la safety cosafety language use pref copref trapa compa abbreviate pref la copref la trapla compla respectively automaton set states denote automaton obtained dening set initial states say automaton innite words universal runs nite words universal automaton empty state q 2 q nonempty set states universal resp rejecting universal empty note universality problem nondeterministic automata known pspacecomplete ms72 wol82 state basic result concerning analysis safety generalizes sistlas result sis94 concerning safety ltl formulas theorem 21 checking whether alternating buchi automaton safety cosafety automaton pspacecomplete proof let given alternating buchi automaton equivalent nondeterministic buchi automaton n whose size exponential size mh84 assume state n accepts least one word otherwise remove state simplify transitions relation let n loop automaton obtained n taking states accepting states shown as87 sis94 safety automaton ln loop contained la order check latter rst construct nondeterministic automaton n l construct n rst complement quadratic blowup kv97 translate result alternating buchi automaton nondeterministic buchi automaton involves exponential blow mh84 thus size n exponential size ln loop contained la intersection ln loop l n empty since constructions described performed emptiness intersection checked space polynomial size claim cosafety follows since noted alternating buchi automata complemented quadratic blowup kv97 lower bound follows sistlas lower bound ltl sis94 since ltl formulas translated alternating buchi automata linear blowup see theorem 22 note nonemptiness tests required algorithm performed using model checking tools cf cvwy92 tbk95 24 automata temporal logic given ltl formula positive normal form one build nondeterministic buchi automaton vw94 size exponential j j shown kvw00 var96 alternating automata used translation involves linear blow 1 translation ltl formulas alternating buchi automata going useful also methodology describe theorem 22 kvw00 var96 given ltl formula construct linear running time alternating buchi automaton proof set f accepting states consists formulas form 1 remains dene transition function 2 2 ap dene using translation described mh84 alternating buchi automata nondeterministic buchi automata get corollary 23 vw94 given ltl formula construct exponential running time nondeterministic buchi automaton n ln combining corollary 23 theorem 21 get following algorithm checking safety ltl formula algorithm essentially described sis94 rephrased somewhat emphasize usage model checking 1 construct nondeterministic buchi automaton 1 automaton linearly many states since alphabet 2 ap may exponential formula transition function linear size involves implicit representation 2 use model checker compute set nonempty states eliminate states take remaining states accepting states let n loop resulting automaton theorem 21 safety formula kn loop k kn k thus computations accepted n loop satisfy 3 convert n loop system loop transition labeling function thus system loop exactly computations accepted n loop 4 use model checker verify loop detecting bad prexes linear properties nonterminating systems often specied using automata innite words linear temporal logic ltl formulas given ltl formula one build nondeterministic buchi automaton recognizes k k size worst case exponential gpvw95 vw94 practice given property happens safe want automaton nite words detects bad prexes discuss introduc tion automaton easier reason section construct given safety property automaton bad prexes rst study case property given nondeterministic buchi automaton given automaton deterministic construction automaton 0 pref straightforward indeed obtain 0 dening set accepting states set states empty theorem 31 shows nondeterministic automaton things simple avoid dicult determinization may also require acceptance condition stronger buchi saf88 cannot avoid exponential blowup theorem 31 given safety nondeterministic buchi automaton size n size automaton recognizes pref 2 n proof start upper bound let recall pref la contains exactly prexes x 2 2 x 62 la accordingly automaton pref accepts prex x set states could reading x rejecting formally dene deterministic automaton follows transition function 0 follows subset construction induced every s2s set accepting states contains rejecting sets turn lower bound essentially follows fact pref refers words accepted hence avor complementation complementing nondeterministic automaton nite words involves exponential blowup mf71 fact one construct nondeterministic automaton qi states accepting smallest nondeterministic automaton recognizes compa states see consider language l n consisting words w either jwj 2n given let 0 regarded buchi automaton innite words claim pref see note since states accepting word w rejected runs w get stuck reading states 0 accepting holds w pref note constructing deterministic automaton 0 one apply minimization techniques used verication tool mona kla98 lower bound theorem 31 surprising complementation nondeterministic automata involves exponential blowup demonstrate lowerbound proof tight relation pref compa could hope therefore properties specied negative form describe forbidden behaviors system given ltl whose formulas negated detection bad prexes would harder detection bad computations theorems 32 33 refute hope theorem 32 given cosafety nondeterministic buchi automaton size n size automaton recognizes copref la 2 n proof upper bound similar one theorem 31 dene set accepting states 0 set universal sets prove matching lower bound n 1 let g dene l n language words w w contains least one letter rst either already appeared somewhere rst language l n cosafety language indeed word l n good prex eg one contains rst successor recognize l n nondeterministic buchi automaton states automaton guesses letter appears rst obvious good prexes l n 12 1232 etc recognize prexes nondeterministic automaton states n also less obvious good prexes like 1234 n permutation prexes indeed good every sux concatenate would start either letter ng appeared recognize prexes nondeterministic automaton needs keep track subsets ng needs states consequently nondeterministic automaton copref l n must least 2 n states extend proof theorem 32 get doublyexponential lower bound going safety ltl formula nondeterministic automaton bad prexes idea similar proof theorem 32 uses exponential lower bound going nondeterministic deterministic buchi automata proof case variant doubly exponential lower bound going ltl formulas deterministic buchi automata kv98 order prove latter kv98 dene language l n f0 1 g word w l n sux length n comes single w appears somewhere cks81 smallest deterministic automaton nite words accepts l n least 2 2 n states reaching automaton remember possible set words f0 1g n appeared hand specify l n following length quadratic n ignore technical fact buchi automata ltl formulas describe innite words 1in theorem 33 given safety ltl formula size n size automaton pref 2p n proof upper bounds follows exponential translation ltl formulas nondeterministic buchi automata vw94 exponential upper bound theorem 31 lower bound dene n 1 language l 0 n innite words f0 1 g every word l 0 n contains least one rst either word f0 1g n appeared word f0 1g n least one rst n positions rst language l 0 n cosafety language proof theorem 32 prex form x x 2 f0 1 g contains words f0 1g n good prex nondeterministic automaton needs 2 2 n states detect good prexes makes automaton copref l 0 doubly exponential hand specify l 0 n ltl formula n quadratic n formula similar one l n satised also computations rst followed word f0 1g n safety formula size quadratic n size smallest nondeterministic buchi automaton pref order get upper bound theorem 33 applied exponential construction theorem 31 exponential buchi automaton k k construction theorem 31 based subset construction requires check universality sets states q check corresponds validity check dnf formula disjunct corresponds state q size formula exponential j j number distinct literals formula linear j j implying following lemma lemma 34 consider ltl formula nondeterministic buchi automaton let q set states universality problem q checked using space polynomial j j proof every state associated set subformulas set q states corresponds set f 1 sets subformulas let l g set q universal j valid though formula q may exponentially longer check validity pspace rst negate get formula clearly q valid satisable q satisable least one conjunction disjunctive normal thus check q satisable enumerate conjunctions check whether one satisable since conjunction polynomial size number literals bounded j j claim follows note satisability problem ltl thus reduced nonemptiness problem nondeterministic buchi automata thus also model checking cvwy92 tbk95 fact nondeterministic buchi automaton constructed vw94 contains sets subformulas states run universality test suces compute set states accepting innite word conjunction satisable set f 1 g contained state given safety formula say nondeterministic automaton nite words tight view lower bounds proven construction tight automata may expensive say nondeterministic automaton nite words ne exists x 2 trapk k x thus ne automaton need accept bad prexes yet must accept least one bad prex every computation satisfy practice almost benet one obtain tight automaton also obtained ne automaton get back point section 6 open question whether feasible constructions ne automata general safety formulas section 5 show natural safety formulas construction automaton ne easy construction automaton 4 symbolic verication safety properties construction tight automata reduces problem verication safety properties problem invariance checking amenable large variety techniques particular backward forward symbolic reachability analysis proven eective techniques checking invariant properties systems large state spaces bcm practice however veried systems often large even clever symbolic methods cannot cope stateexplosion problem model checking faces section describe way construct tight automata enables case bdds constructed symbolic reachability test get big analysis intermediate data collected analysis solves modelchecking problem without traversal system consider system nm automaton accepts nite computations given let nondeterministic cosafety automaton k proof theorem 32 construct automaton 0 following subset construction dening set accepting states set universal sets one needs verify invariance product nm 0 never reaches accepting state 0 addition forward backward symbolic reachability analysis one could use variety recent techniques semiexhaustive reachability analysis rs95 ysaa97 including standard simulation techniques lwa98 also one could use bounded modelchecking techniques reduction propositional satisability problem used check whether path bounded length initial state accepting state nm 0 bcc however 0 doubly exponential j j bdd representation 0 use exponentially j boolean variables conceivable however due determinism 0 bdd would practice large width therefore would manageable size see section 62 related discussion another approach apply forward reachability analysis product system automaton formally let let product state space w q successors state hw qi pairs hw methods use predicate posts given set states represented symbolically returns successor set set states transition state starting initial set methods iteratively construct 0 set could therefore say construction implements subset construction dynamically model checking rather statically model checking calculation proceeds symbolically represented bdds forward symbolic methods actually follow subset construction indeed w 2 w set q w set states reached via path length state w 0 state w note set exponentially j large resulting possibly large bdd hand number boolean variables used represent linear j j experimental work needed compare merit two approaches ie static vs dynamic subset construction discussion suggests following technique case encounter space prob lems suppose point bdd gets big check whether state w set q w universal lemma 34 check universality space polynomial j j note need enumerate states w check q w enumerate directly sets q w whose number doubly exponential j j repeatedly select state w 2 w analyze q w remove states u 2 w q u lemma 41 encountering universal q w solves modelchecking problem without traversal system lemma 41 safety formula nonempty q w universal proof suppose q w universal consider innite trace starts w since q w universal state q 2 q w accepted q addition denition nite trace x state w 0 w reading x automaton reaches q hence innite trace x satisfy suppose nonempty innite trace accepted safety formula bad prex x length q 0 x universal x ends state w q w universal let j length shortest bad prex exists direction left right lemma 41 strengthened nonemptiness implies every j w 2 w q w universal want sometime cannot calculate j advance stronger version gives information method discuss sound also complete note possible use semiexhaustive reachability techniques also analyzing instead taking i1 posts take subset 0 ensure however saturated respect states lwa98 informally allowed drop states i1 allowed drop states formally hw qi 2 0 words pair mstate element w stays subset 0 pairs mstate element w stay ensures semiexhaustive analysis follows bad prex length q 0w universal extreme case follow one trace ie simulate case 0 related approaches see ces97 abg 00 note simulation cannot general performed safety formula use heuristic also general formulas get back point remarks 53 61 5 classication safety properties consider safety ltl formula gp bad prex x gp must contain state p hold user gets x error trace immediately understand gp violated consider formula equivalent gp therefore safety formula moreover set bad prexes gp coincide nevertheless minimal bad prex eg single state p hold tell whole story violation indeed latter depends fact xqxq unsatisable especially complicated examples may trivially noticed user intuition prex tells whole story base classication safety properties three distinct safety levels rst formalize intuition terms informative prexes recall assume ltl formulas given positive normal form negation applied propositions refer positive normal form ltl formula nite computation informative exists mapping following hold empty 3 1 n 2 li following hold propositional assertion satised informative existing mapping l called witness note emptiness ln guarantees requirements imposed fullled along example nite computation fpg informative gp eg witness l informative xq informative prex must contain least one state rst state p holds theorem 51 given ltl formula nite computation length n problem deciding whether informative solved time j j proof intuitively since branches deciding whether informative proceed similarly ctl model checking given construct mapping ng contains exactly formulas 2 cl sux informative informative 1 construction l max proceeds bottomup manner initially l 1 n insert l max propositional assertions cl satised proceed induction structure formula inserting subformula l max conditions item 3 satised taking order cope circular dependency conditions insertion formulas proceeds l max n l max 1 thus example formula 1 2 added l x 1 added l contains formulas form added l insert 1 u 2 l examine insertion 1 u 2 l max j j subformulas examine requires time linear n thus overall complexity j j remark 52 similar argument shows one check linear running time whether innite computation represented prex followed cycle satises ltl formula remark 53 clearly innite computation prex informative satisfy hand may satisfy prexes certain length say length bdds described section 4 explode informative hence practice one may want apply check theorem 51 one would get one following answers fail prex informative exists hence satisfy pass prex informative exists hence satises undetermined neither prexes found note methodology independent safety property use notion informative prex order distinguish three types safety formulas safety formula intentionally safe bad prexes informative example formula gp intentionally safe safety formula accidentally safe bad prexes informative every computation violates informative bad prex example accidentally safe safety formula pathologically safe computation violates informative bad prex example formula gqfgpgrfgpgqgr pathologically safe sistla shown temporal formulas positive normal form constructed temporal connectives x v safety formulas sis94 call formulas syntactically safe following strengthens sistlas result theorem 54 syntactically safe intentionally accidentally safe proof let syntactically safe formula temporal operators x u consider computation semantics ltl mapping conditions 1 3 witness mapping hold l 1 2 li 1 empty prex 1 informative follows every computation violates prex informative thus intentionally accidentally safe described section 24 given ltl formula positive normal form one build alternating buchi automaton essentially state la corresponds subformula transitions follow semantics ltl dene alternating buchi automaton true redening set accepting states empty set copy automaton may accept either reaching state proceed true visiting states innitely often true copies must reach state proceed true accordingly true accepts exactly computations nite prex informative see note computations accepted run copies eventually reach state associated propositional assertions satised let na true true regarded automaton nite words theorem 55 every safety formula automaton na true accepts exactly prexes informative proof assume rst prex informative witness mapping ng witness l induces run r true formally set states r visits reads sux coincides li denition witness mapping states q r visits reads n therefore r accepting direction similar thus every accepting run na true induces witness corollary 56 consider safety formula 1 intentionally safe na true tight 2 accidentally safe na true ne theorem 57 deciding whether given formula pathologically safe pspacecomplete proof consider formula recall automaton true accepts exactly computations nite prex informative hence pathologically safe every computation satisfy accepted true accordingly checking whether pathologically safe reduced checking containment since size linear length containment alternating buchi automata checked polynomial space kv97 done lower bound reduction problem deciding whether given formula safety formula consider formula let p q r atomic propositions pathologically safe shown safety formula pathologically safe note lower bound theorem 57 implies reverse direction theorem 54 hold theorem 58 deciding whether given formula intentionally safe expspace proof consider formula size n theorem 33 construct automaton pref theorem 55 accepts prexes informative note intentionally safe every prex pref informative prex thus check intentionally safe one complement na true intersection automaton pref empty nondeterministic automaton complements na true exponential n mh84 product automaton pref doubly exponential n since emptiness checked nondeterministic logarithmic space claim follows 6 methodology 61 exploiting classication section 5 partitioned safety formulas three safety levels showed formulas circumvent blowup involved constructing tight automaton bad prexes particular showed automaton na true linear length tight intentionally safe ne accidentally safe section describe methodology ecient verication safety properties based observations consider system safety ltl formula let nm nondeterministic automaton nite words accepts prexes computations let u true nondeterministic automaton nite words equivalent alternating automaton size u true exponential size na true exponential length given suggest proceed follows see figure 1 instead checking emptiness verication starts checking nm respect u true since automata refer nite words done using nite forward reachability analysis 2 product nm u true empty return word w intersection namely bad prex generated 3 product nm u true empty u true ne intentionally accidentally safe formulas may two reasons one satises second pathologically safe therefore next check whether pathologically safe note syntactically safe formulas check unnecessary theorem 54 pathologically safe conclude satises otherwise tell user formula pathologically safe indicating specication needlessly complicated accidentally pathologically safe formulas contain redundancy point user would probably surprised formula safety formula known safety would simplied intentionally user wishes continue formula give using fact safety proceed usual ltl model checking thus check emptiness recall symbolic algorithm emptiness buchi automata worst case quadratic hksv97 tbk95 note point error trace user gets satisfy consists prex cycle yet since user want change formula probably idea safety formula nite noninformative error trace would help user prefers large making discovery bad cycles infeasible build automaton pref hoping learning user would understand simplify formula spite potential blowup nite forward reachability would work better section 62 alternative approach 3 note since may intentionally safe automaton u true may tight thus w minimal informative bad prex may minimal bad prex 4 automatic translation pathologically safe formulas intentionally safe formulas open problem translation may proceed automaton formulas bad prexes case would nonelementary correct consult user nm u true incorrect return error trace pathologically safe figure 1 verication safety formulas remark 61 fact methodology adjusted formulas known safety formulas often terminate helpful output formulas safety formulas start checking emptiness nm u true note u true dened also formulas safety intersection empty contains error trace incorrect intersection empty check whether intentionally accidentally safe formula conclude correct otherwise consult user note also determinizing u true get checker used simulation 62 going backwards detailed given system safety formula method starts checking whether nite prex computation word accepted nm informative bad prex word accepted u true nm u true automata nite words product thus search word intersection done using nite forward reachability analysis section discuss another approach checking nite prex computation informative bad prex say nondeterministic automaton every state q 2 q letter 2 one state q 0 2 q q 2 q thus given current state run u last letter read input one determine state visited current one let reverse function thus 1 q g u reverse deterministic sets range 1 either empty singletons extend 1 sets natural way follows set q contains states may lead state q 0 letter input assume reverse deterministic ne automaton u thus u accepts exactly bad prexes informative consider product nite prex computation informative bad prex p nonempty namely path p state 0 state f state p pair hw qi state w state q u say set states p qhomogeneous q 2 q 0 wfqg w state states pairs 0 agree second element every state hw qi letter 2 2 ap set 1 hw qi may contain one state nevertheless since u reverse deterministic set 1 hw qi qhomogeneous moreover since u reverse deterministic every qhomogeneous set 0 every 2 2 ap set 1 qhomogeneous well accordingly start qhomogeneous set traverse p backwards along one word need maintain qhomogeneous sets practice means instead maintaining sets 2 w 2 q need forward traversal maintain sets 2 w q conduct backwards breadthrst search starting f could hope sets maintained search would smaller though necessarily homogeneous due reverse determinism suggests ne automaton reverse deterministic may useful check nonemptiness p using backwards search starting ne automatons accepting states automaton u true dened means alternating word automaton reverse deterministic example reach state q states xp xq xq xr describe ne reverse deterministic size exponential length automaton based reverse deterministic automata dened vw94 ltl vw94 state associated set formulas cl automaton state associated accepts exactly innite words satisfy formulas unlike automata vw94 state n associated imposes requirements formulas satised imposes requirements formulas cl n satised property crucial ne automaton n visits state associated empty set requirements accordingly dene fg set accepting states note fact set accepting states singleton implies product p start single qhomogeneous set w fg easy dene n formally terms reverse deterministic function 1 consider state cl n letter 2 2 ap single state 0 1 maximal subset cl computation satises formulas 0 rst position labeled sux 1 satises formulas formally 0 contains exactly propositional assertion cl satised formulas cl following hold easy see every single 0 satises conditions also sequence states n starts 0 containing leads via nite computation induces mapping showing informative follows n reverse deterministic ne automaton 63 safety assumeguarantee paradigm given system two ltl formulas 1 2 linear assumeguarantee specication holds every system 0 composition mkm 0 satises assump composition mkm 0 also satises guarantee 2 testing assumeguarantee specications reduced ltl model checking indeed hard see system satises intersection 1 may safety formula 1 safety formula proof theorem 21 analysis 1 ignore fairness conditions 1 proceed model checking 2 note however system 1 may total ie may deadend states need eliminated model checking 2 suppose 2 safety formula 1 safety formula proceed follows rst ignore fairness condition 1 use techniques model check suppose found bad prex ends state hw qi 1 remains check hw qi fair state ie fair path starting hw qi instead performing fair reachability analysis entire state space 1 reachable state space 1 suces perform analysis set states reachable hw qi could potentially much easier full fair reachability analysis conclusion reasoning assumeguarantee specications useful consider safety assumptions guarantee separately 64 safety branching paradigm consider binary tree prex nonempty prexclosed subset labeled tree prex p p extension ht labeled tree ht v v 0 agree labels nodes p say branching formula violates exists prex p p extensions ht violates logic ctl branching temporal logic ctl every temporal operator preceded path quantier e path paths theorem 62 given ctl formula deciding whether safety formula exptime complete proof sistlas algorithm checking safety ltl formulas sis94 adapted branching paradigm follows consider ctl formula recall safe tree satisfy whose prexes least one extension satises without loss generality assume tree branching degree bounded nondeterministic automaton thus accepts exactly dary trees satisfy assume state accepts least one tree otherwise remove simplify transitions relation let dloop automaton obtained taking states accepting states dening set accepting states set states thus dloop accepts exactly dary trees whose prexes least one extension accepted hence safety empty since size automata exponential nonemptiness check quadratic vw86b exptime upper bound follows lower bound reduction ctl satisability given ctl formula let p proposition let claim safe satisable first satisable therefore safe direction assume way contradiction safe satised tree ht v tree labeled propositions appearing let extension ht refers also proposition p labels ht bad prex p whose extensions violate consider p extension agrees propositions frontier ps p extension satises afp contradicting fact p bad prex using similar arguments prove following theorem showing disable alternation universal existential quantication formula problem complex linear paradigm theorem 63 given actl formula deciding whether safety formula pspacecomplete since ctl actl model checking completed time linear ces86 performed using symbolic methods tree automaton exponential size detects nite bad prexes much help hand perhaps safety could oer advantage alternatingautomatatheoretic framework kvw00 point open question whether safety useful notion branchingtime paradigm acknowledgment second author grateful avner landver stimulating discussions r recognizing safety liveness symbolic model checking using sat procedures instead bdds symbolic model check ing 10 20 states beyond design synthesis synchronization skeletons using branching time temporal logic automatic veri alternation journal association computing machinery memory ecient algorithms veri cation temporal properties alternative semantics temporal logics temporal modal logic program veri simple onthe automatic veri cation linear temporal logic using partial orders ecient veri cation deadlock freedom safety properties new heuristic bad cycle detection using bdds forward model checking techniques oriented buggy designs weak alternating automata weak automatatheoretic approach branchingtime model checking logical foundation checking hybrid techniques fast functional simulation stanford temporal prover using unfolding avoid state explosion problem veri economy description automata temporal logic reactive concurrent systems speci temporal logic reactive concurrent systems safety deadlock checking using net unfoldings equivalence problem regular expressions squaring requires exponential time proving liveness properties concurrent programs complexity complexity propositional linear temporal logic satefy liveness fairness temporal logic pvs proof checker reference manual beta release testing language containment automatatheoretic approach linear temporal logic automatatheoretic approach automatic program veri ca tion reasoning synthesis communicating processes temporal logic speci combining formal informal veri tr complexity propositional linear temporal logics automatic verification finitestate concurrent systems using temporal logic specifications automatatheoretic techniques modal logics programs temporal modal logic temporal logic reactive concurrent systems symbolic model checking memoryefficient algorithms verification temporal properties reasoning infinite computations testing language containment myampersandohgrautomata using bdds highdensity reachability analysis automatatheoretic approach linear temporal logic forward model checking techniques oriented buggy designs hybrid techniques fast functional simulation symbolic model checking using sat procedures instead bdds checking finite state concurrent programs satisfy linear specification alternation automatatheoretic approach branchingtime model checking proving liveness properties concurrent programs program verification simple onthefly automatic verification linear temporal logic safety branching time semantics specification verification concurrent systems cesar using unfoldings avoid state explosion problem verification asynchronous circuits onthefly verification stubborn sets combining formal informal verification deadlock checking using net unfoldings mona myampersandamp fido design synthesis synchronization skeletons using branchingtime temporal logic using partial orders efficient verification deadlock freedom safety properties freedom weakness determinism checking formal specifications simulation weak alternating automata weak step stanford temporal prover synthesis communicating processes temporal logic specifications ctr freddy yc mang peihsin ho abstraction refinement controllability cooperativeness analysis proceedings 41st annual conference design automation june 0711 2004 san diego ca usa r armoni egorov r fraer korchemny vardi efficient ltl compilation satbased model checking proceedings 2005 ieeeacm international conference computeraided design p877884 november 0610 2005 san jose ca orna kupferman moshe vardi complementation certification theoretical computer science v345 n1 p83100 21 november 2005 roberto sebastiani eli singerman stefano tonetta moshe vardi gste partitioned model checking formal methods system design v31 n2 p177196 october 2007 chao wang zijiang yang franjo ivani aarti gupta disjunctive image computation software verification acm transactions design automation electronic systems todaes v12 n2 p10es april 2007
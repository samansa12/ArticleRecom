relative debugging application development large numerical models large scientific codes rarely static objects developers often faced tedious task accounting discrepancies new old versions paper describe new technique called relative debugging addresses problem automating process comparing modified code correct reference code examine utility relative debugging technique applying relative debugger called guard range debugging problems large atmospheric circulation model experience confirms effectiveness approach using guard able validate new sequential version atmospheric model identify source significant discrepancy parallel version short period time b introduction large scientific codes constantly evolving refinements understanding physical phenomena result changes physics improved numerical methods result changes solution techniques developments computer architecture result new algorithms unfortunately evolutionary process often introduces subtle errors extremely difficult find consequence scientific programmers spend many hours days weeks laboriously comparing executions two almost identical codes seeking identify source small discrepancy debuggers assist locating program errors tools allow user investigate execution state application program example examining state program variables 11 12 13 17 significant recent extensions include graphical user interfaces improve ease use data visualization facilities aid interpretation large complex data structures concept process groups aid management many independent threads parallel machines support parallel distributed debugging 2 8 9 11 14 traditional debuggers proved invaluable developing new programs however directly address problems maintaining extending existing computer programs converting software one machine language another programmers want examine new versions existing programs isolation instead want compare execution execution old reference program assumed correct acting reference working version assist locating section code modified program introduces incorrect values existing techniques comparing executions two program versions tedious error prone limited scope example programmer may invoke two programs separate debuggers manually set breakpoints run programs visually compare resulting program states advanced approach insert output statements programs compare output using file comparison program 6 approach also limitations requires huge amounts disk storage program output involves modifications programs easily extended take account data types example floating point numbers compared programs compare files character character may sufficiently flexible paper describe new debugging paradigm called relative debugging addresses difficulties key idea relative debugging errors new version program located automated runtime comparison internal state new reference versions supported appropriate tools approach require modifications user programs perform comparisons fly without requiring disk storage comparisons take account differences data representations two pro grams making possible new reference versions run different machines written different languages latter feature particularly important supercomputing applications example porting vector code parallel computer addition introducing relative debugging paper describes particular instantiation paradigmthe relative debugger guardand present results experimental study guard applied large scientific code guard uses machine independent debugging interface support relative debugging heterogeneous multilanguage environments experimental study involves mesoscale atmospheric circulation model called mm5 demonstrates power guard using existing sequential version account subtle numeric differencess parallel version relative debugging traditional debuggers allow user control program examine state point execution user sets breakpoints code interactively examines program variables verifies variables expected values erroneous values traced erroneous code using information program data flow relative debugging differs traditional debugging two important respects first program variables compared user expectations variables another reference program known correct second reference program available compute correct values comparison process automated hence relative debugging process proceeds follows user first formulates set assertions key data structures reference development versions assertions specify locations data structures identical violations assertions indicate errors relative debugger responsible managing execution two program versions validating supplied assertions comparing data structures reporting differences differences reported user proceeds isolate erroneous code repeatedly refining assertions reinvoking relative debugger erroneous region small enough traditional debugging techniques used correct development version thus relative debugger provides quick effective way locating problems development version relative debugger provides functionality traditional debugger including commands program control state access breakpoints however heart relative debugger set new commands available conventional debuggers commands support relative debugging paradigm introduce briefly describe relative debugger reference program development program computer computer c figure 1 relative debugging detail next section discuss guard reference development versions program executed concurrently relative debugger must capable handling two programs time figure 1 useful relative debugger support debugging programs written different programming languages executing different computers heterogeneous network makes possible use relative debugger porting programs one language computer another relative debugger checks usersupplied assertions comparing data structures reference development versions performs necessary transformations different internal data representations different computers different languages performing com parisons debugger must take account different data types allowing issues inexact equality floating point numbers differences dynamic pointer values violations assertions reported user number approaches possible reporting differences data structures ranging text advanced data visualization techniques differences numeric values differences printed differences numerous visualization techniques required present meaningful way 3 guard relative debugger guard relative debugger provides standard debugging commands start process execu tion set breakpoints examine process state main power novelty guard however comes specialized commands support relative debugging commands broadly broken two groups process control data comparison 31 process control guard commands use symbolic names refer processes names assigned guard launches new process attaches existing one guard handle arbitrary number processes concurrently limited operating system restrictions launched using invoke command following syntax invoke processname command machinename username process name guard variable used identify process command specifies command line program optional machine name user name make possible run code remote system another user case guard creates attaches remote process another computer system ability execute reference development versions program different systems eliminates errors introduced moving reference code target system processes created invoke remain suspended execution resumed verify command takes list process names argument execution continues processes terminate encounter breakpoint assertion 32 data comparison guard supports two different approaches comparison program executions procedural approach declarative approach describe procedural approach first basic command procedural relative debugging compare following syntax compare process1variable1 process2variable2 command traverses two named data structures variable 1 variable 2 two named processes compares corresponding data elements taking account data type user specify tolerance value comparisons case differences reported two corresponding values differ tolerance array comparisons compare interprets array indices according source language enables comparisons multidimensional arrays processes whose source languages use different layouts rows columns fortran c currently guard supports comparison elementary variables arrays support complicated data structures records dynamic data structures planned future use compare user must set breakpoints processes run programs issue compare command programs reach breakpoints procedure tedious error prone especially comparing values within loops eliminate laborious procedure guard provides declarative relative debugging assertions assertions simplify debugging process automating setting breakpoints comparison data structures assertions specified assert command following syntax assert eps type value file filename command contains two tuples process identifier variable name source file name line number guard plants breakpoints two processes specified line numbers stores assertion information internal table breakpoints encountered table searched matching assertions two data structures retrieved compared differences execution resumed differences detected guard returns command line enables use commands print compare etc examining process states optional fields assertion make possible set tolerances comparison structures individual assertion eps parameter specify file output differences file parameter data produced latter option used input visualization program detailed exploration differences also possible set global values tolerance output file overridden using eps file parameters particular assertion 321 subarray expressions index permutations default guard compares elements array data structures however many cases desirable consider subsection array example comparing sequential reference code parallel implementation often case additional array rows columns added parallel code facilitate communication boundary values guard provides subarray expressions allow user make assertion rectangular subarrays following example compares one array subarray size larger data structure guard also supports permutation array indices feature caters cases data structures compared equivalent order indices differently following syntax specifies second array uses index ordering inverted relative first array feature proved valuable comparing versions code optimized vector architecture optimized risc ones cases inner vector loops often moved outer loops improve cache performance 322 visualizing differences guard supports three approaches reporting differences text bitmaps advanced visualization techniques text output simplest actual values differences printed standard output second approach suited array comparisons text output may exces sive case two values printed maximum difference corresponding array elements total cumulative difference elements information reported rectangular bitmap displayed screen bitmap white pixels denote values black pixels denote values different simple array visualization particularly useful detecting erroneous loop bounds addressing expressions types error tend generate regular patterns display arrays two indices folded onto two dimensions using number standard techniques powerful technique supported guard involves use commercial data exploration visualization software ibms data explorer dx complete set differences saved file using parameter assert command values file displayed using dx use advanced visualization techniques well suited display differences arrays two dimensions animations used convey development differences two programs execute 33 underlying guard technology space permit detailed description guard implementation however provide relevant details guard implemented platform called dynascope provides interface building debuggers 16 interface contains operations process control state access breakpoint handling dynascopes hence guards machine independent debugging interface provided debugging servers 15 debugging server associated executing program server executes separate process part program responsible receiving executing debugging requests guard communication servers guard performed tcpip guard implemented terms dynascope mechanisms guard ported without modification computing platform supported dynascope currently debugging servers implemented sun silicon graphics ibm rs6000 next com puters implementations additional architectures progress addition support remote debugging allows guard compare programs executing different machines example successfully run guard across internet guard executing silicon graphics computer australia two programs compared running sun computer europe next computer usa 4 mm5 mesoscale weather model section describe mesoscale model called mm5 used experiments mm5 originally developed national center atmospheric research since modified ported parallel platforms argonne national laboratory parallel version code called mpmm written using portable parallel library whilst similar mm5 functionality much structure altered allow parallel computations performed key data structures altered allow data decomposition distributed memory machines 41 structure mm5 penn statencar mesoscale model limitedarea primitive equation model designed simulate mesoalpha scale 2002000 km mesobeta scale 20200 km atmospheric circulation systems 1 7 model may run resolutions low 1 km domains uniform rectangular grids representing threedimensional regions atmosphere horizontal coordinate system equally spaced geographically model uses arakawa gridding scheme vertical coordinate system oe surfaces layers distributed closely nearer surface 23 layers current model use version nonhydrostatic atmospheric dynamics 4 fourthorder finite difference scheme 3 split semiimplicit scheme used resolve acoustic waves physics includes blackadar highresolution planetary boundary layer scheme grell cumulus scheme explicit moisture treatment mixedphase processes ice shallow convection dry convective adjustment dudhia long shortwave radiation scheme 7 mm5 traditional vector code written almost entirely standard fortran 77 however pointers used keep track different versions model data structures correspond different nesting levels logically code thought invoking physics routines set independent vertical columns nevertheless maximum vectorization code structured longitude loop innermost 42 structure mpmm mpmm version mm5 designed exploit scalable parallel computers 5 10 intended functionally identical mm5 yield results structured quite differently order execute efficiently parallel computers two significant concerns arise moving vector code mm5 scalable parallel computer single processor performance load balance mpmm structured address issues mm5 code restructured obtain columncallable form permits model called vertical model column portable runtime system library rsl used invoke columncallable model column approach facilitates load balancing easy move individual columns processors response changing load distribution figure 2 also results better cache utilization column processes physical processor boundaries figure 2 load balancing mpmm figure shows situation columns migrated compensate load imbalances lines indicate data dependencies columns figure 3 illustrates mpmm code structure notice calls rsl routines used perform computation exchange data required finite different stencils communicate nested subdomains resulting code performs well scalable parallel computers achieving example 115 gflops 64processor ibm sp2 power 1 processors 91 91 23 domain summary mm5 mpmm two complex numerical codes functionally equivalent different structures toplevel code structure loop nesting array structures quite different differences render comparison two models nontrivial exercise 5 debugging experiments section describe experiments performed using guard mm5 first describe experiment guard used determine two sequential versions mm5 thought implement different dynamics fact provided identical results second report experiment guard used investigate account discrepancies correct sequential version mm5 single process parallel version task particularly challenging different data code structures c computation coarse domain call rslexchstencil domain1 stena call rslcomputecells domain1 solvea call rslexchstencil domain1 stenb call rslcomputecells domain1 solveb c force nested boundaries call rslexchstencil domain1 steninterp call rslbcast domain1 domain2 mask c computation nested domain call rslexchstencil domain2 stena call rslcomputecells domain2 solvea etc c force cd nest call rslmerge domain1 domain2 mask computation domain broadcast cd associated cells nest merge nest back onto associated cell cd top level parallel model using rsl figure 3 top level parallel driver mm5 time step nest interactions 51 comparing sequential codes first attempt use guard identify previously unsolved problems compared two versions sequential mm5 code first version unix code produced argonne original ncar cray code second code produced ncar incorporated refined versions number dynamics physics routines two codes supposed functionally equivalent expect bitforbit correspondence task quantify discrepancies two models isolate source discrepancies proceeded follows guard configured compare number principal mm5 data arrays initially ran models steps small tolerance value errors reported errors zero indicating codes producing exactly results surprise guard indicated two models providing bitforbit identical results although simple experiment provides encouraging information regarding guards capabilities first confirmed guards ability deal large complex codes mm5 30000 lines length data structures operates also large second ease could perform comparisons look tolerancebased differences nonidentical values impressive third computational overhead using guard proved expected minimal relative execution time numerical model examination finally experiment performed one authors prior figure 4 lowest layer temperature tendency field computed hirpbl left right modifying hirpbl apply 13 iterations columns knowledge structure operation mm5 required 1 hour time initial examination code specification assertions results delivered 52 comparing parallel sequential codes second experiment reported paper used guard compare sequential mm5 singleprocess implementation parallel mpmm preceding case started assumption code incorrect challenge validate assumption determine sources discrepancies preliminary set assertions applied major data structures showed number dif ferences differences initially small grew slowly visualization showed significant spatial structure suggesting due solely floating point rounding incorporating assertions allowed us identify planetary boundary layer scheme subroutine hirpbl source least one error assertions applied input arguments routine showed minor differences concentrated around boundary grid assertions applied output arguments showed larger widespread differences figure 4 localized error hirpbl routine switched manual code inspection soon identified source discrepancy briefly problem turned difference way serial parallel models determined number minor loop iterations required vertical column air grid point given point number iterations vary minimum 2 maximum 13 problem difference subject terrain conditions atmosphere maximum vectorization sequential code first determined maximum number minor iterations entire northsouth strip performed number iterations column strip applying strategy parallel code would introduce unnecessary communication determine maximum number iterations work hence parallel code performed required number iterations column suspecting difference behavior source problems modified sequential parallel codes performed 13 iterations columns comparison modified codes using guard showed discrepancy interior grid disappeared figure 4 result led us conclude observed discrepancy reflect error parallel code rather consequence known allowable difference model codes modifications hirpbl remove differences two models divergence remains almost exclusively around second row column boundary also small secondary discrepancy near northern boundary time progresses influence divergences spreads predictable fashion magnitude remains small believe divergences reflect two additional errors yet unaccounted summary experiment guard allowed us first account one significant discrepancy sequential parallel codes second identify two differences located investigation 53 guard extensions second experiment also served motivate future extensions guard debugger noted mm5 mpmm different code data structures guard able deal different data layouts quite naturally using array index permutations subarray expressions however one aspect code caused difficulty mm5 tends apply code blocks entire rows data grid proceeding next code block contrast mpmm tends invoke much larger code blocks one grid point time consequence differences structure becomes difficult compare array values arbitrary point time following simplified example shows mm5 mpmm 1 compare x i1nlon i1nlon enddo 2 compare x i1nlon i1nlon enddo enddo 3 compare x code fragment left mm5like structure simplicity code blocks single assignments code right mpmmlike structure code block case consists three assignments observing array x incorrect execution code want determine two assignments x introduces error case first assignment turns culprit hence want compare values x code fragment assignment three comparison points marked first third comparisons performed easily second cannot mpmmlike structure first assignment single element always followed second assignment element entire array x never state first assignment applied elements second currently mpmm program code modified store intermediate values temporary array used comparison end first loop mm5 extensions guard automatically handle temporary arrays planned future 6 conclusions relative debugging new debugging paradigm applications undergo evolutionary changes guard debugger supports paradigm key idea provide support automatic comparison program state state reference program known correct relative debugging appears particularly useful scientific computing context complexity scientific models frequent need adapt existing models incorporate new physics algorithms computational techniques applied guard large scientific code mm5 mesoscale atmospheric model obtained satisfactory results able use guard verify two versions sequential mm5 functionally equivalent isolate discrepancies sequential parallel versions mm5 currently working number extensions guard one important direction significantly increase utility support debugging parallel programs another direction motivated mm5 experiments described paper provide support flexible comparison codes different control structures acknowledgments development mpmm supported part usaf epa grateful bill kuo jimy dudhia georg grell making mm5 available us experimental studies performed ibm sp2 argonne national laboratory ibm sp2 queensland parallel supercomputing facility also express gratitude andrew lewis assisting data visualization development guard supported part australian research council ibm australia paper reports collaborative project griffith university argonne national laboratory guard developed griffith university 1994 experments reported paper mostly performed argonne march 1995 work allowed us demonstrate utility guard large scientific codes motivated numerous enhancements guard r summary workshop ncar community climateforecast models efficient debugging primitives multiprocessors economical timedifferencing system numerical weather prediction nonhydrostatic version penn statencar mesoscale model validation tests simulation atlantic cyclone cold front mpmm massively parallel mesoscale model description fifth generation penn statencar mesoscale model mm5 debugger parallel processes debugging concurrent programs parallel implemen tation provide process visualization debugging environment dataflow approach eventbased debug ging debugging tools high level languages design implementation dynascope procedural interface program directing interactive sourcelevel debugging optimized programs tr debugger parallel processes efficient debugging primitives multiprocessors debugging concurrent programs dataflow approach eventbased debugging applicationsdriven parallel io procedural interface program directing linkedlist visualization debugging ctr david abramson greg watson debugging scientific applications net framework future generation computer systems v19 n5 p665678 july
competitive online algorithms distributed data management competitive online algorithms data management network processors studied paper data object file page virtual memory read updated various processors network goal minimize communication costs incurred serving sequence requests distributed data management important classes networkstrees busbased networksare studied optimal algorithms constant competitive ratios matching lower bounds obtained algorithms use different interesting techniques work functions chrobak larmore proc dimacs workshop online algorithms ams 1991 pp 1164 factoring b introduction management data distributed network important much studied problem management science engineering computer systems theory 3 11 dowdy foster 11 give comprehensive survey research area listing eighteen different models many papers data ob ject f file page virtual memory read updated network processors processor may store copy f local memory reduce time required read data object copies must kept consistent however multiple copies increases time required write object read write requests occur processors online algorithm decide whether replicate move discard copies f serving request trying minimize total cost incurred processing requests online algorithm knowledge future requests assumptions made pattern requests apply competitive analysis 6 algorithm let oe denote sequence read write requests deterministic online algorithm said ccompetitive oe ca oe c delta opt ca oe opt oe costs incurred optimal offline solution respectively c b functions independent oe may depend upon input network file size randomized algorithm replace ca oe expected cost consider two types adversaries oblivious adversary chooses oe advance powerful adaptive online adversary builds oe online choosing request knowledge random moves made previous requests oblivious adversary charged optimal offline cost adaptive online adversary serve oe charged online see bendavid et al 6 full discussion different types adversaries algorithm strongly competitive achieves best possible competitive ratio paper focus two important classes networks trees uniform network tree connected acyclic graph n nodes n gamma 1 edges preliminary version paper appeared 19 research att labs 600700 mountain avenue murray hill nj 079740636 usa email lundresearchattcom reingoldresearchattedu westbrookresearchattcom z work performed author yale university research partially supported nsf grant ccr9009753 x department operations research att labs room 3j314 101 crawfords corner road holmdel nj 077333030 usa work performed author yale university research partially supported fellowships yale university emailyanattcom j westbrook yan uniform network complete graph n nodes unit edge weights obtain strongly competitive deterministic randomized online algorithms classes algorithms use different interesting techniques offset functions factoring competitive online algorithms based offset functions found 3server 9 migration problems 10 advantage algorithms need record entire history requests online algorithm since decisions based current offset values updated easily factoring first observed 7 used 10 17 idea break online problem tree single edge problems thus strongly competitive strategies single edge generalized tree algorithms strongly competitive specific applications networks also illustrate two useful techniques randomized algorithm file allocation barely random 20 ie uses bounded number random bits independent number requests random choice made initialization algorithm runs deterministically 11 problem description study three variants distributed data man agement replication 1 7 17 migration 7 10 22 file allocation described framework given undirected graph e nonnegative edge weights jv represents processor let f represent data file page memory stored processors time let r v residence set represent set nodes contain copy f always require r 6 initially single node v contains copy f sequence read write requests occur processors read processor requests examination contents data location f write processor p requests change contents location f location identifies single word record f read satisfied sending message processor holding copy f processor returns information stored requested location write satisfied sending update message processor holding copy f telling modify desired location request served online server decide reallocate multiple copies f integer constant 1 represents number records f 1 costs serving requests redistributing files follows service cost suppose request occurs node v read request served cost equal shortest path distance v nearest node r write request served cost equal size minimum steiner tree 2 contains nodes r fvg movement cost algorithm replicate copy f node v cost times shortest path distance v nearest node copy f discard copy f cost file reallocation consists sequence zero replications discards represent sets reals positive integers nonnegative integers respectively section 2 definition online distributed copies f replications allocations done order long residence set size least 1 movement cost incurred reallocation equal total sum replication costs replication migration problems special cases file allocation migration require 1 replication requests reads assumed replicated copies f discarded offline optimization problem specify r new request served total cost incurred minimized online replication consider competitive algorithms inequality otherwise trivial 0competitive algorithm exists following previous papers allocation related problems adopt lookahead0 model model request revealed online algorithm must immediately pay service cost making changes residence set one may contrast lookahead0 lookahead1 model algorithm may change residence set paying service cost discuss lookahead issue together implementation issues 12 previous related results black sleator 7 first use competitive analysis study problems giving strongly 3competitive deterministic algorithms file migration trees uniform networks strongly 2competitive deterministic algorithms replication trees uniform networks replication imase waxman 14 showed greedy algorithm building steiner trees online thetalog ncompetitive n number nodes ratio optimal within constant factors general networks algorithm basis solution online replication general networks koga 17 gave randomized algorithms 2competitive 4competitive adaptive online adversary trees circles respectively also obtained randomized algorithm competitive ratio depends approaches 11 grows large oblivious adversary trees migration westbrook 22 obtained randomized algorithm uniform networks competitive ratio depends approaches 5 grows large oblivious adversary general networks westbrook 22 obtained strongly 3competitive randomized algorithm adaptive online adversary also obtained algorithm oblivious adversary competitive ratio depends approaches 1 oecompetitive grows large oe 162 golden ratio chrobak et al 10 studied migration various classes metric spaces including trees hypercubes meshes real vector spaces general products trees gave strongly 212dcompetitive randomized algorithms spaces 212dcompetitive deterministic algorithms spaces general lower bound deterministic algorithms 8527 recently bartal et al 4 obtained 4086competitive deterministic algorithm file allocation general networks awerbuch et al 2 bartal et al 5 give ologncompetitive deterministic randomized algorithms adaptive online adversary respectively westbrook yan 23 show bartal et als algorithm ologdgcompetitive unweighted graph diameter dg exists olog 2 dgcompetitive deterministic algorithm bartal et al also find 3 o1dcompetitive deterministic algorithm tree strongly 3competitive randomized algorithms adaptive online adversary tree uniform network since replication special case file allocation upper bounds also valid replication additive constant b zero 4 c lund n reingold j westbrook yan replication migration file allocation randomized uniform e e tree e e paper table state art trees uniform networks note e 13 new results paper contributes following results ffl online file allocation tree give strongly 3competitive deterministic algorithm 21dcompetitive randomized algorithm oblivious adversary show optimal even g edge ffl uniform networks show offline file allocation problem solved polynomial time give strongly 12dcompetitive randomized online algorithm migration oblivious adversary uniform network ffl replication problem show offline problem nphard implies file allocation problem also nphard obtain randomized algorithms e e gamma 1competitive oblivious adversary tree uniform network optimal even g edge albers koga 1 independently obtained results online replication using different method ffl show randomized algorithm replication single edge better 2competitive adaptive online adversary thus kogas 17 algorithm replication tree strongly competitive table 1 summarizes competitive ratios best known deterministic randomized algorithms oblivious adversary replication migration file allocation trees uniform networks optimal 14 lookahead implementation issues stated adopt lookahead0 model used previous work allocation variants studies online problems however used lookahead1 model subsection comment briefly distinction lookahead1 model allocation request sequences could served online algorithm lower cost would possible lookahead0 model example write request occurs lookahead1 algorithm drop one copies f servicing request thereby reducing service cost lookahead0 model appropriate file allocation however service cost models message cost satisfying request includes cost transmitting answer back read request passing update copies message cost control messages must transmitted order algorithm learn new requests implement replication drop decisions specifically assume new replication occur unless least one member replication set told new request processor discard copy unless told new write request claim large values optimal competitive ratio lookahead1 model materially different optimal competitive ratio lookahead0 model particular ccompetitive algorithm using lookahead1 2dcompetitive algorithm using lookahead0 lookahead0 algorithm online distributed simulates lookahead1 algorithm keeping residence set lookahead1 algorithm saves service cost read amount saved distance replicates files prior satisfying request similarly lookahead1 algorithm saves service cost write amount saved weight minimum steiner tree connects dropped copies undropped copy point past least one dropped copies must replicated edge steiner tree hence unit distance saved reads lookahead1 algorithm one file moved one unit distance holds writes total cost saved lookahead1 algorithm 2 times total movement cost algorithms incur movement cost however one may ask whether service cost optimistic could algorithms actually implemented using control messages accounted service cost although directly address issue algorithms essentially distributed nature implemented constant message overhead special case uniform tree networks 2 preliminaries use technique work functions offset functions introduced chrobak larmore 9 let set states one legal residence set thus isomorphic 2 v n fg let rs denote residence set corresponding state 2 say file system state current residence set rs 2 let set possible requests requests node v respectively request sequence revealed online algorithm oe 2 suppose network state oe arrives algorithm charged service cost sers oe sers oe gammar described section 11 serving oe algorithm move different state cost trans gammar minimum cost moving two residence sets work function w minimum cost serving requests 1 terminating state given oe minimum cost solution found dynamic programming algorithm following functional equation suitable initializations let opt optimal cost serving first requests call offset function value state request revealed define deltaopt increase optimal offline cost due oe online algorithms make decisions based current offset values note compute ss deltaopt suffices know igamma1 ss show algorithm ccompetitive need show reachable combination offset function request file system state inequality deltac deltaphi c delta deltaopt holds deltac cost incurred deltaphi change defined potential function total change phi always bounded nonnegative summing inequality oe ca oe c delta opt oe b b bounded value steiner tree problem shall refer network design problem called steiner tree problem stp 24 stated follows instance stp given weighted undirected 6 c lund n reingold j westbrook yan graph e weight function edges 0 subset z v regular nodes terminals constant b decision problem ask exists steiner tree g includes nodes z total edge weight b 0 stp npcomplete even g restricted bipartite graphs unit edge weights planar graphs 12 16 surveys stp found 13 24 tree network union paths pairs terminals gives optimal steiner tree 3 deterministic algorithms fap tree begin introducing concepts used building deterministic randomized algorithms file allocation trees say residence set connected induces connected subgraph g tree residence set always connected node without copy f easily keep track r hence nearest copy f using pointer fact g tree limit attention algorithms maintain connected r times theorem 31 tree exists optimal algorithm always maintains connected residence set ie given online offline algorithm exists algorithm 0 maintains connected r ca 0 oe ca oe oe online 0 proof let ra residence sets maintained 0 spectively simulate oe let 0 time ra 0 minimum connected set satisfies ra given ra tree defined unique reading cost incurred 0 cannot greater holds true writing cost issued node v since spans unique minimum length steiner tree ra fvg 0 incur greater read write cost algorithm 0 need carry replication unless nodes already leave copy f along replication path done without incurring extra cost ra never needs traverse replication path longer replication hence 0 cannot incur greater replication cost since reallocation sequence replications discards f 0 maintains connected set times incur great cost reallocation henceforth shall consider algorithms maintain connected residence set r times say algorithm replicates node v shall mean leaves copy f nodes along shortest path residence set v tree network make additional simplifying assumptions suppose algorithm decides move residence set r 0 set r reallocation involves sequence replications drops lemma 32 replications performed drops without increasing total cost reallocation proof dropping copy increase cost subsequent replications henceforth assume algorithms comply lemma 32 lemma 33 let r nodes gain copy f f replicated nodes order total cost delta jt r 0 subtree induced node set r proof copy f must sent across edge r 0 r least online distributed order replication copy cannot sent across edge endpoints contain copy f henceforth assume algorithms comply lemma 33 useful tool handling online optimization trees factoring 7 10 makes use fact sequence requests oe tree algorithm factored n gamma 1 individual algorithms one edge total cost tree algorithm equal sum costs individual edge game edge b construct instance twoprocessor file allocation follows removal edge b divides two subtrees b containing b respectively read write request node replaced kind request request node b replaced request b let algorithm residence set ra algorithm induces algorithm edge b follows ra falls entirely b edge algorithm state b respectively otherwise edge algorithm state ab edge algorithm changes state minimum cost way ie one replication factoring approach used algorithms file allocation tree rest paper given edge b use b represent subtrees described denote state edge let offset functions triplet offset function value state oe arrived lemma 34 algorithm request sequence oe let ab algorithm induced edge b oe ab request sequence induced edge b ab2e oe ab proof show cost incurred event contributes amount sides equation write request node v ca oe increases weight unique steiner tree 0 containing nodes ra fvg induced problem edge e 0 residence set request node opposite sides e write cost equal es weight incurred edges v residence set lie side e cost incurred induced problems sides equation increase amount read request node v argument write case used replacing 0 unique path v nearest node copy f sides equation increase amount suppose moves residence set r r 0 consider sequence replications discards make reallocation process show induction length sequence movement cost exactly equal sum movement costs induced edge problems suppose first action sequence replicate f node v cost times sum lengths edges shortest path r v since r connected edges path exactly edges must replicate induced problems thus sides equation increase amount first action discard costs incurred induced edge algorithms lemma 35 let opt oe ab cost incurred optimal edge algorithm b sequence oe ab ab2e opt oe ab opt oe proof lemma follows letting lemma 34 optimal offline algorithm fap tree noting ca ab oe ab opt oe ab edge 8 c lund n reingold j westbrook yan b follows lemmas 34 35 online algorithm oe edge b ca ab oe ab c delta opt oe ab holds ccompetitive construct deterministic algorithm tree first construct suitable optimal algorithm single edge design tree algorithm induces optimal edge algorithm edge thereby guaranteeing competitiveness 31 optimal deterministic edge algorithm let edge abg set states file system inonly node copy node b copy b copy respectively assume g unit length otherwise offsets cost functions scaled obtain results write offset functions triplet similarly work functions suppose starting state w dd ser tran functions given table 2 definition offset functions since free discard copy f always b least one b zero without loss generality assume starting offset function vector oe arrived table 3 gives changes offsets different combinations requests offsets response new request oe i1 b ab 0 ab r w b r b w ab table transition service costs case 1 r 0 mink w case 2 r 0 min1 l l 0 table changes offsets let current state r algorithm specifies new required residence set r oe i1 arrived offsets updated assumes state zerooffset state algorithm edge drop b ie set theorem 36 algorithm detedge strongly 3competitive online distributed proof first show request oe j deltac edge holds function phidelta defined let zerooffset state time define potential function initially always phi 0 considered state b phia hold following cases r w r b r algorithm ensures deltac edge 0 cases let use show holds possible combinations state request offset offsets state variable ones new request oe i1 arrives consider k 1 cases similar k 1 oe r w case 1 oe deltaopt last execution algorithm must case 2 oe deltaopt ab must case 3 oe deltaopt 1 case deltac edge 1 deltaphi 2 lhs 3 hold inequality also holds detedge changes state detedge moves state ab state state ab deltaphi gammadeltac edge gammad hence holds possible combinations offsets requests residence set claim deterministic algorithm better 3competitive fap edge migration known deterministic algorithm better 3competitive single edge 7 show given online algorithm fap exists another online algorithm 0 ca 0 oe ca oe oe write requests ii 0 always keeps one copy f node residence set iii whenever one copy f 0 copy node since 0 legal algorithm instance migration problem optimal cost process oe without using replications less optimal cost replications ccompetitive writeonly sequences 0 ccompetitive migration algorithm implies claim algorithm 0 obtained follows initially 0 copy f node following rules applied whenever changes state 1 replicates 0 change state 2 migrates 0 follows 3 drops page 0 follows node follows rules ii iii hold 0 cannot incur write cost higher movement 0 1 2 corresponds distinct migration earlier replication respectively 0 cannot incur higher movement cost claim follows j westbrook yan 32 optimal deterministic tree algorithm recall edge tree request sequence oe induces sequence oe ab b tree algorithm based factoring individual edge subproblems simulating detedge subproblem r 2 oe served edge induced request r ab computed offset vector induced subproblem updated following algorithm executed updating residence set rt ree initially rt ree consists single node containing f algorithm tree 1 examine edge u v order simulate first step algorithm detedge induced subproblem detedge replicates one nodes say v induced subproblem add v rt ree replicate v 2 simulate step 2 detedge edges node v edge algorithm incident edge deleting node v es residence set es induced problem mark v 3 drop marked nodes show dettree 3competitive show chooses connected residence set edge induces state required detedge immediately obvious requirements detedge one edge might conflict another edge example one edge might want drop copy another edge replicated begin analyzing structure offset functions induced edge problems rest subsection offset values functions refers results induced sequence oe ab next lemma characterizes offset distribution two adjacent edges lemma 37 following properties hold time exists root node r corresponds zero offset state induced problems edges b edge x tree define x adjacent edges x z inequality x z holds 8 following earlier definitions see beginning section 32 claim states node r edge b nearer r b state zero offset state edge note location root node r may unique location changes requests lemma implies following conditions corollary 38 edge root r x let z 6 x neighbor edges x z offsets 0 k xy l xy 0 k yz l yz respectively let x z adjacent edges root r subtree rooted formed removing two edges let offsets edges k xy 0 l xy 0 k yz l yz respectively l xy l proof lemma 37 use induction number requests initially let r node holding single copy f edges offset vectors 0 dd lemma holds trivially assume lemma holds revealed requests show remains valid oe t1 arrived node w first show locate new root let p represent path r w unless specified otherwise offsets referred ones oe t1 arrives choose new root r 0 using following procedure procedure findroot 1 r edges along p offsets 2 otherwise move along p r toward w cross edge offset vector form 0 0 l cannot go w reached pick node stop r 0 let us show r 0 valid root new offsets picture p chain edges starting r going left right ending w condition step 1 algorithm satisfied oe t1 corresponds request zero offset state edges table 3 r remains valid root node suppose 2 executed edge p p right r 0 zerooffset state remains node r 0 valid root node edges c4 edges along p offsets form 0 0 l must form connected subpath p starting r ending r 0 value parameter l table 3 offsets change 0 0 l 1 0 minfl min1 l 0 l r 0 valid root node hence holds choice r 0 show b holds consider two adjacent edges x z whose removal divide three disjoint subtrees x z roots z respectively show different possible positions r w b remains valid oe t1 arrived ie t1 x t1 z holds oe t1 write read r z assume holds oe t1 arrives suppose oe t1 read request r 2 x w 2 x edge condition b shown hold situations similar case analysis please refer appendix complete case analysis thus b holds request lemma follows theorem 39 algorithm dettree strongly 3competitive proof show dettree induces detedge tree edge theorem follows lemmas 34 35 theorem 36 proceed induction number requests initially rt ree consists single node suppose rt ree connected first 2 z edge b state induced rt ree equal state desired detedge run oe ab consider processing request 1 step 1 replication subinduction number replications done step 1 show replication conflict state desired edge suppose processing edge b step 1 causes f replicated lies b inducing state definition detedge definition induced subproblem inductive hypothesis let q path b nearest node rt ree q 6 fbg avoid conflict edge along q must also require replication across c2 theorem 37 see edge x q 12 c lund n reingold j westbrook yan offset form nearer b requires replication similar argument holds case step 2 marking nodes drop perform subinduction number markings done step 2 show marking conflict state desired edge connected residence set results suppose processing edge b step 2 causes b marked occurs b since rt ree connected hypothesis b rt ree nodes b copy f span connected subtree b b root let us call 0 b 0 b 6 fbg edge x 0 b state xy c3 theorem 37 x must offset nearer b detedge x needs drop copy f node hence nodes 0 b required removed rt ree new rt ree remains connected edges conflict thus rt ree connected induced edge algorithms match detedge dettree 3competitive 4 randomized algorithms fap tree approach building randomized tree algorithm approach deterministic case give randomized algorithm twopoint space randedge based counter values assigned nodes factoring obtain randedge 21dcompetitive algorithm randtree file allocation tree randtree requires generation ologd random bits beginning algorithm runs completely deterministically simpler tree algorithm 19 require generation ofomegagamma29 random bits request served 41 optimal randomized edge algorithm randedge let edge b maintain counters c c b nodes b respectively satisfy algorithm maintains distribution r dependent counter values initially node copy f counter value node counter value 0 counter values change according following rules read request increment c c write request c increment c counters change similarly request b change counter values cases algorithm randedge always maintains distribution r 1a 1c observe probability copy f node v 2 fa bg c v order maintain distribution randedge simulates deterministic algorithms numbered 1 moves deterministic algorithm constructed deterministically online according rules given first request one algorithms picked random randedge makes online distributed moves chosen deterministic algorithm thus p e 2 fa b abg proportion algorithms state expected cost incurred randedge average costs incurred algorithms define algorithms achieve probability distribution 1 suppose initially node copy f initially algorithms placed state following changes made new request oe arrived without loss generality assume request arises node c c b values refer counter values oe arrives ffl change algorithms change counter values lowestnumbered algorithm state b moves state ab ffl case 2 oe lowestnumbered algorithm state ab moves state ffl case 3 oe lowestnumbered algorithm state b moves state ab lemma 41 randedge feasible maintains probability distribution 1 proof feasible mean whenever move must made cases 1 2 3 algorithm available make move choice lowestnumbered algorithm emphasize choice must independent algorithm randedge actually emulating lemma holds initially c c prove lemma induction requests assume holds oe arrives change counter values oe arrived lemma holds trivially induction hypothesis case 1 since c p e b 0 least one algorithms state b case 2 since c algorithm state ab case 3 since c algorithm state b hence randedge feasible verified changes algorithms implement probability distribution 1 new counter values theorem 42 randedge strongly proof node v 2 fa bg maintain potential function opt copy f v otherwise opt represents adversary let overall potential function time phi 0 show response request change state edeltac randedge 2 holds deltaop edeltac randedge edeltam cost incurred event opt service movement costs incurred randedge respectively c c b values counter values new request oe arrives case 1 request oe c inequality 2 holds trivially suppose c edeltac randedge 14 c lund n reingold j westbrook yan opt copy f otherwise follows opt copy f oe arrives otherwise inequality 2 holds case 2 request oe edeltac randedge opt copy f b gammac b opt copy f b inequality 2 holds case 3 request oe c lhs20 2 holds trivially suppose c edeltac randedge c opt copy f ae 0 opt copy f otherwise hence 2 holds case 4 opt changes state opt changes state edeltac randedge checked definition phi opt replicates deltaop opt discards copy f deltaphi 0 since 2 holds possible events theorem 46 randedge strongly 42 optimal randomized tree algorithmrandtree extend randedge randomized algorithm fap tree means factoring algorithm randtree induces randedge edge induced request sequence edge description algorithm randtree randtree internally simulates deterministic algorithms maintains residence set spans subtree initially residence set single node contains f one simulated algorithms picked uniformly random beginning randtree behaves exactly particular algorithm chosen maintain counters c c b edge b tree using factoring approach see section 32 obtain induced request sequence oe ab b counter values change according rules described single edge case section 41 using oe ab randtree responds request maintains induced distribution required randedge 1 edges read request suppose new request oe read request node g let rooted g edge nearer g b c c b values described counter values oe arrives edges classified three types 2 edges c c b 0 3 edges c randedge requires change probability values first two types edges type 3 edges requires p e b decreases 1d p e ab goes 1d node v use v denote subtree rooted v randtree changes subtree configurations maintained algorithms using following procedure fig 1 1 let f forest trees formed type 3 edges 2 exists tree 0 2 f least one edge let x leaf node 0 p path x root node 0 root node 0 node 0 nearest g 22 pick one algorithms maintains subtree z includes node x lies entirely x make algorithm replicate along p ie replace z z p remove edges p 0 update forest f fig 1 algorithm randedge read requests lemma 43 randtree implements required changes edges read request proof prove lemmaby induction requests suppose randtree induces randedge edges oe arrives let parent node x randtree feasible ie executed implements changes required randedge described edges show case x leaf node since x type 3 edge p xy x 0 one algorithms must single node fxg tree configuration otherwise suppose descending edges x type 1 let x w one p xw none algorithms maintains subtree edge x since p xy x 0 one algorithms must fxg subtree otherwise suppose x descending type 2 edges let x w one thus edges contained subtree least one algorithms none algorithms subtree w since p xy x 0 least one subtrees must lie x contains node x hence algorithm feasible lemma holds write request suppose oe use notation read request case edges classified three types 2 edges c 3 edges c j westbrook yan randedge requires change probability values type 3 edges type 1 edges requires p e ab decreases 1d p e increases amount decreases 1d p e ab increases amount randtree performs following fig 2 1 let f forest trees formed type 1 edges 2 exists tree 0 2 f least one edge 0 root node 0 x one children nodes 22 pick algorithm subtree z includes edge g z contained 0 make algorithm replace z singlenode replace z tree formed edges z gamma 0 replace 0 f subtrees formed 3 let f forest trees formed type 2 edges 4 exists tree 0 2 f least one edge 41 let x leaf node 0 p path x root node 0 42 pick one algorithms maintains subtree z includes node x lies entirely x make algorithm replicates along p ie extends z z p 43 remove edges p 0 update forest f fig 2 algorithm randedge write requests lemma 44 randtree implements required changes edges request proof prove induction assume randedge induced edges oe arrives randtree feasible implements required changes edges show case consider first loop algorithm step 2 since p g 0 x g 0 x 0 subtree z must exist randtree removes edges z contained 0 note p e ab values type 2 3 edges zero randtree processes edges 0 topdown fashion configuration connected subtree thus first loop executed consider second loop algorithm step 4 let parent node x p xy x leaf node one algorithms must fxg subtree x descending type 1 edge first part algorithm one algorithms must fxg subtree running first loop algorithm suppose descending edges x type 3 edges let x w type 3 edge p xw one algorithms must fxg subtree hence algorithm feasible lemma follows lemmas 43 44 imply randtree induces randedge edges theorem 45 follows lemmas theorem 42 theorem 45 algorithm randtree strongly 1dcompetitive fap tree oblivious adversary 43 lower bound show competitive ratio best possible file allocation oblivious adversary even g single edge theorem 46 online algorithm file allocation problem two points b ccompetitive c 2 proof let randomized algorithm file allocation problem two points define potential function psi give strategy generating adversary request sequences c request sequence oe optimum cost c ii cost randedge oe least 2 independent oe iii psi bounded iv request generated adversary conditions ii iii iv hold adversary sequence oe summing 3 sequence gives b bounded condition adversary make opt oe arbitrarily large constant b 0 independent oe ca opt oe b 0 hence cannot ccompetitive c define adversarys strategy assume online offline algorithms start single copy f adversary generate requests result offset functions form 0 zerocost selfloop request offset function unchanged deltaopt 0 theorem 18 always optimal online algorithm incurs 0 expected cost zerocost self loop assume property simplifies adversarys strategy although result still proved without assumption suppose current offset function 0 let p probability randedge state suppose state probability q q p adversary requests w otherwise adversary requests b r zerocost selfloop adversary request b r similarly r zerocost selfloop adversary requests w therefore adversary always generate next request using rules request sequence made arbitrarily long since offset functions generated strategy arbitrarily long sequence requests must cycle offset functions arbitrarily often notice however cycles cost opt nothing zerocost selfloops since adversary never uses requests cycles nonzero cost continuing long enough adversary generate request sequences arbitrarily large optimum costs hence condition hold next consider condition ii recall c c b counter values maintained randedge claim offset function 0 true initially f located inspection randedge one verify whenever adversary generates request b r c b increases 1 whenever adversary generates w c b decreases 1 hence expected movement cost incurred randedge 1 b r 0 w reference proof theorem 42 note amortized cost randedge exactly 21d times cost opt request adversary might generate assuming opt move following request adversary never generates b r c w c 0 amortized cost incurred j westbrook yan randedge therefore exactly 21d times cost incurred optimum algorithm ever copy f possible show cost really optimum sequences case certainly lowerbounded true optimum cost ii holds define psi delta maxf0 g trivially bounded 1 iii holds finally must verify 3 case 1 adversary requests w case new offset function must 1 suppose request mass q 0 deltac case 2 adversary requests b r case new offset function must 0 1 suppose request mass q 0 deltac 5 migration uniform network give 12dcompetitive randomized algorithm oblivious adversary migration uniform net work competitive ratio optimal even single edge 10 let g complete graph n nodes labeled 1 n initially node 1 copy f algorithm based offsets calculated online let ng algorithm state single copy f node cost functions ae ae otherwise initially w suppose ith request served new offset node calculated algorithm migrate algorithm maintains probability distribution probability ps node contains f follows new request arrived algorithm moves different states transition probabilities minimize total expected movement cost maintaining new required distribution theorem 51 given oe expected cost incurred migrate ec mig oe satisfies proof show request arrived holds edeltac mig expected cost incurred migrate edeltam expected movement cost deltaphi change potential function vs initially time since least one v offset table similar table 3 file allocation constructed since migration equivalent fap write requests seen request oe i1 node offsets states increase one subject maximum deltaopt node offset state decrease one offsets remain deltaopt case 1 request v case deltaopt increases one k edeltac mig verified edeltam 12 deltaphi movement cost zero also edeltac mig case 2 request v deltaopt decreases 1 deltaphi 12 edeltam probability mass hence 6 replication give upper lower bounds performance randomized online algorithms replication problem 20 c lund n reingold j westbrook yan 61 randomized online algorithms let e e e gamma 1 fi gammaee gamma 1 158 dgamma1 describe randomized algorithms fi dcompetitive oblivious adversary uniform network trees first consider single edge r b unit length initially r contains copy f suppose algorithm ffcompetitive replicates f node b probability ith request b 1 p ff must satisfy k 2 z expected cost incurred oe contains k requests b optimal offline strategy replicate copy f b first request arrives k replicate otherwise algorithm incurs cost replicates right serving ith request k otherwise incurs cost k optimal randomized algorithm given set p values satisfy inequalities k ff minimized note conditions identical online block snoopy caching problem two caches 15 karlin et al 15 showed optimal ff value fi achieved zero single edge algorithm applied uniform network replicating f node v ith request v probability p another example factoring theorem 61 exists randomized algorithm strongly fi competitive oblivious adversary replication uniform network extend single edge algorithm tree rooted r node contains f initially algorithm responds requests nodes current residence set algorithm tree keep counter c node 6 r initially request arrives node x w node nearest x contains copy f serving request counters nodes along path w x increased one let nodes along path perform following procedure time request served 1 2 replicate node j node j gamma1 22 f replicated j stop theorem 62 algorithm tree strongly fi competitive oblivious adversary replication tree network proof without loss generality assume connected r always maintained solution let x 6 r node parent x obtains copy f cost equal weight x incurred edge request node subtree rooted x follows r connected unique path x r passes x single edge algorithm algorithm tree fi competitive node x 6 r copy f replicated x ith request subtree rooted x probability p shown induction requests x acquires copy f counter x records number requests arrived subtree rooted x counters form nonincreasing sequence path moving away r hence values p c j defined probability values simple verify time node subtree rooted x receives request copy f replicated x probability p cx c x xs new counter value theorem follows 62 lower bound show randomized algorithm better 2competitive adaptive online adversary use n denote number nodes g theorem 63 let ffl positive function n taking values 0 1 online algorithm better ncompetitive replication adaptive online adversary proof let node initial copy f let b edge g let online algorithm replicates b jth request b probability adversary issues requests b replicates issued whichever first happens algorithm incurs expected cost choose different n two different cases suppose minimum positive integer greater given parameter n finite unique constant adversary replicates b first request arrives incurring cost equation 5 eca oe giving ratio least 2 suppose adversary replicate incurs expected cost 5 7a given p j one choose n arbitrarily close 1 since series one also choose n arbitrarily close zero thus comparing 6 7b see given one choose finite n ratio close 22 c lund n reingold j westbrook yan 7 offline replication file allocation show offline replication problem nphard offline file allocation problem uniform network solved polynomial time 71 offline replication problem awerbuch et al find interesting relationships online steiner tree problem 14 23 online fap show offline replication problem nphard using straightforward reduction steiner tree problem 12 16 see section 2 definition proof involves creating instance replication problem requests issued terminal nodes steiner tree problem instance forcing optimal algorithm replicate nodes theorem 71 replication problem nphard even g bipartite unweighted g planar 72 offline solution file allocation uniform network show offline file allocation problem uniform network solved polynomial time reducing mincost maxflow problem similar reduction obtained chrobak et al 8 kserver problem convert instance fap uniform network nodes mincost maxflow problem acyclic layered network n delta joej nodes 2 joej arcs initially node 1 copy f integral maximum flow n defines dynamic allocation f uniform network arcs costs n chosen mincost maxflow n incurs cost differs minimum cost fap uniform network constant network n constructed follows nodes network n joej layers nodes nodes layer source node sink node layer k 0 k joej nodes fv k n g ngamma1 g node allows maximum flow one unit nodes correspond nodes uniform network layer k n corresponds state uniform network oe k served arcs arc going layer k node layer arc layer joej node arc v 0 1 arcs unit capacity flow maximum flow n value n given integer arc costs mincost maxflow solution integral flow either 0 1 arc flow 1 v k j represents presence copy f node j request arrives flow comes v kgamma1 represents copy f moved node node j serving 1st request flow comes u kgamma1 represents replication node j flow v kgamma1 j u k w represents copy f j dropped oe kgamma1 served thus integral flow n defines strategy relocating copies f since n gamma 1 u nodes layer integral maxflow must include flow 1 unit least one v nodes layer corresponds requirement always least copy f uniform network edge costs edge costs chosen optimal flow cost equal optimal offline cost fap minus number read requests j oe arcs one end point zero costs let b arc going layer k k1 cost equal sum associated movement service costs suppose b v k1 bs associated movement cost unless oe k1 write node node service cost read node service cost gamma1 costs cases zero movement service costs account cost replication serving requests except node charged gamma1 read request arrives copy f add j cost optimal flow thus charging read request 1 advance sum equal cost optimal dynamic allocation f using algorithm 21 solving mincost maxflow problem acyclic networks fap uniform network solved polynomial time theorem 72 optimal offline file allocation uniform network found 3 8 open problems interesting open problems include finding strongly competitive randomized algorithm fap uniform network awerbuch et al 2 conjecture exists c n competitive algorithm online steiner tree problem 14 23 exists ocncompetitive deterministic algorithm fap conjecture still open migration problem gap best known bounds 4 10 r competitive distributed file allocation dynamic file migration distributed computer systems page migration relaxed task systems competitive algorithms distributed data manage ment power randomization online algorithms competitive algorithms replication migration prob lems new results server prob lems server problem online games page migration algorithms using work functions comparative models file assignment problem rectilinear steiner tree problem npcomplete dynamic steiner tree problem competitive randomized algorithms nonuniform problems reducibility among combinatorial problems randomized online algorithms page replication problem linear programs randomized online algorithms randomized competitive algorithms data structures network algorithms randomized algorithms multiprocessor page migration performance greedy algorithms online steiner tree related problems steiner problem networks survey tr ctr baruch awerbuch yossi azar yair bartal online generalized steiner problem theoretical computer science v324 n23 p313324 20 september 2004
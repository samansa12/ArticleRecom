massively parallel fault tolerant computations syntactical patterns general capabilities reliable computations linear cellular arrays investigated terms syntactical pattern recognition consider defects processing elements defects communication links particular processing element cell assumed behave follows dependent result selfdiagnosis stores working state locally becomes visible neighbors defective cell cannot modify information able transmit unchanged unit speed cells link failures able receive information via one links adjacent cells moreover static dynamic defects distinguishedit shown fault tolerant realtime recognition capabilities twoway arrays static defects characterizable intact oneway arrays oneway arrays fault tolerant per se arrays dynamic defects proved failures compensated long number adjacent defective cells boundedin case arrays link failures shown sets patterns reliably recognizable strictly sets intact oneway intact twoway arrays b introduction nowadays becomes possible build massively parallel computing systems consist hundred thousands processing elements single component subject failure probability misoperations loss function whole system increases number elements von neumann 19 rst stated problem building reliable systems unreliable components biological systems may serve good examples due necessity function normally even case certain failures components nature developed mechanisms invalids errors words working sense fault tolerant error detecting correcting components global whole system subject failure therefore fault tolerance design feature single elements model massively parallel homogenously structured computers cellular arrays devices interconnected parallel acting nite state machines studied various points view 4 5 reliable arrays constructed assumption cell links time step fails constant probability moreover failure incapacitate cell permanently violates rule operation step occurs constraint cells links fail ie cannot process information still able transmit unchanged unit speed fault tolerant computations investigated eg 6 14 encodings established allow correction socalled kseparated misoperations 9 10 17 20 famous ring squad synchronization problem considered defective cellular arrays terms interacting automata nonuniform delay 7 11 synchronization networks main object either interested general computations terms pattern recognition general capabilities reliable computations considered since cellular arrays intensively investigated language theoretic point view pattern recognition language acceptance establishes connection known results thus inheres possibility compare fault tolerant capabilities non fault tolerant ones sequel distinguish three dierent types defects static defects main object section 3 assumed cell selfdiagnosis circuit run actual computation results stored locally cells subsequently new defects may occur otherwise whole computation would become invalid defective cell cannot modify information able transmit unit speed otherwise parallel computation would broken two non interacting parts therefore would become impossible section 4 defects generalized cellular arrays dynamic defects may happen cell becomes defective time formalization corresponding arrays includes also possibility repair cell dynamically remaining sections concern another natural type defects cells cause misoperation communication links assumed defective cell able receive information via one links adjacent cells corresponding model introduced section 5 detail section 6 shown realtime arrays link failures able reliably recognize wider range sets patterns intact oneway arrays order prove result auxiliary algorithmic subroutines given section 7 concludes investigations showing devices link failures strictly weaker twoway arrays hence link failures cannot compensated general hand decrease computing power one oneway arrays following section dene basic notions recall underlying intact cellular arrays mode pattern recognition preliminaries denote integers z positive integers f1 2 g n set n f0g n 0 x 1 x denotes cartesian product sets use notion x alternatively use inclusions inclusion strict let set function denote ifold composition f f twoway resp oneway cellular array linear array identical nite state machines sometimes called cells connected nearest neighbors resp nearest neighbor right array bounded cells distinguished socalled boundary state convenience identify cells positive integers state transition depends current state cell current states neighbors transition function applied cells synchronously discrete time steps formally denition 1 twoway cellular array ca system hs ai 1 nite nonempty set cell states 2 boundary state 3 set input symbols local transition function ow information restricted oneway ie right left resulting device oneway cellular array oca local transition function maps fg 2 conguration cellular array time 0 description global state actually mapping c data cellular arrays operate patterns built input symbols since studying onedimensional arrays input data nite strings words set strings length n built symbols set denoted n set nite strings denote empty string reversal string w w r length write jwj set dened n fg sequel interested subsets strings recognizable cellular arrays order establish connection formal language theory call subset formal language moreover sets l l 0 considered equal dier empty word ie l n prepared describe computations ocas operation starts socalled initial conguration c 0w time 0 symbol input string fed one cell c 0w computation oca steps sequence congurations whereby successor congurations computed according global transition function conguration successor conguration follows c t1 c t1 cas c t1 ocas thus induced input string w recognized oca time course computation leftmost cell enters nal state set nal states f denition oca f set nal states 1 input w 2 recognized time step conguration c 2 recognizes w time stepg set strings language recognized 3 mapping recognize w 2 lm within tjwj time steps said time complexity family sets recognizable ca oca time complexity denoted l ca l oca equals identity function recognition said realtime equal k id arbitrary rational number k 1 recognition carried lineartime correspondingly write l rt oca l lt oca sequel use corresponding notations types recognizers going explore general recognition capabilities cas contain defective cells defects sense static 17 assumed cell selfdiagnosis circuit run actual computation result diagnosis stored special register cell intact cells detect defective neighbors moreover static part assumed actual computation new defects may occur otherwise whole computation would become invalid eect defective cell reasonable require defective cell cannot modify information hand must able transmit information order avoid parallel computation broken two interacting lines thus impossible speed information transmission one cell per time step another point view devices dene transmission delay every two adjacent cells allow nonuniform delays 7 11 number defective cells two intact ones determine corresponding delay since selfdiagnosis run actual computation may assume defective cells fetch input symbol nevertheless realtime minimal possible time needed nontrivial computations consequently dened number cells array order obtain computation result require leftmost cell defective later omit assumption formally denote cas static defects sdca corresponding language families l sdca considering general realtime recognition capabilities sdcas best case trivial occurs cells intact capabilities cas hand fault tolerant computations concerned worst case respect assumptions model next two results show cases capabilities characterized intact ocas follows bidirectionality information ow gets lost theorem 3 set fault tolerant realtime recognizable sdca realtime recognizable oca proof let sdca let k 2 n arbitrary positive integer set number cells 1 mapping f ng assume cells positions fi 1 k intact ones cells defective cf figure 1 cells fi fi fi fi defective ones realtime computation states cell fi time 2 cannot uence overall computation result states would reach leftmost 1 2 1 3 2 1 0 4 3 2 1 5 4 3 2 1 0 b 5 b 4 b 3 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 b 7 8 7 6 5 4 3 2 1 9 8 7 6 5 4 3 9 8 7 6 5 9 8 7 12 11 10 9 13 12 11 14 13 15 figure 1 oneway information ow sdcas cell another fi steps gives arrival time greater realtime conversely cell fi computes states time independently states intact neighbors left nearest intact neighbor left cell fi1 2 1 defective cells shown information ow oneway compared ocas cells performing state changes remains show lead stronger capabilities let intact cell long operates independently intact neighbors runs state cycles provided adjacent defective regions long enough let cycle one always enlarge lengths defective regions correspond j therefore isolated computations cells run complete cycles obviously behavior simulated cells oca since cycle lengths bounded number states 2 order obtain characterization realtime sdcas realtime ocas need converse theorem 3 theorem 4 set realtime recognizable oca fault tolerant realtime recognizable sdca proof idea simulation depicted figure 2 cell sdca simulates given oca waits rst information right intact neighbor waiting period signaled left intact neighbor signals labeled information leads waiting period left intact neighbor intact cell performs simulation step receives nonwaiting signal follows cell sends exactly many waiting signals left defective cells located right therefore leftmost cell needs exactly one simulation step intact cell one waiting step defective cell thus computes result realtime 2 0 0 0 0 0 0 0 0 1 1 1 2 3 4 figure 2 oca simulation sdcas following corollary formalizes characterization corollary 5 l rt previous results follows interesting fact ocas per se fault tolerant additional defective cells decrease recognition capabilities corollary 6 l rt often useful examples string sets recognizable certain device example 7 neither set duplicated strings fww set strings whose lengths power 2 fw fault tolerant realtime recognizable sdcas shown 13 resp 15 belong family previous results imply another natural question possible regain recognition power twoway cas fault tolerant sdca computations increasing computation time much additional time would necessary 3 18 shown oca simulate realtime computation twice realtime input word reversed open problem whether l rt ca closed reversal nevertheless piece good news one additional time step intact cell necessary order regain computation power fault tolerant manner theorem 8 set recognizable oca twice realtime thus reversal ca realtime fault tolerant recognizable sdca realtimem denotes number intact cells proof let l set recognizable oca twice realtime denote length input word n let us consider situation proof theorem 4 realtime corresponding sdca simulated n steps corresponding oca due previous delay delay intact cells necessary thus next n steps oca simulated n steps sdca either since number intact cells exactly n part follows let l set recognizable sdca time realtimem follow idea proof theorem 3 distance two intact cells enlarged number intact cells right left distance cells enlarged least 2 1 1 order prevent additional ow information 2 one assumption model intact leftmost cell due corollary 5 omit requirement overall computation result indicated leftmost intact cell oneway array operates per se independently defective left neighbors following cellular arrays dynamic defects ddca introduced dynamic defects seen generalization static defects becomes possible cells fail time computation afterwards behave case static defects order dene ddcas formally helpful suppose state defective cell pair states intact one one component represents information transmitted left one information transmitted right formalization obtain type indication cells defective free defective cells always states 2 intact ones states possible failure implies weak kind nondeterminism local transition function denition 9 twoway cellular array dynamic defects ddca system hs ai 1 nite nonempty set cell states satises 2 boundary state 3 set input symbols sg local transition function satises cell works ne local transition function maps state otherwise maps pair 2 indicating cell defective denition includes possibility repair cell computation case would map pair state note nondeterminism real computation determinism since failure repair cell sense control outside world assume initially cells intact static case leftmost cell remains intact sequel call adjacent subarray defective cells defective region next results show dynamic defects compensated long lengths defective regions bounded theorem 10 set realtime recognizable ca realtime recognizable ddca lengths defective regions bounded k 2 n 0 proof assume moment lengths defective regions exactly k ddca simulates given ca hs ai state set general idea proof depicted figure 3 long cell detect defective neighbor stores states neighbors state additional registers shown gure time state cell might follows center assume right neighbor cell becomes defective due assumption know must exist defective region length k right cell next k time steps cell stores received states computes missing states register contents shown figure 3 subsequently state might follows z center 0 1 0 0 c e c e t1 c c t1 e c e e t1 t1 t2 c t2 c t3 t3 e t2 t3 c t4 figure 3 compensation cell receives states intact cell time able compute necessary intermediate states register contents crucial point lengths defective regions xed k due assumption cell knows receives valid states next intact neighbor ik1 k 1 relax assumption required lengths k cells following extension simulation cell equipped modulo k counter since current value counter part cell state also part transmitted information cell stores received information additional registers stores also received counter value decide whether receives valid state next intact neighbor comparing received counter value latest stored counter value equal received information defective cell otherwise valid cell uses additional registers new failures subsequent time steps detected method received counter value equal latest stored counter value additional cells become defective cases cell uses correspondingly additional registers order compensate new defects remains explain happens two defective regions joint failure single connecting intact cell used transmitted contents main registers actually whole state ie register contents transmitted case question next intact cells left right joint defective region additional registers desired 2 corollary 11 set realtime recognizable oca realtime recognizable ddoca lengths defective regions bounded k 2 n 0 order provide evidence general fault tolerant ddca computations relax assumption bounded defective region lengths concerned worst case hardest scenario follows initially cells intact thus fetching input symbol rst time step leftmost cell fail needless say leftmost cell becomes also defective nobody would expect reasonable computation result easy see cases recognition capabilities ddcas single cell nite state machine see figure 4 lemma 12 set fault tolerant recognizable ddca recognizable nite state machine thus regular corollary 13 set fault tolerant recognizable ddoca recognizable nite state machine thus regular 5 devices link failures section 3 shown cas defective cells case large adjacent defective regions bidirectional information ow gets lost means fault tolerant computation capabilities twoway arrays oneway arrays observation gives rise investigate cellular arrays defective links order explore corresponding general 1 5 g 0 6 7 8 figure 4 worst case ddca computation reliable recognition capabilities take closer look device question assume cell selfdiagnosis circuit links run actual computation result diagnosis indicated states cells intact cells detect defective neighbors eect defective link suppose two adjacent cells interconnected two unidirectional links one link information transmitted right left one left right links failing parallel computation would broken two interacting lines thus would impossible therefore reasonable require least one links two cells fail suppose moment exists cell due link failure cannot receive information right neighbor would imply overall computation result indicated leftmost cell obtained regard input data right defective cell reliable computations would trivial order avoid problem extend hardware cell detects right left link failure able reverse direction intact link thereby always concerned defective links cannot transmit information left right another point view devices cells twoway array behave like cells oneway array sometimes sequel call ocacells result selfdiagnosis indicated states cells therefore partitioned state set denition 14 cellular array defective links moca system partitioned nite nonempty set cell states satisfying 2 boundary state 3 set input symbols 4 2 n 0 upper bound number link failures 5 local transition function intact cells local transition function defective cells reliable recognition process compute correct result distributions defective links advance course known links fail therefore mocas set admissible start congurations follows input string conguration c 0w admissible start conguration moca exists set ng defective cells jdj c 0w ng n c 0w clear understanding dene global transition function mocas follows let c 0 conguration moca defective cells successor conguration follows c t1 c t1 c t1 c t1 c t1 c t1 due denition computation started set remains xed meets requirements model following going answer following questions link failures reduce recognition power intact cas possible compensate defects modications transition function shown cas defective cells mocas recognize wider range string sets intact ocas 6 mocas better ocas inclusions l rt oca l rt moca l rt ca following immediately denitions aim prove inclusions strict 61 subroutines order prove realtime mocas powerful realtime ocas need results concerning cas ocas later serve subroutines general construction 611 time constructors strictly increasing mapping f n n said time constructible exists ca arbitrary initial conguration leftmost cell enters nal state time steps fj 1 j n corresponding ca called time constructor f therefore able distinguish time steps fj following lemma shown 1 lemma 15 mapping proof idea proof depicted figure 5 initial time leftmost cell ca sends signal speed 13 right next time step second signal established runs speed 1 bounces slow signal left border cell leftmost cell enters nal state every time step receives fast signal correctness construction easily seen induction 2 figure 5 time constructor 2 n general investigation time constructible functions found eg 12 2 especially exists time constructor 2 n works area n cells actually need time constructor mapping 2 2 n fortunately 12 closure functions composition shown corollary 16 mapping exists corresponding time constructor works area 2 n cells 612 binary ocacounters need set adjacent cells oca binary counter actually interested value counter time step ows due information ow rightmost cell counter contain least signicant bit assume cell identify order realize simple counter every cell three registers cf figure 6 third ones working modulo 2 second ones signaling carryover left neighbor rst ones indicating whether corresponding cell generated carryover 0 one carryover 1 one carryover 2 whole counter tested leftmoving signal travel counter rst registers containing 0 additionally carryover registers leftmost cell containing 1 recognizes desired time step observe need second carryover register order check counter produces ow rst time figure binary ocacounter figure 7 binary cashiftright counter 613 binary cashiftright counters type counter need twoway information ow set single leftmost cell ca since require least signicant bit rightmost bit counter extend counter every time produces ow principle depicted figure 7 cell two registers one corresponding digit one indication carryover due twoway information ow leftmost cell identify every time generates carryover counter extended purpose leftmost cell simulates additional cell left appropriately fact signals right neighbor need extend counter one cell right neighbor reacts simulating addition old process leftmost cell computes new signicant bit arrival extension signal rightmost cell counter extension physically performed rst cell right counting cells computes least signicant bit obviously checked leftmoving signal whether counter represents power 2 62 proof strictness inclusion prepared prove main result section let set strings l dened follows easy part show l belong l rt oca lemma proof 8 shown mapping f property lim set strings fb n fn j n 2 ng belong l rt oca applying result l obtain lim therefore remains show l realtime recognizable moca theorem proof following realtime 1oca recognizes l constructed input data b n concerned three possible positions unique defective cell 1 position within bcells 2 position within leftmost 2 n acells 3 position right hand side 2 n th acell beginning computation starts following tasks parallel tracks unique defective cell establishes time constructor 1 acell leftmost acell establishes another time constructor additionally binary shiftright counter c 1 counts number rightmost bcell starts binary ocacounter c 2 nally rightmost acell sends stop signal speed 1 left according three positions following three processes superimposed case 3 cf figure 8 shiftright counter increased 1 every time step stop signal arrives ow causes incrementation 1 counter c 2 let time step stop signal arrives shiftright counter c 1 let l number digits c 1 next l time steps signal travels counter tests whether value power 2 subsequently signal tests another n time steps whether value binary counter c 2 exactly 2 n l 2 n follows tests successful input accepted input string form b n l 2 l thus belongs l oca b b overflow figure 8 example case 3 case 2 cf figure 9 case space bs defective cell small setting appropriate counter shown case 3 second binary counter c 3 within bcells used increased 1 every time step receives signal defective cell thus contains number cells bcells defective cell value x conserved additional track moreover every time step time constructor 1 marks defective cell nal signal sent bcells causes reset counter value x copying conserved value back counter track reset counter increased 1 every time step reset signal also marks unmarked bcell input accepted exactly arrival stop signal leftmost oca b b overflow f f f f f f f overflow figure 9 example case 2 cell counter ows rst time bcells marked let last marking 1 happen time r 2 n corresponding leftmoving signal arrives time 2 2 r x bcells resets counter c 3 x stop signal arrives time 2 2 r n counter value x since counter produces ow holds moreover since 1 sent exactly r marking signals bcells marked follows therefore stop signal arrives rightmost bcell time 2 2 r input belongs l case 1 since binary counter 3 within bcells ocacounter works ne even defective cell located within bcells case 1 straightforward adaption case 2 2 used instead 1 2 corollary 19 l rt oca l rt 1oca result generalized devices bounded number defective cells follows theorem 20 let 2 n constant l 2 l rt moca proof defective cells located within bcells within rst within last 2 2 n acells proof follows three cases proof theorem 18 otherwise concerned two cases case 4 leftmost defective acell within rst 1 acells standard compression techniques simulate cells one construction case 3 proof theorem solves case case 5 leftmost defective acell within rst 1 acells order adapt case 2 previous proof due corollary 16 may assume time constructor 2 n works n cells standard compression techniques obtain 1 cells according assumption defective cells within rst 2 n cells two defective cells distance 1 cells allows us use compressed time constructor area remaining construction shown case 2 beginning computation know area possible areas related one order determine start time constructors defective cell able choose correct track successful computation set recognized one time constructors recognizes input 2 corollary constant l rt oca l rt moca 7 cas better mocas order complete comparisons prove computational power realtime mocas strictly weaker cas purpose adapt method developed 16 proving certain string sets belong l rt oca basic idea 16 dene equivalence relation string sets bound number distinguishable equivalence classes realtime oca computations oca xy two strings w w dened mxy equivalent x 2 x 2 leftmost states congurations jwj equal cf figure 10 oca figure 10 principle bounding realtime equivalence classes observation essential point upper bound equivalence classes due fact input sequences x computational unrelated therefore assume cell obtaining rst symbol w resp w 0 input defective adapt results 16 1ocas immediately corollary constant corollary finally follows constant 2 n r relations massively parallel arrays fault tolerant cellular automata synchronization nonuniform networks pushdown cellular automata minimal time synchronization restricted defective cellular automata synchronization line signals one dimensional cellular automata fault tolerant cellular spaces language recognition synchronization cellular au tomata language recognizable real time oneway cellular automata faulttolerant scheme optimumtime ring squad synchro nization deterministic oneway simulation twoway realtime cellular automata related problems probabilistic logics synthesis reliable organisms unreliable components tr realtime cellular automata trellis automata reliable computation cellular automata simple threedimensional realtime reliable cellular array minimal time synchronization restricted defective cellular automata synchronization nonuniform networks finite automata language recognizable real time oneway cellular automata relations massively parallel arrays pushdown cellular automata signals onedimensional cellular automata realtime language recognition oneway twoway cellular automata
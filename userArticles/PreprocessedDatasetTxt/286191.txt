efficient distributed detection conjunctions local predicates abstractglobal predicate detection fundamental problem distributed systems finds applications many domains testing debugging distributed programs paper presents efficient distributed algorithm detect conjunctive form global predicates distributed systems algorithm detects first consistent global state satisfies predicate even predicate unstable unlike previously proposed runtime predicate detection algorithms algorithm require exchange control messages normal computation necessary information detect predicates piggybacked computation messages application programs algorithm distributed predicate detection efforts well necessary information equally distributed among processes prove correctness algorithm compare performance respect message storage computational complexities previously proposed runtime predicate detection algorithms b introduction development distributed applications requires ability analyze behavior run time whether debug control execution particular sometimes essential know property satisfied distributed computation properties computation specify desired undesired evolutions programs execution state described means predicates local variables component processes basic predicate refers programs execution state given time predicates divided two classes called local predicates global predicates local predicate general boolean expression defined local state single process whereas global predicate boolean expression involving variables managed several processes due asynchronous nature distributed computation impossible process determine total order events occurred physical time consequently often impossible determine global states distributed computation passed complicating task ascertaining global predicate became true computation basic predicates used building blocks form complex class predicates linked predicates 14 simple sequences 5 9 1 intervalconstrained sequences 1 regular patterns 4 atomic sequences 8 9 class properties useful characterizing evolution programs execution state protocols exist detecting properties run time way language recognition techniques 2 property ie combination basic properties contains global predicate detection done locally without introducing delays without defining centralized process without exchanging control messages control information piggybacked existing message application however property refers least one global predicate possible observations computation must considered words detection property requires construction traversal lattice consistent global states representing observations computation property reduces one global predicate construction lattice avoided cases property expressed disjunction local predicates obviously cooperation processes needed order detect property computation form global predicate namely conjunction local predicates focus research 5 6 7 12 17 recent years predicates number global states interest lattice considerably rr 4 hurfin mizuno raynal singhal reduced global states includes local state local predicate false need examined previous work problem global predicate detection attracted considerable attention lately number global predicate detection algorithms proposed recent past centralized algorithm cooper marzullo 3 every process reports local states process builds lattice global computation checks state computation satisfies global predicate power algorithm lies generality global predicates detect however algorithm high overhead computation n processes maximum number events process lattice consists om n states worst case thus worst case time complexity algorithm om n algorithm 10 linear space complexity however worst case time complexity still linear number states lattice since detection generalized global predicates building searching entire state space computation utterly prohibitive researchers developed faster efficient global predicate detection algorithms restricting special classes predicates example form global predicate expressed conjunction several local predicates focus research 5 6 7 12 17 recently detection predicates done replay computation 12 17 initial computation 5 6 7this paper focus second kind solution allows one detect predicate even end computation gargwaldecker centralized algorithm detect predicates 6 process gathers information local states processes builds global states satisfy global predicate checks constructed global state consistent distributed algorithm garg chase 7 token used carries information latest global consistent state cut local predicates hold respective local states worst case time complexity algorithms omn 2 linear much smaller worst case time complexity methods require searching entire lattice however price paid properties expressed conjunction local predicates recently stoller schneider 16 proposed algorithm combines gargwaldecker approach 6 approach constructs lattice detect possiblyphi distributed computation satisfies possiblyphi iff predicate phi holds state corresponding lattice algorithm best features inria efficient distributed detection conjunctions local predicates 5 approaches detect possiblyphi predicate phi detects global predicate expressed conjunction local predicates time linear maximum number events process paper objectives paper presents efficient distributed algorithm detect conjunctive form global predicates distributed systems prove correctness algorithm compare performance previous algorithms detect conjunctive form global predicates rest paper organized follows next section define system model introduce necessary definitions notations section 3 presents first global predicate detection algorithm gives correctness proof second algorithm presented section 4 section 5 compare performance proposed algorithms existing algorithms detecting conjunctive form global predicates finally section 6 contains concluding remarks system model definitions notations 21 distributed computations distributed program consists n sequential processes denoted p 1 concurrent execution processes network processors called distributed computation processes share global memory global clock message passing way processes communicate one another computation asynchronous process evolves speed messages exchanged communication channels whose transmission delays finite arbitrary assume messages altered spuriously introduced assumption made fifo nature channels 22 events 221 definition notations activity process modeled sequence events ie executed action three kinds events considered internal send receive events let e x x th event occurs process p figure 1 shows example distributed computation involving two processes p 1 p 2 example event e 2 1 send event event e 1 2 corresponding receive event event e 1 1 internal event rr 6 hurfin mizuno raynal singhal figure 1 distributed computation process p define additional internal event denoted e 0 occurred process p beginning computation given computation execution process p characterized sequence events furthermore computation terminates last action executed process denoted e imaginary internal event denoted e 1 222 causal precedence relation events happenedbefore causal precedence relation lamport induces partial order events distributed computation transitive relation denoted oe defined follows 8e x exists message send event sending p j e j receive event receiving exists event e z k e z relation extended reflexive relation denoted inria efficient distributed detection conjunctions local predicates 7 23 local states 231 definition notations given time local state process p defined values local variables managed process although occurrence event necessarily cause change local state identify local state process given time regard last occurrence event process use oe x denote local state p period event e x event e x1 local state oe 0 called initial state process p figure 2 local states processes 232 causal precedence relation local states definition causal precedence relation states denoted gamma based happenedbefore relation events relation defined follows 8oe x two local states oe x oe said concurrent causal dependency ie oe x j oe set local states consistent pair elements concurrent distributed computation shown figure 2 foe 0 2 g foe 2oe 4 2 g three examples consistent sets local states rr 8 hurfin mizuno raynal singhal 24 intervals 241 definition notations since causal relations among local states different processes caused send receive events introduce notion intervals identify concurrent sequences states computation interval defined segment time process begins send receive event called communication event ends next send receive event thus process execution viewed consecutive sequence intervals order formally define intervals first introduce new notation identify communication events use x denote x th send receive event p thus x exists exactly one e denotes event furthermore imaginary event e 0 renamed 0 computation terminates imaginary event process p renamed l 1 l number communication events occurred process p x th interval process p denoted segment computation begins ends x thus first interval p denoted 0 computation terminates last interval process p identified l figure 3 corresponding set intervals say interval x contains local state oe oe contained x following property holds x relation denoted oe relation hold denoted oe definition interval contains least one local state inria efficient distributed detection conjunctions local predicates 9 242 causal precedence relation intervals relation expresses causal dependencies among intervals denoted relation induces partial order intervals distributed computation defined follows set intervals consistent pair intervals set say x 25 global states global state cut collection n local states containing exactly one local state process p global state denoted f oe x 1 g global state f oe x 1 consistent identified set consistent global states distributed computation form lattice whose minimal element initial global state sigma0 0 distributed computation reach latter former process p executes next event path lattice starting minimal element corresponds possible observation distributed computation observation identified sequence events events computation appear order consistent happen relation lamport maximal element called final global state exists processes distributed computation terminated given computation predicate global state phi use two modal operators proposed cooper marzullo 3 obtain two different pro perties namely possiblyphi definitelyphi distributed computation satisfies lattice consistent global state verifying predicate phi whereas definitelyphi satisfied computation observation ie path lattice passes consistent global state verifying phi paper focus class global predicates formed conjunction local predicates consider first satisfaction rule possiblyphi rule particularly attractive test debug distributed executions rr hurfin mizuno raynal singhal 26 conjunctions local predicates local predicate defined local state process p denoted l notation oe x indicates local predicate l satisfied process p local state oe x due definition local predicate l evaluated process p time without communicating process extend meaning symbol j intervals follows oe let phi denote conjunction p local predicates without loss generality assume p processes involved conjunction phi paper write either phi denote conjunction set p local states f oe x 1 p g called solution p g consistent set global state sigmax 1 called complete solution set local states includes solution definition possiblyphi verified exists complete solution consistent set local states containing less n local states may completed form consistent global state ie consistent set n elements thus solution may extensible one complete solutions goal detection algorithm calculate whole set complete solutions determine solution approach restrictive order deal complete solutions rather solutions programmer simply add conjunction local predicates l true local state consequently longer speak complete solution due link local states intervals following definition solution obviously consistent first one set p local states f oe 1 p g solution iff exists set p g consistent set inria efficient distributed detection conjunctions local predicates 11 let denote set solutions empty first solution unique element denoted f oe f 1 p g every element p g satisfies following property property detect expressed conjunction local predicates particular solution exists well defined computation set intervals includes solution also well defined denote set intervals say set intervals first one verifies phi 3 detection algorithms conjunction local predicate 31 overview mentioned previous section possiblyphi verified detecting set concurrent intervals verifies local predicate developed following two approaches resolve problem 1 first approach processes always keep track sets concurrent intervals set process checks whether interval set verifies local predicate 2 second approach process always keeps track set intervals verifies local predicate set process checks whether intervals set concurrent thus algorithms designed complementary approaches dual section described algorithm corresponding first approach detail including correctness proof next section describes algorithm corresponding second approach 32 first algorithm 321 dependency vectors identify set p concurrent intervals algorithm keeps track causal dependencies among intervals using vector clock mechanism similar described rr hurfin mizuno raynal singhal 13 process p 1 n maintains integer vector 1p called dependency vector since causal relations two intervals different processes created communication events transitive relation values advanced communication event takes place p use x denote value vector process p interval x value computed time x executed process p process p executes following protocol 1 process p interval 0 components vector zero 2 p 1 p executes send event advanced setting 1 message carries updated value 3 p executes receive event message contains dm advanced setting k maxd k dm k 1 k p moreover dependency vector advanced setting belongs set p processes directly implicated conjunction ie process p 1 p interval x following properties observed 15 1 x represents number intervals p precede interval 2 x represents number intervals process p j causally precede interval x 3 set intervals f x p g consistent 4 none intervals j x ie intervals p j causally precede x concurrent x therefore none form set intervals x verifies phi let b two dependency vector clock values use following notations ffl b iff 8i ffl b iff 8i b inria efficient distributed detection conjunctions local ffl b iff b following result holds 322 logs process maintains log denoted log queue vector clock entries log used store value dependency vector associated past local intervals p may part solution ie intervals verify l tested globally yet informations causal relations stored interval intervals processes used future stored interval examined p local state oe contained interval x oe enqueues vector clock value x log value already stored even exists one local state interval x verifies value x needs logged since interested intervals instead states 323 cuts addition vector clock process p 1 n maintains integer vector c 1p called cut boolean vector b 1p vector c defines first consistent global state could verify phi others words previous global states dont satisfy phi definition c denotes set p intervals may first solution informations received p show set certainly solution cut immediately updated new potential solution time c j denotes number interval p j already discarded indicate j first interval p j yet eliminated conjunction satisfied computation cut c evolve denotes first solution let c x denotes value c j communication event x executed p value c remains unchanged interval p maintains values c way none intervals precede event c j j form set intervals verifies phi therefore process p 1 p may discard values log c p 1 n also maintains vector b way b j holds interval c j j p j certain verify local predicate thus system certain whether rr 14 hurfin mizuno raynal singhal interval verifies local predicate b j set false maintain condition cut c b vector must exchanged among processes p sends message includes vectors c message 33 descriptions algorithm formal description algorithm given section 34 algorithm consists following three procedures executed process ffl procedure executed time local predicate l associated p ffl procedure b executed p 1 n sends message ffl procedure c executed p 1 n receives message addition vector clock cut c boolean vector b log log process maintains boolean variable logged yet variable logged yet true iff vector clock value associated current interval logged log variable helps avoid logging vector clock value log local predicate l becomes true let oe local state satisfies local predicate x interval includes state oe vector clock value x associated interval logged log logged yet indicate vector clock interval already logged process p sets variable logged yet false furthermore current interval denoted x x also oldest interval p yet discarded denoted c x set true indicate c x sends message since beginning new interval process p 1 p advances vector clock setting resets variable logged yet true log empty none intervals precedes new interval form set intervals verifies phi particular remark holds last interval ends current execution procedure b ie sending action occurs consequently last interval also intervals p causally inria efficient distributed detection conjunctions local predicates 15 precede one discarded setting c current value step computation identity current send event finally sends message along c receives message p j contains based definition vector clocks advances resets variable logged yet true definition cut process p k 1 k p none intervals precedes interval c k k c j k k form set concurrent intervals verifies phi thus c advanced componentwise maximum c c j b updated contains uptodate information b b j process p deletes log values intervals precede c since intervals belong sets concurrent intervals verify phi operation two possibilities ffl case 1 log becomes empty ie log contain interval occurs c case none intervals p represented form set concurrent intervals verify phi algorithm needs consider future intervals denoted z z since none intervals k k k k processes p k form set concurrent intervals future intervals z c advanced process p executes receive action informations intervals k p therefore components vector b set false contains least one entry logged occurrence event c oldest logged entry log properties vector definition cut process p k 1kp none intervals preceding log k c k k form set concurrent intervals log verifies phi thus c advanced componentwise maximum log similar case 1 value c k modified ie takes value log certain whether p k local predicate held interval log k thus b k set false value c k remains unchanged value b k also remain unchanged rr hurfin mizuno raynal singhal furthermore since log verified local predicate b set true point p checks whether b k true k indicates interval concurrent set intervals 1 f c 1 verifies local predicate thus phi verified 34 formal description algorithm initialization procedure executed process p p createlog yet logged true endif procedure executed process local predicate l becomes true yet logged logged false endif procedure b executed process p sends message p logged true endif append vectors c b message send message procedure c executed process p receives message p j prove subsection 37 set intervals numbered c values always concurrent inria efficient distributed detection conjunctions local predicates 17 extract vectors j c j b j message p logged true emptylog headlog delete logged intervals current knowledge lie solution construct solution passes next local interval else construct solution passes logged interval endif endif deliver message function combine maxima c1b1 c2b2 b vector 1p boolean c vector 1p integers p case endcase 35 simple example since algorithm quite involved illustrate operation algorithm help example figure 4 local state contained interval rr hurfin mizuno raynal singhal represented grey area satisfies associated local predicate different step computation indicate values main variables used detect items square brackets next process interval respectively depict contents vectors c values remain unchanged entire interval value vector b execution communication event indicated round brackets initial value interval number two processes 0 c vector 0 0 processes local predicate holds interval 0 enqueues 1 vector log 1 process p 1 also set b 1 1 true certain c 1 1 sends message m1 increments 1 1 1 sends vectors b 1 c 1 1 message receives message m1 increments 2 2 1 updates b c vectors p 2 finds log empty constructs potential solution using vector stores c vector local predicate becomes true state oe 1 log 2 variable yet logged 2 false process p 2 local state oe 2 2 vector clock logged twice interval p 2 sends message m2 increments 2 2 2 sends vectors b 2 message p 1 receives message m2 increments 1 1 2 updates b c vectors merging vectors received message p 1 finds c 1 1 1headlog 1 1 0 discards entry log 1 since log 1 empty p 1 constructs potential solution using vector stores c vector local predicate becomes true interval oe 2 log 1 p 1 sends message m3 increments 1 1 3 sends vectors b 1 message meantime local predicate holds state oe 3 2 consequently p 2 logs vector 2 log 2 receives message m3 increments 2 2 3 updates b c vectors merging vectors received message p 2 finds c 2 2 2headlog 2 2 1 discards entry since next entry log 2 cannot discarded p 2 constructs potential solution using headlog 2 2 vector stores c b vectors potential solution goes 1 fact interval satisfies l 1 known process p 2 b 2 1 true p 2 sets b 2 2 true finds entries vector b 2 true declares verification global predicate inria efficient distributed detection conjunctions local predicates 19 figure 4 example illustrate algorithm 1 36 extra messages algorithm able detect solution exists without adding extramessage computation without defining centralized process algorithm depends exchange computation message processes detect predicate consequence detection may delayed also cases computation may terminate existing solution may go unde tected example first solution set consisting p last intervals g algorithm detect solve problem solution found computation terminates messages containing vector c b exchanged p processes first solution found guarantee existence least one solution assume set intervals f l 1 1 p g always solution extra messages exchanged computation ends first solution detected yet reduce overhead due extra messages processes one use privilege token owned one process time token circulates around ring consisting p processes disseminating information three vectors another solution consists sending token process may know relevant information ie process p j b j false rr hurfin mizuno raynal singhal 37 correctness algorithm two vector timestamps sets intervals represented f v 1 1 concur rent set intervals represented f v 3 1 p g concurrent proof show pair intervals v 3 combination concurrent renumbering vectors v 1 v 2 necessary suppose v 3 two cases consider 1 case obvious assumption v 1 concurrent 2 suppose contrary v 3 j concurrent two cases consider case contradicts assumption v 1 j concurrent applying argument case leads contradiction assumption v 2 concurrent concurrent 2 following lemma guarantees cut c always keeps track set concurrent intervals lemma 2 process p given time f c 1 p g set concurrent intervals proof c updated one following three ways 1 receive event executed executing c 2 receive event executed taking maximum c c j cut contained message sent process p j taking maximum c log oldest value dependency vector still log inria efficient distributed detection conjunctions local predicates 21 3 send event occurs entry c set let updatec x update cut c communication event x giving value c x define partial order relation represented updates cuts c 1 p follows 1 x two consecutive communication events occur p ie 2 exists message x sending p j receiving p updatec x let seq topological sort partial order update events prove lemma induction number updates seq induction base since set intervals f 0 p g concurrent initially lemma holds c ie updatec 0 induction hypothesis assume lemma holds applications updates induction steps suppose st update occurs process p let c x cut value st update operation denoted updatec x receive event c x definition vector clocks vector clock value set intervals f d1 p g concurrent thus c x represents set concurrent intervals case 2 x receive event c x j corresponding send event updatec clearly relation updatec holds since induction hypo thesis c represent sets concurrent intervals maxc represents set concurrent intervals lemma 1 since definition vector clocks log oldest entry still log represents set concurrent intervals c x represents set concurrent intervals lemma 1 case 3 x send event c x 8j j 6 c x rr 22 hurfin mizuno raynal singhal suppose receive event occurs process p send event x entries vector x vector c x zero therefore proof case 1 suppose last receive event occurs sending event x log discarded since event occurred log empty conclude log also empty receive event occurred hence c event last receive event occurs x conclude 8j j 6 c proof case 1the following lemma shows solution cut c miss pass beyond solution lemma 3 consider particular cut identified integer vector p g set concurrent intervals verifies phi denote communication event communication events j proof proof contradiction suppose exists communication event x c x communication event j first event advances c beyond two cases consider 1 c x hypothesis c holds therefore entry c j modified execution event x event necessarily receive event z k corresponding send event note c x denote interval sj x holds definition dependency vectors sj however either c x contradicts hypothesis f s1 p g set concurrent intervals inria efficient distributed detection conjunctions local predicates 23 assumption c k therefore c x log holds definition dependency vec tors sj max operation log sj proof case 1 2 c x either send receive event algorithm clear case occurs none intervals occurred c including x verifies contradicts fact si verifies l since c k log receive event z k corresponding send event assumption c c z k si assume c k c si therefore c x algorithm clear case occurs none intervals occurred c including log verifies contradicts fact si verifies l since c log ithe following lemma proves algorithm keeps making progress encountered solution lemma 4 suppose process p executed algorithm x th communication event x interval x set f c x verify phi exists j c x proof two reasons f c x p g verifying phi 1 c x verify rr hurfin mizuno raynal singhal case x could find interval verifies l therefore set x ie value x next communication event updates least th entry c setting c x1 x1 2 exists least one process p k 1 k p c x k verify case p k eventually advance c k k value greater c x refer case 1 new value computed event z occurs propagate processes extra messages eventually exchanged end computation guarantee eventually communication event j process p j z c x finally following theorem shows phi verified computation iff algorithm detects solution theorem 1 exists interval x p interval holds k 1 k p f c x verifies phi conversely f c x verifies phi event x processor exists communication event j k 1 k p holds proof 1 proof contradiction suppose c x k verify l k k show long c k changed b k false two cases consider 1 verify l updated communication events x occurs x receive set false time remains false interval necessarily empty entire duration interval c x modified event x1 occurs send event value b unchanged since last receive event since beginning computation receive event occurs process send event x cases log remains empty entire period b remains false inria efficient distributed detection conjunctions local predicates 25 2 6 k updated c k c x existed process p j advanced c x k value propagated p p j must set b j k false information must propagated p value propagated p without going p k else p k would advanced value greater c x k easy see b x k false since k process change b k k true p never see b true together c 2 assume f c x verifies phi message exchanges guarantee eventually communication event j k 1 k p process p k interval c x k set true lemma 3 process p h sets c h k c x change value future implies processes p h path message exchange c x k c x k b h k true none processes p h sets b h k false advancing c h k beyond c x information eventually propagated p j b holds k 1 k p4 second algorithm second algorithm every process always keeps track set intervals processes intervals verifies local predicate set process checks whether intervals set concurrent 41 overview algorithm 411 verified intervals algorithm intervals verify associated local predicates interest call intervals verified intervals new used identify x th verified interval process p thus exists exactly one denotes interval rr 26 hurfin mizuno raynal singhal omega 0omega 1omega 0omega 1 0 figure 5 corresponding set verified intervals 412 dependency vectors first algorithm process p 1 n maintains dependency vector track identity next verified interval p encounter even though p know interval knows next verified interval denoted encountered x th verified interval denoted omega detailed description log given later moment increments one x look next verified note existence verified guaranteed moment local predicate may satisfied anymore computation first algorithm vector remains entire duration interval second algorithm contrary vector may change interval interval verified interval order capture causal relation among verified intervals different processes following protocol executed process p 1 n 1 initially components vector zero 2 p executes send event sends along message 3 p executes receive event message contains dm advanced setting k maxd k dm k 1 k p inria efficient distributed detection conjunctions local predicates 27 clearly following properties hold 1 represents number verified intervals p whose existence confirmed p ie p already passed st verified interval 2 jj 6 represents number verified intervals occurred process p j causally precede current interval p 3 set verified intervals p g necessarily consistent yet definition exists satisfies associated local predicate 4 none j j ie verified intervals p j causally precedeomega j concurrent therefore none form set intervals verifies phi 413 logs process p maintains log denoted log manner first algorithm p verifies local predicate l enqueues current incrementing one log empty notation log used denote value vector clock head log necessarily log empty existence omega log already confirmed p 414 cuts like first algorithm process p maintains integer vector c boolean vector meaning c similar first algorithm next possible interval p j may solution none verified intervals precedesomega c j j solution therefore process p may discard values log meaning b also similar algorithm 1 p maintains way b j true process p certain verified interval j confirmed p j furthermore process p certain none verified causally precedeomega c j thus p certain rr 28 hurfin mizuno raynal singhal whether verified j already confirmed p j b j set false 42 descriptions algorithm formal description algorithm given section 43 first algorithm second algorithm consists three procedures executed process p assume set intervals f l 1 1 p g solution extra messages exchanged computation ends first solution discovered yet local predicate l becomes true let oe local state satisfies local predicate p entered verified includes state oe logs log logged yet since beginning interval order indicate vector clock interval already logged sets variable logged yet false counter verified interval incremented one reflect current interval verified interval furthermore current verified interval also oldest verified interval discarded denoted set true confirm existence p sends message since marks beginning new interval p resets variable logged yet true sends message along c receives message p j contains since new interval begins resets variable logged yet true first algorithm none intervals process p k precedeomega c k form set concurrent intervals verifies phi thus c advanced componentwise maximum c c j moment b also updated b k true means p certain existence k confirmed thus c k least one b k b j k true b k set true deletes entries log precedeomega c since verified intervals potential components solution operation two cases consider inria efficient distributed detection conjunctions local predicates 29 ffl case 1 log becomes empty case none verified intervals p moment forms set concurrent verified intervals algorithm needs consider verified intervals occur future intervals existomega first one since verified k k processes p k causally precedeomega none intervals solution thus cut c advanced process p executes receive action certain whether p k 1 p encountered verified k therefore components vector b set false contains least one logged interval let oldest logged entry log properties vector definition cut verified intervals process p k precedingomega c k oromega log causally precedeomega log none intervals solution thus c advanced componentwise maximum log similar case 1 value c k modified ie takes value log certain whether p k encounter verified interval log k thus b k set false c k remains unchanged b k also remains unchanged follow processes decision furthermore b set true since p confirmed existence ofomega log moment new information c may able detect solution thus p checks whether b k true k indicates verified intervals set confirmed concurrent one another since process detected causal relations pair intervals set 43 formal description algorithm initialization procedure executed process p p createlog yet logged true endif rr hurfin mizuno raynal singhal procedure executed process local predicate l becomes true yet logged logged false endif procedure b executed process p sends message p yet logged true endif append vectors c b message send message procedure c executed process p receives message p j extract vectors j c j b j message p yet logged true emptylog headlog delete logged intervals current knowledge lie solution construct solution passes next local verified interval else construct solution passes logged verified interval endif endif deliver message inria efficient distributed detection conjunctions local predicates 31 44 discussion 441 example help readers understand algorithm figure 5 illustrate operation second algorithm computation similar one used figure 4 figure 5 contents vector c indicated next process interval square brackets values vectors evaluation last local state interval ie execution communication event f fa fa f fa fa fa f fa f fa f ta ta figure example illustrate algorithm 2 442 difference approaches second algorithm considered optimization first one interval counters c evolve slowly second algorithm updates vectors occur less often example vector c modified send action algorithm finds first solution different way first algorithm interval solution located via number communication events occur process encounters interval second algorithm delivered information number validated interval precede solution difference algorithms much semantics properties control variables rather way updated example update vector c made similar way algorithms yet rr hurfin mizuno raynal singhal component managed counter interval first algorithm counter verified interval second algorithm algorithms employ complementary approaches find first solution first algorithm corresponding set interval always concurrent ie satisfies first criterion solution second algorithm elements set always verified intervals ie set satisfies second criterion solution correctness proof second algorithm similar proof first algorithm however lemma 1 lemma 2 become irrelevant second algo rithm instead following lemma becomes useful lemma 5 time execution p b j 1 j p true proof process p j necessarily updated b j j true account fact j encountered oldest interval discarded yet time p j used value head log log j update components c j k value greater equal log k order invalidate verified intervals causal past therefore cut c never decreases due merge operation made beginning receive share p j vision values bj cj time keep older value component c k 2 rest proof first algorithm definition interval appropriately modified 5 comparison existing work previous work detecting conjunctive form global predicates mainly garg waldecker 6 garg chase 7 gargwaldecker algorithm centralized 6 process reports local states satisfying local predicate checker process checker process gathers information builds global states satisfy global predicate checks constructed global state consistent algorithm message storage computation complexities omp 2 number messages sent process p number processes global predicate defined inria efficient distributed detection conjunctions local predicates 33 7 garg chase present two distributed algorithms detection conjunctive form predicates algorithm processes participate global predicate detection equal basis first distributed algorithm requires vector clocks employs token carries information latest global consistent cut local predicates hold respective local states message storage computation complexities algorithm garg waldecker 6 algorithm namely omp 2 however worst case message sto rage computation complexities process algorithm omp thus distribution work equitable centralized algorithm second distributed algorithm use vector clocks uses direct dependencies instead message storage computation complexities algorithm omn worst case message storage computation complexities process algorithm om thus algorithm desirable p 2 greater n proposed predicate detection algorithm cause transfer additional messages except end provided predicate detected computation terminates control information needed predicate detection piggybacked computation messages contrary distributed algorithms garg chase may require exchange many mp mn control mes sages respectively although worst case volume control information exchanged identical namely omp 2 first garg chase algorithm proposed algorithm latter results additional message exchanges study lazowska et al 11 showed message send receive overhead considerable due context switching execution multiple communication protocol layers desirable send bigger performance point view 6 concluding remarks global predicate detection fundamental problem design coding testing debugging implementation distributed programs addition finds applications many domains distributed systems deadlock detection termination detection paper presented two efficient distributed algorithms detect conjunctive form global predicates distributed systems algorithms detect first consistent global state satisfies predicate work even predicate uns rr 34 hurfin mizuno raynal singhal table algorithms based complementary approaches second algorithm considered optimization first one vectors c increase lower rate proved correctness algorithms algorithms distributed predicate detection efforts well necessary information equally distributed among processes unlike previous algorithms detect conjunctive form global predicates algorithms require transfer additional messages normal computation instead piggyback control information computation messages additional messages exchanged predicate remains undetected computation terminates r consistent detection global predicates detection unstable predicates distributed pro grams detection weak unstable predicates distributed programs distributed algorithms detecting conjunctive predi cates global events global breakpoints distributed sys tems detecting atomic sequences predicates distributed computations linear space algorithm online detection global states file access performance diskless workstations global conditions debugging distributed programs virtual time global states distributed systems breakpoints halting distributed programs way capture causality distributed systems faster possibility detection combining two ap proaches le de nancybrabois campus scientifique 615 rue du jardin botanique bp 101 54600 villers le nancy unite de recherche inria rennes irisa campus universitaire de beaulieu 35042 rennes cedex unite de recherche inria rho tr ctr punit chandra ajay kshemkalyani distributed algorithm detect strong conjunctive predicates information processing letters v87 n5 p243249 15 september loonbeen chen ichen wu efficient distributed online algorithm detect strong conjunctive predicates ieee transactions software engineering v28 n11 p10771084 november 2002 ajay kshemkalyani finegrained modality classification global predicates ieee transactions parallel distributed systems v14 n8 p807816 august guy dumais hon f li distributed predicate detection seriesparallel systems ieee transactions parallel distributed systems v13 n4 p373387 april 2002 emmanuelle anceaume jeanmichel hlary michel raynal tracking immediate predecessors distributed computations proceedings fourteenth annual acm symposium parallel algorithms architectures august 1013 2002 winnipeg manitoba canada neeraj mittal vijay k garg techniques applications computation slicing distributed computing v17 n3 p251277 march 2005 scott stoller detecting global predicates distributed systems clocks distributed computing v13 n2 p8598 april 2000 punit chandra ajay kshemkalyani causalitybased predicate detection across space time ieee transactions computers v54 n11 p14381453 november 2005
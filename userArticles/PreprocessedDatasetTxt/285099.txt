capabilitiesbased query rewriting mediator systems users today struggling integrate broad range information sources providing different levels query capabilities currently data sources different limited capabilities accessed either writing rich functional wrappers primitive sources dealing sources lowest common denominator paper explores third approach mediator ensures sources receive queries handle still taking advantage query power source propose architecture enables identify key component architecture capabilitiesbased rewriter cbr cbr takes input description capabilities data source query targeted data source cbr determines component queries sent sources commensurate abilities computes plan combining results using joins unions selections projections provide language describe query capability data sources plan generation algorithm description language plan generation algorithm schema independent handle spj queries also extend cbr costbased optimizer net effect prune without losing completeness finally compare implementation cbr garlic project algorithms proposed paper b introduction organizations today must integrate multiple heterogeneous information sources many conventional sql database management systems examples information sources include bibliographic databases object repositories chemical structure databases wais servers etc systems provide powerful query capabilities others much limited new challenge database community allow users query data using single powerful query language location transparency despite diverse capabilities underlying systems figure 1a shows one commonly proposed integration architecture 1 2 3 4 data source wrapper provides view data source common data model wrapper translate queries expressed common language language underlying information source mediator provides integrated view data research partially supported wright laboratories wright patterson afb arpa contract f3361593c1337 wrapper cbr component subqueries target query mediator query decomposition description queries supported wrapper plan 1a client mediator wrapper 1 wrapper 2 wrapper n information information information source n figure 1 typical integration architecture b cbrmediator interaction exported wrappers particular mediator receives query client determines data needs underlying wrapper sends wrappers individual queries collect required data combines responses produce query result scenario works well wrappers support query data however types systems consider assumption unrealis tic leads extremely complex wrappers needed support powerful query interface possibly quite limited data sources example many systems relational data model taken common data model wrappers must provide full sql interface even underlying data source file system hierarchical dbms alternatively assumption may lead lowest common denomina tor approach simple queries sent wrappers case search capabilities sophisticated data sources exploited hence mediator forced work resulting unnecessarily poor performance would like simple wrappers accurately reflect search capabilities underlying data source enable mediator must recognize differences limitations capabilities ensure wrappers receive queries handle garlic 1 integrator heterogeneous multimedia data developed ibms almaden research center understanding essential garlic needs deal efficiently disparate data types querying capabilities needed applications diverse medical advertising pharmaceutical research computeraided design model wrapper capable handling set queries known supported queries wrap per mediator receives query client decomposes set queries references data single wrapper call individual queries target queries wrappers target query need supported query may sometimes necessary decompose simpler supported component subqueries csqs order execute plan combines results csqs produce answer target query obtain functionality exploring capabilitiesbased rewriter cbr module fig ure 1b part garlic query engine media tor cbr uses description wrappers ability expressed special purpose query capabilities description language develop plan wrappers target query mediator decomposes users query target queries q wrapper w without considering whether q supported w passes q cbr inspection cbr compares q description queries supported wrapper produces plan p q either q directly supported w ii q computable mediator plan involves selection projection join csqs supported w mediator combines individual plans p complete plan users query cbr allows clean separation wrapper capabilities mediator internals wrappers thin modules translate queries common model sourcespecific queries 2 hence wrappers reflect actual capabilities underlying data sources mediator general mechanism interpreting capabilities forming execution strategies queries paper focuses technology needed enable cbr approach first present language describing wrappers query capabilities descriptions look like contextfree grammars modified describe queries rather arbitrary strings descriptions may recursive thus allowing description infinitely large supported queries addition may schema independent example may describe capabilities relational database wrapper without general onetoone mapping optimization involved translation optimization done mediator ferring schema specific relational database additional benefit grammarlike description language appropriately augmented actions translate target query query underlying information system feature described 5 discuss paper second contribution paper architecture cbr algorithm build plans target query using csqs supported relevant wrapper problem generalization problem determining query answered using set materialized queriesviews 6 7 however cbr uses description potentially infinite queries opposed finite set materialized views problem identifying csqs compute target query many sources exponentiality even restricted case discussed 6 7 cbr algorithm uses optimizations heuristics eliminate sources exponentiality many common cases next section present language used describe wrappers query capabilities section 3 describe basic architecture cbr identifying three modules component subquery discov ery plan construction plan refinement components detailed sections 4 5 6 spectively section 7 summarizes runtime performance cbr section 8 compares cbr related work finally section 9 concludes directions future work area 2 relational query description rqdl language use describe wrap pers supported queries discuss select projectjoin queries paper section 21 introduce basic language features followed sections 22 23 extensions needed describe infinite query sets support schemaindependent descriptions section 24 introduces normal form queries descriptors increases precision language complete language specification appears 8 description language focuses conjunctive queries found powerful enough express abilities many wrappers sources lookup catalogs object databases indeed believe expressive contextfree grammars currently working proof 21 language basics rqdl specification contains set query tem plates essentially parameterized query actual query might con stant query template constant placeholder allowing represent many queries form addition allow values assumed constant placeholders restricted specifier metapredicates query described template loosely speaking 1 predicate query matches one predicate template vice versa 2 metapredicates placeholders template evaluate true matching constants query order predicates query template need different variable names course possible example consider lookup facility provides information name department office address employees company lookup facility either retrieve employees retrieve employees whose last name specific prefix retrieve employees whose last name first name specific prefixes 3 integrate lookup heterogeneous system creating wrapper called lookup exports predicate empfirstname lastname department office manager manager field may n wrapper also exports predicate prefixfull prefix successful second argument prefix first argument second argument must string consisting letters may write following datalog query retrieve emp tuples persons whose first name starts rak whose last name starts aggr prefixfnrak prefixlnaggr paper use datalog 9 query language wellsuited handling spj queries facilitates discussion algorithms 4 use following datalog terms paper distinguished variables variables appear target query head join variable variable appears twice target query tail query q1 distinguished variables fn ln join variables fn ln description d2 rqdl specification lookups query capabilities identifiers starting lp constant placeholders isalpha metapredicate returns true argument string contains letters metapredicates start underscore lowercase letter intuitively template qt23 describes query q1 predicates query match template despite differences order variable names metapredicates evaluate true fp mapped rak lp aggr d2 answerfldom qt21 empfldom answerfldom qt22 empfldom prefixl lp isalphalp answerfldom qt23 empfldom prefixl lp prefixffp 3 lookup facility similar stanford university facility 4 could used spj sql queries instead datalog would use description language looks like sql datalog notions ie placeholders nonter minals hold cbr algorithm also general template describes query produced following steps 1 map placeholder constant eg map lp aggr 2 map template variable query variable eg map f fn 3 evaluate metapredicates discard template contains least one metapredicate evaluates false 4 permute templates subgoals 22 descriptions large infinite sets supported queries rqdl describe arbitrarily large sets templates hence queries extended nonterminals contextfree grammars nonterminals represented identifiers start underscore capital letter zero parameters associated nonterminal templates query template containing nonterminals describes query q expansion describes q expansion obtained replacing nonterminal n one nonterminal templates define n nonterminal example assume lookup allows us pose one substring conditions one fields emp example may pose query q3 retrieves data employees whose office contains strings alma b substringoalma substringob d4 uses nonterminal cond describe supported queries description query template qt41 supported nonterminal templates nt41 d4answerfldom qt41 empfldom condfldom substringf fs condfldom substringl ls condfldom substringd ds condfldom substringoos condfldom substringm ms condfldom see description d4 describes query q3 expand condfldom qt41 nonterminal template nt44 expand cond template cond subgoal resulting expansion expanded empty template nt46 obtain expansion e5 substringoos substringoos1 template used expansion variables renamed unique hence second occurrence placeholder os template nt44 renamed os1 e5 e5 describes query q3 ie placeholders variables e5 mapped constants variables q3 23 schema independent descriptions supported queries description d4 assumes wrapper exports fixed schema however query capabilities many sources thus wrappers independent schemas data reside exam ple relational database allows spj queries relations support schema independent descriptions rqdl allows use placeholders place relation name furthermore allow tables arbitrary arity column names rqdl provides special variables called vector variables simply vec tors match lists variables appear query represent vectors examples identifiers starting underscore addition provide two builtin metapredicates relate vectors attributes subset subset r succeeds variable list matches r appears list matches inposition x matches variable list query variable matches x appears position number matches position readability use italics vectors bold metapredicates example consider wrapper called filewrap accesses tables residing plain unix files may output subset tables fields may impose one substring conditions field wrapper may easily implemented using unix utility awk d6 uses vectors builtin metapredicates describe queries supported filewrap substringxs cond general decide whether query described template containing vectors must expand nonterminals map variables placeholders vectors finally evaluate metapredicates illustrate show verify query q7 described d6 substringoalma substringob first expand qt61 replacing nonterminal cond nt61 twice nt62 thus obtaining expansion e8 inpositionx asubstringxs inposition1x1 asubstringx1s1 subset r expansion e8 describes query q7 mapping variables vectors placeholders e8 makes metapredicates succeed makes every predicate expansion identical predicate query namely vector mapped fldom vector r ld placeholders position position1 4 alma s1 b variables x x1 must careful vector mappings vector v maps appears metapredicate replace however vector v appears predicate p v mapping results finally metapredicate in4 fldom succeeds fourth variable list subsetld fldom succeeds ld subset fldom vectors useful even schema known specification may otherwise repetitious description d4 running example even though know attributes emp save effort explicitly mention column names say substring condition placed column 24 query description normal form allow templates variables vectors map arbitrary lists constants variables descriptions may appear support queries underlying wrapper support using variable name different places query description cause implicit join selection explicitly appear description example consider query q9 retrieves employees manager field first last names equal denoted double appearance fl emp d6 describe query q9 nevertheless construct expansion e10 erroneously matches query q9 map flfldoy r fld section introduces query description normal form avoids inadvertently describing joins selections intended normal form queries descriptions explicit equalities query normalized replacing every constant c unique variable v introducing subgoal every join variable v appears n 1 times query replace instances vn introduce subgoals replace appearance v head v 1 example query q11 normal form q9 fl1fl2 description d6 describe q11 d6 support equality conditions rqdl plan refinement target query specification plans fully optimized component subqueries component subquery discovery algebraically optimal plans plan construction figure 2 cbrs components appear q11 description d12 supports equality conditions column equalities two columns nt122 describes equalities constants nt123 describes equalities columns table d12 answer r qt121 table inpositionx substringx inposition1x xc cond inpos1x inpos2y xy cond presentation purposes use compact unnormalized form queries descriptions danger introducing inadvertent selections joins however algorithms rely normal form 3 capabilitiesbased rewriter capabilitiesbased rewriter cbr determines whether target query q directly supported appropriate wrapper ie whether matches description wrappers capabilities cbr determines whether q computed combining set supported queries using selections projections joins case cbr produce set plans evaluating query cbr consists three modules invoked serially see figure component subquery csq discovery finds supported queries involve one subgoals q csqs returned contain largest possible number selections joins projection csqs pruned prevents exponential explosion number csqs ffl plan construction produces one plans compute q combining csqs exported csq discovery plan construction algorithm based query subsumption tuned perform efficiently cases typically arising capabilitiesbased rewriting ffl plan refinement refines plans constructed previous phase pushing many projections possible wrapper 31 consider query q13 retrieves names managers manage departments employees offices b wing employees office numbers query directly supported wrapper described d12 empf1l1do1m1 substringo1b csq detection module identifies outputs following csqs answer 14 answer 15 empf1l1do1m1 substringo1 b note csq discovery module output 2 4 csqs tail q14 export different subset variables f0 l0 o0 like wise q15 csqs export fewer variables pruned plan construction module detects join answer 14 answer 15 produces required answer q13 consequently derives plan p16 answer 14 answer 15 finally plan refinement module detects variables o0 f1 l1 m1 answer 14 answer 15 unnecessary consequently generates efficient plan p19 answer 17 answer empf1l1do1m1 substringo1 b answer 17 f0l0d answer do1the cbrs goal produce algebraically optimal plans evaluating query algebraically optimal plan one selection projection join done wrapper done unnecessary queries definition 31 algebraically optimal plan p plan p algebraically optimal plan p 0 every csq p corresponding csq 0 p 0 set subgoals 0 superset set subgoals ie 0 selections joins set exported variables superset set exported variables 0 ie 0 projections next three sections describe modules cbr turn csq discovery module takes input target query description operates rule production system templates description production rules subgoals target query base facts csq discovery module uses bottomup evaluation guaranteed terminate even recursive descriptions 10 ever bottomup derivation often derives unnecessary facts unlike topdown use variant magic sets rewriting 10 focus bottomup derivation reduce set derived csqs develop two pruning techniques decsribed sections 42 43 reducing number derived csqs makes csq discovery efficient also reduces size input plan construction module query templates derive answer facts correspond csqs particular derived answer fact head produced csq whereas underlying base facts ie facts used deriving answer subgoals csq nonterminal templates derive intermediate facts may used query nonterminal templates keep track sets facts underlying derived facts pruning csqs following example illustrates bottomup derivation csqs gains realize use magicsets rewriting next subsection discusses issues pertaining derivation facts containing vectors example 41 consider query q3 description d4 page 3 subgoals empfldom substringo alma substringob treated csq discovery module base facts distinguish variables target query subgoals templates variables freeze vari ables eg fldo similarly named constants eg fldo actual constants like b single quotes first round derivations template nt46 derives fact condfldom without using base fact since template empty body hence set facts underlying derived fact empty variables allowed derived facts nontermi nals semantics derived fact holds assignment frozen constants variables derived fact second round many templates fire example derives fact condfldom using condfldom substringoalma using condfldom substringob thus generate two facts though identical different underlying sets hence must retain since may generate different csqs second round may also fire nt46 produce condfldom retain since set underlying facts equal version condfldom already produced eventually generate answerfldom set underlying facts fempfldom substringo alma substringobg hence output csq q3 incidentally target query process produce exponential number facts example could proved condoldom condfodom condoodom general assuming emp n columns apply substrings may derive n facts magicsets remove source exponentiality focusing nontermi nals applying magicsets rewriting simplifications described chapter 134 10 obtain following equivalent description show rewriting templates nt44 nt46 others rewritten similarly empfldom condfldom mg condfldofficem substringoffice os condfldofficem mg condfldom empfldom condfldom facts different underlying sets produced note magicsets rewritten program uses available information way similar topdown strategy thus derives relevant facts 2 41 derivations involving vectors head nonterminal template contains vector variable may possible derivation using nonterminal may able either bind vector specific list frozen variables allow variable derived fact csq discovery module handle situation descriptions magicsets rewriting solves problem demonstrate formally define set nonproblematic descriptions example let us fire template nt61 d6 base facts produced query q3 assume also nt62 already derived cond derive cond holds set underlying facts fsubstringo almag provided constraint contains holds constraint follow fact binds list frozen variables avoid mess constraints using following magicsets rewriting d6 d21 answer r qt211 table subset r mg cond inpositionx substringxs cond rules nt211 nt212 fire first subgoal instantiates variable fldom derive condfldom thus magic sets caused bound vector inter est namely fldom note program derives facts unbound vectors may problematic metapredicate may use unbound vector variable however take conservative approach consider programs produce facts bound vector variables magicsets rewriting always ensure derived facts bound vectors rest section describe sufficient conditions guaranteeing derivation facts bound vectors first provide condition theorem 41 guarantees program may result magic rewriting derive facts unbound vectors describe class programs magic rewriteen satisfy condition theorem 41 theorem 41 program always produce facts bound vector variables rules gammatail tail nonmetapredicate subgoal refers v general v assigned binding nonmetapredicate subgoals tail bound 2 intuitively magicrewrite program deriving facts unbound vectors nonterminal initial program derives uninstan tianted vectors rules used share variables predicates nonterminals bind arguments otherwise magic predicate force rules produce uninstan tianted vectors focus bindings ex ample specification ms6 derive uninstan tianted vectors nonterminal cond may derive uninstantianted variables shares variables table 8 provides formal criterion deciding whether bottomup evaluation derives facts vector variables criterion used following algorithm derives csqs given target query description algorithm 1 input target query q description output set csqs check program derives facts vector variables see 8 reorder template r predicate subgoals occur front rule nonterminal n appears n depends grounding metapredicates appear end rule rewrite using magicsets evaluate bottomup rewritten description described 8 note template r always reordered proof appears 8 42 retaining representative csqs large number unneeded csqs generated templates use vectors subset metapred icate example template qt121 describes particular csqs head subset variables necessary generate possible csqs instead csqs derived expansion e template e form metapredicate listi v appear hpredicate metapredicate listi generate representative csq derived mapping v variable list w 5 represented csqs ie csqs derived e mapping v proper subset w gener ated example representative csq q15 represented csq q18 derived expansion e22 template qt121 inpositionx substringxb subset r csq discovery module generates q15 q18 q15 fewer attributes q18 derived mapping vector r vector ie f1l1do1m1 representative csqs often retain unneeded attributes consequently representative plans ie plans containing representative csqs retrieve unneeded tributes unneeded attributes projected plan refinement module theorem 42 retaining representative csqs lose plan ie algebraically optimal plan p involves represented query p discovered cbr 2 intuitive proof claim every plan p corresponding representative plan r derived replacing csqs p rep resentatives given plan refinement component considers plans represented representative plan sure cbr algorithm lose plan complete proof appears 8 evaluation retaining representative csq head arity eliminates 2 gamma 1 represented csqs thus 5 general hlist predicates metapredicates may contain metapredicates form inhpositionihvariable case template describes csqs output subset w superset hvariableimg csq discovery module puts usual representative csq annotates set provides minimum set variables represented csqs must export paper describe extensions needed handling case eliminating exponential factor execution time size output csq discovery module still one might ask csq discovery phase remove variables projected reason projection step better done plans formed time information available csqs plan way interact see section 6 thus though postponing projection pushes part complexity later stage eliminates complexity altogether eliminated complexity corresponds represented csqs end participate plan retain variables 43 pruning nonmaximal csqs efficiency gained eliminating csq q fewer subgoals csq checks fewer conditions q 0 csq maximal csq subgoals set exported variables modulo variable renaming formalize maximality terms subsumption 10 definition 41 maximal csqs csq maximal csq csq subsumed 2 evaluation general csq discovery module generates maximal csqs prunes others pruning technique particularly effective csqs contain large number conditions example assume g conditions applied variables predicate consequently 2 csqs one contains different proper subset conditions keeping maximal csqs eliminate exponential factor 2 g output size csq discovery module theorem 43 pruning nonmaximal csqs lose algebraically optimal plan 2 reason every plan p involving nonmaximal csq also plan pm involves corresponding maximal csq pm pushes selections andor joins wrapper p since definition involves selections andor joins 5 plan construction section present plan construction module see figure 2 order generate rep resentative plan select subset csqs provides information needed target query ie csqs check subgoals target query ii results joined correctly iii csq receives constants necessary evaluation section 51 addresses notion subgoal consumption section 52 checks ii ie checks join variables section 53 checks iii ensuring bindings avail able finally section 54 summarizes conditions required constructing plan provides efficient plan construction algorithm 51 set consumed subgoals associate csq set consumed subgoals describes csqs contribution plan loosely speaking component query consumes subgoal extracts required information subgoal csq necessarily consume subgoals example consider csq e semijoins emp relation dept relation output emp tuple department relation dept even though csq subgoal refers dept relation may always consume dept subgoal particular consider target query q requires names employees location departments csq e output location attribute table dept thus consume dept subgoal respect query q formalize intuition following definition definition 51 set consumed subgoals csq set subgoals csq constitutes set consumed subgoals 1 exports every distinguished variable target query appears 2 exports every join variable appears also appears subgoal target query theorem 51 csq unique maximal set consumed subgoals superset every set consumed subgoals 2 proof uniqueness maximal consumed set appears 8 intuitively maximal set describes largest contribution csq may plan following algorithm states compute set maximal consumed subgoals csq annotate every csq set maximal consumed subgoals c algorithm 2 input csq target query q output csq computed annotation c insert c subgoals remove c subgoals distinguished attribute q exported repeat size c unchanged remove c subgoals join variable v subgoal g q g c join variable v exported discard csq c empty algorithm polynomial number subgoals variables csq also algorithm discards csqs relevant target query definition 52 relevant csq csq called relevant c nonempty 2 intuitively irrelevant csqs pruned cases contribute plan since consume subgoal note decide relevance csq locally ie without considering csqs may join pruning nonrelevant csqs build efficient plan construction algorithm cases section 52 produces plan time polynomial number csqs produced csq discovery module however scenarios see extended version 8 relevance criteria may erroneously prune csq could part plan may avoid loss plans pruning irrelevant csqs thus sacrificing polynomiality plan construction algorithm paper consider option 52 join variables condition always case union consumed subgoals csqs equal set target querys subgoals csqs together form plan particular possible join csqs may constitute plan exam ple consider online employee database queries names employees given divi sion database also queried names employees given location name employee uniquely determined location division employee database cannot used find employees given division given location joining results two queries one division location see consider query looks employees cs new york joining results two independent queries division location incorectly return answer person named john smith john smith cs san jose different john smith electrical new york intuitively problem arises two independent queries export information necessary correctly join results avoid problem checking csqs combined export join variables necessary correct combination theorem section 54 formally describes conditions join variables guarantee correct combination csqs 53 passing required bindings via nested loops joins cbrs plans may emulate joins could pushed wrapper nested loops joins one csq passes join variable bindings example may compute q13 following steps first execute q23 collect department names ie bindings binding replace q24 send instantianted query wrap per use notation nested loops plan p25 denote q24 receives values placeholder bindings csqs q23 example answer 23 answer 24 introduction nested loops binding passing poses following requirements csq discovery ffl csq discovery subgoal csq may contain placeholders hvari place corresponding join variables example whenever case introduce structure hvari next answer appears plan variables appear structure included set b called set bindings needed ex ample fg csq discovery previously use bindings information deriving facts thus algorithm derives useless csqs need bindings exported csq optimized derivation process uses two sets attributes proceeds iteratively iteration derives facts use bindings provided existing facts addition fact derived uses least one binding made available last itera tion thus first iteration derives facts need bindings b empty next iteration derives facts use least one binding provided facts derived iteration one thus second iteration derive subgoal derived first iteration complete algorithm appears 8 formalizes intuition bindings needed csq plan impose order constraints plan example existence b 24 requires csq exports executed q24 responsibility plan construction module ensure produced plans satisfy order constraints evaluation pruning csqs inappropriate bindings prunes exponential number csqs following common scenario assume put equality condition variable subgoal p consider csq contains p assume n variables p appear subgoals target query contained generate versions describe different binding pat terns assuming csq may provide variables one 2 n csqs useful 54 plan construction algorithm section summarize conditions sufficient construction plan present efficient algorithm finds plans satisfy theorems conditions finally evaluate algo rithms performance theorem 52 given csqs corresponding heads answer v sets maximal consumed subgoals c sets needed bindings plan correct ffl consumed sets condition union maximal consumed sets i1n c equal target querys subgoal set ffl join variables condition set maximal consumed subgoals csq join variable v every csq j contains v set maximal consumed subgoals c j exports v ffl bindings passing condition must csq exports v 2 proof based theory containment mappings appropriately extended take consideration nested loops 8 plan construction algorithm extended version paper 8 based theorem 52 algorithm takes input set csqs derived discovery process described later target query q step algorithm selects csq consumes least one subgoal consumed csq 0 considered far variables b exported least one 0 assuming algorithm given csqs csq discovery module construct set satisfies consumed sets bindings passing conditions time polynomial neverthe less join variables condition hold algorithm takes time exponential may create exponentially many sets find one satisfies join variables condition ever join variables condition evaluates true wrappers find practice see following dis cussion thus usually construct plan time polynomial every plan p may plans p 0 identical p modulo permutation csqs p worst case number csqs p since useless generate permutations plan algorithm creates total order oe input csqs generates plans considering csq 1 csq 2 csqs considered order oe note query 2 must always considered query 1 1 provides bindings 2 hence oe must respect partial order oe oe provides bindings 2 plan construction algorithm first sorts input csqs total order respects po b oe procedes picking csqs testing conditions theorem 52 consumes subgoals target query algorithm capitalizes assumption practical cases every csq consumes least one subgoal join variables condition holds case one plan developed time polynomial number input csqs following lemma describes important case join variables condition always holds lemma 51 join variables condition holds set csqs 1 two csqs set intersecting sets maximal consumed subgoals 2 two csqs contain subgoal gv sets maximal consumed subgoals export variables condition 1 lemma 51 holds typical wrappers bibliographic information systems lookup services wrappers structure d12 relational databases object oriented databases wrapped relational model systems typical two csqs common subgoals combined form single csq thus end set maximal csqs nonintersecting consumed sets condition 2 relaxes condition 1 condition 2 holds wrappers export variables appear csq two conditions lemma 51 cover essentially wrapper practical importance 6 plan refinement plan refinement module filters refines constructed plans two ways first eliminates plans algebraically optimal fact csqs representative plans maximum number selections joins plan refinement pushes maximum number projections enough guarantee plans produced algebraically optimal example assume csqs interchangeable plans set subgoals 1 superset set subgoals exports subset variables exported 2 plans 2 participates algebraically worse corresponding plans 1 nevertheless produced plan construction module 1 2 may maximal represent produced different template expansions plan refinement must therefore eliminate plans include 2 plan refinement must also project unnecessary variables representative csqs intuitively necessary variables representative csq variables allow consumed set csq interface consumed sets csqs plan formalize notion significance following definition note definition restricted maximal consumed sets definition 61 necessary variables set consumed subgoals variable v necessary variable consumed subgoals set csq exporting v longer consumed set 2 set necessary variables easily computed given set consumed subgoals variable v necessary variable distinguished variable join variable appears least one subgoal due space limitations complete plan refinement algorithm evaluation appear 8 main complication due fact unecessary variables cannot always projected maximal consumed sets csqs intersect 7 evaluation cbr algorithm employs many techniques eliminate sources exponentiality would otherwise arise many practical cases evaluation paragraphs many sections paper describe benefit derive using techniques remember assumption every csq consumes least one subgoal led plan construction module develops plan time polynomial number csqs produced csq detection mod ule provided join variables condition holds important result join variables condition holds wrappers practice argued subsection 54 cbr deals selectprojectjoin queries corresponding descriptions produces algebraically optimal plans involving csqs ie plans push maximum number selections projections joins source however cbr complete misses plans contain irrelevant csqs see definition 52 discussion section 51 hand techniques eliminating exponentiality preserve completeness miss plan applying one techniques see justifications sections 42 43 8 related work significant results developed resolution semantic schematic discrepancies integrating heterogeneous information sources ever systems 11 12 4 13 address problem different limited query capabilities underlying sources assume sources fullfledged databases answer query schema 6 recent interest integration arbitrary information sources including databases file systems web many legacy systems invalidates assumption underlying sources answer query data export forces us resolve mismatch query capabilities provided sources systems addressed problem hermes 11 proposes rule language specification mediators explicit set parameterized calls made sources runtime parameters instantiated specific values corresponding calls made thus hermes guarantees queries sent wrappers supported unfortunately solution reduces interface wrappers mediators simple form particular parameterized 6 work query decomposition distributed databases also assumed underlying systems relational equally able perform sql query calls fully utilize sources query power disco 14describes set supported queries using contextfree grammars technique reduces efficiency capabilitiesbased rewriting treats queries strings information manifold 15 develops query capabilities description attached schema exported wrapper description states many conditions may applied attribute rqdl provides greater expressive power able express schemaindependent descriptions descriptions exactly one condition allowed tsimmis suggests explicit description wrappers query capabilities 5 using contextfree grammar approach current paper description also used query translation common query language language underlying source however tsimmis considers restricted form problem wherein descriptions consider relations prespecified arities mediator select project results single csq paper enhances query capability description language 5 describe queries arbitrary schemas namely relations unspecified arities names well capabilities selections first attribute relation language also allows specification required bindings eg bibliography database returns titles books given author names provide algorithms identifying target query q algebraically optimal csqs given descriptions also provide algorithms generating plans q combining results csqs using selections projections joins cbr problem related problem determining answer query using set materialized views 16 6 7 17 however significant differences papers consider specification language uses spj expressions given relations specifying finite number views cannot express arbitrary relations arbitrary arities binding requirements exception 7 infinitely large queriesviews also consider generating plans require particular evaluation order due binding requirements 6 shows rewriting conjunctive query general exponential total size query views 17 shows query acyclic rewrite time polynomial total size query views 6 7 generate necessary sufficient conditions query answered available views contrast algorithms check sufficient conditions might miss plan heuristics used algorithm viewed generalization algorithms decide subsumption datalog query datalog program ie description recently 18 proposed datalog description supported queries also suggested algorithm essentially finds call maximal csqs 9 conclusions future work paper presented relational query description language rqdl provides powerful features description wrappers query capabilities rqdl allows description infinite sets arbitrarily large queries arbitrary schemas also introduced capabilitiesbased rewriter cbr presented algorithm discovers plans computing wrappers target query using queries supported wrapper despite inherent exponentiality problem cbr uses optimizations heuristics produce plans reasonable time practical situations output cbr algorithm terms number derived plans remains major source exponentiality though cbr prunes output plans deriving plan plan pushes selections projections joins source may still case number plans exponential number subgoals andor join vari ables example consider case query involves chain n joins one accomplished either lefttoright nested loops join righttoleft nested loops join local join case cbr output 3 n plans plans employs one three join methods mediators costbased optimizer would estimate cost one plans choose efficient could modify cbr generate plans depending time spent optimization currently looking implementing cbr ibms garlic system 1 also investigating tighter couplings mediators costbased optimizer cbr finally investigating powerful rewriting techniques may replace target querys subgoals combinations semantically equivalent subgoals supported wrapper acknowledgements grateful mike carey hector garcia molina anand rajaraman anthony tomasic jeff ullman ed wimmers jennifer widom many fruitful discussions comments r towards heterogeneous multimedia information systems garlic approach object exchange across heterogeneous information sources amalgame tool creating interoperating persistent pegasus heterogeneous multidatabase system query translation scheme rapid implementation wrappers answering queries using views answering queries using templates binding patterns principles database knowledgebase systems principles database knowledgebase systems hermes heterogeneous reasoning mediator system approach resolving semantic heterogeneity federation autonomous integration information systems bridging heterogeneous databases scaling heterogeneous databases design disco query processing information manifold computing queries derived relations query folding answering queries using limited external processors tr ctr stefan huesemann information sharing across multiple humanitarian organizationsa webbased information exchange platform project reporting information technology management v7 n4 p277291 december 2006 yannis papakonstantinou vinayak borkar maxim orgiyan kostas stathatos lucian suta vasilis vassalos pavel velikhov xml queries algebra enosys integration platform data knowledge engineering v44 n3 p299322 march alin deutsch lucian popa val tannen physical data independence constraints optimization universal plans proceedings 25th international conference large data bases p459470 september 0710 1999 andreas koeller elke rundensteiner historydriven approach evolving views meta data changes knowledge information systems v8 n1 p3467 july 2005
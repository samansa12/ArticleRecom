pointer analysis use past two decades many different pointer analysis algorithms published although descriptions include measurements effectiveness algorithm qualitative comparisons among algorithms difficult varying infrastructure benchmarks performance metrics without comparisons difficult implementor determine pointer analysis appropriate application also researcher know algorithms used basis future advancesthis paper describes empirical comparison effectiveness five pointer analysis algorithms c programs algorithms vary use control flow information flowsensitivity alias data structure resulting worstcase complexity linear polynomial effectiveness analyses quantified terms compiletime precision efficiency addition measuring direct effects pointer analysis precision also reported determining information computed five pointer analyses affects typical client analyses pointer information modref analysis live variable analysis dead assignment identification reaching definitions analysis dependence analysis conditional constant propagation unreachable code identification efficiency reported measuring analysis time memory consumption pointer analyses clients b introduction programs written languages pointers troublesome analyze memory location accessed pointer known inspecting statement effectively analyze languages knowledge pointer behavior required without knowledge conserva copy posted permission acm may redis tributed official citation work hind pioli 2000 pointer analysis use acm sigsoft international symposium software testing analysis august 2225 2000 copyright 2000 acm 158113266200008500 tive assumptions memory locations accessed pointer must made assumptions adversely affect precision efficiency analysis requires information program understanding system optimizing compiler testing tool pointer analysis compiletime analysis attempts determine possible values pointer analysis general undecidable 16 28 many approximation algorithms developed provide tradeoff efficiency analysis precision computed solution worstcase time complexities analyses range linear exponential worstcase complexities often true indication analysis time many researchers provide empirical results algorithms however comparisons among results different researchers difficult differing program representations benchmark suites preci sionefficiency metrics work describe comprehensive study five widely used pointer analysis algorithms holds factors constant thereby focusing efficacy algorithms less manner results obtained main contributions paper following ffl empirical results measure precision efficiency five pointer alias analysis algorithms varying degrees flowsensitivity alias data struc tures addresstaken steensgaard 34 andersen 1 burke et al 4 12 choi et al 5 12 ffl empirical data pointer analyses solutions affect precision efficiency following client analyses modref live variable analysis dead assignment identification reaching definition analysis dependence analysis interprocedural conditional constant propagation unreachable code identification results show 1 steensgaards analysis significantly precise addresstaken analysis terms direct precision client precision 2 andersens burke et als analyses provide level precision modest increase precision steensgaards analysis 3 flowsensitive analysis choi et al offers minimal increase precision analyses andersen burke et al using direct metric little precision improvement client analyses 4 increasing precision pointer information reduces client analyses put resulting significant improvement efficiency remainder paper organized follows section describes background work describes differs similar studies section 3 provides overview five pointer algorithms section 4 summarizes client analyses section 5 describes empirical study discusses results section 6 describes related work section 7 summarizes conclusions 2 background pointer alias analysis attempts determine two pointer expressions refer storage location example p q point storage location say lambdap lambdaq aliases written hlambdap lambdaq pointsto analysis attempts determine storage location pointer point information used determine aliases program works uses compact representation 5 12 alias information shares property pointsto representation 8 captures edge characteristic alias relations 1 example variable points b b points c compact representation records following alias set cig inferred h ci h lambdabi also aliases cost time information inferred affect precision efficiency analysis 22 12 20 interprocedural dataflow analysis classified flowsensitive flowinsensitive depending whether controlflow information procedure used analysis 23 considering control flow information therefore computing conservative summary flowinsensitive analysis efficient less precise flowsensitive analysis addition flowsensitivity several factors affect costprecision tradeoffs including contextsensitivity calling context considered analyzing function heap modeling objects named allocation site sophisticated shape analysis performed struct modeling components distinguished collapsed one object alias representation explicit alias representation pointstocompact representation used work holds factors constant choosing popular efficient alternatives case results vary usage flowsensitivity particular analyses contextinsensitive name heap objects based allocation site collapse aggregate components use compactpointsto representation work differs previous studies 33 35 7 21 following ways 1 minor difference compact pointsto representations 12 relevant work ffl breadth pointer algorithms studied two studies 35 21 also include flowsensitive analysis analysis study 18 also benefits context sensitive uses different alias representation explicit one pointsto flowinsensitive analyses compared ffl number client analyses reported work first report reaching definitions flow de pendences interprocedural constant propagation affected quality pointer analysis ffl reporting memory usage important aspect evaluating scalability interprocedural dataflow analyses 3 pointer analyses algorithms consider listed order increasing precision addresstaken flowinsensitive algorithm often used production compilers records variables whose addresses assigned another variable set includes heap objects actual parameters whose addresses stored corresponding mal analysis efficient linear size program uses single solution set imprecise steensgaard 34 flowinsensitive algorithm computes one solution set entire program employs fast unionfind 36 data structure represent alias relations results almost linear time algorithm makes one pass program similar algorithms discussed 42 24 2 andersen 1 iterative implementation andersens contextinsensitive flowinsensitive algorithm originally described using constraintsolving 1 although also uses one solution set entire pro gram precise steensgaards algorithm perform merging required unionfind data structure however require fixedpoint computation pointer related statements produce constant alias relations burke et al 4 12 flowinsensitive algorithm also iterates pointerrelated statements pro gram differs andersens analysis computes alias solution procedure requiring iteration within function addition iteration functions worklist used latter case improve efficiency distinguishing alias sets function allows precisionimproving enhancements using precomputed kill information 4 et als analysis precise andersens analysis filter alias information based scoping ie formals locals provably nonactive functions considered particular enhancement never improved precision burke et als analysis studied paper 13 thus enhanced version burke et als analysis uses precomputed kill information included study void main f s5 void f f void gt fp f s9 figure 1 example program may less efficient computes solution set function rather one whole program choi et al 5 12 flowsensitive algorithm computes solution set every program point associates alias sets cfg node program uses worklists efficiency 13 analyses incorporate optimistic function pointer analysis alias analysis resolving indirect call sites analysis proceeds 8 4 theory subsequent analysis precise costly predecessors paper help quantify characteristics also client analyses affected precision pointer analyses consider program figure 1 main calls f g f also calls g addresstaken analysis computes one set objects assumes pointers may point fheaps1 heaps4 heaps6 heaps8 local p qg appear referenced s5 steensgaards analysis unions two objects pointedto pointer one object leads unioning pointsto sets formerly distinct ob jects unioning removes necessity iteration algorithm example formal parameter g may point either p q resulting p q unioned one object thus appears point heap objects either point heaps1 local dereference s5 four objects reported aliased lambdap andersens analysis also keeps one set aliases hold anywhere program merge objects common pointer point leads local reported aliased lambdap burke et als analysis associates one set every function conservatively represents may hold cfg node function without considering control flow within function distinction allows removal objects longer active local functions main f leads heaps1 heaps4 aliased lambdap s5 choi et als analysis associates alias set inn outn every cfg node n example outs1 lambdap heaps1 refer storage s1 choi et als analysis compute fhlambdap heaps4ig precise solution simple example example illustrates theoretical precisionefficiency levels five analyses study addresstaken least precise choi et als precise address taken analysis efficient analysis linear uses one set steensgaards analysis also uses one set almost linear three analyses require iteration differ amount information stored one alias set per program andersen one set per function burke et al two per cfg node choi et al 3 analyses implemented npic system experimental program analysis system written c system uses multiple virtual inheritance provide extensible framework dataflow analyses 14 26 prototype version ibm visualage c compiler 15 used front end analyzed program represented program call multi graph pcg node corresponds function directed edge represents call target function 4 function body represented control flow graph cfg node roughly corresponds statement graph used build simplified sparse evaluation graph seg 6 used choi et als analysis manner similar wilson 39 cfg available library functions call library function modeled based functions semantics respect pointer analysis handcoded modeling provides benefits contextsensitive analysis calls library calls cannot affect value pointer treated identity transfer function pointer analysis implementation also assumes pointer values exist pointer variables pointer arithmetic result pointer outside array string literals modeled one object implementation handles setjmplongjmp manner similar wilson 39 calls setjmp recorded used determine possible effects call longjmp model values passed argc argv main function dummy main function added called benchmarks main function simulating effects 3 found performing choi et als analysis using seg sparse evaluation graph 6 instead cfg reduces number alias sets average 73 reduces analysis time average 280 13 indirect calls result several potential target functions argc argv function also initialized iob array used standard io added function similar one added ruf 29 30 landi et al 19 17 explicit implicit initializations global variables automatically modeled assignment statements dummy main function array initializations expanded assignment array component 4 client analyses section summarizes client analyses used study 41 modref analysis modref analysis 20 determines objects may mod ifiedreferenced cfg node information subsequently used analyses reaching definitions live variable analysis information computed first visiting cfg node computing objects modified referenced node pointer dereferences generate query alias information determine objects modified results mod ref sets summarized function used call sites function call sites modref set include local function cannot activation stack lifetime active actual parameters call site assumed referenced value assigned corresponding formal parameter passbyvalue semantics modref analysis makes simplifying assumption libraries modify reference locations indirectly pointer parameter fixedpoint iteration employed program pcg cycles 42 live variable analysis live variable analysis 25 determines objects may referenced program point without intervening killing definition information useful register allo cation detecting uninitialized variables finding dead assignments implementation backward analysis directly uses modref information associates two sets live variables cfg node representing live execution node sharing sets performed cfg node one successor node acts identify function ie empty mod ref set named objects ref set cfg node become live node named object killed cfg node definitely assigned ie element mod set noncall node represents one runtime object ie aggregate heap object localformal recursive function implementation processes function employing prioritybased worklist cfg nodes function optimistic named objects considered live initially except exit node nonlocals modified function considered live 43 reaching definitions analysis reaching definitions analysis 25 determines definitions named objects may reach execution sense program point information useful computing data dependences among statements important step program slicing 37 code motion implementation forward analysis uses modref information associates two sets reaching definitions cfg node set sharing performed live variable analysis named objects mod set cfg node result new definitions generated node definitions killed live variable analysis function processed using prioritybased worklist cfg nodes function analysis optimistic definitions initially considered reaching point except dummy definitions created entry node function parameter nonlocal referenced function 44 interprocedural constant propagation constant propagation client 26 optimistic interprocedural algorithm inspired wegman zadecks conditional constant algorithm 38 algorithm tracks values variables interprocedurally throughout program uses information simultaneously evaluate conditional branches possible thereby determining conditional branch always evaluate one value addition potentially removing unexecutable code analysis simplify computations provide useful information cloning algorithms analysis designed combined choi et als pointer analysis 26 27 uses pointer information directly rather using modref sets done reaching definitions live variable analysis work constant propagation analysis simply run pointer analysis completed like choi et als analysis constant propagation algorithm uses nested iteration seg 5 algorithm extends traditional lattice constant include positive negative nonzero help analyzing c programs treat nonzero values true 5 results study performed 333mhz ibm rs6000 powerpc 604e 512mb ram 817mb paging space running aix 43 analyses compiled ibms xlc compiler using o3 option benchmark following reported pointer analyses clients precision analysis time maximum memory usage table describes characteristics benchmark suite contains 23 c programs provided researchers 19 8 29 31 spec benchmark suites 6 loc computed using wc source header files column marked fcts number userdefined func tions includes dummy main function created simu 5 however seg benefits dramatic cfg nodes interesting constant propagation thus efficiency typically worse choi et als analysis 6 large number cfg nodes 129compress results explicit creation assignment statements implicit array initialization programs syntactically modified satisfy cs stricter typechecking semantics program names different reported 29 namely ks referred part ft span 30 also spec cint92 program 052alvinn named backprop todd austins benchmark suite 3 table 1 static characteristics benchmark suite ptrasg cfg nodes name source loc nodes fcts pct allroots landi 227 159 7 13 01qbsort mccat 325 170 8 241 06matx mccat 350 245 7 135 15trie mccat 358 167 13 234 04bisect mccat 463 175 9 97 fixoutput prolangs 477 299 6 44 17bintr mccat 496 193 17 88 anagram austin 650 346 ks austin 782 526 14 274 05eks mccat 1202 677 08main mccat 1206 793 41 209 09vor mccat 1406 857 52 286 loader landi 1539 691 129compress spec95 1934 17012 25 02 football landi 2354 2854 58 18 compiler landi 2360 1767 40 51 assembler landi 3446 1845 52 166 simulator landi 4639 2929 111 63 flex prolangs 7659 7107 88 52 late commandline argument passing column marked ptrasg nodes pct reports percentage cfg nodes considered pointerassignment nodes ie number assignment nodes left side variable involved pointer expression declared pointer 51 pointer analysis precision direct way measure precision pointer analysis record number objects aliased pointer expression appearing program using metric andersens burke et als analyses provide level precision benchmarks suggesting alias relations involving formals locals provably nonactive functions occur benchmark suite client analyses use alias solution computed analysis input likewise precision difference clients reason group two analysis together precision data efficiency results section 56 distinguish analyses pointer expression multiple dereferences lambdap counted multiple dereference expressions one dereference intermediate dereferences lambdap counted reads last dereference lambdap counted read write depending context expression statements lambdap lambdap increment treated read write lambdap pointer considered dereferenced variable declared pointer array formal parameter one operators used variable formal parameter arrays included corresponding actual parameters could pointer count use operator arrays formal parameters resulting pointer array name constant therefore counting may skew results left half table 2 reports average size mod ref sets expressions containing pointer dereference benchmark average benchmarks 7 table rest paper use signify value previous column example ptrmod allroots choi et als analysis andersenburke et als analyses results show 1 substantial difference addresstaken analysis steensgaards analysis average 3026 vs 403 improvement benchmarks assigned pointer ptrmod ii average 3070 vs 487 improvement benchmarks ptrref 2 measurable difference steensgaards analysis andersenburke et als analyses average 403 vs 206 improvement 15 22 benchmarks assign pointer ptrmod ii average 487 vs 235 improvement 13 23 benchmarks ptrref 3 little difference andersenburke et als analyses choi et als analysis average 206 vs 202 improvement 5 22 benchmarks assign pointer ptrmod ii 235 vs 229 improvement 5 23 benchmarks ptrref summary varying degrees increased precision gained using precise analysis however precise algorithms used improvement diminishes 52 modref precision right half table 2 reports average modref set size cfg nodes captures pointer analysis affects modref analysis serves input many analyses results show 1 substantial difference addresstaken analysis steensgaards analysis average 250 vs 104 improvement 22 23 benchmarks mod ii 448 vs 175 improvement 23 benchmarks ref 2 measurable difference steensgaards analysis andersenburke et als analyses average 104 vs87 improvement 13 23 benchmarks mod ii 175 vs 154 improvement 11 23 benchmarks ref 3 little difference andersenburke et als analyses choi et als analysis average 871 vs867 improvement 3 23 benchmarks mod ii average 1540 vs 1536 improvement 4 23 benchmarks ref 7 modeling potentially many runtime objects one representative object may seem precise compared model uses names 29 20 example heap modeled one object heapdirected pointers would resolved one object table 2 table 2 mod ref pointer dereferences cfg nodes assignments pointer occur compiler et al ptr mod ptr ref mod ref name st ab ch st ab ch st ab ch st ab ch allroots 3 200 100 3 200 138 88 85 83 177 158 152 04bisect 14 115 14 100 257 58 392 157 anagram ks 17 190 186 162 17 179 174 170 56 55 53 376 135 134 05eks 09vor 19 185 135 132 19 192 168 160 204 63 62 791 140 134 loader 129compress 13 140 107 13 226 111 168 80 78 166 129 128 football compiler assembler 87 124 221 87 1514 211 121 188 87 1507 409 147 simulator 87 316 205 87 395 186 682 62 57 821 121 106 flex 56 537 178 56 509 203 201 597 160 118 155 389 344 343 average 3026 403 206 202 3070 487 235 229 250 104 0871 0867 448 175 1540 1536 varying degrees increased precision gained using precise analysis however improvements dramatic previous metric resulting minimal precision gain flowsensitive analysis 53 live variable analysis dead assignment first set four columns table 3 reports precision results live variable analysis benchmark list average number live variables cfg node average averages live variable information used find assignments variables never used ie dead assignments second set four columns gives number cfg nodes dead assignments results show 1 substantial difference addresstaken analysis steensgaards analysis live variables average 3424 vs 2013 improvement benchmarks difference finding dead assignments 2 significant difference steensgaards analysis andersenburke et als analyses live variables average 2013 vs 1836 improvement 13 23 benchmarks less difference finding dead assignments average 191 vs 196 improvement 1 23 benchmarks 3 small difference andersenburke et als analyses choi et als analysis live variables average 1836 vs 1830 improvement 3 benchmarks difference finding dead assignments summary precise pointer analyses improved precision live variable analysis choi et als analysis provided minimal improvement contrast dead assignments identification hardly affected using different pointer analyses 54 reaching definitions andflowdependences third set four columns table 3 reports precision results reaching definitions analysis benchmark list average number definitions reach cfg node last set four columns reports average number unique flow dependences two cfg nodes per function metric captures reaching definitions used cfg node counts dependences two nodes thus set variables potentially defined one node potentially used another node one dependence counted one dependence needed prohibit code motion two nodes part slice results show 1 significant difference addresstaken analysis steensgaards analysis average 3639 vs 2204 improvement 23 benchmarks reaching definitions ii average 5251 vs 4424 improvement 21 23 benchmarks flow dependences 2 measurable difference steensgaards analysis andersenburke et als analyses aver table 3 live variables dead assignments reaching definitions flow dependences avg live variables node total dead assignments avg reaching defs node avg flow deps per function name st ab ch st ab ch st ab ch st ab ch allroots 04bisect fixoutput anagram ks 05eks 08main 09vor 2033 696 685 2 2368 735 726 3492 2652 2620 loader 5016 2176 129compress compiler 4373 4370 assembler 8224 3736 2075 simulator average 3424 2013 1836 age 2204 vs 2021 improvement 12 23 benchmarks reaching definitions ii average 4424 vs 4384 improvement 9 23 benchmarks flow dependences 3 negligible difference andersenburke et als analyses choi et als analysis reaching definitions average 2021 vs 2016 improvement 5 23 benchmarks difference flow dependences benchmark summary successively precise analysis results improvement precision reaching definitions improvement diminished flow dependences computed particular gain flow dependences precision using choi et als analysis ander senburke et als analyses minor improvements using andersenburke et als analyses steensgaards analysis constant propagation unexecutable code detection constant propagation precision results shown table 4 benchmark name first four columns give number complete expressions found constant metric count subexpressions b bc next four columns report number unexecutable nodes found analysis results show 1 significant difference addresstaken analysis steensgaards analysis average 78 vs 106 constants found improvement 3 22 benchmarks ii average 32 vs 253 unexecutable nodes detected improvement 2 22 benchmarks table 4 constants unexecutable cfg nodes found gaards ab andersenburke et al choi et al 099go included exhausts 200mb heap size constants unexecutable nodes name st ab ch st ab ch allroots 04bisect ks 05eks 08main 36 loader 129compress 34 5 compiler assembler simulator flex average 78 106 107 32 253 254 2 negligible difference steensgaards analysis andersenburke et als analyses average 106 vs 107 constants found improvement 1 22 benchmarks ii average 253 vs 254 unexecutable nodes detected improvement 1 22 benchmarks 3 difference andersenburke et als analyses choi et als analysis terms constants found unexecutable nodes detected summary constant propagation unexecutable code detection seem benefit much increasing precision beyond steensgaards analysis 56 efficiency efficiency algorithm vary greatly depending implementation 13 therefore care must taken drawing conclusions regarding efficiency example fahndrich et al 9 demonstrated efficiency constraint solving implementation andersens algorithm improved orders magnitude without loss precision using partial online cycle detection inductive form table 5 presents analysis time seconds five individual runs benchmark runs differ pointer analysis used times given pointer analysis total time client analyses sum two values time reported include time build pcg cfgs include analysisspecific preprocessing building seg cfg choi et als analysis last line gives average column expressed ratio addresstaken analysis category pointer analysis clients total example average pointer analysis time andersens analysis 2960 times average pointer analysis time addresstaken analysis average client analyses using information 84 times average client analyses using alias information addresstaken analysis results show 1 addresstaken steensgaards analyses fast benchmarks analyses completed less second 2 flowinsensitive analyses andersen burke et al significantly slower approximately addresstaken steensgaards analyses 3 flowsensitive analysis choi et als average times slower addresstaken analysis 25 times slower andersenburke et als analyses 4 client analyses improved efficiency pointer information made precise input size client analysis smaller average reduction outweighed initial costs pointer analysis steensgaard andersen burke et als analyses compared addresstaken analysis brought total time flowsensitive analysis choi et als within 9 total time addresstaken analysis table 6 reports highwater mark memory usage various analyses reported ps v command aix 43 amounts given pointer analysis total memory client analyses sum two values last line gives average column expressed ratio address taken analysis category pointer analysis clients total results show 1 memory consumption addresstaken steensgaards analyses similar 2 memory consumption flowsensitive analysis choi et al 6 times larger pointer analysis flex average uses 12 times memory addresstaken analysis 3 memory usage client analyses improves precision pointer information increases average clients using information produced choi et als analysis used least amount memory enough overcome twelvefold increase pointer analysis memory consumption addresstaken analysis 6 related work space constraints limit section comparative studies pointer analyses thorough treatment related work found 12 20 39 ruf 29 presents empirical study two algorithms flowsensitive algorithm similar choi et al contextsensitive version algorithm contextsensitive algorithm improve precision pointer dereferences ruf cautioned may characteristic benchmark suite shapiro horwitz 32 present empirical comparison four flowinsensitive algorithms addresstaken steens gaard andersen fourth algorithm 33 parameterized steensgaards andersens analysis authors measure precision analyses using procedurelevel mod live truly live variables analyses interprocedural slicing algorithm results suggest precise analysis improve precision efficiency clients leave open question whether flowsensitive analysis follow pattern landi et al 20 35 report precision results computation interprocedural mod problem using flowsensitive contextsensitive analysis landi ryder 18 compare analysis analysis 42 similar steensgaards analysis found precise analysis provided improved precision exhausted memory programs less precise analysis able process emami et al 8 report precision results flowsensitive contextsensitive algorithm ghiya hendren 11 empir table 5 analysis time seconds pointer analysis clients total name st bu ch st bu ch st bu ch allroots 04bisect ks 05eks loader 129compress compiler assembler simulator flex ratio 100 090 2960 3292 7949 100 081 084 071 069 100 082 098 087 109 table memory usage mbs pointer analysis clients total name st bu ch st bu ch st bu ch allroots 04bisect 101 061 225 000 050 089 091 055 066 060 190 152 280 066 110 fixoutput anagram 050 028 162 004 025 115 110 091 096 137 165 138 253 100 162 ks 026 031 239 042 163 279 238 236 231 286 305 269 475 273 449 05eks 000 010 204 018 075 213 186 169 172 166 213 196 373 190 241 08main 019 000 339 076 272 266 189 147 143 142 285 189 486 219 414 loader 129compress compiler 061 122 420 105 219 1460 1503 1411 1380 1372 1521 1625 1831 1485 1591 assembler simulator ratio 100 115 852 315 1219 100 081 077 071 070 100 082 089 074 087 ically demonstrate version pointsto 8 connection analyses 10 improve traditional transformations array dependence testing program understanding wilson lam 40 39 present contextsensitive algorithm avoids redundant analyses functions similar calling contexts algorithm distinguishes structure components handles pointer arithmetic wilson 39 compares various levels contextsensitivity describes dependence analysis uses computed information parallelize loops two spec benchmarks diwan et al 7 examine effectiveness three typebased flowinsensitive analyses typesafe language modula 3 first two algorithms rely type declarations third considers assignments manner similar steens gaards analysis retains declared type information evaluate effect algorithms redundant load elimination using statical dynamic upper bound met rics conclude typesafe languages modula3 java fast simple typebased analysis may sufficient earlier paper 13 describe empirical comparison four contextinsensitive pointer algorithms three described paper choi et al burke et al address taken flowinsensitive algorithm uses precomputed kill information 4 12 alias analysis clients studied paper also quantifies analysistime speedup various implementation techniques choi et als analysis yong et al 41 present tunable pointeranalysis framework handling structures presence casting provide experimental results four instances framework using flow contextinsensitive algorithm appears similar andersens algorithm results show pointer algorithm distinguishing struct components improve precision pointers dereferenced metric used section 51 address affects precision client analyses similar results hold pointer analyses liang harrold 21 describe contextsensitive flowinsensitive algorithm empirically compare three algorithms steensgaard andersen landi ryder 18 using ptrmod section 51 summary edges system dependence graph average slice size precision metrics demonstrate performance precision mostly andersens steensgaards algorithms none implementations handles function pointers setjmplongjmp 7 conclusions paper describes empirical study precision efficiency five pointer analyses typical clients alias information compute major conclusions ffl steensgaards analysis significantly precise addresstaken analysis without appreciable increase compilation time memory usage therefore always preferred addresstaken analysis ffl flowinsensitive analysis andersen burke et al provide level precision analyses offer modest increase precision steensgaards analysis although improvement requires additional pointer analysis time typically offset decreasing input size alias information analysis time subsequent analyses clear distinction analysis time memory usage implementations analyses ffl use flowsensitive pointer analysis described paper seem justified offers minimum increase precision analyses andersen burke et al using direct metric ptrmodref little precision improvement client analyses ffl time space efficiency client analyses improved pointer analysis precision increased increase precision reduced input client analysis 8 acknowledgments thank vivek sarkar support work npic group members assisted implemen tation also thank todd austin bill landi laurie hendren making benchmarks available thank frank tip laureen treacy anonymous referees comments earlier draft work work supported part national science foundation grant ccr9633010 ibm research suny new paltz research creative project awards 9 r program analysis specialization c programming language effective wholeprogram analysis pressence pointers efficient flowsensitive interprocedural computation pointerinduced aliases side effects automatic construction sparse data flow evaluation graphs partial online cycle elimination inclusion constraint graphs connection analysis practical interprocedural heap analysis c putting pointer analysis work interprocedural pointer alias analysis assessing effects flowsensitivity pointer alias analyses traveling dakota experiences objectoriented program analysis system architecture montana open extensible programming environment incremental c undecidability static analysis personal communication safe approximate algorithm interprocedural pointer aliasing interprocedural modification side effect analysis pointer aliasing schema interprocedural modification sideeffect analysis pointer aliasing efficient pointsto analysis wholeprogram analysis defining flow sensitivity data flow problems static analysis software transformation tool advanced compiler design imlementation conditional pointer aliasing constant propagation combining interprocedural pointer analysis conditional constant propagation undecidability aliasing personal communication effects precision pointer analysis fast accurate flowinsensitive pointto analysis comparing flow context sensitivity modificationssideeffects problem data structures network flow algorithms survey program slicing techniques constant propagation conditional branches efficient contextsensitive pointer analysis c programs efficient contextsensitive pointer analysis c programs pointer analysis programs structures casting program decomposition pointer aliasing step toward practical analyses tr data structures network algorithms automatic construction sparse data flow evaluation graphs constant propagation conditional branches safe approximate algorithm interprocedural aliasing interprocedural modification side effect analysis pointer aliasing efficient flowsensitive interprocedural computation pointerinduced aliases side effects undecidability static analysis pointerinduced aliasing contextsensitive interprocedural pointsto analysis presence function pointers undecidability aliasing efficient contextsensitive pointer analysis c programs contextinsensitive alias analysis reconsidered pointsto analysis almost linear time program decomposition pointer aliasing connection analysis fast accurate flowinsensitive pointsto analysis putting pointer analysis work comparing flow context sensitivity modificationsideeffects problem partial online cycle elimination inclusion constraint graphs typebased alias analysis advanced compiler design implementation static analysis software transformation tool effective wholeprogram analysis presence pointers architecture montana pointer analysis programs structures casting efficient pointsto analysis wholeprogram analysis interprocedural pointer alias analysis flowinsensitive interprocedural alias analysis presence pointers effects presision pointer analysis assessing effects flowsensitivity pointer alias analyses traveling dakota efficient contextsensitive pointer analysis c programs ctr mana taghdiri robert seater daniel jackson lightweight extraction syntactic specifications proceedings 14th acm sigsoft international symposium foundations software engineering november 0511 2006 portland oregon usa andreas zeller isolating causeeffect chains computer programs acm sigsoft software engineering notes v27 n6 november 2002 ran shaham elliot k kolodner mooly sagiv heap profiling spaceefficient java acm sigplan notices v36 n5 p104113 may 2001 andreas zeller isolating causeeffect chains computer programs proceedings 10th acm sigsoft symposium foundations software engineering november 1822 2002 charleston south carolina usa jens krinke effects context program slicing journal systems software v79 n9 p12491260 september 2006 ondrej lhotk comparing call graphs proceedings 7th acm sigplansigsoft workshop program analysis software tools engineering p3742 june 1314 2007 san diego california usa markus mock manuvir das craig chambers susan j eggers dynamic pointsto sets comparison static analyses potential applications program understanding optimization proceedings 2001 acm sigplansigsoft workshop program analysis software tools engineering p6672 june 2001 snowbird utah united states jamieson cobleigh lori clarke leon j osterweil right algorithm right time comparing data flow analysis algorithms finite state verification proceedings 23rd international conference software engineering p3746 may 1219 2001 toronto ontario canada haifeng john trimble somu perianayagam saumya debray gregory andrews code compaction operating system kernel proceedings international symposium code generation optimization p283298 march 1114 2007 esther salam mateo valero dynamic memory interval test vs interprocedural pointer analysis multimedia applications acm transactions architecture code optimization taco v2 n2 p199219 june 2005 donglin liang maikel pennings mary jean harrold extending evaluating flowinsenstitive contextinsensitive pointsto analyses java proceedings 2001 acm sigplansigsoft workshop program analysis software tools engineering p7379 june 2001 snowbird utah united states david j pearce paul h j kelly chris hankin efficient fieldsensitive pointer analysis c proceedings acmsigplansigsoft workshop program analysis software tools engineering june 0708 2004 washington dc usa donglin liang mary jean harrold equivalence analysis application improving efficiency program slicing acm transactions software engineering methodology tosem v11 n3 p347383 july 2002 thomas eisenbarth rainer koschke gunther vogel static object trace extraction programs pointers journal systems software v77 n3 p263284 september 2005 ana milanova atanas rountev barbara g ryder parameterized object sensitivity pointsto sideeffect analyses java acm sigsoft software engineering notes v27 n4 july 2002 brian hackett alex aiken aliasing used systems software proceedings 14th acm sigsoft international symposium foundations software engineering november 0511 2006 portland oregon usa bolei guo matthew j bridges spyridon triantafyllis guilherme ottoni easwaran raman david august practical accurate lowlevel pointer analysis proceedings international symposium code generation optimization p291302 march 2023 2005 jeff da silva j gregory steffan probabilistic pointer analysis speculative optimizations acm sigplan notices v41 n11 november 2006 gregor snelting frank tip understanding class hierarchies using concept analysis acm transactions programming languages systems toplas v22 n3 p540582 may 2000 charles n fischer interactive scalable declarative program analysis prototype implementation proceedings 9th acm sigplan international symposium principles practice declarative programming july 1416 2007 wroclaw poland ana milanova atanas rountev barbara g ryder parameterized object sensitivity pointsto analysis java acm transactions software engineering methodology tosem v14 n1 p141 january 2005 jianwen zhu silvian calman symbolic pointer analysis revisited acm sigplan notices v39 n6 may 2004 markus mock darren c atkinson craig chambers susan j eggers program slicing dynamic pointsto sets ieee transactions software engineering v31 n8 p657678 august 2005 chris lattner vikram adve llvm compilation framework lifelong program analysis transformation proceedings international symposium code generation optimization feedbackdirected runtime optimization p75 march 2024 2004 palo alto california martin hirzel daniel von dincklage amer diwan michael hind fast online pointer analysis acm transactions programming languages systems toplas v29 n2 p11es april 2007 michael hind pointer analysis havent solved problem yet proceedings 2001 acm sigplansigsoft workshop program analysis software tools engineering p5461 june 2001 snowbird utah united states david j pearce paul h j kelly chris hankin online cycle detection difference propagation applications pointer analysis software quality control v12 n4 p311337 december 2004 baowen xu ju qian xiaofang zhang zhongqiang wu lin chen brief survey program slicing acm sigsoft software engineering notes v30 n2 march 2005
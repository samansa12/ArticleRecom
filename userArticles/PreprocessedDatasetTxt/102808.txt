waitfree synchronization waitfree implementation concurrent data object one guarantees process complete operation finite number steps regardless execution speeds processes problem constructing waitfree implementation one data object another lies heart much recent work concurrent algorithms concurrent data structures multiprocessor architectures first introduce simple general technique based reduction concensus protocol proving statements form waitfree implementation x derive hierarchy objects object one level waitfree implementation terms objects lower levels particular show atomic readwrite registers focus much recent attention bottom hierarchy thay cannot used construct waitfree implementations many simple familiar data types moreover classical synchronization primitives astestset fetchadd powerful read write also computationally weak standard messagepassing primitives second nevertheless show exist simple universal objects one construct waitfree implementation sequential object b introduction concurrent object data structure shared concurrent processes algorithms implementing concurrent objects lie heart many important problems concurrent systems traditional approach implementing objects centers around use critical sections one process time allowed operate object nevertheless critical sections poorly suited asynchronous faulttolerant systems faulty process halted delayed critical section nonfaulty processes also unable progress even failurefree system process encounter unexpected delay result page fault cache miss exhausting scheduling quantum swapped similar problems arise heterogeneous architectures processors may inherently faster others memory locations may slower access waitfree implementation concurrent data object one guarantees process complete operation finite number steps regardless execution speeds processes waitfree condition provides faulttolerance process prevented completing operation undetected halting failures processes arbitrary variations speed fundamental problem waitfree synchronization phrased follows given two concurrent objects x exist waitfree implementation x clear show waitfree implementation exists one displays current literature takes approach examples include atomic registers nonatomic safe registers 19 complex atomic registers simpler atomic registers 4 5 16 23 25 26 29 31 readmodifywrite operations combining networks 11 15 typed objects queues sets simpler objects 14 18 20 less clear show implementation ex ist first part paper propose simple new technique proving statements form waitfree implementation x derive hierarchy objects object one level implement object higher levels see figure 1 basic idea following object associated consensus number maximum number processes object solve simple consensus problem system n concurrent processes show impossible construct waitfree implementation object consensus number n object lower consensus number impossibility results means imply waitfree synchronization impossible infeasible second part paper show exist universal objects one construct waitfree implementation object give simple test univer sality showing object universal system n processes consensus number greater equal n figure 1 object level n universal system n processes machine architecture programming language computationally powerful enough support arbitrary waitfree synchronization provides universal object primitive recent work waitfree synchronization focused construction atomic readwrite registers 4 5 16 19 23 25 26 29 31 results address basic question registers good used construct waitfree implementations complex data structures show atomic registers interesting applications area set atomic registers show impossible construct waitfree implementation 1 common data types sets queues stacks priority queues lists 2 classical synchronization primitives testset compareswap fetchadd 3 simple memorytomemory operations move memorytomemory swap results suggest progress understanding waitfree synchronization requires turning attention conventional read write operations fundamental primitives results also illustrate inherent limitations certain multiprocessor architectures nyu ultracomputer project 10 investigated architectural support waitfree implementations common synchronization primitives use combining networks implement fetchadd generalization testset ibms rp3 8 project investigating similar approach fetchadd operation quite flexible used semaphores highly concurrent queues even database synchronization 11 14 30 nevertheless show universal disproving conjecture gottlieb et al 11 also show messagepassing architectures hypercubes 28 universal either paper organized follows section 2 defines model com putation section 3 presents impossibility results section 4 describes universal objects section 5 concludes summary consensus object number readwrite registers testset swap fetchadd queue stack assignment memorytomemory move swap augmented queue figure 1 impossibility universality hierarchy 2 model informally model computation consists collection sequential threads control called processes communicate shared data structures called objects object type defines set possible states set primitive operations provide means manipulate object process applies sequence operations ob jects issuing invocation receiving associated response basic correctness condition concurrent systems linearizability 14 although operations concurrent processes may overlap operation appears take effect instantaneously point invocation sponse particular operations overlap take effect realtime order 21 io automata formally model objects processes using simplified form io automata 22 waitfree condition require fairness liveness conditions consider finite sets processes objects make use full power io automata formalism nevertheless simplified io automata provide convenient way describe basic structure model give basic definition means one object implement another brevity later constructions impossibility results expressed less formally using pseudocode straightforward exercise translate notation io automata io automaton nondeterministic automaton following ffl statesa finite infinite set states including distinguished set starting states ffl ina set input events ffl outa set output events ffl inta set internal events ffl stepsa transition relation given set triples 0 states e event triple called step means automaton state 0 undergo transition state transition associated event e step say e enabled 0 io automata must satisfy additional condition inputs cannot disabled input event e state 0 exist state step execution fragment automaton finite sequence infinite sequence alternating states events step execution execution fragment 0 starting state history fragment automaton subsequence events occurring execution fragment history subsequence occurring execution new io automaton constructed composing set compatible io automata paper consider finite compositions set automata compatible share output internal events state composed automaton tuple component states starting state tuple component starting states set events eventss union components sets events set output events outs union components sets output events set internal events ints union components sets internal events set input events ins ins gamma outs input events output events component triple stepss component automata one following holds 1 e event projection remain consistent terminology 14 use event lynch tuttle use operation history use schedule step onto step 2 e event state components identical 0 note composition associative h history composite automaton component automaton h ja denotes subhistory h consisting events 22 concurrent systems concurrent system set processes set objects processes represent sequential threads control objects represent data structures shared processes process p io automaton output events invokep op x op operation 2 object x input events res result value refer events invocations responses two invocations responses match process object names agree capture notion process represents single thread control say process history wellformed begins invocation alternates matching invocations responses invocation pending followed matching response object x input events invokep op x p process op operation object output events res x res result value process object names unique ensuring process object automata compatible concurrent system fp io automaton composed processes p objects composed identifying corresponding invoke respond events history concurrent system wellformed h jp wellformed concurrent system wellformed histories wellformed henceforth restrict attention wellformed concurrent systems execution sequential first event invocation alternates matching invocations responses history sequential derived sequential execution notice sequential execution permits process steps interleaved granularity complete operations restrict attention sequential histories behavior object specified particularly simple way giving pre postconditions operation refer specification sequential specification paper consider objects whose sequential specifications total object pending invocation may also include argument values matching enabled response example partial deq might undefined applied empty queue total deq would return exception restrict attention objects whose operations total unclear interpret waitfree condition partial operations example natural way define effects partial deq concurrent system wait queue becomes nonempty specification clearly admit waitfree implementation history h induces partial realtime order oe h opera tions op 0 oe h op 1 response op 0 precedes invocation op 1 operations unrelated oe h said concurrent h sequential oe h total order let completeh denote maximal subsequence h consisting invocations matching responses concurrent system linearizable history h exists sequential history ffl words history appears sequential individual process apparent sequential interleaving respects realtime precedence ordering operations equivalently operation appears take effect instantaneously point invocation response concurrent object linearizable 14 every history h every concurrent system linearizable linearizable object thus equivalent sequential object operations also specified simple pre postconditions henceforth objects assumed linearizable unlike related correctness conditions sequential consistency 17 strict serializability 24 linearizability local property concurrent system linearizable individual object linearizable 14 restrict attention linearizable concurrent systems 23 implementations implementation object concurrent system ff f called frontends r called representation object informally r data structure implements f procedure called process p execute operation object implementation shown schematically figure 2 oe process invoke oe respond oe frontend invoke oe respond oe object r object figure 2 schematic view object implementation ffl external events implementation external events input event input event f output event output event ffl implementation following internal events input event r composed matching output event f output event res r r composed matching input event f ffl rule certain trivial solutions frontends share events communicate indirectly r let j implementation j j correct every history h every system fp exists history h 0 fp g hjfp g implementation waitfree ffl history invocation p remains pending across infinite number steps f ffl p pending invocation state exists history fragment starting consisting entirely events f r includes response invocation first condition rules unbounded busywaiting frontend cannot take infinite number steps without responding invocation second condition rules conditional waiting f cannot block waiting another process make condition true note found necessary make fairness liveness assumptions waitfree implementation guarantees r eventually responds invocations f f eventually respond invocations p independently process speeds implementation bounded waitfree exists n history invocation p remains pending across n steps f bounded waitfree implies waitfree viceversa use waitfree condition impossibility results bounded waitfree condition universal constructions brevity say r implements exists waitfree implementation immediate definitions implements reflexive partial order universe objects rest paper investigate mathematical structure implements relation next section introduce simple technique proving one object implement another following section display universal objects capable implementing object 3 impossibility results informally consensus protocol system n processes communicate set shared objects fx g processes start input value domain communicate one another applying operations shared objects eventually agree common input value halt consensus protocol required ffl consistent distinct processes never decide distinct values ffl waitfree process decides finite number steps ffl valid common decision value input process purposes convenient express consensus problem using terminology abstract data types consensus object provides single operation decideinput value returnsvalue protocols sequential specification simple decide operations return argument value first decide cf plotkins stickybit 27 common value called historys decision value waitfree linearizable implementation consensus object called consensus protocol cf fisher lynch paterson 9 investigate circumstances possible construct consensus protocols particular objects constructions presented paper use multireadermultiwriter registers addition object interest brevity say x solves nprocess consensus exists consensus protocol ff set readwrite registers w x may initialized state 1 consensus number x largest n x solves nprocess consensus largest n exists consensus number said infinite immediate consequence definitions implements x x solves nprocess consensus also solves nprocess consensus theorem 2 x consensus number n consensus number exists waitfree implementation x system processes proof noted frontend object automata compatible definition thus composition welldefined let ff consensus protocol k w set readwrite regis ters let ff 0 implementation x easily checked waitfree composition associative identical ff 1 1 composition f f 0 since former consensus protocol latter contradicting hypothesis consensus number rest section consider number objects displaying consensus protocols impossibility results others impossibility proofs usually assume existence consensus protocol derive contradiction constructing sequential execution forces protocol run forever constructing consensus protocol particular linearizable object observe linearizability condition implies exists execution consensus fails either inconsistent invalid runs forever exists gammapsi reads r runs alone decides r decides x runs alone figure 3 p reads first gammapsi xvalent state r yvalent state gammapsi r figure 4 p q write different registers equivalent sequential execution property consequence consensus protocol correct sequential executions correct brevity protocols defined informally pseudocode translations io automata selfevident 31 atomic readwrite registers section show exists twoprocess consensus protocol using multireadermultiwriter atomic registers first terminology protocol state bivalent either decision value still possible ie current execution extended yield different decision values otherwise univalent xvalent state univalent state eventual decision value x decision step operation carries protocol bivalent univalent state theorem 3 readwrite registers consensus number 1 gammapsi r gammapsi gammapsi decides x runs alone gammapsi decides runs alone figure 5 p q write register proof assume exists twoprocess consensus protocol implemented atomic readwrite registers derive contradiction constructing infinite sequential execution keeps protocol bivalent state processes different input values validity condition implies initial state bivalent consider following sequential execution starting initial state first stage p executes sequence operations ie alternates matching invocation response events reaches state next operation leave protocol univalent state p must eventually reach state since cannot run forever cannot block second stage q executes sequence operations reaches similar state successive stages p q alternate sequences operations make decision step protocol cannot run forever must eventually reach bivalent state subsequent operation either process decision step suppose p operation carries protocol xvalent state qs operation carries protocol yvalent state x distinct ffl suppose decision step one process say p read shared register figure 3 let 0 protocol state immediately following read protocol history fragment starting con rmwr register f function returnsvalue previous r r fr return previous figure sisting entirely operations q yielding decision value since states 0 differ internal state p protocol history fragment starting 0 impossibility 0 xvalent ffl suppose processes write different registers figure 4 state results p write immediately followed qs identical state results writes occur opposite order impossible since one state xvalent yvalent ffl suppose processes write register figure 5 let 0 xvalent state immediately p write exists history fragment starting 0 consisting entirely operations p yields decision value x let 00 yvalent state reached qs write immediately followed p p overwrites value written q 0 00 differ internal states q therefore protocol history fragment starting 00 impossibility since 00 yvalent similar results shown loui abuamara 21 chor israeli li 6 anderson gouda 1 contribution lies following corollary corollary 4 impossible construct waitfree implementation object consensus number greater 1 using atomic readwrite registers 32 readmodifywrite operations decideinput value returnsvalue preferp input return preferp else return preferq decide figure 7 readmodifywrite twoprocess consensus kruskal rudolph snir 15 observed many classical synchronization primitives expressed readmodify write operations defined follows let r register f function values values operation rmwr f informally defined procedure shown figure 6 executed atomically f iden tity rmwr f simply read operation readmodifywrite operation nontrivial f identity function examples wellknown nontrivial readmodifywrite operations include testset swap compareswap fetchadd numerous others given 15 theorem 5 register nontrivial readmodifywrite operation consensus number least 2 proof since f identity exists value v v 6 fv let p q two processes share tworegister array prefer entry initialized readmodifywrite register r initialized v p executes protocol shown figure 7 qs protocol symmetric expressed terms io automaton model readmodifywrite register r object x prefer array set atomic registers w pseudocode figure 7 defines frontend automaton frontend three output events write rmw invocations sent r prefer decision value returned p similarly input events p invocation decide responses write rmw invocations noted r prefer linearizable suffices check correctness sequential executions operations commute two readmodifywrite operations applied r protocol chooses p input p operation occurs first qs input otherwise corollary 6 impossible construct waitfree implementation nontrivial readmodifywrite operation set atomic readwrite registers system two processes although readmodifywrite registers powerful readwrite registers many common readmodifywrite operations still computationally weak particular one cannot construct waitfree solution three process consensus using registers support combination read write testset swap fetchadd operations let f set functions indexed arbitrary set define f interfering values v j either 1 f f j commute f f j 2 one function overwrites either f f j theorem 7 waitfree solution threeprocess consensus using combination readmodifywrite operations apply functions interfering set f proof contradiction let three processes p q r proof theorem 2 construct sequential execution leaving protocol bivalent state every operation enabled p q decision step operation p carries protocol xvalent state operation q carries protocol yvalent state x distinct usual commutativity argument p q must operate register say p executes let v current value register r two cases consider first suppose f f j v state results p executes xvalent thus exists history fragment consisting entirely operations r yields decision value x let 0 state results p q execute operations reverse order since register values identical 0 protocol history fragment starting 0 contradicting hypothesis 0 yvalent second suppose f f j v state results p executes xvalent thus exists history fragment consisting entirely operations r yields decision value x let 0 state results q alone executes operation since register values identical 0 protocol compareswapr register old value new value returnsvalue previous r previous old r new return previous figure 8 compareswap history fragment starting 0 contradicting hypothesis 0 valent follows one cannot use combination classical primitives construct waitfree implementation object consensus number greater 2 another classical primitive compareswap shown figure 8 primitive takes two values old new registers current value equal old replaced new otherwise left unchanged registers old value returned theorem 8 compareswap register infinite consensus number proof protocol shown figure 9 processes share register r initialized process attempts replace input decision value established process succeeds protocol clearly waitfree since contains loops consistency follows following observations 1 r 6 postcondition compareswap 2 v 6 assertion r v stable becomes true remains true validity follows observation r 6 r contains processs input corollary 9 impossible construct waitfree implementation compareswap register set registers support combination read write testset swap fetchadd operations system three processes decideinput value returnsvalue first compareswapr input return input else return first decide figure 9 compareswap nprocess consensus decideinput value returnsvalue preferp input return preferp else return preferq decide figure 10 fifo queues twoprocess consensus 33 queues stacks lists etc consider fifo queue two operations enq places item end queue deq removes item head queue returning error value queue empty theorem 10 fifo queue consensus number least 2 proof figure shows twoprocess consensus protocol queue initialized enqueuing value 0 followed value 1 processes share twoelement array prefer p executes protocol shown figure qs protocol symmetric process dequeues item queue returning preference dequeues 0 others preference dequeues 1 protocol waitfree since contains loops process returns input must dequeued 0 violating queue specification returns others input must dequeued 1 also violating queue specification let winner process dequeues 0 validity follows observing winners position prefer initialized first queue operation trivial variations program yield protocols stacks priority queues lists sets object operations return different results applied different orders corollary 11 impossible construct waitfree implementation queue stack priority queue set list set atomic readwrite registers although fifo queues solve twoprocess consensus cannot solve threeprocess consensus theorem 12 fifo queues consensus number 2 proof contradiction assume consensus protocol processes maneuver protocol state p q make decision step assume p operation would carry protocol xvalent state qs yvalent state rest case analysis first suppose p q execute deq operations let protocol state p dequeues q dequeues let 0 state dequeues occur opposite order since xvalent exists history fragment consisting entirely operations r yielding decision value x 0 differ internal states p q thus protocol history fragment 0 contradiction 0 yvalent suppose p enq q deq queue nonempty contradiction immediate two operations commute r cannot observe order occurred queue empty yvalent state reached q dequeues p enqueues indistinguishable r xvalent state reached p alone enqueues finally suppose p q enq operations let state end following execution 1 p q enqueue items p q order 2 run p dequeues p since way observe queues state via deq operation p cannot decide observes one p q 3 run q dequeues q let 0 state following alternative execution decideinput value returnsvalue enqq input return peekq decide figure augmented fifo queue nprocess consensus 1 q p enqueue items q p order 2 run p dequeues q 3 run q dequeues p clearly xvalent 0 yvalent p executions identical dequeues p q since p halted modify objects qs executions also identical dequeues p q nowfamiliar argument contradiction arises 0 indistinguishable r trivial variations argument applied show many similar data types sets stacks doubleended queues priority queues consensus number 2 messagepassing architecture eg hypercube 28 set processors communicate via shared fifo queues theorem 12 implies messagepassing architectures cannot solve threeprocess consensus implement object dolev dwork stockmeyer 7 give related result pointtopoint fifo message channels cannot solve twoprocess con sensus result imply theorem 12 however queue item unlike message addressed particular process hence dequeued anyone 34 augmented queue let us augment queue one operation peek returns remove first item queue theorem 13 augmented queue infinite consensus number proof protocol shown figure 11 queue q initialized empty process enqueues input decision value input process whose enq occurs first decideinput value returnsvalue preferp input 1 p1 n 3 ri n 1 6 return preferi 8 decide figure 12 memorytomemory move nprocess consensus usual protocol waitfree since contains loops consistency follows following observations 1 queue nonempty postcondition enq hence precondition peek 2 v v first item queue stable validity follows observation first item queue processs input corollary 14 impossible construct waitfree implementation augmented queue set registers supporting combination read write testset swap fetchadd operations corollary 15 impossible construct waitfree implementation augmented queue set regular queues fetchcons operation atomically threads item onto front linked list argument virtually identical one given theorem 13 linked list fetchcons infinite consensus number 35 memorytomemory operations consider collection atomic readwrite registers one additional operation move atomically copies value one register another 3 use expression b move contents b 3 memorytomemory move confused assignment former copies values two public registers latter copies values public private registers theorem array registers move infinite consensus number proof nprocess consensus protocol appears figure 12 processes share two arrays prefer1n r1n 12 rp 1 initialized 1 rp 2 0 n protocol clearly waitfree since loops bounded show consistency use following assertions easily checked pp qp sp stable p pp qp mutually exclusive sp true p executes statement 2 si true execution statement 4 say process p stabilized sp holds claim pp holds p qq holds every process q p stabilized let p least process pp holds since rp 1 rp 2 0 must assigned 0 rp 1 statement 4 p executed statement 2 q however executes statement 2 statement 4 hence sq holds since pq false hypothesis qq must hold moreover q assigned rp 1 assigned every rp thus p 0 stabilized define termination assertion follows stable holds one process p finishes first loop statements 35 every process greater equal p stabilized satisfies done otherwise exists largest processes p q stabilized implying q holds p protocol terminates chooses input unique q satisfying q since termination assertion stable processes agree validity follows preferp must initialized p become true decideinput value returnsvalue preferp input q 1 n return preferq end decide figure 13 memorytomemory swap nprocess consensus theorem 17 array registers memorytomemory swap 4 infinite consensus number proof protocol shown figure 13 processes share array registers a1n whose elements initialized 0 single register r initialized 1 first process swap 1 wins protocol waitfree loop bounded show consistency consider following assertions 9p means exists unique p first assertion invariant second stable becomes true first swap follows process observes unique stable p ap validity follows process initializes position prefer executing swap corollary impossible construct waitfree implementation memorytomemory move swap set registers support combination read write testset swap fetchadd operations corollary 19 impossible construct waitfree implementation memorytomemory move swap set fifo queues 4 memorytomemory swap confused readmodifywrite swap former exchanges values two public registers latter exchanges value public register processors private register 36 multiple assignment expression atomically assigns value v register r theorem 20 atomic mregister assignment consensus number least proof protocol uses singlewriter registers r writes register r mmgamma12 multiwriter registers r ij j write register r ij registers initialized process atomically assigns input value registers singlewriter register registers decision value protocol first value assigned assigning registers process determines relative ordering assignments two processes p p j follows value neither assignment occurred ffl otherwise read r r j r value p j precedes p similarly r j ffl neither r r j reread r ij value equal value read r p j precedes p else viceversa repeating procedure process determine value written earliest assignment result improved theorem 21 atomic mregister assignment consensus number least 2 proof consider following twophase protocol process two singlewriter registers one phase pair processes share register divide processes two predefined groups gamma 1 first phase group achieves consensus within using protocol theorem 20 second phase process atomically assigns groups value phasetwo singlewriter register registers shared processes group using ordering procedure described process constructs directed graph g property edge p j p k p j p k different groups formers assignment precedes latters locates source process least one outgoing edge incoming edges returns processs value least one process performed assignment thus g edges let q process whose assignment first linearization order q source outgoing edge every process group thus process group also source therefore source processes belong group algorithm optimal respect number processes theorem 22 atomic mregister assignment consensus number exactly 2 proof show atomic mregister assignment cannot solve 2m gamma 1 process consensus 1 usual construction maneuver protocol bivalent state subsequent operation executed process decision step refer decision value forced process default first show process must singlewriter register alone writes suppose let p q processes distinct defaults x let 0 state reached p performs assignment q performs assignment processes perform p went first 0 xvalent hypothesis every register written p overwritten another process let 00 state reached p halts without writing processes execute order q wrote first 00 yvalent exists history fragment 0 consisting entirely operations q decision value x values registers identical 0 00 protocol history fragment 00 contradiction 00 yvalent next show p q distinct default values must register written two processes suppose let 0 state reached p performs assignment q performs assignment followed processes assignments let 00 state reached sequence operations except p q execute assignments reverse order 0 xvalent exists history fragment 0 consisting operations p decision value x every register written p q overwritten process register values 0 hence protocol history fragment 00 contradiction follows p default value x k processes different default values p must assign k registers default process must disagree least processes process must must assign 1 registers last theorem shows consensus irreducible following sense impossible achieve consensus among 2n processes combining protocols achieve consensus among 2m 2n processes possible one could implement individual 2mprocess protocol using yielding 2nprocess consensus protocol contradicting theorem 22 37 remarks fischer lynch paterson 9 shown exists twoprocess consensus protocol using message channels permit messages delayed reordered result imply theorem 3 however atomic readwrite registers lack certain commutativity properties asynchronous message buffers particular lemma 1 9 hold dolev dwork stockmeyer 7 give thorough analysis circumstances consensus achieved messagepassing consider effects thirtytwo combinations parameters synchronous vs asynchronous processors synchronous vs asynchronous communication fifo vs nonfifo message delivery broadcast vs pointtopoint transmis sion whether send receive distinct primitives expressed terminology model asynchronous processes synchronous communi cation distinct send receive primitives model send receive operations shared message channel object whether delivery fifo whether broadcast supported depends type channel results translate directly model impossible achieve twoprocess consensus communicating shared channel supports either broadcast unordered delivery pointtopoint transmission fifo delivery broadcast ordered delivery however solve nprocess consensus safe readwrite register 19 one behaves like atomic readwrite register long operations overlap read overlaps write however guarantees made value read since atomic registers implement safe registers safe registers cannot solve twoprocess con sensus hence impossibility results derive atomic registers apply equally safe registers similar remarks apply atomic registers restrict number readers writers loui abuamara 21 give number constructions impossibility results consensus protocols using shared readmodifywrite registers call testset registers among results show nprocess consensus n 2 cannot solved readmodifywrite operations singlebit registers lamport 18 gives queue implementation permits one enqueuing process execute concurrently one dequeuing process minor changes implementation transformed waitfree implementation using atomic readwrite registers theorem 3 implies lamports queue cannot extended permit concurrent deq operations without augmenting read write operations powerful primitives concurrent object implementation nonblocking guarantees process complete operation finite number steps regardless relative execution speeds processes nonblocking condition guarantees system whole make progress despite individual halting failures delays waitfree implementation necessarily nonblocking viceversa since nonblocking implementation may permit individual processes starve impossibility universality results presented paper hold nonblocking implementations well waitfree implementations elsewhere 14 give nonblocking implementation fifo queue using read fetchadd swap operations permits arbitrary number concurrent enq deq operations corollary 14 implies queue implementation cannot extended support nonblocking peek operation without introducing powerful primitives 4 universality results object universal implements object section show object consensus number n universal system n fewer processes basic idea following represent object linked list sequence cells represents sequence operations applied object hence objects sequence states process executes operation threading new cell end list cell becomes sufficiently old reclaimed reused construction requires 3 memory cells represent object 3 worstcase time execute operation assume cells hold integers unbounded size presentation intended emphasize simplicity omits many obvious optimizations let invoc objects domain invocations result domain results state domain states objects behavior may specified following relation apply ae invoc theta state theta state theta result specification means applying operation p state leaves object state 0 returns result value r hp ri 2 apply apply relation rather function operation may nondeterministic brevity use notation applyp denote arbitrary pair hs ri hp ri 2 apply 41 algorithm object represented doublylinked list cells following fields ffl seq cells sequence number list field zero cell initialized yet threaded onto list otherwise positive sequence numbers successive cells list increase one ffl inv invocation operation name argument values ffl new consensus object whose value pair hnewstate newresulti first component objects state following operation second operations result value ffl pointer previous cell list field used free storage management ffl consensus object whose value pointer next cell list c cells function maxc returns cell higher sequence number initially object represented unique anchor cell sequence number 1 holding creation operation initial state processes share following data structures ffl announce nelement array whose p th element pointer cell p currently trying thread onto list initially elements point anchor cell ffl head nelement array whose p th element pointer last cell list p observed initially elements point anchor cell let maxhead maxhead denote assertion pointer cell c assigned head q q use following auxiliary variables set cells whose addresses stored head array since p last announcement startp value maxhead p last announcement notice auxiliary variables affect protocols control flow present facilitate proofs protocol process p shown figure 14 figure v declares initializes variable v type value e type cell means pointer cell sequences statements enclosed angle brackets executed atomically compound state ments first affects shared data control flow remainder bookkeeping operations update auxiliary variables readability auxiliary variables shown italics informally protocol works follows p allocates initializes cell represent operation statement 1 stores pointer cell announcep statement 2 ensuring p succeed threading cell onto list process locate cell near end list p scans head array setting head p cell maximal sequence number statement 3 p enters main loop protocol statement 4 executes cell threaded onto list detected sequence number becomes non zero p chooses process help statement 6 checks whether process unthreaded cell statement 7 p try thread otherwise tries thread cell helping step omitted protocol would nonblocking rather waitfree p tries set head p point cell trying thread statement 8 field must consensus cell ensure one process succeeds setting whether p succeeds initializes remaining fields next cell list operation may nondeterministic different processes may try set new field different values field must consensus object statement 9 values fields computed deterministically simply written atomic registers statements 10 11 brevity say process threads cell statement 7 decide operation alters value field announces cell statement 2 stores cells address announce lemma 23 following assertion invariant proof jconcurp j n concurp includes successive cells q r respective sequence numbers equal threaded processes q r q concurp q threads q p announcement r cannot modify unthreaded cell r reads announcep statement 5 q threads q follows r reads announcep p announcement therefore either announcep already threaded r p lemma 23 places bound number cells threaded operation progress give sequence lemmas showing p finishes scanning head array either announcep threaded head p lies within cells end list lemma 24 following assertion invariant proof sequence number head q nondecreasing universalwhat invoc returnsresult mine cell seq 0 1 inv new createconsensus object createconsensus object null process q 3 end announcep c cell headp help cell announcecseq mod n prefer help else prefer announcep decidecafter prefer 8 decidednew applydinv cnewstate 9 dbefore hheadp hheadp return announcep newresult 14 universal figure 14 universal construction lemma 25 following loop invariant statement 3 maxhead p q loop index proof q 1 assertion implied lemma 24 truth assertion preserved iteration head p replaced maxhead p head q lemma 26 following assertion holds statement 4 head p seq startp proof loop statement 3 maxhead p head head p seq result follows lemma 25 lemma 27 following invariant proof lower bound follows lemma 26 upper bound follows equation 1 theorem 28 protocol figure 14 correct bounded waitfree proof linearizability immediate since order cells threaded clearly compatible natural partial order corresponding operations protocol bounded waitfree p execute main loop times iteration head p seq increases one implies lemma 23 implies announcep must threaded 42 memory management section discuss cells allocated reclaimed reclaim cell assume consensus object provides reset operation restores object state reused new round consensus construction resets consensus object concurrent operations progress basic idea following process executing operation traverse cell threaded theorem 28 conversely cell traversed times process finished threading cell releases preceding cells setting bit cell released recycle cell holds additional field array released n bits initially false process completes operation scans setting releasedi true cell distance process maintains private pool cells process needs allocate new cell scans pool reinitializes first cell whose released bits true assume object pool particular cells new sequence number exceeds old sequence number process p allocating new cell list representing object includes n gamma 1 incomplete operations cell inhibit reclamation n cells ensure p find needs pool least n 2 cells note locating free cell requires worst 3 read operations since process may scan cells cell requires reading bits atomic fetchadd operation available counter used instead released bits free cell located 2 read operations proof lemma 23 remains unchanged lemma 24 observe cell reclaimed followed list least n 1 cells hence reclaiming cell cannot affect value maxhead statement lemma 26 needs strengthened lemma 29 following assertion holds statement 4 proof p announces cell process q head q sequence number greater equal startp cell reclaimed n1 cells threaded front implying jconcurp j n 1 hence announcep proof theorem 28 proceeds one last detail check p cell threaded time finishes scanning head claim none cells traverses reclaimed operation progress lemma 23 states list cannot grown n cells since p announcement thus every cell reachable lies within n1 cells end list announcep threaded either case cells cannot reclaimed p operation progress since must least one released bit unset 43 remarks first universal construction 12 used unbounded memory plotkin 27 describes universal construction employing stickybyte registers kind writeonce memory plotkins construction cells allocated common pool reclaimed way similar author 13 describes universal construction using compareswap currently implemented multiprocessor randomized waitfree implementation concurrent object one guarantees process complete operation finite expected number steps elsewhere 2 give randomized consensus protocol using atomic registers whose expected running time polynomial number processes protocol several important implications waitfree guarantee allowed probabilistic nature hierarchy shown figure 1 collapses atomic registers become uni versal moreover combining randomized consensus protocol universal construction yields polynomialtime randomized universal con struction barnoy dolev 3 adapted randomized consensus protocol messagepassing model protocol used manage randomized waitfree replicated data objects conclusions waitfree synchronization represents qualitative break traditional lockingbased techniques implementing concurrent objects tried suggest resulting theory rich structure yielding number unexpected results consequences algorithm design multiprocessor architectures realtime systems nevertheless many interesting problems remain unsolved little known lower bounds universal constructions terms time rounds consensus space number cells implements relation may additional structure shown impossibility hierarchy figure 1 example atomic registers implement object consensus number 1 system two processes fetchadd implement object consensus number 2 system three processes implements relation different structure bounded waitfree waitfree nonblocking synchronization finally little known practical implementation techniques acknowledgments grateful jim aspnes vladimir lanin michael merritt serge plotkin mark tuttle jennifer welch anonymous referees many invaluable suggestions r virtue patience concurrent programming without waiting fast randomized consensus using shared memory shared memory vs messagepassing asynchronous distributed environment constructing twowriter atomic registers constructing multireader atomic values nonatomic values processor coordination using asynchronous hardware minimal synchronism needed distributed consensus ibm research parallel processor prototype rp3 introduction architecture impossibility distributed commit one faulty process nyu ultracomputer designing mimd parallel com puter basic techniques efficient coordination large numbers cooperating sequential processors impossibility universality results waitfree syn chronization methodology implementing highly concurrent data structures axioms concurrent objects concurrent reading writing make multiprocessor computer correctly executes multiprocess programs specifying concurrent program modules interprocess communication concurrent set manipulation without lock ing memory requirements agreement among unreliable asynchronous processes introduction inputoutput au tomata protocol waitfree serializability concurrent database updates concurrent reading writing concurrent reading writing ii multiwriter case bits universality consensus cosmic cube elusive atomic register revisited database applications fetchandadd instruction atomic shared register access asynchronous hardware tr cosmic cube minimal synchronism needed distributed consensus efficient synchronization multiprocessors shared memory axioms concurrent objects processor coordination using asynchronous hardware elusive atomic register revisited constructing multireader atomic values nonatomic values protocol waitfree atomic multireader shared variables constructing twowriter atomic registers impossibility universality results waitfree synchronization bits universality consensus sharedmemory vs messagepassing asynchronous distributed environment fast randomized consensus using shared memory methodology implementing highly concurrent data structures impossibility distributed consensus one faulty process concurrent set manipulation without locking serializability concurrent database updates concurrent reading writing basic techniques efficient coordination large numbers cooperating sequential processors specifying concurrent program modules concurrent reading writing ctr ted herman valeriu damianiordache spaceoptimal waitfree queues proceedings sixteenth annual acm symposium principles distributed computing p280 august 2124 1997 santa barbara california united states matei david brief announcement single enqueuer waitfree queue implementation proceedings twentythird annual acm symposium principles distributed computing july 2528 2004 st johns newfoundland canada john valois space bounds transactional synchronization proceedings fifteenth annual acm symposium principles distributed computing p243 may 2326 1996 philadelphia pennsylvania united states waikau lo martha j kosa lazywriter multivalued registers proceedings fourteenth annual acm symposium principles distributed computing p270 august 2023 1995 ottowa ontario canada jason liu david nicol king tan lockfree scheduling logical processes parallel simulation proceedings fifteenth workshop parallel distributed simulation p2231 may 1518 2001 lake arrowhead california united states philippas tsigas yi zhang simple fast scalable nonblocking concurrent fifo queue shared memory multiprocessor systems proceedings thirteenth annual acm symposium parallel algorithms architectures p134143 july 2001 crete island greece olin shivers james w clark roland mcgrath atomic heap transactions finegrain interrupts acm sigplan notices v34 n9 p4859 sept 1999 shenk consensus hierarchy robust proceedings sixteenth annual acm symposium principles distributed computing p279 august 2124 1997 santa barbara california united states robert blumofe dionisios papadopoulos performance work stealing multiprogrammed environments extended abstract acm sigmetrics performance evaluation review v26 n1 p266267 june 1998 martha j kosa waitfree lazywriter registers eager readers proceedings 36th annual southeast regional conference p274276 april 1998 p herlihy j e b moss lockfree garbage collection multiprocessors ieee transactions parallel distributed systems v3 n3 p304311 may 1992 hadzilacos note group mutual exclusion proceedings twentieth annual acm symposium principles distributed computing p100106 august 2001 newport rhode island united states james h anderson mark moir universal constructions multiobject operations proceedings fourteenth annual acm symposium principles distributed computing p184193 august 2023 1995 ottowa ontario canada james h anderson mark moir waitfree synchronization multiprogrammed systems integrating prioritybased quantumbased scheduling proceedings eighteenth annual acm symposium principles distributed computing p123132 may 0406 1999 atlanta georgia united states consensus numbers multiobjects proceedings seventeenth annual acm symposium principles distributed computing p211217 june 28july 02 1998 puerto vallarta mexico progress bounded fairness distributed computing v12 n4 p197207 september 1999 mikhail fomitchev eric ruppert lockfree linked lists skip lists proceedings twentythird annual acm symposium principles distributed computing july 2528 2004 st johns newfoundland canada partha dutta rachid guerraoui ron r levy arindam chakraborty fast distributed atomic read proceedings twentythird annual acm symposium principles distributed computing july 2528 2004 st johns newfoundland canada hkan sundell philippas tsigas scalable lockfree concurrent dictionaries proceedings 2004 acm symposium applied computing march 1417 2004 nicosia cyprus donald e porter owen hofmann emmett witchel optimism optimistic concurrency warranted proceedings 11th usenix workshop hot topics operating systems p16 may 0709 2007 san diego ca gary l peterson rida bazzi gil neiger gap theorem consensus types extended abstract proceedings thirteenth annual acm symposium principles distributed computing p344353 august 1417 1994 los angeles california united states waikau lo vassos hadzilacos us smarter us waitfree hierarchies robust proceedings twentyninth annual acm symposium theory computing p579588 may 0406 1997 el paso texas united states tushar chandra vassos hadzilacos prasad jayanti sam toueg waitfreedom vs jon kleinberg sendhil mullainathan resource bounds combinations consensus objects proceedings twelfth annual acm symposium principles distributed computing p133143 august 1518 1993 ithaca new york united states waikau lo vassos hadziolacos power shared object types implement oneresilient consensus proceedings sixteenth annual acm symposium principles distributed computing p101110 august 2124 1997 santa barbara california united states richard j anderson primitives asynchronous list compression proceedings fourth annual acm symposium parallel algorithms architectures p199208 june 29july 01 1992 san diego california united states michael l scott william n scherer scalable queuebased spin locks timeout acm sigplan notices v36 n7 p4452 july 2001 philippas tsigas yi zhang integrating nonblocking synchronisation parallel applications performance advantages methodologies proceedings 3rd international workshop software performance july 2426 2002 rome italy paul attie waitfree byzantine consensus information processing letters v83 n4 p221227 31 august 2002 jan friso groote wim h hesselink sjouke mauw rogier vermeulen algorithm asynchronous writeall problem based process collision distributed computing v14 n2 p7581 april 2001 simon doherty maurice herlihy victor luchangco mark moir bringing practical lockfree synchronization 64bit applications proceedings twentythird annual acm symposium principles distributed computing july 2528 2004 st johns newfoundland canada linearization assertional proof distributed computing v8 n2 p6580 october 1994 dimitrios nikolopoulos theodore papatheodorou quantitative architectural evaluation synchronization algorithms disciplines ccnuma systems case sgi origin2000 proceedings 13th international conference supercomputing p319328 june 2025 1999 rhodes greece mark moir practical implementations nonblocking synchronization primitives proceedings sixteenth annual acm symposium principles distributed computing p219228 august 2124 1997 santa barbara california united states danny hendler nir shavit nonblocking stealhalf work queues proceedings twentyfirst annual symposium principles distributed computing july 2124 2002 monterey california rachid guerraoui benot garbinato karim r mazouni garf library dsm consistency models proceedings 6th workshop acm sigops european workshop matching operating systems application needs september 1214 1994 wadern germany jaeheon yang james h anderson time bounds mutual exclusion related problems proceedings twentysixth annual acm symposium theory computing p224233 may 2325 1994 montreal quebec canada srikanth ramamurthy mark moir james h anderson realtime object sharing minimal system support proceedings fifteenth annual acm symposium principles distributed computing p233242 may 2326 1996 philadelphia pennsylvania united states waikau lo vassos hadzilacos power shared object types implement oneresilient consensus distributed computing v13 n4 p219238 november 2000 liqiang wang scott stoller static analysis atomicity programs nonblocking synchronization proceedings tenth acm sigplan symposium principles practice parallel programming june 1517 2005 chicago il usa john bruno jos brustoloni eran gabber avi silberschatz christopher small pebble componentbased operating system embedded applications proceedings workshop embedded systems workshop embedded systems p77 march 2931 1999 cambridge massachusetts prasad jayanti robustness herlihys hierarchy proceedings twelfth annual acm symposium principles distributed computing p145157 august 1518 1993 ithaca new york united states ramesh subramonian designing synchronous algorithms asynchronous processors proceedings fourth annual acm symposium parallel algorithms architectures p189198 june 29july 01 1992 san diego california united states maged michael high performance dynamic lockfree hash tables listbased sets proceedings fourteenth annual acm symposium parallel algorithms architectures august 1013 2002 winnipeg manitoba canada hagit attiya eyal dagan universal operations unary versus binary proceedings fifteenth annual acm symposium principles distributed computing p223232 may 2326 1996 philadelphia pennsylvania united states svend frlund rachid guerraoui xability theory replication proceedings nineteenth annual acm symposium principles distributed computing p229237 july 1619 2000 portland oregon united states xiaozhou li c greg plaxton name resolution peertopeer networks proceedings second acm international workshop principles mobile computing october 3031 2002 toulouse france rida bazzi gil neiger gary l peterson use registers achieving waitfree consensus proceedings thirteenth annual acm symposium principles distributed computing p354362 august 1417 1994 los angeles california united states hansj boehm almost nonblocking stack proceedings twentythird annual acm symposium principles distributed computing july 2528 2004 st johns newfoundland canada james h anderson mark moir universal constructions large objects ieee transactions parallel distributed systems v10 n12 p13171332 december 1999 maged michael scalable lockfree dynamic memory allocation acm sigplan notices v39 n6 may 2004 n scherer iii doug lea michael l scott scalable synchronous queues proceedings eleventh acm sigplan symposium principles practice parallel programming march 2931 2006 new york new york usa faith fich danny hendler nir shavit inherent weakness conditional synchronization primitives proceedings twentythird annual acm symposium principles distributed computing july 2528 2004 st johns newfoundland canada joseph berrios manuel e bermudez using waitfree synchronization design distributed applications future generation computer systems v22 n1 p4656 january 2006 leslie lamport arbitrationfree synchronization distributed computing v16 n23 p219237 september faith ellen fich danny hendler nir shavit inherent weakness conditional primitives distributed computing v18 n4 p267277 march 2006 taisuke izumi toshimitsu masuzawa weaklyadaptive conditionbased consensus algorithm asynchronous distributed systems information processing letters v100 n5 p199205 december 2006 w craig scratchley using smalltalk waitfree implementation highlyconcurrent objects acm sigplan oops messenger v4 n4 p4453 oct 1993 yehuda afek michael merritt gadi taubenfeld power multiobjects extended abstract proceedings fifteenth annual acm symposium principles distributed computing p213222 may 2326 1996 philadelphia pennsylvania united states alur hagit attiya gadi taubenfeld timeadaptive algorithms synchronization proceedings twentysixth annual acm symposium theory computing p800809 may 2325 1994 montreal quebec canada stephen menke mark moir srikanth ramamurthy synchronization mechanisms scramnet systems proceedings seventeenth annual acm symposium principles distributed computing p7180 june 28july 02 1998 puerto vallarta mexico frank stomp gadi taubenfeld constructing reliable testset bit ieee transactions parallel distributed systems v10 n3 p252265 march 1999 prasad jayanti robust waitfree hierarchies journal acm jacm v44 n4 p592614 july 1997 j strother moore mechanically checked proof multiprocessor result via uniprocessor view formal methods system design v14 n2 p213228 march 1999 concurrent memory management create read deletion carud distributed computing v14 n1 p3139 january 2001 prasad jayanti farrays implementation applications proceedings twentyfirst annual symposium principles distributed computing july 2124 2002 monterey california maged michael hazard pointers safe memory reclamation lockfree objects ieee transactions parallel distributed systems v15 n6 p491504 june 2004 james h anderson yongjik kim generic localspin fetchandbased mutual exclusion algorithm journal parallel distributed computing v67 n5 p551580 may 2007 ruppert determining consensus numbers proceedings sixteenth annual acm symposium principles distributed computing p9399 august 2124 1997 santa barbara california united states yehuda afek gideon stupp dan touitou longlived adaptive atomic snapshot immediate snapshot extended abstract proceedings nineteenth annual acm symposium principles distributed computing p7180 july 1619 2000 portland oregon united states maged michael safe memory reclamation dynamic lockfree objects using atomic reads writes proceedings twentyfirst annual symposium principles distributed computing july 2124 2002 monterey california tushar deepak chandra prasad jayanti king tan polylog time waitfree construction closed objects proceedings seventeenth annual acm symposium principles distributed computing p287296 june 28july 02 1998 puerto vallarta mexico hagit attiya arie fouren adaptive waitfree algorithms lattice agreement renaming extended abstract proceedings seventeenth annual acm symposium principles distributed computing p277286 june 28july 02 1998 puerto vallarta mexico juan alemany edward w felten performance issues nonblocking synchronization sharedmemory multiprocessors proceedings eleventh annual acm symposium principles distributed computing p125134 august 1012 1992 vancouver british columbia canada dahlia malkhi michael merritt michael k reiter gadi taubenfeld objects shared byzantine processes distributed computing v16 n1 p3748 february h gao j f groote w h hesselink lockfree dynamic hash tables open addressing distributed computing v18 n1 p2142 july 2005 guy e blelloch perry cheng phillip b gibbons room synchronizations proceedings thirteenth annual acm symposium parallel algorithms architectures p122133 july 2001 crete island greece yehuda afek gideon stupp delimiting power bounded size synchronization objects extended abstract proceedings thirteenth annual acm symposium principles distributed computing p4251 august 1417 1994 los angeles california united states weights contention balancing networks proceedings thirteenth annual acm symposium principles distributed computing p193205 august 1417 1994 los angeles california united states j aspnes herlihy waitfree data structures asynchronous pram model proceedings second annual acm symposium parallel algorithms architectures p340349 july 0206 1990 island crete greece maurice herlihy sergio rajsbaum set consensus using arbitrary objects preliminary version proceedings thirteenth annual acm symposium principles distributed computing p324333 august 1417 1994 los angeles california united states john valois lockfree linked lists using compareandswap proceedings fourteenth annual acm symposium principles distributed computing p214222 august 2023 1995 ottowa ontario canada maurice p herlihy j e b moss lockfree garbage collection multiprocessors proceedings third annual acm symposium parallel algorithms architectures p229236 july 2124 1991 hilton head south carolina united states jaaphenk hoepman marina papatriantafilou philippas tsigas selfstabilization waitfree shared memory objects journal parallel distributed computing v62 n5 p818842 may 2002 danny hendler nir shavit operationvalency cost coordination proceedings twentysecond annual symposium principles distributed computing p8491 july 1316 2003 boston massachusetts hagit attiya alla gorbach shlomo moran computing totally anonymous asynchronous shared memory systems information computation v173 n2 p162183 march 15 2002 hkan sundell philippas tsigas fast lockfree concurrent priority queues multithread systems journal parallel distributed computing v65 n5 p609627 may 2005 alur gadi taubenfeld fast timingbased algorithms distributed computing v10 n1 p110 july 1996 michel raynal waitfree computing introductory lecture future generation computer systems v21 n5 p655663 may 2005 hagit attiya rachid guerraoui danny hendler petr kouznetsov synchronizing without locks inherently expensive proceedings twentyfifth annual acm symposium principles distributed computing july 2326 2006 denver colorado usa h gao w h hesselink general lockfree algorithm using compareandswap information computation v205 n2 p225241 february 2007 ronald c unrau orran krieger benjamin gamsa michael stumm experiences locking numa multiprocessor operating system kernel proceedings 1st usenix conference operating systems design implementation p11es november 1417 1994 monterey california yehuda afek eytan weisberger hanan weisman completeness theorem class synchronization objects proceedings twelfth annual acm symposium principles distributed computing p159170 august 1518 1993 ithaca new york united states michael saks fotios zaharoglou waitfree ravi rajwar james r goodman transactional lockfree execution lockbased programs acm sigops operating systems review v36 n5 december 2002 danny hendler nir shavit operationvalency cost coordination proceedings twentysecond annual symposium principles distributed computing p8491 july 1316 2003 boston massachusetts faith fich maurice herlihy nir shavit space complexity randomized synchronization proceedings twelfth annual acm symposium principles distributed computing p241249 august 1518 1993 ithaca new york united states victor luchangco mark moir nir shavit nonblocking kcomparesingleswap proceedings fifteenth annual acm symposium parallel algorithms architectures june 0709 2003 san diego california usa simon doherty david l detlefs lindsay grove christine h flood victor luchangco paul martin mark moir nir shavit guy l steele jr dcas silver bullet nonblocking algorithm design proceedings sixteenth annual acm symposium parallelism algorithms architectures june 2730 2004 barcelona spain rida bazzi gil neiger gary l peterson use registers achieving waitfree consensus distributed computing v10 n3 p117127 april 1997 michael merritt gadi taubenfeld atomic mregister operations distributed computing v7 n4 p213221 may 1994 rachid guerraoui marko vukoli fast robust read proceedings twentyfifth annual acm symposium principles distributed computing july 2326 2006 denver colorado usa yehuda afek eli gafni adam morrison common2 extended stacks unbounded concurrency proceedings twentyfifth annual acm symposium principles distributed computing july 2326 2006 denver colorado usa yehuda afek david greenberg michael merritt gadi taubenfeld computing faulty shared memory proceedings eleventh annual acm symposium principles distributed computing p4758 august 1012 1992 vancouver british columbia canada manhoi choy ambuj k singh efficient faulttolerant algorithms distributed resource allocation acm transactions programming languages systems toplas v17 n3 p535559 may 1995 yehuda afek dalia dauber dan touitou waitfree made fast proceedings twentyseventh annual acm symposium theory computing p538547 may 29june 01 1995 las vegas nevada united states prasad jayanti lower bound local time complexity universal constructions proceedings seventeenth annual acm symposium principles distributed computing p183192 june 28july 02 1998 puerto vallarta mexico james h anderson srikanth ramamurthy kevin jeffay realtime computing lockfree shared objects acm transactions computer systems tocs v15 n2 p134165 may 1997 miltos grammatikakis marcello coppola fabrizio sensini software multiprocessor networks chip networks chip kluwer academic publishers hingham maurice herlihy beyond registers waitfree readable objects proceedings twentieth annual acm symposium principles distributed computing p2642 august 2001 newport rhode island united states hansj boehm threads cannot implemented library acm sigplan notices v40 n6 june 2005 maurice herlihy victor luchangco paul martin mark moir nonblocking memory management support dynamicsized data structures acm transactions computer systems tocs v23 n2 p146196 may 2005 greg barnes method implementing lockfree shareddata structures proceedings fifth annual acm symposium parallel algorithms architectures p261270 june 30july 02 1993 velen germany maurice herlihy benghong lim nir shavit low contention load balancing largescale multiprocessors proceedings fourth annual acm symposium parallel algorithms architectures p219227 june 29july 01 1992 san diego california united states hagit attiya eyal dagan improved implementations binary universal operations journal acm jacm v48 n5 p10131037 september 2001 kai shen hong tang tao yang adaptive twolevel thread management fast mpi execution shared memory machines proceedings 1999 acmieee conference supercomputing cdrom p49es november 1419 1999 portland oregon united states hong tang kai shen tao yang program transformation runtime support threaded mpi execution sharedmemory machines acm transactions programming languages systems toplas v22 n4 p673700 july 2000 edouard bugnion scott devine kinshuk govil mendel rosenblum disco running commodity operating systems scalable multiprocessors acm transactions computer systems tocs v15 n4 p412447 nov 1997 alessandro panconesi marina papatriantafilou philippas tsigas paul vitnyi randomized naming using waitfree shared variables distributed computing v11 n3 p113124 august 1998 mark burgess demosthenes skipitaris adaptive locks frequently scheduled tasks unpredictable runtimes proceedings 11th usenix conference system administration october 2631 1997 san diego california yuhjzer joung asynchronous group mutual exclusion distributed computing v13 n4 p189206 november 2000 panagiota fatourou maurice herlihy readmodifywrite networks distributed computing v17 n1 p3346 february 2004 wojciech golab danny hendler philipp woelfel o1 rmrs leader election algorithm proceedings twentyfifth annual acm symposium principles distributed computing july 2326 2006 denver colorado usa hagit attiya fabian kuhn c greg plaxton mirjam wattenhofer roger wattenhofer efficient adaptive collect using randomization distributed computing v18 n3 p179188 february 2006 alysson neves bessani joni da silva fraga lau cheuk lung bts byzantine faulttolerant tuple space proceedings 2006 acm symposium applied computing april 2327 2006 dijon france daniel stodolsky j bradley chen brian n bershad fast interrupt priority management operating system kernels usenix symposium usenix microkernels kernel architectures symposium p99 september 2023 1993 san diego california phuong hoai ha marina papatriantafilou philippas tsigas selftuning reactive diffracting trees journal parallel distributed computing v67 n6 p674694 june 2007 nir shavit dan touitou software transactional memory proceedings fourteenth annual acm symposium principles distributed computing p204213 august 2023 1995 ottowa ontario canada elizabeth borowsky eli gafni yehuda afek consensus power makes sense extended abstract proceedings thirteenth annual acm symposium principles distributed computing p363372 august 1417 1994 los angeles california united states hagit brit shlomo moran waitfreedom vs bounded waitfreedom public data structures extended abstract proceedings thirteenth annual acm symposium principles distributed computing p5260 august 1417 1994 los angeles california united states hagit attiya vita bortnikov adaptive efficient mutual exclusion extended abstract proceedings nineteenth annual acm symposium principles distributed computing p91100 july 1619 2000 portland oregon united states yehuda afek danny dolev eli gafni michael merritt nir shavit bounded firstin firstenabled solution lexclusion problem acm transactions programming languages systems toplas v16 n3 p939953 may 1994 ole agesen david l detlefs christine h flood alexander garthwaite paul martin nir n shavit guy l steele jr dcasbased concurrent deques proceedings twelfth annual acm symposium parallel algorithms architectures p137146 july 0913 2000 bar harbor maine united states james h anderson composite registers distributed computing v6 n3 p141154 april 1993 alon michael merritt omer reingold gadi taubenfeld rebecca n wright tight bounds shared memory systems accessed byzantine processes distributed computing v18 n2 p99109 december 2005 edouard bugnion scott devine mendel rosenblum disco running commodity operating systems scalable multiprocessors acm sigops operating systems review v31 n5 p143156 dec 1997 hai huang padmanabhan pillai kang g shin improving waitfree algorithms interprocess communication embedded realtime systems proceedings general track 2002 usenix annual technical conference p303316 june 1015 2002 michel raynal gadi taubenfeld notion timed register application indulgent synchronization proceedings nineteenth annual acm symposium parallel algorithms architectures june 0911 2007 san diego california usa hagit attiya ophir rachman atomic snapshots lorenz huelsbergen james r larus concurrent copying garbage collector languages distinguish immutable data acm sigplan notices v28 n7 p7382 july 1993 soma chaudhuri maurice erlihy nancy lynch mark r tuttle tight bounds brian n bershad david redell john r ellis fast mutual exclusion uniprocessors acm sigplan notices v27 n9 p223233 sept 1992 gil neiger failure detectors waitfree hierarchy extended abstract proceedings fourteenth annual acm symposium principles distributed computing p100109 august 2023 1995 ottowa ontario canada grzegorz malewicz workoptimal deterministic algorithm asynchronous certified writeall problem proceedings twentysecond annual symposium principles distributed computing p255264 july 1316 2003 boston massachusetts yoram moses sergio rajsbaum unified structure consensus layered analysis guy e blelloch perry cheng bounding time space multiprocessor garbage collection acm sigplan notices v39 n4 april 2004 maurice herlihy nir shavit asynchronous computability theorem z kedem k v palem rabin raghunathan efficient program transformations resilient parallel computation via randomization preliminary version proceedings twentyfourth annual acm symposium theory computing p306317 may 0406 1992 victoria british columbia canada john tromp paul vitnyi randomized twoprocess waitfree testandset distributed computing v15 n3 p127135 july 2002 maurice herlihy randomized waitfree concurrent objects extended abstract proceedings tenth annual acm symposium principles distributed computing p1121 august 1921 1991 montreal quebec canada mary hall peter kogge jeff koller pedro diniz jacqueline chame jeff draper jeff lacoss john granacki jay brockman apoorv srivastava william athas vincent freeh jaewook shin joonseok park mapping irregular applications diva pimbased dataintensive architecture proceedings 1999 acmieee conference supercomputing cdrom p57es november 1419 1999 portland oregon united states yehuda afek hagit attiya danny dolev eli gafni michael merritt nir shavit atomic snapshots shared memory journal acm jacm v40 n4 p873890 sept 1993 nir shavit eli upfal asaph zemach waitfree sorting algorithm proceedings sixteenth annual acm symposium principles distributed computing p121128 august 2124 1997 santa barbara california united states yehuda afek hagit attiya arie fouren gideon stupp dan touitou longlived renaming made adaptive proceedings eighteenth annual acm symposium principles distributed computing p91103 may 0406 1999 atlanta georgia united states steven l scott synchronization communication t3e multiprocessor acm sigplan notices v31 n9 p2636 sept 1996 nir shavit asaph zemach diffracting trees preliminary version proceedings sixth annual acm symposium parallel algorithms architectures p167176 june 2729 1994 cape may new jersey united states prasad jayanti tushar deepak chandra sam toueg faulttolerant waitfree shared objects journal acm jacm v45 n3 p451500 may 1998 mer eeciolu ambuj k singh naming symmetric processes using shared variables distributed computing v8 n1 p1938 august 1994 maurice herlihy impossibility results asynchronous pram extended abstract proceedings third annual acm symposium parallel algorithms architectures p327336 july 2124 1991 hilton head south carolina united states freudenthal allan gottlieb process coordination fetchandincrement acm sigplan notices v26 n4 p260268 apr 1991 panagiota fatourou faith fich eric ruppert spaceoptimal multiwriter snapshot objects slow proceedings twentyfirst annual symposium principles distributed computing july 2124 2002 monterey california prasad jayanti time complexity lower bound randomized implementations shared objects proceedings seventeenth annual acm symposium principles distributed computing p201210 june 28july 02 1998 puerto vallarta mexico yehuda afek michael merritt gadi taubenfeld dan touitou disentangling multiobject operations extended abstract proceedings sixteenth annual acm symposium principles distributed computing p111120 august 2124 1997 santa barbara california united states hong tang kai shen tao yang compileruntime support threaded mpi execution multiprogrammed shared memory machines acm sigplan notices v34 n8 p107118 aug 1999 james h anderson multiwriter composite registers distributed computing v7 n4 p175195 may 1994 hany e ramadan christopher j rossbach donald e porter owen hofmann aditya bhandari emmett witchel metatmtxlinux transactional memory operating system acm sigarch computer architecture news v35 n2 may 2007 yehuda afek gideon stupp dan touitou long lived adaptive splitter applications distributed computing v15 n2 p6786 april 2002 maurice herlihy methodology implementing highly concurrent data objects acm transactions programming languages systems toplas v15 n5 p745770 nov 1993 p v van der stok h janssenraemaekers realtime atomic multicast algorithms implemented shared memory multiprocessor realtime systems v24 n1 p5591 january taisuke izumi akinori saitoh toshimitsu masuzawa adaptive timeliness consensus presence crash timing faults journal parallel distributed computing v67 n6 p648658 june 2007 faith fich maurice herlihy nir shavit space complexity randomized synchronization journal acm jacm v45 n5 p843862 sept 1998 paul c attie e allen emerson synthesis concurrent programs atomic readwrite model computation acm transactions programming languages systems toplas v23 n2 p187242 march 2001 yonatan aumann michael bender efficient lowcontention asynchronous consensus valueoblivious adversary scheduler distributed computing v17 n3 p191207 march 2005 gunnar hoest nir shavit towards topological characterization asynchronous complexity proceedings sixteenth annual acm symposium principles distributed computing p199208 august 2124 1997 santa barbara california united states phillip b gibbons ephraim korach testing cachecoherent shared memories proceedings sixth annual acm symposium parallel algorithms architectures p177188 june 2729 1994 cape may new jersey united states panagiota fatourou faith fich eric ruppert tight time lower bound spaceoptimal implementations multiwriter snapshots proceedings thirtyfifth annual acm symposium theory computing june 0911 2003 san diego ca usa hagit attiya faith ellen fich yaniv kaplan lower bounds adaptive collect related objects proceedings twentythird annual acm symposium principles distributed computing july 2528 2004 st johns newfoundland canada michael hicks greg morrisett dan grossman trevor jim experience safe manual memorymanagement cyclone proceedings 4th international symposium memory management october 2425 2004 vancouver bc canada maurice herlihy sergio rajsbaum classification waitfree loop agreement tasks theoretical computer science v291 n1 p5577 4 january hagit attiya keren censor tight bounds asynchronous randomized consensus proceedings thirtyninth annual acm symposium theory computing june 1113 2007 san diego california usa svend frlund rachid guerraoui implementing etransactions asynchronous replication ieee transactions parallel distributed systems v12 n2 p133146 february 2001 james aspnes gauri shah jatin shah waitfree consensus infinite arrivals proceedings thiryfourth annual acm symposium theory computing may 1921 2002 montreal quebec canada hagit brit shlomo moran gadi taubenfeld public data structures counters special case theoretical computer science v289 n1 p401423 23 october 2002 maurice herlihy nir shavit topological structure asynchronous computability journal acm jacm v46 n6 p858923 nov 1999 hagit attiya arie fouren algorithms adapting point contention journal acm jacm v50 n4 p444468 july hagit attiya nancy lynch nir shavit waitfree algorithms fast journal acm jacm v41 n4 p725763 july 1994 maurice herlihy sergio rajsbaum decidability distributed decision tasks extended abstract proceedings twentyninth annual acm symposium theory computing p589598 may 0406 1997 el paso texas united states dimitrios nikolopoulos theodore papatheodorou architectural operating system implications performance synchronization ccnuma multiprocessors international journal parallel programming v29 n3 p249282 june 2001 achour mostefaoui sergio rajsbaum michel raynal conditions input vectors consensus solvability asynchronous distributed systems proceedings thirtythird annual acm symposium theory computing p153162 july 2001 hersonissos greece james aspnes lower bounds distributed coinflipping randomized consensus proceedings twentyninth annual acm symposium theory computing p559568 may 0406 1997 el paso texas united states nir shavit asaph zemach diffracting trees acm transactions computer systems tocs v14 n4 p385428 nov 1996 nimar arora robert blumofe c greg plaxton thread scheduling multiprogrammed multiprocessors proceedings tenth annual acm symposium parallel algorithms architectures p119129 june 28july 02 1998 puerto vallarta mexico yehuda afek david greenberg michael merritt gadi taubenfeld computing faulty shared objects journal acm jacm v42 n6 p12311274 nov 1995 hagit attiya arie fouren eli gafni adaptive collect algorithm applications distributed computing v15 n2 p8796 april 2002 cynthia dwork maurice herlihy orli waarts contention shared memory algorithms proceedings twentyfifth annual acm symposium theory computing p174183 may 1618 1993 san diego california united states james aspnes lower bounds distributed coinflipping randomized consensus journal acm jacm v45 n3 p415450 may 1998 hagit attiya maurice herlihy ophir rachman atomic snapshots using lattice agreement distributed computing v8 n3 p121132 march 1995 gregory chockler dahlia malkhi active disk paxos infinitely many processes proceedings twentyfirst annual symposium principles distributed computing july 2124 2002 monterey california hagit attiya amotz barnoy danny dolev sharing memory robustly messagepassing systems journal acm jacm v42 n1 p124142 jan 1995 henry g baker lively linear lisp look garbage acm sigplan notices v27 n8 p8998 aug 1992 philippe charles christian grothoff vijay saraswat christopher donawa allan kielstra kemal ebcioglu christoph von praun vivek sarkar x10 objectoriented approach nonuniform cluster computing acm sigplan notices v40 n10 october 2005 achour mostefaoui sergio rajsbaum michel raynal conditions input vectors consensus solvability asynchronous distributed systems journal acm jacm v50 n6 p922954 november guojing cong david bader designing irregular parallel algorithms mutual exclusion lockfree protocols journal parallel distributed computing v66 n6 p854866 june 2006 gregory chockler dahlia malkhi active disk paxos infinitely many processes distributed computing v18 n1 p7384 july 2005 marcos k aguilera pleasant stroll land infinitely many creatures acm sigact news v35 n2 june 2004 henry g baker useonce variables linear objects storage management reflection multithreading acm sigplan notices v30 n1 p4552 jan 1995 cynthia dwork maurice herlihy orli waarts contention shared memory algorithms journal acm jacm v44 n6 p779805 nov 1997 james aspnes orli waarts compositional competitiveness distributed algorithms journal algorithms v54 n2 p127151 february 2005 james aspnes randomized protocols asynchronous consensus distributed computing v16 n23 p165175 september henry g baker linear logic permutation stacksthe forth shall first acm sigarch computer architecture news v22 n1 p3443 march 1994 faith fich eric ruppert hundreds impossibility results distributed computing distributed computing v16 n23 p121163 september
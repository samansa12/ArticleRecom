supporting scalable performance monitoring analysis parallel programs tools performance monitoring analysis become indispensable parts programming environments parallel computers number processors increases conventional techniques monitoring performance parallel programs produce large amounts data form event trace files hand wealth information problem programmer forced navigate tools must store process makes situation worse time large amount data irrelevant understanding performance application paper present new approach collecting performance data tracing events storing statistics performance approach provide accurate useful performance information yet require far less data stored addition approach also supports realtime performance monitoring b introduction monitoring performance parallel program runtime extremely useful feature powerful performance tool existing runtime performance monitors provide display limited information performance tuning one major reasons runtime monitoring limited time data collection analysis longer time data collection takes intrusive behaviour program intrusiveness monitoring may result change program behaviour another major difficulty providing useful performance information runtime due large amount performance data understand performance parallel program necessary collect fullsized data sets running large number processors conventional techniques monitoring performance parallel programs generate large volumes performance data common generate megabytes data per second program run collecting basic performance information granularity procedure system calls estimate based generating traces procedure system call events large scale parallel computer consisting say 1000 nodes amount data would impractical collect therefore creates dilemma identifying performance bottleneck necessitates collecting detailed information yet collecting large amount data overload memory trace files reduce volume data collected performance tool collect information necessary explain performance program however deciding data relevant programs execution difficult hand wealth data problem user navigate tool process runtime monitoring paper introduces instrumentation approach data collection supports runtime analysis parallel programs performance approach maintain ordering program events collect timing information interesting events paper also presents trace data organisation scheme provides performance information rapidly execution program require far less amount data stored collected trace data organised different levels ranging program individual communication statement user tune program topdown fashion focusing areas greatest impact performance furthermore technique also suitable postmortem performance analysis 2 related work review previous work related two major concerns mentioned ie dynamic program instrumentation methods reducing intrusiveness trace data organisation methods reducing data volume increasing scalability 21 instrumentation gupta spezialetti 8 present approach dynamically minimizing intrusive effect monitoring ensuring execution selection nondeterministic event uninstrumented instrumented versions program assume execution model distributed computation composed multiple processes located different processing sites processes communication via message passing pending messages maintained message pool process nondeterminism arises due order messages arriving process different sources handle restoring message pool message ordering approach undo intrusive effects monitoring runtime estimates time messages would sent received monitoring actions performed basis estimates process restore message pool waiting late messages ignoring messages become available early addition messages also appropriately ordered major limitations system 1 assumes messages sent asynchronous mode 2 assumes messages sent arrive stored destinations message pool receiving process ready receive 3 nondeterministic receiving event requests monitor wait messages remote sites arrive cai turner 16 introduced logical clock approach monitors behaviour occam programs transputer system approach partial ordering events also communication ordering process preserved permitting nondeterministic communication alt construct oc cam monitor wait safe allow communication occur process granted permission receive message message destined process earlier logical time ever may introduce deadlocks normally existing programs without monitoring avoid deadlocks introduced logical clock approach cai turner developed carriernull message algorithm 2 based deadlock avoidance algorithm called nullmessage 3 developed chandy misra 22 scalability performance metric predicate library pmpl 5 attempts solve problem performance data size pmpl used existing trace monitors aims 18 19 picl 6 uses userdefined predicates pmps control output event trace data applications execution predicates test state program performance performance fall specified tolerance monitor output performance history leading point performance degradation major limitations system requires user manually specify predicates additional perturbation applications performance imposed performance metric predicates dynamic instrumentation 9 13 controls amount data collected deferring insertion instrumentation probes application exe cution insert change instrumentation time execution modifying applications binary image instrumentation probes required currently selected analysis visualisation inserted approach periodically samples detailed information stored event counters timers intermediate values provide information useful making decisions change instrumentation meet need volume data collected controlled collecting information needed given moment controlling sampling rate although approach provides great flexi bility requires many decisions made collect collect quality collected performance data depends sampling rate time required make decisions correctness decisions mpp apprentice performance tool 17 designed help users tune performance cray t3d applications collects statistics section code summarises data processor displays summary across processors program execution time pass count code block summed within processor kept locally processors mem ory enables mpp apprentice tool handle longrunning programs without increasing demand processor memory end program execution requested user global reduction statistics code object across processors done runtime information file created mpp apprentice tool postprocesses file provides performance information user major limitation tool support realtime performance analysis quartz 1 profiling tool tuning parallel program performance shared memory multiprocessors philosophy underlying quartz inspired sequential unix tool gprof 7 appropriately direct attention programmer efficiently measuring factors responsible performance relating metrics one another structure program primary limitations profiling tool dependence external sampling task potential errors inherent sampling another limitation tool focuses finding cpu time bottlenecks 3 design goals compared existing approaches identified limitations discuss four major goals design runtime performance monitor goal 1 providing accurate performance information goal includes minimising intrusiveness data collection accurately calculating performance eg timing information goal 2 keeping trace data manageable size mentioned large scale parallel computer could impractical collect amount performance data problem also happens small long running programs also generate large amount trace data fore second goal monitor maintain performance data set manageable size without losing characteristics usefulness data goal 3 providing performance information rapidly parallel programs incur overhead many different ways synchronisation load imbalance communication prompt assessment processing time spent aspects useful performance tuning parallel programs third goal monitor store performance data form performance information including statistics cpu time load imbalance transmission time communication blocking time synchronisation easily derived rapidly provided goal 4 providing hierarchical data relating back source program performance tuning process associated source program means focusing successively detailed regions program provided one proceed hierarchical manner respect program code studying code various levels detail helps systematically focus region code causing performance problem previous informal study 10 shows users generally start taking high level view performance applications isolate source programs poor performance process continues understand programs performance well enough start tuning therefore fourth goal monitor provide user different levels performance statistics ranging whole program single communication statement performance statistics organised according hierarchical structure program achieve four goals key questions answered ffl minimize intrusiveness data collection ffl data collected ffl collected data organised next section discusses various approaches performance data collection achieve goals presents design decisions made order achieve goals sections 5 6 present approaches intrusion minimisation reduction trace data volume 4 data collection methods design decisions three basic approaches collecting performance data counting statistical sampling event tracing representing different tradeoff among information volume potential instrumentation perturbation accuracy implementation complexity 41 counting first approach records number times interesting event occurred unix grof 7 monitoring routine called prologue profiled procedure monitoring routine updates count calls procedure caller given count total time one compute average execution time approach significantly reduces volume performance data collected however records number times event occurred event occurred therefore loses important information event context approach achieves goals 2 3 cannot achieve goal 4 also achieves goal 1 extent since collects counting information introduces little intrusion 42 statistical sampling another approach data collection statistical sampling involves periodic sampling program resources currently active procedures gauge program performance unix grof 7 periodically interrupts program sample program counter thereby estimating execution time procedure quartz 1 set processors execute program maintain states shared memory special code executed thread operations procedure entries exits states sampled dedicated processor participate executing program crovella leblancs predicate profiling tool 4 uses similar approach primary limitations approaches dependence external sampling task potential errors inherent sampling sampling procedures provide estimate accurate needs routines 6 keichun li kang zhang spend programs time accuracy result depends sampling rate hand total program execution time low sampling error may intolerable ponder fateman 14 identified number limitations statistical sampling approaches statistical sampling approach achieves goals 2 3 cannot achieve goals 1 4 43 event tracing event tracing general flexible approach data collection generates sequence event records event record consists encoded instance action attributes typically including following ffl action occurred e event identifier ffl time event occurred ffl location event occurred eg line number ffl additional data define event circumstances event tracing identify happened happened event timestamps impose order events defines control flow interactions system components one strengths judiciously chosen events identify performance problems correctness prob lems task schedules may directly obtained trace files immense amount flexibility available assigning interpreting timestamped events event tracing subsumes counting sampling one compute times counts trace data example given trace procedure entries ex one compute total number calls procedure counting number instances event type well total procedure execution times matching procedure entry exit events computing difference event times adding difference running sum procedure addition dynamic procedure call graphs spacetime diagrams drawn program visualisation using trace data tracing one capture components interactions dynamic behavior transients well load imbalances due message waiting since performance information retrieved trace files technique usually used postmortem performance tuning tools aims 18 19 picl 6 pablo 15 tools present information perspective time try give user idea happening every processor system given moment event traces great potential help user understand program behaviour also serious problems discussed understand performance parallel programs necessary collect large amount data running large number processors volume data proportional number processors frequency trace points length program execution limit scalability monitoring system example aims generates 36 megabytes trace file parallelised version arc2d nas parallel benchmark executed 64 processors two seconds 5 massively parallel computer amount trace data large collect maintain realistic programs continued increases number processors sizes applications event tracing solution scales well hand data volume also difficult manage display user left interpret events happening thousands processors therefore approach achieves goal 4 cannot achieve goals 2 3 goal 1 collects accurately performance information counting timing generates serious intrusion especially monitoring large longrunning parallel programs 44 design decisions discussion single approach achieve four goals therefore developed approach hybrid counting event tracing provides low data volume counting detailed tracing instrument interesting events eg communications collect event traces execution program collected data summarised counts times counting approach information locations events breakdown timing also stored eventtracing approach moreover support users crossreferencing approach uses knowledge program structure relate performance characteristics back source program data collected collecting performance data parallel programs interesting events usually include procedures communications support tuning longrunning programs reasonable assume execution time spent loops hence loops treated interesting events approach provide detailed timing information procedures procedure calls also considered monitor interesting events thus statements communications procedure calls procedures loops instrumented performance data collection organisation performance data collecting performance data interesting event monitor accumulate collected execution times store data structure dynamically generated program execution also updates count event locations monitored events source program also stored data structure used relate performance characteristics interesting events back source program moreover break timing also recorded details example monitor records total execution time count calls procedure also break information different procedure calls processed onthefly execution program crossreference performance data source program relate performance characteristics back source program must maintain link control flow computation performance data means representing original source program control flow provide abstraction intermediate program representation using program graphs following two sections present approaches based design decisions program instrumentation aims minimising intrusiveness data organisation aims reducing volume trace data 5 intrusion minimisation fundamental problem performance monitoring tool intrusiveness data collection perturbation program behaviour intrusiveness may alter timing events program arbitrary manner lead change ordering events means result monitoring intrusive monitor taken approximation happened unmonitored program may also hide deadlocks existing program even create new deadlock situations 16 51 perturbation instrumentation time characteristics intrusive monitor may alter time characteristics events program arbitrary manner delays introduced monitor execution processes change relative timings executions thus overall execution times processes affected also time characteristics waiting messages processor idle figure 1 spacetime diagram showing effect intrusiveness terms timing three different processes without instrumentation sending event e p1 ready send message p2 time 1 receiving event e b p 2 ready receive message p 1 time 2 assume 2 earlier 1 ready time e b earlier e assuming one probe inserted one probe inserted event two instrumented events e b instrumentation one probe e five probes e b simplicity calculation assuming delay time every probe equal ready time e becomes 3t earlier e b therefore instrumentation altered ordering events timing information synchronisation delay longer without monitoring execution selection second major problem program instrumentation may result change execution selection nondeterministic communication multiple legal executions given input nondeterministic message reception supported using anyway branch receiving process may accept message r r r r 3t ea ea t25t without instrumentation b instrumentation receiving event probe r sending event figure 1 intrusiveness time characteristics process node ie selects path along anyway branch ie corresponds sender message criteria message selection expressed application user may differ different implementations distributed systems selection based upon criteria order messages arrive priorities senders fairness criteria selecting message process least recently considered purely random selection may made etc assume receiver selects path along anyway branch corresponds sender whose message first ready send receiver therefore selection particular execution made runtime typically influenced timing various events since monitoring actions alter execution time likelihood selection various legal executions may also altered 52 instrumentation methods existing instrumentation methods classified three groups software hardware hybrid approaches software approach add set instructions probes application program enable runtime collection useful information system behaviour approach offers advantage fairly independent target architecture also provides information high level abstraction directly useable designers graphical display tool many ways realising software instrumentation probes inserted manually editing source code automatically precompiler linking instrumented libraries modifying linked executable modifying operating system according programming stages probes inserted software instrumentation divided source instrumen tation library instrumentation object instrumentation kernel instrumentation main shortcoming software instrumentation related time overhead introduced information gathering limit effect intrusion instrumentation usually limited events whose observation considered essential instrumentation methods reply extensive hardware support noticeable effect behaviour program observed hardware approach involves connecting probes system hardware order observe behaviour without disturbing however number limita tions firstly provide lowlevel data usually considerable processing complicated mechanisms required provide application level monitoring information machine level data secondly form least portable class monitoring mechanisms thirdly design hardware monitor complicated use pipelining onchip cache increasing throughput microprocessors also increase integration various functional units eg floating point units memory management units makes monitoring difficult hybrid monitoring compromise software hardware monitoring approaches based addition instructions programs order select adequate information useful explain behaviour offline information collected specific device transmitted host system interprets offline displays result approach advantages two approaches gives information high abstraction level introduces low overhead however major limitation hybrid instrumentation often dedicated specific hardware architectures therefore standard interfaces important supporting instrumentation portability achieve high portability flexibility choose source instrumentation method using software monitoring following subsection presents instrumentation method using virtual time monitoring parallel messagepassing programs 53 virtual clock approach order achieve goal 1 stated section 3 ie accurately capture performance information synchronous delay transmission time introduce minimal intrusiveness program behaviour use virtual clock approach collect performance data approach based cai turners logical clocks approach 16 able handle parallel programs involve nondeterministic communications however differs cai turners approach three key aspects 20 ffl new deadlock avoidance method used speed realisation global waiting dependency decrease amount control messages time monitor select earliest available sending process moreover suitable parallel systems containing nodes connected within network provides pointtopoint communications ffl approach designed implemented monitoring synchronous asynchronous communication functions cmmd cm5 however general enough applied parallel platforms process necessary approach monitor implemented runtime library contains set routines ie probes inserted source code assume execution model parallel computation composed multiple processes located different processors processes communicate via message passing nondeterminism arises due order communication requests process different sources handled destination process 531 virtual time order keep execution selection collected timing characteristics events original uninstrumented program estimate time spent monitoring activities maintained virtual clock process using estimates processes involved infer times various actions would occurred monitoring performed next define various times used approach 1 local time processor p execution instrumented process denoted lt given rt real time p obtained p internal physical clock current intrusion time virtual time v estimate real time p execution original uninstrumented program given rt given application process local value intrusion time indicates delay due monitoring activities execution process 532 execution control order preserve timing characteristics keep execution selection unchanged monitor needs take control process ready communicate processes determine timing ordering communication events monitoring deterministic synchronous communication event monitor postpone permission communication detects arrival partner communication event monitoring deterministic asynchronous communication event monitor permit asynchronous function execute without waiting readiness communication partner permitting nondeterministic communication monitor wait safe allow communication occur receiving process oehas granted permission receive message process send message process earlier virtual time timing counting information collected subroutine calls probes data collection library inserted source code preprocessor probes inserted procedure call communication loop statement procedure probe inserted heading procedure monitoring communication events monitoring functionality divided two parts fore monitoring activities back monitoring activities fore monitoring responsible recording synchronisation time controlling interprocess communication since fore monitoring activities performed communication statement monitor control occurrences communication events monitor notices communication partner ready communicate able decide sender communicate monitor calculate time spent synchronisation permit communication start execution communication back monitoring simply calculates time spent message transmission 533 preservation time characteristics consider example shown figure 1 use virtual time preserve ordering execution times events illustrated figure 2 rt 1 rt 2 rt 3 real times virtual time sending event e receiving event e b arrive real times times spent monitoring activities e e b 5t respectively intrusion time e arrives e b 5t therefore e arrives virtual time arrives virtual time based virtual time measurement correct ordering events preserved e arrives e b synchronous delay equal also accurately collected r r t25t 3t t1t ea figure 2 preservation time characteristics 534 preservation execution selection monitor also uses virtual time control occurrence interprocess communication keep execution selection unchanged achieve nondeterministic receiving event arrives monitor makes decision interprocess communication happen next based virtual times rather real times pro cesses delays occurrence communication aware least one possible candidate process communication running earlier virtual time way communication prevented occurring either early virtual time late real time therefore although realtime execution process slowed monitoring activities behaviour program unchanged figure 3 shows example monitor uses virtual time keep execution selection unchanged virtual times processes nondeterministic receiving events p 2 e e c sending events p 1 p 3 respectively delays introduced monitor routines e arrive real times q p r instead original times executing uninstrumented program relationships times r ea r ec real time ed figure 3 preservation execution selection 535 deadlock avoidance virtual clock approach may introduce deadlock nondeterministic communication consider example shown figure 4 w end line connected waiting process n end line connected nonwaiting process example process p 1 waiting input processes p 0 p 3 p 0 ready output p 1 virtual time 30 p 3 waiting receive process p 2 p 2 waiting receive 1 assumed virtual time p 3 less 30 thus p 3 might chance become ready output p 1 30 therefore according virtual clock approach monitor cannot permit p 1 receive p 0 message sent p 2 thus deadlock occurs p 1 waiting waiting p 2 p 2 waiting p 1 without monitoring deadlock situation happen since p 1 select communication deadlock introduced monitoring policy virtual clock approach clear kind deadlock avoided cai turner developed carriernull message algorithm 2 14 keichun li kang zhang figure 4 deadlock creation based nullmessage algorithm 3 algorithms avoid deadlocks transmitting null messages announce absence real messages advance simulation time logical time process waiting dependency loop however parallel systems eg cm5 sp2 tens hundreds processors using carriernull message algorithm amount protocol messages overload system message traffic developed new deadlock avoidance method 20 detects global waiting dependency allows earliest available sending process p 0 example send message obtain information global waiting dependency monitor nondeterministic receiving event collects timing state information processes identifying dependency loop monitor selects earliest ready process permit communication nondeterministic receiving event approach uses simple algorithm introduces little amount extra control messages 536 performance instrumentation compared times different stages test program executing monitoring without monitoring order measure overhead monitor accuracy times collected monitor 12 test program matrix multiplication parallel program written c cmmd program master process executes processor 0 number worker processes execute processors 1 31 beginning master process initialises matrix matrix b sends different portions matrix matrix b worker processes worker processes perform calculations receiving data send results back master process master process merges result multiplication matrix matrix b form matrix c figure 5 shows tolerance timings different stages indicates maximum tolerance 36 also obtained monitoring overhead 2 total execution time program without monitoring inserting different delays monitoring routines evaluate variation tolerance timings observed maximum tolerances ranged 18 12 results shown tolerances proportional increase delays inserted monitor figure 5 tolerance timings 6 reducing trace data volume reduce amount trace data maintained organise performance data collected program instrumentation two major forms data structure ie static tables dynamic records figure 6 illustrates performance information organised execution parallel program performance analyser generates performance report based information static tables dynamic records users input user interface end program execution monitor may also save dynamic records system disk postmortem analysis combined use static tables dynamic records ensures necessary performance information structurally maintained storage required data structures manageable size increase proportionally program size running time 61 program graphs able represent interpret performance program relate performance back source program use abstraction called program graph depicted figure 7 program graph consists nodes represent major control points program procedure calls loops procedure headers nodes organised according hierarchical structure parallel program table analyser information analysis runtime postmortem analysis query performance interface user performance dynamic records figure 6 generation performance information procedure communication communication procedure procedure call communication loop loop procedure call communication procedure procedure call procedure figure 7 program graph message passing parallel program top level program graph main procedure second level consists monitored events main procedure communication events procedure calls loops loop event nested loop procedure call communication event within loop lower level description event attached loop event procedure call event called procedure attached calling event program graph implemented number static tables monitor static tables constructed program instrumentation preprocessor execution program since entries determined program text figure 8 shows structure preprocessor 62 static tables static tables used storing hierarchical relationship program structures statements interesting program structure statement identified static tables application source code instrumented source code preprocessor figure 8 preprocessor program instrumentation line number program tables pl pcom pc store information loop structures communication statements procedure calls inside procedure respectively tables lcom lc store information loop structures communication statements procedure calls inside loop structure respectively figure 9 shows format static tables following fields l p line number procedure statement since data presented monitor primarily based procedures field key tables l l line number loop statement field key tables lcom lc l c line number communication statement l pc line number procedure call statement l pi line number procedure statement invoked l pc l il line number loop statement nested another loop fields table l p l l l c l pc l pi l il figure 9 format static tables 63 dynamic records dynamic records generated monitor execution parallel program store statistics interesting events approach interesting events include procedures loops communications dynamic record allocated procedure loop communication statement whose structure shown figure 10 looptime loopnum communication events destnode transtime syncdelay transnum nextdest com record record com line selfnode eventtype cplptr activateline nextcaller proctime procnum loop record proc record loop events procedure events record records figure 10 structure dynamic records storing interesting events list dynamic records named event records allocated runtime different interesting program events parallel program event record stores statistics interesting program event four tuple line self node event ffl line line number first statement program event ffl self node identifier process executes program event event type type program event communication loop procedure ffl c p l ptr pointer pointing corresponding records type event type relate performance characteristics back source program interesting program event identified line number program communication event line stores line number communication statement loop procedure event line stores line number first statement event since performance data may collected different processes self node identifies process program event executed use multiple event records store performance data different program events according type program event stored event type c p l ptr points corresponding records communication event event points list com records loop event loop record procedure event points list proc records describe design records respective program events procedure events large complex program usually composed many small procedures implement abstractions program direct users attention location causing performance problem statistics procedure count procedures invocations execution time provided hand useful know procedure statistics procedures invokes consider following example procedure x call assume procedure x responsible 90 execution time program call statement responsible 80 execution time obviously focus attention procedure rather procedure x reason necessary detect situation time dispersed among several procedures unix gprof 7 provide information gathers three pieces information program execution call counts execution time profiled routine arcs dynamic call graph traversed program execution postprocessing data gprof builds dynamic call graph nodes represent routines directed arcs represent calls routines propagates times along arcs graph routines invoke since assumes call routine takes average amount time calls routine caller r accountable theta c rs c total time spent callee c rs number calls caller r c number calls routine assumption always true since execution time routine may depend parameters passed procedure invoked provide accurate timing routine times spent routines invokes separately store execution information procedure different callers since approach provides runtime performance information execution parallel program rather building dynamic call graph execution program list proc records dynamically allocated procedure execution store statistics different procedure call statements proc record list stores statistics particular call statement four tuple activate line next caller proc time proc num ffl activate line line number statement calls procedure ffl next caller pointer linking proc records list ffl proc time accumulated execution time procedure called statement whose line number stored activate line ffl proc num counts number executions procedure called statement whose line number stored activate line however arrangement would work programs containing recursive calls figure 11 shows two simple examples relationship caller callee mixed time propagated one statement another cycle solution allocate proc record recursive call example figure 11a proc record allocated call x statement provide counting timing information procedure x like call x statement exist information stored proc time proc num proc record procedure x external call statements case figure 11b treat procedures x single procedure z callers procedures x become callers procedure z arrangement results situation like figure 11a proc record allocated either call x call statement counting timing information procedure z stored list proc record procedure z event record external call statements procedure x procedure x procedure call x call call x recursive routine b mutually recursive routines figure 11 program examples containing recursive calls therefore provide user simple accurate performance information recursive procedures instead presenting overlapping complicated timing information communication events communication one important activities may optimised improve performance parallel programs order observe communication behaviour collect measurements transmission time synchronous delay count executions communication statement communication statement may change destination execution parallel program following example cm5s cmmd send statement whose destination changes 1 numworkers dest numworkers dest cmmdsendblockdest 1 buf bsize provide detailed timing information communication event time spent communication two processes list com records dynamically allocated store statistical information different destinations communication statement program com record five tuple dest node trans time trans num sync delay next dest ffl dest node identifier process destination communication ffl trans time accumulated message transmission time communication event ffl trans num counts number executions communication event ffl sync delay accumulated synchronisation time event ffl next dest pointer linking next com record list loop events many longrunning programs execution time spent loops collect time count executions every loop event program loop record dynamically allocated store statistical information loop event program two tuple loop time loop num ffl loop time accumulated execution time loop event ffl loop num counts number executions loop event 64 results following two case studies indicate results evaluation effectiveness data structure performance interpretation reduction trace volumes 22 keichun li kang zhang 641 performance interpretation describe explain data structures used approach demonstrate provide performance statistics example parallel program used shown figure 12 example program l1 l15 line numbers program state ments main procedure main l1 consists two procedure call statements l2 l3 call procedures p1 p2 l4 l6 respectively therefore two records l1 l2 l4 l1 l3 l6 included table pl loop event loop1 l11 nested loop loop2 l13 record l11 l13 included table since communication statement e1 l9 inside procedure p3 l8 record l8 l9 table pcom hand communication statement e2 l12 inside loop1 l11 record l11 l12 table lcom figure 13 shows static tables generated example program since procedure p3 called statements l7 l5 two dynamic records ie proc record activate line l5 proc record activate list referenced c p l ptr event record procedure p3 one loop record also allocated loop1 loop2 following performance information derived static tables dynamic records total execution time whole program since line number main procedure l1 record line l1 searched event records main procedure first procedure execute proc record activate line 0 list referenced c p l ptr matching event record value proc time proc record total execution time whole program total message transmission time whole program records event type equal communication events searched event records matching records values trans time com records referenced records c p l ptr accumulated sum accumulated values total message transmission time whole program total communication synchronisation time whole program calculation total message transmission time whole program except values sync delay rather trans time accumulated total execution time procedure calls main procedure using activate line l1 key two records l1 l2 l4 l1 l3 l6 found table pc means two procedure call statements main procedure execution time first call statement proc time proc record whose activate line l2 referenced c p l ptr record whose l4 method find execution time second procedure call statement find first sum two values total execution time procedure calls main procedure total execution time procedure call l5 calculation without searching table pc one procedure call statement searched dynamic records l2 call p1 l3 call p2 l4 procedure p1 l5 call p3 l6 procedure p2 l7 call p3 l8 procedure p3 call p4 l11 loop1 l13 loop2 l14 call p4 procedure p4 figure 12 example program table pl table pcom l p l l l p l c table l p l pc l pi table table lcom l l l il l l l c table l l l pc l pi figure 13 static tables generated example program total time count procedure p3 executions since line number procedure p3 l8 record line l8 searched event records sum proc time values proc records referenced c p l ptr matching event record total execution time procedure p3 sum values proc num count procedure p3 executions total execution time communication event l12 record line l12 searched event records sum values trans time sync delay com records list referenced c p l ptr matching event record total execution time communication event l12 total execution time loop1 timing information events loop record line l11 searched event records value loop time loop record referenced c p l ptr matching event record total execution time loop1 using line l11 search key record l11 l13 found table means loop l13 nested inside loop1 method find total execution time loop2 loop1 key record l11 l12 found table lcom means communication event l12 loop1 way calculate time spent communication event demonstrated using key record found table pc procedure call statement loop1 discussion see collected performance data organised way related back structure application program performance information provided different levels performance statistics ranging whole program single communication statement information user tune program topdown fashion focusing effort areas greatest impact performance use program figure 12 example assume procedure p4 consumes programs execution time firstly user checks performance main procedure finds execution time spent call p1 call p2 statements performance procedures p1 p2 checked indicates call p3 timeconsuming statement user checks performance procedure p3 found execution time procedure p3 spent call p4 statement user conclude procedure p4 greatest impact whole performance focus hisher attention procedure p4 642 comparison data sizes size performance data needed approach much smaller generated traditional tracebased systems let us consider following portion parallel program written cmmd executed cm5 48 50 cmmdreceiveblock4 stype coffset0 bsize 52 cmmdsendblock6 mtype offset intsize 53 cmmdsendblock6 mtype b ncadbsize processor 5 repeatedly receives data processor 4 calls subroutine cal calculation sends result processor 6 assuming user interested time spent communication compare volume data collected traditional event trace tools approach traditional event trace tool monitoring routines inserted four communication statements lines 49 50 52 53 collecting timing information generating trace event records assume following format event trace record line line number event source program type event type source process executes event destination receiving process identifier communication event timestamp start time event execution given sizes five fields 2 2 4 4 8 bytes respectively record occupies 20 bytes following event records created first iteration loop line 48 26 keichun li kang zhang 49 2 5 4 0308713 49 2 5 4 0308880 50 2 5 4 0308905 50 2 5 4 0484081 52 2 5 6 1423808 52 2 5 6 1424025 53 2 5 6 1424053 53 2 5 6 1583002 since loop executed 200 times 1600 8 theta 200 event records created means size trace data storing timing information four communication statements 3125 kbytes 1600 theta 201024 fields size bytes line 2 self node 4 event type 2 dest node 4 trans time 8 delay 8 trans next dest 2 table 1 sizes fields event com records approach four event records allocated four communication statements since destinations four communication statements fixed one com record allocated lists pointed c p l ptr event records table 1 shows sizes fields event com records table calculate event record occupies 12 bytes 2424 com record occupies 24 bytes 48822 total size four event records four com records 144 bytes 4 theta 12 24 volume trace data significantly less kbytes generated using traditional approach traditional event trace tools trace data size increased proportionally number iterations loop structure approach increase trace data size increasing number iterations approach especially suitable handling long running programs hand set event trace records generated traditional event trace tools provide breakdown timing information communication eg transmission time synchronous delay however detailed information provided approach small size performance data set 7 summary achieving four goals summarise approaches matching original design goals stated section 3 claim four goals achieved large extent runtime monitor uses virtual time instrumentation approach timestamp maintain order interesting events allows monitor collect accurate performance data transfer data central processing perform activities supporting runtime performance analysis achieves first goal since monitor traces events stores statistics per formance obtain sufficient performance information yet require far less data stored thus amount trace data controlled manageable size achieves second goal stored statistical form trace data provide performance information rapidly runtime monitoring achieves third goal combining information dynamic records static tables monitor provide user different levels performance statistics whole program single communication statement appropriately direct users attention efficiently measuring factors responsible performance relating metrics one another structure program information user tune program topdown fashion focusing effort areas greatest impact performance achieves fourth goal 8 conclusion paper introduced monitor supporting runtime data collection analysis parallel program performance high scalability assists user location identification resolution performance problems parallel programs instrumentation approach preserves ordering events without affected speed monitoring activities thus supports runtime performance monitoring since raw performance data process summarised statistics process dynamic records program execution monitor requires far less data stored maintained performance information provided easily rapidly runtime monitoring reduced data volume requires fewer resources causes less intrusion program behaviour data volume proportional execution time program approach scale well growing number processes handle long running programs lower data volume manageable tool process easy user understand performance characteristics referred back source code monitor provides users different levels performance statistics relating entire program procedure loop block procedure call statement communication statement statistics organised according hierarchical structure 28 keichun li kang zhang program approach appropriately direct attention user efficiently measuring factors responsible performance relating metrics one another structure program therefore users tune programs topdown fashion focusing effort areas greatest impact performance acknowledgments authors would like thank anonymous referees comments useful improving paper r quartz tool tuning parallel program perfor mance algorithm distributed discreteevent simulation carriernull message approach case study design verification distributed programs performance debugging using parallel performance pred icates selective monitoring using performance metric pred icates users guide picl portable instrumented communication library gprof call graph execution profiler dynamic techniques minimizing intrusive effect monitoring actions dynamic program instrumentation scalable performance tools finding bottlenecks large scale parallel programs instrumenting parallel programs based virtual clock ap proach performance tuning support messagepassing parallel programming inaccuracies program profiles scalable performance analysis pablo performance analysis environment logical clocks approach visualization parallel programs mpp apprentice performance tool delivering performance cray t3d performance tuning aims automated instrumentation monitoring system multicomputers visualisation modelling parallel distributed programs using aims toolkit collecting timing information preserving events ordering parallel program instrumentation tr
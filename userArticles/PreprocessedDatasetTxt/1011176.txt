twolevel languages program optimization twolevel languages incorporate binding time information inside types whether piece code completely known compiletime needs inputs evaluated runtime consider use 2level languages framework partial evaluation use 2level version simply typed lambda calculus recursion give operational semantics equational theory denotational semantics give account distinction compilation execution phases adequacy theorem given relate two semantics showing particular agree nontermination compile time finally give refined model using functor categories b introduction partial evaluation attempt gap interpreting compil ing rst case obtain easytoprove correctness good exibility modications unfortunately usually get also poor runtime behaviour often order magnitude slower noninterpretative counterpart hand compiled code comparatively hard understand prove correct aim partial evaluation take program input produce new program gives output original one constant evaluations performed program generation process new program incorporate data remains constant called specialized version old one following picture illustrates process program compiletime residual runtime value view essential distinguish computations performed compiletime called static computations need data executed called dynamic process making distinction called binding time analysis classical example function power takes two integers x computes x xth power function could dened follows research partially supported murst suppose know compiletime x number 3 x static variable dynamic produce residual program program typically ecient f 3 various ways perform binding time analysis promising technique use 2level language language incorporates binding time information inside types usually languages two versions data type constructor one static one dynamic types 2level languages originally introduced 12 studied extensively 18 use partial evaluation recent examples found 4 11 paper study semantics 2level language give operational semantics denotational model basic idea semantics evaluate static components program compilation obtaining residual program specialized version original one execute runtime second section introduce 2level language essentially 2level variant callbyname language pcf 19 give operational semantics gives account distinction compilation execution phases distinction made clear showing dynamic operations postponed static ones performed study equivalences terms show unrestricted rule valid dynamic terms although levels language purely call byname taken isolation makes dicult give abstract model two kinds undenedness required one level clear rst generalize higher types third section relate operational semantics denotational model given show adequacy theorem asserting model gives results also preserves phase distinction operational semantics last section shows although adequate model contains junk basic elements denable within language suggest better solution using slightly complex machinery purpose work provide insight prove correctness partial evaluation prove equivalence semantics original program semantics specialized one 11 4 give partial evaluator 2level language leave correctness proof work 18 gives dynamic semantics parametrised xed static semantics consider partial evaluation model given 18 connection operational notions made view connection crucial understanding link semantics implementation issues especially partial evaluation proving correctness partial evaluators dicult often error prone shown 8 partial evaluation untyped language considered alternative solution given 16 correctness original model proved 7 also provides correctness proof partial evaluator 4 existing models 8 7 16 give syntactic interpretation dynamic types namely collections open terms language approach abstract similar standard treatment pcf novelty approach interpretation compilation execution phases framework allowing study interaction respect computational eects like nontermination 2 simple 2level language section introduce simple language 2level pcf obtained pcf augmenting construct dynamic counterpart first explain syntax language type formation rules give operational semantics equational theory denotational model 21 2level pcf 2level pcf language obtained pcf adding dynamic types dynamic terms intended use language evaluate static components compiletime execute remaining part residual program runtime base types usual natural numbers nat dynamic numbers nat higher types constructed static arrows dynamic ones wellformedness rules dynamic types introduced originally 18 dynamic arrow must dynamic types either side rules motivated consideration dynamic functions depend static computations runtime static computations already performed base case reason allow dynamic functions take static naturals inputs construct lift embeds terms type nat dynamic terms moreover constraints give interesting properties allow postpone dynamic evaluations static ones operational semantics types 2level pcf given following grammar static types dynamic ones use terms type rules structured similar way essentially two copies every construct terms pred pred succ successor function numbers ifz conditional whose guard checks rst argument zero x recursion operator lift embeds static expression type nat dynamic expression note possible base type purpose lift insert static value residual program type assignment written nite set variabletype pairs x distinct indicates extension type formation rules note dynamic ifthenelse requires arguments dynamic avoid example static terms like whose evaluation would depend evaluation dynamic term would problem especially consider possibility nontermination terminate runtime cannot uence value whole term compiletime 22 operational semantics section give operational semantics 2level pcf basic idea give two reduction relations static reduction dynamic reduction intended constraint static reduction must always performed dynamic one operational semantics pred liftn liftn 0 1 static contexts c dynamic contexts c dened follows pred pred pred notation indicates subtraction natural numbers extended relation dened analogous way usual reductions pcf nx indicates capturefree substitution n x term particular exactly one pcf obvious dynamic counterpart note use lift form basic constants fact canonical forms dynamic numbers ie form terminating computation expected reach consider static term sund dened follows sund x xx nat use sund canonical term represent static undenedness base type clearly evaluation fail terminate already compilation phase hand consider dynamic term dund dund x xx nat new term evaluated compilation fact cannot reduced statically attempt execute runtime lead nontermination need constraints interleaving static dynamic reductions explained examples consider following term principle possible use dynamic reduction yield result careful analysis reveals presence subterm sund terminate compiletime setting partial evaluation try reduce causing nontermination compilation conversely term statically reduced 0 although innite reduction sequence discussion suggests term reduced dynamically compiled words terms terminating static reduction reduced dynamically simplest way ensure term run safely require static normal form snf denition 1 term snf 0 0 put two relations together denition 2 given welltyped term sd 0 1 2 snf 0 following lemma crucial sense shows static reductions performed dynamic ones obtaining complete separation two phases lemma 3 postponent given welltyped term sd 0 term 00 proof show snf 0 0 snf interesting part rule snf hence problem 1 contains subterm form x n n possible x must dynamic type due type formation rules ut relax condition must welltyped previous lemma longer valid consider illtyped term clearly snf xx conclude section complete example partial evaluation power function discussed introduction let pow natnatnat x f nxifz nthen lift1 else x f n 1 x static subtraction dynamic product denable obvious way reduction eect compiling program yielding optimized version sd x x x lift1 arguments given pow also execution phase performed sd lift49 example clear operational semantics gives information compilation execution programs 23 equational theory section consider rules familiar type theory state versions valid setting two versions rule expressed language one four combinations invalid following rules valid xm rules valid static fragment language purely callbyname rule aect static behaviour term purely dynamic terms behave callbyname fashion rule valid fact consider term xlift0 liftsund cannot equal lift0 term sund terminate compiletime thus code lift0 never produced borrowing ideas operational semantics give special rule snf remarks section veried introducing denotational model 24 denotational semantics cpo complete partial order partially ordered set least element least upper bounds chains function cpos said continuous preserves least upper bounds chains hence monotone section give model language interpreting types cpos terms continuous functions cpos write n cpo natural numbers n number n general x cpo obtained cpo x adding new least element xy indicates cpo continuous functions x function composition interpretation types interpretation static types usual one callbyname pcf dynamic types deserve explanation seen two kinds undenedness compiletime runtime view type nat contains two elements apart natural numbers intended interpret terms like liftsund indicate failure compilation phase intended interpret terms like dund terminate exe cuted normally nat would written n use notational convenience denote inner dynamic arrow idea dynamic function either terminate compiletime behave usual callbyname fashion run time thus semantics dynamic types turns lifting semantics corresponding static types obtained removing underlines semantics types one might expected valid invalid looks like lazy calculus see reverse true cpo x consider function xx embeds x 2 x x identity x extended sending least element x two following functions essential give semantics dynamic terms otherwise function dyn used transform static arrow dynamic types dynamic arrow corresponds type formation rule idea behind denition dyn static function dynamic types either undened dened dened argument failure compile function applied depend dynamic argument passed unless argument fails compiled dapp operator used interpret dynamic application purpose propagating undenedness terms callbyvalue style note levels essentially callbyname taken isolation dynamic level behaves like callbyvalue respect static undenedness given type assignment environment function given judgement write interpretation environment figure 1 denes interpretation terms language static components language interpreted callbyname pcf use functions dyn dapp already explained constructs interpreted natural way propagating static undened ness case nontermination using standard interpretation otherwise reconsider rules introduced equational theory section show valid model see valid consider terms pred pred f fig 1 denotational semantics denotational rules rule first note since x free assumption since dync 7 otherwise exists f rule trivial order prove rules need fundamental lemma lemma 4 substitution lemma proof proof induction indicate 0 environment x 7 n consider two important cases case case ym 0 exploiting result easy see rule valid note failure rule due fail substitution lemma fact general validity 0 rule follows easily result next section n static normal form n 3 adequacy far seen operational semantics denotational model 2level pcf time relate two semantics prove adequacy result achieved using two dierent logical relations dened induction structure types rst one used obtain static adequacy result gives semantic counterpart syntactic result phase distinction static dynamic evaluation second easier shows purely dynamic fragment behaves exactly like callbyname pcf way introduce static undenedness 31 adequacy theorems state two adequacy theorems leaving proofs end section theorem 5 static adequacy let closed term type nat dynamic adequacy theorem states term type nat compiled denotation moreover compiled terminates runtime denotation crucial result shows operational distinction static dynamic evaluation respected model particular way two relations combined ected theorem 6 dynamic adequacy let closed term type nat dynamic value moreover liftn 32 proof static adequacy section prove static adequacy theorem logical relation given relate operational semantics denotational model way ignores denotational semantics dynamic terms following lemma states independence static reduction dynamic terms n u 00 term 00 proof enough observe static rewriting discard duplicate dynamic subterm depend shape nx introduce notion value shape term reach static reduction compilation succeeds values v divided static following two lemmas give characterization values con uence property lemma 8 term value either abstraction snf lemma 9 equality equivalence considered denition logical relation dene family relations elements closed terms type 2 closed 1 exists v upn nat n nat v 0 v 0 c 1 d1 relation used prove semantics term unde ned statically reduced value important dynamic terms show static subterms completely evaluated discarded compilation note relation essentially independent actual interpretation dynamic constructs since checks interpretation dened lemma proof trivial case c c 6 exists unique lemma lemma 12 relation monotone complete type closed following hold chain c 2 f proof interesting case point 2 form 1 2 f nothing prove otherwise exists k 2 v unique lemma 1 u denition 2 c 2 induction hypothesis f f following lemma valid general open terms particular case closed terms states interpretation term related term proof various cases developed quite natural way previous lemmas exception case eort required lemma c 2 proof induction structure let substitution let environment consider important cases case xm let f xm 0 f conclusion immediate otherwise since xm 0 value show c 2 0 taken c n induction hypothesis gives application rule lemma 11 implies fc 00 case l n suppose l n prove fa 00 l n fa conclusion immediate otherwise also f 6 induction hypothesis l induction hypothesis 0 n fa 00 xl 0 n operational rules l gives result case xm let f c 7 proof immediate otherwise denition dyn c 6 fc 6 show exists value v xm 0 0 dynamic type written 1 dn nat consider easy show z 0 induction hypothesis 0 exists value v x 7 z 0 using lemma 7 obtain case xxm let f c 7 0 x 7 c let e 0 e f induction hypothesis 0 e operational semantics x lemma 11 obtain e i1 shown 2 f lemma 14 static soundness given closed term proof proof simple case analysis involving substitution lemma ut proof theorem 5 consider closed term type nat lemma 13 n conversely 33 proof dynamic adequacy section prove interpretation purely dynamic terms essentially callbyname pcf dene translation 2level pcf standard pcf relation two denotational seman tics conclude proof dynamic adequacy theorem refer dynamic terms dynamic types simply terms types introduce new notation indicates interpretation terms 2level pcf usual interpretation terms callbyname pcf ie continuous function model n given 19 dene translation p q dynamic values 2level pcf terms standard pcf translation types simply removes annotations translation type assignments pointwise denition terms following pliftnq pred pv q px xv q understand following logical relation note semantics dynamic type lift corresponding static type denition logical relation r dynamic type dene logical relation r f r d1 d2 g b c b r d1 c implies dappf b r d2 gc relation intended used purely dynamic terms ie terms compile hence always dened thus 2lpcf relation anything upper levels relation essentially one toone lemma type b r c equivalently lemma b r c proof induction structure let environment x 7 let 0 environment x 7 c consider key cases case xd let f b 7 0 let g c 7 pd 0 suppose denition dyn exists 2 1 6 fa r d1 downa lemma 16 hence induction hypothesis 0 fa r d2 gdowna lemma contradiction hence conclude dynf 6 show dynf r d1 d2 g suppose b r d1 c show dappdynf b r d2 gc induction hypothesis 0 fb r d2 gc dynf 6 b 6 since fb shown dynf r d1 d2 g case x let f xd 0 g xpd 0 case dynf r g b r c implies dappdynf b r gc lemma 16 hence f f proof theorem 6 take closed term type nat dynamic value conversely lemma 14 suppose upn hence adequacy pcf liftn conversely liftn soundness pcf upn lemma 17 4 model cpo nal section introduce new model 2level pcf showing advantages previous one show limits new model outline ideal model would far seen interpret 2level pcf category cpo complete partial orders continuous functions seen function dyn interpret dynamic types denition completely natural use cpo allows give natural interpretation denition category cpo dened follows objects triples x p x cpos continuous function morphisms x p b q pairs hf gi following diagram commutes f identity x p pair hid id x composition pointwise hh li hf category cpo cartesian closed product dened pointwise exponential object x p b q 1 rst projection order upper cpo dened conjunction two orders functions use additional notation unique morphism x1 1 cpo one element element 1 f xy continuous function f xy extension f maps indicates exponential cpo exponential cpo machinery give another model 2level pcf types interpreted follows id cpo uses parametrisation visualized static compile dynamic model top cpo represents information compilation bottom one represents information compilation nat case bottom part says whether program compiled give characterization interpretation dynamic types consider notation 2 x given cpo x interpretation dynamic type following property dene family morphisms dyn 0 used interpret dynamic terms denition 19 pair cpos x dene diagrams nature objects involved enough give upper function morphism lower one determined note f also g give formal interpretation terms since similar cpo case note considering global elements ie morphisms 1 interpretations base types dynamic types cpo order isomorphic interpretations cpo hence interpretation dynamic terms static constructs given essentially way particular type assignment interpreted product interpretations types static abstraction application interpreted usual way using cartesian closed structure cpo remaining cases dynamic abstraction interpreted like cpo case using dyn 0 instead dyn static x point interpreted using cpoenrichment cpo another example illustrates model cpo improvement previous one consider type u natnat denition intuition operational semantics suggests denable functions type constant ones way dynamic subterm uence compilation static term side elements pairs hf gi following diagram commutes f id f 6 g constant function otherwise g maps constant remaining elements 41 limits model seen introduction cpo model eliminates junk present cpo one new model completely satisfactory clear following example consider simple language base types booleans interpretation type boolbool contain pairs hf gi f commutes b set ftrue falseg particular clearly denable term would required able distinguish failure compiletime runtime argument shows elements model denable nal remark make casestudy optimal interpretation even easier type consider type unit whose constant want study denable functions type unitunit consider global elements unitunit say ones denable f following cases case f also g dened xliftsund case g component dened xydund x dened xx dened xylift x case component dened xdund dened xlift summary 6 denable functions type unitunit cpo interpretation contains 8 functions cpo one contains 10 functions 5 conclusion work presented operational denotational semantics 2level language dynamic static operational semantics callbyname denotational model however bit unusual model static part standard model dynamic part lift standard callby name model lifting used capture interplay static dynamic evaluation adequacy theorem conrms accuracy model regard model although adequate precise contains junk example type natnat interpreted cpo n n actual denable functions either undened send dened element dened result conclusion relation static dynamic subtle understand perfectly yet semantic point view particular nature cartesian closed arrow usual interpretation callbyvalue lazy calculus future work would clarify meaning categorical point view another area work choice evaluation strategies chosen callbyname static dynamic levels simplicity expect could work callbyvalue lazy calculus acknowledgements want thank peter ohearn many fruitful discussions also grateful eugenio moggi anonymous referees useful comments early draft paper paul taylors macros diagrams used r handbook logic computer science mixed linear nonlinear logic proofs categorical model intuitionistic linear logic pragmatics typedirected partial evaluation semantic account typedirected partial evaluation partial evaluator untyped lambda cal culus semantics programming languages structures techniques polymorphic bindingtime analysis type specialization lambda calculus leeuwen editor handbook theoretical computer science projection factorisations partial evaluation categorical account twolevel languages functor categories twolevel languages lcf programming language tr experiment partial evaluation generation compiler generator projection factorisations partial evaluation twolevel functional languages semantics programming languages handbook logic computer science vol 2 typedirected partial evaluation handbook theoretical computer science partial evaluation polymorphic bindingtime analysis semantic account typedirected partial evaluation functor categories twolevel languages multilevel lambdacalculi pragmatics typedirected partial evaluation type specialisation lambdacalculus new paradigm partial evaluation based type inference
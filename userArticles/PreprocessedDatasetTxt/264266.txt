scheduling data layout policies nearline multimedia storage architecture recent advances computer technologies made feasible provide multimedia services news distribution entertainment via highbandwidth networks storage retrieval large multimedia objects eg video becomes major design issue multimedia information system works multimedia storage servers assume online disk storage system consider twotier storage architecture robotic tape library vast nearline storage online disk system frontline storage magnetic tapes cheaper robust larger capacity hence cost effective large scale storage systems eg videoondemand vod systems may store tens thousands videos study detail design issues tape subsystem propose novel tapescheduling algorithms give faster response require less disk buffer space also study diskstriping policy data layout tape cartridge order fully utilize throughput robotic tape system minimize online disk storage space b introduction past years witnessed tremendous advances computer technologies storage architectures eg fault tolerant disk arrays parallel io architec tures high speed networking systems eg atm switching technology compression coding algorithms advances made feasible provide multimedia services multimedia mail news distribution advertisement entertainment via high bandwidth networks consequently research multimedia storage system received lot attention recent years recent research works emphasized upon investigation design multimedia storage server systems magnetic disks primary storage 2 7 issues realtime playback multiple audio channels studied 17 author presented technique storing video audio streams individually magnetic disk author proposed 16 techniques merging storage patterns multiple video audio streams optimize disk space utilization maximize number simultaneous streams 9 performance study carried robotic storage system 4 5 novel storage structure known staggered striping technique proposed efficient way delivery multiple video audio objects different bandwidth demands multiple display stations 8 hierarchical storage server proposed support continuous display audio video objects personal computer 11 authors proposed cost model data placement storage devices finally prototype continuous media disk storage server described 12 challenging task implement costeffective continuous multimedia storage system store many large multimedia objects eg video time allow retrieval objects playback bandwidths example 100 minutes hdtv video requires least 2 mbytessecond display bandwidth 12 gbytes storage3 moderate size video library 1000 videos would require tbytes storage would cost effective implement manage huge amount data magnetic disk subsystem costeffective alternative store multimedia objects permanently robotic tape library use pool magnetic disks disk arrays 15 buffering distribution words multimedia objects reside permanently tapes loaded onto disks delivery requested disk server reduce tape access delays actively accessed videos would also stored disks long term basis disk array functions cache objects residing tape library well buffer handling bandwidth mismatch tape drive multimedia objects given architecture paper aims design high performance storage server following requirements ffl minimal disk buffer space robotic tape library parallel disk array disk space required handling bandwidth mismatch large multimedia objects video hdtv tape subsystem ffl minimal response time request multimedia storage system response time request large multimedia object greatly reduced organizing display unit network device parallel disk robotic tape library pipeline data flows continuous rate display bandwidth multimedia object along pipeline since multimedia objects reside tape subsystem minimize system response time minimize tape subsystem response time throughout paper tape subsystem response time defined arrival time first byte data request disk array minus arrival time request multimedia storage system ffl maximal bandwidth utilization tape drives current tape library architectures usually tape drives hence bandwidth utilization tape drives major factor average response time throughput storage server better utilization bandwidth tape drives means higher throughput tape subsystem contribution paper twofold first propose novel scheduling approach tape subsystem show approach reduce system response time increase system throughput lower disk buffer requirement secondly study disk block organization disk subsystem show incorporated tape subsystem support concurrent upload playback large multimedia objects organization paper follows describe architecture multimedia storage system present tape subsystem scheduling algorithms sections 2 3 respectively discuss disk buffer requirement supporting various tape subsystem scheduling algorithms section 4 section 5 describe disk block organization data layout tape cartridge supporting concurrent upload playback large multimedia objects section 6 discuss performance study lastly conclusion given section 7 multimedia storage system consists robotic tape library parallel disk array robotic tape library robotic arm multiple tape drives tape cartridges multimedia objects reside tape cartridge storage cells placing tape cartridges figure 1 illustrates architectural view multimedia storage server robotic arm computer control load unload tape cartridges load tape cartridge tape drive system performs following steps 1 wait tape drive become available 2 tape drive available occupied another tape ex tape uploaded previous request eject tape drive unload tape storage cell library call operations drive eject operation robot unload operation respectively 3 fetch newly requested tape storage cell load ready tape drive call operations robot load operation drive load operation respectively multimedia object requested multimedia object first read tape stored disk drives via memory buffer cpu multimedia object played back retrieving data blocks multimedia object disk drives continuous rate object bandwidth main memory storage server sends data blocks main memory playback unit via network interface frequently accessed multimedia objects cached disk drives reduce tape access improve system response time well throughput define notations robotic tape library table 1 notations useful performance study later sections display display display parallel disk array disk controller memory buffer robotic tape library tape controller cartridge cell robot arm tape cartridge figure 1 costeffective multimedia storage server important point parameter values robotic tape library vary greatly system system instance table 2 shows typical numbers two commercial storage libraries 3 tape subsystem scheduling algorithms section describe several tape drive scheduling algorithms multimedia storage system typical robotic tape library one robot arm small number tape drives request tape library demands reading uploading multimedia object tape cartridge straightforward algorithm conventional algorithm schedule tape drive serve request one one ie tape drive reads whole multimedia object current request disk array reading multimedia object next request queue since number tape drives small r number robotic arms number tape drives l tape drive load time drive eject time drive rewind time drive search time u robot load unload time drive transfer rate display bandwidth object size object table 1 notations used robotic tape library reading time multimedia object quite long 1 new request often wait available tape drive conventional algorithm performs reasonably well tape drive bandwidth lower display bandwidth multimedia objects requested however conventional algorithm would result good request response time tape drive bandwidth total display bandwidth two objects illustrate suppose tape library ampex dst800 2 one tape drive consider situation two requests 100 minutes different objects display bandwidth 2 mbytessecond two requests arrive time tape drive idle video object size equal display duration times display bandwidth equal 100 theta 60 theta 2 mbytes conventional algorithm transfer first request starts robot load operation drive load operation response time takes 1200 seconds upload 1 hour hdtv video object tape drive 6 mbytessecond bandwidth 2 parameter values table 2 parameter exabyte120 ampex dst800 average l 354 5 average e 165 seconds 4 seconds seconds 1213 seconds average 45 seconds 15 seconds number tapes 116 256 tape capacity 5 gbytes 25 gbytes table 2 typical parameter values two commercial storage libraries first request however second request wait complete transfer first multimedia object request rewinding tape r ejecting tape drive unloading tape tape drive cell robot u robot load newly requested tape u load tape drive l response time second request hence average response time two requests 450 seconds scenario illustrated figure 2 transferr request 1 request 2 drive load drive eject figure 2 conventional tape scheduling algorithm major problem conventional algorithm multiple requests arrive within short period time average request response time significantly increased due large service time individual requests since tape drive ampex system several times display bandwidth multimedia objects tape drive serve two requests timeslice manner request receives half bandwidth tape drive suppose tape drive serves two requests timeslice manner transfer period 300 seconds illustrated figure 3 two objects uploaded disk array average rate 65 mbytessecond 3 figure 3 response time first second requests u seconds u l 300t e u u l seconds respectively hence average response time 15 seconds improvement 60 argue timeslice scheduling request 2 request 1 drive load drive eject figure 3 timeslice tape scheduling algorithm algorithm implemented small overheads tape systems instance d2 tapes used ampex robot system concept zones1 zones 3 overhead tape switch approximately10 transfer time hence effective bandwidth tape drive 1305 mbytessecond 65 mbytessecond object places tape tape drift stop reading tape function zone tape drive start reading zone rather rewinding beginning tape tape drive reads tape timeslice algorithm following advantages ffl average response time greatly improved light load conditions ffl case request multimedia object canceled uploading parts object disks ex customers may want cancel movie due emergency poor entertainment value movie waste tape drive bandwidth uploading unused parts multimedia objects reduced ffl timeslice algorithm requires less disk buffer space conventional algo rithm discussion disk buffer space requirement given section 4 however timeslice algorithm requires tape switches therefore higher tape switch overheads higher chance robot arm contention goal study several versions timeslice scheduling algorithm minimize average response time requests multimedia storage system also find point switch timeslice algorithm conventional tape scheduling algorithm rest section describe scheduling algorithm detail 31 conventional algorithms conventional algorithm nonpreemptive scheduling algorithm firstcomefirstserved algorithm request arrives request joins request queue request request queue said ready tape cartridge request used serve another request simplest scheduling algorithm fcfs algorithm fcfs algorithm selects oldest ready request queue reading tape drive available disadvantage fcfs algorithm response time short request greatly increased preceding long requests 18 another possible conventional algorithm shortestjobfirst sjf algorithm sjf algorithm improves average response time serving ready request shortest service time service time request time required complete tape switch data transfer tape rewind operation request however risk using sjf algorithm possibility starvation longer requests long steady supply shorter requests implementations fcfs sjf algorithms similar separate implementation two cases 1 single tape drive available tape subsystem 2 multiple tape drives tape subsystem single tape drive implementation conventional algorithms straightforward shown follow procedure conventional begin true begin ready request wait ready request get ready request request queue serve request multiple tape drives implementation conventional algorithms consists several procedures procedure robot instantiated procedure tape instantiated n times instance procedure tape corresponds physical tape drive instance unique id procedure conventional begin run robot process 0 num tape 1 run tapei process procedure robot begin true begin accept new request request ready tape drive available begin get request request queue send request idle tape drive else available drive occupied perform drive unload operation robot unload operation else wait ready request occupied available drive procedure tapeinteger id begin true begin wait request robot arm serve request 32 timeslice algorithms timeslice algorithms classify requests two types 1 nonactive requests 2 active requests newly arrived requests first classified nonactive requests put request queue nonactive request said ready tape cartridge used serving another request active requests requests served tape drive timeslice manner since timeslice algorithms viable tape switch overhead small restrict tape rewind operation performed request completely served tape search operation performed beginning service request implies two requests tape cannot served concurrently note chance two requests tape system small 1 access distribution objects highly skewed since video rental statistics suggest highly skewed access distributions 8020 rule 80 percent accesses go popular 20 percent data 6 2 frequently accessed objects kept disk drives tape switch time equal total time complete tape drive eject opera tion robot unload operation robot load operation tape drive load operation tape search operation remaining paper let h maximum tape switch time timeslice algorithms break request many tasks unique task number task request served separately order increasing task number request assigned timeslice period maximum service time task request service time task includes time required tape switch data transfer task last task request service time also includes time required tape rewind operation many possible ways serve several requests timeslice manner concentrate two representative timeslice algorithms roundrobin rr algorithm least slack ls algorithm 321 roundrobin algorithm section formally describe roundrobin algorithm active requests r n1 rm ready nonactive requests n let video object requested r let timeslice periods assigned r roundrobin algorithm active requests served roundrobin manner round service one task active request served active requests served order round service order satisfy bandwidth requirement active request r average transfer bandwidth allocated r must geater equal bandwidth r formally speaking bandwidth requirement r satisfied roundrobin algorithm maintains following condition condition guarantees bandwidth requirements active requests satisfied efficiency algorithm defined 1 system lightly loaded tape drive serve least one request addition currently active requests average response time reduced smaller timeslice period newly arrival less likely wait long period however smaller timeslice period means smaller number active requests served simultaneously thereby increasing chance newly arrived request wait completion active request therefore different timeslice periods different efficiencies timeslice algorithm required optimize average response time different load conditions simplify discussion assume request timeslice period rest paper unless state otherwise specification roundrobin algorithm simple roundrobin algorithm algorithm assigns active request timeslice period h seconds satisfy following conditions condition 1 tape drive serves requests r 1 r n roundrobin manner timeslice period seconds condition 2 time slice period available time data transfer task served last task active request otherwise available time data transfer rewind time tape condition 3 request r n1 oldest ready nonactive request becomes active straightforward implementation simple roundrobin algorithm consider whether active requests served concurrently end service round ie algorithm evaluates condition 3 end service round call implementation rr1 algorithm separate implementation two cases 1 single tape drive tape subsystem 2 multiple tape drives tape subsystem single tape drive procedure rr1 begin true begin active request ready nonactive request wait ready nonactive request last active request served condition 3 simple roundrobin algorithm satisfied accept ready nonactive request get task active task queue serve task rr1 algorithm newly arrived request wait one half duration service round tape subsystem serve least one request addition currently active requests since duration service round grows linearly number active requests average waiting time request high several active requests improve situation check whether one request served tape subsystem every completion active task call improved implementation roundrobin algorithm rr2 algorithm multiple tape drives case multiple tape drives consider robot arm contention tape drives need wait robot arm load unload worst case tape switch requires robot load operation robot unload operation therefore worst case robot waiting time 2 theta u theta n gamma 1 hence condition 3 revised become 322 leastslack ls algorithm let us study another version timeslice algorithm improve response time multimedia request order maintain playback continuity object task request object must start transfer data finishing playback data previous task gamma 1 define latest start time transfer lstt task active request latest time task start transfer data order maintain playback continuity requested object formally lstt task j defined request arrival time request response time j first task time data task j slack time task defined maxlstt task gamma current time 0 let time required complete data transfer j tape rewind operation j j last task request deadline task j defined ready nonactive request r become active tasks r served immediately task active request served lstt ls algorithm algorithm serves requests following conditions condition 1 active task served one timeslice period seconds condition 2 active tasks served ascending order slack time condition 3 time slice period available time data transfer task served last task active request otherwise available time data transfer rewind time tape condition 4 data transfer active task start lstt active task condition 5 ready nonactive request become active condition 4 violated request become active choose ls algorithm tape scheduling ls algorithm optimal single tape system 14 4 sense scheduling achieved algorithm achieved optimal algorithm case tape subsystem one robot arm one tape drive condition 4 ls algorithm rewritten follows given robotic tape library single tape drive let j active tasks listed ascending order slack time active task service condition 4 ls algorithm equivalent condition active task completed deadline words condition 4 ls algorithm equivalent following condition tape switch time j 4 paper discussed scheduling single multiple processors case single tape drive robot library equivalent case single processor described paper proof assume active task service equation 2 active task start data transfer lstt completed deadline task j k completed deadline time current time deadline j k enough complete j k preceding tasks therefore condition 4 ls algorithm equivalent separate implementation two cases 1 single tape drive tape subsystem 2 multiple tape drives tape subsystem implementation ls algorithm single tape case follows single tape drive procedure ls begin true begin request wait new request ready request nonempty acceptnew begin get oldest ready request put tasks request active task queue get active task least slack time serve task begin float work pointer x active task queue empty work 00 save active task queue put tasks oldest ready request active task queue task queue empty begin x next active task work current time begin restore active task queue returnfalse restore active task queue multiple tape drives implementation consists two procedures robot tape drive procedure robot performs following steps repeatedly accept ready request request accepted become active immediately active tasks idle tape send active task least slack time idle tape else wait idle tape active task procedure tape repeatedly waits active task performs sequence drive eject operation drive load operation data transfer tape rewind operation last task request procedure robot instantiated procedure tape instantiated n times instance procedure tape unique id 4 disk buffer space requirement section study disk buffer requirement various scheduling algorithms described first show conventional algorithm fcfs sjf algorithm requires huge amount buffer space achieve maximum put following theorem states buffer space requirement conventional algorithm theorem 1 object request size display bandwidth conventional algorithm requires b buffer space order achieve maximum throughput sustained tape throughput b equal sb proof tape subsystem achieves maximum throughput 1 infinite number ready requests 2 request search time ie requested object resides beginning tape cartridge tape drive start read object right drive load operation done sustained bandwidth tape subsystem tape subsystem idle starts serve requests one one time interval 0 data consumed rate b uploaded rate hence time gammab os buffer space required hold accumulated data time interval data consumed rate 2b uploaded rate b therefore time gammab os gamma2b os buffer space required hold accumulated data argument continues total object display throughput matches tape sustained throughput obtain upper bound buffer requirement assume tape system whose sustained throughput satisfies following criteria upper bound buffer requirement obtain lower bound buffer requirement assume tape system whose sustained throughput b l satisfies following criteria lower bound buffer requirement 1stherefore buffer space requirement b example disk buffer size 3822 gbytes corollary 1 n tape drives tape library system buffer disk buffer requirement n b following theorem state disk buffer requirement roundrobin timeslice algorithm theorem 2 r 1 r n active requests satisfy following condition roundrobin algorithm achieves bandwidth requirements requested objects 1 n iff disk buffer size proof r 1 n least two disk buffers size gamma hb required concurrent uploading display object hence necessary condition proved suppose request two disk buffers b i1 b i2 size one buffer used uploading multimedia object tape library buffer used displaying object steady state maximum period available buffer till time uploading tape b i1 available system starts output data buffer b i2 display condition theorem b i2 emptied tape drive starts upload data b i1 hence bandwidth satisfied 5 equivalent 15 hours display time arguments following corollary disk buffer requirement ls algorithm corollary 2 r 1 r n active requests satisfy following condition ls algorithm achieves bandwidth requirements requested objects 1 iff disk buffer size theorem 2 corollary 2 ls roundrobin algorithms require less buffer conventional algorithm throughput transfer time time slice period chosen much smaller total upload period object 5 disk subsystem since tape drive bandwidth object bandwidth higher bandwidth single disk drive use striping techniques achieve required bandwidth tape drive object 4 novel architecture known staggered striping technique proposed high bandwidth objects htdv video objects shown staggered striping better throughput simple striping virtual data replication techniques various system loads 4 section show organize disk blocks staggered striping together robotic tape subsystem 1 bandwidths disks tape drives matched 2 concurrent upload display multimedia objects supported 51 staggered striping first give brief review staggered striping architecture technique object divided subobjects u divided mo fragments fragment unit data transferred single disk drive disk drives clustered logical groups disk drives logical group accessed concurrently retrieve subobject u rate equivalent b stride k distance 6 first fragment u first fragment u i1 relationships parameters shown e b disk bandwidth single disk drive ffl size subobject mo theta size fragment ffl unit time time required reading fragment single disk drive note subobject loaded disk drives main memory one time unit reduce seek rotational overheads fragment size chosen multiple size cylinder typical 12 gbytes disk drive consists 1635 cylinders size 756000 bytes peak transfer rate 24 mbitsecond minimum disk seek time 4 milliseconds maximum disk seek time 35 milliseconds maximum latency 1683 milliseconds fragment size 2 cylinders maximum seek latency delay times first cylinder second cylinder milliseconds milliseconds respectively transfer time two cylinders 481 milliseconds total service time including disk seek latency delay disk transfer time fragment 55366 milliseconds hence seek rotational overheads 13 disk bandwidth 7 simplify 6 measured number disks 7 increase number cylinders result much reduction overhead hence fragment 2 cylinders reasonable assumption discussion assume fragment size two cylinders one unit time 055 seconds illustrate idea staggered striping consider following example example 1 figure 4 shows retrieval pattern 50 mbytessecond object five 25 mbytessecond disk drives stride 1 mo 2 object read display subobject u 0 read disk drives 0 1 disk time 4 u41 u40 6 u60 u61 9 u91 u90 figure 4 retrieval pattern object 52 layout storage tape following discussion assume 1 staggered striping used storage retrieval objects disk drives 2 memory buffer tape drives disk drives much smaller size fragment let effective bandwidth time slice algorithm b equal sgammah show storage layout object tape must match storage layout disk drives achieve maximum throughput tape drive object displayed fragment requires bandwidth b mo therefore tape drive produces fragments c unit time blocks fragments stored roundrobin manner fragments produced continuous streams data time consider case described example 1 suppose b 3 subobjects stored following first time unit u 00 u 01 u 10 read tape drive time u 00 u 01 stored disk drive 0 disk drive 1 fragment u 10 discarded reread next time unit disk drive 1 store either u 01 u 10 since output rate tape drive must match input rate disk drives effective bandwidth tape drive 5 mbytessecond tape drive bandwidth cannot fully utilized hand storage layout object follows fu 00 u 01 u 11 g time unit output fragments tape drive stored 3 consecutive disk drives hence bandwidth tape drive fully utilized figure 5 shows timing diagram upload object tape drive time 2 subobject u 0 read disk drives 0 1 hence object displayed time 2 remaining subobjects uploaded disk drives tape drive bandwidth disk drives tape drive fully utilized derive conditions matching way fragments retrieved disk way fragments uploaded tape let k number disk drives disk array stride respectively zg representation shows blocks x z stored roundrobin manner disk time 3 u41 u71 u40 6 u101 u111 u80 9 u141 u110 u140 figure 5 upload pattern object rest section assume bandwidth tape drive least mo1 theta b mo given object uploaded tape drive disk array retrieval pattern ro l theta matrix l number time units required retrieval disk drives ro j equal u ab fragment u ab read time disk drive j ro contains blank entry fragment read disk drive j time given object upload pattern po l theta matrix l number time units required uploading po j tape drive disk array equal u ab fragment u ab read time stored disk drive j ro contains blank entry fragment stored disk drive j time definition 3 storage pattern lp retrieval upload pattern p l theta matrix l integer lp j ith nonblank entry column j p ie lp obtained replacing blank entries p lower nonblanking entries column preservation roworder entries ie 8lp b examples retrieval upload patterns shown figures 4 5 respectively retrieval upload patterns figure 4 figure 5 storage pattern shown figure 6 disk figure example storage pattern staggered striping object uploaded tape drive disk array tape drive bandwidth fully utilized ffl tape drive reads fragments different disk drives unit time ffl storage patterns retrieval pattern upload pattern proof assume retrieval pattern upload pattern storage pattern tape drive reads fragments different disk drives since retrieval pattern upload pattern storage pattern uploaded fragment tape drive retrieved storage disk display since tape drive reads fragments unit time uploaded fragments tape drive retrieved storage disks bandwidth tape drive fully utilized definition 4 object said uniformly distributed set disk drives disk drive contains number fragments object theorem 3 staggered striping object uploaded tape drive disk array tape drive bandwidth fully utilized 1 k common factor greater 1 ie greatest common divisor gcd k 1 2 data transfer period gamma h multiple lcmdmo n least common multiple integers x z proof suppose gcd k 1 gamma h multiple lcmdmo n units consider case object starts uploaded time 0 time fragments stored uniformly distributed disk drives theta since gcd k 1 mod oneone mapping extend domain f set natural numbers n implies fragments uniformly distributed disk drives hence time lcmdmo n stored uniformly distributed disk drives disk buffer consider case object playbacked time 0 time mo fragments retrieved disk drives theta time lcmdmo n retrieved lcmdmo n fragments retrieved disk drive let 0 object consisting fragments following procedure finds upload pattern po 0 storage pattern retrieval pattern ro procedure uploadvar upattern upload pattern rpattern retrieval pattern var begin initialize entries count 0 initialize entries upattern blank spattern storage pattern rpattern begin c ikj mod upload pattern po 0 tape reads different fragments different disk drives time unit storage pattern retrieval pattern upload pattern 0 lemma 2 0 retrieved maximum throughput tape drive hence object multiple size 0 ie uploaded maximum throughput tape drive thus data transfer period multiple lcmdmo n tape drive bandwidth fully utilized case example 1 data transfer period multiple lcm523 10 time units 55 seconds case seconds reasonable timeslice period 200 300 seconds 9 video demand system capacity 1000 100minutes hdtv videos 2 mbytessecond bandwidth requires storage space 1000 theta 12 mbytes 12 tbytes 10 videos reside disks 12 tbytes disk space required number 12 gbytes disk drives disk array 1200 data transfer period multiple lcm120023 400 time units 400 theta 055 seconds seconds timeslice period 250 seconds hence disk array 1200 disk drives used disk buffer well disk cache maximize tape drive throughput maximum output rate disk buffer 9 range timeslice period tape switch overhead 1015 tape drive bandwidth must least maximum utilized bandwidth tape drive maximum utilized bandwidth tape drive given nob mo output rate least maximum utilized bandwidth tape drive disk buffer must support concurrent retrieval least mo e subobjects tape drive minimum number required disk drive buffering mo e theta mo video uploading tape drive first stored disk array playback video object start cluster disk drives uploading overlap cluster disk drives first subobject hence minimum delay disk buffer defined smallest integer n 80 mo stride k carefully chosen minimize disk buffer delay improve overall response time storage server 6 performance evaluation evaluate performance scheduling algorithms two values tape drive mbytessecond 15 mbytessecond computer simulation assume 1 tape contains one object hence search time request 0 seconds 2 request never waits tape since frequently accessed objects kept disk drives probability request wait tape used serve another request low 10 hence second assumption causes negligible errors simulation results assume disk contention disk reads generated playback objects disk writes generated upload objects resolved delaying disk writes 13 follows fragment uploaded tape first stored memory buffer written storage disk idle period disk technique smoothes bursty data traffic disk subsystem probability order 0001 parameters simulation hence improves request response time practice additional memory buffer space required technique small aggregate transfer rate tape subsystem much lower disk subsystem 13 storage size object uniformly distributed 7200 14400 mbytes table 3 shows major simulation parameters results presented 95 confidence intervals length confidence interval bounded 1 parameter case 1 case 2 seconds 12 seconds table 3 simulation parameters 61 single tape drive first study performance algorithms system one robot arm one tape drive request arrival process poisson case 1 tape drive maximum throughput tape subsystem 195 requestshour table 4 presents average response time fcfs sjf rr ls algorithms blank entries table show tape subsystem reached maximum utilization system cannot sustain input requests efficiency rr ls algorithms defined percentage time spent data transfer efficiency 90 means 10 time spent tape switches define relative response time ratio scheduling algorithm response time divided fcfs algorithm response time relative response times sjf rr ls algorithms shown figure 7 req arr fcfs sjf rr1 rr1 rr1 ls ls ls rate reqhr sec sec sec sec sec sec sec sec 100 102284 93615 86736 132380 242681 65223 105995 206968 table 4 response time vs request arrival rate case 2 tape drive bandwidth 15 mbytessecond maximum throughput tape subsystem 472 requestshour consider tape subsystem higher performance tape drive average response time fcfs sjf rr ls algorithms tabulated table 5 request arrival rate reqhour relative average response time figure 7 relative response time sjf rr ls scheduling algorithms blank entries table represent case whereby tape subsystem reached maximum utilization system cannot sustain input requests relative response time rr ls algorithms shown figure 8 req arr fcfs sjf rr1 rr1 rr1 rr2 rr2 rr2 ls ls ls rate reqhr sec sec sec sec sec sec sec sec sec sec sec 20 29870 28084 14582 11013 16325 10466 7562 13280 10630 7392 10224 25 44742 41077 25022 22621 50059 16293 17168 46691 16901 17092 38094 table 5 response time vs request arrival rate cases ls algorithm best performance wide range request arrival rates simulation result shows timeslice algorithm especially ls algorithm performs better fcfs algorithm sjf algorithm rr2 rr2 rr2 request arrival rate reqhour relative average response time figure 8 relative response time sjf rr1 rr2 ls algorithms wide range request arrival rates sjf algorithm performs better fcfs algorithm request arrival rates 62 multiple tape drives previous experiments shown ls rr algorithms outperform fcfs sjf algorithms wide range load conditions study effect robot arm contention ls algorithm experiment system contains 4 tape drives bandwidth 150 mbytessecond maximum throughput tape subsystem 1890 requestshour results shown table 6 plot relative response time vs arrival rate shown figure 9 simulation experiment found large range request arrival rates utilization robot arm small example robot arm utilization 0215 request arrival rate 140 requestshour hence effect request arrival rate fcfs sjf ls e09 20 1919 1918 1513 40 2511 2502 1622 60 3605 3560 2060 table multiple tape drives case response time vs request arrival rate robot arm contention major factor determining average response time 63 throughput finite disk buffer section study maximum throughput fcfs sjf ls algorithms finite disk buffer space maximum throughput scheduling algorithm found close queueing network 200 clients client initiates new request immediately previous request served hence always 200 requests system maximum throughput ls fcfs sjf algorithms evaluated cases 1 2 case size disk buffer chosen large enough store data uploaded tape drive one timeslice period efficiency ls algorithm chosen 09 therefore timeslice period 300 seconds disk buffer sizes case 1 2 1582 gbytes 3955 gbytes respectively results case 1 case 2 shown figure 10 request arrival rate reqhour relative average response time figure 9 relative response time sjf ls algorithms figure respectively figures observe ls algorithm much higher throughput cases 50 improvement fcfs sjf algorithms wide range number disk buffers throughput algorithm grows number disk buffers ls algorithm reaches maximumpossible throughput half buffer requirement fcfs algorithm needs achieve maximum possible throughput sjf algorithm performs slightly better fcfs algorithm fcfs sjf algorithm performs better ls algorithm 10 disk buffer space large enough 64 discussion results results show ls roundrobin algorithms outperform conventional algorithms fcfs sjf wide range request arrival rates cases ls algorithm 90 efficiency outperforms fcfs algorithm sjf algorithm request arrival rate 60 maximum throughput tape subsystem conventional algorithms better response time request fcfs number disk buffers maximum throughput reqhr figure 10 maximum throughput fcfs sjf ls algorithms arrival rate quite high 70 maximum throughput conventional algorithms ls roundrobin algorithm algorithm performs better lower efficiency factor low request arrival rate better higher efficiency factor high request arrival rate results also show relative response time ls roundrobin algorithms reach minimum certain request arrival rate response time sum waiting time w tape switch time h low request arrival rate h major component response time request arrival rate increases zero waiting time conventional algorithms grows faster ls roundrobin algorithms ls roundrobin algorithms serve several requests time hence reduce chance waiting available tape drive therefore relative response time ls roundrobin algorithms decreases increase request arrival rate request arrival low request arrival rate high enough waiting time ls roundrobin algorithms becomes higher conventional algorithms conventional algorithms better utilization tape drive bandwidth covers high load conditions fcfs number disk buffers maximum throughput reqhr figure maximum throughput fcfs sjf ls algorithms 7 concluding remarks paper proposed costeffective nearline storage system large scale multimedia storage server using robotic tape library studied class novel timeslice scheduling algorithms tape subsystem shown light moderate workload class tape scheduling algoritms better response time requires less disk buffer space conventional algorithm also complemented work proposed staggered striping architecture 4 showed using proposed scheduling algorithms organize data layout disks tape cartridges concurrent upload display large multimedia objects performance results selection timeslice value often important choice timeslice algorithm used request arrival process known advance ie average request arrival rate interarrival time distribution known timeslice value adjusted using precomputed results obtained either analytical methods simulations practical environments request arrival process usually known advance one simple method used adjust timeslice value according length queue waiting requests ie larger timeslice value required length queue longer function queue length timeslice value predetermined empirical studies general optimal timeslice value depends request arrival process number requests waiting service states currently active requests work required find best way determine optimal timeslice value r ampex dst800 robotic tape library technical marketing document file system continuous media channel coding digital hdtv terrestrial broadcasting staggered striping multimedia information systems fault tolerant design multimedia server evaluation new applications principles delaysensitive multimedia data storage retrieval multimedia repositories personal com puters hierarchical storage systems analysis striping techniques robotic storage libraries video demand architecture systems applications using design storage server continuous dia scheduling replacement policies hierarchical multimedia storage server multiprocessor scheduling hard realtime environment case redundant arrays inexpensive disks raid efficient storage techniques digital continuous multimedia designing ondemand multimedia service operating systems designing multiuser hdtv storage server tr case redundant arrays inexpensive disks raid principles delaysensitive multimedia data storage retrieval file system continuous media staggered striping multimedia information systems multimedia repositories personal computers hierarchical storage systems tertiary storage fault tolerant design multimedia servers efficient storage techniques digital continuous multimedia using tertiary storage videoondemand servers ctr kien hua ying cai simon sheu patching leung j c lui l golubchik use analytical performance models system sizing resource allocation interactive videoondemand systems employing data sharing techniques ieee transactions knowledge data engineering v14 n3 p615637 may 2002 sh gary chan fouad tobagi modeling dimensioning hierarchical storage systems lowdelay video services ieee transactions computers v52 n7 p907919 july
polynomial time approximation scheme general multiprocessor job scheduling recently considerable interests multiprocessor job scheduling problem job processed parallel one several alternative subsets processors paper polynomial time approximation scheme presented problem number processors system fixed constant result best possible strong nphardness problem significant improvement past results best previous result approximation algorithm ratio 76 epsilon 3processor systems based goemanss algorithm restricted version problem b introduction one assumption made classical scheduling theory job always executed one processor time advances parallel algorithms assumption may longer valid job systems example semiconductor circuit design workforce planning design project processed group people project contains n jobs job worked one set alternatives alternative consists one persons group working simultaneously particular job processing time job depends subgroup people assigned handle job note person may belong several different subgroups question schedule jobs project finished early possible applications include berth allocation problem 21 large vessel may occupy several berths loading unloading ii diagnosable microprocessor systems 20 job must performed parallel processors order detect faults iii manufacturing job may need machines tools people simultaneously iv scheduling sequence meetings meeting requires certain group people 11 scheduling literature 17 kind problems called multiprocessor job scheduling problems among others two types multiprocessor job scheduling problems extensively studied 7 22 first type pm jfixjc max problem subset processors processing time parallel processing job fixed second type general version pm jsetjc max problem job may number alternative processing modes processing mode specifies subset processors job processing time particular processor subset objective problems construct scheduling minimum makespan mprocessor system given list jobs jobs supposed nonpreemptive approximability multiprocessor job scheduling problems studied problem generalized version classical job scheduling prob department computer science texas university college station email chencstamuedu supported part national science foundation grant ccr9613805 department computer science bucknell university lewisburg pennsylvania 17837 email amirandaegbucknelledu j chen miranda lem 2processor system 13 thus nphard hoogeveen et al 18 showed p 3 jfixjc max problem thus also p 3 jsetjc max problem nphard strong sense thus fully polynomial time approximation scheme 5 blazewicz et al 4 developed polynomial time approximation algorithm ratio 43 problem p 3 jfixjc max improved later dellolmo et al 10 gave polynomial time approximation algorithm ratio 54 problem algorithms based study special type schedulings called normal schedulings goemans 14 improved algorithms giving polynomial time approximation algorithm ratio 76 recently amoura et al 1 developed polynomial time approximation scheme problem pm jfixjc max every fixed integer approximation algorithms pm jsetjc max problem successful pm jfixjc max problem bianco et al 3 presented polynomial time approximation algorithm pm jsetjc max problem whose approximation ratio bounded chen lee 8 improved algorithm giving polynomial time approximation algorithm pm jsetjc max problem approximation showed problem p 3 jsetjc max approximated polynomial time ratio 76 ffl present paper unknown whether polynomial time approximation algorithm ratio c problem pm jsetjc max c constant independent number processors system paper present polynomial time approximation scheme problem pm jsetjc max algorithm combines techniques developed amoura et al 1 split jobs large jobs small jobs techniques developed bellolmo et al 10 goemans 14 normal schedulings plus standard dynamic programming scaling techniques precisely based classification large jobs small jobs introduce concept fflcanonical schedulings regarded generalization normal schedulings show job list fflcanonical scheduling whose makespan close optimal makespan show fflcanonical scheduling approximated combining two steps gives us polynomial time approximation scheme pm jsetjc max problem result best possible following sense problem pm jsetjc max nphard strong sense unlikely algorithm improved fully polynomial time approximation scheme 13 polynomial time approximation scheme cannot extended general problem p jsetjc max number processors system given parameter input shown constant problem p jsetjc max polynomial time approximation algorithms whose approximation ratio bounded n ffi 23 paper organized follows section 2 gives necessary background preliminaries problem section 3 introduce fflcanonical schedulings study properties section 4 presents polynomial time approximation scheme problem pm jsetjc max section 5 concludes remarks research directions 2 preliminaries pm jsetjc max problem scheduling problem minimizing makespan set jobs may several alternative processing modes formally instance j problem pm jsetjc max list jobs job j associated list alternative processing modes processing mode simply mode ij specified subset processors mprocessor system ij integer indicating parallel processing time job j processor case ambiguity also say processor set q ij mode job j job j min value min called minimum parallel processing time job j given list jobs scheduling gammaj j mprocessor system consists two parts 1 determination processing mode job j j 2 determination starting execution time job assigned mode moment processor system used maybe parallel processing one job assuming system starts time makespan scheduling gammaj latest finishing time job j scheduling gammaj let optj denote minimum makespan schedulings j pm jsetjc max problem given instance j construct scheduling makespan optj j let pm set processors mprocessor system collection k g k nonempty subsets pm kpartition pm collection subsets pm partition pm kpartition integer k 1 total number bm different partitions set pm called mth bell number 16 using formula comtet 9 looser simpler upper bound bm bm easily proved induction another combinatorial fact need analysis scheduling algorithm cutindex nonincreasing sequence integers lemma 21 let nonincreasing sequence integers let fixed integer ffl 0 arbitrary real number respect ffl integer 2 subset 0 3j 0 mbm integers q q j 0 proof simplify expressions let b 1 decompose sum 4 j chen miranda since bmfflc subsums j larger first subsum k1 fflm since sum first b k1 integers q q bounded fflm fflm sequence nonincreasing conclude subset 0 3j 0 mbm integers q q j 0 must completes proof nonincreasing sequence integers denote j mffl smallest index satisfies conditions 1 2 lemma 21 index j mffl called cutindex sequence 3 fflcanonical schedulings section first assume mode assignment job instance j decided discuss schedule jobs j mode assignment processor set pm assumption job list j actually instance pm jfixjc max problem recall pm jfixjc max problem problem pm jsetjc max restriction every job instance one processing mode instance pm jfixjc max problem job j requires fixed set q processors parallel execution processing time loss generality assume processing time sequence nonincreasing fixed number processors system arbitrarily given real number ffl 0 let j mffl cutindex sequence defined lemma 21 integer bounded bmfflc subset 0 3j mffl mbm integers q q j mffl split job set j two subsets 1 jobs jl called large jobs jobs js called small jobs let gammaj scheduling job set j consider nondecreasing sequence integers h starting finishing times j mffl large jobs gammaj small job block gammaj consists subset p 0 pm processors time interval subset processors exactly executing large jobs time interval called height processor set p 0 called type small job block therefore subset p 0 processors associated small job block processors either idle used executing small jobs time interval note small job block height 0 small job block time interval latest finish time large job called last small job block note last small job block type pm let small job block associated processor set p 0 time interval small job block time moment time interval characterized uniquely collection q pairwise disjoint subsets processor set p 0 time processors subset q used parallel execution small job thus subset subset idle processors time collection q called type time moment layer small job block time moments j type type layer equal type time moment layer height layer let l 1 l 2 two layers small job block types q respectively say layer l 1 covers layer l 2 fr g particular l 1 l 2 two consecutive layers small job block layer l 2 starts right layer l 1 finishes l 1 covers l 2 layer l 2 actually continuation layer l 1 small jobs finished definition 31 floor oe small job block sequence fl consecutive layers 1 h layer l starts right layer 2 small jobs interlacing layer layer l 1 small jobs interlacing layer l h finish layer l h example floor given figure 1a note small job block may nonempty floor shown figure 1b remark 1 important properties floors small job block suppose layer l 1 starts time 1 layer l h finishes time 2 property 2 definition small jobs cross floor boundaries 1 2 therefore floor oe regarded single job uses processor set p 0 starts time 1 finishes time 2 height floor oe defined equal sum heights layers l 1 secondly since floors small job block processor subset p 0 small jobs crossing starting finishing times floors floors small job block rearranged order still fit small job block without exceeding height small job block finally property 1 definition ensures matter small jobs floor rearranged simple greedy algorithm sufficient refit small jobs floor without exceeding floor height greedy algorithm based idea wellknown grahams scheduling algorithm classical job scheduling problem 15 definition 32 let j instance problem pm jfixjc max let permutation jobs j list scheduling algorithm based ordering schedule job j mode q j following ordering earliest time processor subset q becomes available lemma 33 let j oe set small jobs floor oe list scheduling algorithm based ordering jobs j oe always reconstruct floor oe proof suppose first layer l 1 floor oe type according property 1 definition every job j oe must mode q definition layer covers layer l j therefore floor oe processor subset q become idle final completion time 6 j chen miranda b c small job block small job block c floor fig 1 floor fl1 l2 l3g b small job block floor since subsets q pairwise disjoint jobs mode q j oe executed processor subset q order without changing completion time q therefore regardless ordering jobs j oe long list scheduling algorithm starts job earliest possible time thus subset become idle final completion time completion time subset changed therefore list scheduling algorithm construct floor exactly layers l 1 definition 34 let q partition processor subset p 0 say assign type q floor type layer l 1 subcollection fq g note possible assign two different types floor long type floor subcollection assigned floor types example let partition processor subset p 0 first layer l 1 floor oe type q assign either type floor oe definition 35 small job block tower constituted sequence floors assign types floors two floors tower type note since floor type partition processor subset p 0 tower contains bm floors bm mth bell number number different partitions set elements discussion concentrating schedulings special form following sense definition 36 let j instance problem pm jfixjc max divided large job set jl small job set js given equation 1 fixed fixed constant ffl 0 scheduling gammaj j fflcanonical every small job block gammaj tower remark 2 note fflcanonical scheduling small jobs cross boundary tower therefore tower height associated processor set q simply regarded job mode q first show fflcanonical scheduling gammaj j constructed list scheduling algorithm large jobs towers gammaj given proper order lemma 37 let gammaj fflcanonical scheduling job set j let sequence large jobs towers gammaj ordered terms starting times gammaj list scheduling algorithm based ordering regards tower single job constructs scheduling j makespan larger gammaj proof let prefix ordered sequence j j either large job tower let gammaj scheduling j obtained gammaj removing large jobs towers j let gamma 0 j scheduling list scheduling algorithm jobs j suffices prove completion time processor gamma 0 j larger completion time processor gammaj prove induction case suppose mode job tower requires processor subset q i1 parallel processing time i1 let earliest time scheduling gammaj processor subset q available let 0 earliest time scheduling gamma 0 j processor subset available list scheduling algorithm start j i1 time thus scheduling gamma 0 j i1 completion time processor subset hand scheduling gammaj i1 job j i1 cannot start earlier since according definition ordered sequence j i1 cannot start jobs j started therefore scheduling gammaj i1 completion time processor q i1 least smaller since inductive hypothesis assumes 0 finally processor subset q i1 completion time gamma 0 j i1 equal gamma 0 j induction larger gammaj equal completion time processor gammaj i1 thus ordering large jobs towers decided easy construct scheduling worse given fflcanonical scheduling following prove instance j problem pm jfixjc max fflcanonical scheduling whose makespan close optimal makespan theorem 38 let j instance problem pm jfixjc max ffl 0 fflcanonical scheduling gammaj j makespan gammaj bounded 1 proof optimal scheduling makespan optj j construct fflcanonical scheduling j based optimal scheduling 8 j chen miranda let jl js set large jobs set small jobs j respectively according definition equation 1 consider small job block scheduling assume small job block associated processor set p 0 r processors r time interval list partitions processor set p 0 divide layers small job block groups corresponding partition p 0 follows layer type 0 put group corresponding partition j 0 subcollection j note layer type 0 may subcollection one partition p 0 case put layer arbitrarily one one groups ensure layer belongs one group partition j p 0 construct floor frame oe j whose type j height equal sum heights layers belonging group corresponding partition j note far actually assigned small jobs floor frames oe 1 yet moreover since layer belongs exactly one groups easy see sum heights floor frames oe 1 equal sum heights layers small job block equal height small job block construction floor frames last small job block gamma 1 j slightly different group layers processors idle thus sum heights floor frames last small job block equal latest finish time large job scheduling construction floor frames small job block scheduling small jobs js floor frames using following greedy method small job j requires parallel processing processor subset q assign j arbitrary floor frame oe small job block long floor frame oe satisfies following conditions 1 type floor frame oe contains subset q 2 adding job j oe exceed height floor frame oe one floor frames satisfying conditions arbitrarily pick one note assign job floor frame mode job contained type floor frame therefore assignment never leave gap two jobs floor frame assignment small jobs js floor frames stops none small jobs left js assigned floor frames according rules floor frame becomes floor small job block gamma 1 j let set floor frames since height resulting floor larger height corresponding floor frame sum heights floors resulting floor frames larger height small job block therefore put floors small job block arbitrary order make tower small job blocks gamma 1 j gives fflcanonical scheduling job set jl j 0 set small jobs assigned floor frames procedure makespan scheduling bounded optj thing left still need schedule small jobs assigned floor frames let j 00 set small jobs assigned floor frames procedure want demonstrate many jobs set j 00 definition number small job blocks scheduling gamma 1 j 2j mffl 1 3j mffl since small job block associated processors number floor frames constructed small job block bounded bm therefore total number floor frames constructed scheduling bounded 3bm j mffl moreover floor type collection processor subsets set j 00 contains 3mbm j mffl small jobs must subset q processors number small jobs mode q j 00 larger number constructed floor frames whose type contains subset q set floor frames whose type contains subset q assignment rules assigning job mode q j 00 floor frame would exceed height corresponding floor frame since small jobs mode q j 00 sum processing times small jobs mode q js larger hand construction floor frames small job block sum heights floor frames whose type contains q smaller sum heights layers whose type contains q summarizing small job blocks conclude sum smaller sum processing times small jobs mode q js since small job mode q must contained consecutive layers whose type contains q derives contradiction contradiction shows 3mbm j mffl small jobs set j 00 assign small jobs j 00 floor frames last small job block scheduling gamma 2 jl j 0 small job j mode q j 00 arbitrarily assign j floor frame whose type contains q last small job block even assignment exceeds height floor frame note last small job block associated whole processor set pm mode q must floor frame last small job block whose type contains processor subset q procedure stops small jobs j 00 assigned floor frames last small job block easy see resulting scheduling fflcanonical scheduling original job set j moreover since makespan scheduling bounded optj makespan fflcanonical scheduling gamma 3 j bounded tj parallel processing time small job j since small jobs set j 00 lemma 21 easy see optj therefore makespan ffl canonical scheduling gamma 3 j bounded 1 completes proof theorem close section introduce one definition definition 39 let oe floor type pairwise disjoint subsets processors processor set pm subset plus height l called room floor oe whose type q j chen miranda 4 approximation scheme come back original problem pm jsetjc max recall instance j problem pm jsetjc max set jobs job j given list alternative processing modes pair q specifies parallel processing time ij job j subset q ij processors mprocessor system order describe polynomial time approximation scheme problem let us first discuss problem difficult classical job scheduling problem classical job scheduling problem job executed one processor system therefore order executions jobs processor crucial running time processor simply equal sum processing times jobs assigned processor therefore decision job assigned processor order uniquely determine makespan resulting scheduling makes possible use dynamic programming approach extends scheduling subset jobs larger subset situation general multiprocessor job scheduling problem pm jsetjc max hand complicated particular makespan scheduling depends assignment processing modes jobs also order jobs executed therefore techniques extending scheduling subset jobs classical job scheduling problem directly applicable theorem 38 shows fflcanonical scheduling whose makespan close optimal makespan therefore constructing scheduling whose makespan larger makespan good fflcanonical scheduling give good approximation optimal schedulings nice properties fflcanonical scheduling within tower order floors affect height tower within floor order small jobs affect height floor see remark 1 remark 2 previous section therefore factor affects heights towers floors assignments jobs towers floors makes become possible least small jobs apply techniques classical job scheduling problem current problem described follows first suppose somehow divide job set j large job set jl small job set js let us start fflcanonical scheduling gammaj set j scheduling gammaj gives nondecreasing sequence f integers starting finishing times j mffl large jobs jl let corresponding towers g tower j consists subset p 0 j processors suppose subset p 0 j processors associated tower j known large jobs towers scheduling gammaj ordered sequence terms starting times however assume assignment small jobs rooms scheduling gammaj unknown show information recovered tower j associated processor set p 0 number floors tower j q r number processors set p 0 let oe j1 floors possible different types tower j floor oe jq let fl jq1 jq rooms floor oe jq r jq therefore configuration small jobs fflcanonical scheduling gammaj algorithm schedulesmall input set js small jobs order large jobs towers gammaj output scheduling job set j 1 2 ns mode q ij small job j 0 true job j 0 mode q ij addable room fl jqr 3 call list scheduling algorithm based order construct scheduling j room fl jqr running time jqr jqr 0 4 return scheduling constructed step 3 minimum makespan fig 2 scheduling small jobs floors specified 2j mffl jqr specifies running time room fl jqr index fj q rg corresponding room fl jqr exists simply set suppose upper bound 0 running time rooms derived use boolean array 2j mffl dimensions describe configuration subset small jobs scheduling z number small jobs j scheduling first small jobs floors gammaj running time room fl jqr jqr recall running time room dependent assignment small jobs room independent order small jobs executed room initially array elements array suppose configuration scheduling first small jobs given 2 say ith small job j 0 mode q addable room fl jqr configuration 2 room fl jqr type q adding job j 0 room exceed upper bound 0 running time room fl jqr ready present dynamic programming algorithm scheduling small jobs rooms fflcanonical scheduling gammaj algorithm given figure 2 note algorithm schedulesmall may return fflcanonical scheduling job set j fact guarantee height towers constructed algorithm exceed height corresponding towers j chen miranda original fflcanonical scheduling gammaj however show scheduling constructed algorithm schedulesmall makespan bounded makespan original fflcanonical scheduling gammaj lemma 41 0 ns array element way assign modes first small jobs arrange rooms room fl jqr running time jqr fj q rg proof prove lemma induction case easily verified suppose way w assign modes first small jobs arrange rooms room fl jqr running time jqr rg suppose w assigns ith small job j 0 processing time ij room removing job j 0 w obtain way assigns modes first arrange rooms room fl jqr running time jqr fj q rg 6 room fl j0 q 0 r 0 running time j0 q 0 r 0 inductive hypothesis ith execution loop step 2 algorithm schedulesmall mode small job j 0 chosen q ij processing time ij algorithm assign direction lemma proved similarly omit lemma gives us directly following corollary corollary 42 sequence large jobs towers ordered terms starting times fflcanonical scheduling gammaj algorithm schedulesmall constructs scheduling job set j whose makespan bounded makespan fflcanonical scheduling gammaj proof note fflcanonical scheduling gammaj gives way assign arrange small jobs js rooms according lemma 41 corresponding array element array must value true array element step 3 algorithm construct towers exactly types heights corresponding towers fflcanonical scheduling gammaj may give exactly assignment small jobs rooms however running times corresponding rooms must exactly since sequence given order sorted starting times large jobs towers fflcanonical scheduling gammaj lemma 37 call step 3 list scheduling algorithm based order configuration construct scheduling whose makespan larger makespan fflcanonical scheduling gammaj finally since step 4 algorithm returns scheduling minimum makespan constructed step 3 conclude algorithm returns scheduling whose makespan larger makespan gammaj analyze algorithm schedulesmall lemma 43 let 0 upper bound used algorithm schedulesmall running time rooms running time algorithm schedule small bounded on2 mffl mffl proof number ns small jobs js bounded total number n jobs j small job may 2 different modes also indicated number rooms bounded running time room bounded 0 fixed cannot mffl finally check mffl component values jqr decide job j 0 addable room fl jqr conclusion running time step 2 algorithm schedulesmall bounded also attach mode assignment room assignment job j 0 element true information given configuration true corresponding scheduling small jobs rooms constructed easily backtracking dynamic programming procedure makespan computed time mffl therefore step 3 algorithm takes time conclusion running time algorithm schedulesmall bounded on2 mffl mffl discuss upper bound 0 running time rooms derived given instance problem pm jsetjc max positive real number ffl 0 job j specified list alternative processing modes j recall g sum obviously upper bound makespan fflcanonical schedulings j 0 makespan straightforward scheduling assigns job j mode corresponding min starts job j previous job j finishes fore fflcanonical scheduling makespan better 0 simply return straightforward scheduling particular value upper bound running time rooms moreover since job set j takes least 0 amount work work taken job equal parallel processing time multiplied number processors involved processing system processors value 0 also provides lower bound optimal makespan optj order apply algorithm schedulesmall need first decide set j split large job set jl small job set js modes large jobs types towers ordering large jobs towers list scheduling algorithm applied according lemma 21 number large jobs form j k bmfflc definition number towers 2j mffl 1 ffl fixed number large jobs number towers bounded constant therefore use brute force method exhaustively try possible cases achieve polynomial time approximation scheme problem pm jsetjc max combine standard scaling techniques 19 concept fflcanonical schedulings follows 14 j chen miranda algorithm approxscheme input instance j problem pm jsetjcmax output scheduling j 2 let j 0 job set obtained scaling job set j k 3 bmfflc 31 subset j 0 l j 0 jobs j 0 32 mode assignment jobs j 0 33 possible sequence 2j0 34 ordering j 0 jobs j 0 l 2j0 call schedulesmall small job set j 0 ordering construct scheduling job set j 0 use 0 upper bound running time rooms 4 scheduling constructed step 3 minimum makespan 5 replace job j 0 corresponding job j obtain scheduling gamma 0 j job set j 6 return job scheduling gamma 0 j fig 3 approximation scheme instance pm jsetjc max problem j let construct another instance n g problem j 0 jobs j 0 identical j except processing times ij replaced bt ij kc say job set j 0 obtained job set j scaling processing times k apply algorithm discussed instance j 0 construct scheduling j 0 scheduling j induced formal algorithm presented figure 3 explain step 5 converts scheduling gamma 0 j 0 job set j 0 scheduling job set j first multiply processing time starting time job j 0 scheduling gamma 0 j 0 k keeping processing mode job j 0 mode q ij processing time bt ij kc starts time gamma 0 j 0 replace job j 00 mode q ij processing time k let start time k equivalent proportionally expanding scheduling k expansion scheduling gamma 0 j 0 following order terms finish times correction processing times increasing processing time job j 00 k increase processing time may cause many jobs scheduling delay starting time units particular increase may cause makespan scheduling increase units corrections processing time jobs j obtain scheduling gamma 0 j job set j lemma 44 fixed 2 ffi 0 running time algorithm approxscheme problem pm jsetjc max bounded mffl j mffl 1 proof since integer k bounded bmfflc number j 0 large jobs j 0 bounded j therefore ways choose large job set j 0 l since job may 2 alternative mode assignments total number mode assignments large set j 0 l bounded tower associated subset processor set pm processors thus tower may associated different subsets pm therefore number different sequences 2j mffl 1 towers bounded finally number permutations j 0 large jobs 2j 0 1 towers 3j 0 1 summarizing together conclude number times algorithm schedulesmall called bounded obmfflc algorithm schedulesmall applied job set j 0 upper bound running time rooms according lemma 43 call algorithm schedulesmall takes time combining equations 3 4 noting ffi thus ffl fixed constants conclude running time algorithm approxscheme bounded mffl j mffl 1 ready present main theorem theorem 45 algorithm approxscheme polynomial time approximation scheme problem pm jsetjc max proof proved lemma 44 algorithm approxscheme runs polynomial time ffi fixed constants therefore need show makespan scheduling gamma 0 j constructed algorithm approx scheme instance j problem pm jsetjc max 1 times optimal makespan optj instance j let let gammaj optimal scheduling makespan optj scheduling gammaj mode assignments jobs fixed thus particular mode assignment makes us able split job set j large job set jl small job set js according job processing time according theorem 38 ffl canonical scheduling instance j mode assignments makespan gamma 1 j bounded 1 consider room fl jqr fflcanonical scheduling gamma 1 j suppose small jobs assigned room fl jqr scheduling gamma 1 j processing time job j p gammaj thus must 0therefore mode assignments processing time replaced room assignments corresponding scheduling gamma 1 j 0 set j 0 rooms running time exceeding 0 thus lemma 41 step 3 algorithm approxscheme loops stage large job set mode assignments tower types ordering large jobs towers match scheduling gamma 1 j 0 array element j chen miranda corresponding room configurations scheduling must value true thus scheduling gamma 0 based configuration constructed makespan calculated note scheduling gamma 0 may exactly scheduling must exactly makespan since step 4 algorithm approxscheme picks scheduling gamma 0 j 0 smallest makespan schedulings j 0 constructed step 3 conclude makespan scheduling gamma 0 j 0 larger makespan scheduling gamma 0 larger makespan scheduling described paragraph lemma 44 obtain corresponding scheduling job set j first expand scheduling gamma 0 j 0 k ie multiplying job processing times starting times gamma 0 j 0 k let resulting scheduling gamma 0 j 00 similarly expand scheduling gamma 1 j 0 k obtain scheduling gamma 1 j 00 makespan scheduling gamma 0 j 00 larger makespan scheduling gamma 1 j 00 since obtained proportionally expanding schedulings respectively factor k moreover makespan gamma 1 j 00 larger makespan ffl canonical scheduling two schedulings use large job set mode assignment small job set mode assignment room assignment order large jobs towers difference processing time ij job j gamma 1 j replaced possibly smaller processing time k corresponding job j 00 consequence conclude makespan scheduling gamma 0 j 00 larger makespan fflcanonical scheduling gamma 1 j bounded finally obtain scheduling gamma 0 j job set j make corrections processing times jobs scheduling gamma 0 j 00 precisely replace processing time k processing time job j job set j correcting processing time job j 00 may make makespan scheduling increase therefore corrections processing time jobs j 00 makespan finally resulting scheduling gamma 0 j job set j constructed algorithm approxscheme bounded makespan used fact optj 0 completes proof theorem 5 conclusion remarks paper developed polynomial time approximation scheme pm jsetjc max problem fixed constant result achieved combinations recent techniques developed area multiprocessor job schedulings plus classical dynamic programming scaling techniques note result significant improvement previous results problem previous approximation algorithms problem pm jsetjc max approximation ratio bounded constant independent number processors system result also confirms conjecture made amoura et al 1 following make remarks work problem multiprocessor job scheduling problem seems intrinsically difficult prob lem example number processors system given variable input problem becomes highly nonapproximable constant ffi polynomial time approximation algorithm problem approximation ratio smaller n 23 observing plus difficulties developing good approximation algorithms problem people suspected whether pm jsetjc max problem fixed maxnp hard 8 present paper completely eliminates possibility 2 current form polynomial time approximation scheme may practically useful yet even small integer reasonably small constant ffl time complexity algorithm bounded polynomial high degree hand algorithm shows normalized schedul ings whose makespan close optimal ones good normalized schedulings constructed systematically interested investigating tradeoff degree kind normalization time complexity approximation algorithms particular interested developing practical polynomial time algorithms systems small number processors p 4 jsetjc max note currently known practical approximation algorithm p 4 jsetjc max problem whose approximation ratio smaller 2 ratio 2 approximation algorithm problem follows chen lees recent work general pm jsetjc max problem 8 moreover far approximation algorithms pm jsetjc max problem involved technique dynamic programming general results algorithms high complexity techniques may avoid dynamic programming acknowledgement authors would like thank friesen frank ruskey helpful discussions r scheduling independent multiprocessor tasks proof verification hardness approximation problems scheduling multiprocessor tasks dynamic configuration dedicated processors scheduling multiprocessor tasks three dedicated processors scheduling multiprocessor tasks three dedicated processors information processing letters 41 1992 pp 275280 scheduling multiprocessor tasks minimize scheduling length scheduling multiprocessor tasks survey general multiprocessor tasks scheduling efficiency effectiveness normal schedules three dedicated processors simultaneous resource scheduling minimize weighted flow times complexity scheduling parallel task systems computers intractability guide theory npcompleteness approximation algorithm scheduling three dedicated machines bounds certain multiprocessing anomalies concrete mathematics approximation algorithms scheduling complexity scheduling multiprocessor tasks prespecified processor allocations fast approximation algorithms knapsack sum subset problems approximation algorithm diagnostic test scheduling multicomputer systems scheduling multiprocessor tasks without prespecified processor allo cations current trends deterministic scheduling approximation algorithms multiprocessor task scheduling tr ctr c w duin e van sluis complexity adjacent resource scheduling journal scheduling v9 n1 p4962 february 2006 klaus jansen lorant porkolab polynomial time approximation schemes general multiprocessor job shop scheduling journal algorithms v45 n2 p167191 november 2002 jianer chen xiuzhen huang iyad kanj ge xia polynomial time approximation schemes parameterized complexity discrete applied mathematics v155 n2 p180193 january 2007
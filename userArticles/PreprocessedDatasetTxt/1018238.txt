adaptive offloading pervasive computing pervasive computing lets users continuously consistently access application heterogeneous devices however delivering complex applications resourceconstrained mobile devices cell phones challenging application systembased adaptations attempt address problem often cost considerable degradation application fidelity solution dynamically partition application offload part application execution data powerful nearby surrogate allows delivery application pervasive computing environment without significant fidelity degradation expensive application rewriting runtime offloading must adapt different application execution patterns resource fluctuations pervasive computing environment offloading inference engine adaptively solves two key decisionmaking problems runtime offloading timely triggering offloading efficient partitioning applications tracedriven simulations prototype experiments confirm effectiveness adaptive offloading system b figure 1 adaptive ofoading system architecture partition selection function invocation data access candidate partition plan generation module offloading triggering inference applicationspecific offloading rules application execution monitor event filter bandwidth monitor figure 2 ofoading inference engine architecture stability ofoading inference engine employs fuzzy control model 13 basis ofoading triggering inference module module easily congured using applicationspecic ofoading rules approach analogous internet protocol ip conguration network connection modern operating system avoid unnecessary inference overhead event lter used drop insignicant resource application execution change events ofoading inference engine decides trigger new ofoading action selects new levels resource utilization selects effective application partitioning many possible partition plans generated partition module ofoading platform ofoading platform generates set candidate partition plans using simple heuristic algorithm derived mincut algorithm 17 simultaneously meet multiple user requirements ofoading ofoading inference engine uses composite partitioning cost metric select best partition plan selected application partition plan indicates program objects ofoaded surrogate program objects pulled back mobile device new ofoading action one critical resource constraints mobile device strict memory limitation although memory capacity mobile devices continue increase memory limitation still exist user runs multiple applications multiple instances application article focus describing minimize performance penalty experienced application using adaptive ofoading relieve mobile devices memory constraint overcoming memory constraint allows memoryintensive application used mobile device good performance result otherwise cannot supported without incurring ofoading delity degradation although research 14 shown adaptive ofoading could applied resources cpu speed consider memory article using extensive tracedriven simulations prototype experiments show adaptive ofoading system efciently support memoryintensive applications mobile device pervasive computing environment distributed ofoading platform section introduce distributed ofoading platform includes 1 application execution monitoring 2 resource monitoring 3 application partitioning candidate generation 4 surrogate discovery 5 transparent remote procedure call rpc platform support 21 application execution monitoring without loss generality use java programs rest article illustrate approach ofoading platform application execution characterized weighted directed graph called application execution graph graph node represents java class choose class graph node 1 classes represent natural component unit objectoriented programs 2 classes enable precise ofoading decisions coarser component granules 3 classes make possible avoid manipulating large execution graph many negrained objects eg simple imageediting java program created 16994 distinct objects 174 seconds execution weight metrics associated graph node include 1 memory size describes amount memory occupied java objects java class 2 accessfreq represents many times methods data elds class accessed 3 location describes whether java classs objects currently located mobile device local surrogate surrogate 4 isnative indicates whether classs objects migrated mobile device surrogate classes must always execute mobile device classes invoke devicespecic native methods graph edge represents interactionsdependencies objects two classes edge annotated two elds 1 interactionfreq represents number interactions objects two classes 2 bandwidthrequirement represents total amount information transferred objects two classes current prototype entire application execution graph maintained mobile device ofoading platform execution monitor rst application split execution information surrogate periodically collected merged execution graph mobile device 22 resource monitoring adapt resource changes ofoading platform needs monitor resources mobile device surrogate wireless network available memory mobile device surrogate monitored tracking amount free space java heap obtained garbage collector java virtual machine jvm wireless bandwidth delay estimated passively observing ongoing trafc ofoading platform actively measuring information measurement tools whenever signicant change happens eg certain amount memory consumed sufciently large wireless bandwidth uctuation occurs ofoading inference engine decides whether ofoading triggered 23 candidate partition plan generation problem optimal application partitioning ie nding minimum cut two bounded sets npcomplete 6 however ofoading system designed resourceconstrained devices hence ofoading platform uses efcient partitioning heuristic derived stoers wagners mincut algorithm 17 generate set candidate partition plans e describe current application execution graph v set nodes e set edges edge associated cost value reecting interclass interactionsdependencies introduced later section 32 let pm represent partition mobile device ps represent partition surrogate beginning pm ps initialized empty partition candidate generation algorithm follows step 1 merge nodes cannot migrated surrogate ie nodes isnative eld set true one node v1 merging mean nodes coalesced one node k edges node merged nodes substitute one edge k edges new edge edge cost equal sum costs k old edges suppose n nodes merging let fv2vng 50 90 b figure 3 illustration candidate partition plan generation step 2 among neighbors v1 representing partition mobile device select one largest edge cost v1 suppose selected node vi merge vi v1 move vi ps pm consider cut pmps one candidate partition plans partition plan recorded information paritioning cost two partitions step 3 repeat step 2 nodes merged v1 example figure 3 illustrates process candidate partition plan generation original execution graph cost annotation shown figure 3 first v2 selected among neighbors v1 largest edge cost merge v2 v1 get new graph illustrated figure 3 b new graph derive another candidate partition plan continue merging process four nodes merged one node ofoading inference engine select best partitioning candidate partition plans according partitioning cost metric introduced later section 32 24 surrogate discovery ofoading platform mobile device runs master device surrogate runs slave device slave device runs jvm ofoading platform monitoring modules simplicity current prototype mobile device runs candidate partition plan generator ofoading inference engine components runtime ofoading inference engine decides ofoading needs performed triggers new ofoading action mobile device initiates discovery protocol nd nearby surrogate accept ofoaded application executions current prototype uses wellknown server surrogate easily discovered using wireless broadcast surrogate discovery message complex service discovery protocol upnp 2 jini 1 mobile device transfers bytecode data wishes remotely execute surrogate surrogate loads related classes awaits rpc requests mobile device continue application execution 25 transparent rpc platform support transparent partitioning mechanism transparent rpcs virtual machines needed javas existing support remote execution rmi provide transparent mapping calls objects rpcs machines hence modify hps chai jvm objects transparently migrated mobile device surrogate jvm object uniquely identied object reference support remote execution modify jvm ag object references remote objects intercept accesses remote objects using hooks ofoading platform converts remote accesses transparent rpcs two jvms jvm receives rpc request uses pool threads perform execution behalf jvm using approach threads migrated instead invocations data accesses follow placement objects however several issues must addressed support goal providing single transparent distributed platform two jvms native methods cannot migrated implemented using nonjava languages may different implementations different platforms solve problem native invocations directed back master jvm gives application appearance executing mobile device even though part execution surrogate java objects statically shared application objects systemproperties contains keyvalue pairs specifying information name host operating system therefore ensure consistency accesses static data directed back master jvm jvm private object reference namespace understand object reference another jvm overcome namespace limitations modied jvm map reference another jvm namespace jvm keeps stub local references remote objects placeholders jvm invokes method accesses object jvm sends operation referring object using local object reference receiving jvm maps rst jvms local reference real local reference object jvm maintains object reference mappings objects object references move two jvms 3 adaptive ofoading inference engine section present design details ofoading inference engine describe two decisionmaking modules ofoading inference engine address problems triggering ofoading selecting partitionings ofoading add overhead applications execution overhead includes cost 1 transferring objects mobile device surrogate 2 performing remote data accesses function invocations wireless network one inference engines goals minimize ofoading overhead relieving memory constraint mobile device 31 ofoading triggering inference perform ofoading triggering inference ofoading inference engine examines current resource consumption application available resources pervasive computing environment decides whether ofoading triggered given users ofoading goals decides level resource utilization used mobile device much memory freed ofoading program objects surrogate rst glance problem solved using simple thresholdbased approach example thresholdbased rules hardcoded ofoading inference engine current amount free memory mobile device less 20 total memory trigger ofoading ofoad enough program objects free least 40 mobile devices memory however simple approach cannot meet challenges adaptability congurability stability described section 11 ofoading inference engine addresses problem fuzzy control model 13 shown effective exible expressive stable coarsegrained application adaptations use approach ofoading inference engine novel applies model negrained application adaptation via runtime ofoading fuzzy control model includes 1 linguistic decisionmaking rules provided system application developers 2 membership functions 3 generic fuzzy inference engine based fuzzy logic theory based fuzzy control model ofoading inference engines ofoading rules specied lingvar availmem 08000 class low 0 0 800 900 class moderate 850 1500 4000 4200 class high 4150 5500 7500 8000 confidencelow moderate moderate high moderate high low 850 1500 4150 5500 7500 8000 available memory b figure 4 illustration membership function denition linguistic variable availmem availmem low availbw high newmemsize low availmem low availbw moderate newmemsize average availmem high availbw low newmemsize high availmem availbw variables input linguistic variables represent current available memory available wireless bandwidth respectively newmemsize variable output linguistic variable representing new memory utilization mobile device rules matched current system conditions ofoading inference engine triggers ofoading derives ofoading memory size using current memory consumption new memory utilization difference negative means program objects pulled back surrogate adapt low wireless bandwidth application developer user easily congure ofoading inference engine using linguistic ofoading rules however interpret linguistic ofoading rules ofoading inference engine needs establish mappings numerical linguistic values linguistic variable low moderate high called linguistic values fuzzy logic mapping numerical value linguistic variable linguistic values dened membership function example figure 4 shows membership function denition linguistic variable availmem figure 4 b gives graph representation corresponding membership function example numerical value availmem within range 0800 ofoading inference engines stochastic condence availmem belongs set linguistic value low 100 numerical value availmem within 800900 condence availmem belongs low linear decreasing function 100 0 intersection different linguistic values represents uncertainty stochastic condence result belong either linguistic value low moderate different condence probabilities membership functions provided application developer generic fuzzy inference engine implements fuzzylogicbased mapping nonlinear adaptation pro cess takes condence values fuzzy sets eg low average high inputs generates outputs form condence values fuzzy sets output variables eg newmemsize hence use generic fuzzy inference engine ofoading inference engine provides two functions fuzzication prepare input fuzzy sets generic fuzzy inference engine defuzzication convert output fuzzy sets actual ofoading decisions new memory utilization mobile device 32 application partition selection ofoading inference engine selects best application partitioning group candidate partition plans generated ofoading platform first ofoading inference engine considers target memory utilization mobile device rule partition plans meet minimum requirement ofoading inference engine selects best partitioning remaining candidate partition plans using composite partition cost metric case memory ofoading overcoming memory constraints mobile devices user multiple ofoading requirements minimizing wireless bandwidth overhead minimizing average response time stretch minimizing total execution time wireless bandwidth cost comes two factors 1 migration program objects ofoading 2 remote function calls remote data accesses average response time stretch decided total number remote invocations total execution time stretch caused ofoading includes migration delays remote interaction delays ofoading inference engine addresses problem comprehensively considering different interclass dependencies interactions application execution neighbor node vk vi use bik denote total amount data trafc transferred vi vk use fik dene total interaction number use msk represent memory size vk thus ofoading inference engine uses composite cost metric application execution graph edge vi vk ck bik fik msk 8 shown composite cost metric effective meeting different ofoading requirements partitioning cost candidate partition plan aggregated costs edges whose endpoints belong different partitions ofoading inference engine selects best partition plan minimizes partitioning cost suppose bmax fmax msmax represent upper bound possible bik fik msk dene comparison two cost metrics ck cl follows ck cl comparison equation implies ofoading inference engine always keeps java classes active ie larger bandwidth requirements interaction frequencies smaller memory sizes mobile device hand ofoading inference engine intends ofoad java classes isolated ie smaller bandwidth requirements interaction frequencies larger memory sizes surrogate allow customization use wi 1 represent importance ith factor eg wireless bandwidth remote interaction delay memory size java class making ofoading decision weights adaptively congured according application requirements user preferences example user cares interaction delay plentiful wireless bandwidth set w1 lower value w2 higher value 33 splitting large classes mentioned classes selected execution graph nodes however practice found memory size classes large treat class single node example string class javanote application occupied 59 mb execution ofoad large class cause large migration remote invocation overhead ofoad cannot meet memory constraint mobile device hence memory size java class exceeds certain threshold create new node execution graph represent class objects belonging large class distributed several parts represents node execution graph thus large class node split several nodes smaller memory sizes enable precise control memory ofoading tracedriven simulation experiments conduct tracedriven simulation experiments ibm thinkpad t22 running redhat linux 71 rst collect execution traces using three benchmark applications described table 1 execution trace les program description operation lifetime peak memory req dia java image editor open 180 kb picture image drag around 174 8949 kb biomer graphical molecular editor create three complex molecules 261 10668 kb javanote java text editor open 600 kb text le 268 7972 kb table 1 descriptions application suite used experiments record method invocations data eld accesses object creationsdeletions querying instrumented jvm use chaivm hps jvm embedded realtime systems experiments wireless network traces collected laptop ieee 80211 wavelan network card using ping system utility available bandwidth measurement tools 10 surrogate represented desktop sits ofce room mobile roaming scenario selected evaluation conducted computer science department building university illinois urbanachampaign wireless network trace obtained person mobile device start ofce room enter elevator ride basement exit elevator walk stairway measured wireless bandwidth maintains around 48 mbps person enters elevator drops 24 mbps rises 36 mbps person walks basement size parameters used function interactions data accesses quite small ie 64 bytes execution traces measure round trip time rtt small data packets 24 ms simulator driven execution network traces described simulator emulates remote interaction stretching total execution time remote data access delay time duration sending request remote site receiving requested data approximately equal rtt remote function call delay time duration redirect function request remote site close half rtt way migration delay simulated increasing execution time using equation memory classes migratedcurrent available bandwidth set java heap size 8 mb dia biomer 7 mb javanote according peak memory requirements shown table 1 consider three performance metrics 1 total ofoading delay consists migration delay remote data access delay remote function call delay delays extend total execution time application 2 average interaction stretch represents average interaction delay stretch caused remote data accesses remote function calls 3 total bandwidth requirement measured sum total size migrated objects total size parameters passed remote interactions finally compare inference time different approaches ofoading triggering ie using hardcoded simple rules fuzzy control comparison implemented common memory management heuristic algorithm least recently used lru lru algorithm adopts simple ofoading rule triggers ofoading available memory lower 5 total memory sets new target memory utilization 80 total memory application partitioning lru algorithm ofoads classes least recently used according accessfreq eld class enhance lru algorithm splitting large class nodes smaller ones memory sizes smaller 500 kb denoted splitclass next enhance splitclass algorithm replacing simple thresholdbased rules fuzzycontrolbased ofoading triggering denoted fuzzy trigger finally run complete ofoading inference engine algorithm partitioning selection using composite metric dened equation 1 weights wi 1 set equal use approach denote complete ofoading inference engine algorithm 8 reported performance comparisons composite simple metrics eg access frequency bandwidth requirement alone shown composite metric performs better simple metrics comparison ratio total offloading delay 10602lru splitclass fuzzy trigger approach different decisionmaking approaches figure 5 comparison total ofoading delay four different decisionmaking approaches1diabiomer javanote 040 comparison ratio average interaction stretch dia biomer javanote lru splitclass fuzzy trigger approach different decisionmaking approaches figure 6 comparison average interaction stretch four different decisionmaking approaches comparison ratio total bandwidth biomer javanote lru lrusplit fuzzy trigger approach different decisionmaking approaches figure 7 comparison total bandwidth requirement four different decisionmaking approaches execution time seconds3002001000 constrained memory memory offloading constrained memory javanote biomer applications figure 8 execution time two applications ofoading prototype rst compare total ofoading delay among four different decisionmaking approaches illustrated figure 5 comparison normalize delay value splitclass fuzzy trigger approach value lru algorithm results show splitting large classes reduce total ofoading delay much 60 compared simple lru algorithm compared splitclass algorithm uses simple triggering rules fuzzy trigger algorithm reduce total ofoading delay much 44 finally ofoading inference engine consistently achieves lowest ofoading delay three applications conduct similar comparative study two performance metrics average interaction stretch total bandwidth requirement illustrated figure 6 figure 7 respectively results show splitting large classes reduce average interaction stretch much 90 decrease bandwidth requirement much 54 compared lru algorithm compared splitclass uses simple triggering rule fuzzy trigger algorithm reduce average interaction stretch much 100 decrease bandwidth requirement much 47 compared fuzzy trigger approach reduce average interaction stretch much 62 decrease bandwidth requirement much 52 regard inference overhead fuzzycontrolbased ofoading inference requires twice inference time used simple thresholdbased triggering 006 ms 5 prototype experiments developed prototype distributed runtime ofoading system prototype provides simple working environment encapsulates functionality tracedriven simulator like simulator uses modied version hps chaivm monitor applications resources uses information partition applications prototype chaivm extended support transparent rpc introduced section 25 pdastyle mobile device emulated old 266 mhz hp laptop 11 mbps ieee 80211b pcmcia card operating shared network 733 mhz hp kayak pc workstation 128 mb memory used represent surrogate server surrogate attached 10mbps corporate wireless network using network switch leads access point machines run redhat linux 62 linux 2416 kernel use javanote biomer case study applications perform operations simulation study described table 1 investigate monitoring overhead evaluate javanote application running prototype singlesite mode performs monitoring using 8 mb java heap application execute without running memory compare reran conguration without monitoring enabled unoptimized implementation using hashedarrays shows monitoring overhead around 7 total execution time believe monitoring overhead reduced improving implementation system next evaluate additional memory footprint required ofoading platform virtual machine already maintains lot states need memory footprint growth mainly result application execution graph several runs javanote application observe 138 class creationdeletion events 11 million interaction events almost evenly divided function calls data accesses information recorded interactions two different classes includes total number interactions total number transferred bytes unoptimized implementation class node consumes bytes execution graph edge consumes 12 bytes equivalent memory footprint 15 kb javanote application believe amount storage acceptable system could optimized evaluate runtime performance memory ofoaded applications compare execution time javanote biomer ofoading prototype normal execution unmodied jvm first use prototype determine baseline memory allows application run completion successfully select smaller memory size emulate memory constraint javanote baseline memory 79 mb constrained memory 61 mb selected biomer baseline memory 107 mb constrained memory 8 mb selected simplicity prototype triggers ofoading available memory lower 5 total memory tries free 20 total memory ofoading figure 8 shows results experiment without ofoading constrained memory causes application crash heap becomes full bar shows time execution exited bars labelled small explosion symbols x indicate applications fail completion run enough heap applications take longer run processing better baseline comparison ofoaded run run ofoading constrained heap system runs 15 57 slower baseline heap size without ofoading increased execution cost difference improved performance borrowing memory surrogate minus cost monitoring performing remote accesses partitioning believe low performance cost well worth benet allowing applications execute normally rather crash insufcient memory 6 related work besides related work mentioned introduction work also related spectra project 4 proposed remote execution system mobile devices used pervasive computing spectra generate distributed execution plan balances competing goals performance energy conservation application quality puppeteer project 12 supports adaptations without modifying applications monet research group 7 proposed dynamic service composition distribution framework delivering componentbased applications pervasive computing support applicationspecic adaptation application developers provided metalevel programming tools deploying applications pervasive computing 9 18 3 however work assumes application already written componentbased fashion exported component interfaces system closely related work includes research work application partitioning coign 11 project proposed system statically partition binary applications built com components unlike coign approach performs dynamic runtime partitioning without offline proling furthermore assume componentbased applications written com components however approach without limitations first applications designed aware distributed execution error modes eg loss communication surrogate affect executions assumption wireless networking technologies ieee 80211 ultra wide band future provide fairly good communication coverage local areas second applications readily partitionable either tightly coupled eg hard split video codec badly written eg one large class le used rather objectoriented approach however believe large category applications fall corner cases provide good candidates partitioned ofoading 7 conclusion future directions presented adaptive ofoading system pervasive computing includes ofoading platform support ofoading inference engine adaptive ofoading system enables pervasive application delivery without degrading application delity incurring expensive application rewriting ofoading inference engine makes ofoading decisions without assuming prior knowledge applications execution systemnetwork conditions pervasive computing first address two decisionmaking problems runtime ofoading system namely adaptive ofoading triggering efcient partition selection second use fuzzy control model achieve adaptability congurability stability making negrained ofoading triggering decision third propose composite metric selecting efcient partition simultaneously satisfy multiple user requirements extensive tracedriven evaluations show ofoading inference engine runtime ofoading effectively relieve memory constraints mobile devices much lower overhead common approaches prototype experiments show execution memory overheads introduced adaptive ofoading system acceptable future research directions adaptive ofoading system include 1 applying ofoading approach relieving resource constraints mobile device constraints related cpu speed battery lifetime 2 supporting use multiple surrogates ofoading r jini network technology language compiler support adaptive distributed applications dynamic qosaware multimedia service conguration ubiquitous computing environments evaluation characterization available bandwidth probing techniques coign automatic distributed partitioning system controlbased middleware framework quality service adaptations towards distributed platform resourceconstrained devices system support mobile agile applicationaware adaptation mobility simple mincut algorithm programming framework qualityaware ubiquitous multimedia applications tr ctr shumao ou kun yang jie zhang effective offloading middleware pervasive services mobile devices pervasive mobile computing v3 n4 p362385 august 2007 kalasapur mohan kumar behrooz shirazi seamless service composition sesco pervasive environments proceedings first acm international workshop multimedia service composition november 1111 2005 hilton singapore lin zhong bin wei michael j sinclair smert energyefficient design multimedia messaging system mobile devices proceedings 43rd annual conference design automation july 2428 2006 san francisco ca usa
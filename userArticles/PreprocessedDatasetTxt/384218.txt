compiler design industrial network processor one important problem code generation embedded processors design efficient compilers asips application specific architectures paper outlines design c compiler industrial asip telecom applications target asip network processor special instructions bitlevel access data registers required packetoriented communication protocol processing practical viewpoint describe main challenges exploiting application specific features c compiler show compiler backend designed accomodates features means compiler intrinsics dedicated register allocator compiler fully operational first experimental results indicate clevel programming asip leads good code quality without need timeconsuming assembly programming b introduction use application specic instruction set processors asips embedded system design become quite com mon asips located standard otheshelf programmable processors custom asics hence asips represent frequently needed compromise high eciency asics low development eort associated standard processors cores tailored towards certain application areas asips still oer programmability hence high exibility debugging upgrading industrial examples asips tensilicas congurable xtensa risc processor 1 congurable gepard dsp core austria micro systems 2 like case standard processors compiler support asips desirable compilers urgently required avoid timeconsuming errorprone assembly programming embedded software fast timetomarket dependability requirements embedded systems met however due specialized architectures asips classical compiler technology often insucient fully exploiting processor capabilities demands dedicated code generation optimization techniques number code generation techniques intended meet high code quality demands embedded systems already developed include code generation irregular data paths 3 4 5 6 7 address code optimization dsps 8 9 10 11 exploitation multimedia instruction sets 12 13 14 shown experimentally highly machinespecic techniques promising approach generate highquality machine code whose quality often comes close handwritten assembly code naturally paid increased compilation times many cases partially impressive results achieved code optimization asips dsp area less emphasis far new important class asips bitserial protocol processing called network processors nps design nps motivated growing need new high bandwidth communication equipment networks eg internet routers ethernet adapters well telecommunication eg isdn xdsl corresponding communication protocols mostly employ bitstreamoriented data formats bitstreams consist packets dierent length ie variable length header packets typically longer payload pack ets typical packet processing requirements include decod ing compression encryption routing major system design problem area required high bandwidth leaves short time frame low nanoseconds processing bit packet arriving network node 15 even contemporary highend programmable processors hardly keep pace required realtime performance mention issue computational eciency eg respect power consumption several approaches asic design deal ecient bitlevel processing 16 shown narrow bitwidth operations detectable hardware runtime processor uses knowledge bitwidth operation either reduce power consumption increase performance furthermore possible identify significant number unused bits compile time according 17 38 computed signicant bits specint95 benchmarks discarded therefore ecient use hardware operations reduced bitwidth application specic processors might achieve reasonable saving hardware resources approaches 18 19 20 use information bitwidth operands reducing size datapath functional units recongurable processor solutions require highly application specic hard ware hand design hardwired asics frequently desirable due high design eort low exibility special class asips nps represent promising solution problem since instruction sets tailored towards ecient communication protocol processing advantage exemplied following since memories transmitters receivers normally show xed wordlength eg 8 16 bits relatively expensive processing may required sides using standard processors g 1 beginning communication packets transmitted typically aligned word boundaries transmitter storing words send buer packed bitstream format required network protocol transmission communication channel packets extracted receiver side align receiver wordlength may even dierent transmitter wordlength obviously data conversion overhead reduces benets bitstreamoriented protocol contrast nps may designed capable directly processing bit packets variable length ie form stored receive buer feature largely reduces data transport overhead nps relatively new semiconductor market standard chips eg intel ibm several inhouse designs see overview 15 also describes np development eorts stmicroelectronics paper focus specic machine inneon technologies network processor 21 ansi c compiler developed within industrial project design c compiler inneon np important goal order avoid timeconsuming assembly programming ensure relatively compilerfriendly architecture means processorcompiler codesign also observed 15 approach turns essential order avoid expensive compilerarchitecture mis network stream memory receive buffer transmitter memory send buffer receiver figure 1 communication via bitstreamoriented protocols match right beginning however ecient compiler design nps least challenging dsps since dedicated bitpacket oriented instructions easily generated highlevel language like c contrast approach taken 15 based retargetable flexware tool suite 22 decided develop nearly full custom compiler backend essentially motivated need incorporate c language extensions dedicated register allocator become clear later another approach related work valenc compiler 23 retargetable compiler allows specication arbitrary bitwidths c vari ables however direct support np applications purpose paper show complete c compiler advanced np architecture imple mented describe required new code generation techniques believe similar techniques also used np architectures growing compiler demand may expected future remainder paper structured follows section 2 inneon np architecture instruction set described detail section 3 outlines problems associated modeling bitlevel processing c lan guage next two sections describe actual compiler design coarsely subdivided frontend section backend section 5 components experimental results presented section 6 finally give conclusions mention directions future work 2 target architecture fig 2 shows overall architecture target machine inneon np 21 np core shows 16bit risclike basic architecture special extensions bitlevel data access principle illustrated g 3 np instruction set permits performing alu computations bit packets aligned proces code np core buffer io figure 2 inneon np architecture alu packet machine wordlength packet packet figure 3 processing variable length bit packets wordlength 2 packet may stored bit index subrange register packet may even span two dierent registers way protocol processing aligned required variable packet lengths instead xed machine wordlength however packetlevel addressing possible within registers within mem ory therefore partial bitstreams loaded memory registers processing alu take place g 4 register file memory alu figure 4 data layout memory registers bit packets aligned memory register wordlengths order enable packetlevel addressing unaligned data np instruction set permits specication osets operand lengths within registers shown gs 5 bit packet addressed means corresponding register number oset within register packet bit width oset plus width larger register wordlength 16 bits packet spans two registers without increasing access latency though especially feature challenging also standard processors intel i960 processor family support bitoriented data access however without corresponding arithmetic capabilities compiler designers viewpoint width argument result packets must identical one two argument registers also result location alu oper ation therefore two osets one width parameter per instruction sucient register number offset within register cmd reg1off reg2off width command assembly width operands figure 5 np assembly instruction format register n1 register n offset within registern n machine word size packet width figure packetlevel addressing within registers 3 bit packet processing c although possible description bit packetlevel addressing c language inconvenient since expressed means rather complex shift masking scheme example given g 7 shows fragment gsm speech compression algorithm imple mentation communications operating systems research group tu berlin pointer c used traverse array unaligned bit packets shown g 4 gsmbyte c word xmc8 figure 7 bit packet processing example gsm speech compression obviously convenient programming style situation becomes even worse case multiregister packets code readability thus maintainability poor furthermore masking constants generally make code highly machinedependent 31 use compilerknown functions outlined section 2 np instruction set allows avoid costly shift mask operations means special instructions packetlevel addressing c compiler bit packet manipulation made visible programmer means compilerknown functions ckfs compiler intrinsics compiler maps calls ckfs regular function calls xed instructions instruction sequences thus ckfs considered clevel macros without calling overhead ckf approach also used several c compilers dsps eg texas instruments c62xx using ckfs programmer still detailed knowledge underlying target processor readability code improved signicantly addition providing suitable set simulation functions ckfs c code written np longer machinedependent also compiled host machines debugging purposes illustrate use ckfs simple example consider case would like add constant 2 7bit wide packet stored bits 2 8 register denoted c variable standard c expressed means complex assignment follows standard processor would translate relatively large instruction sequence contrast np implement entire assignment within single instruction purpose introduce packet access pa ckf shown g 8 ckf directly ects packetlevel instructions illustrated gs 5 6 operator parameter selects operation eg add sub shift performed arguments v arname1 arname2 addition required intraregister osets packet bitwidth passed function pa ckf name operator name offset paint operator int varname1 int off1 int varname2 int off2 int packet width name result first operand name second operand offset packet second packet within first operand figure 8 format compilerknown function pa using function pa example expressed simply c follows int b papaadd 3 b 0 w7 pa add selecting add instruction w7 specifying bitwidth 7 dened constants c header le scalar variables b mapped registers assembly code register allocator 32 bit packet access loops exemplied ckfs provide elegant way reduce description eort bit packet processing c urgently ckfs required case bit packet ar rays indirectly accessed within loops avoid unacceptable quality compilergenerated code2 figure 9 array bit packets consider example g 9 process array 8 packets 10 bit length bit packet array turn stored array 5 16bit registers r0 r4 consequence bit packets aligned register wordlength packets even cross register boundaries suppose want compute sum bit packets within loop standard c would require code shown g 10 due unaligned bit packets register le pointer elem must incremented every loop iteration bit packet crosses register boundary therefore control code required within loop obviously highly undesirable respect code quality int a5 int sum aelem offset 0x03ff else sum aelemoffset aelem116offset 0x03ff offset 10 offset15 elem offset 16 figure 10 bit packet array access loop order avoid overhead np instruction set architecture provides means indirect access unaligned bit packet arrays via bit packet pointer register compiler exploit feature ckfs mod ied c code ckfs sum computation example given g 11 array declared attribute register attribute instructs compiler backend assign whole array register le contrast regular c compiler would store array like complex data structures memory concept register arrays required since np machine operations using packetlevel addressing work registers memory variables pr1 pr2 pointers operands ckf init introduced backend pointers bit packets backend uses knowledge pointer belongs elementarray life time analysis register allocation example pr2 used traverse dierent bit packets array constantly points sum variable number physical registers lower number simultaneously required register variables spill code inserted register allocator uses names pointer registers case identify register arrays loaded register le given indirect bit packet operation init ckf translates assembly code load constant register constant name register oset width bit packet pointer points en coded example g 11 pointer pr2 points rst element bit packet array name register bit packet located known register allocation therefore backend works symbolic addresses register allocation symbolic automatically replaced register allocation phase paiadd ckf single indirect addition like c expression p q backend creates single machine operation ckf order keep number ckfs low specify arithmetic operation rst parameter ckf instead dedicated ckf operation ckf inc denotes increment bit packet pointer like increment pointer ansi c pointer point next array element call inc np supports bit packet pointer arithmetic hard ware requires single machine instruction independent whether advancing pointer requires crossing register boundary obviously source code example specied low level programming style however programmer still gets signicant benet use compiler first permits use high level language constructs eg control code loops addition address generation register allocation performed compiler keeps code reusable saves lot development time 4 frontend design like compilers np c compiler subdivided frontend backend part frontend responsible source code analysis generation intermediate representation ir machineindependent optimiza register int a5 int pr1 pr2 int initpr1 sum 10 paiadd pr1 pr2 figure 11 bit packet array access ckfs tions backend maps machineindependent ir machinespecic assembly code see section 5 frontend use lance compiler system developed university dortmund 28 give brief description sake completeness lance machineindependent optimizing c frontend system includes backend interface retargeting dierent pro cessors however support automatic targeting current version lance v20 comprises following main components ansi c frontend c frontend analyzes c source code generates lowlevel three address code ir case syntax semantical errors c code error messages similar gnus gcc emit ted ir almost machineindependent bit width c data types memory alignment specied form conguration le library lance comprises c class library ir access analysis manipulation includes le io control data ow analysis symbol table main tenance modication ir statements addi tion auxiliary classes frequently required compiler tools lists sets stacks graphs optimization tools based ir library lance contains set common dragon book 29 machineindependent code optimizations constant fold ing dead code elimination well jump loop optimizations dependent required optimization level optimization tools called separately iterated via shell script since optimization tools operate ir format new optimizations plugged time backend interface backend interface transforms three address code ir data ow trees dfts maximum size dft represents piece computation c code comprises arguments oper ations storage locations well data dependencies generated dft format compatible code generator generator tools like iburg olive feature strongly facilitates retargeting new processors mainly distinguishes lance c frontends provided gcc 30 lcc 32 executable ir basic ir structure three address code consists assignments jumps branches labels return statements together corresponding symbol table information identiers three address code mainly serves facilitate implementation ir optimization tools since ir structure much simpler original c source language executability achieved dening ir low level assemblylike subset c language generated c frontend highlevel constructions eg loops switch ifthenelse statements replaced equivalent branch statement constructs addition implicit loads stores address arithmetic array structure accesses well type casts made explicit ir suif compiler system 31 similar c export facilities ir generate pure three address code int main static int a16 b16 c16 d16 register int register int register int figure 12 example c source code example c source code taken dspstone 33 fraction corresponding ir given gs 12 13 ir contains auxiliary variables labels inserted frontend local identiers assigned unique numerical sux seen ir still valid lowlevel c code compiled linked executed compiler host machine signicant advantage executable cbased particular context industrial compiler projects correctness important optimizations validation methodology sketched g 14 applied check correctness frontend part com piler key idea original c program ir compiled native c compiler host machine equivalence two executables checked means comparison outputs test input data dierence outputs indicates implementation error regression tests validation process easily automated although approach naturally cannot provide correctness proof ensures good fault coverage practice using representative suite c programs test inputs case used large heterogeneous set c applications including complex program packages like mp3 jpeg gsm bdd package gnu ex bison gzip static int statica316 staticb416 static int staticc516 staticd616 int main char t1t3 int t2t4 register int register int l3 return 0 figure 13 partial ir code c code g 12 vhdl parser 6502 c compiler validate c frontend ir optimizations well backend interface lance latter achieved exporting generated dfts c syntax helpful practical point view since nonexecutable ir formats cannot validated without processorspecic backends instructionset simula tors frequently slow crosssimulation runs nat urally validation machinespecic backends still requires instructionset simulation however frontend part typically contributes largest part total compiler source code compiler bugs may expected xed already phase 5 backend design c compiler backend subdivided code selection register allocation modules instruction scheduler original c source ir generation ir c source executable 1 executable 2 test input data output 1 output 2 comparison figure 14 frontend validation methodology implemented far code selector maps data ow trees generated lance frontend assembly instructions many compilers riscs phase innite number virtual registers assumed later folded available amount physical registers register allocator 51 code selection code selector uses widespread technique tree pattern matching dynamic programming 24 mapping data ow trees dfts assembly code basic idea approach represent target machine instruction set form costattributed tree grammar parsing given dft respect grammar result optimum derivation given cost metric hence optimal code selection obtained runtime complexity linear dft size tree parsing process visualized covering dft minimum set instruction pattern instances g 15 c b e c b e add mac b c mac add figure 15 visualization dftbased code selection data ow tree b instruction patterns c optimal tree cover implementation used olive tool extension iburg 25 contained spam compiler 26 generates code selector c source code given instruction set tree grammar respectively specifying instruction set olive convenient since tool permits attach action functions instruction patterns facilitates bookkeeping assembly code emission lance frontend splits c function set basic blocks contains ordered list dfts dfts directly generated format required olive passed generated code selector translated assembly code sequences one another phase also calls compilerknown functions ckfs detected directly transformed corresponding np assembly instructions step rather straightforward since ckfs simply identied name however code selector cooperation register allocator still responsible correct register mapping since ckfs called symbolic c variables instead register names result code selection phase symbolic assembly code references virtual registers code passed register allocator described following 52 register allocation although np shows risclike basic architecture classical graph coloring approach global register allocation 27 cannot directly used reason need handle register arrays explained section 3 see also gs 9 11 register arrays arise indirect addressing c programs unaligned bit packets traversed within loops consequence virtual registers containing fragments bit packet arrays assigned contiguous windows physical register le order achieve register allocator maintains two sets virtual registers one scalar values one register arrays virtual registers indexed unique number register arrays gets dedicated unique contiguous index range usual register allocation starts lifetime analysis virtual registers potential con icts form overlapping life ranges represented interference graph node represents virtual register edge denotes lifetime overlap lifetime analysis based defuse analysis virtual registers lifetime analysis special attention paid bit packets indirectly addressed via register pointers whose values might known compile time order ensure program correctness register array elements potentially pointed register pointer p assumed live p use liveness p determined inspecting pointer initializations calls compiler known function init see g 11 due allocation constraints imposed register ar rays mapping virtual registers physical registers based special multilevel graph coloring algorithm physical registers assigned virtual registers rst belong register arrays necessary since register arrays present higher pressure register allocator scalar registers first node set original interference graph belongs certain register array merged super node interference graph transformed superinterference graph sig deleting edges internal supernode scalar virtual register nodes incident edges g 16 next weight assigned supernode n equal number internal virtual registers n plus maximum number internal virtual registers ns neighbors sig supernodes mapped physical registers according descending weights heuristic motivated fact supernodes lower weight generally easier allocate cause less lifetime con icts furthermore case con ict cheaper spillreload smaller array instead larger one r1 r3 r4 figure construction sig example virtual register sets fr1 r2g fr3 r4 r5g supposed represent two register arrays r6 refers scalar variable supernode n r internal virtual registers contiguous range register le assigned since may multiple windows available certain point time selection range based best strategy order ensure tight packing register arrays register le ie order avoid many spills approach element register array accessed two dierent ways rst direct addressing eg a3 indirectly use bit packet pointer case insucient physical registers using indirect access spill code generated virtual registers within register array otherwise particular virtual register spilled register allocation symbolic addresses bit packets recalculated specify physical register within register le instead name virtual register size arrays bit packets restricted size register array therefore compiler needs reject code register allocation done note code would impossible nd equivalent assembly code even manually case encountered large register arrays control ow gives multiple denitions pointer variable multiple register arrays case possibly accessed register arrays must assumed live time therefore register le large enough hold simultaneously register allocation supernodes remaining virtual registers original interference graph mapped physical registers traditional graph coloring inserting spill code whenever required 6 results c compiler np described previous sections fully operational performance generated code measured means cycletrue np instruction set simulator set test programs mainly include arithmetic operations checksum computation bitstreams test programs relatively small due eort required rewrite source code compiler known functions ckfs may expected quality compilergenerated code largely depends clever use ckfs underlying register array concept using ckfs without specic knowledge application performance overhead compiled code may several hundred percent clearly acceptable intended application domain due massive increase register pres sure many register arrays simultaneously live naturally implies huge amount spill code case even using standard c programs without use ckfs might well result ecient code hand careful use ckfs derived detailed application knowledge generally leads small performance overhead order 10 observed overhead even reduced means instruction scheduling techniques reduce register lifetimes thereby spill code well peephole optimizations far implemented also interesting consider improvement oered ckfs compared regular c code table 1 shows performance six test routines specied c compiled np machine code columns 2 3 give performance clock cycles without ckfs register arrays enabled respectively column 4 shows performance gain percent without ckfs ckfs gain 43 29 33 prg4 853 639 25 prg5 103 81 21 prg6 156 106 table 1 experimental performance results use packetlevel addressing resulted average performance gain 28 standard c reference im plementations naturally mainly attributed np hardware however systemlevel perspective important prove performance gain also achieved means compiled c programs instead handwritten assembly code result evaluation believe introduction ckfs register arrays represents reasonable compromise programming eort code quality ckfs give programmer direct access dedicated instructions important optimizing hot spots c application program compiler still performs otherwise timeconsuming task register allocation noncritical program parts high performance bitlevel operations hardly issue productivity gain oered compiler versus assembly programming clearly compensates potential loss code quality 7 conclusions future work modern embedded systems frequently designed basis programmable asips allow high exibil ity ip reuse compiler support asip software development urgently required order avoid timeintensive assembly programming however special compiler backend techniques developed order make optimal use dedicated architectural features asips contribution outlined compiler challenges encountered network processors new class asips allow ecient protocol processing means packetlevel addressing described implementation c compiler representative industrial np main concepts compiler order make packetlevel addressing accessible c language level use compilerknown functions special register allocation technique experimental results indicate techniques work practice processor features well exploited although detailed implementation rather machinespecic believe main techniques easily ported similar forthcoming nps improved versions np c compiler already planned ongoing work deals gradually replacing pragmatic approach compilerknown functions sophisticated code selection techniques capable directly mapping complex bit masking operations single machine instruc tions enabled use special tree grammars model instruction set code selector addition plan include technique similar register pipelining 34 order reduce registermemory trac multiregister bit packets several peephole optimizations developed order close quality gap compiled code handwritten assembly code acknowledgments c compiler described paper developed informatik centrum dortmund icd inneon technologies ag munich whose project funding gratefully acknowledged required assembler simulator tools provided frank engel tu dresden authors would also like thank yue zhang contributed test compiler backend 8 r tensilica inc austria mikro systeme international asic automatic instruction code generation based trellis diagrams optimal code generation embedded memory nonhomogeneous register architectures code optimization techniques embedded dsp microprocessors con ict modeling instruction scheduling code generation inhouse dsp cores constraint driven code selection fixedpoint dsps optimizing stack frame accesses processors restricted addressing modes storage assignment decrease code size uniform optimization technique minimizing cost local variables access dsp processors compiling simd within register code selection media processors simd instructions exploiting superword level parallelism multimedia instruction sets perspective market requirements dynamically exploiting narrow width operands improve processor power performance hpca5 bitvalue inference detecting exploiting narrow bitwidth computations bitwidth analysis application silicon compilation coprocessor streaming multimedia acceleration new network processor architecture highspeed communications retargetable compilers embedded core processors language compiler optimizing datapath widths embedded systems engineering simple code optimization libraries retargetable compilation embedded digital signal processors register allocation via graph coloring code optimization techniques embedded processors stanford compiler group suif retargetable c compiler design implementation improving register allocation subscripted variables tr compilers principles techniques tools code generation using tree matching dynamic programming improving register allocation subscripted variables optimizing stack frame accesses processors restricted addressing modes engineering simple efficient codegenerator generator register allocation via graph coloring storage assignment decrease code size conflict modelling instruction scheduling code generation inhouse dsp cores code optimization techniques embedded dsp microprocessors optimal code generation embedded memory nonhomogeneous register architectures uniform optimization technique offset assignment problems piperench constraint driven code selection fixedpoint dsps minimizing cost local variables access dspprocessors code selection media processors simd instructions bidwidth analysis application silicon compilation exploiting superword level parallelism multimedia instruction sets network processors code optimization techniques embedded processors retargetable compilers embedded core processors retargetable c compiler piperench compiling simd within register bitvalue inference dynamically exploiting narrow width operands improve processor power performance code optimization libraries retargetable compilation embedded digital signal processors ctr xiaotong zhuang santosh pande effective thread management network processors compiler analysis acm sigplan notices v41 n7 july 2006 xiaotong zhuang santosh pande balancing register allocation across threads multithreaded network processor acm sigplan notices v39 n6 may 2004 jinhwan kim yunheung paek gangryung uh code optimizations vliwstyle network processing unit softwarepractice experience v34 n9 p847874 25 july 2004 jinhwan kim sungjoon jung yunheung paek gangryung uh experience retargetable compiler commercial network processor proceedings 2002 international conference compilers architecture synthesis embedded systems october 0811 2002 grenoble france sriraman tallam rajiv gupta bitwidth aware global register allocation acm sigplan notices v38 n1 p8596 january section instruction set extension arm embedded applications proceedings 2002 international conference compilers architecture synthesis embedded systems october 0811 2002 grenoble france bengu li rajiv gupta simple offset assignment presence subword data proceedings international conference compilers architecture synthesis embedded systems october 30november 01 2003 san jose california usa v krishna nandivada jens palsberg efficient spill code sdram proceedings international conference compilers architecture synthesis embedded systems october 30november 01 2003 san jose california usa chidamber kulkarni matthias gries christian sauer kurt keutzer programming challenges network processor deployment proceedings international conference compilers architecture synthesis embedded systems october 30november 01 2003 san jose california usa
graphbased data model ramifications abstractcurrently database researchers investigating new data models order remedy deficiences flat relational model applied nonbusiness applications herein concentrate recent graphbased data model called hypernode model single underlying data structure model hypernode digraph unique defining label present detail three components model namely data structure hypernode query update language called hnql provision enforcing integrity constraints first demonstrate said data model natural candidate formalising hypertext compare graphbased data models setbased data models also investigate expressive power hnql finally using hypernode model paradigm graphbased data modelling show bridge gap graphbased setbased data models computational cost done b introduction relational database management systems dbmss currently dominating commercial database marketplace flat relational model commonly known relational model advocated codd since early 1970s codd70 taken 20 years relational model attain present dominant position relational dbmss developed traditional business data processing applications mind banking payroll inventory control systems units data needed applications typically small simple flat structure furthermore operations performed units data relatively straightforward general involve making recursive inferences recent years growing demand use databases applications beyond traditional business applications computer aided software engineering case hypertext knowledge base systems computer aided design cad image processing scientific data satellite data analysis geographical data analysis applications levene department computer science university college london gower street london wc1e 6bt uk email address mleveneukacuclcs g loizou department computer science birkbeck college university london malet street london wc1e 7hx uk email address gloizouukacbbkcs units data typically larger complex traditional business applications ie complex objects whose structure may hierarchical may general digraph structure furthermore operations needed manipulate complex objects may straightforward define may involve making recursive inferences example consider storing vlsi chip layout database defining operations modifying testing chip another example consider library would like available online papers scientific journals particular subject area computer science task organising text included individual papers manner allows readers browse query text flexible manner task creating appropriate references papers cannot carried easily using relational model currently database researchers actively investigating new data models order able manage efficiently applications easily modelled using relational approach implementing prototype dbmss based new models two main categories new data models developed 1 setbased data models nested relational model leve92 pare89 thom86 vang88 extend traditional relational model 2 graphbased data models hypernode model leve90 presented herein build upon traditional hierarchical network data models ullm88 hereinafter concentrate graphbased data model namely hypernode model less research carried graphbased data models yet agreement within database community single graphbased data model contrast relational model nested relational counterpart extensively investigated provide adequate formalisms development setbased dbmss informally introduce three components hypernode model single underlying data structure hypernode model hypernode equation e n e digraph g unique defining label hypernode database finite set hypernodes fig 1 illustrate part simple hypernode database models simple airline reservation system hypernode whose defining label airlines contains defining labels hypernodes describe various airlines hypernode whose defining label passengers contains defining labels hypernodes describe booking information pertaining passengers hypernode defining label flies represents relationship telling us airline particular passenger flying note labels denoted strings beginning uppercase letter fig 2 show details passenger hypernodes note atomic values denoted strings surrounded double quotes attribute names strings beginning observe attribute name dependent passenger hypernode used reference passengers unspecified way depend example pass2 pass3 may depend pass1 drive airport references hypernodes viewed conceptually partof relationship alternatively encapsulating data represented referenced hypernodes use distinguished atomic value null indicate value exists unknown note also model incomplete information type value exist isolated attribute names example delete arc dependent null node null digraph hypernode whose defining label pass3 interpretation changes pass3 dependent unknown exist dependent pass3 fig 1 part passengers airlines hypernode database flies passengers ea ba da ai airlines ba ea da ai query update language alternatively database language hypernode model presented herein called hypernode query language hnql hnql consists basic set operators declarative querying updating hypernodes addition standard deterministic operators provide several nondeterministic operators cf abit90 arbitrarily choose member set examples need nondeterminism choosing arbitrary seat number passenger given flight choosing arbitrary referenced paper specific topic given set references hnql extended procedural style adding said set operators assignment construct sequential fig 2 passengers hypernode database ea121 21a null mary 12c ba212 sara 22b ea121 hanna 12d ba212 iris name dependent dependent name dependent name name dependent composition construct conditional construct making inferences finally loop loop constructs providing iteration equivalently recursion facilities finally equip hypernode model integrity constraint called hypernode functional dependency hfd hfds incorporate hypernode model functional dependencies fds relational model pare89 ullm88 using graphtheoretic formalism briefly overview ramifications hypernode model given detail paper demonstrate natural candidate formalising hypertext conk87 niel90 due support generalpurpose digraph constructor ability support navigation declarative querying via hnql go investigate expressive power hnql terms class transformations databases databases termed computable updates expressed hnql present two classes computable updates discuss expressive power hnql respect two classes finally using hypernode model paradigm graphbased data modelling show possible bridge gap graphbased setbased data models achieved transformation hypernodes nonwellfounded sets acze88 barw91 unfortunately transformation shown least hard testing isomorphism digraphs buck90 whose complexity general open problem gare79 rest paper organised follows section ii present three components hypernode model section iii show hypernode model provide underlying formalism hypertext section iv compare hypernode model graphbased data models setbased data models section v discuss expressive power hnql section vi show bridge gap graphbased setbased data models finally section vii give concluding remarks indicate research problems solved ii hypernode model section present hypernode model builds traditional graphbased models ie hierarchical network data models ullm88 particular section iia present single underlying data structure model namely hypernode section iib present query update language model ie hnql section iic show fds incorporated model form hfds hypernodes hypernode databases underlying data structure hypernode model hypernode used represent realworld objects begin recalling definition directed graph simply digraph buck90 digraph ordered pair n e n finite set nodes e set ordered pairs nodes n called arcs also known directed edges use following terminology digraph n e arc n e said incident two nodes n call n anchor destination also say n adjacent adjacent n indegree node n n number nodes adjacent n outdegree n number nodes adjacent n node incident arcs said isolated assume following two disjoint countable domains constants available firstly domain labels l whose elements denoted strings beginning uppercase letter excluding x since used denote variables secondly domain primitive nodes p partitioned two disjoint domains one atomic values av attribute names simply attributes denote atomic values strings surrounded double quotes attributes strings beginning also assume domain atomic values av contains distinguished value null meaning value exists unknown hypernode defined equation form e g l termed defining label hypernode simply label hypernode ambiguity arises n e digraph termed digraph hypernode simply digraph g n p l impose following syntactic restrictions arcs hypernode e1 indegree nodes n n ie nodes attributes zero e2 outdegree nodes n av n ie nodes atomic values zero ie anchor node arc label l n ie destination node arc also label order explain motivation behind restrictions take approach entityrelationship model chen76 asserts real world described entities objects case hypernodes turn represented set attributes values relationships entities observe arc set digraph viewed binary relation nodes incident arcs thus semantics restriction e1 attributes cannot range relation induced arc set furthermore arc whose anchor attribute represents attributevalue pair ie property whose destination node value value either atomic value label thus arc incident attribute attribute must anchor arc semantics restriction e2 atomic values cannot domain relation defined arc set thus arc incident atomic value value must destination arc finally semantics restriction e3 label domain relation defined arc set arc incident label represents relationship two hypernodes ie two objects thus relationship two hypernodes represented arc incident defining labels observe conceptually kind relationship viewed referential relationship see relational links dero89 easily verified hypernodes shown fig 1 fig 2 satisfy restrictions e1 e2 e3 discussed introduction hypernodes model part simple airline reservation system detailing information passengers indicating airline particular passenger flying note arc hypernode defining label flies fig 1 represents referential relationship arc passenger hypernodes fig 2 represents attributevalue pair hypernode database simply database say hd finite set hypernodes satisfying following three conditions two distinct hypernodes hd defining label h2 label say g node set digraph hypernode hd exists hypernode hd whose defining label g every attribute name meaning node sets digraphs hypernodes hd attribute name appears given database hd denote labelshd set labels appearing hypernodes hd primhd set primitive nodes appearing hypernodes hd atthd set attributes appearing hd ie primhd note condition h1 corresponds entity integrity requirement codd79 since hypernode viewed representing realworld entity objectoriented terminology kim90 labels unique serve systemwide object identifiers assuming hypernodes known system stored single database simi larly condition h2 corresponds referential integrity requirement codd79 since requires existing entities referenced implies relationship two hypernodes also represented terms reference one hypernode rather reference via arc two labels digraph hypernode observe conceptually kind relationship viewed partof relationship provides hypernode model inherent support data encapsulation see inclusion links dero89 condition h3 corresponds universal relation schema assumption originating universal relation model leve92 maie84 example attribute title means title document cannot also mean title author document note condition h3 always enforced renaming attributes conflict arise example could attribute dtitle meaning title document attri bute atitle meaning title author document easily verified hypernodes shown fig 1 fig 2 comprise portion hypernode database add hypernodes pass5 pass6 ea ba da ai whose node sets include new labels would database satisfying conditions h1 h2 h3 note condition h1 hypernode representing one objects database unique label furthermore defining labels passenger hypernodes partof hypernode defining label passengers thus condition h2 must one hypernode database passenger finally note condition h3 attribute included passenger hypernodes shown fig 2 plays unique role hypernode accessibility graph hag hypernode e hd simply hag g whenever hd understood context digraph telling us hypernodes hd partof encapsulated hypernode defining label g considering partof transitive relationship cf composite objects kim90 formally define hag g denoted n g e g minimal digraph constructed hypernodes hd follows 1 g n g g distinguished node called root n g e g 2 g n g g n e hd hypernode must exist condition h2 note general hag g may cyclic fig 3 illustrate hag pass1 hypernode defining label pass1 shown fig 2 note hag pass1 cyclic thus pass4 partof pass1 pass1 partof pass4 indicating pass1 pass4 depend fig 3 hag pass1 order simplify presentation assume hypernodes untyped ie put constraints structure hypernodes thus hypernodes dynamic sense nodes arcs hypernodes updated subject restric tions approach classify entities according entity set belong rather consider entities classless ullm91 cf rich91 ie belonging single set entities particular available hypernodes members single database types give us means defining database schemas enforcing constraints structure content hypernodes extension hypernode model deal typed hypernodes typed databases found poul92 b query update language hypernodes introduce query update language hypernode model called query language hnql hnql consists basic set operators declarative querying updating hypernodes hnql extended procedural style adding basic set operators assignment construct sequential composition construct conditional construct making inferences finally loop loop constructs providing iteration equivalently recursion facilities apropos hnql assume countable domain variables v available v denote variables strings beginning uppercase letters x variables hnql untyped ie values range union domains primitive nodes labels assume hd hypernode database operators define evaluated respect hd also assume label null labelshd reserved order return error code necessary notationally use strings beginning lowercase letter v denote either label primitive node strings beginning uppercase letter g denote labels following four operators update hypernodes database hd 1 insertnodeg v returns g e hd side effect v inserted n ie n n v otherwise null returned 2 deletenodeg v returns g e hd v n arc v v e v v e side effect v deleted n ie n n v otherwise null returned e hd v 1 v 2 n side effect e hd v 1 side effect deleted e ie e following two operators add remove hypernodes database hd 1 create returns arbitrary new label g g labelshd null side effect added hd ie hd hd 2 destroyg returns label g g hd hypernode g n e hd true g n side effect removed hd ie hd following five predicates provide membership tests node arc contained given hypernode defining label hypernode database hd digraph hypernode contain given node given arc returns true e hd v n otherwise false returned returns true e hd v 1 false returned returns true e hd otherwise false returned returns true e hd v n otherwise false returned returns true e hd v 1 false returned also allow two equality tests return true false case may define simple condition either membership test equality test condition defined either simple condition parenthesising condition used grouping purposes negation condition say cond denoted cond conjunction two con ditions say cond 1 cond 2 denoted cond 1 cond 2 following five nondeterministic operators used arbitrarily choose node arc contained given hypernode arbitrarily choose defining label hypernode database hd one containing given node given arc 1 anynodeg returns arbitrary node v n e hd n otherwise null returned 2 anyarcg returns arbitrary arc v 1 e hd e otherwise null null returned 3 anylabel returns arbitrary label g e hd hd otherwise null returned returns arbitrary label g e hd v n otherwise null returned returns arbitrary label g e hd null returned hereafter assume variables hnql current value either label primitive node always initialised value null thus extend earlier notation allow strings beginning letters v g denote current value variable appropriate define assignment statement expression lvalue rvalue lvalue variable pair variables rvalue constant variable possible pairs two one hnql operators defined far semantics assignment statement current value lvalue becomes result evaluating rvalue current state hypernode database hd possibly updating hd side effect note evaluating constant hd returns constant evaluating variable hd returns current value assume assignment undefined example trying assign pair constants variable constant pair variables lvalue assigned value null null null respec tively consistent standard destructive assignment imperative programming languages pascal jens85 defining value variable statements assignment statements one kinds statements defined subsequently composed sequentially using statement separator use keywords transaction begin transaction end delimit compound statements analogy begin end keywords used pascal convenience may omit statement contains single statement note since compound statement statement nesting compound statements made possible compound statment shown fig 4 deletes arc dependent null node null hypernode defining label pass3 inserts node pass5 arc dependent pass5 hypernode finally arbitrary arc deleted hypernode defining label flies syntax conditional statement defined follows condition compound statement semantics conditional statement condition evaluates true current state database hd compound statement executed current state hd hand condition evaluates false compound statement executed conditional statement shown fig 5 deletes arc dependent null node null hypernode defining label pass3 inserts node pass2 arc dependent pass2 pass2 pass3 flying flightno ea121 pass2 already dependent pass3 fig 4 example compound statement fig 5 example statement next define two types loop loops give us bounded looping construct loops give us unbounded looping construct chan88 syntax loop defined follows forall forpredicate compound statement forpredicate one following five membership testing predicates x nodesg semantics loop described firstly forpredicate evaluated current state database hd prior execution loop evaluation effected possible substitution variables forpredicate values thereafter compound statement executed synchronously parallel current state hd time forpredicate evaluates true evaluation indicated note semantics compound statement executed parallel statements comprise compound statement also executed synchronously parallel observe compound statement always executed finite number times ie looping bounded loop shown fig 6 modifies flight number ba212 ba345 passengers database syntax loop defined follows changes compound statement y1 fig 6 example loop semantics loop compound statement repeatedly executed current state database hd changes effected current state hd compound statement executed fixpoint attained observe gen eral loop may terminate since fixpoint may attainable ie number times compound statement executed may unbounded loop shown fig 7 transitively closes digraph hypernode e note omitted tb te since loop comprises single statement hnql program defined compound statement terminated fullstop ie sequential composition one kinds statements including compound statement hnql program shown fig 8 oscillates updating digraph hypernode e irreflexive updating reflexive note program terminate changes forall x1 x2 arcsg fig 7 example loop changes x1 x1 arcsg x1 x1 arcsg te fig 8 example hnql program c hypernode functional dependencies functional dependencies fds far common integrity constraint real world pare89 ullm88 notion key derived given set fds codd79 fundamental relational model fds also extended nested relations leve92 thom86 vang88 essentially allowing attribute domains relationvalued ie nested relations fds capable modelling singlevalued multivalued data dependencies leve91 shown extended fds naturally incorporated hypergraphbased data model precursor hypernode model fds also incorporated graphbased model good gyss90 form functional multivalued arcs finally general type fd called path fd pfd defined wedd92 objectoriented data model wherein class schemas instances thereof interpreted digraphs sound complete axiomatisation pfds exhibited also shown general schema cyclic may infinite number derived pfds show concept fds incorporated hypernode model using graphtheoretic formalism recall subgraph n e n e digraph n n e e induced subgraph n e node set denoted induceds n e maximal subgraph n e whose node set buck90 let hd hypernode database e hd n atthd denote adja set attributes together set nodes n adjacent node n next give definition fd hd informally set attributes atthd functionally determines another set attributes b atthd attribute b b whenever induced subgraphs node set adja two digraphs hypernodes hd equal corresponding induced subgraphs node set adjb two digraphs also equal formally let b atthd two sets attributes hypernode functional dependency hfd b satisfied hd b b every pair necessarily distinct hypernodes g also case example hfd holding simple airline reservation database hfd asserts passengers seat number flight number uniquely determine name dependents easily verified passenger hypernodes fig 2 satisfy hfd following assume atthd fixed set attributes u hypernode database hd f set hfds b single hfd denote fact database hd satisfies f respectively b hd f respectively hd b say f logically implies b respect class hypernode databases denoted f b every hypernode database hd given class hd f hd b axiom system hfds given class hypernode databases set inference rules used derive hfds given set f hfds denote f b fact either b f b inferred f using one inference rules given axiom system hfds define closure set attributes respect f denoted set attributes b f b finally axiom system sound f b implies f b complete f b implies f b define axiom system hfds respect class hypernode databases r1 reflexivity b u f b r4 decomposition f b b b f b observe transitivity rule ie f b f sound fds respect relational databases sound inference rule hfds consider following counterexample let hd database shown fig 9 c denote pairwise disjoint sets attributes easily verified hd hd c hd c fig 9 hypernode database satisfying c c g1 g2 g3 1 1 1 0 theorem 1 axiom system comprising inference rules r1r4 sound complete class hypernode databases proof see appendix note axiom system comprising r1r4 also shown sound complete fds respect class relational databases single unmarked null value lien82 implies within hypernode model capture semantics incomplete information proposed lien82 without explicitly storing missing information database semantics fit well nulls type value exist modelled isolated attribute names see section next show condition h1 asserts uniqueness defining label every hypernode database hd used explicitly define concept key hypernode model let id distinguished attribute id primhd assume hnql program shown fig 10 enhances hd adding hypernode say e database arc id g call resulting database enhanced obviously class enhanced databases proper subset class hypernode databases insertnodex id insertnodex x insertarcx id x te fig 10 hnql program enhance hypernode database add following two inference rules axiom system hfds theorem 2 axiom system comprising inference rules r1r6 sound complete class enhanced databases proof see appendix iii hypernode model underlying hypertext conk87 niel90 text read nonsequentially contrast traditional text example book form single linear sequence defining order text read hypertext presents several different options readers individual reader chooses particular sequence time reading hypertext database known network hypertext terminology digraph tomp89 directed hypergraph con sidered whose nodes represent units information whose arcs known links hypertext terminology allow reader navigate anchor node destination node context paper consider textual units information general hypertext databases integrate system multimedia data types graphics sound video activity navigating within hypertext database traversing links examining text associated destination nodes called browsing pointed hala88 browsing provide sufficient access hypertext database since database may complex digraph structure rendering navigation difficult may cause readers get lost hyper space conk87 niel90 ie readers may know andor know get position network therefore declarative querying searching facilities needed order complement browsing querying done via structure digraph using query language graphlog suggested cons89 searching done textual content using fulltext retrieval techniques hypernode model possesses number features make natural candidate formal model hypertext firstly hypernode digraph structure two builtin link types first link type arc representing referential relationship second link type encapsulated label representing partof relationship furthermore attributes allow us give additional semantics nodes fact hypernodes model arbitrary complex objects order support text directly assume domain atomic values actually domain textual fragments fulltext retrieval operations possible fig 11 show part hypertext database called papers stores online papers scientific journals particular figure shows overview diagram niel90 papers adjacent pap1 ie pap7 pap3 adjacent pap1 ie pap11 pap4 pap15 assume pap1 currently browsed hypernodes encapsulated in1 in2 out1 out2 out3 annotations links niel90 annotation link provides additional information link name creator link date created subject matter link see fig 12 details annotation out1 addition annotation out1 fig 12 shows hypernode pap1 currently browsed two encapsulated hypernodes auth1 showing details one authors paper contains actual text paper secondly hypernode model provide browsing declarative querying facilities via hnql hnql also cater authoring niel90 via update facilities finally within context hypernode model reason integrity constraints see section iic hypertext database summary view hypertext promising application hypernode model iv comparison hypernode model comparison graphbased data models fig 11 part hypertext database out3 briefly compare hypernode model recent graphbased data models respect data modelling capabilities particular deal logical data model ldm kupe84 good glog gyss90 pare91 graphlog cons90 graphbased data models database consists single digraph hypernode database consists finite set digraphs unique feature hypernode model permits data encapsulation ability represent realworld object database separately ldm database schemas represented digraphs instances represented twocolumn tables associates entities particular type either primitive type tuple type set type corresponding values hypernode model single data structure ie digraph shown leve90 ability types good glog ldm separation database schema database instance hypernode model presented herein separation since hypernodes untyped advantage changes database dynamic hand disadvantage typing constraints cannot imposed database unlike good glog graphlog label arcs hypernode model ever attain data modelling expressiveness including arcs label good glog graphlog digraph within arc set single hypernode hypernodes generalise graphs various semantic data models example hierarchical network number data models graphs formed foundation fig 12 hypernodes hypertext database london ucl levene address college name text author abstract title hypernode model creator date subject jbloggs 22492 hypertext whose defining label label example represent set labelled arcs hypernode next briefly compare hypernode model objectoriented data models kim90 respect data modelling capabilities typically objectoriented data models support tuple set list data constructors used define type object object unique object identity belongs one class class object defines structure behaviour ie type methods responds hypernode model supports single generalpurpose digraph constructor mentioned ability represent tuple set list constructors hypernodes provided object identity via unique labels support classes hypernode model since hypernodes untyped furthermore support methods hypernode model since generalpurpose database language ie hnql allows us directly pose database query update definable hnql noted ullm91 generalpurpose database language essential database applications scientific market applications see tsur91 details applications large variety queries updates cannot always planned advance may posed database b comparison setbased data models setbased data models relational model codd70 parer89 ullm88 nested relational model leve92 pare89 thom86 vang88 valuebased tuples relations respectively nested relations identified solely attribute values hand graphbased data models hypernode model objectbased ie hypernodes identified unique labels serve systemwide object identifiers ullm88 argued query update languages valuebased data models general declarative objectbased data models example ullm91 shown consequence attaching object identity path buck90 digraph may cause undesirable sideeffects particular trying generate set paths digraph may mistakenly generate set walks buck90 since different walks induced path different object identities digraph cyclic infinite number walks ie objects generated furthermore interested reachability relation nodes digraph generating walks first obviously ineffective although declarativeness generally desirable firmly believe navigational features supported languages graphbased data models hypernode model necessary certain applications hypertext furthermore claim need loss data independence objectbased data models thus query update languages need less declarative valuebased data models substantiate claim reference model follows unique labels hypernodes system generated via operator create machineindependent allow portabil ity therefore internal values hidden users order overcome prob lem unique meaningful aliases used conceptual level database order identify defining labels hypernodes demonstrated throughout paper close section brief mention integrity constraints graphbased setbased data models section iic showed fds incorporated hypernode model order theory comprehensive need extend results include kinds integrity constraint inclusion dependencies vard88 used enforce referential integrity constraints context relational model plethora data dependencies described vard88 would pity tap wealth ideas investigating data dependencies graphbased data models leuc91 step taken direction reconstructing tuple equality generating dependencies vard88 graphtheoretic setting context objectoriented data model pfds mentioned section iic generalised path constraints cobu91 also assert equations typing constraints v expressive power hnql fundamental measure expressive power query update language class transformations databases databases termed computable updates language express cannot use directly standard notion turing computable mapping strings strings define said class two reasons firstly database domains normally abstract thus builtin ordering called genericity requirement chan80 genericity requirement called consistency criterion example domains l p hypernode model abstract domains thus uninterpreted respect ordering defined secondly may introduce nondeterminism database language two ways 1 allowing creation new objects arbitrarily chosen object identifiers using create operator hnql defined section iib 2 introducing explicit nondeterministic operators language via five nondeterministic operators hnql also defined section iib nondeterminism introduced 1 motivated fact internal values object identifiers hidden users therefore least users point view generation nondeterministic hand nondeterminism introduced 2 motivated need answer queries choose arbitrary seat number passenger given flight choose arbitrary referenced paper specific topic given set references result define two classes computable updates generic computable updates cater genericity requirement arbitraryorder computable updates cater nondeterminism introduced 1 2 show former class special case latter class investigate expressiveness hnql respect class arbitraryorder computable updates first introduce useful notation following let hd database p isomorphism l p w w set natural numbers p 1 inverse p turing computable mapping strings strings next define certain auxiliary operators used sequel 1 encodephd returns standard encoding gare79 say se phd note p preserves adjacency digraphs hypernodes hd returns database p 1 ise ise result computing inverse standard encoding se output encode operator 3 dse denotes result computing via turing machine computes input se observe p necessary defining encode decode since set represented string elements set need ordered gare79 ready formalise notion computable update mapping databases databases computable update exists turing computable mapping strings strings isomorphism p query update language update complete respect class computable updates expresses computable updates class observe context query considered special case update since always put result query distinguished hypernode remove hypernode database user inspected contents generic computable updates introduce notion generic computable update computable update generic commutes every isomorphism r maps primitive nodes primitive nodes labels labels ie database hd trhd note abit90 general definition genericity considered finite set c constants primitive nodes case hypernode model may appear query update mapped herein simplicity assumed c empty set note genericity consequence requirement database provide high degree data independence due fact data independence requires computable update independent internal representation data particular ordering imposed underlying domains physical level database known conceptual level ordering affect result given update b arbitraryorder computable updates generic computable updates allow us express certain computable updates choose member set since update generic noted abit89 update easily expressed presence total ordering underlying domains since treat set ordered list without duplicate elements alternatively allow sort update expressed introducing nondeterministic operators nondeterministic operators hnql permit us choose member set introducing arbitrary order members set cf cut operator prolog cloc81 choice predicate ldl naqv89 next define class computable updates takes account added expressiveness nondeterministic operators hnql investigate expressive power hnql respect said class computable updates binary relation databases databases arbitraryorder computable update simply ao computable update computable update choice p used computing observe definition ao computable update may hd hd1 hd hd2 resulting two different choices p say p 1 p 2 note l p fixed natural ordering always used computing definition ao computable update would degenerate definition computable update since one choice p would ever used note general definition ao computable update weaker definition computable update sense assume given choice p priori available computing following lemma shows generic computable updates special case ao computable updates lemma 3 generic computable update independent choice p used computing proof see appendix hnqls nondeterministic operators including create operator interpreted ao computable updates must behave deterministically choice p made formalise approach defining semantics hnqls nondeterministic operators let set l p make assumption internal structure define following three auxiliary operators 1 members returns arbitrary member 2 lists p returns list resulting imposing ordering p set 3 firstl returns first element list l next formalise notion returns arbitrary member replacing definition members 1 given choice p thus replaced choice arbitrary member definition members choice arbitrary ordering imposed given choice p returned value members first element chosen ordering make assumption hnql program say prog may contain nondeterministic operators evaluated utilise making particular choice p prior evaluation prog nondeterministic hnql operator prog returns arbitrary member may node arc label given set say used particular choice p order compute returned value members call assumption respect operational semantics hnqls nondeterministic operators assumption note create operator also utilise assumption returning least label present labelshd hd current state hd according ordering imposed choice p illustrate deterministic behaviour resulting assumption simple example let assume simple hnql program shown fig 13 executed respect hd deletenodeg x te fig 13 simple hnql program program executed current state hd either depending whether choice p induces ready state main result section characterises expressiveness hnql given assumption operational semantics nondeterministic operators hnql theorem 4 given assumption hnql update complete respect class ao computable updates proof see appendix abit90 nondeterministic computable update called nondeterministic database transformation therein binary relation databases databases generic recursively enumerable although approach semantically clean provide us operational semantics nondeterminism since due genericity mechanism decide output choose query update given set possible outputs hand ao computable updates provide us clean operational semantics non determinism since choice p assumption made example using physical layout database since layout changes time result query update appear user nondeterministic discussion computable updates see abit89 abit90 chan80 chan88 hull90 hull91 naqv89 vi bridging gap graphbased setbased section endeavour bridge gap graphbased setbased data models considering transformation one first define important notions copy copy elimination two hypernode databases defined copies equal exists isomorphism one maps primitive nodes ie identity mapping p labels labels intuitively means two databases modelling exactly set objects hypernode database copies database two subsets consisting hypernodes copies finally operation copy elimination operation replacing database copies maximal subset database without copies ie operation removing duplicate copies observe copy elimination performed easily hnql since arbitrarily retain one copies duplicates remove others discussion copy elimination see since setbased data model viewed special case graphbased data model ie one database always without copies need consider transforming graphbased setbased data models would straightforward graphbased data models builtin copy elimination operator would invoked database query update computed use model demonstrate said transfor mation effect would like hypernode model behave like setbased data model involves solving two problems first problem find suitable setbased formalism hypernode model behaves like formalism second problem devise transformation hypernode model suitable setbased formalism suggest nonwellfounded sets acze88 also called hypersets barw91 solution first two problems hypersets subsume wellfounded sets dropping requirement sets hierarchical structure thus allowing us model various kinds circular phenomena whereby set may contain shown acze88 certain systems equations unique solutions universe hyperests hyperset viewed unique solution system equations important result called solution lemma consequence solution lemma define hyperrelations unique solutions set hypernodes viewed set equations whose indeterminates constitute set unique defining labels hypernode database hd interpretation allow us transform model valuebased data model thus solving second problem although solution appealing theoretically practice faced problem copy elimination ie solution two different defining labels hyperrelation detected computational cost words test equality two hyperrelations show hypernode model solving problem least hard testing isomorphism digraphs buck90 whose complexity general open problem note subgraph isomorphism problem npcomplete gare79 briefly describe two isomorphism tests local test global test used solve copy elimination hypernode model order check whether two hypernodes locally isomorphic restrict mapping realising isomorphism primitive nodes map ie identity mapping p labels map labels label g 1 maps label g 2 example consider following three hypernodes first hypernode locally isomorphic second hypernode locally isomorphic third hypernode since case g 1 would mapped g 3 g 4 observe local test general sufficient considering isomorphism two hypernodes database since condition h2 may violated one isomorphic hypernodes removed database example consider following four hypernodes first hypernode locally isomorphic second hypernode third hypernode locally isomorphic fourth hypernode since iris cannot map robert furthermore eliminate one first two hypernodes either third fourth hypernode lose parent result global isomorphism test devised taking account hypernode accessibility graphs hags two hypernodes consideration order test whether two hypernodes defining labels g 1 g 2 globally isomorphic use following algorithm first test whether hags g 1 g 2 isomorphic g 1 maps answer test fails otherwise answer yes let r onetoone mapping verifies isomorphism test node g node set hag g 1 whether hypernode whose defining label g locally isomorphic hypernode whose defining label rg local tests succeed global isomorphism test succeeds otherwise fails example following two digraphs respectively hags g 1 g 2 shown easily verified hags indeed isomorphic g 1 maps g 2 finally hypernode defined g 1 globally isomorphic hypernode defined g 2 since shown hypernode defined g 3 locally isomorphic hypernode defined g 4 vii concluding remarks research presented three components hypernode model detail single underlying data structure hypernode query update language hnql integrity constraints form hfds also presented hypertext natural application hypernode model compared model graphbased data models setbased data models finally using model example demonstrated hypersets used bridge gap graphbased setbased data models achieved cost testing isomorphism digraphs whose complexity general open problem practical point view may imply one bridge gap hierarchical databases ie digraphs hypernodes database trees since testing isomorphism trees solved polynomial time gare79 advantage graphbased database formalisms important next generation database systems considerably enhance usability complex systems hare88 particular graphbased formalisms encourage graphical user interfaces list topics demand attention utilising wealth algorithmic graph theory order incorporate hnql specialpurpose operators solve particular distancerelated problems finding shortest distance path two nodes developing higher level database language hypernode model top hnql step direction logicbased language hyperlog discussed leve90 poul92 developing ideas formal model hypertext close briefly mentioning first prototype storage manager hypernode model already implemented tuv92 storage manager set modules carrying manipulation digraphs persistent store caters object identity referential integrity hypernodes storage large dynamic hypernodes clustering strategies secondary storage retrieval operations utilise indexing techniques also supports basic set operators hnql excluding nondeterministic operators proof easily shown axiom system comprising r1r4 sound order prove completeness need show f b f b equivalently latter exhibit database say ex ex f ex b let ex database shown fig 9 c denote pairwise disjoint sets attributes first show ex f suppose contrary ex f thus exists f ex v w follows construction ex v c c follows f w r4 follows f c leads contradiction since follows c conclude proof showing ex b suppose contrary ex construction ex fore b b f b r3 follows f b leads contradic tion since derived f b proof observe identity inference rule r5 consequence condition h1 thus sound cf simple attribution rule wedd92 furthermore key inference rule r6 consequence fact f id superkey ie superset key every enhanced database satisfying f sound two observations theorem 1 follows axiom system comprising r1r6 sound order prove completeness need show f b f b equivalently latter exhibit enhanced database say exe exe f exe b let exe enhanced database shown fig 14 c id denote pairwise disjoint sets attributes fig 14 enhanced database satisfying f b g3 0 id g3 1 id g2 id 1 1 first show exe f suppose contrary ex f thus exists f exe v w follows construction exe v either c w c c first case result follows proof theorem 1 assume id w r4 follows f id using r6 deduce c f c leads contradiction since follows c proof exe b similar proof theorem 1 note construction exe id otherwise would allowed us derive f b r5 proof lemma 3 proof let turing computable mapping used compute thd let denote composition independent choice p used computing trhd required assume independent choice p exist least two choices p say p 1 p 2 follows either assume assume without loss generality isomorphism r maps primitive nodes primitive nodes labels labels definition r therefore follows encodep 1 se result turing machine computation hence follows using genericity requirement since thus since r concludes proof since also case thus leading contradiction proof let hnql det denote subset hnql without nondeterministic operators easily shown updates expressed hnql det fact generic computable updates thus lemma 3 updates expressed hnql det also ao computable updates assumption hnqls nondeterministic operators become ao computable updates thus since choice p made prior evaluation given hnql program follows structural induction constructs hnql programs hnql expresses ao computable updates order conclude proof need show hnql express ao computable updates let ao computable update immediate definition nondeterministic operators hnql given choice p say p generated hnql observe current state hd say hd p need defined primhd labelshd let turing computable mapping used compute thd p isomorphism used definition computable update next need show simulated hnql firstly encodephd simulated hnql using standard encoding scheme gare79 example result encoding hypernode ignoring p sake brevity shown fig 15 secondly dse simulated hnql since hnql capable simulating working turing machine realised using certain results given fig 15 example encoding hypernode end node edge node g begin leve90 finally decodep1 dse simulated hnql defining hnql inverse mapping encode operator leave remaining technical details proof reader techniques used similar used abit89 abit90 chan80 prove update completeness acknowledgement work mark levene funded grant grg26662 uk science engineering research council would like thank alexandra poulovassilis joint work hypernode model r object identity query language primitive procedural languages database queries updates hypersets distance graphs computable queries relational data bases theory database queries entityrelationship model towards unified view data programming prolog path constraints graphbased data models towards unified theory typing constraints equations functional dependencies relational model data large shared data banks extending database relational model capture meaning introduction survey expressing structural hypertext queries graphlog visual formalism real life recursion expanding notion links computers intractability guide theory npcompleteness graphoriented object database model reflections notecards seven issues next generation hypermedia systems visual formalisms ilog declarative creation manipulation object identifiers expressive power database queries intermediate types germany springerverlag new approach database logic equivalence database models nested universal relation database model hypernode model associated query language objectoriented data model formalised hypergraphs agreement graph dependencies foundations universal relation model logical language data knowledge bases structure relational database model glog declarative graphical query language nestedgraph model representation manipulation complex objects aspects extending objects support multiple independent roles data model flexible hypertext database systems nested relational structures deductive databases action storage manager hypernode model principles database knowledgebase systems comparison deductive objectoriented database sys tems multilevel nested relational structures fundamentals dependency theory reasoning functional dependencies generalized semantic data models tr ctr ivan radev niki pissinou kia makki e k park graphbased objectoriented approach structural behavioral representation multimedia data proceedings eighth international conference information knowledge management p522530 november 0206 1999 kansas city missouri united states mark levene alexandra poulovassilis kerima benkerimi sara schwartz eran tuv implementation graphbased data model complex objects acm sigmod record v22 n4 p2631 dec 1993 sankhayan choudhury nabendu chaki swapan bhattacharya gdm new graph based data model using functional abstractionx journal computer science technology v21 n3 p430438 may 2006 avigdor gal opher etzion multiagent update process database temporal data dependencies schema versioning ieee transactions knowledge data engineering v10 n1 p2137 january 1998
inheritancebased technique building simulation proofs incrementally paper presents technique incrementally constructing safety specifications abstract algorithm descriptions simulation proofs showing algorithms meet specificationsthe technique building specifications algorithms allows child specification algorithm inherit parent two forms incremental modification interface extension new forms interaction added parents interface b specialization subtyping new data restrictions effects added parents behavior description combination interface extension specialization constitutes powerful expressive incremental modification mechanism describing changes override behavior parent although may introduce new behaviorconsider case incremental modification applied parent specification parent algorithm proof child algorithm implements child specification built incrementally upon simulation proof algorithm implements specification new work required involves reasoning modifications require repetition reasoning original simulation proofthe paper presents technique mathematically terms automata technique already used model validate fullfledged group communication system see 26 methodology results experiment summarized paper b introduction formal modeling validation software systems major challenge size complex ity among factors could increase widespread usage formal methods improved costeffectiveness scalability cf 20 22 current software engineering practice addresses problems building complex systems use incremental development techniques based objectoriented approach believe successful efforts system modeling validation also require incremental techniques enable reuse models proofs paper provide framework reuse proofs analogous complementary reuse provided objectoriented software engineering method ologies specifically present technique incrementally constructing safety specifications abstract algorithm descriptions simulation proofs algorithms specifications simulation proofs one important techniques proving properties complex systems proofs exhibit simulation relation refinement mapping abstraction func tion formal description system specification 13 24 29 technique presented paper evolved experience context largescale modeling validation project successfully used technique modeling validating complex group communication system 26 implemented c interacts two services developed different teams group communication system acts middleware providing tools building distributed applications order useful variety applications group communication system provides services diverse semantics bear many similarities yet differ subtle ways modeled diverse services system validated algorithms implementing ser vices reuse models proofs essential order make task feasible example allowed us avoid repeating fivepage long correctness proof algorithm provides basic semantics proving correctness algorithms provide sophisticated semantics correctness proof sophisticated algorithm comparison two half pages long describe experience project well methodology evolved section 6 approach reuse specifications algorithms inheritance uses incremental modification derive new component specification algo rithm called child existing component called parent specifically present two constructions modifying existing components 1 allow child specialize parent reusing state readonly fashion adding new state components readwrite constraining set behaviors parent corresponds subtyping view inheritance 8 show observable behavior child subsumed cf 1 possible behaviors parent making specialization analogous substitution inheritance 8 particular child used anywhere parent used specialization subject section 3 2 child also derived parent means interface signature extension case state parent unchanged child may include new observable actions found parent new parameters actions exist parent new actions parameters hidden behavior child exactly behavior parent interface extension presented section 5 interface extension combined specializa tion corresponds subclassing extension form inheritance 8 provides powerful mechanism incrementally constructing specifications algorithms consider following example parent defines unordered messaging service using send recv primitives produce totally ordered messaging service specialize parent way recv possible current message totally ordered next introduce safe primitive informs sender message deliv ered first extend service interface include safe primitives specialize enable safe actions case message actually delivered specialization extension constructs applied specification level algorithm level way preserves relationship specification algorithm main technical challenge addressed paper section 4 provision formal framework reuse simulation proofs especially specialization construct consider example figure 1 let specifica tion abstract algorithm description assume proven implements using simulation relation r p assume specialize specification yielding new child specification 0 time specialize algorithm construct algorithm 0 supports additional semantics required 0 figure algorithm simulates specification r p reused building simulation r c child 0 child 0 simulation simulation rp inheritance inheritance proving 0 implements 0 would like rely fact already proven implements avoid need repeat reasoning would like reason new features introduced 0 0 proof extension theorem section 4 provides means incrementally building simulation proofs manner simulation proofs 13 lend naturally supported interactive theorem provers proofs typically break many simple cases based different actions checked hand help interactive theorem provers incremental simulation proofs break similar fashion present incremental modification constructs context io automata model 30 32 basics model reviewed section 2 io automata widely used formulating formal service definitions abstract implementations reasoning eg 6 9 11 12 14 15 21 24 28 31 important feature io automaton formalism strong support composition example hickey et al 24 used compositional approach modeling verification certain modules ensemble 19 largescale modularly structured group communication system introducing inheritance io automaton model vital order push limits projects verification individual modules verification entire systems experienced work project 26 programming modeling language based io automata formalism ioa 17 18 defined intend exploit ioa framework develop ioabased tools support techniques presented paper validation code generation stata guttag 36 recognized need reuse manner similar suggested paper facilitates reasoning correctness subclass given correctness superclass known suggest framework defining programming guidelines supplement framework informal rules may used facilitate reason ing however address informal reasoning provide mathematical foundation formal proofs furthermore 36 restricted context sequential programming encompass reactive components paper many works eg 1 6 10 23 25 33 formally dealt inheritance semantics distinguishing contribution provision mathematical framework incremental construction simulation proofs applying formal notion inheritance two levels specification algorithm section presents background io automaton model based 30 ch 8 model system component described statemachine called io automaton transitions automaton associated named actions classified input output internal input output actions model components interaction components internal actions externally unobservable formally io automaton consists interface signature siga consisting input output internal actions set states statesa set start states starta statetransition relation subset statesa thetasiga thetastatesa transa action said enabled state automaton transition form input actions enabled every state execution automaton alternating sequence states actions begins start state successive triples allowable transitions trace subsequence execution consisting solely automatons external actions io automaton model defines composition operation specifies automata interact via input output actions io automata conveniently presented using preconditioneffect style style typed state variables initial values specify set states start states transitions grouped action name specified using pre block preconditions states action enabled eff block specifies prestate modified effect executed atomically yield poststate simulation relations reasoning automaton interested externallyobservable behavior reflected traces common way specify set traces automaton allowed generate using abstract io automata generate legal sets traces implementation automaton satisfies specification traces also traces specification automaton simulation relations commonly used technique proving trace inclusion definition 21 let two automata external interface relation r statesa theta statess simulation satisfies following two conditions 1 initial state initial state 2 rt 2 2 rt reachable states respectively 0 step exists execution fragment trace following theorem emphasizes significance simulation relations proven 30 ch 8 theorem 21 two automata external interface r simulation tracesa tracess simulation relation technique complete finite trace inclusion shown using simulation relations conjunction history prophecy variables 2 35 specialization construct captures notion subtyping io automata sense trace inclusion allows creating child automaton specializes parent automaton child read parents state add new readwrite state components restrict parents transitions specialize construct defined operates parent automaton accepts three additional parameters state extension new state components initial state extension initial values new state components transition restriction specifies childs addition new preconditions effects modifying new state components parent transitions define specialization construct formally definition 31 let automaton let n set states called state extension let n 0 nonempty subset n called initial state extension let tr statesa theta n theta siga theta n relation called transition restriction action tr specifies additional restrictions child places states n enabled specifies new state components modified result child taking step involving specializean defines automaton 0 follows notation 32 use following denote parent component tj n denote new component ff execution sequence 0 ffj p denotes sequence obtained replacing state ff tj p also extend notation sets states sets execution sequences exemplify use specialization con struct figure 2 presents simple algorithm automaton write cache implementing sequentiallyconsistent register x shared among set processes p process access local cache p register x initialized default value v 0 write p v request propagates v x cache p response read p v read request returns value v ps local cache p without ensuring current thus process p responds read request value x least current last value previously seen p necessarily uptodate one figure 3 presents atomic writethrough cache au tomaton atomic write cache specialization write cache specialized automaton maintains additional boolean variable synched p process p order restrict behavior parent response read request returns latest value x traces automaton indistinguishable system single shared register cache general transition restriction denoted type preconditioneffect code union following two sets ffl triples form tj n mentioned code 0 ie 0 figure writethrough cache automaton automaton write cache signature input write p v read output read p v synch p state transitions cache p internal synch p eff cache p input read req p output read p v pre figure 3 atomic writethrough cache automaton automaton atomic write cache modifies write cache state extension initially true transition restriction eff synched q internal synch p eff synched p true output read p v pre synched p true restrict transitions involving read req p ac tion figure 2 example note new state component tj n changed state satisfies new preconditions placed 0 state result applying new effects theorem 31 says every trace specialized automaton trace parent automaton section 4 demonstrate proving correctness automata presented using specialization operator done incremental steps top correctness proofs parents theorem 31 0 child automaton 1 execsa 2 proof 31 1 straightforward induction length execution sequence basis 2 definition starta 0 inductive step 0 step 0 step definition 2 follows part 1 fact siga alternatively notice trace inclusion implied theorem 21 fact function maps state 2 simulation mapping 0 formalism introduced allows code reuse also show section proof reuse means incremental proof construction start example prove general theorem example proof reuse revisit shared register example section 3 present parent specification sequentiallyconsistent shared register describe simulation proves implemented write cache automaton presented previous section derive child specification atomic shared register specializing parent specification finally illustrate proof automaton atomic write cache implements child specification constructed incrementally parentlevel simulation proof figure 4 presents standard specification sequentiallyconsistent shared register x interface seq consistent register cache specification maintains sequence histx values stored x execution write p v request appends v end histx response read p v read request allowed return value v stored x since p last accessed x nondeterminism innate part sequential consistency specification keeps track last accesses index last p histx argue automaton write cache figure 2 satisfies specification exhibiting simulation relation r r relates state write cache state seq consistent register follows 2 r 2 integer shistx step write cache initiating state involving read p v simulates figure 4 sequentially consistent shared register specification automaton automaton seq consistent register signature input write p v read output read p v state last p transitions eff append v histx last p input read req p output read p v choose pre last p eff last p step seq consistent register initiates involves read p v choose hi p hi p number whose existence implied simulation relation r steps write cache involving read v actions simulate steps seq consistent register respective actions straightforward prove r satisfies two conditions simulation relation definition 21 interested actual proof reusing ie avoiding need repeat purpose illustrating proof reuse present figure 5 specification atomic shared register specialization seq consistent register child restricts allowed values returned read p v current value x restricting nondeterministic choice index latest value histx figure 5 atomic shared register specification automaton atomic register modifies seq consistent register transition restriction output read p v choose pre want reuse simulation r prove automaton atomic write cache implements atomic register since atomic register extend states seq consistent register simulation relation need extended works general one may need extend simulation relation capture imple mentations state relates new state added specifications child prove r also simulation relation child algorithm atomic write cache child specification atomic register show two things first show initial states atomic write cache relate initial states atomic register general prove theorem 41 need check new variables added specification child need show initial state implementation exists related assignment initial values new variables example since atomic register add new state get property free second need show whenever r simulates step seq consistent register step still valid transition atomic register implied theorem 41 check new preconditions placed atomic register transitions seq consistent register still satisfied extension simulation relation pre served since example atomic register add new state variables need show first condition whenever read p v choose simulated atomic register new precondition holds recall read p v choose simulated atomic register chosen hi p simulation work need prove always possible choose hi p histx follows immediately added precondition atomic write cache requires read p v occurs synched p true following simple invariant invariant proven straightforward induction invariant 41 reachable state atomic write cache true tcache p proof extension theorem present theorem lays foundation incremental proof construction consider example illustrated figure 1 simulation relation algorithm specification given want construct simulation relation r c specialized version 0 automaton specialized version 0 specification automaton theorem 41 prove relation r c constructed supplementing r p relation r n relates states 0 state extension introduced 0 relation r n relate every initial state 0 initial state extension 0 satisfy step condition similar one definition 21 involving transition restriction relation 0 theorem 41 let automaton 0 child automaton let automaton 0 child automaton simulation let r n relation r c defined terms r p r n simulation 0 0 r c satisfies following two conditions 1 2 exists state sj nr n sj n 2 reachable state 0 reachable state 0 sj p step 0 exists finite sequence ff alternating states actions 0 beginning ending state 0 satisfying following conditions ffj p execution sequence e ff trace proof 41 show r c satisfies two conditions definition 21 1 consider initial state 0 fact simulation must exist state sj pr p sj p starts property 1 must exist state sj n consider state r c definition also starts theta n 0 use fact starts 0 def 31 2 first notice assumption state relation r c imply 2 r c properties 2c 2d imply 0 next show ff execution sequence right trace indeed every step ff consistent transs 2a consistent tr 2b therefore definition def 31 every step ff consistent words ff execution sequence 0 starts state r c ends state r c trace practice one would exploit theorem follows simulation proof parent automata already provides corresponding execution sequence parent specification every step parent al gorithm typically case execution sequence padded new state variables corresponds step child algorithm thus conditions 2a 2c 2e theorem 41 hold se quence conditions checked 2b 2d ie every step execution sequence consistent transition restriction tr placed 0 values new state variables 0 final state execution related poststate child algorithm note state specialized version theorem 41 case three automata 0 letting 0 version would useful know algorithm simulates specification would like prove also simulate child 0 statement proof specialized version theorem 41 except child 0 must substituted 0 tj p fact given specialized version theorem 41 follows corollary relation fht g simulation relation 0 specialized theorem applies automata 0 0 interface extension formal construct altering interface automaton extending new forms interaction technical reasons convenient assume interface every automaton contains empty action ffl statetransition relation contains empty transitions ie automaton interface extension automaton defined using interface mapping function translates new child interface original parent interface new actions added child mapped empty action ffl parent childs states start states parent statetransition child consists parents transi tions renamed according interface mapping particular statetransition includes steps change state involve new actions map ffl definition 51 automaton 0 interface extension automaton statesa exists function f called interfacemapping 1 1 f function f map nonffl actions 0 ffl new actions added 0 also allowed manytoone 2 f preserves classification actions input output internal 2 input action f 6 ffl f also input action likewise output internal actions 3 notation 52 let 0 interfaceextension interfacemapping f ff execution sequence 0 ffj f denotes sequence obtained replacing action alpha f collapsing every transition form ffl likewise fi trace 0 fij f denotes sequence obtained replacing action fi f subsequently removing occurrences ffl following theorem formalizes intuition sets executions traces interfaceextended automaton equivalent respective sets parent automaton modulo interfacemapping proof straightforward induction using definition 51 notation 52 theorem 51 let automaton 0 interface extension interfacemapping f let ff sequence alternating states actions 0 let fi sequence external actions 0 1 ff 2 2 interface extension followed specialization modification resulting combination corresponds notion modification subclassing extension 8 resulting child specializes parents behavior introduces new functionality specifically specialization interfaceextended automaton may add transitions involving new state components new interface generalized definition parentchild relationship follows 1 interfacemapping similar strong correspondence 38 definition 53 automaton 0 child automaton 0 specialization interface extension theorem 51 enables use proof extension theorem theorem 41 parentchild definition childs actions translated parents actions using interface mapping definition 51 6 practical experience incremental proofs section describe experience designing modeling complex group communications service see 26 framework presented paper exploited describe interesting modeling methodology evolved experience project group communication systems gcss 3 37 powerful building blocks facilitate development faulttolerant distributed applications gcss typically provide reliable multicast group membership ser vices task membership service maintain listing currently active connected processes deliver information application whenever changes output membership service called view reliable multicast services deliver messages current view members traditionally gcs developers concentrated primarily making systems useful realworld distributed applications data replication eg 16 highly available servers eg 5 collaborative computing eg 7 formal specifications correctness proofs seldom provided many suggested specifications complicated difficult understand shown ambiguous 4 recently challenging task specifying semantics services gcss become active research area io automaton formalism recently exploited specifying reasoning gcss eg 9 11 12 15 24 28 however suggested io automatonstyle specifications gcss used single abstract automaton represent multiple properties system component presented single algorithm automaton implements properties thus means provided reasoning subset properties often difficult follow part algorithm implements part specification papers dealt proving correctness individual service layer fullfledged system 26 modeled fullfledged example spanning entire virtually synchronous reliable group multicast service provided specifications formal algorithm descriptions corresponding actual c implementation also simulation proofs algorithms specifications employed clientserver presented virtually synchronous group multicast client interacts external membership server virtually synchronous group multicast client implemented using approximately 6000 lines c code server 27 developed another development team also using roughly 6000 lines c code group multicast service also exploits reliable multicast engine implemented third team 34 using 2500 lines c code sought model new group multicast service manner would match actual implementation one hand would allow us verify algorithms specifications hand order manage complexity project hand found need employing objectoriented approach would allow reuse models proofs would also correspond implementation turn would reuse code data structures 26 used io automaton formalism inheritancebased incremental modification constructs presented paper specify safety properties group communication service specified four abstract specification automata capture different gcs properties began specifying simple gcs provides reliable fifo multicast within views next used new inheritancebased modification construct specialize specification require also processes moving together one view another deliver set messages former specialized specification also capture self delivery property requires processes deliver messages fourth automaton specified standalone property without inheritance augments view delivery special information called transitional set 37 proceeded formalize algorithms implementing specifications first presented algorithm withinview reliable fifo multicast provided five page long formal simulation proof showing algorithm implements first specification next presented second algorithm extension specialization first one second al gorithm restricted parents behavior according second specification ie added restriction processes moving together one view another deliver set messages former additionally second algorithm extended service interface convey transitional sets added new functionality providing clients transitional sets per fourth specification exploiting theorem 41 able prove second algorithm implements second specification therefore also first one two pages without needing repeat arguments made previous five page proof separately proved algorithm meets fourth specification finally extended specialized second algorithm support third property exploited theorem 41 order prove final algorithm meets third specification hence four specifications merely two half page long proof currently continuing work group commu nication incrementally extending system described 26 new services semantics using techniques modeling methodology specialization allow children introduce behaviors permitted parents allow change state variables par ents however modeled algorithms 26 one case saw need child algorithm modify parents variable dealt case introducing certain level nondeterminism parent thereby allowing child resolve specialize nondeterminism later particular algorithm implemented second specification described sometimes needed forward messages processes although forwarding needed parent forwarded messages would stored buffers messages however message buffers variables parent child allowed modify solved problem adding forwarding action would forward arbitrary messages parent automaton parent stored forwarded messages appropriate message buffers child restricted arbitrary message forwarding according algorithm liken methodology use abstract methods pure virtual methods objectoriented methodol ogy since nondeterminism left parent hook prospective children specify forwarding policy might need experience using methodology make proofs complicated 7 discussion described formal approach incrementally defining specifications algorithms incorporated inheritancebased methodology incrementally constructing simulation proofs algorithms specifications technique eliminates need repeat arguments original system proving correctness new system successfully used methodology specifying proving correct complex group communication service 26 planning experiment methodology order prove complex systems presented technique mathematically terms io automata furthermore formalism presented paper syntax incremental modification consistent continued evolution ioa programming modeling language since ioa developed practical programming framework distributed systems one goals incorporate inheritancebased modification technique approach proof reuse ioa programming language toolset 17 18 future plans also include extending proofreuse methodology construct allows child modify state variables parent future plans include adding ability deal multiple inher itance work aim formulate extend formal specification techniques would useful practical software development acknowledgments thank paul attie steve garland victor luchangco jens palsberg helpful comments suggestions r theory objects existence refinement mappings acm 394 formal specification group membership ser vices fault tolerant video ondemand services objectoriented approach verifying group communication systems middleware support distributed multimedia collaborative computing introduction objectoriented program ming adaptive totally ordered multicast protocol tolerates partitions denotational semantics inheritance correctness dynamic primary configuration group communication service data refinement modeloriented proof methods comparison specifying using partionable group communication ser vice fast replicated state machines partitionable networks foundations component based systems ioa language specifying optimizing layered communication protocols formal methods developing high assurance computer systems working group report generalized railroad crossing case study formal verification realtime systems need practical formal methods wrapper semantics objectoriented programming language state specifications proofs ensemble layers inheritance smalltalk80 denotational definition clientserver approach virtually synchronous group multicast specifica tions clientserver oriented algorithm virtually synchronous group membership wans multicast group communication base loadbalancing replicated data service generalizing abstraction functions distributed algorithms robust emulation shared memory using dynamic quorumacknowledged broadcasts introduction putoutput automata objects closures abstract semantics objectoriented languages implementation reliable datagram service lan environment proving correctness respect nondeterministic safety specifications modular reasoning presence subclassing group communication specifications comprehensive study io automaton model operating system primitives tr objects closures abstract semantics objectoriented languages inheritance smalltalk80 denotational definition existence refinement mappings proving correctness respect nondeterministic safety specifications denotational semantics inheritance correctness modular reasoning presence subclassing introduction objectoriented programming 2nd ed specifying using partitionable group communication service dynamic vieworiented group communication service eventuallyserializable data services distributed algorithms theory objects data refinement wrapper semantics objectoriented programming language state multicast group communication base loadbalancing replicated data service dynamic primary configuration group communication service specifications proofs ensemble layers need practical formal methods robust emulation shared memory using dynamic quorumacknowledged broadcasts fast replicated state machines partitionable networks formal methods developing high assurance computer systems clientserver approach virtually synchronous group multicast optimizing layered communication protocols fault tolerant video demand services clientserver oriented algorithm virtually synchronous group membership wans ctr sarfraz khurshid darko marinov daniel jackson analyzable annotation language acm sigplan notices v37 n11 november 2002 keidar roger khazan nancy lynch alex shvartsman inheritancebased technique building simulation proofs incrementally acm transactions software engineering methodology tosem v11 n1 p6391 january 2002
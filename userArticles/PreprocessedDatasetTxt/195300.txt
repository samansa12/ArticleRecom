using specialized procedures specificationbased analysis reduce runtime costs modularity managing tradeoffs program structure program efficiency one difficult problems facing software engineers decomposing programs abstractions simplifies construction maintenance software results fewer errors however introduction abstractions often introduces significant inefficienciesthis paper describes strategy eliminating many inefficiencies based upon providing alternative implementations abstraction using information contained formal specifications allow compiler choose appropriate one strategy implemented prototype compiler incorporates theorem proving technology b introduction many approaches programming emphasize use specifications interfaces basic idea achieve separation concerns client interface looks specification writes code uses inter need concern specified behavior achieved implementors job provide implementation satisfies specification efficient contexts used practice often happens first implementation proves unacceptably inefficient must tuned changing implementation may necessitate recompiling client client source code changed unfortunately often occurs practice achieving desired efficiency requires changing inter supported part advanced research projects agency department defense monitored office naval research research contract n0001492j1795 part national science foundation grant 9115797ccr authors address mit lab computer science 545 technology square cambridge 02139 internet fmtvguttagglcsmitedu appeared proceedings 1994 acmsigsoft foundations software engineering conference mapdefine map dom ran r modifies ensures defines r image already defined changes image r ran maplookup map dom modifies nothing ensures undefined returns nullran otherwise returns image figure 1 interface maps r nullran map figure 2 opportunity optimize map define bets client code consider following scenario suppose specifications figure implemented unsorted list mainrange pairs invariant domain element appears maintain invariant implementation map define must invocation search list find domain element defined already clients map code looks like figure 2 run unnecessarily slowly time spent implementation map define checking domain element listwhen calling context guarantees isnt one conventional solution problem extend interface adding map defineunique specified figure 3 depending upon context call clients call either map define map defineunique depending upon whether requires clause map defineunique satisfied however unfortunate ramifications solving problem way 1 unhappy client wrote code appearing figure change code 2 clients notified encouraged look code mapdefineunique map dom ran r requires undefined modifies ensures defines r image figure 3 addition interface maps 3 new opportunity bugs created clients may call map defineunique invariant fact satisfied general procedures nontrivial requires clauses avoided possible 4 solution may applied level abstraction suppose example maps used represent graphs map define called within implementation procedure graph addnode call map define replace one map defineunique perhaps done node added new might lead changing graph abstraction adding procedure addnewnode etc 5 change difficult back suppose example implementation map changed binary tree longer anything gained calling map defineunique instead map define unless one willing revisit client code yet interfaces maintained better approach original problem change implementation map define automatically take advantage information available calling context illustrated figure 4 leave client code untouched avoids problems listed unfortunately raises problems 1 efficiency gained implementation cant runtime test decide case therefore compiler must able decide whether guard true 2 order compiler know safe use implementation doesnt test membership must able deduce compile time actual parameter map deducing context call implementations map lookup map define ran create well beyond capability contemporary compilers paper presents approach dealing two problems basic idea allowing compiler take advantage information contained perhaps incomplete formal specifications becomes possible superior analysis program text analysis makes possible evaluate compile time guards specialized procedure implementations spis one figure 4 turn allows one write client programs simple efficient remainder paper deal three questions ffl significant opportunities improve program performance using spis address question section 2 reporting analysis legacy code mapdefine map dom ran r pair p p null insertpairmd r return specialize undefined figure 4 dual implementation map define ffl one go building compiler takes advantage opportunities address question describing section 3 built prototype implementation spi compiler section 6 discusses extent implementation realizes potential opportunities discussed section 2 ffl much kind work programmer take advantage opportunities discussed section 4 estimate potential benefits spis examined two existing programs neither wrote tried measure much merely introducing spis might improve performance purpose made unrealistic assumption compiler would detect opportunities use spis section 6 shall see one come surprisingly close satisfying assumption two programs studied perform different tasks written different programming languages one program acunify computes unifying substitutions terms containing associativecommutative operators 22 8000 lines commented clu code program sim simulates objectoriented database 7 7000 lines commented c code programs key attributes common although carefully designed algorithmic efficiency neither highly tuned performance codelevel thus room improvement also programs wellstructured make good use data abstraction made relatively easy read understand program 1 profiled program identify hot spots 2 introduced spis speedup hot spots 3 measured speedup assumption compiler would detect opportunities use spis reduce time spent hot spots acunify added spis three procedures shown figure 5 procedures operation abstract data type spi setinsert avoids check see whether e already represented unsorted array without duplicates spi mappinginsert similar discussed setelem e elem specialize e dom r ran signals exists specialize defined returns assignmentvarval signals empty duplicates specialize env contains duplicate vars figure 5 spis acunify v variable signals exists specialize v defined figure propagated spi acunify introduction spi assignmentcreate avoids check see whether env contains duplicate vars figure 6 contains signature procedure specialized propagating spi mappinginsert substitution represented mappingvariableterm thus implementation substitutionstore calls mappinginsert acunify makes substitutiona separate data type maintain invariants substitutions enforced mapping procedures figure 5 figure 6 called total 14 call sites 14 sites nine could safely optimized five could optimizing nine sites reduced running time 14 writing spis added negligible amount source codeseven lines sim added two spis procedure shown figure 7 operator returns reference element dynamicarray userdefined abstraction operator causes runtime assertion failure index within current array bounds first spi eliminates low bound check second spi eliminates high low bound checks general third spi eliminates high bound check would useful spi unnecessary hot spots sim optimizations illustrate one common use spisremoving unnecessary error checks uses spis closely related work done 9 17 eliminating checks mandated source language key difference spis allow compiler remove checks particular programmersupplied abstractions hot spots sim invoke operator 12 call sites ten require bounds checks two require low bound checks unnecessary checks eliminated running time reduced 14 note sim good example bad idea disable error checks conditions two checks prevent program clobbering memory class dynamicarray public element operatorint index const specialize index low bound specialize index low bound index high bound figure 7 spi sim intset e int requires modifies ensures e figure 8 speckle procedure specification based integer based integerset figure 9 speckle data type specifications section 2 indicated significant opportunities using spis reduce need trade abstraction efficiency next question address feasibility exploiting opportunities central problem go building compiler detects contexts spis used subsidiary problem designing programming language incorporates formal specifications spis related annotations come grips problems built prototype compiler dialect clu 14 call speckle prototype speckle compiler psc incorporates primitive automated theorem proving technology identify opportunities use spis generate code speckle retains clus features including static typing side effects data abstraction garbagecollected heap iterators exceptions combination side effects pointers heapallocated data structures requires psc handle aliasing challenging problem optimizing compilers specification language portion speckle builds larch family specification languages 10 borrows heavily larchclu language 21 procedure specifications consist pre postconditions written stylized fashion figure 8 specification procedure insert int intset empty requires clause indicates precondition vacuous true postcondition intlist e int general implementation repmembers e return end repinsertlasts e specialized implementation special repinsertlasts e figure 10 dual implementation insert combination modifies clause states visible side effects ensures clause states upon return value union feg value call functions used pre postconditions eg defined separate language called larch shared language lsl lsl provides syntax semantics specifying functions sorts first order multisorted predicate logic speckle also facilities writing data type speci fications consist two primary parts first part declares whether objects type mutable immutable immutable objects value throughout program execution whereas mutable objects modified different values different times declaring type immutable simplifies analysis code uses objects type primarily aliasing issue immutable objects based clause specifies lsl sort used model values objects type figure 9 contains parts specifications int intset specifications incorporated programming language straightforward add constructs express spis speckle allows users supply multiple implementations procedure first implementation general oneit must work correctly calling context critical since general one cannot count compiler discharging guard specialized implementations sound compiler needs safe default implementation fall back specialized implementations follow general one prefixed special clause clause supplies guard condition written syntax specification lan guage compiler must discharge substitute specialized implementation general one figure shows multiple implementations procedure insert figure 8 might written final component needed building compiler formal model reasoning programs model includes formalization program states set proof rules sketch model detailed description model used psc contained 20 model procedure implementation represented control flow graph cfg six kinds nodes assignment procedure call iterator call branch merge loop edge cfg associated program state represents state program control edge program state contains usual kind information program store program state represented using logical theory available reasoning point computation theory built part specifications data types used code reason values program states edges cfg use small set proof rules one six kinds nodes similar hoare floyd rules 4 12 procedure specifications come play proof rule procedure call node uses specification called procedure define program state call terms program state call interprocedural analysis based propagating information specifications procedure say p invokes another procedure say p1 compiler uses information specification p1 optimize p use information derivable code implementing p1 optimize p organization psc based directly proof rules first psc builds cfg using proof rules assignment procedure call iterator call branch nodes psc constructs logical system edge cfg next uses logical systems edge try discharge guards spis step psc uses proof rules merge loop nodes perform automated proofbycases proofbyinduction finally psc chooses implementation associated first guard able discharge guard discharged chooses general implementation reasoning guards done using equational conditional term rewriting early versions psc invoking lp 5 theorem proving system proved unsatisfactory current version psc internalizes theorem proving technology great deal code borrowed lp modified make suitable noninteractive application theorem proving experience building using psc leaves little doubt technical feasibility building spi compilers difficult question whether benefits compiler sufficiently large relative effort required use one effort falls two classes ffl supplying program documentation might normally provided ie specifications key interfaces abstraction functions implementations data abstractions representation module invariants ffl looking problems specifications well code debugging tuning performance evaluating costbenefit tradeoff important keep mind supplying better quality program documentation several advantages beyond facilitating use spis moreover discussed amount specification required use spis less suggested good software engineering practice contrast many suggested supplying abstraction functions invariants useful 8 information practice usually provided spi compilers rely specifications bugs specifications lead optimizations change behavior code program run may exhibit behavior cannot explained merely examining code similarly program may exhibit performance cannot explained merely examining code since current debugging tools designed work spi compilers bugs hard find 41 supplying specifications invariants abstraction functions information found formal specifications procedures case speckle iterators used help discharge guards spis usually complete specification information psc actually needs minimize effort involved using psc designed speckle support partial specifications procedures iterators partial specification weaker pre postcondition intended specification 1 extreme case specification omitted entirely often part procedure specification needed discharge guard spi modifies clause enable compiler approximate omitted modifies clauses speckle requires data type specify types mutable objects may contained value type example type sets mutable queue objects would specify contains queue psc uses contains clauses bound types objects reachable procedures arguments turn bounds objects procedure may modify test utility partial specifications deliberately wrote weakest partial specifications needed detect optimizations acunify partial specification worked well specifications necessary 11 roughly 300 procedures acunify total wrote 69 lines specifications speckle 139 lines small fraction 8000 lines commented source code furthermore many lsl specifications generic sorts integer mapping sequence set probably considered part theorem proving library partial specifications worked well two reasons first reason modularity optimize hot spot procedure p compiler needed procedure specifications p procedures called p program decomposed many small procedures fanout call graph small small number procedure specifications needed optimization second reason partial specifications worked well contains clauses modifies clause omitted psc could still deduce useful approximation using contains clauses acunify psc deduced seven modifies clauses essential four optimizations addition specifications psc sometimes needs invariants abstraction functions programs often rely invariants constrain values data accessed group procedures psc performs interprocedural analysis may need invariants discharge guards spis 1 purpose detecting spis distinction partial intended specifications unnecessary however optimizations performed psc distinction necessary soundness abstraction functions 2 13 map values used represent abstract type values abstract type suppose p procedure interface data type psc uses abstraction function two ways one translate information precondition p abstract level used ps specification representation level used ps implementation makes information available discharging guards spis ps implementation way psc uses abstraction function propagate spi ps implementation technique explained 20 acunify psc used abstraction function substitution automatically propagate spi mappinginsert caller substitutionstore thus psc able optimize callers substitutionstore question wanted explore little information needed psc perform desired optimizations therefore provided abstraction functions invariants needed enable optimizations acunify psc needed representation invariants implementations mapping partition tree solution data types abstraction functions mapping substitution total required three lines state representation invariants seven lines state abstraction functions 42 debugging performance tuning program compiled using spi compiler may exhibit behavior performance cannot understood merely examining code means programmers must consider code specifications debugging performance tuning code specifications inconsistent spi compiler may perform unsound optimizations one way avoid problems detect compile time places code specifications may inconsistent undecidable problem many occasions inconsistencies found relatively easily 3 relatively easy example flag places formal parameter modified mutated mutations necessarily violations specification sideeffect may later undone may invisible caller good places look bugs another possibility compiler generate programmer supply code check guards specialized implementations debugging mode code executed detect places inappropriate spi chosen similar assertion checking supplied anna 15 finally compiler could directed selectively turn optimizations used pinpoint optimizations triggered changed behavior tuning performance first use conventional techniques eg profiling localize problem identified code region includes calls spis examine output compiler see implementation chosen one expected need understand experience suggests common cause psc failing choose appropriate specialized implemen abstraction functions analogous reification vdm literature tation compilers limited theorem proving capability particular sometimes fails deduce appropriate consequences underlying lsl specifications one way circumvent problem would provide mechanism would allow programmers insert assertions code reluctant however since fear wishful thinking often lead insertion incorrect assertions sounder approach use add implications lemmas deducible axioms lsl specifications identify useful implications used lp examine logical system point psc failed choose appropriate specialization easy us understand psc lp well others would surely difficulty part solution problem reduce need implications using better theorem proving technology eg incorporating lp another part provide diagnostics help user identify missing implications challenge provide diagnostics contain necessary information concise easy understand spis one variety techniques improving program speed introducing specialpurpose code another approach inline procedure calls information calling context available perform traditional optimizations constant folding essence form partial evaluation spis inlining complementary approaches inlining good performing lowlevel optimizations eliminating common subexpressions located different procedure bodies spis hand good higherlevel optimizations checking whether newly allocated element object member previously existing set object speckle first language allows users define optimizations 11 hisgen presents unimplemented design strategy based transformation rules rather specifications define optimization implementor describes transformations performed compiler transformation rule may precondition expressed using applications sideeffect free functions play role analogous lsl functions thus transformation language sufficiently powerful express specialized procedure fact transformation language expressive speckle main problem transformation rule strategy lacks modularity apply transformation rule compiler must reorder program match pattern rule problem commute one procedure call another compiler must general rely commutative transformation rules supplied user maximize compilers ability perform transformations user must consider pairs procedures contrast speckle uses modifies clauses one per procedureto determine whether procedure call interferes optimization common use specialized procedures eliminate runtime checks many focussed eliminating checks operations primitive source language eg array bounds checking nil checks pointer dereferences overflow assignments supertypes subtypes etc specialized procedures general used eliminate runtime checks primitive source language 18 sites describes technique proving programs written language like algol 60 terminate without runtime errors requires proving properties sufficient eliminate runtime checks array references numeric operations assignments supertypes subtypes etc language pointers problem aliasing simpler speckle sites simulates technique manually several examples 6 german develops tool verifying absence runtime errors arithmetic overflow invalid array indices users write formal specifications procedures entry exit assertions decorate code sufficiently strong assertions verifier discharge assertions plus absence runtime errors germans work focuses defining pascal formally expressing assertions sufficient preclude runtime error describe strategies used discharge assertions 16 mchugh examines static checks gypsy derivative pascal gypsy programming environment verified software programs typically contain entry exit assertions mchughs compiler generated optimization conjectures discharged ut interactive prover 2 resulted elimination code supporting exceptionsie broad category runtime checks mchugh describe strategies used prove conjectures 9 gupta reduces overhead array bounds checks eliminating redundant checks occur code fragments ai ai1 moving checks loops strategy used relies programming language semantics arrays extend userdefined types currently greg nelson david detlefs studying ways eliminating array bounds checking nil checks runtime checks modula3 17 6 status conclusions extended programming language clu 14 include spis using framework outlined section 3 built prototype compiler language psc identifies sound optimizations apply addition performing optimizations based specialized procedures psc takes advantage information provided specifications perform enhanced global common subexpression elimination code motion loops dead code elimination 1 aspects work reported 19 20 psc used acunify program way described section 2 able optimize nine possible calls resulted performance improvement 14 compiling procedures containing nine call sites took 105 seconds dec alpha running 150 mhz unacceptably slow psc could easily sped considerably clu unusual programming language many features eg garbage collection exception handling iterators found imperative programming languages help us better understand general utility spis recently began looking applying ideas context c discussed section 2 seem plenty opportunities apply spis context yet implemented compiler c plus spis therefore cannot sure many opportunities optimization identified section 2 realizable practical compiler estimate translated relevant sections sim speckle fed psc psc identified 14 22 possible optimizations improved performance 9 missed optimizations would brought overall improvement 14 psc took 109 seconds compile procedures containing 22 call sites many years us working like think foundations software engineering concentrated understanding create programs appropriate functionality devoted relatively little attention understanding achieve appropriate performance unfortunate since much complexity useful programs caused desire achieve good performance paper presented mechanism potential greatly reducing need trade simplicity efficiency experiments convinced us spis used write code clear efficient remains seen much effort typical programmer must expend realize advantages acknowledgments kathy yelick sanjay ghemawat provided acunify sim programs steve garland helped us integrate theorem proving psc general provided help throughout work jim horning provided sound advice several occasions dorothy curtis maintains pclu system used implement psc r ut interactive prover tool using specifications check code assigning meanings programs guide lp verifying absence common runtime errors computer programs disk management objectoriented databases programming methodology collection articles members ifip wg2 fresh look optimizing array bound checking languages tools formal specification optimization userdefined abstract data types program transformation approach axiomatic basis computer pro gramming proofs correctness data represen tations clu reference manual anna reference manual towards generation efficient code verified programs extended static checking proving computer programs terminate cleanly specifications make programs run faster exploiting specifications improve program performance generalized approach equational uni fication tr clu reference manual compilers principles techniques tools fresh look optimizing array bound checking languages tools formal specification exploiting specifications improve program performance lclint axiomatic basis computer programming specifications make programs run faster generalized approach equational unification twotiered approach specifying programs towards generation efficient code verified programs optimization userdefined abstract data types ctr dawson r engler incorporating application semantics control compilation proceedings conference domainspecific languages conference domainspecific languages dsl 1997 p99 october 1517 1997 santa barbara california lee lin michael ernst improving adaptability multimode systems via program steering acm sigsoft software engineering notes v29 n4 july 2004 dawson r engler interface compilation steps toward compiling program interfaces languages ieee transactions software engineering v25 n3 p387400 may 1999 g griswold richard wolski scott b baden stephen j fink scott r kohn programming language requirements next millennium acm computing surveys csur v28 n4es dec 1996
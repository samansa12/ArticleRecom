logical data model propose objectoriented data model generalizes relational hierarchical network models database scheme model directed graph whose leaves represent data whose internal nodes represent connections among data instances constructed objects separate names values define logic model describe nonprocedural query language based logic also describe algebraic query language show equivalent logical language b introduction research database theory 1970s early 1980s focused mainly relational model cod70 due elegance mathematical simplicity simplicity however gradually recognized one major disadvantages relational model forces stored data flat structure real data always ss77 cod79 motivated great deal research past decade structured data models socalled semantic data models cf nested relations cf complex objects cf reader referred excellent surveys two works found particular inspiring jacobs jac79 jac82 hull yap hy82 jacobs describes database logic mathematical model databases claims generalize three principal data models hull yap hy82 describe format model generalizes relational hierarchical models format model database schemes viewed trees leaf represents data internal node represents connection among data models unsatisfactory ability restructure data ie ability query database hull yap ignore issue data manipulation language jacobs treatment overkillhis query language enables one write noncomputable queries var83 furthermore approaches fail model significant aspect hierarchical network database management systems ability use virtual records virtual records essentially pointers physical records used avoid redundancy database ull82 note virtual records introduce cyclicity schema level also instance level model propose database scheme arbitrary directed graph format model leaves ie nodes outgoing edges represent data internal nodes represent connections among data hard model cyclicity schema level quite apparent instance level without running cyclic defini tions solution distinguish object names object values equivalently address space data space distinction goes back codds notions surrogates cod79 thus instances model consist objects separate names values enables us give semantics instances welldefined way data model consists several components tl82 first database structure mentioned describes static portion database second component way specify integrity constraints database restrict allowed instances schema shall describe logic integrity constraints specified logic inspired jacobs database logic jac82 unlike database logic logic effective given database sentence logic one test effectively whether sentence true database third component way restructure data order describe user views queries etc describe two mechanisms logical ie nonprocedural query language algebraic ie procedural query language analogous codds relational calculus relational algebra prove two languages equivalent languages novel feature access nonflat data structure eg hierarchy answers produce flat either thus language really ability restructure data retrieve opposed approaches cited 2 introduction logical data model logical data model ldm generalization hull yaps format model hy82 format model fails model important part network hierarchical database systems namely ability use virtual records model introducing cyclicity database schemas ldm schema labeled directed multigraph 1 node particular type leaves schema ie nodes outgoing edges basic type denoted graphically instance node contains data values stored database interior node one following types 1 product denoted graphically h theta domain node cartesian product domains children 2 power denoted graphically h node exactly one child 1 multigraph one one edge two nodes domain node set finite subsets domain child 3 union denoted graphically h domain node disjoint union domains children person parent rehoboam solomon solomon david solomon batsheba david jesse figure 1 personparent relation theta figure 2 personparent relation ldm schema example 1 fig 1 shows genealogy database relation represent structure relation ldm schema fig 2 consists two nodes u v type correspond person parent attributes respectively one node w type h theta contains pairs related attributes moment instance ldm schema assignment node u set iu values corresponding domain instance corresponding data fig 1 consists following assignments person oe figure 3 genealogy network figure 4 ldm schema corresponding fig 3 example 2 genealogy could represented network fig 3 network two record types person containing names people database dummy record pp two links sets connect dummy record person parents idea behind mapping network ldm schema fig 4 follows record type r mapped product node v r field r v r child type link set network r member let r j owner link v r j child v r fig 4 w v pp v v person u corresponds field person record ie persons name two arcs w v correspond two links network contents relation fig 1 corresponding instance ldm schema fig 4 would virtual person person figure 5 genealogy hierarchy figure corresponding hierarchy example 3 fig 5 shows hierarchical representation genealogy hierarchy person record related linked list parents even though hierarchical model uses linked lists really matter implementation intuitively user see connection person set parents therefore map record type r product node v r network model child type corresponding r fields however r member link r r j instead connecting v r v r j directly connect node type corresponding ldm schema cyclic schema fig 6 cyclic schemas one cannot define instance way writing instance example complicated general data well schema cyclic cannot write similar one problems jacobs database logic mathematical theory develop deal problem closely related nonwellfounded sets acz85 approach defining instance schema separate concepts object name object value intuitively object name address object value content address instance consists 1 assignment set iu object names node u schema 2 assignment object value vall name l iu names taken fixed infinite set l usually set natural numbers values taken fixed infinite set data values built object names show instances previous examples look like use names values example 4 relational instance example 1 consists following assignment names nodes assign value vall names assignment shown fig 7 l vall 3 david l vall 6 batsheba 7 jesse l vall 9 2 5 figure 7 instance ldm schema corresponds relation example 5 fig 8 show instance corresponds hierarchy example 3 l vall 3 david 5 jesse l vall 9 4 l vall figure 8 instance ldm schema corresponds hierarchy 3 formal description logical data model definition 1 schema tuple 1 v e directed multigraph 2 total order e 3 function v set types f g satisfies following conditions see fig leaf b v exactly one child c children v distinct nodes theta however multiple edges v node w order edges used induce order components tuples v called type v readability use following abbreviations 1 w abbreviation child w 2 n abbreviation theta v n children figure 9 nodes ldm schemas abbreviation theta exactly n edges e 1 e n tail v edges heads v 1 v n 3 n abbreviation v n children abbreviation exactly n edges e 1 e n tail v edges heads v 1 v n really overloading symbol practice cause confusion abbreviations use include referring elements v e nodes edges respectively referring order children node shall ignore order clear context shall often refer schema instance consists two parts assignment set object names node assignment object value object name proviso assume fixed infinite set l object names fixed infinite set data values definition 2 instance tuple hi vali satisfies assignment sets object names nodes require iv iw disjoint whenever v w distinct nodes 2 val mapping domain v2v iv ie set names instance mapping val must satisfy v l 2 iv vall member set data values b vall tuple l 1 n l element c w l 2 iv vall finite subset iw definition 3 finite instance instance hi vali node v iv finite shall interested mostly finite instances since correspond real databases l v2v iv say name vall called value set v2v valiv called set values definition 4 let instance schema let v node type l name iv 1 th component vall shall also use notation l component whenever result ambiguity following definition says meaningful compare two names ie v w nodes l 1 2 iw possible l 1 l 2 value definition 5 say two nodes v w schema similar iff type children ie one following holds 1 2 node u 3 n nodes u 1 4 n nodes u query ldm schema involve addition nodes need following definitions definition schema extension iff 1 2 b v v 0 ie new edges either new nodes new node node v 3 conservative extension 4 conservative extension intuition behind 1 2 schema 0 adds extra nodes adds edges e e change schema ie add edges nodes v nodes v new nodes extension define extension instance 0 follows definition 7 let 0 extension let hi vali instance say instance extension 0 iff 1 v v 0 2 v node l 2 iv val 0 proof following lemma straightforward lemma 1 let 0 extension let 0 instance 0 unique instance 0 extension 0 instance called restriction 0 conclude section definition isomorphism two instances isomorphic essentially ie differ renaming shall want show result query welldefined isomorphism give stronger definition isomorphism let instance let 0 extension let 1 2 extensions 0 shall say 1 2 isomorphic relative isomorphism 1 2 leaves objects fixed case query means isomorphism relative database leaves contents database fixed definition 8 let 0 extension let hi vali instance let 1 two extensions 0 say 1 2 isomorphic relative iff mapping g 1 v 11 gamma onto 2 v 1 node v g identity iv 2 node v 0 g maps 1 v onto 2 v 3 v node 0 l 2 1 v v type val 2 l b v type val 2 val 1 l val 1 l c v type l v type gval 2 gl special case definition get definition ordinary isomorphism definition 9 let 1 instances say 1 2 isomorphic iff isomorphic relative empty schema ie schema 4 ldm logic section define ldm logic logic similar relational tuple calculus used part logical query language logic also used specify integrity constraints ldm schemas define views throughout section fixed schema hi vali fixed instance variable logic fixed sort sorts elements v sorts define domains variables range example x variable sort v x ranges iv analogue relational calculus tuple variable ranges specific relation shall usually write variable sort subscript eg x v variables different subscripts denote distinct variables x u different variable x v even though variables range object names think ranging objects thus shall refer name x v value x v definition 10 atomic formulas following 1 x v w w node type theta v th child 2 x v ae w w node type v one children 3 x v 2 w w type 4 x 5 x w similar nodes data element v type atomic formula x v w means name x v th component value w note mention component w referring since may multiple edges w v however shall also write x v w unambiguous atomic formula means value w x v since one edge w v use ae rather ae atomic formula x v 2 w means x v member value w several kinds equality atomic formula x means names x v v equal since iv iw disjoint whenever v 6 w need atomic formulas form x means values x v w equal meaningful v w similar nodes finally atomic formula x means data value x v equal data element definition 11 wellformed ldm formula schema 1 atomic formula 2 oe 1 oe 1 oe 2 wellformed formulas 3 oe 1 wellformed formula 4 8x v oe 1 oe 1 wellformed formula free variables oe defined way firstorder logic use oe 1 oe 1 standard meanings another useful abbreviation following definition 12 formula x vn v node type define satisfaction ldm formulas let oex 1 vn x n vn let l 1 l n assignment object names free variables formula ie l member corresponding iv means oe satisfied l instance clear context shall write j instead definition 13 let oex 1 vn formula free variables x 1 vn let l following hold 1 oe x 2 oe x 3 oe x 4 oe x 5 oe x 6 oe x 7 8 hold 9 oe formula free variables x 1 l definition 14 let oe ldm sentence say satisfies oe iff oe holds example example next one ldm schema fig 6 instance fig 8 ldm formula oex says name x u equal first component value v holds l 1 example 7 following constraint says name u related exactly one set w example 8 9 parents 2 must one set rather two different sets constraint words name u x u one name w z 1 z 2 associated association 1 2 note constraint says name u associated one set w rather saying person database associated one set could still duplication u eg two names data value solomon one way prevent constraint following lemma shows slightly restricted logic power restricted logic atomic formulas compare data values internal nodes lemma makes subsequent proofs definitions simpler lemma 2 let oex 1 vn ldm formula whose free variables variables x 1 x n vn ldm formula x 1 vn contain atomic subformula form x different equivalent oe instances l 1 iff proof proof induction size oe show construct formulas form x similar type result follows immediately distinguish possible types v w 1 u v type new variable let instance l iw l 2 vall 1 therefore oe valid 2 u v type wn wn n x u z n wn z n wn n distinct new variables let instance equivalent vall 1 vall 1 n vall 2 equivalent conjunction l l words vall 1 therefore equivalent wn wn n x u z n wn l 1 ie oe valid 3 u v type ae x u z 1 ae v wn z n wn ae x u z n wn ae v z n wn n distinct new variables let instance equivalent vall 1 holds iff case ae x u z ae v oe valid shall assume x appear subformula proofs concerned shall able use general form convenient proof following lemma says satisfaction preserved isomorphism straightforward lemma 3 let 0 extension let 1 2 extensions 0 let g isomorphism 1 2 relative let vn ldm formula oe finally show logic effective finite instances lemma 4 let oex 1 vn ldm formula whose free variables variables x 1 vn let finite instance let l determined effectively proof show induction size formula atomic formulas testing satisfaction straightforward testing disjunction negation also clearly effective quantification make use finiteness order test whether test whether l finite set iw 5 logical query language relational model result query relation natural generalization would result query model another ldm schema called henceforth query schema together instance schema modify slightly requiring querys schema independent schema instead allowing successors nodes query nodes database schema continuing analogy relational calculus natural thing would let query ldm formula oe resulting instance would consist objects satisfy oe two problems approach first clear ldm formula select objects satisfy certain conditions clear ldm formula construct new objects one solution would prevent query referring directly object names rather query refer object values could find possible values might appear result assign arbitrary names show result unique isomorphism figure 10 ldm schema 1 l vall 1 v l vall 4 2 figure 11 possible result query still solve second problem deal cyclicity need ability refer directly object names order deal cycles even result query always l vall 2 v l vall 3 2 figure 12 another possible result query defined uniquely example query schema fig 10 query specifies iu iv contain least two different names way choose two incomparable instances fig 11 12 solution problem restrict queries ones contain cycles allowing cyclicity database furthermore allow query refer explicitly names nodes database detailed discussion motivation underlying approach see kup85 recent work eg iql shown query languages could defined allow cyclic queries 51 query language definition 15 let ldm schema query consists tuple 1 sq extension 2 oe q topological order nodes vq gamma v ie oe q linear order v child w v oe q w 3 phi q set pairs hv oe v assigns formula oe v node v node v formula oe v corresponds node oe v one free variable sort v b variables oe v bound sorts either node database schema query node precedes v oe q order oe q used specify order define result query formula oe v specifies contents v terms database nodes query nodes precede v continuing formal details give several examples queries database schema examples genealogy schema fig 6 instance fig 8 example 8 schema q 1 shown fig 13 formula oe u words want iu 0 copy iu eliminate however duplication may iu result query shown fig 14 2 figure 13 schema q 1 example 9 schema q 2 shown fig 15 want v 0 contain set parents solomon formulas oe oe v 0 examples result defined isomorphism relative ie choice names arbitrary 19 david jesse figure 14 result q 1 intuition behind oe u name value solomon another name 1 equal x u 0 rest formula says 1 parent 2 oe v 0 says iv 0 contains names iu 0 one set result query shown fig 16 figure 15 schema q 2 formally define result logical query start looking queries add one node schema shall call queries simple queries query q called simple query jv shall use notation q v simple query let q v simple query schema let instance result q v extension v sqv order define v l vall figure define names v v contains values names would like v v contain objects satisfy oe v x v problem using definition v oe v names since v v yet defined meaningless talk objects satisfy oe v might seem really trivial problem suppose oe v included conjunct 8y v 8z v contain one name rest oe v allowed several possibilities value name would way choose one result reason problem us formula allowed query languageall bound variables language must refer database nodes nodes precede v cannot refer v result restriction turns although oe v refers names oe v actually statement values therefore find values satisfy oe v pick names arbitrarily definition 17 let val value ie anything could value say val candidate value v 3 following holds let l new name ie name appear let v extension sqv v using arbitrary name able express fact val one objects result query note definition make use fact query acyclic first show particular choice name unimportant lemma 5 let val data value let 1 2 two extensions sqv defined respectively 1 3 really depends q well clear context val proof definition oe v one free variable sort v ie variable x v inspection see atomic formulas contain x v xw last always true easy see truth others depends value x v name proof straightforward induction define result sqv take candidate values v pick new name one put names v v notice set candidate values infinite principle even finite instance queries property set candidate values finite correspond safe queries relational model next section look issue detail definition 18 result q v extension v sqv defined follows let r set candidate values v let fl val j val 2 rg set new names ie names appear v v defined set fl val j val 2 rg val v l val val val 2 r show definition desired properties words result well defined isomorphism relative everything result satisfies oe v cannot add anything else satisfies oe v result without introducing duplication proof following lemma similar proof lemma 5 lemma 1 extension sqv let l element 1 v let 2 extension sqv defined 2 val lemma 7 1 let 1 2 two results q v 1 2 isomorphic relative 2 let v result sqv l v v proof 1 let l 1 element 1 v since val 1 l 1 candidate value v must l 2 2 v val 2 l 2 definition result query 1 v 2 v dupli cation immediately get 11 correspondence names 1 v 2 v straightforward show correspondence isomorphism 2 let l arbitrary element v v let extension sqv defined lemma 6 since vall candidate value v extend instance sqv defining oe v l lemma 5 oe v l therefore define result arbitrary query q first define composition queries definition 19 let q 1 query let q 2 query sq 1 query get composing following way consists sq 2 ffiq 1 lemma 8 query let nodes added query q define sequence simple queries q q vn follows q v query schema q v igamma1 q adds node v schema formula v oe v easy see use define result q definition 20 result query q result applying queries q vn successively lemma 9 result q unique isomorphism words different choices names step yield isomorphic results proof straightforward application first part lemma 7 theorem 10 let q result query q instance 1 let v node added q let l element q v q 2 let v node added q let l 1 l 2 two different names iv vall duplication result 3 q maximal extension sq satisfies 12 means extension q satisfies 12 least one v inclusion proper proof 1 let q query q result q lemma 7 oe v l easy see q extension isomorphic image q extending q q affect satisfaction oe v 2 obvious 3 assume exists let first nodes v 1 v n query q 1 2 follows immediately q restricted sq results q lemma 9 implies q q isomorphic contradiction 52 safe queries previous section observed set candidate values query node infinite principle even finite instances example example 10 oe u query unsafe since set candidate data values fdavidg infinite set definition 21 query q schema safe finite instance set candidate data values node finite q safe safe every finite instance let v query node assume defined result q nodes precede v preceding nodes contains finite set names theta h h set candidate values v subset respectively cartesian product powerset union instances vs children therefore finite case set candidate values may infinite since set data values infinite lemma 11 q safe iff every query node type set candidate data values v finite following two examples use database query schema fig 13 database instance fig 8 example 11 oe u safe since set candidate data values solomon rehoboam absalomg testing safety relational queries reduced testing safety ldm queries kup85 consequence testing safety general undecidable decidable however test whether given query q schema safe given instance describe decision procedure lemma 12 let w nodes database schema type let fd constants occur formula q q safe iff query node v type candidate value v either value element iw b one j proof one direction obviousif condition holds q safe prove converse induction query nodes query node type assume lemma holds nodes precede v q safe let igamma1 result q v igamma1 safe set candidate data values v finite set r show call right hand equation lemma false element val r gamma induction hypothesis since val candidate data value v extend igamma1 instance 1 sqv defining 1 arbitrary element gamma extend igamma1 instance 2 sqv defining 2 val val 0 appear either database preceding query nodes query formulas induction size oe v shows key point induction x v occur oe v 1 atomic formulas form x node type either v one nodes v 1 v igamma1 formula false whenever data value x v 2 x v x formulas always true therefore shown elements infinite set gamma candidate values contradicting assumption q safe technique proof gives us effective procedure determining whether simple query q v safe finite instance take data value 0 2 occur anywhere database query formulas test 0 candidate value difficult see done effectively similar way proof lemma show q v safe iff 0 candidate value v intuitively 0 result result infinite since 0 cannot distinguished data value proves following theorem theorem 13 let q query let finite instance decision procedure test whether q safe q safe result computed effectively 6 algebraic query language 61 algebraic operators section define set algebraic operators show safe logical query equivalent sequence algebraic operations conversely sequence algebraic operations equivalent safe logical query since logical query adds nodes database schema leaves instance database schema unchanged algebraic operator must therefore selection operator example delete tuples satisfy selection condition rather create copy database node copy contain tuples satisfy condition fact copying tuples really done relational modela query throw away tuples database meet selection condition rather copies tuples issue addressed explicitly relational database theory since theory deal happens temporary relations created computing result query shall see next section necessary delete nodes certain circumstances would still like make deletions explicit rather hide algebraic operations section database schema instance algebra consists operations form w ff name operator arguments v 1 v n nodes schema ff adds node w schema extends new schema define operator simple logical query giving 1 types arguments 2 type w list children 3 ldm formula oe w specifies contents iw 611 operators copy combine existing nodes figure 17 algebraic operation figure 18 algebraic operation v 1 w v creates copy node v shown fig 17 figures schema shown box right node created operation left distinct data value iv iw contains exactly one name data value note duplication iv eliminated iw v node type b w type c oe w 2 w creates node type contains data value data value data domain b w type c oe w 3 w h v creates node contains finite subsets iv see fig 18 v node schema b w type h theta figure 19 algebraic operation theta v figure 20 algebraic operation c oe w 4 w h theta v creates node contains cartesian product fig 19 n nodes schema b w type h c oe w 5 w h creates node contains disjoint union fig 20 n distinct nodes schema b w type h c oe w 612 selection operators ldm algebra two selection operators 1 operation w oe j v similar selection operation relational algebra operator selects tuples v whose th j th components related see fig 21 v node type h one relations b w type h c oe w alternatively selection condition may form data value oe w theta theta figure 21 algebraic operation u r q figure 22 algebraic operation w oe u v 2 w oe u v u child v w contain objects iu actually appear iv see fig 22 example v type h element iv set elements iu result oe u v select iv elements least one sets u v nodes u child v b w type u children c oe w depends type v note v cannot type since child u v type h theta u th child oe w strictly speaking oe u v underspecified case multiple edges v u since specify edge referring case shall use notation oe u v mean use th edge tail ii v type h iii v type h oe w 613 union difference projection 1 union operator similar relational union syntax use w fig 23 n nodes type children b w type children v c oe w figure 23 algebraic operation theta theta v figure 24 algebraic operation 2 difference shall use infix notation ie shall write w rather gammav v 1 v 2 nodes type children b w type children v 1 v 2 c oe w 3 projection operation similar projection relational alge bra syntax use w pi v ordered multiset edges tail v v node type h ordered multiset edges tail v b let edge v v j w c oe w cause ambiguity shall use set nodes rather edges fig 24 62 equivalence logical algebraic query languages use algebraic operators define algebraic query language algebraic query sequence fff g ff algebraic operator result ff igamma1 would like able show query language equivalent logical query language words logical query schema exist sequence algebraic operations vice versa property schemas created two queries identical every database instance results isomorphic relative unfortunately next example shows quite true example 12 let consist node u type let q logical query adds node v type let 1 2 two data values let oe v candidate values v g algebraic query equivalent q query would consist one algebraic operation alone since operator adds new node schema inspection see single algebraic operator equivalent q modify definition get equivalent query qa algebraic query consists operations w 1 1 clear instance v restrict result query schema consists nodes u v get instance want essentially used two nodes w 1 w 2 temporary storage computing result query fact thing occurs relational model since temporary relations used subexpressions deleted end therefore reasonable expect thing happen logical data model able use temporary nodes extend algebraic query language adding delete operator operator deletes node schema restricts instance original schema new schema make sure never delete node child node since case result would legal schema operator deletes node v written dv definition 22 let ldm schema instance algebraic operator dv legal v node parent result dv schema 0 consists deleting v together instance get restricting 0 algebraic query language must take care delete database nodes ie must allow user delete nodes constructed query shall call language deletion operator extended algebraic query language definition 23 let ldm schema extended algebraic query sequence ff either 1 operation form w algebraic operator deletion operator v 1 either node nodes created previous fi j deleted 2 operator dv v node created previous algebraic operator sequence fi 1 fi igamma1 yet deleted definition 24 let qa extended algebraic query let qb extended algebraic query result qa query qb ffi qa composition qa qb formed simply concatenating lists algebraic operators obviously delete operator equivalent logical query since every logical query adds nodes schema necessarily mean cannot find logical query equivalent extended algebraic query extended algebraic query delete database nodes since nodes deleted constructed previous algebraic operations might still case example 12 equivalent logical query use temporary nodes nevertheless kup85 shown extended algebraic query language strictly powerful logical query language order get equivalent query language modify logical language include temporary nodes well definition 25 let ldm schema extended logical query tuple 1 logical query 2 dq set temporary nodes used query dq subset query nodes delete still get ldm schema words edge tail outside dq head dq ie definition 26 let q extended logical query hs let instance result query consists 1 schema q consisting nodes vq gamma dq b relevant edges ie edges sq whose head tail vq gamma dq c restriction type assignment vq gamma dq 2 result q defined follows let q result result q restriction q show every extended algebraic query equivalent extended logical query lemma 14 let extended algebraic query exists safe extended logical query q l every instance results qa q l isomorphic relative proof schema q l consists nodes created operations query qa set temporary nodes dql set nodes deleted qa ie fv j operator ff dv g since allowed delete nodes parent easy see edge whose head dql whose tail ff delete operator must form w define order nodes formula used define operator fi j easy verify results qa q l instance indeed isomorphic show converse let q l logical query let fixed instance q l safe definition qa depend results qa q l isomorphic instances q l safe keep fixed able prove various lemmas results queries go along first look case q l simple query qw start creating node w dom contains domain w ie objects might candidate values w ignore everything except type w fact q l safe define w dom follows 1 w type let v 1 v nodes type let 1 k constants occur oe w w dom algebraic query w dom 2 theta v 3 v 4 call algebraic query q dom lemma 15 1 schema created q dom equal schema together node w dom type children node w original logical query qw 2 let dom result q dom let w result qw val value object w w val also value object dom w dom proof w type h theta h h lemma obvious w type first part follows fact nodes except w dom created q dom also deleted q dom second part immediate consequence lemma 12 definition q dom may assume necessary renaming bound variables bound variables formula oe w distinct let variables x 1 x k algebraic query q prod result q dom consists operation w prod h theta w purpose defining qa shall label edges tail w prod follows th edge tail w prod labeled x labels used define algebraic query part query purpose tell us bound variable edge corresponds certain cases create new node using algebraic oper ation outgoing edges new node inherit labels corresponding edges whose head one arguments operator use inheritance cases unambiguous ie cases arguments labeling operations labels inherited oe j difference union use projection operation new edges also inherit labeling corresponding edges whose head argument projection arrange wellformed subformulas oe w list 1 subformula j subformula define extended algebraic query q result q q query result q prod node w type h intuitively tuples l edges tail w labelled variables might free ie havent yet bound definition q follows 1 x 2 x w oe k1 w prod 3 xw xw q w 4 x w 5 w let 1 ordered multiset edges tail w label edge tail w let 2 corresponding set edges tail w q following extended algebraic query w w different temporary nodes used similarly named nodes used note way defined 1 2 guarantees ambiguity labeling edges result least long labels edges 1 2 order shall show later indeed case 7 j let ordered multiset edges tail w dom label edge tail w j q following extended algebraic query w dom previous case shall show label edges tail w without ambiguity 8 9x wa j let ordered multiset edges tail edge labeled x wa show must exactly one edge label q consists algebraic operation w lemma one well formed subformulas oe w let x 1 x j variables list bound note x may actually occur w type h furthermore th edge tail head w labeled variable x wa consequence labelings edges order assumptions made labelings defined w hold proof proof fairly straightforward induction using definition w tricky case children w correspond bound variables oe w bound j 1 children w bound variables oe w bound j 2 since variable bound j 1 iff bound j 1 bound see result hold case 4 lemma 17 let w type h result q let l member w dom let l member w k exists l w l candidate value iff satisfies proof straightforward induction structure extended algebraic query q final result q oe w consists wa oe w dom w oe prod dom finally define algebraic query qa lemma 18 let 1 result qw let 2 result algebraic query qa 1 2 isomorphic relative proof first note schemas equal node created deleted qa node wa node similar node w dom hence w show instances wa w isomorphic ie point evaluating queries compute instances nodes candidate values assume point evaluation qa final round deletions 4 note bound free variable bound one formulas either free formula appear let val candidate data value w extend instance w sqw defining w oe w result q oe w second clause lemma 15 val candidate data value w dom l oe w w dom vall lemma 6 oe w l therefore lemma 17 l oe oe w w dom vall oe val candidate data value wa converse suppose val candidate data value wa let oe w result q oe w since val candidate data value wa l oe oe w w oe w l oe w w dom vall oe l oe oe w w oe w implies restrict oe w instance dom schema q dom dom lemma 6 vall val candidate data value w since arbitrary logical query viewed sequence simple queries easily extend construction arbitrary queries concatenating algebraic queries individual simple queries extended logical query add deletion operations delete nodes delete set query yields following theorem theorem 19 extended algebraic query language extended logical query language equivalent ie every extended algebraic query exists safe extended logical query every extended logical query exists extended algebraic query queries define schema every database instance logical query safe results queries isomorphic relative 7 concluding remarks described new model data logical data model designed combine advantages existing data models one hand enables database describe semantics data possible using relational model data hand lose nice properties relational databases particular ability query database using equivalent nonprocedural procedural languages complexity query language studied kv85 work unifies generalizes long sequence previous works semantic data models ab84 db82 fk77 gdb82 gra79 har78 kob80 mak77 mp82 oy85 rr83 sp82 ss77 tsi76 preliminary publication results kv84 stimulated later work models viewed special cases ldm designed make certain classes queries easier express efficient implement model incorporates two important objectoriented features object identity captured distinction object names object values strong typing types built product power union operations however incorporate features considered important objectoriented databases inheritance methods encapsulation etc cf important feature model separation schema instance unlike models one feature ldm ability describe cyclic data feature lacking query language brings two questions possible eliminate cycles databases possible add cycles queries first question addressed kv85 recently shows extend query language allow cycles queries query languages described based paradigm firstorder logic recognized framework relational model firstorder languages weak task database querying au79 motivated study powerful query lan guages based paradigm logic programming rei78 ull85 recently similar query languages developed models similar ldm acknowledgments indebted jeff ullman basic ideas underlying work would also like thank rick hull paris kanellakis dave maier helpful discussions suggestions anonymous referees suggestions improvements r non first normal form relations represent hierarchically organized data notes nonwellfounded sets universality data retrieval lan guages relational model data large shared data banks extending database relational model capture meaning correct translation update operations relational views algebra quotient relations semantics network data manipulation languages objectoriented approach nets operations logic ambiguity processing boolean queries tdms treestructures study four different philosophies format model theory database organization application database logic database design database logic overview database mangement technology logical data model new approach database logic new approach database logic expressive power logical data model consideration normal form notnecessarily normalized relations relational data model normal form nested rela tions deductive question answering relational databases data definition language statistical database data structures integrated data base management information retrieval system database abstractions aggregation generalization data models lsl link selector language principles database systems implementation logical query languages databases review tr format model compiling queries recursive firstorder databases non first normal form relations algebra allowing data restructuring logical data model new approach database logic calculus complex objects amateurs introduction recursive query processing strategies sets negation logic data base language ldl1 extending relational algebra relational calculus setvalued attributes aggregate functions database modeling survey applications research issues survey theoretical research typed complex database objects complexity queries logical data model data models flogic higherorder language reasoning objects inheritance scheme object identity query language primitive logic programming sets rulebased language functions sets objectoriented database systems expressive power logical data model functional data model data languages daplex database description sdm correct translation update operations relational views implementation logiclal query languages databases abstract extending database relational model capture meaning database abstractions database logic normal form nested relations relational model data large shared data banks algebra quotient relations principles database systems universality data retrieval languages data models cqlfa query language codasyltype databases new approach database logic remarks algebra non first normal form relations semantics network data manipulation languages data structures integrated data base management information retrieval system extended algebra calculus 1nf relational databases ctr hongcheu liu jeffery x yu algebraic equivalences nested relational operators information systems v30 n3 p167204 may 2005 evgeny dantsin andrei voronkov expressive power data complexity nonrecursive query languages lists trees extended abstract proceedings nineteenth acm sigmodsigactsigart symposium principles database systems p157165 may 1518 2000 dallas texas united states serge abiteboul sophie cluet tova milo correspondence translation heterogeneous data theoretical computer science v275 n12 p179213 march 28 2002 jan van den bussche dirk van gucht marc andries marc gyssens completeness objectcreating database transformation languages journal acm jacm v44 n2 p272319 march 1997 christoph koch complexity nonrecursive xquery functional query languages complex values acm transactions database systems tods v31 n4 p12151256 december 2006 serge abiteboul paris c kanellakis object identity query language primitive journal acm jacm v45 n5 p798842 sept 1998 mihalis yannakakis perspectives database theory acm sigact news v27 n3 p2549 sept 1996
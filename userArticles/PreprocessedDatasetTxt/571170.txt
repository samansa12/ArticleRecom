using heap eliminate stack accesses value variable often given field heap cell frequently program pick values several variables different fields heap cell keeping variables stack frame accessing original locations heap instead reduce number loads stores stack cost introducing smaller number loads heap present algorithm finds optimal set variables access via heap cell instead stack slot transforms code program accordingly implemented optimization mercury compiler measurements show reduce program runtimes 12 time reducing program size optimization straightforward apply mercury languages immutable data structures adaptation languages destructive assignment would require compiler perform mutability analysis b introduction compilers try keep values variables per haps virtual registers whenever possible however procedure calls general case modify contents permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee ppdp02 october 68 2002 pittsburgh pennsylvania usa registers standard solution problem allocate slot stack frame every variable live call copy variables stack call paper investigate possibility avoiding allocations associated copies exploiting fact variable values must save may already available memory locations cannot updated call suppose obtained value variable eld immutable cell heap pointed variable b assume cells immutable unless specically say otherwise allows us avoid storing stack provided nd location heap everywhere need case procedure single assignment language procedure imperative language expressed singleassignment form places later procedure refer storing value b instead value stack may look promising worst case requires number stack slots one number stores stack call one additional instructions load b stack places later procedure want access however may happen program needs b call case needs stack slot store instruction stack slot anyway accessing via b needs additional store may also happen every basic block program accesses also accesses b case accessing via b requires additional loads either things happen accessing via b eliminates one stack slot one store operation stack slot used denition rst call denition accessing via b also saves load cell would need storing stack slot overall accessing via b may better storing stack slot course may two calls procedure accesses b case accessing via b incurs cost additional load however often happens two calls procedure access variable pointing cell eg b accesses one variable whose values came elds cell single load b gives us access a1 a2 a3 cost load b needs divided among a1 a2 a3 means cost accessing instead storing a1 stack slot depends variables reachable b access via b indeed may happen accessing a1 via b worthwhile accessing a2 via b worthwhile accessing a1 a2 via b worthwhile interdependence decisions need make dierent variables reachable cell sig nicantly complicates task nding optimal partition variables stored cell stack slots accessed via cell compared partition variables stored stack slots optimal partition may reduce total number stack accesses loads stores performed program may reduce number stack slots required may course may also neither optimization guarantee speedup trying partitions obvious algorithm computing best partition unfortunately algorithm feasible cells contain dozens elds require trying millions partitions paper describe much ecient algorithm based maximal matching bipartite graphs implemented algorithm mercury compiler experiments show gives real benets real programs eg mercury compiler next section give brief introduction mercury concentrating features relevant optimization section 3 give worked example explaining technique section 4 dene conditions applicability optimization show collect information need implement opti mization section 5 gives algorithm computing optimal partitions section 6 explains sourcetosource transformation use exploit optimal partitions section 7 give results preliminary experimental evaluation optimization 2 mercury assume familiarity basic concepts logic pro gramming prolog syntax also mercury syntax mercury purely declarative logic programming language designed construction large reliable ecient software systems teams programmers 3 6 mercurys syntax similar syntax prolog mercury also strong module type mode determinism systems catch large fraction programmer errors enable compiler generate fast code main features mercury relevant paper following every predicate one modes say every argument whether input output mode system sophisticated matters paper call mode predicate procedure mode system insists able nd compile time state instantiation every variable every point every procedure able reorder conjunctions goals use value variable come goal generates value variable cannot perform either task rejects program mercury associates every procedure determinism expresses upper lower bounds number solutions procedure procedures guaranteed exactly one solution determinism det procedures may one solution one set inputs zero solutions inputs determinism semidet procedures may number solutions determinism nondet denition predicate mercury body made atoms conjunctions negations disjunctions thenelses simplify algorithms compiler converts body clause forms atoms appearing b distinct variables mode analysis compiler classies unica tions one types copies one b input output tests input deconstructions b input output constructions input b output complex unications otherwise use respective notations b b b indicate mode unication paper shall mainly concerned de constructions deconstruction b whether principal functor b f hasnt previously established n 0 assigns elds cell pointed b various note eld variables used later particular anonymous variables compiler access eld compiler also detects disjunctions disjunct deconstructs input variable dierent function symbols disjunctions value variable entry disjunction determines dis junct succeed others cannot succeed try unify variable function symbol bound compiler converts disjunctions switches resemble switch construct c mercury compiler several backends translate mercury dierent target languages backend work paper compilers original backend translates mercury low level c code backend uses execution algorithm described 6 execution algorithm uses virtual machine whose data structures consist heap two stacks set general purpose registers used argument passing set special purpose registers heap stack pointers differences two stacks irrelevant purposes paper mercury compiler responsible parameter pass ing stack frame management heap allocation control ow including management backtracking almost every aspect execution signicant tasks leaves c compiler instruction selection instruction scheduling register allocation within basic blocks eect use c compiler high level optimizing assembler besides achieving portability approach allows mercury compiler perform optimizations exploit semantic properties mercury programs immutability ground terms cannot conveyed c compiler mercury compiler assumes every call clobber every virtual machine register every call site ushes live variables slots current procedures switch t0 t0 empty load k0 v0 l0 r0 store k v k0 v0 l0 r0 compareresult k k0 b switch result load k v l0 load k0 v0 r0 load v k0 l0 r0 load k v r0 load k0 v0 l0 switch t0 t0 empty load k0 store k v t0 compareresult k k0 b switch result load k v t0 l0 bc load t0 k0 ce v0 ce r0 ce load v t0 k0 l0 r0 load k v t0 r0 bd updater0 bd k v r load t0 k0 de v0 de l0 de b figure 1 update predicate original form modied transformation b stack frame similarly starts nondeterministic dis junctions ushes stack variables live start second later disjuncts since starts disjuncts reached backtracking long execution clobbered virtual machine reg isters ifthenelse treated similarly else branch corresponds second disjunct situations mercury execution algorithm requires live variables ushed stack mercury compiler therefore pass gures ush points variables need ushed stack point variables need exists stack simultaneously need stored dierent stack slots one may able use stack slot store dierent variables dierent ush points compiler uses standard graph colouring approach see eg 2 assign variables stack slots 3 motivating example consider mercury predicate illustrated figure 1a updates binary search tree t0 containing keyvalue pairs new version tree maps key k value v text symbol comment predicates predicates search update various kinds fairly important many mercury programs declarative nature mercury encourages programmers use represent dictionaries instead arrays must updated destructively original form predicate variables k0 v0 l0 r0 whose values produced deconstruction live call compare immediately follows deconstruc tion compiler therefore allocates stack slot variables saves values stack slots call saving value variables requires loaded register rst original location memory cell pointed t0 k v also live call already put registers updates caller execution follow one three paths compare turns k k0 equal execution takes second arm switch code uses k0 v l0 r0 inputs four variables must loaded stack slots k less k0 execution takes rst arm switch contains call making call requires l0 k v loaded registers stack slots call returns l register call need load registers k0 v0 r0 third arm switch analogous rst added comments indicate variables code stores stack variables loads stack heap count loads stores variables involved deconstruction cell variable t0 eld variables k0v0l0r0 required make values variables available along path execution involves deconstruction execution takes rst arm switch result execute four loads four stores involving variables program points b three loads b c three loads c e total ten loads four stores execution takes third arm switch result similar reasons also execute total ten loads four stores execution takes second arm switch result execute four loads four stores b three loads b e total seven loads four stores key idea paper realization loads stores b signicant cost avoid cost willing insert clones deconstruction later procedure body clones incur extra cost load t0 long choose perform transformation initial saving least big extra cost paths execution achieved speedup figure 1b shows predicate transfor mation clones original deconstruction one region rst uses eld variables execution takes rst arm switch result transformed predicate executes one load one store b two loads b c loading t0 stack slot register loading l0 bc cell t0 points four loads c e loading t0 stack slot register loading k0 bc v0 bc r0 bc cell t0 points total seven loads one store execution takes third arm switch result analysis analogous total cost seven loads one store execution takes second arm switch result execute one load one store b four loads b e total loads one store overall transformation reduces costs paths rst third arms ten loads four stores seven loads one store cost path second arm seven loads four stores loads one store transformation also reduces number stack slots required original code needed six stack slots variables one kvk0v0l0r0 transformed code needs three stack slots vari ables one kvt0 source speedup added one two extra loads t0 path execution replaced four loads four loads b one load one store extra cost always form extra loads cell variable t0 rst stack ush deconstruction possibly case extra store cell variable stack ush savings always form eliminated stores eld variables stack ush eliminated loads eld variables needed stack ush case must keep load k0 eliminate loads well stores v0 l0 r0 reason reduction stack slot requirements saving t0 stack preserves values eld variables t0s heap cell across calls since number eld variables cell greater one using one stack slot save value one variable across calls 4 detecting opportunities optimization describe algorithm performing transformation shown example need introduce background information denitions body mercury procedure goal goal may atomic goal compound goal atomic goal may unication builtin operation eg arithmetic call purposes paper distinction rst order calls higher order calls method calls compound goal may conjunction disjunction switch ifthenelse negation existential quanti er rest paper restrict attention rst four compound goal types algorithms treat negation special case ifthenelse notgoal equivalent goal fail true treat existentially quantied goal goal call dis junctions switches ifthenelses branched control structures branched goals denition 1 ush point point body procedure code generator required store variables stack slots registers mercury four kinds ush points execution reaches call code generator must ush variables live call stack like compilers mercury compiler assumes calls clobber registers execution reaches start ifthenelse code generator must ush variables live start else case else case reached register may clobbered eg call inside condition code generator must ush variables stack otherwise ush variables registers well stack slots execution reaches start disjunction code generator must ush variables live start second disjunct later disjunct nonrst disjunct reached via deep backtracking ie failure call inside previous disjunct failure goal following disjunction whole code generator must ush variables stack otherwise ush variables registers well stack slots execution reaches end branched control structure code generator must store variable live afterwards specic stack slot specic register exact location determined prepass code generator ensures branches leave variables place denition 2 anchor one following start procedure body call site start branched control structure end condition ifthenelse end branched control structure end procedure body ush points anchors anchors ush points example figure 1a program points abcd e represent start outer switch call compare two calls update end inner switch respectively anchors also ush points code fragment also contains two anchors start inner switch end outer switch example distinguish two anchors program points b e denition 3 interval sequence atomic goals delimited leftright pair anchors satisfying property forward execution starts left anchor continues without encountering failure would initiate backtracking ie backward execution next anchor reaches right anchor pair consider call part atomic goals interval call site right anchor interval left anchor denition 4 segment maximal sequence one intervals right anchor interval sequence except last left anchor interval following sequence sequence must also satisfy property execution get left anchor rst interval right anchor last interval without code generator throwing away current record values live variables segments contain one interval however right anchor interval start ifthenelse interval ifthenelse interval start condition belong segment right anchor interval start disjunction interval disjunction interval start rst disjunct belong segment right anchor interval start switch interval disjunction interval start arm switch belong segment intervals whose right anchor start switch intervals part one segment example figure 1a ab bc ce bd de segments empty interval containing atomic goals end call compare start following switch part segments starting b transformation algorithm three phases rst phase nd intervals procedure body interval record left right anchors set variables needed inputs interval include inputs atomic goals interval intervals whose right anchor start switch variable switched set variables needed segment denote varss union sets variables needed component intervals segment also record interval leftmost anchor segments interval belongs second phase traverse procedure body backwards looking deconstruction b fa1 call eld vari ables opposed b cell variable nd deconstruction try nd eld variables avoid storing stack slots loading heap cell pointed cell variable instead wherever needed access eld variable via cell variable following conditions hold memory cell pointed cell variable must immutable isnt values elds cell may change original deconstruction copies deconstruction transformation inserts elsewhere procedure body mercury cell mutable instantiation state cell variable point deconstruction states pointer cell live point compiler may choose destructively update cell program points value eld variable needed input atomic goal live variable ushed output argument procedure whole must within eective scope deconstruction consider variable following program fa b rxaz need determine single location use r3 hence must stored stack slot every interval needs value eld variable value cell variable must reachable time execution reaches deconstruction consider variable following program fab qxab rxa sxyaz accessed indirectly need add load segment q3 r2 q3 succeed multiple times load executed per success guaranteed compensated removal store call q3 value eld variable required segment deconstruction otherwise point investigating whether would worthwhile access via cell variable segments deconstructions four conditions hold least eld variables form set candidate eld variables partition set candidates two subsets access via cell vari able nevertheless store access via stack slots rst nd set maximal paths execution take procedure body point deconstruction point deconstruction goes scope denition 5 path sequence segments starting segment containing deconstruction segment follow segment j left anchor rst interval segment j right anchor last interval segment b execution resume left anchor rst interval segment j backtracking initiated within segment path maximal isnt contained within another path maximal path disjunction includes maximal path rst disjunct maximal path second disjunct maximal path third etc maximal path ifthenelse either maximal path condition followed maximal path part maximal path condition followed maximal path else part maximal path switch maximal path one arms switch program figure 1a maximal paths abbcce abbe abbdde since backtracking switch maximal path starting given deconstruction nonempty set candidate eld variables invoke algorithm described next section partition candidate variables set point view execution takes particular maximal path procedure body better access via cell variable set better store stack slots 5 deciding variables load cells 51 introduction maximal matching algorithm use deciding variable load cells make use maximal matching algorithms bipartite graphs section introduce terminology examples denition 6 bipartite graph g made two disjoint sets vertices b c edges e application sets vertices represent benets costs matching bipartite graph g set edges e vertex occurs maximal matching g matching matching 0 g jm 0 j jm j ecient algorithms maximal matching bipartite graphs based searching augmenting paths denition 7 given bipartite graph g matching alternating path path whose edges alternatively e dene set reachableu set nodes reachable u alternating path given bipartite graph g matching augmenting path p alternating path rst last vertices free ie occur given bipartite graph g matching augmenting path p matching jm costs benefits figure 2 stack optimization graph program figure 3 together maximal matching important property maximal matchings relationship augmenting paths property 1 matching g maximal exist augmenting paths p g straightforward algorithm bipartite maximal matching based searching augmenting paths using breadthrst search oju j jej sophisticated algorithms example 1 figure 2 shows bipartite graph matching illustrated solid arcs matching 5g example alternating path loadt 0 dened edges fstorek0 loadt 0 5 storek0 storet 0 2g augmenting path endpoints matched indeed matching maximal matching 52 minimizing stack operations aim nd deconstruction unication b set variables involved stored stack order minimize number stack operations required let f ang candidate eld variables maximal path deconstruction assume given list segments function determines variables whose values required program segment determine maximal path independently set variables require stack slot denition 8 costs must incurred access candidate variable f via cell variable b instead via stack loadb need add load b every segment storeb need add store b rst seg ment b live initial segment 1 call set costf benets gained access candidate variable f via cell variable b instead via stack b live initial segment even original program would need store b stack store extra cost incurred accessing eld variable via b storef storing f initial segment loadf 1 avoid loading f initial segment call set benefitf use model total costs benets choosing access given subset v f via cell variable instead storing stack total set costs incur choose access given subset v f via cell variable instead storing stack costv total benets choice benefitv note benets f independent costs since cost load b given segment incurred even used access one candidate variable therefore cannot decide candidate variable individually whether stored stack accessed via cell variable must consider set candidates time need ecient algorithm nding set v f benefitv greater equal costv time assume cost load store operation equal discuss relaxing assumption section 7 hence searching set v f two choices v1 v2 prefer v1 since requires fewer stack slots algorithm reduces stack optimization problem maximal matching problem bipartite graphs ecient algorithms known denition 9 stack optimization graph deconstruction given bipartite graph g whose vertex sets f2f benefitf dened costfg node graph represents load store instruc tion edges represent benets one gain one willing incur given set costs diagrams cost nodes top benet nodes bottom example 2 consider program shown figure 3a default compilation requires 14 loads stores deconstruction t0 treek0v0l0r0 single maximal path entire procedure eld variables candidates segments anchored end call vars information given costs benets eld variables given cost benet k0 fstoret 0 loadt 0 3 fstorek0g loadt 0 4 loadt 0 5g note since t0 required deconstruction cost candidate since candidate required initial segment load benets stack optimization graph deconstruction shown figure 2 algorithm starts nding maximal match stack optimization graph figure 2 shows edges maximal matching solid lines marks unmatched cost node node reachable nodes using alternating path respect cost nodes marks represent costs paid corresponding benets benet nodes marked benet equals outweighs corresponding costs algorithm partitions candidates whose benets include marked nodes whose benets include marked nodes result v variables want access via cell variable latter set fact benet nodes candidate variable either marked unmarked consequence following lemma lemma 1 let g stack optimization graph adjacent subset c maximal matching g let mg matched nodes c let nodes reachable alternating path unmatched node c b1 b2 2 r proof suppose contrary wlog b1 2 r alternating path c 2 mc b1 hence alternating path c 2 since c 2 mc rst edge path cannot since path must even number edges last edge must b2 also adjacent extend alternating path c reach b2 contradiction alternatively since alternating path c means path c must use edge hence alternating path c b2 contradiction example 3 figure 2 shows stack optimization graph program figure 3a together maximal matching mark nodes reachable alternating path starting unmatched node c case node floadt0 4g figure 2 marked nodes loadt 0 4 storek0 loadt 0 5 set v dened matching set candidate variables whose benet nodes unmarked case 0g resulting optimized program shown figure 3c requires 14 loads stores note accessing eld variables cell results program figure 3b requires 15 loads stores show choice v worse default accessing every candidate stack slot choice optimal theorem 1 let g stack optimization graph maximal matching g let load k0 v0 l0 r0 store k0 v0 l0 r0 dodgyk0 v0 l0 r0 load l0 r0 load k0 v0 checkk0 v0 c1 load k0 checkk0 c1 c2 load k0 checkk0 c2 c3 load k0 v0 l0 r0 store t0 dodgyk0 v0 l0 r0 load t0 l0 2 r0 2 load t0 k0 3 v0 3 checkk0 3 v0 3 c1 load t0 k0 4 checkk0 4 c1 c2 load t0 k0 5 checkk0 5 c2 c3 store t0 k0 dodgyk0 v0 l0 r0 load t0 l0 2 r0 2 load k0 t0 v0 3 checkk0 v0 3 c1 load k0 checkk0 c1 c2 load k0 checkk0 c2 c3 b c figure 3 original arbitrary program b transformed program maximal stack space savings c optimal transformed program matched nodes c unmatched nodes c let maximal proof let node c 2 rc matched otherwise would mc must matched node rb suppose contrary c matched b 2 rb alternating path c 0 2 mc b ends unmatched edge since starts unmatched edge c b hence extend path using matching edge b c hence c 2 r contradiction implies b 2 rb otherwise would augmenting path c 2 mc b since node rb either matches node rc unmatched denition benefitv rb since v contains exactly f benefitf show costv rc costv nodes c adjacent node benefitv rb since node rc matched node rb must adjacent node rb thus rc costv suppose contrary node c 62 rc adjacent b 2 rb c 2 rc hence alternating path c 0 2 mc c ends edge alternating path extended b since b c hence b 2 r contradiction thus rc netv jmbj consider set variables v 0 f let mb denition node unmatched matches node costv 0 hence jmc 0 j jmb 0 j also clearly mb 0 mb since nodes mb 0 unmatched netv 0 netv 53 merging results different maximal paths example 4 program figure 1a 3 maximal paths following t0 treek0v0l0r0 abbcce abbdde abbe stack optimization graphs maximal path shown figure 4 none maximal matchings leave unmatched cost nodes v get result along maximal path therefore access variables fk0 v 0 l0 r0g via t0 along every maximal path resulting optimized program shown figure 1b however general may compute dierent sets v along dierent maximal paths value v computed along given maximal path include given eld variable accessing eld variable via heap cell along maximal path may lead slowdown execution takes maximal path accessing eld variable via cell maximal path via stack slot maximal paths doesnt make sense need store eld variable stack slot rst interval use maximal paths accessed via stack slot gain nothing may lose something access via cell along maximal paths since try make sure optimization never slows program rst harm therefore access eld variable via cell maximal paths prefer access eld variable via cell ie eld variable sets v computed maximal paths value v compute along given maximal paths guarantee accessing variables v via cell instead via stack slots slow program however similar guarantee subsets accessing subset variables v via cell instead via stack slots slow program would therefore good idea simply take intersection loadl01 storel0 loadr01 storer0 storek0 loadv01 storev0 costs benefits loadl01 storel0 loadr01 storer0 storek0 loadv01 storev0 costs benefits loadl01 storel0 loadr01 storer0 storek0 loadv01 storev0 costs benefits figure 4 stack optimization graphs maximal paths abbcce abbdde abbe program figure 1a sets v computed along dierent maximal paths access variables intersection via cell instead restrict candidate set removing variables tersection restart analysis beginning new candidate set keep get set v maximal paths time restart analysis remove least one variable candidate set size initial candidate set thus puts upper bound number times need perform analysis 54 cost operations assumed loads stores cost reasonably close truth whole truth optimization deals two kinds stores four kinds loads kinds stores deal 1 stores eld variables stack 2 stores cell variables stack kinds loads deal 1 loading eld variables registers store stack initial segment 2 loading cell variable stack register later segments use register base loading eld variable cell 3 loading eld variable cell 4 loading variable stack slot transformation adds type 2 loads possibly type store removing type 1 stores possibly type 1 loads side eect also turns type 4 loads type 3 loads stores involved either side ledger go current stack frame means likely cache hits type 1 loads clustered means also likely cache hits example unication deconstructs cell arguments machine cache block contains four words type 1 loads required load arguments cell registers two cache misses type 2 loads occurring one per cell per segment clustered therefore much likely cache misses type 3 loads also likely cache loads loads type 1 typically followed within instructions store loaded value loads type typically followed within instructions load type 3 using loaded value cells address optimization turn type 4 load type 3 load nothing change distance load instruction next instruction needs loaded value types stores property value stored likely accessed next structions making pipeline stall data hazard unlikely type 1 2 loads hand signicant chance causing data hazard results stall chance cost resulting stall depends independent instructions scheduled compiler hardware execute load rst instruction uses loaded value means probability cost thus average cost stalls dependent program input data since relative costs dierent types loads stores depend average number length cache misses stalls generate relative costs programdependent lesser extent datadependent well therefore extended optimization four parameters give relative costs type 1 loads type 1 2 stores cost parameter loads also supposed account associated cost turning type 4 loads type 3 loads parameters form small integers extension consists replicating node stack optimization graph c times c cost parameter type operation represented node replicas given original node connectivity according lemma 1 retain property copies node either marked hence set v remains well dened theorem continues hold however matching algorithm generate solution whose net eect eg addition n type 2 cell variable loads removal type 1 eld variable stores arloadcost f ieldv arstorecost experiments set cellv arloadcost 3 three parameters cellv arstorecost f ieldv arloadcost f ieldv arstorecost 1 6 transforming code determined set v eld variables accessed cell variable deconstruction transform program adding clones deconstruction perform forward traversal procedure body starting deconstruction applying current substitution go initially current substitution identity substitution reach beginning segment v varsi 6 add clone decon struction eld variable f replaced new variable f 0 construct substitution eect replacing variable access cell copy clone deconstruction remaining new variables clone deconstruction never used proceed applying substitution reach end segment example 5 program given figure 3a r0g traversing forward decon struction reach segment 2 segment following call dodgy4 since vars2 v empty add clone deconstruction t0 fk0 2 v0 2 construct substitution 2g continuing traversal apply substitution balancedl0 r0 replacing balancedl0 2 r0 2 note k0 2 v0 2 never used reaching end segment 2 start segment 3 insert new clone deconstruction t0 construct new current substitution 3g processing later segments similar segments share intervals must interval ending start switch transformation inserts clone unication unique anchor starts segments figure 1a would mean inserting single clone deconstruction immediately call compare instead three clone deconstructions starts three switch arms show figure 1b however mercury code generator load variables cells needs code generated transformation therefore exactly eect code figure 1b optimization extends straightforward manner cases cell variable b eld variable another deconstruction eg c gbb2bk simply applying optimization rst deconstruction b fa1an applying optimization c achieve desired eect implementation optimization two passes procedure body rst pass backwards traversal builds data structures describing intervals segments goes along reaches deconstruction unication uses data structures nd candidate variables applies matching algorithm nd candidates accessed via cell vari able updates data structures ect results associated transformation would apply transformation yet instead transformations required optimizable deconstructions performed second forward traversal procedure 7 performance evaluation implemented optimization described paper melbourne mercury compiler initial testing found necessary add two tuning parameters onepath node ratio threshhold value opr accept results matching algorithm given path ratio number benet nodes number cost nodes computed matching least opr allpaths node ratio threshhold value apr accept results matching algorithm ratio total number benet nodes total number cost nodes paths least apr accepted result matching algorithm must pass thresholds fails one thresholds algorithm use cell access path eld variables store eld variables stack example 6 consider program figure 3 contains one path whose matching shown figure 2 ratio unmarked benet nodes unmarked cost nodes correspond benets costs accessing opr 100 optimization rejected stored stack slot since one path allpaths ratio example 7 program figure 1a three paths abbcce abdbde abbe matchings shown figure 4 ratio unmarked benet nodes unmarked cost nodes abbcce abdbde ratio abbe onepath node threshold reject transformation leading code figure 1b unless opr 233 three paths share benet nodes share one cost node one looks paths benet node costs node ratio 11666 hence allpath node threshold reject transformation apr 116 increasing onepath node ratio threshhold beyond 100 kind eect increasing numbers nodes allocated cell variable loads stores relative numbers nodes allocated eld variable loads stores advantage setting threshhold say 125 signicantly cheaper compilation time running matching algorithm graphs copies cost node four copies benet node allpath node ratio threshhold poses dierent test onepath node ratio threshhold dierent paths share benets elimination eld variable stores maybe loads principal component costs insertion cell variable loads segments controlling impact optimization executable size allpath node ratio threshhold useful controlling impact optimization executable size operations number nodes setting parameter 100 virtually guarantees optimization increase size executable cost operations nodes benet opera tions setting parameter 100 virtually guarantees application transformation strictly decrease size executable one cannot make concrete guarantee c compiler mercury compiler nal say executable size two reasons found thresholds nec essary first impacts pipeline eects cache program lines opt opt 100125 opt 133133 opt 150100 opt 150125 mmc 262844 5031 4484 891 4405 876 4494 893 4555 905 compress 689 1566 1567 1000 1566 1000 1565 1000 1566 1000 ray 2102 1342 1331 992 1329 990 1330 991 1329 990 table 1 performance evaluation eects discussed section 54 vary depending circumstances sometimes variations make transformed program faster original sometimes make slower thresholds allow us lter applications transformation highest chance slowing program leaving applications likely yield speedups second even original program transformed program performance respect cache pipeline eects reason prefer original program reason concerns happens cell variable becomes dead eld variables still alive original program garbage collector may able reclaim storage occupied cells dead eld variables since may live roots pointing transformed program reclamation possible live root reachable cell variable whose lifetime transformation articially extends therefore tested test programs several sets parameter values unfortunately whole parameter space big searching even close exhaustively really feasible due space limitations cannot present results parameter sets however four chosen representative results comments make still true one looks results date four sets parameter values cost cell variable load set three operations cost one since preliminary investigations suggested roughly right sets diered values one path allpath node ratio threshholds four combinations parameters values report 100125 133133 150100 150125 onepathallpath test programs following mmc test case melbourne mercury compiler compiling six largest modules code compress mercury version 129compress benchmark specint95 suite next two entries involve groups entries recent icfp programming contests 2000 entry ray tracer generates ppm les structural description scene 2001 entry sourcetosource compression program hypothetical markup language nuc mercury version pseudoknot benchmark executed 1000 times ray ray tracing program generating picture helix dodecahedron benchmark machine dell pc 16 mhz pentium iv 512 mb linux 2416 table 1 shows results rst column identies benchmark program second gives size source lines code measured word count program wc third column gives time taken program compiled without stack slot optimization following four groups two columns give time takes compiled stack slot optimization indicated set parameter values ratio time unoptimized time times derived executing benchmark program eight times discarding highest lowest times averaging remaining times table shows wide range behaviors compress optimization eect compress simply doesnt contain kind code optimization applies two programs icfp2001 ray stack slot optimization consistently gives speedup 1 icfp2000 stack slot optimization consistently gives slowdown around 1 nuc stack slot optimization gives speedup bit 2 sets parameter values slowdown bit 2 sets parameter values clearly indicates transformations performed stack slot optimization benecial others harmful dierent parameter values admit dierent proportions two kinds general raising threshold reduces probability slowdown also reduces amount speedup available one cannot guarantee given threshold value excludes undesirable applications transformation without also guaranteeing also excludes desirable ones icfp2000 parameter values explored range 100 150 admitted many wrong kind using parameter values 150 using higher costs cell loads stores may yield speedups icfp2000 also mmc stack slot optimization achieves speedups 9 12 range one considers one doesnt expect program spend much 30 time stack accesses also allocate memory cells make decisions perform calls returns arithmetic collect garbage results show elimination maybe one quarter stack accesses results look impressive interestingly previous benchmark runs may typical slightly earlier versions compiler yielded somewhat smaller speedups around 59 still pretty good results think reason largest complex program benchmark suite gives far best results also far program makes use complex data structures small programs tend use relatively simple data structures code traverse complex data structure also complex therefore big therefore reason believe performance stack slot optimization large programs likely resemble behavior mmc benchmark programs however fact stack slot optimization sometimes lead slowdowns means may good idea compilers turn automatically probably better let programmer testing eect benchmarking also shows stack slot optimization usually reduces sizes executables usually 01 05 cases increases tiny amount less 01 nice given many optimizations improve speed cost additional memory enabling stack slot optimization slows compilation slightly cases seen impact compilation time 02 range cases seen go 65 havent seen higher also looked eect optimization sizes stack frames tested version mercury compiler 8815 predicates whose implementations need stack frames parameter values explored stack slot optimization able reduce sizes stack frames 1331 predicates 151 also reduced average size stack frame averaged 8815 predicates 133 550 words 477 words oddly enough optimization leads trivial reduction less 01 stack space required execute compiler point compiler requires maximum stack space virtually frames stack predicates whose stack frame sizes aected optimization 8 conclusion related work optimization described replaces number stack accesses equivalent smaller number heap accesses many cases optimization reduce number memory accesses required execute pro gram optimization also reduce sizes pro cedures stack frames improves locality makes caches eective optimization lead significant performance improvements programs manipulating complex data structures default usage optimization needs conservative order avoid slowdowns parameter values 150125 would appear suitable gain maximum benet optimization programmer may need explore parameter space since conservative threshholds restrict benet optimization optimization dene somewhat similar rematerialization register allocation eg 1 2 sometimes easier recompute value variable keep register rematerialization optimization eectively split lifetime variable order reduce pressure registers stack slots key dier ence rematerialization variable independent variables whereas complexity problem arises interdependence choices stack slots fact mercury compiler long optimization took variable denitions form b f f constant cloned segments b needed order avoid storing b stack substituting dierent variables b segment unlike optimization presented paper optimization requires analysis also somewhat related partial dead code elimination 5 savings loads initial segment eectively result sinking calculation eld variable point later program code restrict candidate eld variables ensure sinking add overhead worth discussing optimization applied languages optimization applicable prolog even without mode information since even though rst occurrence unication may neither construct deconstruct execution copies added algorithm deconstructs good prolog compiler take advantage information execute eciently course without information determinism optimization dangerous simply assuming code deterministic reasonable quite large proportion prolog code unfortunately advantage likely visible wambased compilers since registers wam memory strict functional languages ml optimization straightforwardly applicable since mode information syntactically available code always deterministic optimization available next major release mercury system also available releaseoftheday mercury system httpwwwcsmuozaumercury near future 9 r register allocation spilling via graph coloring david je bernhard ste execution algorithm mercury tr rematerialization partial dead code elimination register allocation myampersandamp spilling via graph coloring
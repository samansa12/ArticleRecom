type specialisation imperative languages extend type specialisation computational lambda calculus firstclass references resulting specialiser used specialise selfinterpreter typed computational lambda calculus optimally furthermore specialiser perform operations references specialisation time possible b introduction far important program specialisation technique partial evaluation partial evaluation program transformation program parts input static part transformed new program partial evaluator performs operations enough data available reconstructs rest interpreter operates values partial evaluator operates values symbolic values code values combination code values partial evaluators appear two variants online offline online partial evaluators specialisation decisions taken inspecting symbolic values whereas offline variants specialisation decisions taken actually running specialiser decisions communicated specialiser means twolevel annotated programs annotations introduced hand means bindingtime anal ysis specialiser case interpreter twolevel programs type specialisation extension offline partial evaluation specialiser expressed collection nonstandard typing rules type inference rule specifies transformation expression e type via specialisation judgements gamma code part dynamic part result applying transfor mation 0 plays role symbolic values partial evaluation may contain values static supported belgian national fund scientific research nfwo work done visiting chalmers work done visiting chalmers appear proceedings icfp97 parts used static computations dynamic parts treated blackboxes setting specialisation corresponds building proof specialisation judgement advantage partial evaluation symbolic values residual types propagated via type unification 1 combination rich language residual types superior value propagation strategy type unification enabled hughes achieve optimal specialisation selfinterpreter typed lambda calculus feat achieved standard partial eval uation optimal specialisation context means specialising interpreter respect term yields term ffconversion problem presence universal type selfinterpreter standard partial evaluation able get rid tagging untagging operations universal type work serves two purposes first show type specialisation modular respect addition new type constructors references computations sec ond show type specialisation restricted purely functional languages also applies specialising operations computational effects performing operations references specialisation time language like ml formally extend type specialisation extension moggis computational metalanguage ml firstclass references demonstrate usefulness extension instantiating store monad result type specialiser oe ml ml extended mlstyle operations references distinguishing feature specialiser fact perform operations references statically specializer achieves optimal specialisation selfinterpreter oe ml also yields satisfactory results interesting problems described overview reader unfamiliar type speciali sation start short type specialisation primer information found hughes original paper introduce language oe ml extension moggis computational lambda calculus firstclass references first step towards full specialiser state specialisation rules treatment dynamic reference operations apply specialiser self interpreter oe ml achieve optimal specialisation second step add specialisation rules static references apply specialiser interpreter lazy functional language implements laziness using updatable information found section closures next discuss extension state threads state new postprocessing rules finally assess work respect partial evaluation consider related work conclude type specialisation primer type specialisation form program specialisation types play central role rather saying one term specialises another term say source term type specialise residual term type e carry information control specialisa tion particular bindingtimes type formers come static dynamic variants mark dynamic ones underlining usual residual types sufficiently refined carry static information means static values need appear residual terms exam ple static integer constants specialised dummy val residual type records integer dummy value represents residual type information enough specialise expressions use static values appropriately example lift operation converts static integer dynamic one specialises constant value given residual type argument welltypedness source term checked specialisation welltypedness residual term checked constructed specialisation thus specialiser embodies residual typechecker unifications typechecker propagate static information specialisation example specialising dynamic function application yields unification assigns x residual type 3 sufficient information perform static addition specialise lift 4 type specialisation propagate static information effectively partial evaluation modifying example slightly specialise since unification assigns x residual type 3 enables static addition performed allowing f assigned residual type 3 4 enables lift specialised constant done even though f dynamic function whose calls may unfolded conventional partial evaluators allow dynamic functions return static results since derive static values reducing expressions normal form dynamic function applications must reduced type specialisation inherently monovariant modify example longer specialised f would need assigned 3 int 4 int residual types polyvariance easily added via new source type poly constructor poly selector spec expression poly e specialises tuple specialisations e spec e specialises selection tuple rewrite example poly xlift x1 spec f 3 spec f 4 int specialises f residual type 3 int residual type information enough enable spec choose right version call conversely type information spec enough enable poly decide versions create alternatively could change f example static function note applications longer lined static functions unfolded specialisation example call f replaced specialisation body course two specialisations different order unfold static function applications specialiser represents static function closure static parts closure bound variable name body residual types free variables make residual type static dynamic part tuple becomes residual term residual type static function says nothing type argument result function freely applied different static arguments different calls example f free variables residual term empty tuple dummy value result specialisation examples reveal static computations leave undesirable residue dummy values specialised pro grams optimal specialiser must remove static computations completely fortunately dummy values removed postprocessing phase call void erasure completely static expressions yield residual types single element example 3 4 3 4 3 theta 4 expressions safely replaced dummy value ffl types void using isomorphisms eliminate void components void parameters course letbound variables void type void erasure often simplifies residual programs drastically example last two specialisations become optimal specialisation typed interpreters demands specialise universal type interpreters poly e j spec e terms poly types poly poly figure 1 twolevel source language 1 e 0 figure 2 basic specialisation rules use represent values appropriately example interpreter calculus integers might use type data represent values example static sum type constructors encode type interpreted values must known statically therefore embed static constructors residual types rather residual terms example residual type records fact num constructor applied need appear residual term case expressions static sums simplified one branch given residual type inspected ex pression neither runtime type tags runtime tag checks need appear residual programs interpreter oe ml specialised optimally given course partial evaluators also implement static sum types keep track constructors statically specialise interpreters optimally need able return values static sum type dynamic function type specialiser deriving static information type inference problem partial evaluator using reduction impossible figure give syntax twolevel type system large fragment metalanguage essentially twolevel version simplytyped calculus full language also includes sums products omitted allow types recursive special syntax point wish emphasise types freely formed according syntax given wellformedness conditions argument result dynamic function type must dynamic neither side conditions typing rules requiring example variable bound dynamic let dynamic type extra conditions essential part twolevel calculi needed make partial evaluation possible key advantage type specialisation conditions dropped standard semantics metalanguage usual semantics callbyname calculus static dynamic constructs distinguished poly e spec e semantics e annotations control specialisation affect meaning original program type specialisation specified quite simply via specialisation rules let us infer judgements form context gamma tells us specialise variables via sequence entries selection figure 3 computational metalanguage specialisation rules appears figure omitted rules static functions little complicated express compare rules static dynamic let expressions difference static let un folded dynamic one precisely static information bound variable x available cases contrast partial evaluation variable bound dynamic let must dynamic specialisation rules complicated implement usual type inference rules syntaxdirected description implementation beyond scope paper found 3 metalanguage effects languages effects invariably harder treat formally purely functional languages one reason evaluation order suddenly becomes important even constructs pure subset adding references unrestricted assignment metalanguage would therefore change semantics every construct potentially invalidate specialisation rules presented avoid chosen work moggis computational metalanguage ml explicitly distinguishes value type computation effects delivering result type latter assigned computation type trivial computations ef fects created unit operator j results computations inspected using mlet x e1 e2 combines computations e1 e2 sequence binds x value e1 delivers evaluation e2 extensions syntax typesystem metalanguage shown figure e1 e2 computations effects type error write e1 e2 instead must write mlet x1 e1 mlet x2 e2 j x1 making evaluation order explicit similarly pass result e1 function f must write mlet x e1 f x making explicit e1 evaluated call write f e1 instead would compute e1 first would pass entire computation parameter f invoked later f pleasure think value type suspended computation invoked mlet many different kinds effects represented moggis framework depending types operators j mlet interpreted represent side effects store example interpet computation function store beforehand result store afterwards mlet x e1 note translation passes store e1 produces e2 x scope e2 operations create assign references interpreted suitable functions computation type interpretation j mlet called monad provided satisfies socalled monad laws mlet x e mlet x mlet e1 e2 mlet e1 mlet x e2 e3 third law must occur free e3 haskell provides imperative operations exactly way course imperative languages distinguish computations explicitly however well known calculus implicit effects simply translated several different ways ml translation making different evaluation order explicit extending callbyvalue translation map say ml algol programs metalanguage thus claim type specialisation also applicable languages simply mapped intermediate form makes evaluation order explicit first moggis language conservative extension calculus meaning pure subset remains unchanged isomorphisms void remain true function type effects must computation type sides represent suspended com putation big advantage us type specialisation void erasure rules pure metalanguage remain valid effects added need define new rules new constructs specialisation rules j mlet cannot given yet depend kind effects interested note operations come static dynamic versions indeed interested static dynamic effects since kinds may used one computation need one computation type therefore one version monad operators specialising operations state approach specialisation imperative operations three steps first consider situation operations deferred run time already enough achieve optimal specialisation self interpreter sec move consider static effects finally section show combine figure 4 operations dynamic references residual types 1 e 0 figure 5 specialisation rules dynamic state two requires us factorise monad static state transformer second monad specialiser manipulate static state 41 specialising dynamic state shall extend metalanguage operations cre ate inspect update dynamic references additional syntax typing rules given figure ref creates reference reads contents assigns course three operations computation type assumption monadic operations dynamic specialisation rules turn rather straightforward see fig monadic operations simply specialise subexpressions reconstruct selves spite simplicity still possible achieve interesting results since dynamic references contain static information residual type propagated rest computation via unification example specialising mlet r ref 2 mlet x j lift yields mlet r ref ffl mlet x j 3 int static value 2 present runtime preserved residual type r ref 2 r dereferenced know statically result 2 even though r dynamic see specialised expression reference r still exists residual program useless contents void type final phase type specialisation void erasure extended remove references operations thus transform term j 3 assume reading writing operations references testing references equality also available erasing void references would correct since residual type dynamic reference includes residual type value contains values assign must static part example value assign r 2 dynamic reference contains partially static value static part must assignment dynamic part vary example reference type ref univ univ defined sec created mlet r ref num lift 2 could later assigned num lift 3 num lift 4 values residual type num int could assigned value form fun f residual program would contain reference int would assigned untagged values 2 3 4 want reference contain many different static values obliged use static reference situation comparable difference static dynamic functions dynamic function specialised one static argument whereas static function unfolded applied number data data case e case eval env e 1 case eval env e case eval env e1 case eval upd env v e2 case eval env e e 1 case eval env e1 eval iwrong figure selfinterpreter optimal specialisation 42 optimal specialisation specialiser already capable optimal specialisation show give selfinterpreter metalanguage figure interpreter recursive see specialisation rules recursion since interpreted language typed represent values static sum type expression type univ specialised residual type example num int fun num int us type value represents type tags known specialisation time corresponding tag tests simplified away specialiser consequence interpreter specialised welltyped programs supplying illtyped input lead failure residual type inference references needed write self interpreter use references interpreter model references interpreted program references assigned values one type cause interpreted language welltyped specialisation values assigned static part specialise interpreter term obtain essentially term result ffconversion operations interpreter give rise residual code marked dynamic lift interpretation constants monadic operations mlet j inspection clear cases eval specialises copy second argument provided true recursive calls example case constants contains one lift generates residual constant case expressions contains one dynamic generates residual expression two cases break pattern rf generate additional mlet j however always removed postprocessor applies monad laws case rf residual code always mlet r ref e j r second monad law equal ref e case residual code form mlet z e1 e2 j ffl since z type void equivalent mlet z e1 e2 j z equal e1 e2 second monad law postprocessor performs simplifications specialisation interpreter therefore optimal fact postprocessor may simplify additional dexes accurate specialise interpreter term obtain reduct original term claim specialisation still considered optimal would unreasonable refuse specialiser sometimes performs simplifications optimality requires 43 specialising static state dynamic references created updated runtime consequently cannot know contents special isation insist contents static part know specialisation time example expression mlet r ref 2 mlet z r 3 r would cause specialisation error since r used ref 2 ref 3 residual types could avoid error making reference contents dynamic mlet r ref lift 2 mlet z r lift 3 r specialisation succeeds since r residual type ref int hand useful simplification performed constrast static references created updated specialisation specialiser keeps track contents static state may freely assigned residual types 1 s0 e 0 figure 7 specialisation rules static state values different residual types different times example rewritten using static references mlet r ref 2 mlet z r 3 r specialisation succeeds produces section shall consider specialisation language static references new operations types analogous dynamic references figure difference omit underlines specialised dynamic state able treat monad operations black box effects deferred runtime specialiser need know anything treating static effects longer case let us therefore say explicitly computation type state computations represented functions static state tuple contents existing static references actually build tuples pairs let us define little syntactic sugar values types also obvious translate pattern matching combinations projections source programs static state implicit residual programs represent explicitly tuple pass explicitly residual computations encounter problem residual type static state tuple type whose components residual types contents references computation may modify residual types thus residual pro gram computation may modify contents state type residual computations types form oe residual type state beforehand oe 0 type afterwards type monad means cannot express residual program terms monad operators however st much common monad example give sensible definitions mlet monad laws hold call quasimonad 2 specialisation rules static references given figure rules j mlet generate code pass state around explicitly notice rule mlet residual types propagate static information store e1 e2 via shared variable oe 1 creating static reference third rule enlarges static store one element static reference may well dynamic contents become part residual static store static information need new reference location refers introduce new form residual type loc represent ith location dereferencing assignment operations generate functions access modify residual store appropriately notice residual types record precisely static contents every reference operation last three rules cannot applied unless shape static store known last two cannot either applied unless address static location also known specialisation information propagated context unification considered specialisation error possible determine size static store specialisation example suppose specialise term mlet x ref lift 2 mlet ref 3 mlet z x lift 4 j x initially empty static store result applying 2 quite different steeles pseudomonads 1 s0 e 0 figure 8 specialisation rules mixed state specialisation rules s3 x s3 s0 x z void types removed void eraser also deletes void components tuples result void erasure case s3 s3 use postprocessor contracts trivial firedexes actual parameter variable since specialisation rules introduce many final result postprocessing static operations store removed resulting program passes around dynamic values held residual programs generate approach purely functional pass around dynamic components static store explicitly alternative approach considered store dynamic components dynamic store instead thus every static reference dynamic contents would associated reference residual program holding dynamic part contents remember static reference hold values different residual types different times ex ample reference type ref univ could hold num n fun f different occasions single residual reference hold dynamic parts n f different types could perhaps associate static reference tuple references residual program one type value assigned dereference operation would course know statically associated residual references held current dynamic part contents reference creation would awkward one corresponding residual references would uninitialised problems probably soluble feel approach presented considerably simpler 44 specialising mixed state know specialise static dynamic state separately relatively straightforward specialise together trick separate monad two parts static part manipulate explicitly specialiser dynamic part treat black box therefore interpret monad type monad type used residual programs previous section residual computations may change type static state types form specification rules modified produce terms type modify rules dynamic reference operations pass static store unchanged modify rules static reference operations construct trivial 0 computations using j modified rules given figure 45 specialisation lazy interpreter demonstrate capabilities specialiser specialising lazy interpreter term laziness implemented using updatable closures application abstraction passed reference closure evaluated reduces argument weakhead normal form performs update reference cell provided bounded number closures created reference operations performed statically figure shows interpreter specialising interpreter term xxx1 2 yields residual type st hi hvl num inti num int output store contains vl num int constructor vl tells us corresponding closure evaluated specialisation time constructor num also manipulated specialisation time means eliminate tagging untagging residual pro grams remains stored run time integer residual term simplication see section let f b resulting program although bit awkward expected structure f corresponds abstraction b argument 1 2 build closure closure b takes store returns result addition f takes closuredereference taken place specialisation time applies closure itselfthe closure sole element store result application computation taken apart monadic let perform addition tuple result updating store application store may seem strange perfectly admissible recursive type int result void erasure delimiting effects type specialiser able among things derive static information result dynamic conditional example b num lift tells us statically result tagged num course possible residual program well typed two branches must residual type arms conditional computations implies must leave static store state awkward meet restriction means references created one branch exactly corresponding references must created assigned contents static part partial evaluators imperative languages handle problem forbidding modifications static store arms dynamic conditional makes static store much less useful solution problem support stack discipline static store introduce store prompt e causes specialiser deallocate static references created e specialisation complete see fig use store prompts arms dynamic conditional arm refer previous static store create use local references without causing residual type mismatch course store prompts used local references escape enclosed expression explained operations static store specialised size store known specialisation rules propagate static store operation operation initial size store known size derivable subsequent operations course intend initial store empty far glossed specify fact reasons wanting specify size store consider function tmlet r ref 1 mlet v liftv uses static store internally compute 1 functions type intm int cannot specialised without knowing size static store point called seems unfortunate since doesnt refer nonlocal references moreover function called two points different static stores would need make polyvariant construct two different specialisations even though doesnt access different stores would case even inserted store prompt functions definition solution run computation functions body new empty static store define two new operators differ treatment dynamic store see fig runm e turns computation effects one without computational perspective runs e completely new static dy namic store e neither access modify enclosing store state thread residual type involve monad residual code must include effect delimiter runm runm e runs e type new empty static store threads dynamic store e access modify nonlocal dynamic references residual type still dynamic store ensure references neither escape runm e imported outside analogously runm e static references gloss problem apply launchbury peyton joness solution related problem specialisation rule runm e see fig applies residual quasimonad e empty initial static state runs resulting dynamic computation discards final static state result value residual type 0 rule runm e also applies residual quasimonad empty static state final state oe 0 dis carded contrast runm resulting expression might still induce effects runtime reason thread resulting computation dynamic computation thread specialise initial example two ways mlet v mlet v data data data case e case v mlet case b ap mlet ref bl 0 mlet b cl mlet c eval env e2 vl c case f pl eval env e1 mlet b eval env e2 case case b eval iwrong figure 9 lazy interpreter figure 10 typing specialisation rules store prompts specialiser combine firstclass functions static references due dussart thiemann conventional partial evaluator dynamic functions cannot static arguments consequently always specialises bodies dynamic expressions empty static store runm essentially simulates behaviour effect delimiters runm runm rather blunt instruments ideally would like able specialise computation knowing contents static references actually refers likewise would like able invoke specialisation different static stores provided references actually used contents requires polymorphism residual programs want invoke residual function stores different residual types generation polymorphic programs type specialisation far open problem must solved better treatment static stores possible 6 postprocessing remarked oe ml pure language sense isomorphisms like void still valid therefore techniques void erasure lambda calculus still valid 61 void erasure void eraser follows one simple principle replace every expression whose type denotes singleton set ffl apart standard situations involving products sums function types described hughes two additional type constructors consider ref keeping references type ref void makes sense unless equality operation references erased absence operation however type void denotes computation returning void computation may well affect dynamic state cannot erased since regard ref void useless replace figure 11 type rules store delimiters figure 12 specialisation rules store delimiters operations processing appropriate monadic units process removes operations dynamic state residual operations static state expressed explicit store passing simplification rules standard types suffice simplify 62 monadic simplifications residual programs written monadic style contain lot redundant monadic let unit expres sions partly due actions preceding void erasure expressions present ideal targets applying three monad laws moggi proved ml sound complete respect monadic mod els specifically model uses state transformers therefore application monad laws safe sense duplicate discard reorder computations type x void application rule drop let e 0 entirely type x void case let postprocessor unfold lets general use simplication terms form appear quite often applying preceding transformations finally simplification discards trivial computations wrapped runm runm j e e 63 simplifications due explicit storepassing style residual program contains many trivial firedexes like xe x convert letexpressions apply simplifications outlined serious fi reductions performed explicit representation store tuples introduces lot extraneous tupling tuple operations eliminated via arity raising phase finally explicit storepassing introduces many jredexes top computations affect static store therefore void eraser also performs jreductions assessment type specialisation enhances partial evaluation information propagation unification enables sideways information exchange source programs execution tree whereas partial evaluation restricted paths execution tree consequence residual programs cannot constructed bottomup manner rather program fragments constructed demanddriven order prescribed flow information much power type specialisaton stems refined type language used type language able express single element types play role symbolic values partially static values standard partial evaluation contrast partial evaluation twolevel type discipline type specialisation impose wellformedness conditions like abstraction dynamic argument result must also dynamic another instance fact dynamic references may hold static values liberality unique type specialisation key optimal specialisation results typed functional languages reported hughes initial work allows information static tags communicated dynamic functions however wellformedness conditions heart traditional bindingtime analysis bindingtime analyser constructs least static assignment wellformed types terms dynamic inputs force computations dynamic also via wellformedness conditions static type assignment always best leads strongest specialisation type specialiser contrast check twolevel program welltyped cannot infer best assignment twolevel types onelevel program absence wellformedness constraints many operations made static mean example interpreters paper chose make univ static sum type type tags would removed specialisation consequence interpreters specialised welltyped programs interpret typed language chosen make univ dynamic sum instead type tags would remained residual programs would able specialise interpreters arbitrary programs interpreters accept untyped language neither alternative obviously better believe choice made automated analysis assignment bindingtimes interpreter essentially way specify static semantics interpreted language creative activity furthermore type specialisation also performs program analysis residual program constructs residual program example shown hughes work constructs firstifying twolevel interpreter type lambda calculus type specializer performs closure analysis construction recursive residual types fly 8 related work 81 type constructor specialisation hughes introduces type specialisation simplytyped lambda calculus products sums current work conservative extension moggis computational metalanguage type specialiser embodies constructor specialisation extends higherorder languages hagiya iino consider weaker variant constructor specialisation call data type specialisation lisplike language set extension standard partial evaluation framework consisting extended bindingtime analysis specialiser expressed nonstandard interpreter constructs residual program compositional manner bechet gives account similiar technique geared towards typed languages constructor specialisers type specialiser construct residual program order 82 partial evaluation partial evaluators traditional imperative languages like fortran c pascal modula2 perform side effects specialization time however none incurs problems inherent higherorder control flow face problems dealing pointers similar problems firstclass references present work type specialisation deals satisfactorily language higherorder control flow firstclass references partial evaluators higherorder functional languages quite common attempt handle side effects follow approach bondorf danvy deferring side effects like operations references assignments global variables io run time recently approaches perform partial evaluation imperative programs static operations references moura consel lawall show use schism partial evaluator pure scheme poy variant bindingtime analysisto specialise programs c language transforming sophisticated variant storepassing style approach avoids construction new program analyses new partial evaluation techniques imperative programs dussart thiemann constructed offline partial evaluator simplytyped lambda calculus firstclass references system traditional monovariant bindingtime analysis ensures errors specialization time bindingtime analysis based effect system system automatic contrast type specialiser works manually annotated programs 9 conclusion type specialisation adapts seamlessly specialisation imperative languages unification gives us necessary power achieve optimal specialisation version moggis computational metalanguage firstclass references use computational metalanguage oe ml turned big win first add rules new constructs language type specializer existing rule changed contrast specializer dussart thiemann every specialization rule changed order thread state computation second specialiser completely independent evaluation order sequence monadic operations fixed remaining parts program specialized without committing specific evaluation order third conjecture monadic approach allows modular extensions cater ex ceptions nondeterminism etc acknowledgement thank anonymous reviewers mads tofte valuable comments r program analysis specialization c programming language partial evaluation numerical programs fortran removing value encoding using alternative values partial evaluation stronglytyped languages automatic autoprojection higher order recursive equations automatic autoprojection recursive equations global variables abstract data types efficient analysis realistic offline partial evaluation practical aspects specialization algollike programs tour schism general approach runtime specialization application c partial evaluation polyvariant constructor specialization partial evaluation higherorder languages state building interpreters transforming stratified monads binding time analysis data type specialization functional programming languages computer architecture type specialisation partial evaluation automatic program generation stronglytyped selfapplicable partial evaluator modular denotational semantics compiler construction ml partial evaluation using setbased analysis techniques partial evaluation imperative languages constructor specialization computational lambdacalculus mon ads bridging gap functional imperative languages automatic online partial evaluation tr computational lambdacalculus monads arity raiser use program specialization techniques partial evaluation imperative languages automatic autoprojection recursive equations global variable abstract data types stronglytyped selfapplicable partial evaluator automatic online partial evaluation twolevel functional languages automatic autoprojection higher order recursive equations partial evaluation automatic program generation partial evaluation semanticsbased program manipulation constructor specialization generic account continuationpassing styles building interpreters composing monads lazy functional state threads polyvariant constructor specialisation state haskell general approach runtime specialization application c functional programming languages computer architecture partial evaluation removing value encoding using alternative values partial evaluation stronglytyped languages handwriting program generator generators practical aspects specialization algollike programs type specialisation lambdacalculus new paradigm partial evaluation based type inference ctr john hughes type specialization acm computing surveys csur v30 n3es sept 1998 john hatcliff foundations partial evaluation functional programs computational effects acm computing surveys csur v30 n3es sept 1998 kedar swadi walid taha oleg kiselyov emir pasalic monadic approach avoiding code duplication staging memoized functions proceedings 2006 acm sigplan symposium partial evaluation semanticsbased program manipulation january 0910 2006 charleston south carolina gilles barthe john hatcliff morten heine b srensen cps translations applications cube beyond higherorder symbolic computation v12 n2 p125170 september 1999
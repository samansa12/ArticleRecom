observational proofs rewriting observability concepts contribute better understanding software correctness order prove observational properties concept context induction developed hennicker hennicker formal aspects computing 34 1991 326345 propose paper embed context induction implicit induction framework bouhoula rusinowitch journal automated reasoning 142 1995 189235 proof system obtain applies conditional specifications allows many rewriting techniques refutation false observational conjectures reasonable assumptions method refutationally complete ie refute conjecture observationally valid moreover proof system operational implemented within spike prover interesting computer experiments reported b introduction observational concepts fundamental formal methods since proving correctness program respect specication essential able abstract away internal implementation details data objects viewed equal cannot distinguished experiments observable result idea semantics specication must describe behaviour abstract data type viewed external user due 14 though lot work devoted semantical aspects observability see 4 classication proof techniques studied 3572524 even less implemented recently increasing interest behaviouralobservational proofs projects cafeobj see eg 27 new approach validation objectoriented software promoted b jacobs 1819 paper propose automatic method proving observational properties conditional specications method relies computing families email addresses adelbouhoulasupcomrnutn adel bouhoula rusiloriafr michael rusinowitch preprint submitted elsevier science well chosen contexts called critical contexts cover sense observable ones families applied induction schemes inference system basically consists extending terms critical contexts simplifying results powerful rewriting machinery order generate new subgoals advantage approach allows also disproving false observational conjectures method even refutationally complete interesting class specications prototype implementation top spike prover 9 computer experiments reported given examples treated fully automatic way program related works hennicker 16 proposed induction principle called context induction proof principle behavioural abstractions property observationally valid valid observable experiments experiments represented observable contexts context observable sort signature specication distinguished subset sorts specied observable hence property valid observable experiments valid corresponding observable contexts context c viewed particular term containing exactly one variable therefore subterm ordering denes noetherian relation set observable contexts consequently principle structural induction induces proof principle properties contexts observable sort called context induction approach provides uniform proof method verication behavioural properties implemented system isar 3 ever concrete examples verication non trivial task requires human guidance system often needs generalization current induction assertion nested context induction achieve proof malcolm goguen 25 proposed proof technique simplies hennicker proofs idea split signature generators dened functions proving two terms behaviourally equivalent comes prove give result observable contexts built dened functions provided generators verify congruence relation wrt behavioural equivalence proof technique ecient optimization hennicker proofs bidoit henniker 6 investigated rst order logic theorem prover used prove properties observational framework method consists computing automatically special contexts called crucial contexts enriching specication automatically prove observational properties method developed proof equations specications one sort observable sides fails several examples cf stack example possible compute crucial contexts bidoit hennicker 7 also investigated characterization behavioural theories allows proving behavioural theorems standard proof techniques rst order logic particular propose general conditions innite axiomatization observational equality transformed nitary one however general automatic procedure generating nite axiomatization observational equality puel 30 adapted huethullot procedure proof consistency wrt nal model lysne 24 extends bachmairs method proof consistency nal algebra framework proof technique based special completion procedure whose idea consider critical pairs emerging positioning rewrite rules equations also emerging positioning equations rewrite rules approach restricted equations requires ground convergence property axioms order sound case ground convergence needed refutational completeness preliminary version paper presented march 1998 2 comparison system study admits powerful simplication techniques instance contextual simplications allowed conditional rules exists recent related works 1226 instance circular coinductive rewriting approach goguen rusu 12 also based computing special contexts however contexts cannot used general refutation approach also allows simplication techniques since eg clause smaller current subgoal used induction hypothesis contextual rewriting available unlike others also allow specications relations constructors section 3 introduce approach simple example give section 4 concepts algebraic specications rewriting required order describe observational semantics section 4 induction schemes section 6 inference system section 7 finally report computer experiments prototype implementation section 8 future extensions technique sketched conclusion 3 objectoriented example observational specication techniques well adapted description objectoriented systems non observable sorts used model states objects states observed applying methods attributes hence observational techniques allow describe systems abstract way hiding implementation details objects considered behaviourally equivalent whenever produce reactions observable experiments actions transitions messages consider instance simple class points given cartesian coordinates class point private distance nat methods create incry decry assume point instances initially located origin 0 moved methods incrx incry resp decx decy incrementing coordinates two accessors getx gety allow consult public attributes xy point instance also comes private attribute whose value distance covered since creation distance incremented call incrx incry given two fresh instances class p p prove behaviourally equivalen although attributes identical behavioural equivalence dened using observable contexts context term describing experience applied object instance getx observable context point class approach relies computing families well chosen contexts called critical contexts families cover sense observation contexts applied induction schemes point example critical contexts getxz point getyz point inference system basically consists applying critical contexts conjectures simplifying results rewriting rules order generate new subgoals instance proving behavioural equivalence b b reduces proof getxb getya getyb subgoals simplied tautological equations nishes proof 4 basic notions assume reader familiar basic concepts algebraic specications 37 term rewriting equational reasoning many sorted signature pair f set sorts f set function symbols short many sorted signature simply denoted f assume partition f two subsets rst one c contains constructor symbols second set dened symbols let x family sorted variables let f x set sorted terms stands set variables appearing term linear variables occur vart empty ground term set ground terms arbitrary nonempty set let fg f arity n f function n pair fa called algebra carrier algebra sake simplicity write denote algebra f fa nonambiguous substitution assigns terms appropriate sorts variables domain dened xg term denotes application applies every variable ground term ground substitution denote syntactic equivalence objects let n set sequences positive integers term p ost n denotes set positions expression tu denotes subterm position u write ts u resp ts indicate subterm position u resp positionthe top position written let tu denote symbol position u position u term said strict position position u term linear variable position x occurs otherwise u non linear variable position linear variable term variable occurs depth term dened follows constant variable otherwise denote transitive irre exive relation set terms monotonic implies ws u wt u stable per instantiation implies satises subterm property f note conditions imply noetherian multiset extension denoted equation formula form l r conditional equation formula following form written v n called conditional rule flg fr substitution precondition rule v n term l lefthand side rule rewrite rule c l r leftlinear l linear set conditional rules called rewrite system constructor free root lefthand side rule let term c x called constructor term rewrite system r leftlinear every rule r leftlinear dene jrj maximal depth strict positions lefthand sides let r set conditional rules let term u position write tl u r tr u substitution conditional rule v n r r 2 1 n exists c r c rewriting extended literals clauses expected term irreducible normal form term r term ground reducible ground instances reducible completely dened ground terms root f reducible terms c say r suciently complete symbols completely dened clause c expression clause c horn clause 1 clause c positive clause tautology either contains subclause positive literal clause c logical consequence e c valid model e denoted e say c inductively valid e denote e ground substitution exists j say two terms joinable denoted r v r v term v rewrite system r ground convergent terms u v joinable whenever r 5 observational semantics notion observation technique see eg 4 introduced mean describing observed given algebra various observation techniques proposed literature observations based sorts 36312816 operators 1 terms 34155 formulas 333422 observational specication obtained adding observation technique standard algebraic specication observation technique based sorts easily extended operators observational semantics based weakening satisfaction relation informally speaking behavioural properties data type obtained forgetting unnecessary information objects distinguished experiments considered observationally equal 51 contexts framework algebraic specications experiments formally represented contexts observable sorts operators signature specication thus showing certain property valid observable experiments formally reason contexts observable sorts operators notion context use close one used bidoit hennicker 6 denition 51 context let f x term algebra signature 1 context context nonground term c 2 distinguished linear variable called context variable c indicate context variable occuring c often write cz instead c sort z variable z sort context called empty context sort 2 application context cz term 2 f x sort denoted ct dened result replacement z cz context c said applicable application context equation b equation 3 exception varc denote set variables occuring c context variable c context c ground 4 subcontext resp strict subcontext c context subterm strict subterm c context variable next lemma gives properties contexts lemma 52 let cz c 0 z 0 two contexts c 0 sort term sort 0 substitution z 62 dom notion context generalized clauses clausal context clause list contexts applied order equation negated clause set contextual variables clausal context set contextual variables components denition 53 clausal context let set contexts c clausal context wrt clause list contexts applicable e application c c denoted cc equal clause v dene composition clausal contexts way contexts denition 54 let n two clausal contexts 2 1n c applicable c 0 composition c c 0 denoted cc 0 clausal context fc 1 c 0 g clausal contexts induce ordering relation clauses call context subsumption since extension classical subsumption ordering viewed generalization functional subsumption rule dened 32 useful redundancy elimination rstorder theoremproving denition 55 context subsumption clause c contextually subsumes c 0 exists clausal context c substitution c 0 c note strict part ordering wellfounded argument standard subsumption lemma 52 extended clausal contexts straightforward way lemma 56 let c c 0 two clausal contexts let c clause substitution contextual variables c dom 52 observational validity notion observational validity based idea two objects given algebra observationally equal cannot distinguished computations observable results computations formalized contexts dening observational specications need specify observable sorts notion observational specication generalized bobjs hidden logic 12 cafeobjs coherent hidden algebra logic 26 well bidoit hennickers observational logic 7 also allowing nonbehavioral operations expect results generalize directly general framework denition 57 observational specication observational specica tion sp obs quadruple f e obs f signature e set conditional equations obs set observable sorts following assume observational specication sp obs given signature specication stack sorts nat stack observable sorts nat constructors 0 nat nat nat nil stack nat stack stack dened functions pop stack stack axioms toppushisi popnilnil poppushiss fig 1 stack specication example 58 specication stack figure 1 observational speci cation fnatg denition 59 observable context context whose sort belongs obs observable clausal context clausal context whose component contexts observable set observable contexts denoted c obs sake simplicity also denote set observable clausal contexts example 510 consider specication stack figure 1 innite ly many observable contexts topz stack toppopz stack denition 511 terms b observationally equal c 2 c obs denote e simply obs b example 512 consider stack specication figure 1 equation satised initial algebra however intuitively observationally satised observe elements occurring pushtops pops proved formally considering observable contexts lemma 513 relation obs congruence proof relation obs obviously equivalence relation us prove fa sucient show induction j immediately us show fa consider arbitrary observable context cz sort induction hypothesis deduce since observable context transitivity ind cfa induction step completed 2 main goal generalize implicit induction proofs observational framework particular sorts observable theory obtain reduces standard initial one however generalization initial semantics straightforward since specications admit conditional axioms instance let two ground equations assume e 6j ind may e v case v reason adopt semantics close one dened p padawitz 29 denition 514 observational property let c v n say c observational property observationally valid denote e ground substitutions e obs congruence e quotient algebra respect obs properties f e studied 29 particular shown f e nal class termgenerated visibly initial algebras proof system develop following sections dedicated derivation validity algebra f e theorem 515 let c e proof simple consequence fact f e 6 induction schemes purpose section introduce ingredients allowing us prove disprove observational properties task amounts general check innite number ground formulas validity since innite number instances innite number contexts considered building ground instances induction comes play test substitutions provide us induction schemes substitutions critical contexts provide us induction schemes contexts general possible consider observable contexts however cover contexts sucient prove observational theorems reasoning ground irreducible observable contexts rather whole set observable contexts following denote r conditional rewriting system denition 61 cover set cover set denoted cs r nite set irreducible terms ground irreducible term exist term cs ground substitution introduce notion cover context used schematize contexts note cover context need observable unlike crucial contexts 6 intuitive idea use cover context extend conjectures top order create redexes obtained formulas simplied axioms induction hypothesis denition 62 cover context set cover context set cc minimal inclusion set contexts ground irreducible context c obs z substitution varc c subcontext c obs cover context set specication stack fz nat topz stack popz stack g context pushi z stack cannot belong cover context set since z stack poppushi z stack reducible note usually innitely many possible cover context sets instancefz nat topz stack toppopz stack poppopz stack g also cover context set similar notions called complete set observers proposed hennicker 17 recently another close concept introduced goguen et al 12 cover sets cover context sets fundamental correctness method however cannot help us disprove non observationally valid clauses purpose introduce new notion critical context sets use test sets dened 8 following rene cover context sets prove behavioural properties also disprove non valid ones need rst introduce following notions context c quasi ground reducible ground substitution term strongly irreducible none nonvariable subterms matches lefthand side rule r positive clause c pos w n strongly irreducible c pos tautology maximal elements fa wrt strongly irreducible r induction position f 2 f position p exists r rewrite rule lefthand side ft position ft function symbol nonlinearvariable subterm given r set induction variables term subset variables whose elements occur subterm form fs term 2 1n induction position f notion induction variables extended clauses expected test sets test substitutions dened simultaneously denition 63 test set test substitution test set cover set following additional properties instance ground reducible term test substitution matches lefthand side r ii instance positive clause c pos test substitution strongly irreducible c pos inductively valid wrt r test substitution clause c instanciates induction variables c terms taken given test set whose variables renamed following denition introduces notions critical context set critical clausal context denition 64 critical context set critical clausal context critical context set cover context set positive clause c pos cc pos strongly irreducible test substitution c pos c clausal context c pos wrt c pos observationally valid wrt r critical clausal context wrt clause c clausal context c whose contexts belongs example 65 example 1 set critical contexts r fpopz stack z nat topz stack g test substitutions critical context sets permit us refute false conjectures constructing counterexample denition 66 provably inconsistent say clause v n j provably inconsistent exists test substitution clausal critical context c 1 inductive theorem wrt r strongly irreducible r provably inconsistent clauses observationally valid theorem 67 let r ground convergent rewrite system let c provably inconsistent clause c observationally valid proof let c v n j provably inconsistent clause exists critical context c test substitution r strongly irreducible r denition 64 j observationally valid wrt r r 6j obs c using 2 example 68 consider stack specication figure 1 let us check whether conjecture observationally valid apply rst induction step obtain 1 2 theses subgoals simplied r obtain 3 4 equation apply induction step obtain 5 topnilx 6 toppushyzx equation simplied r provably inconsistent since r ground convergent conclude observationally valid 61 computation test sets computation test sets test substitutions conditional specica tions decidable axioms suciently complete constructors specied set unconditional equations see 2321 unfortunately algorithm exists general case conditional specications however 8 procedure described computing test sets axioms suciently complete arbitrary specication constructors 62 computation critical contexts let us rst introduce following lemma gives us useful characterization critical context sets lemma 69 let r leftlinear conditional rewriting system let cc cover context set context cz variables cz appear depth greater equal jrj 1 exists observable context c obs c obs c strongly irreducible cc critical context set r proof let c positive clause cc strongly irreducible test substitution c c critical clausal context c let us prove c observationally valid c 2 c obs denition 63 conclude cc inductive theorem therefore c observationally valid assume c 62 c obs assumption exists c quasi ground reducible contain observable strict subcontextg c quasi ground reducible c contain observable subcontext variables including context one c occur jrj g repeat c quasi ground reducibleg cc output cc fig 2 computation critical contexts observable clausal context c obs c obs c strongly irreducible let us show c obs cc strongly irreducible assume otherwise exists rule lefthand side l applies c obs cc position p every nonvariable position p 0 l pp 0 nonvariable position c obs c since variables cz appear depth greater equal jrj 1 since l linear dene substitution every variable x occurs position q l x c obs cpq c obs cp l contradicts assumption c obs c strongly irreducible c obs cc strongly irreducible denition 63 c obs cc inductively valid thus r 6j obs c 2 us present method constructing critical contexts idea procedure following starting non quasi ground reducible observable contexts depth smaller equal jrj construct contexts embedded one observable contexts give non quasi ground reducible observable context quasi ground reducibility cosemidecidable conditional rewrite systems argument employed ground reducibility 20 procedure amounts enumerate ground instances term check reducibility proved reduction ground reducibility quasi ground reducibility decidable equational systems proposition 610 given set non conditional rewrite rules r context cz decidable whether cz quasi ground reducible proof let us rst introduce new constant symbol 62 f let red l x unary predicate true ground term x contains subterm instance l context cz quasi ground reducible instances cd substitutions satisfying 8x x 2 reducible r denote g set ground terms contain one one occurrence note g regular tree language hence quasi ground reducibility cz expressed rstorder formula red red l set lefthand sides r g formula decided thanks theorem 418 caron et al 10 2 following proposition also useful testing context quasi ground reducible proposition 611 let r equational rewriting system dened functions completely dened free constructors given context form ft completely dened function constructor term z appear induction position f cz quasi ground reducible proof assume exists ground instance cz form irreducible r consider substitution z ground irreducible constructor term ft ground irreducible assume otherwise exists rule lefthand side l applies ft position z cz position p appear function symbol l therefore p induction position f contradiction assumption p induction position f ft ground irreducible contradicts assumption f completely dened 2 theorem 612 let r rewriting system cc result application procedure given figure 2 1 cc cover context set r 2 r equational leftlinear cc critical context set r proof relatively easy show cc cover context set r assume r equational leftlinear let us prove cc also critical context set r construction nonobservable context cc variables depth greater equal jrj since r equational non quasi ground reducible context necessarily strongly irreducible hand r leftlinear variables nonobservable context occur jrj context cz exists c 2 cc show exists observable context c obs c obs c strongly irreducible proof done induction specication list sorts nat bool list observable sorts nat bool constructors 0 nat nat nat nil list insert nat list list true bool false bool dened functions union list list list nat list bool eq nat nat bool axioms unionnilll inxnilfalse eqxytrue eqxyfalse eq00true eq0sxfalse eqsx0false fig 3 list specication example 613 consider stack specication figure 1 stack pushi z stack g critical context set r example 614 consider list specication figure 3 list g list x insertx z list g list xg cover context set r fact unionx z list quasi ground reducible iny unionz list x quasi ground reducible since list n il irreducible iny insertx z list quasi ground reducible possible compute critical context sets case r conditional rewriting system sucient apply procedure given figure 2 compute cover context set cc check non observable context c 2 cc exists observable context c obs c obs c strongly irreducible example 614 inx unionz list strongly irreducible conclude list unionz list xg critical context set r 7 inference system inference system use see figure 4 based set transition rules applied set conjectures prove h set induction hypotheses initial set conditional rules r oriented well founded ordering iderivation sequence states say iderivation fair set persistent clauses ji context induction performed implicitly generation rule clause extended critical contexts test sets extensions simplied either deletion contextual simplification case simplification resulting conjectures collected simplification illustrates case reasoning simplies conjecture conditional rules contextual simplification viewed powerful generalization contextual rewriting 38 allows simplify observational properties rule context subsumption appeared useful manipulating non orientable conjectures iderivation fails exists conjecture rule applied iderivation succeeds conjectures proved example 71 let us take signature axioms specication figure 1 let us add new function elem nat bool following axioms assume observable sort bool test set critical context g easily show topy inductive theorem observationally valid since ground term topt reduces either 0 s0 note example relations constructors cannot handled related approaches 1226 theorem 72 correctness successful iderivations let fair iderivation succeeds r proof suppose r 6j obs e 0 let set minimal elements wrt fc j ground irreducible substitution r 6j obs cg note 6 since r 6j obs e 0 well founded let c 0 clause c 0 minimal wrt context subsumption exist clause irreducible ground substitution c r 6j obs c consider observable context c obs r 6j c obs c without loss generality assume c obs irreducible otherwise simplied r irreducible one property show rule applied c shows derivation fails since c must persist derivation fairness hypothesis hence let us assume c rule applied c discuss situation according rule applied every case shall derive contradiction order simplify notations write e e j h h j case simplification suppose rule case simplification applied c since r exists k r r 6j c obs cl r r 6j obs c k hand c contradiction since proved existence instance clause observationally valid smaller c contextual simplification suppose rule contextual simplification applied c without loss generality assume c context built replacing l context variable z let c obs c 1n1 obs obs c minimal counterexample r obs hence r obs c r conclude hand c generation suppose rule generation applied c since substitution ground irreducible exists ground substitution test substitution besides since r 6j obs c consider irreducible ground observable context c obs r 6j c obs c since c obs ground irreducible exists critical context c c 0 2 c obs c deletion applied r contextual simplification case simplification applied cc following reasoning used proofs soundness contextual simplification case simplification derive contradiction context subsumption since r 6j obs c c cannot contextually subsumed axiom r exists c fcg r 6j cc 0 c empty context since c minimum subsumption ordering therefore c 0 62 e n fcg hand c 0 62 h otherwise rule generation also applied c contradiction previous case hence rule cannot applied c deletion since r 6j obs c c tautology rule need consideredtheorem 73 correctness disproof let iderivation exists j disproof applied r 6j proof exists j disproof applied theorem 67 conclude r 6j prove r 6j sucient prove following claim let iderivation step 8i j r simplication rule equations used simplication occur therefore observationally valid r assumption hence e j1 observationally valid r generation c every auxiliary equation used rewriting instance c critical context c test substitution either r observationally valid r subsumption deletion e j1 e j therefore e j1 observationally valid r 2 consider boolean specications specic assume exists sort bool two free constructors ftrue falseg every rule r type v n conjectures boolean clauses ie clauses whose negative literals completely dened symbol r f strongly complete 8 wrt r rules whose lefthand sides identical renaming r say r strongly complete f 2 f strongly complete wrt r theorem 74 refutational completeness let r conditional rewrite system assume r ground convergent strongly complete let e 0 set boolean clauses r 6j derivations issued case simplication r contextual simplication c context subsumption contextually subsumes c deletion c tautology generation critical context c test substitution application deletion contextual case simplication disproof c provably inconsistent fig 4 inference system proof theorem 72 rule permits us introduce negative clauses case simplification since axioms boolean preconditions e 0 contains boolean clauses clauses generated iderivation boolean disproof applied iderivation exists positive clause c generation cannot applied c therefore exists critical context c test substitution r 6j cc moreover cc match lefthand side r otherwise contextual simplification rule case simplification rule applied cc since r strongly complete consequence c provably inconsistent clause therefore r 6j 8 computer experiments prototype written objective caml top spike designed prove disprove behavioural properties conditional theories nice feature approach needed modications implicit induction system spike get operational procedure observational deduction also optimisation strategies available spike also applied observational proof system rst step proof session compute test sets critical contexts second step check ground convergence set axioms steps succeed refute false behavioural properties computation fails user introduce cover sets cover contexts preliminary tasks proof starts example 81 proved automatically pushtops behavioural property stack specication see figure 1 note example fails approach 6 since possible compute automatically set crucial contexts two stacks top necessarily equal approach 16 introduce auxiliary function iterated pop nat stack stack iterated popn iterates times pop easy pop unary function iterated pop dened iterated pop0 iterated popn pops prove property contexts form topiterated popx cz stack however schematization contexts could complicated case function arity greater two process seems easy automatize general approach 25 problem remains us describe proof prover computes rst test set r induction positions functions necessary inductive proofs also computes critical context computation done beginning proof test set r critical contexts r induction positions functions application generation subsumed nil r delete subsumed subsumed delete subsumed initial conjectures observationally valid r example 82 consider specication list figure 3 theorem automatically proved test set r list critical contexts r induction positions functions application generation delete delete subsumed true r simplification simplification delete application generation delete delete delete subsumed true r simplification false r delete subsumed true h4 initial conjectures observationally valid r way proved following conjectures 9 conclusion presented automatic procedure proving observational properties conditional specications method relies construction set critical contexts enables prove disprove conjectures reasonable hypotheses shown procedure refutational com plete non observationally valid conjecture detected nite time shown potential context induction technique reasoning object behaviours especially renement implementation proved several examples completely automatic way cover context wrt denition 62 garantees soundness proce dure however cover contexts computed procedure may contain unecessary contexts example 3 unionz list x useless observations plan rene notion cover critical contexts order select needed contexts also plan extend observation technique terms formulas near future plan extend approach verify properties concurrent distributed object systems acknowledgements thank diane bahrami referees helpful comments r proving correctness algebraically speci observational proofs critical contexts proving correctness algebraic implementations isar system behavioural approaches algebraic speci towards adequate notion observation prove observational theorems lp behavioural theories proof behavioural properties automated theorem proving test set induction implicit induction conditional theories encompassment properties automata constraints fundamentals algebraic speci rosu k towards algebraic semantics object paradigm speci implementation parameterized observational speci context induction proof principle behavioural abstractions algebraic implementations structured speci reasoning classes objectoriented languages logical models tools decidability quasireducibility automating inductionless induction using test sets testing ground coreducibility property termrewriting systems extending bachmairs method proof consistency proving correctness test towards automated veri cation behavioural properties verifying behavioural speci initial behaviour semantics algebraic speci computing horn clause theories proofs behavioural validity conditional equations observational equivalence algebraic speci toward formal development programs algebraic speci towards formal development ml programs foundations methodology final algebra semantics data type extensions algebraic speci implementing contextual rewriting tr observational equivalence algebraic specification toward formal development programs algebraic specifications implementations revisited computing horn clause theories initial behavior semantics algebraic specifications theoremproving resolution superposition automating inductionless induction using test sets algebraic specification towards adequate notion observation testing ground coreducibility property termrewriting systems extending bachmairs method proof consistency final algebra behavioural approaches algebraic specifications towards algebraic semantics object paradigm behavioural theories proof behavioural properties automated theorem proving test set induction fundamentals algebraic specification reasonong classess objectoriented languages specifications observable formulae observational satisfaction relation proving correctness algebraically specified software proving correctness algebraic implementations isar system prove observational theorems lp behaviourrefinement coalgebraic specifications coinductive correctness proofs implementation parameterized observational specifications toward formal development ml programs encompassment properties automata constraints implementing contextual rewriting verifying behavioural specifications cafeobj environment circular coinductive rewriting specification application programming abstract data types ctr abdessamad imine michal rusinowitch grald oster pascal molli formal design verification operational transformation algorithms copies convergence theoretical computer science v351 n2 p167183 21 february 2006 grigore rosu implementing behavioral rewriting proceedings 2002 acm sigplan workshop rulebased programming p4352 october 05 2002 pittsburgh pennsylvania manuel martins closure properties class behavioral models theoretical computer science v379 n12 p5383 june 2007
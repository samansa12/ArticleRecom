reliable communication highly mobile agents provision reliable communication infrastructure mobile agents still open research issue challenge reliability address work come possibility faults rather mere presence mobility complicates problem ensuring delivery information even faultfree network instance asynchronous nature message passing agent migration may cause situations messages forever chase mobile agent moves frequently one host another current solutions rely conventional technologies either provide solution aforementioned problem designed mobility mind enforce continuous connectivity message source many cases defeats purpose using mobile agentsin paper propose algorithm guarantees delivery highly mobile agents using technique similar distributed snapshot number enhancements basic idea discussed limit scope message delivery allowing dynamic creation connectivity graph notably structure algorithm makes amenable guarantee message delivery specific mobile agent also provide multicast communication group agents constitutes another open problem research mobile agents presenting algorithm properties discuss implementability analyzing requirements underlying mobile agent platform argue applicability b introduction mobile agent systems currently provide increasing degree sophistication abstractions mechanisms support well beyond purpose achieving agent migration however questionable whether features added top plain agent migration really focused needs application developers really address problems peculiar mobility good example gap provided needed problem providing communication infrastructure mobile agents aspect often overlooked misunderstood context mobile agent research instance significant efforts devoted problem enabling communication among mobile agents defining common semantic layer exchange formation kqml 6 despite relevance questions posed researchers area particularly affected presence mobility focus problem communication completely different much higher abstraction level one concerned paper even assume problem ensuring proper semantic level agent communication somehow solved still left problem reliably delivering message mobile agent whose patterns mobility potentially unknown priori problem address paper challenge reliable communication persists even assumption ideal transport mechanism guarantees correct delivery information presence faults underlying communication link communicating nodes sheer presence mobility possibility faults undermines notion reliability mobile agents allowed move freely one host another according priori unknown migration pattern challenge delivering information properly caused difficulty determining mobile agent ensuring information reaches mobile agent moves large currently available mobile agent systems rely either conventional communication facilities like sockets remote procedure method call 1 8 13 implement message passing facility 10 knowledge none satisfactorily addresses aforementioned problem require knowledge location mobile agent obtained either overly restricting freedom mobility assuming continuous connectivityassumptions many cases defeat whole purpose using mobile agents paper propose algorithm guarantees message delivery highly mobile agents faultfree network focus message passing communication mechanism want adapt mobility fundamental well understood form communication distributed system incurs loss generality complex mechanisms like remote procedure call method invocation easily built top message passing algorithm assume knowledge location agents constrains movement agents enhanced form limited amount time furthermore structure makes inherently amenable extension provides multicast communication group agents dispersed network another problem satisfactory solutions yet exist paper structured follows section 2 discusses motivation work current state art field section 3 presents al gorithm starting underlying assumptions illustrating subsequent refinements original key idea section 4 discusses applicability implementability communication mechanism embodying algorithm mobile agent platform finally section 5 provides concluding remarks 2 motivation related work typical use mobile agent paradigm bypassing communication link exploiting local access resources remote server 7 thus one could argue communication remote agent important mobile agent platform focus instead communication mechanisms exploited locally ie get access server communicate agents colocated site many mobile agent systems provide mechanisms local communication either using sort meeting abstraction initially proposed telescript 18 event notification group communication 1 10 recently tuple spaces 4 16 nevertheless several common scenarios provide counterarguments statement related issue managing mobile agents imagine master agent spawning number slave mobile agents subsequently injected network perform kind cooperative computation eg find piece informa tion point master agent may want actively terminate computation slave agents eg requested information found one thus desirable prevent unnecessary resource consumption may want change parameter governing behavior agents context determined creation changed meanwhile turn slave agents may want detect whether master agent still alive performing sort orphan detection requires locating master agent allowed mobile examples related fact mobile agents one paradigms available designers distributed application use mixture mobile agent message passing achieve different functionalities context ap plication instance mobile agent could visit site perform check given condition condition satisfied agent could register event listener site way mobile agent visiting sites reporting results could receive notifications changes state sites already visited decide whether worth second visit scenarios require presence message passing mechanism mobile agents however highly desirable requirement mechanism guarantee message actually delivered least destination independently relative movement source target communi cation mobility heavily complicates matters typical delivery schemes suffer fundamental problem agent transit delivery easily missed illustrate issue discuss two strawman approaches message delivery broadcast forwarding simple broadcast scheme assumes spanning tree network nodes message may sent node node broadcasts message neighbors broadcast message neighbors leaf nodes reached however guarantee delivery message agent traveling reverse direction respect propagation message depicted figure 1 agent b forwarding spanning tree broadcasting sender agent message sender home agent retransmission figure 1 problem missing delivery simplistic broadcast forwarding schemes ing transferred instant message propagating direction agent message cross channel delivery never occur simple forwarding scheme maintains pointer mobile agent wellknown location called home agent mobile ip protocol 14 idea enables physical mobility hosts upon mi gration mobile agent must inform home agent new location order enable com munication however messages sent migration update lost agent basically ran away messages could delivered even retransmission new location attempted agent move miss retransmission thus effectively preventing guaranteed delivery depicted figure 1 furthermore forwarding additional drawback requires communication home agent every time agent moves situations may defeat purpose using mobile agents reintroducing centralization instance presence many highly mobile agents spawned host scheme may lead considerable traffic overhead generated around home agent possibly much slower performance latency mobile home agent high finally umbilical cord must maintained home agent approach intrinsically difficult apply disconnected operations required mobile agent systems currently available employ different communication strategies omg masif standard 11 specifies interfaces enable naming locating agents across different platforms actual mechanisms locate agent communicate intentionally left scope standard although number location techniques suggested large regarded variations broadcast forwarding systems notably aglets 10 voyager 13 employ forwarding associating mobile component proxy object plays role home agent others like emerald 9 precursor mobile objects use forwarding resort broadcast object cannot found others eg mole 1 simply prevent movement mobile agent engaged communication mole exploits also different forwarding scheme keep single home agent rather maintains whole trail pointers source destination faster communication however employed context protocol orphan detection 2 finally systems eg agent tcl 8 provide mechanisms based common remote procedure call leave application developer chore handling missed delivery related subject provision mechanism reliable communication group mobile agents group communication useful programming abstraction dealing clusters mobile agents functionally related piece information must sent many mobile agent systems notably telescript aglets voyager provide capability multicast messages within context single runtime support finally mole 1 provides mechanism group communication ever still assumes agents stationary set information exchanges approach propose provides reasonable solution problem guaranteeing delivery single mobile agent nice side effect providing straightforward way achieve group communication well details algorithm discussed next section 3 enabling reliable communication discussed earlier simplistic message delivery mechanisms spanning tree broadcasting forwarding potential failure agents transit rapidly moving address shortcomings note general must flush agents channels regions cannot escape without receiving copy message instance aforementioned broadcast mechanism look case agent moving opposite direction message bidirectional channel case message still present destination node chan nel could delivered agent arrived node leads solution message stored nodes delivery completes although simple extension would guarantee delivery reasonable expect nodes store messages arbitrary lengths time therefore seek solution tight bound storage time given message node must also address situation message continually forwarded new location mobile agent never reaches agent effectively running away message never catches could store message every node network de livered better solution would involve trapping agent region graph wherever moves cannot avoid receiving message first algorithm present guaranteed message delivery mobile agents direct adaptation previous work done first author area physical mobility 12 work assumes network nodes channels known advance assumes one message present system time setting exactlyonce delivery message guaranteed without modifying agents behavior either respect movement message acceptance next extend basic algorithm allow multiple messages delivered concurrently achieve enhancement must relax exactlyonce semantics become atleastonce meaning duplication messages acceptable still prevent agent missing message although algorithms provide reliable message delivery assumption entire network graph known advance often unreasonable situations mobile agents used therefore enhance algorithm allowing graph grow dynamically agents move still preserve atleastonce semantics message delivery simplicity pre sentation present latter enhancement two stages first assuming messages originate single node allowing node initiate processing needed send message 31 model logical model work typical network graph nodes represent nodes willing host agents edges represent directional fifo channels along agents migrate messages passed fifo assumption critical proper execution algorithm implications underlying mobile agent platform discussed section 4 assume con figure 2 connected network connected sub networks agents enter leave subnetworks going gateway servers nected network graph ie path exists every pair nodes necessarily fully connected ie channel necessarily exist pair nodes typical ip network nodes logically connected directly however always case application level shown figure 2 set subnetworks connected one another ip network agent enter leave subnetwork passing gateway server eg security reasons also assume mobile agent server keeps track agents currently hosting provides fundamental mechanism deliver message agent eg invoking method agent object finally assume every agent single globally unique identifier used direct message agent latter assumptions reasonable already satisfied majority mobile agent platforms 32 delivery static network graph begin description solution basic algorithm assumes fixed network nodes simplicity describe first behavior algorithm unrealistic assumption single message present system show result extended allow concurrent delivery multiple messages single message delivery previous work first author physical mobility environment approached reliable message delivery adapting notion distributed snapshots 12 snapshot algo rithms goal record local state nodes channels order construct consistent global state critical features algorithms include propagation snapshot initiation flush 1 pre incoming channels open action 2 pre message j arrives action 3 pre message j finished processing action 4 pre message arrives action buffer message open figure 3 state transitions related diagram multiple message delivery static network graph ing channels record messages transit recording every message exactly approach message delivery uses many ideas original snapshot paper presented chandy lamport 5 however instead spreading knowledge snapshot using messages spread actual message delivered instead flushing messages channels flush agents channels instead recording existence messages deliver copy message algorithm works associating state flushed open incoming channel node initially channels open message arrives channel state changed flushed implying agents channel ahead message forced channel fifo assumption message arrives first time node stored locally propagated outgoing channels starting flushing process channels message also delivered agents present node agents arrive open channel node storing message must receive copy incoming channels node flushed node longer required deliver message arriving agents therefore message copy deleted channels atomically reset open multiple message delivery simplistic adaptation previous algorithm multiple message delivery would require node wait termination current message delivery coordinate nodes initiating new one order ensure one message present system however unnecessarily constrains behavior sender requires knowledge nonlocal state propose instead approach multiple messages present system long node message originates tags message sequence number unique node prac tice sequence number allows nodes deal multiple instantiations algorithm running con currently thus encompassing case single source transmitting burst messages without waiting well case multiple sources transmitting time allow concurrent message delivery take place must address issue new message arriving processing current one case channel already flushed channels flushed handle case introduce new state buffering shown figure 3 messages arriving flushed channel put buffer processed later time transition 4 channel buffering state considered determining transition flushed open transition finally made 1 buffering channels also transitioned open 3 messages buffer queues treated messages arriving channel moment thus processed possible processing first message next message causes another transition buffering fact head channel processed ensures eventual progress sequence messages delivered although force messages buffered agent arrival restricted agent allowed move ahead messages originally followed along channel effectively agent may move back region network message yet delivered therefore duplicate delivery possible although duplicates discarded easily runtime support agent based sequence number 33 delivery dynamic network graph although solutions proposed far provide delivery guarantees presence mobility necessity knowing network neighbors priori sometimes unreasonable dynamic environment mobile agents furthermore delivery mechanism insensitive nodes active delivers messages also regions network visited agents therefore goal still flush channels trap agents regions network messages propagate also allow network graph used delivery process grow dynamically agents migrate channel included message delivery agent traversed therefore node included message delivery agent hosted refer node channel included message delivery active presentation organized two phases first show restricted approach messages must originate single fixed source reasonable monitoring masterslave scenarios communication flows fixed initiator agents system extend initial solution enable direct interagent messaging allowing node send messages without need centralized source single message source first identify problems arise nodes channels added dynamically due possible disparity messages processed source destination nodes channel becomes active initially present issues example develop general solution destination ahead source assume network shown figure 4a x sender messages initially active node system graph extended x sends agent causing x become active suppose x sends burst messages 14 processed later second sequence messages 58 second transfer immediately followed migration new agent node z makes z x z active message 5 arrives agent sent z thus causing channel z added active graph problem arises agent decides immediately leave z messages 58 yet delivered furthermore processing occur messages arrive z along new channel z messages blindly forwarded zs outgoing channels message ordering possibly lost messages possibly keep propagating network without ever deleted solution hold agent z messages 58 received messages ar rive deliver detained agent ie without broadcasting neighboring nodes therefore messages lost system wide processing messages affected notably although inhibit movement agent messages arrive takes place time proportional diameter network even important topology network changing source ahead destination uncover another potential problem use scenario presented nodes x z except instead assuming agent moving z assume moving z making z active ure 4b although agent miss messages move two potential problems exist first making z active wait z flushed buffering proceeding next message however message 5 never sent z solution delay activation channel catches z example delay 8 processed second message 9 sent x propagated along channel z must buffered processed order given present solution generalizes previous one describe detail channel states critical transitions among states using state diagram figure 5 ffl closed initially channels closed active message delivery ffl open channel waiting participate message delivery agent arrives open channel node storing message destined agent agent receive copy message ffl flushed current message delivered already arrived channel therefore channel completed current message delivery agents arriving flushed channels need special processing source destination b source ahead destination ahead z 8 figure 4 problems managing dynamic graph values shown inside nodes indicate last message processed node subscripts agent indicate last message processed source channel traversed right migrated ffl bufferingj source ahead desti nation messages arriving buffering channels put fifo buffer processed node catches source processing message j ffl holdingj destination ahead source messages identifiers less equal j arrive holding channels delivered held agents agents arriving holding channels whose last received message identifier less j held j arrives initial transition channel closed active state based current state destination node state source carried agent destination node either still inactive finished delivering message source 9 still still processing message 8 processing earlier message 10 processing later message 7 based comparison new active state assigned channel active state transitions occur response arrival message already taken measures ensure messages delivered agents remaining concerns detained agents eventually released every node next message eventually processed whether agent must detained determined comparing identifier latest message received agent carried part agent state current state destination node agents behind destination actually detained agent detained channel state holdingj released soon j processed along channel connectivity network graph guaranteed j eventually arrive destination node either still processing j completed processing cases agent released former case channel transitions flushed 6 wait rest channels catch latter case channel transitions open 5 ready process next message argue eventually messages delivered must extend progress argument presented section 32 include progress holding channels well addition new channels noted previous paragraph message j guaranteed eventually arrive along holding channel thus ensuring progress channel next assert maximum number channels added incoming channels bounded num 1 pre incoming channels open incoming channels holding action 2 pre message j arrives action 3 pre message j finished processing action 4 pre message arrives action buffer message 5 pre message j arrives action deliver held agents release held agents pre message j arrives action deliver held agents release held agents 7 pre agent arrives ahead action 8 pre agent arrives curmsg processing message action 9 pre agent arrives active processing message action 10 pre agent j arrives ahead action open flushed closed figure 5 state transitions related diagram multiple message delivery single source dynamic network graph state transitions refer single channel ber nodes system guaranteed channels continuously added eventually maximum reached progress properties eventually channels either flushed buffering case processing next message begin multiple message sources although previous solution guarantees message delivery allows dynamic expansion graph assumption messages originate node overly restric tive extend algorithm allow message originate node effectively superimpose multiple instances algorithm network allowing concurrent execution purposes explanation let n number nodes system ffl state incoming channel represented vector size n state node recorded channel added active graph channel considered closed channel active messages received particular node state element vector corresponding node set open ffl processing message done respect channel state associated node message originated ffl nodes deliver n messages concurrently one node second message arrives node buffered prior message completes processing ffl agent always carries vector containing message source identifier last message received moreover agent traverses new outgoing channel carries another vector contains message source identifier last message processed source new channel right agent departed ffl incoming agent held long message source identifier last message received greater corresponding holding value channel agent arrived ffl enable node originate message must guarantee graph remains connected maintain property make links bidi rectional case agent arrives channel opposite direction already outgoing channel fake agent message sent state information message effectively makes reverse channel active must argue detained agents eventually released progress made respect messages sent node assume message smallest message identifier node delivered nodes must exist path copy every node arrived every node path blocked arrives connectivity network graph propagate every node along every channel complete delivery system node buffer minimum message identifier waited completed delivery next message new minimum make progress similar manner buffering messages done respect individual source nodes channel whole messages node make independent progress holding agents requires coordination among nodes j value respect node channel held eg holdingj fixed first agent arrives messages guaranteed make progress guaranteed eventually j processed detained agents released 34 multicast message delivery algorithms described far exploited fact distributed snapshot records state node exactly modified algorithm substituting message recording message delivery agent hence one could describe algorithm saying attempts deliver message every agent system agents whose identifier match message target actually accept mes sage view mind solution presented adapted straightforwardly support multicast modification must introduced notion multicast address allows group agents specified recipients messageno modification algorithm needed 4 discussion future work section analyze impact communication mechanism underlying mobile agent platform argue applicability discuss possible extensions future work topic 41 implementation issues fundamental assumption must preserved order mechanism work communication channels must fifoa legacy fact core schema based distributed global snapshot fifo property must maintained every piece information traveling channel ie messages agents combination two necessarily requirement mobile agent platform common design map operations require message agent delivery data transfers taking place different data streams typically sockets higherlevel mechanism like remote method invocation case operations insist destination fifo property may preserved since data item sent first one stream received later another data item another stream depending architecture underlying runtime support nevertheless fifo property implemented straightforwardly mobile agent server associating queue contains messages agents must transmitted remote server way fifo property structurally enforced server architecture although may require nontrivial modifications case already existing platform mechanism assumes runtime support maintains state network graph messages exchanged static form solution state constituted last message received must kept de livered system bidirectional channels means time equal maximum round trip delay node neighbors hand dynamic variant algorithm server must maintain vector identifiers active outgoing incoming channels channel vector containing messages possibly buffered size latter unbounded message must kept vector time proportional diameter network 42 applicability evident algorithm presented work generates considerable overall traffic overhead compared instance forwarding scheme consequence fact technique involves contacting nodes network visited least one agent order find message recipient thus generates amount traffic comparable broadcast unfortunately price must paid guaranteed delivery frequent unconstrained agent movement part application requirements since simpler lightweight schemes provide guarantees discussed section 2 hence question whether communication mechanism propose useful addition mobile agent platforms ultimately answered practical mobile agent applications still largely missing determine requirements communication case expect mechanism one provided runtime support make analogy one shout party one step away one resorts shouting exceptional condition party available expected algorithm provides clever way shout ie broadcast message precise guarantees minimal constraints used conventional mechanisms applicable hence runtime support leave programmer opportunity choose different communication mechanisms even different variants algorithm instance fully dynamic solution described section 33 necessarily convenient situations network configuration one depicted figure 2 graph structured clusters nodes best tradeoff probably achieved using fully dynamic algorithm gateway servers sit border cluster static algorithm within cluster thus leveraging knowledge internal network configuration along lines also possible exploit hybrid schemes instance common case receipt message triggers reply bandwidth consumption reduced encoding reply destination initial message using conventional mechanism long sending agent willing remain stationary reply received 43 enhancements future work work argued problem reliable message delivery inherently complicated presence mobility even absence faults links nodes involved communication practice however faults happen depending execution context relevant case techniques traditionally proposed coping faults distributed snapshot applied mechanism instance simple technique consists periodically checkpointing state system recording state links keeping track last snapshot dumping image agents hosted many systems already provide checkpointing mechanisms mobile agents information used reconcile state faulty node neighbors fault occurred related issue ability dynamically add nodes graph also remove could model faults model fact given node longer willing host agents eg mobile agent support intentionally shut simple solution would consist short cir cuiting node removed setting incoming channels outgoing neighbors point nodes incoming neighbors however involves running distributed transaction thus enforces undesirable level complexity work disregarded problem couple reasons first evident ability adding nodes dynamically enables better use communication resources limiting communication areas effectively visited agents unclear whether similar gain obtained case removing nodes especially considering aforementioned implementation complexity second mobile agent systems provide ability start stop dynamically mobile agent runtime support assume runtime started offline operates mobile agent application terminates currently designing implementing communication package based algorithm described paper included code 15 mobile code toolkit goal activity gain handson understanding design implementation issues concerned realization scheme provide basis precise quantitative characterization approach especially comparison traditional ones 5 conclusions work point sheer presence mobility makes problem guaranteeing delivery message mobile agent inherently difficult even absence faults network knowledge problem addressed research community currently available mobile agent systems employ techniques either provide guarantees overly constrain movement connectivity mobile agents thus extent reducing usefulness work propose solution based concept distributed snapshot several extensions basic idea allow us cope different levels dynamicity along way provide straightforward way implement group communication mobile agents communication mechanism meant complement currently provided mobile agent systems thus allowing programmer trade reliability bandwith consumption work address fault tolerance exploit implementation mechanism evaluate tradeoffs conventional mechanisms acknowledgments paper based upon work supported part national science foundation nsf grant ccr9624815 opinions findings conclusions recommendations expressed paper authors necessarily reflect views nsf r communication concepts mobile agent systems shadow ap proach orphan detection protocol mobile agents software agents reactive tuple spaces mobile agent coordination distributed snap shots determining global states distributed sys tems kqml agent communication language understanding code mobility agent tcl programming deploying mobile agents aglets exercise formal reasoning mobile computations objectspace inc ip mobility support lime linda meets mobility mobile agents 2 nd int telescript technology mobile agents tr ctr mosaab daoud qusay h mahmoud reliability analysis mobile agentbased systems proceedings 2005 acm symposium applied computing march 1317 2005 santa fe new mexico scalable platform highly mobile agents distributed computing environments proceedings 2006 international symposium world wireless mobile multimedia networks p633637 june 2629 2006 elena gmezmartnez sergio ilarri jos merseguer performance analysis mobile agents tracking proceedings 6th international workshop software performance february 0508 2007 buenes aires argentina hojjat jafarpour nasser yazdani navid bazzazzadeh scalable group communication mechanism mobile agents journal network computer applications v30 n1 p186208 january 2007
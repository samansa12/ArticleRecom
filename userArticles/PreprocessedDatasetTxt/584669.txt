simple objectbased view multiprogramming objectbased sequential programming major impact software engineering however objectbased concurrent programming remains elusive effective programming tool class applications implemented future highbandwidth networks processors significantly ambitious current applications mostly involved transmissions digital data images objectbased concurrent programming potential simplify designs applications many programming concepts developed databases objectoriented programming designs reactive systems unified compact model concurrent programs serve foundation designing future applications propose model multiprograms discipline programming addresses issues reasoning eg understanding efficient implementation major point departure disentanglement sequential multiprogramming features propose sparse model multiprograms distinguishes two forms computations allows disciplined interactions b introduction objectbased sequential programming major impact software engineer ing however objectbased concurrent programming remains elusive eective programming tool class applications implemented future highbandwidth networks processors signicantly ambitious current applications mostly involved transmissions digital data images objectbased concurrent programming potential simplify designs applications many programming concepts developed databases objectoriented programming designs reactive systems unied compact model concurrent programs serve foundation designing future applications 11 motivation research multiprogramming traditionally attempted reconcile two apparently contradictory goals 1 possible understand module eg process data object isolation without considerations interference modules 2 possible implement concurrent threads ne level granularity process ever locked accessing common data long periods time goals con ict ne granularity general implies considerable interference earliest multiprograms see instance solution mutual exclusion problem dijkstra 8 trivially small impossibly dicult understand behaviors individual processes could understood isolation possible interactions among processes analyzed explicitly since much eort gone limiting even eliminating interference among processes employing variety synchronization mechanisms locks semaphores critical regions monitors message communications constraining programming model specic protocol binary semaphores message communication bounded channels instance prove shortsighted designing complex applications general mechanisms interactions among modules include specic protocols required fur ther distributed applications future essential devise model distinction computation communication removed particular methods designing reasoning interfaces dierent employed computations nodes network 12 seuss developed model multiprogramming called seuss seuss fosters discipline programming makes possible understand program execution single thread control yet permits program implementation multiple threads consequence possible reason properties simple objectbased view multiprogramming 281 program single execution thread whereas implementation spe cic platform eg shared memory message communicating system may exploit inherent concurrency appropriately central theorem establishes multiple execution threads implement single execution threads ie interleaved execution actions exists noninterleaved execution actions establishes identical nal state starting initial state major point departure seuss builtin concurrency commitment either shared memory messagepassing style implementation communication synchronization mechanism except procedure call built model particular notions inputoutput complementary nature rendezvousbased communication 9 17 outside model distinction computation communication process specications interface specications distinguished consequently many traditional multiprogramming concepts processes locking rendezvous waiting interference deadlock basic concepts model yet typical multiprograms employing message passing bounded unbounded channels encoded seuss declaring processes channels components program similarly shared memory multiprograms encoded processes memories components seuss permits mixture either style programming variety dierent interaction mechanisms semaphore critical region 4phase handshake etc encoded components seuss proposes complete disentanglement sequential concurrent aspects programming expect large sections code written understood reasonedabout sequential programs view multiprogramming way orchestrate executions sequential programs specifying conditions program executed typically several sequential programs execute simultaneously yet guarantee executions would noninterfering hence program may regarded atomic propose ecient implementation scheme user directives interleave individual sequential programs ne granularity without causing interference 2 seuss programming model seuss programming model sparse program built cats cat short category boxes cat built procedures cat similar many ways processclassmonitor type cat denotes type box instance cat box local state includes procedures local state accessed updated procedures box may call upon procedures boxes cats used encode processes well communication protocols process interactions therefore necessary develop methodology programming understanding cats component procedures propose two distinct kinds procedures model terminating potentially nonterminating computations representing computations waitfree programs multiprograms respectively former assigned semantic preand postconditions ie based possible inputs corresponding outputs without considerations interference environment multiprograms ever cannot given pre postcondition semantic ongoing interaction environment essence distinguish two types computations using two dierent kinds procedures total procedure never waits unbounded amount time interact environment whereas partial procedure may wait possibly forever interactions view p operation semaphore partial procedure may never terminate whereas v operation total procedure total procedure models waitfree transformational aspects programming partial procedure models con current reactive aspects programming15 programming model include waiting fundamental concept therefore partial procedure wait rejects call thus preserving program state next elaborate main concepts total partial procedure cat program 21 total procedure total procedure assigned meaning based inputs outputs procedure started state satises input specication terminates eventually state satises output specication procedures sort list nd minimum spanning tree graph send job unbounded printqueue examples total procedures total procedure need deterministic eg minimum spanning tree could returned procedure furthermore total procedure need implemented single processor eg list may sorted sorting network1 instance data parallel programs synchronous computation schemes usually total procedures total procedure may even multiprogram model admitting asynchronous execution provided guaranteed terminate eect understood inputs outputs therefore procedure never waits receive input instance example total procedure interacts environment one sends jobs printqueue without waiting jobs may processed environment procedure continues execution almost total procedures shown manuscript sequential programs total procedure may call total procedures total procedure called certain parameters given state may 1 terminate normally 2 fail 3 execute forever failure caused programming error occurs procedure invoked state invoked instance computation requires number divided 0 natural number reduced 0 failure general programming issue issue seuss multiprogramming interpret failure mean resulting state arbitrary step taken failed state results failed state typically hardware software trap terminates program failure occurs simple objectbased view multiprogramming 283 nontermination total procedure also result programming error expect programmer establish procedure invoked states execution nite 22 partial procedure rst consider simple form partial procedure g p precondition h preprocedure body procedure precondition predicate state box g belongs preprocedure name partial procedure another box preprocedure optional body consists local computations aecting state gs box calls total procedures boxes partial procedure call another partial procedure preprocedure partial procedure accepts rejects call made upon partial procedure form p preprocedure absent accepts call whenever holds partial procedure g form accepts call pre condition p holds preprocedure h accepts call made g impose additional restrictions program structure denition wellfounded call accepted body procedure executed potentially changing state box returning computed values parameters call rejected procedure body executed state change caller made aware outcome call cases call made g h rejected caller g also rejects call made upon call h accepted g accepts call executes body sense partial procedures dier fundamentally total ones calls accepted latter case examples partial procedures p operation semaphore get operation printqueue performed printer call upon p accepted semaphore value nonzero get printqueue nonempty observe whenever call rejected callers state change whenever call accepted procedure form body preprocedure h executed execution procedure body require execution body terminate whenever partial procedure g accepts call alternative introduce generalization body partial procedure consists one alternatives alternative form described previously partial procedures alternative positive negative rst alternative positive alternative preceded j positive one preceded j negative precondition one alternative partial procedure holds state ie preconditions pairwise disjoint rule execution partial method alternatives follows partialmethod accepts rejects call accepts call one 284 jayadev misra positive alternatives accepts call rejects call otherwise alternative positive negative accepts call given state follows alternative form p accepts call p holds body executed control returned caller alternative form accepts call provided p holds h accepts call made procedure using rules since h also partial procedure upon completion execution h body executed control returned caller thus alternative rejects call precondition hold preprocedure provided present rejects call note since precondition one alternative partial procedure holds given state one alternative accept call alternative accepts call call rejected follows state callers box unchanged whenever call rejected though state called box may changed negative alternative may accepted call alternatives essential programming concurrent systems negative alternatives especially useful coding strong semaphores instance 23 method action procedure either method action action executed autonomously innite number times tight program execution see section 241 method executed autonomously called another procedure declaration procedure indicates partial total action method example semaphore ubiquitous concept multiprogramming semaphore cat semaphore var n nat init 1 finitially semaphore value 1g partial method p n total method v n binary semaphore may encoded similarly except v fails n 6 0 prior execution next show small example employing semaphores let two instances semaphore declared cat user shown executes critical section holds releases semaphores upon completion critical section code user dealing accesses shown boolean variables hs ht true user holds semaphores respectively cat user var hs ht boolean init false simple objectbased view multiprogramming 285 partial action acquire hs sp hs true partial action acquire ht tp ht true partial action execute solution permits acquiring arbitrary order necessary acquire specic order say rst precondition action acquire changed hs ht 24 program program consists nite set boxes cat instances restrict manner procedure calls procedures procedures executing time belong dierent boxes impose condition partial order boxes ensures restriction denition procedures p q write p calls q mean execution p call made q let calls transitive closure calls calls exive transitive closure calls dene relation calls p procedures operational terms x calls p means procedure x calls procedure execution procedure p program required satisfy following condition partial order boxes every procedure p imposes partial order p boxes execution p procedure box b call procedure box b 0 made procedures higher box lower box note observe p exive p irre exive observation 1 follows observation 1 procedures part callchain belong dierent boxes observation 2 calls acyclic ie irre exive asymmetric transitive relation procedures denition program contrast usual views process networks processes communicate messages sharing common mem ory typically network regarded partially ordered instance suppose process p sends messages channel chp process q 286 jayadev misra q sends chq p processes viewed nodes cycle edges channels chp chq directed p q q p respectively representing direction message ow similar remarks apply processes communicating shared memory view communication media message channels memory boxes therefore would represent system described set four boxes p q chp chq procedures chp chq called p q respectively direction message ow immaterial hierarchy matters p q call upon chp chq though chp chq call upon p q partial order extremely useful deducing properties induction levels procedures restriction procedure calls made along partial order implies partial procedure lowest level consists one alternatives form preprocedure absent body contains procedure calls total procedure lowest level contains procedure calls 241 program execution prescribe execution style programs called tight execution tight execution consists innite number steps step action box chosen executed action calls upon pre procedure accepts call preprocedure rst executed followed execution action body action calls upon preprocedure rejects call state caller change choice action execute step arbitrary except following fairness constraint action box chosen eventually tight execution easy understand execution action completed another action started procedure total partial may understood text alone given meanings procedures calls without consideration interference procedures simple temporal logic unitylogic 19 18 suitable deducing properties program execution model later show program may implemented multiple asynchronous processors ne grain interleaving actions preserves semantics tight execution simple objectbased view multiprogramming 287 3 small examples number small examples treated section goal show typical multiprogramming examples literature succinct representations seuss additionally small number features seuss adequate solving many wellknown problems communications bounded unbounded channels mutual exclusions synchronizations show number variations examples implementing various progress guarantees instance operational arguments program behavior use tight executions programs dened section 241 31 channels unbounded channels unbounded fo channel cat two methods put ie send total method appends element end message sequence get ie receive partial method removes returns head element message sequence provided nonempty dene polymorphic version channel message type left arbitrary method put use assignment denote concatenation cat fifochannel type var r seq type init hi finitially r emptyg partial method getx type r total method putx type r r x end ffifochannel type g instance cat may interposed set senders set receivers unordered channels fo channel guarantees order delivery messages order arrived next consider unordered channel returns message channel response call get channel nonempty channel implemented bag get implemented nondeterministic operation write x 2 b denote x assigned value bag b provided b nonempty usual notation set operations used bags following example cat uch type var b bag type init fg finitially b emptyg partial method getx type b 6 fg x 2 b b b fxg total method putx type b b fxg end fuch typeg channel guarantee every message eventually delivered given messages removed bag unbounded number times 288 jayadev misra guarantee course established fo channel propose solution implements additional guarantee solution every message assigned index natural number variable less equal smallest index message assigned index strictly exceeding whenever put channel indices need distinct get method removes message smallest index updates cat nch type var b bag index nat msg type init fg finitially b emptyg nat init 0 nat type partial method getx type remove pair minimum index b x total method putx type natural number strictly exceeding end fnch typeg show every message eventually removed given unbounded number calls get message index show pair p p number messages index decreases lexicographically execution get never increases hence eventually implying message removed execution put aect p added message receives index higher thus p change get either increases thus decreasing keeps decreases p thus decreasing p 32 broadcast show cat implements broadcaststyle message communication processes called writers attempt broadcast sequence values set n processes called readers introduce cat broadcast writer writes next value reader reads structure cat follows internally value broadcast stored variable v n counts number readers read v read write partial methods precondition write counter n equals n ie readers read current value precondition read particular reader read current value v implement precondition reading associate sequence number value stored v sucient 1bit sequence number boolean variable alternating bit protocol communication faulty channel 21 read operation boolean argument last sequence number read reader match reader already read value hence call upon read rejected dier reader allowed read value n updated binary sequence number reversed whenever new value written v easy show n equals number readers whose svalue equals simple objectbased view multiprogramming 289 cats tvalue initially local variable reader true following denition n parameter cat cat broadcast data partial method reads boolean x data partial method writex data end fbroadcast datag 33 barrier synchronization problem solution section due rajeev joshi10 barrier synchronization process group concurrently executing processes performs computation sequence stages required process begin computing th stage processes completed k th stage k 0 propose cat includes partial method sync called process order start computation next stage call accepted processes completed stage process completed caller may advance next stage problem description see point execution users completed execution upto stage k users may executing may completed stage k 1 k k 0 initially problem broadcast user boolean barrier boolean maintain invariant user means user yet entered stage k 1 n number ticket holders box user var boolean init true partial action next phase box barrier boolean init true partial method syncs boolean 34 readers writers consider classic readers writers problem 7 common resource say le shared among set reader processes writer processes number readers may simultaneous access le writer needs exclusive access following solution includes two partial methods startread startw rite reader writer gain access resource respec tively upon completion accesses reader releases lock calling total method endread writer calling endw rite assume throughout read write operations nite ie accepted startread eventually followed endread startw rite endw rite employ parameter n solution indicates maximum number readers permitted simultaneous access resource n may set arbitrarily high permit simultaneous access readers following solution based upon one section 610 5 uses pool tokens initially n tokens reader needs 1 token writer n tokens proceed follows many n readers could active simultaneously one writer access resource time upon completion accesses readers writers return tokens hold 1 reader n writer pool following program n number available tokens cat readerwriter partial method startread n partial method startw rite total method endread n total method endw rite n n solution given make guarantee progress either readers writers next solution guarantees readers permanently overtake writers waiting writer writer gains access resource eventually strategy follows boolean variable w riteattempt set true using negative alternative call upon startw rite rejected w riteattempt holds calls startread rejected thus new readers allowed start reading readers eventually stop reading next call startw rite succeed cat readerwriter1 partial method startread n partial method startw rite total method endread n total method endw rite n n w riteattempt false next solution guarantees progress readers writers similar previous solution introduce boolean variable readattempt analogous w riteattempt however analysis considerably complicated case outline operational argument progress guarantees simple objectbased view multiprogramming 291 cat readerwriter2 partial method startread partial method startw rite total method endread n total method endw rite n n w riteattempt false show w riteattempt ever true eventually falsied asserting write operation complete eventually ie endw rite called similarly readattempt ever true eventually falsied prove rst result consider state w riteattempt set true note initially w riteattempt false since n 6 n precondition assignment either read write operation underway latter case write eventually completed calling endw rite thus setting w riteattempt false w riteattempt set read underway call startread accepted successive calls endread eventually establish hold method startw rite execute state none alternatives startread accept call upon endread endw rite made read write operation underway therefore call upon startw rite accepted later followed call upon endw rite argument eventual falsication readattempt similar precondition assignment readattempt true implying either n readers reading write operation underway former case readers allowed join upon completion reading reader readattempt set false latter case upon completion writing endw rite called execution establish riteattempt method startread execute state reader succeeds executing startread eventually execute endread thus falsifying readattempt 35 semaphore binary semaphore often called lock typically associated resource process exclusive access resource holds corresponding semaphore process acquires semaphore completing p operation releases semaphore executing v regard p partial method v total method traditionally semaphore weak strong depending guarantees made eventual success ie acceptance individual calls p weak semaphore guarantee made success particular process matter many times attempts p though asserted call p accepted semaphore available thus specic process may starved never granted semaphore even though another process may hold arbitrarily many times strong semaphore avoids individual process starvation semaphore available innitely often eventually acquired process attempting p operation discuss types semaphores show variations restrict binary semaphores cases extensions general semaphores straightforward 351 weak semaphore following cat describes weak binary semaphore cat semaphore var avail boolean init true finitially semaphore availableg partial method p avail avail false total method v avail true typical calling pattern semaphore shown box user partial action c sp use resource associated sv f actions boxg usually precondition c becomes true remains true process acquires semaphore requirement seuss however c remain true described 352 strong semaphore strong semaphore guarantees absence individual starvation seuss terminology cat contains partial action form precondition c remains true long sp accepted strong semaphore sp eventually accepted following cat implements strong semaphore call upon p includes process id parameter pid type process id procedure p adds caller id queue q id q grants semaphore caller provided semaphore available caller id head queue cat strongsemaphore var q seq pid init hi avail boolean init true finitially semaphore availableg partial method pi pid simple objectbased view multiprogramming 293 total method v avail true observe way negative alternative employed record callers id rejecting call sequence q may replaced fair bag done unordered channel nch note call upon p rejected even queue empty semaphore available straightforward add alternative grant semaphore case process requesting semaphore persistent caller calls p operation innitely often long acquired semaphore otherwise transient caller solution strong semaphore works callers persistent transient caller block callers acquiring semaphore unfortunately exists solution case guarantee every persistent caller eventually acquire semaphore given every holder semaphore eventually releases presence transient callers11 reasonable compromise add new total method strong semaphore cat transient caller may call remove process id queue callers 353 snoopy semaphore traditionally semaphore associated resource rst acquired process executing p resource used semaphore released executing v consider variation traditional model resource released unless outstanding requests resource processes appropriate strategy low contention resource process may use resource long required others describe new kind semaphore called snoopysemaphore show used solve problem later section employ snoopy semaphore solve multiple resource allocation problem starvationfree fashion adopt strategy process used resource snoops see demand time time demand releases semaphore otherwise may continue access resource weak snoopy semaphore shown add new method snoop semaphore cat thus snoopysemaphore three methods p v methods p v meaning traditional semaphores process attempts acquire semaphore calling partial method p releases calling v partial method accepts last call upon p process rejected process typically calls using resource least releases semaphore accepts following solution boolean variable b set false whenever call p accepted set true whenever call p rejected thus b false process acquires semaphore subsequently detects b true semaphore demand cat snoopysemaphore1 var b boolean init false avail boolean init true finitially semaphore availableg partial method p total method v avail true partial method b skip proposed solution implements weak snoopy semaphore guarantee specic process ever acquire semaphore next solution similar strongsemaphore since solution already maintains queue process ids whose calls p rejected implement simply cat strongsnoopysemaphore var q seq pid init hi avail boolean init true finitially semaphore availableg partial method pi pid total method v avail true partial method q 6 hi skip simple objectbased view multiprogramming 295 4 distributed implementation thus far considered program executions action completes another one started section 241 dened tight execution seuss program innite sequence steps step consists executing action box choice actions arbitrary except action box chosen eventually model execution chosen makes programming easier consider another execution model loose execution executions actions may interleaved loose execution exploits available concurrency restrict loose executions manner loose execution may simulated tight execution crucial loose executions notion compatibility among actions set actions pairwise compatible executions noninterfering concurrent execution equivalent serial execution actions precise denition compatibility central theorem establishes correspondence loose tight executions treated section 44 note compatibility weaker notion commutativity holds put get channels see section 44 operations semaphores instance first describe multiprocessor implementation scheduler may initiate several compatible actions concurrent executions also describe general scheduling strategy problem implementations scheduling strategy uniprocessors well multiprocessors dene notion compatibility state fundamental reduction theorem establishes correspondence loose tight executions 41 outline implementation strategy implementation consists 1 scheduler decides action may next scheduled execution 2 processors carry actual executions actions boxes program partitioned among processors processor thus manages set boxes responsible executions actions boxes criterion partitioning boxes processors arbitrary though heuristics may employed minimize message transmissions among processors scheduler repeatedly chooses action execution choice constrained requirement compatible procedures may executed concurrently fairness requirement scheduler sends message corresponding processor start execution action processor starts executing action upon receiving message sched uler may call upon methods processors sending messages waiting responses call includes values procedure parameters part message guaranteed call elicits response either accept reject accept response sent call accepted always case calls upon total methods parameter values returned response reject response possible calls upon partial methods parameter values accompany response 42 design scheduler following abstraction captures essence scheduling problem given nite undirected graph graph need connected vertex graph black white vertices initially white abstraction vertex denotes action black vertex executing action two vertices neighbors incompatible given e every black vertex becomes white eventually steps taken environment control required devise coloring scheduling strategy neighbors simultaneously black ie compatible actions may executed simultaneously s2 every vertex becomes black innitely often thus ensuring fairness note scheduler blacken vertices may whiten vertex simple scheduling strategy blacken single vertex wait environment whitens blacken another vertex strategy implements trivially one black vertex time s2 may ensured blackening vertices xed roundrobin order protocol however defeats goal concurrent execution impose additional requirement scheduling strategy maximal allow valid concurrent executions actions innite sequence satises es1s2 possible execution scheduler maximal scheduler general scheduler execution another scheduler possible execution maximal scheduler suitable renement maximal sched uler derive centralized scheduler distributed scheduler see 12 formal denition maximality condition scheduling strategy assign natural number called height vertex let xh denote height vertex x maintain invariant neighbors dierent heights invariant neighbors xh 6 yh vertex x xlow holds height x smaller neighbors ie xlow 8y x neighbors xh yh write vblack denote v black given state scheduling strategy simple objectbased view multiprogramming 297 c1 consider vertex v blackening eventually vblackvlow holds blacken v c2 simultaneous whitening vertex v environment increase vh preserving invariant shown 12 scheduling strategy satises s1s2 maximal sense described previously 43 implementation scheduling strategy 431 central scheduler central scheduler implements given strategy may operate follows scheduler scans vertices blackens vertex holds eect blackening send message appropriate processor specifying selected action may executed upon termination execution action message sent scheduler scheduler whitens corresponding vertex increases height ensuring two neighbors height scheduler may scan vertices order every vertex must considered eventually required c1 implementation may improved maintaining set l vertices white low ie l contains vertices v vblack vlow holds scheduler blackens vertex l removes l whenever vertex x whitened height increased scheduler checks x neighbors determine vertices qualify inclusion l vertex qualies added l guaranteed every vertex l eventually scanned removed one way keep l list additions done rear deletions front observe vertex l remains white low blackened 432 distributed scheduler proposed scheduling strategy distributed vertex blackens eventually white low vertices communicate messages special form called token associated edge x token token value positive integer value token x jxh yhj token held either x whichever smaller height follows description vertex holds incident tokens height smaller neighbors vertex white may color black vertex upon becoming white increases height 0 eectively reducing value incident token note vertex holds incident tokens hence alter values quantity dierent token values neighbors height ie token value becomes zero vertexs height increased token x ys value becomes negative result reducing indicating holder x greater height x resets token value absolute value sends token observe vertices need query heights token eventually sent vertex lower height also since token value dierence heights neighbors possible bound token values whereas vertex heights unbounded course computa tion initially token values computed tokens placed appropriately based heights vertices need keep vertex heights explicitly left open question vertexs height increased whitened requirement neighbors never height particularly interesting scheme increase vertexs height beyond neighbors heights whenever whitened amounts sending incident tokens neighbors vertex whitened strategy token values immaterial white vertex blackened holds incident tokens upon whitened vertex sends incident tokens neighbors assuming edge x directed tokenholder x graph initially acyclic blackening whitening move preserves acyclicity strategy employed solving distributed dining philosophers problem chandy misra 4 black vertex eating white vertex hungry constraint s1 amounts wellknown requirement neighboring philosophers eat simultaneously current problem counterpart thinking state added slight complication solution 4 tokens called forks solution described section 41 actions vertices partitioned among group processors distributed scheduling strategy modied slightly steps prescribed vertices taken processors behalf constituent actions message transmissions among vertices processor simulated simple manipulations data structures processor 44 compatibility loose execution program allows compatible actions executed si multaneously section give denition compatibility state reduction theorem says eect loose execution may simulated tight execution executions dierent actions interleaved expect user specify compatibility relation procedures within box compatibility relation among procedures computed e ciently denition given states box given values variables state program given box states procedure partial total associate binary relation program states informally u v 2 p program states denotes tight execution p moves state system u v following concatenation procedure names simple objectbased view multiprogramming 299 corresponds relational product strings x write x denote relation corresponding x subset relation corresponding procedures p q compatible denoted p q following conditions hold observe symmetric relation c1 p q box p total qp pq q total pq qp c2 p q dierent boxes transitive closure relation partial order boxes condition c0 requires procedures called compatible procedures compatible condition wellgrounded p calls condition c1 says p q box eect executing partial procedure total procedure simulated executing reverse order condition c2 says compatible procedures impose similar ie noncon icting partial orders boxes notes 1 procedures parameters compatibility checked possible values parameters 2 partial procedures box always compatible 3 total procedures p q box compatible provided example compatibility consider unbounded fo channel section 31 show get put ie x getx puty puty getx note pair states u v u represents empty channel belong relation getx nal states given values x r identical preceding argument shows two procedures dierent boxes call put get ie sender receiver may execute concurrently since get get denition multiple receivers may also execute concurrently however case put put fo channel sequence appending pair items dierent orders result dierent sequences therefore multiple senders may execute concurrently 300 jayadev misra lemma 1 let p q p total p q may belong box qp pq crucial lemma establishing reduction theorem given lemma permits total procedure p moved left procedure compatible strategy employed bring components single procedure together thereby converting loose execution tight execution observe resulting tight execution establishes identical nal state starting initial state original loose execution therefore properties loose executions may derived tight executions proof following theorem see chapter 10 20 reduction theorem let e denote nite loose execution set ac tions exists tight execution f actions e f simple objectbased view multiprogramming 301 5 concluding remarks traditionally multiprograms consist processes execute autonomously typical process receives requests processes may call upon processes data communication synchronization interaction mechanism shared memory message passing broadcast etc denes platform suitable implement specic multiprogram seuss model view multiprogram set actions action deals one aspect system functionality execution action waitfree additionally specify conditions action executed typical actions operating system may include ones garbage collection response device failure posting appropriate warnings initiation communication receiving request instance process control systems avionics telephony may contain actions processing received data updates internal data structures outputs display archival recordings seuss view multiprogramming regarded 1 coding actionbodies 2 specifying conditions actionbody executed diers markedly conventional view consider justify dierences first seuss insists program execution understood single thread control avoiding interleaved executions actionbodies simpler understand single thread formalize understanding within logic implementation however need restricted single thread long achieves eect singlethread execution show implementations may exploit structures seuss programs user supplied directives run concurrent threads consequence single thread notion waiting abandoned thread aord wait another thread whose execution terminate waiting rendezvousbased interactions 9 17 require least two threads control meaningful abandoned model execution replaced waiting refusal procedure execute instance call upon p operation semaphore could cause caller wait replaced call rejected semaphore appropriate state caller attempts call repeatedly ensuing execution second cat mechanism grouping related actions process though traditional processes may encoded cats done multiplex database cat used encode protocols communi cation synchronization mutual exclusion used encode objects objectoriented programming method communication among cats procedure calls much like programming methodology based remote procedure calls minimality model makes possible develop simple theory programming third seuss divides multiprogramming world 1 programming action bodies whose executions waitfree 2 specifying conditions orchestrating executions action bodies dierent theories programming methodologies appropriate two tasks particular action bodies sequential programs traditional sequential programming methodologies may adopted developments orchestration actions employ multiprogramming theory largely independent actionbodies seuss addresses design aspects multiprograms ie combine actions designs actionbodies separation sequential multiprogramming features also advocated browne et al 3 fourth seuss severely restricts amount control available programmer multiprogramming level component actions program executed innite repetitions particular sequencing two actions implemented explicitly loss exibility expected controlling larger abstractions analogy observe machine language offers complete control aspects machine operation instructions may treated data data types may ignored entirely control ow may altered arbitrarily exibility appropriate piece code short human eye follow arbitrary jumps mistreatment data explained away comment flow charts particularly useful unraveling intent short tangled piece code higher levels control structures sequential programs typically limited sequential composition alternation repetition arbitrary jumps nearly vanished highlevel programming flow charts limited value level programming intricate manipulations dangerous attempted higher level prudent programmers limit appropriate programming methodologies order avoid dangers expect rules combination become even simpler multiprogramming level propose component actions multiprogram executed using form repeated nondeterministic selection work incorporates ideas serializability atomicity databases2 notions objects inheritance16 communicating sequential processes9 io automata14 temporal logic actions13 partial procedure similar database nested transaction may commit abort procedure commits execute precondition holds preprocedure commits aborts otherwise typical abort database transaction requires rollback valid state seuss partial procedure change program state commits therefore need rollback form partial procedure inspired communicating sequential processes9 model may viewed special case csp disallow nested partial procedures seuss outgrowth earlier work unity 5 unity program consists statements may change program state program execution starts specied initial state statements program chosen execution nondeterministic fashion subject fairness rule statement chosen eventually unity statements particularly simple assignments program variables model allowed programming abstractions besides asynchronous compositions programs seuss attempt simple objectbased view multiprogramming 303 build compositional model multiprogramming retaining advantages unity action similar statement though expect actions much larger size added structure unity distinguishing total partial procedures imposing hierarchy cats executing actions indivisible units would extract heavy penalty perfor mance therefore developed theory permits interleaved executions actions programs unity interact operating shared data space seuss cats however shared data interact procedure calls sense cats may share cats unity issues deadlock starvation progress liveness etc treated making assertions sequence states every execution also unity program termination basic concept program reached xed point preconditions actions false execution program change state implementation may terminate program execution reaches xed point developed simple logic unity recent devel opments see 19 18 6 applicable seuss well acknowledgments profoundly grateful rajeev joshi provided number ideas leading formulation concept compatibility reduction theorem many ideas paper developed discussions lorenzo alvisi adams calvin lin also indebted participants marktoberdorf summer school 1998 particularly tony hoare interactions 304 jayadev misra r sorting networks applications concurrency control recovery database systems language speci drinking philosophers problem parallel program design foundation towards compositional speci concurrent control readers writers solution problem concurrent programming control communicating sequential processes personal communication impossibility robust solutions fair resource allocation maximally concurrent programs temporal logic actions introduction inputoutput automata temporal logic reactive concurrent systems communication concurrency logic concurrent programming progress logic concurrent programming safety discipline multiprogramming note reliable fullduplex transmission halfduplex links tr drinking philosophers problem communicating sequential processes concurrency control recovery database systems temporal logic reactive concurrent systems temporal logic actions objectoriented software construction 2nd ed concurrent control myampersandldquoreadersmyampersandrdquo myampersandldquowritersmyampersandrdquo note reliable fullduplex transmission halfduplex links solution problem concurrent programming control discipline multiprogramming communication concurrency maximally concurrent programs impossibility robust solutions fair resource allocation ctr emil sekerinski verification refinement finegrained actionbased concurrent objects theoretical computer science v331 n23 p429455 25 february 2005
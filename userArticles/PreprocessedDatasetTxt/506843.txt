mutual exclusion algorithm ad hoc mobile networks faulttolerant distributed mutual exclusion algorithm adjusts node mobility presented along proof correctness simulation results algorithm requires nodes communicate current neighbors making wellsuited ad hoc environment experimental results indicate adaptation mobility improve performance similar nonadaptive algorithms nodes mobile b introduction mobile ad hoc network network wherein pair nodes communicates sending messages either direct wireless link sequence wireless links including one intermediate nodes direct communication possible pairs nodes lie within one anothers transmission radius wireless link failures occur previously communicating nodes move longer within transmission range like wise wireless link formation occurs nodes far separated extended version paper presented dial mobility workshop dallas tx oct 30 1998 supported ge faculty future dept education gaann fellowships supported part nsf pyi grant ccr9396098 nsf grant ccr9972235 supported part texas advanced technology program grant 010115248 nsf grants cda9529442 ccr9972235 communicate move within transmission range characteristics distinguish ad hoc networks existing distributed networks include frequent unpredictable topology changes highly variable message delays characteristics make ad hoc networks challenging environments implement distributed algorithms past work modifying existing distributed algorithms ad hoc networks includes numerous routing protocols eg 8911131618192224 wireless channel allocation algorithms eg 14 protocols broadcasting multicasting eg 8122126 dynamic networks xed wired networks share characteristics ad hoc networks since failure repair nodes links unpredictable cases research dynamic networks focused total ordering 17 endtoend communication routing eg 12 existing distributed algorithms run correctly top ad hoc routing protocols since protocols designed hide dynamic nature network topology higher layers protocol stack see figure 1a routing algorithms ad hoc networks provide ability send messages node node however contention eciency gained developing core set distributed algorithms primitives aware underlying mobility network shown figure 1b paper present mobility aware distributed mutual exclusion algorithm illustrate layering approach figure 1b user applications distributed primitives routing protocol distributed primitives routing protocol ad hoc network user applications ad hoc network b figure 1 two possible approaches implementing distributed primitives mutual exclusion problem involves group processes intermittently requires access resource piece code called critical section cs one process may cs given time providing shared access resources mutual exclusion fundamental problem computer science worth considering ad hoc environment strippeddown mobile nodes may need share resources distributed mutual exclusion algorithms rely maintenance logical structure provide order eciency eg 2025 may inecient run mobile environment topology potentially change every node movement badrinath et al3 solve problem cellular mobile networks bulk computation run wired portions network present mutual exclusion algorithm induces logical directed acyclic graph dag network dynamically modifying logical structure adapt changing physical topology ad hoc environment present simulation results comparing performance algorithm static distributed mutual exclusion algorithm running top ad hoc routing protocol simulation results indicate algorithm better average waiting time per cs entry message complexity per cs entry greater cost incurred static mutual exclusion algorithm running top ad hoc routing algorithm next section discusses related work section 3 describe system assumptions dene problem detail section 4 presents mutual exclusion algorithm present proof correctness discuss simulation results sections 5 6 respectively section 7 presents conclusions 2 related work token based mutual exclusion algorithms provide access cs maintenance single token cannot simultaneously present one node system requests cs entry typically directed whichever node current token holder raymond 25 introduced token based mutual exclusion algorithm requests sent static spanning tree network toward token algorithm resilient nonadjacent node crashes recoveries resilient link failures chang et al7 extend raymonds algorithm imposing logical direction sucient number links induce token oriented dag every node exists directed path originating terminating token holder allowing request messages sent links dag provides resilience link site failures however algorithm consider link recovery essential feature system mobile nodes dhamdhere kulkarni 10 show algorithm 7 suer deadlock solve problem assigning dynamically changing sequence number node forming total ordering nodes system token holder always highest sequence number dening links point node lower higher sequence number token oriented dag maintained due link failures node wants send request token may nd outgoing links token holder situation oods network messages build temporary spanning tree token holder becomes part spanning tree token passed directly node along tree bypassing requests since priority given nodes lose path token holder seems likely requesting nodes could starved long link failures continue also ooding response link failures storing messages delivery link recovery make algorithm illsuited highly dynamic ad hoc environment token based algorithm combines ideas several papers partial reversal technique 13 used maintain destination oriented dag packet radio network destination static used algorithm maintain token oriented dag dynamic destination like algorithms 25 7 10 node algorithm maintains request queue containing identiers neighboring nodes received requests token like 10 algorithm totally orders nodes lowest node always current token holder making sink toward requests sent algorithm also includes new features node dynamically chooses lowest neighbor preferred link token holder nodes sense link changes immediate neighbors reroute requests based status previous preferred link token holder current contents local request queue requests reaching token holder treated symmetri cally requests continually serviced dag reoriented blocked requests rerouted 3 denitions system contains set n independent mobile nodes communicating message passing wireless network mobile node runs application process mutual exclusion process communicate ensure node cycles remainder section interested cs waiting section waiting access cs critical section assumptions 1 mobile nodes network 1 nodes unique node identiers 2 node failures occur 3 communication links bidirectional fifo 4 linklevel protocol ensures node aware set nodes currently directly communicate providing indications link formations failures 5 incipient link failures detectable providing reliable communication perhop basis 6 partitions network occur rest section contains formal denitions explicitly model mutual exclusion process node constraints behavior application processes network appear conditions executions system architecture shown figure 2 assume node identiers 0 1 node mutual exclusion process modeled state machine usual set states initial states transition function state contains local variable holds node identier local variable holds current neighbors node transition function described detail shortly application process mutual exclusion process network node requestcs entercs figure 2 system architecture section 7 discussion relaxing assumption 6 conguration describes instantaneous state whole system mally set n states one process initial conguration state initial state neighbor variables describe connected undirected graph step process node triggered occurrence input event input events application process node requests access cs entering waiting section application process node releases access cs entering remainder section recv j node receives message node j receives notication link l incident linkdown l node receives notication link l incident eect step apply process transition function taking input current state process input event producing output possibly empty set output events new state process output events mutual exclusion process node informs application process enter critical section send j node sends message node j constraint state produced transition function neighbor set variable must properly updated response linkup linkdown event called application events called network events execution sequence form c c k congurations k input events k sets output events execution must end conguration nite positive real number associated representing time event occurs execution must satisfy number additional conditions list rst set conditions basic syntactic ones c 0 initial conguration k occurs node k state c k correct according transition function operating k state c k 1 times assigned steps must nondecreasing execution innite times must increase without bound one step process occur given time next set conditions require application process interact properly mutual exclusion process k requestcs previous application event node k releasecs previous application event node must remaining conditions constrain behavior network match informal description given first consider mobility notication occurs time linkup j l occurs time l joins j furthermore linkup l occurs j currently neighbor according neighbor variable analogous condition holds linkdown linkdown never disconnects graph finally consider message delivery must exist onetoone onto correspondence occurrences send j recv j j requirement implies every message sent received network duplicate corrupt messages deliver spurious messages furthermore correspondence must satisfy following send j occurs time corresponding recv j occurs later time 0 link connecting j continuously 0 implies linkdown event link l cannot occur messages transit l state problem formally every execution following must hold k entercs previous application event node must requestcs ie cs access given requesting nodes mutual exclusion k entercs previous entercs j event must followed releasecs j prior k nite number linkup linkdown events k requestcs following entercs last condition hypothesis link changes cease needed adversarial pattern link changes cause starvation 4 reverse link rl mutual exclusion algorithm section rst present data structures maintained node system followed overview algorithm algorithm pseudocode examples algorithm operation throughout section data structures described node 0 n 1 subscripts data structures indicate node included needed 41 data structures status indicates whether node waiting critical remainder section initially status remainder set nodes direct wireless contact node initially n contains node neighbors myheight threetuple h1h2i representing height node links considered directed nodes higher height toward nodes lower height based lexicographic ordering eg myheight myheight link nodes would directed node 1 node 2 initially node 0 initialized directed links form dag every node directed path node 0 heightj array tuples representing node view myheight j initially node viewpoint link j incoming node heightj myheight outgoing node heightj myheight tokenholder flag set true node holds token set false otherwise initially next node holds token next otherwise next node outgoing link initially next next outgoing neighbor otherwise q queue containing identiers requesting neighbors operations q include enqueue enqueues item already q de queue usual fifo semantics delete removes specied item q regardless location initially receivedlij boolean array indicating whether linkinfo message received node j token message recently sent height information received node node j receivedlij false recorded heightj initially receivedli formingj boolean array set true link node j detected forming reset false rst linkinfo message arrives node j initially forming formheightj array tuples storing value myheight new link rst detected initially formheight 42 overview rl algorithm mutual exclusion algorithm eventdriven event node consists receiving message another node j 6 indication link failure formation link layer input application node request release cs message sent includes current value height sender modules assumed executed atomically first describe pseudocode triggered events describe pseudocode procedures requesting releasing cs node requests access cs enqueues identier q sets status waiting node currently hold token single element queue calls forwardrequest send request message node hold token set status critical enter cs since head q node releases cs calls givetokentonext send token message q nonempty sets status remainder request messages request message sent neighboring node j received node ignores request receivedlij false otherwise changes heightj enqueues j q link j incoming q nonempty status remainder calls givetokentonext holds token nontoken holding node calls raiseheight link j incoming outgoing links calls forwardrequest nonempty link next reversed token messages node receives token message neighbor j lowers height lower last token holder node j informs outgoing neighbors new height sending linkinfo messages calls givetokentonext node also informs j new height j know received token messages receivedlij true linkinfo message received node node j js height saved heightj receivedlij false checks height j message sent token message j sets receivedlij true formingj true current value myheight compared value myheight link j rst detected formheightj myheight formheightj dierent linkinfo message sent j identier j added n formingj set false j element q j outgoing link j deleted q node outgoing links token holder calls raiseheight outgoing link formed otherwise q nonempty link next reversed calls forwardrequest since must send another request token link failures node senses failure link neighboring node j removes j n sets receivedlij true j element q deletes j q token holder outgoing links calls raiseheight node token holder q nonempty link next failed calls forwardrequest since must send another request token link formation node detects new link node j sends linkinfo message j myheight sets formingj true sets myheight procedure forwardrequest selects node lowest height neighbor next sends request message next procedure givetokentonext node dequeues rst node q sets next equal value next enters cs next 6 lowers heightnext myheighth1 myheighth2 1 next incoming request messages sent next sets tokenholder false sets receivedlinext false sends token message next q nonempty sending token message next request message sent next immediately following token message token eventually returned procedure raiseheight called nontoken holding node loses last outgoing link node raises height lines 13 using partial reversal method 13 informs neighbors height change linkinfo messages nodes q links outgoing deleted q q empty point forwardrequest called since must send another request token 43 rl algorithm node requests access cs 1 status waiting 2 enqueueq 3 tokenholder 4 5 else givetokentonext node releases cs 1 jqj 0 givetokentonext 2 status remainder requesth received node node j h denotes js height message sent 1 receivedlij 2 heightj h set view js height 3 myheight heightj enqueueq 4 tokenholder 5 status remainder jqj 0 givetokentonext 6 else tokenholder 7 myheight heightk 8 k 2 n raiseheight 8 else 9 forwardrequest reroute request tokenh received node node j h denotes js height message sent 1 tokenholder true 2 heightj h 3 send linkinfohh1 hh2 1 outgoing k 2 n j 4 myheighth1 hh1 5 myheighth2 hh2 1 lower height 6 jqj 0 givetokentonext else next linkinfoh received node node j h denotes js height message sent 1 n n fjg 2 formingj myheight 6 formheightj 3 send linkinfomyheight j 4 formingj false 5 receivedlij heightj h 6 else 7 myheight heightj deleteq 8 myheight heightk 8k 2 n tokenholder raiseheight reroute request 9 else jqj 0 myheight heightnext forwardrequest failure link j detected node 1 n n fjg 2 deleteq 3 receivedlij true 4 tokenholder 5 myheight heightk 8k 2 n raiseheight reroute request 6 else jqj 0 next 62 n forwardrequest formation link j detected node 1 send linkinfomyheight j 2 formingj true 3 formheightj myheight procedure 1 next l 2 send requestmyheight next procedure givetokentonext called jqj 0 1 next dequeueq 2 next 6 3 tokenholder false 4 heightnext myheighth1 myheighth2 1 next 5 receivedlinext false 6 send tokenmyheight next 7 jqj 0 send requestmyheight next 8 else next 9 status critical 10 enter cs procedure 1 2 3 6 myheighth2 min l2s fheightlh2g 1 4 send linkinfomyheight k 2 n raising height cause links become outgoing 5 k 2 n myheight heightk deleteq must reroute request queue nonempty since outgoing links 6 jqj 0 forwardrequest 44 examples algorithm operation rst discuss case static network followed dynamic network illustration algorithm static network links fail form depicted figure 3 snapshots system conguration algorithm execution shown time increasing 3a 3e direct wireless links shown dashed lines connecting circular nodes arrow wireless link points higher height node lower height node request queue node depicted rectangle height shown 3tuple token holder shaded circle next pointers shown solid arrows note node holds token next pointer directed towards figure nodes 2 3 requested access cs note nodes 2 3 enqueued q 2 q 3 sent request messages node 0 enqueued q 0 order request messages received part b depicts system later time node 1 requested access cs sent request message node 3 note 1 enqueued q 1 q 3 figure 3c shows system conguration node 0 released cs sent token message node 3 followed request sent node 0 behalf node 2 observe logical direction b c figure 3 operation reverse link mutual exclusion algorithm static network link node 0 node 3 changes directed away node 3 part b directed toward node 3 part c node 3 receives token message lowers height notice also next pointers nodes 0 3 change nodes next pointers directed toward node 0 part b nodes next pointers directed toward node 3 part c part shows system conguration node 3 sent token message node 1 followed request message request message sent node 3 received request message node 0 notice items head nodes request queues part form path token holder node 1 sole remaining requester node 2 part e depicts system conguration token messages passed node 1 node 3 0 node 0 2 observe middle element h2 nodes myheight tuple decreases 1 every hop token travels token holder always lowest height node system consider execution rl algorithm dynamic network height information allows node keep track current logical direction links neighboring nodes particularly node chosen next link next changes jqj 0 node must reroute request calling forwardrequest figure 4a shows snapshot system execution shown figure 3a time increasing 4a 4e figure 4b depicts system conguration node 3 moved relation nodes b c e figure 4 operation reverse link mutual exclusion algorithm dynamic network system resulting network temporarily token oriented since node 3 outgoing links node 0 adapted lost link node 3 removing 3 request queue node 2 takes action result loss link node 3 since link next 2 aected node 2 still one outgoing link part c node 3 adapted loss link node 0 raising height sent request message node 1 yet arrived node 1 part shows system conguration node 1 received request message node 3 enqueued 3 q 1 raised height due loss last outgoing link part e node 1 propagated request received node 3 sending request node 2 also informing node 2 change height node 2 subsequently enqueued 1 q 2 raise height send request node 2 intact link next 2 node 0 already sent unfullled request 5 correctness reverse link algorithm following theorem holds one token system time theorem 1 algorithm ensures mutual exclusion prove starvation rst show link changes cease eventually system reaches good conguration apply variant function argument show link changes cease logical directions links imparted height values eventually form token oriented dag since height values nodes totally ordered cannot cycles logical graph thus dag hard part showing dag token oriented dened next denition 1 node token holder conguration tokenholder true token message transit node next denition 2 dag token oriented conguration every node exists directed path originating node terminating token holder prove lemma 3 dag eventually token oriented rst show lemma 1 condition equivalent absence sink nodes 13 dened show lemma 2 eventually calls raiseheight throughout assume eventually link changes cease denition 3 node sink conguration lemma 1 every conguration every execution dag token oriented sinks proof onlyif direction follows denition token oriented dag direction proved contradiction assume contradiction exists node conguration tokenholder false directed path starting ending token holder since sinks must least one outgoing link incoming node since number nodes nite network connected links logically directed logical path form cycle must exist directed path token holder contradiction show eventually sinks lemma 3 show nite number calls raiseheight lemma 2 every execution nite number link changes exists nite number calls raiseheight proof contradiction consider execution nite number link changes innite number calls raiseheight link changes cease node calls raiseheight innitely often rst note one node calls raiseheight innitely often every node calls raiseheight innitely often see consider node would call raiseheight innitely often lost outgoing links innitely often would happen innitely often node neighboring node j raised height innitely often neighboring node j would call raiseheight innitely often neighbor k raised height innitely often however claim 1 shows least one node calls raiseheight nite number times 1 node holds token last link change ever calls subsequently proof suppose claim false node holds token last link change calls raiseheight subsequently let rst node code node hold token calls raiseheight suppose node sends token neighboring node j time 1 setting view j outgoing later time 3 node calls raiseheight reason calls raiseheight time 3 lost last outgoing link thus time 2 time 1 3 link j reversed direction view outgoing incoming code direction change node must due receipt linkinfo request message node j discuss cases separately case 1 direction change node due receipt linkinfo message node j time 2 code sends token j 1 sets receivedlij false therefore linkinfo message received j time 2 node must already reset receivedlij true would still see link j outgoing would call raiseheight time 2 since called receiving linkinfo message j time 2 must received linkinfo message node j sent received token time 2 fifo assumption message delivery node must received token sent another node k 6 j raised height sent linkinfo message node received time 2 however violates assumption rst node call raiseheight last link change contradiction case 2 direction change node due receipt request message node j time 2 similar argument case 1 request received node j would ignored node long receivedlij false means node j must called raiseheight received token node subsequently sent request received time 2 violates assumption rst node call raiseheight last link change contradiction therefore node call raiseheight time 2 claim true therefore claim 1 nite number calls raiseheight execution nite number link changes lemma 3 follows lemma 2 since node becomes sink eventually informed via linkinfo messages call raiseheight lemma 3 link changes cease logical direction links imparted height values eventually always form token oriented dag consider node waiting execution point link changes calls raiseheight ceased rst dene request chain node path along request propagated modify variant function argument 25 show node eventually gets enter cs denition 4 given conguration request chain node l nonempty request queue maximal length list node identiers queue empty link p 1 p outgoing p 1 incoming p request message transit p 1 p token message transit p p 1 lemma 4 gives useful information going end request chain lemma 4 following true every conguration let l node nonempty request queue let request chain l q l l waiting c either p j token holder token message transit p j request message transit p j next p j linkinfo message transit next p j p j next p j higher next p j sees link p j failed proof induction execution property easily shown hold since node enqueues identier application requests access cs point changes status waiting code point node dequeue identier enters cs sets status critical properties b c vacuously true initial conguration since node nonempty queue suppose b c true 1 st conguration c 1 execution possible show properties true th conguration considering turn every possibility th event events applied c 1 easily shown yield conguration c properties b c true discuss events outcome less clear presenting problematic cases appear disrupt request chain note following cases nontoken holding nodes often required nd outgoing link due link reversals failures hard show node token holder always nd outgoing link due performance raiseheight case 1 node receives requesth node j enqueue j request queue ensure js request overlooked causing possible starvation show either linkinfo token message sent j request j received j enqueued case 11 receivedlij false must sent token j previous conguration yet received linkinfo message j must send upon receipt token token transit j held j c 1 earlier j token passed request received sent linkinfo message j must send upon receipt token j waiting c 1 already sent newer request properties b c hold request chain c inductive hypothesis case 12 receivedlij true j enqueued request queue must myheight h since viewed outgoing sent request node must either called n relative heights j changed time link rst detected j added n either case node j must eventually receive linkinfo message see link next j reversed case j take action resulting eventual sending another request case 2 node receives input causing delete identier j request queue ensure js request forgotten calls deleteq j show either node j received token message prior deletion case js request satised node j notied link failed case j take appropriate action reroute request chain case 21 node calls deleteq receives linkinfo message j indicating link j become outgoing since enqueued j must earlier conguration saw link j incoming since receipt linkinfo message j caused link change incoming outgoing view must linkinfo sent j j received token lowered height token held j c 1 earlier j token passed j waiting c 1 already sent newer request properties b c hold request chain c inductive hypothesis case 22 node calls deleteq received indication link must receive indication case take appropriate action advance request chains case 3 node receives input makes see link next incoming failed case request chains including node c 1 end c show node takes correct action propagate request chains sending either new request linkinfo message case 31 node receives linkinfo message neighbor indicating link j become incoming link j last outgoing link c call raiseheight node delete identiers nodes outgoing links request queue node send linkinfo message neighbor including nodes whose identiers removed request queue request queue nonempty call forwardrequest send request message node chosen next case 32 node receives indication link next failed c take actions case 31 link next reversed therefore action taken node make properties b c false lemma holds lemma 5 link changes calls raiseheight cease every cong uration node ls request chain include token holder later conguration ls request chain include token holder proof lemma 3 link changes cease eventually token oriented dag formed consider conguration link changes calls raiseheight cease dag token oriented meaning linkinfo messages generated nodes raise heights delivered proof contradiction assume node ls request chain never includes token holder token held transit nodes ls request chain assumption execution linkinfo messages caused call raiseheight transit node ls request chain node ls request chain detect failed link neighboring node therefore lemma 4c request message must transit node ls request chain node ls request chain number nodes ls request chain increase request message received point ls request chain either include token holder another request message transit node ls request chain node ls request chain ls request chain joined request chain node number nodes ls request chain increases number nodes ls request chain decreases since nite number nodes system eventually ls request chain includes nodes therefore token eventually contained ls request chain system contradiction let l node waiting link changes calls raise cease given conguration execution function v l l dened following vector positive integers let ls request chain v l either depending whether request message transit p either case v 1 position p 1 l q l 1 j v j position p j 1 positions numbered ascending order 1 head queue request message transit v l l elements vectors compared lexicographically lemma 6 v l variant function proof key points prove l never n entries every entry 1 n range v l wellfounded 2 events easily seen increase v l discuss remaining events request message end ls request chain received node j node p ls request chain increases length decreases m1 p position q j request message received token message received node p end ls request chain either kept p v l decreases hv sent toward l v l decreases hv sent away l followed request message v l decreases 3 see events cause v l decrease continue occur consider following two cases case 1 token holder ls request chain lemma 5 eventually token holder ls request chain case 2 token holder ls request chain since node stays cs forever later time token sent received decreasing value v l part 2 proof v l equals h1i l enters cs theorem 2 link changes cease every request eventually satised 6 simulation results section discuss static dynamic performance reverse link rl algorithm compared mutual exclusion algorithm designed operate static network simulated raymonds token based mutual exclusion algorithm 25 running top routing layer always provided shortest path routes nodes section refer simulation raymonds routing rr raymonds algorithm used static algorithm rl algorithm adapted provide link failures recovery must rely routing layer maintain logical paths run dynamic network order make results generally applicable made bestcase assumptions underlying routing protocol used raymonds algorithm always provides shortest paths time message complexity zero simulation shows rl algorithm better rr combination scenario rl algorithm also better raymonds algorithm scenario real ad hoc routing algorithm used simulation shows rl algorithm worse rr combination scenario might might worse actual situation depending much worse simulation costs routing algorithm simulated node system various scenarios chose simulate system networks larger nodes time needed simulation high also envision ad hoc networks much smaller scale wired networks like internet typical numbers nodes used simulations ad hoc networks range 10 50 46151826 experiments cs execution took one time unit message delay one time unit requests cs modeled poisson process arrival rate req thus time delay node left cs made next request enter cs exponential random variable mean 1 time units link changes modeled poisson process arrival rate mob thus time delay change graph exponential random variable mean 1 mob time units change graph consisted deletion link chosen random whose loss disconnect graph formation link chosen random execution measured average waiting time cs entry average number time units nodes spent waiting sections also measured average number messages sent per cs entry varied load system req degree mobility mob connectivity graph connectivity measured percentage possible links present graph note clique nodes 435 undirected links graphs results plotted point represents average six repetitions simulation thus plots average time per cs entry point average averages six executions similarly plots average number messages per cs entry rr simulations initially formed random connected graph desired number links used breadthrst search form spanning tree graph play part static virtual spanning tree nodes communicate raymonds algorithm spanning tree formed randomly permuted graph maintaining desired connectivity calculated shortest paths nodes neighbors virtual spanning tree started mutual exclusion algorithm began counting messages waiting time per cs entry link changes occurred measure time messages needed recalculate shortest path routes modied graph measure added time distance application messages traveled due route changes charging one message per link traversed simulations rl formed random connected graph desired number links initialized node heights link directions started algorithm performance measurements link changes occurred time messages needed nd new routes nodes included overall cost performance section part gure displays results graph static part b low mobility part c choice value low mobility parameter corresponds situation nodes remain stationary tens seconds moving prior making another move choice value high mobility parameter represents much volatile network nodes remain static seconds moves 61 average waiting time per cs entry load request arrival rate load request arrival rate20601001401800001 b time unitscs entry time unitscs entry load request arrival rate time unitscs entry rr 20 connectivity rr 80 connectivity rl 80 connectivity rl 20 connectivity figure 5 load vs timecs entry zero b low c high mobility figure 5 plots average number time units elapsed host request subsequent entry cs values req increasing 10 4 mean time units requests requests 1 left right along x axis chose high load value req rate node would request pending almost time low load value req represents much less busy network requests rarely pending nodes time plots shown runs 20 87 links 80 348 links connectivity rl rr simulations figure 5 indicates rl better performance rr terms average waiting time per cs entry factor six reason raymonds algorithm sends application messages static virtual spanning tree message sent node one neighbors virtual spanning tree may actually routed long distance thus increasing time delay contrast rl algorithm uses accurate information actual topology resulting less delay request subsequent cs entry algorithms show increase average waiting time per cs entry low high load figure 5 higher load larger number nodes precede given node cs average waiting time cs entry reaches peak rl simulation around 75 time units per cs entry highest load caused essentially round robin pattern token traversal however average waiting time rl simulation figure 5c highest load actually decreases high mobility phenomenon may due fact high loads frequent link failures break fair pattern token received causing nodes get token frequently figure 5 also shows waiting time advantage rl rr increases increasing load increasing mobility increased waiting time rr increased load network connectivity low due longer average route lengths simulation trials average route length roughly doubled connectivity decreased 80 20 performance gap waiting time rl rr seen lesser degree high connectivity average route length rr lower however apparent rr simulation suers combined eects higher contention imposed static spanning tree communication paths high loads rl mainly aected contention cs high loads finally figure 5 suggests connectivity range tested immaterial behavior rl algorithm high load whereas larger connectivity better rr smaller connectivity loads order study eect connectivity ran experiments shown figure 6 average number time units elapsed host request subsequent entry cs plotted network connectivity increasing 10 43 links 100 435 links along x axis curves plotted low load mean time unit requests load mean time unit requests rl rr simulations rl low load rr high load rr low load101000 x101000 connectivity connectivity b time unitscs entry time unitscs entry time unitscs entry connectivity figure 6 connectivity vs timecs entry zero b low c high mobility figure 6 conrms connectivity aect waiting time per cs entry rl simulation high load high load rl algorithm exploit connectivity load high rl simulation always sends request messages path last traveled token even shorter path token request made low load rl connectivity aect waiting time per cs entry request messages always sent path last traveled token lower load sucient time requests token movement change link direction vicinity token holder eect increases higher connectivity shortening request paths waiting time rr algorithm decreases increasing connec tivity since path lengths neighbors virtual spanning tree approach one however even clique shortest path lengths one time rr match rl reason spanning tree used rr communication might relatively large diameter whereas rl neighboring nodes always direct communication results simulations section summarized table 1 zero mobility low mobility high mobility connectivity 20 80 20 80 20 80 rr high load 185 107 185 140 294 290 rl high load rr low load 17 8 rl low load 7 4 table 1 summary time per cs entry 62 average number messages per cs entry rr algorithm sends request token messages along virtual spanning tree message node virtual neighbor converted sequence actual messages traverse current shortest path sender recipient rl algorithm sends request token messages along actual token oriented dag addition token traverses path node path sends linkinfo messages outgoing neighbors additional linkinfo messages sent propagated link failure causes node lose last outgoing link experimental results ect relative number routing messages rr vs linkinfo messages rl interpreting results important remember simulation rr algorithm charged messages needed recalculate routes due topology changes thus rl better rr situation certainly better routing messages charged even prorated also rr better rl another load request arrival rate a10152535100010load request arrival ratex entry entry entry load request arrival rate rr 20 connectivity rr 80 connectivity rl 80 connectivity rl 20 connectivity figure 7 load vs messagescs entry zero b low c high mobility situation depending much better rl might comparable even better rr routing messages charged rr figure 7 plots average number messages received per cs execution values req ranging 10 4 mean time units requests mean time units requests 1 left right along x axis plots shown runs 20 87 links 80 348 links connectivity rl rr simulations figure 7b c show rr algorithm sends fewer messages per cs entry rl algorithm simulation trials mobility although load increases message advantage rr decreases markedly situations studied except rl simulation static case high connectivity number messages per cs entry tends decrease load increases reason although overall number messages increases load algorithms due additional token request messages increases less linearly number requests hence less linearly number cs entries extreme high load every time token moves likely cause cs entry static case high connectivity rl algorithm experiences threshold eect around load 01 load less 01 number messages per cs entry roughly constant lower value load 01 number messages per cs entry roughly constant higher value threshold eect becomes less pronounced connectivity decreases conjecture qualitative behavior algorithm 30 node graph changes load increases 001 01 change may attributed observation token movement eectively shortens request path length high connectivity low load low load sucient time requests nodes receive linkinfo messages sent token moves causing nodes send requests direct links token holder rather last link sent token eect amplied high connectivity node likely directly connected token holder rl algorithm sends messages per cs entry rr algorithm mobility causes link changes number messages sent rl algorithm grows large low loads observed figure 7b c links fail form rl algorithm sends many linkinfo messages maintain token oriented dag resulting higher message cs entry ratio low loads degree mobility remains constant however interpreting results important note rl algorithm charged cost routing simulations mobility rr simulation charged routing figure 8 shows results experiments designed understand eect connectivity number messages per cs entry gure average number messages per cs entry plotted network connectivity increasing 10 43 links 100 435 links left right x axis curves plotted low load requests load requests 1 rl rr simulations static case number rl messages per cs entry increases linearly connectivity xed load connectivity increases number neighbors per node increases resulting linkinfo messages sent rr low load rr high load rl low load connectivity connectivity b entry entry entry connectivity c figure 8 connectivity vs messagescs entry zero b low c high mobility token travels however number rr messages per cs entry decreases less linearly connectivity since shortest path lengths neighbors virtual spanning tree decrease fact results rr 100 connectivity virtual spanning tree actual spanning tree high load match performance approximately 4 messages per cs entry cited raymond 25 high load part figure 8 shows static case rl algorithm uses fewer messages per cs entry 25 connectivity high load 60 connectivity low load figure 8b c show dynamic cases number messages per cs entry little aected connectivity xed load rl algorithm two opposing trends increasing connectivity appear cancel higher connectivity means neighbors per node means linkinfo messages sent failure hand neighbors per node means less likely link failure last outgoing link thus linkinfo messages due failure propagate less rr case logarithmic scale axis figure 8c hides slight decrease messages per cs entry making curves appear results simulations section summarized table 2 zero mobility low mobility high mobility connectivity 20 80 20 80 20 80 rr high load 13 6 11 7 rr low load rl low load 13 17 189 180 1900 1825 table 2 summary messages per cs entry 7 conclusion discussion presented distributed mutual exclusion algorithm designed aware adapt node mobility along proof correctness simulation results comparing performance algorithm static token based mutual exclusion algorithm running top ideal ad hoc routing protocol assumed partitions network throughout paper simplicity partitions handled algorithm using method similar used tora ad hoc routing protocol 22 22 additional labels used represent heights nodes allowing nodes detect recognition originator chain height increases series height changes occurred reachable nodes without encountering destination similar partition detection mechanism could encorporated mutual exclusion algorithm expense slightly larger messages algorithm compares favorably layered approach using ad hoc routing protocol providing better average waiting time per cs entry tested scenarios simulation results indicate many situations message complexity per cs entry algorithm would greater message cost incurred static mutual exclusion algorithm running top ad hoc routing algorithm messages mutual exclusion algorithm routing algorithm counted acknowledgements thank savita kini many discussions previous versions algo rithm soma chaudhuri careful reading helpful comments liveness proof debra elkins helpful discussions r slide mechanism applications dynamic networks polynomial end end communication structuring distributed algorithms mobile hosts distance routing e performance comparison multihop wireless ad hoc network routing protocols query localization techniques ondemand routing protocols ad hoc networks fault tolerant algorithm distributed mutual exclusion routing multicast multihop distributed routing algorithm mobile wireless networks token based kresilient mutual exclusion algorithm distributed systems signal stability based adaptive routing ssa adhoc mobile networks scheduling broadcasts multihop radio networks distributed algorithms generating loopfree routes networks frequently changing topology dynamic source routing ad hoc wireless networks clusterbased approach routing dynamic networks reliable broadcast mobile multihop packet networks highly adaptive distributed routing algorithm mobile wireless networks highly dynamic destinationsequenced distancevector routing mobile computers multicast operation adhoc ondemand distance vector routing protocol tr treebased algorithm distributed mutual exclusion slide mechanism applications dynamic networks token based italickitalicresilient mutual exclusion algorithm distributed systems highly dynamic destinationsequenced distancevector routing dsdv mobile computers distributed routing algorithm mobile wireless networks efficient message ordering dynamic networks reliable broadcast mobile multihop packet networks clusterbased approach routing dynamic networks multicluster mobile multimedia radio network locationaided routing lar mobile ad hoc networks distance routing effect algorithm mobility dream performance comparison multihop wireless ad hoc network routing protocols query localization techniques ondemand routing protocols ad hoc networks scenariobased performance analysis routing protocols mobile adhoc networks multicast operation adhoc ondemand distance vector routing protocol adhoc ondemand distance vector routing highly adaptive distributed routing algorithm mobile wireless networks ctr chen jennifer l welch selfstabilizing mutual exclusion using tokens mobile ad hoc networks proceedings 6th international workshop discrete algorithms methods mobile computing communications september 2828 2002 atlanta georgia usa chen jennifer l welch selfstabilizing dynamic mutual exclusion mobile ad hoc networks journal parallel distributed computing v65 n9 p10721089 september 2005 djibo karimou jean frdric myoupo application initialization protocol permutation routing singlehop mobile ad hoc networks journal supercomputing v31 n3 p215226 march 2005 emmanuelle anceaume ajoy k datta maria gradinariu gwendal simon publishsubscribe scheme mobile networks proceedings second acm international workshop principles mobile computing october 3031 2002 toulouse france gruiacatalin roman jamie payton termination detection protocol use mobile ad hoc networks automated software engineering v12 n1 p8199 january 2005 benchaba bouabdallah n badache ahmednacer distributed mutual exclusion algorithms mobile ad hoc networks overview acm sigops operating systems review v38 n1 p7489 january 2004
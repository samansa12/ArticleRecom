development verified erlang program resource locking paper describe tool verify erlang programs show means industrial case study tool used tool includes number components including translation component state space generation component model checking component verify properties code tool first translates erlang code process algebraic specification outcome translation made efficient taking advantage fact software written erlang builds upon software design patterns clientserver behaviours labelled transition system constructed specification use crl toolset resulting labelled transition system model checked set properties formulated calculus using caesaraldbaran toolsetas case study focus simplified resource manager modelled real implementation control software axd 301 atm switch key properties verified program mutual exclusion nonstarvation since toolset supports regular alternationfree calculus ingenuity needed checking liveness property nonstarvation case study refined step step provide functionality step motivated corresponding formal verification using model checking b introduction within ericsson functional programming language erlang 1 used development concurrentdistributed safety critical software faced task creating support development formally veried erlang programs subtask built tool enable use model checking programs tool aimed accessible erlang programmers without forcing learn extra language specic model checking tool used using model checking formal verication software well known eld research basically two branches either one uses spec ication language combination model checker obtain correct spec ication used write implementation programming language one takes program code starting point abstracts model checked model checker either way implementation proved correct approaches error encountered may indicate error implementation use model checking seen accurate debugging method rst approach one successful many examples combination specication language promela model checker spin 14 attractive merit promela language close implementation language c becomes rather easy derive implementation specication direct fault free way case one uses uml specication language java c implementation language one might need eort apart fact model checking uml specications still unsettled topic also respect second approach many examples among pathfinder 13 bandera 6 starting java code exists even earlier attempt use model checking erlang code huch 15 approach could added list probably dierence use knowledge occurring design patterns used erlang code obtain smaller state spaces cf 2 follow similar approach translation java promela checked spin 13 however translate erlang crl 12 model check using csarald ebaran 9 compared huchs approach focus much data part abstract case statements nondeterministic choices really check data involved reason check mutual exclusion absence deadlock small locker program leading example paper one abstracts data program way case statements translated nondeterministic choices mutual exclusion longer guaranteed hence shown one main goals approach able deal erlang code written according design principles advocated within ericsson starting point distributed locker algorithm running ericssons axd 301 atm switch 4 started redesigning locker way formal verication guides development paper illustrate ideas one rst locker prototypes development process section 2 describe locker algorithm consider paper show section 3 locker implemented erlang using generic server supervision tree design principles erlang modules automatically translated crl specication section 4 describe contribution form translation tool verication crl specication classical properties deadlock mutual exclusion starvation described section 5 conclusion section 6 discuss merits shortcomings approach put context respect approaches 2 designing algorithm casestudy hand paper classical locker algorithm several processes want access one resources given nite set locker process playing arbiter responding requests access resources way clients eventually get demanded access two clients get access resource time client sends one message containing resources requested waits access granted accesses resource gives resource free starts asking resources several fault situations easy imagine guide us towards solutions rudimentary problems describe analysis situations prestudy actual implementation however tools discuss later one could nd results experimenting fashion implement idea erlang obtain possible runs program automatically discuss fault situations using special notation scenarios scenario sequence states locker process state locker contains xed set resources every resource three elds name resource client access resource list clients want access resource example notation sketch possible starvation situation two resources b three clients 3 algorithm demanded set resources available certain client client gets access resources client 1 requests resource client 2 requests resource b thereafter client 3 requests resources client 1 releases requests resource client 2 releases requests b continuous operation way causes client 3 waiting ever get access ie client 3 starving access 1 pending access pending access pending 3 3 access 2 pending 3 3 access pending 3 3 access 1 pending 3 3 access pending 3 3 scenario indicates general one pay price optimal resource usage viz possibility starvation clearly one want starvation program one still may accept algorithm one good evidence believe resources accessed frequently situation might unlikely one might choose loose performance client 3 favor better overall performance however assume frequency access resources rather high dierent clients may overlapping demands resources 1 therefore need decide upon solution problem choose use rst come rst serve strategy resource available client client 1 2 3 would ask resources starvation problem would occur waiting ie access eld list pending processes demanded resource empty access pending access pending 1 access pending access 2 pending 3 3 thus solution client could wait resources even demanded resources unused moment optimizations possible example timestamp pending processes give access resource rst pending processes yet waited certain amount time involved consider optimizations version action upon client requesting list resources look whether demanded resources available resource available process accessing processes pending resource demanded resources available client notied given access resources demanded resources unavailable every demanded resource client placed end list pending processes client assumed release previously demanded resources one release message upon release client removed resources calculation performed see whether one clients get access demanded resources similar reasoning cannot give access client demanded resources available even one resource case clear need take rst come rst serve policy thus one resource several clients would give client head pending list access resource however one could wonder happens two resources one clients pending list access pending need algorithm decide whether client 2 3 gets access resource client 1 releases possibilities could think boil construction one list pending processes rst client list demanded resource available gets access resources ie notied removed pending lists put access eld several ways constructing combined list 1 merge list sort client identier means client lowest identier highest priority hence starvation obvious problem example client 2 given access client 1 requests resources time client 2 releases client 1 granted access repeatedly 1 2 requesting access cause 3 starve 2 append lists use small optimization unique append ie appending clients yet present list clearly starvation problem occurs solution 3 construct list contains heads pending lists occur one tails pending list reason work clients always request resources hence clients put pending list sorted manner situation like access pending cannot occur setting since either client 2 follows client 3 pending lists vice versa might clients order cannot reversed 4 add timestamp incoming request save client information timestamp list obtained appending sorting timestamps equivalent approach separately store list requesting clients use order requested priority order giving access experimented version 3 4 present version 3 3 locker implementation erlang ideas sketched previous section implemented erlang clients locker implemented erlang processes communicate message passing locker implemented server following one generic design patterns given erlang distribution 8 generic server design pattern prescribes implementation locker called callback module actual loop saves state server receives messages implemented standard module whenever message arrives appropriate function callback module executed callback functions return new state possible reply message standard module part send caller way generic server principle implements synchronous communication top erlangs asynchronous communication primitives detailed operational semantics refer 2 ow control clients locker follows client requests locker exclusive lock several resources requested resources available locker gives ok client client performed necessary operations resources noties locker release locks locker schedules clients rstcome rstserved basis explained previous section note however scheduling relative resource client requests resource taken may served later client requesting another free resource client programmed simple process using generic server call principle communicate locker gen servercall function hides synchronized communication server second argument function contains message sent server calls handle call function callback module client suspended handle call returns reply value passed server return value gen servercall particular client interested actual returned value use synchronization spawn link function used create new process case running loop function arguments locker resources moduleclient startlockerresources okspawnlinkclientlooplockerresources looplockerresources criticalsection looplockerresources atom critical section two synchronous calls request release implements called critical section real implementation critical code placed critical section abstract implement locks use record following elds resource name resource exclusive client using resource pending list clients want access resource erlang program locker process given generic server callback module accepts messages frequestresourcesg release modulelocker behaviourgenserver initresources end resources init function returns every resource given list resources record type lock rst eld contains name resource two elds instantiated default value empty list case checkavailablesresourceslocks true reply ok end locks false noreply end locks handlecallrelease client locks end locks sendreplynewlocksallpendingsnewlocks reply ok locksupdated generic server automatically supports every message gen servercall process identier sender tag kind time stamp distinguish dierent messages client obtaining request locker stores combination identier tag pair pending list exclusive eld releasing new tag used pair since new message removing pair list done looking process identier note locker cannot remove tag already moment receiving request client since tag necessary reply implemented send reply function checks every pending client whether resources available client notied locks updated case obtainableslockspending true promotependinglockpending end locks false sendreplylockspendings end functions contain side eects viz sending receiving messages functions sideeect free easy implement addition client locker code also implemented called supervision tree commonly used design principle monitor individual processes 8 basically code supervision tree describes process started monitors two processes one locker new supervisor process monitors clients code describes happen one processes crashes instructed restart clients locker processes processes together started one function call viz supervisorstart arguments number clients one wants start list resources one considers 4 crl specication erlang modules described previous section automatically translated one crl specication data directly translated erlang crl without abstraction specication used generate transition system used model checking translation performed two steps first apply sourcetosource transformation level erlang resulting erlang code executable way original optimized verication second translate collection erlang modules one crl specication advantage intermediate erlang format programmers easily understand severe manipulations code therefore better able understand smaller step crl notation moreover intermediate code input verication tools 41 erlang erlang transformation sourcetosource transformation erlang modules contains many steps mention relevant ones skipping trivial steps like removing debug statements code use supervision tree structure obtain nite set initial processes start translator arguments would need build start supervision tree allows us bind number clients resources certain value every dierent number need run dierent transformation supervisor processes taken away new initialization function creates processes locker clients handling process crashes left detected transition system replace predened set higher order functions like map rstorder alternative since target specication language support higher order functions thus call mapfunx fxy1yn end xs replaced call new function map fxsy1yn dened added code fxy1yn mapfxsy1yn next phase determine functions sideeects ie functions send receive message call function callgraph problem keep list sideeect free functions library modules gen servercall function handle call function typically added functions contain sideeects involved operation get rid use return values functions sideeects crl process may sideeects return value hand function crl return value may contain sideeect case erlang function indirectly causes sideeect computation part sideeect part split sourcetosource transformation suces make sure return values matched variable provide decomposition data structure return value means sideeect free functions currently deal basic data types compound data types lists tuples records mixtures 42 erlang crl transformation given erlang modules transformed described generate one crl specication modules erlang dynamically typed whereas crl strongly typed therefore construct crl data type erlangterm erlang data types embedded sideeect free functions added term rewriting system erlangterm data type standard transformation used translate erlang statements term rewriting formalism addition dene equivalence relation data types rather involved particular case 14 dierent atoms 7 data constructors 440 equations reserved comparing data types roughly two third whole specication respect part sideeects benet fact erlang erlang transformation generated specic conguration contains information processes started allows us dene initial conguration crl specication erlang processes coincide crl processes nonterminating erlang function describes main loop process erlang case however translating loop cannot translate recursive calls erlang functions sideeects direct way crl crl computation sideeects cannot intermingled solution found denition separate crl process implementing call stack communication call stack used return values computation certain restrictions respect crl functions taken account one function clause possible sequential com position nondeterministic choice ifthenelse statement control translate case statements pattern matching using ifthenelse construct calls newly introduced process functions handle call gen servercall translated communicating actions crl different clauses handle call function combined one crl loop using state mentioned arguments handle call state loop unique process identiers used erlang integrated argument self process calls instantiated rst call initial part comm genservercall genserverreply returned return proc lockerself termlocks sumresources term handlecallselftuplerequestresourcesclient genserverreplyclientokself lockerself eqcheckavailablesresourceslockstrue lockerself handlecallselfreleaseclient allpendingsmapreleaselocklocksclient rcallresultselflocks2 genserverreplyclientokself lockerselflocks2 wcallresultselflocks eqequalmcrlarg1niltrue genserverreplyhdmcrlarg1okself sendreplyself eqobtainableslockshdmcrlarg1true automatic transformation verify specic conguration clients repeatedly request available resources order perform several verications particular verify situations clients repeatedly request arbitrary varying subset resources modied crl specication hand used crls possibility express nondeterminism crl specication used generate transition system number states generated systems depends congu ration tried several congurations three clients four resources largest resulting million states creating large state spaces takes hours single processor workstation even though time consuming improving highest priority plan focus small examples development phase software larger examples take time testing development onthe model checking parallelization model checker might increase performance dramatically later stage 5 verifying model three properties want verify locker absence deadlock mutual exclusion starvation classical properties well studied literature rst trivially shown second third need right formulation support model checker mutual exclusion safety property whereas starvation liveness property safety properties easier check liveness properties explained later depends fact innite traces specication excluded real erlang execution underlying erlang scheduler 51 mutual exclusion property mutual exclusion express resource accessed one client time order show added two actions crl specication use free resource argument soon enter critical section use action applied resources client requested leaving critical section resources use macro stating possible paths 1 action 1 action must preceded 2 action mutual exclusion property depends number resources fact need dierent formula number resources system two resources r 1 r 2 mutual exclusion property formalized new version model checking tool within csarald ebaran toolset 9 construction new release able formulate one property arbitrary number resources mutual exclusion property shown congurations 2 resources 2 3 clients clients repeatedly request arbitrary none empty subset resources well situation 4 resources 3 clients latter consisted model million states took hours verify mutual exclusion property recently developed parallel model checker used check largest transition system hours reduced nine minutes fty processors 5 promissing development scaling approach 52 starvation proving starvation processes turned problem caused fact traces transition system correspond fair run erlang program erlang processes scheduled use certain scheduler model purpose abstracted scheduling consider possible sequences actions even one single processes gets execution time want base starvation property notion action eventually followed another action particular request resource eventually followed using resource one way formulating property used context instantiated actions 1 2 request resource entering critical section respectively latter use conrmation locker ie returned ok message actual property like mutual exclusion case depends number clients resources three clients two resources unfortunately property hold even simple scenarios denitely starvation occurs example consider following simple scenario three clients two resources clients repeatedly request one resource client 1 2 request client 3 requests b scenario starvation since clients may access resource release request crl specication possibility loop client 3 continuously requests releases resource b clients requesting resource simply get scheduling time sequence however erlang program loop present scheduler thus problem disregard unrealistic loops transition system removing loops transition system could nd way incorrect realistic setting loop could executed times scheduler enables processes realistic setting excluded innite traversal loop would like weaken evtfollow property nonfair paths exist model implementation due scheduling erlang runtime system ignored limitations model checking tool evaluator 30 need express property alternation free calculus external advice required come following reformulation evtfollow describing even loop exists reaching 2 still possible every state loop reach 2 nite number steps modality h 2 itrue property weaker combination property 1 holds mentioned scenarios unfortunately weak ie ignores loops considered property 1 weaker evtfollow holds rst scenario mentioned section 2 starvation erlang context recall scenario client 1 2 turn take priority client 3 thus ignored loop actions client 1 2 although causes client 3 starve need precise kind actions ignore loop thinking little longer turns actions may appear loop neither request release client ignored matter action one would like ignore always plausible scenario possible clear one cannot ignore action even whole loop principle allowed long occur innitely often actions along path also enabled opinion goes beyond expressiveness logic use currently investigate several possibilities work around problem viz adding explicit scheduling crl specication model checker changed using dierent logic model checker enables reasoning fairness one might wonder whether starvation important property since even theoretical starvation problem occurs might happen reality process always gets served regular implementations timer set sending message starvation shows time client site time normally followed retry process might get served attempts experimented adding time outs removing check pending list function check available leads starvation scenario discussed section 2 running program show starvation rst sight client get access resource occasionally implement clients access time say 500 ms critical section starvation show form time clients total number served requests gets lower particular clients know theoretically starve interesting context detected performance problem suciently increasing time spent critical section one argue testing would sucient error could show unexpectedly software use long time hence nd starvation important property verify 6 conclusions main contribution work lays development automatic translation class erlang programs crl enables development erlang programs goes hand hand formal verication leading formally veried programs expect smart abstractions clever tricks performed users tool assuming limited knowledge verication issues provide pushbutton verication ts existing development cycle leading example developing tool used implementation locker algorithm verication locker algorithm partly successful absence deadlock mutual exclusion could proved could shown eectively algorithm starvation free subject research nd way around problem number states models much million real performance problems encountered takes complete verication hours still considered acceptable stage majority work put getting specication right formulating right properties case particular starvation spent much time formulation still satisfactory property use approach similar pathfinder bandera project 13 6 would interesting see java version case study could easily handled using tools found opportunity running model checking approach huch 15 directly example impossible since version support generic server design principle could change program removing generic server implementation use direct implementation erlang instead however approach huch would translate choice whether return ok message client store client pending list nondeterministic choice abstracting away data way mutual exclusion hold obtained transition system another approach verication erlang programs diers model checking use theorem prover checking properties swedish institute computer science cooperation ericsson developed kind theorem prover specially focussed erlang programs 3 advantage using tool compared model checking approach possibility using full calculus instead alternation free possibility reason unbounded number clients resources completeness approach ie proof given holds program specication since model checking allows easier automation aim using technique prototyping use theorem prover approach version satised verication locker casestudy posted several questions research solved several practical issues way continue adding features locker shared locks faulttolerance therewith increasing need even better translation tools acknowledgements would like thank radu mateescu hubert garavel inria rhone alpes izak van langevelde jaco van de pol wan fokkink cwi lars ake fredlund dilian gurov sics taking part discussions case study supporting us advises r verifying generic erlang clientserver implementations new generation atm switching system local parallel model checking alternation free introduction process algebra modelling concurrent systems protocol veri syntax semantics timed model checking java programs using java pathfinder design validation computer protocols tr ctr thomas noll chanchal kumar roy modeling erlang picalculus proceedings 2005 acm sigplan workshop erlang september 2628 2005 tallinn estonia chanchal kumar roy thomas noll banani roy james r cordy towards automatic verification erlang programs calculus translation proceedings 2006 acm sigplan workshop erlang september 1616 2006 portland oregon usa larske fredlund clara benac earle model checking erlang programs functional approach proceedings 2006 acm sigplan workshop erlang september 1616 2006 portland oregon usa koen claessen hans svensson semantics distributed erlang proceedings 2005 acm sigplan workshop erlang september 2628 2005 tallinn estonia
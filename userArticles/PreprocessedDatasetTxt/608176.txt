compared study two correctness proofs standardized algorithm abr conformance abr conformance protocol realtime program controls dataflow rates atm networks crucial part protocol dynamical computation expected rate data cells present modelling corresponding program environment using notion parametric timed automata fundamental property service provided protocol user expressed framework proved two different methods first proof relies inductive invariants originally verified using theoremproving assistant coq second proof based reachability analysis obtained using modelchecker hytech explain compare two proofs unified framework timed automata b introduction last years extensive amount research devoted formal verification realtime concurrent systems basically formal proof methods belong two different fields theorem proving modelchecking methods first crucial phase build formal description system study theorem proving description consists set formulas verification done using logical inference rules modelchecking description graph verification performed using systematic search graph theoremproving methods apply general prob lems often need human interaction modelchecking methods mechanical apply restricted class systems methods thus appear complementary ones several authors advocated need combine together 17 21 24 exciting ambitious trend research still challenging issue believe preliminary useful step towards objective evaluate comparatively respective merits partially supported action forma french programme dsp sttccnrsmenrt rnrt project calife shortcomings methods general abstract level difficult practical examples comparison one may hopefully draw general lessons combining methods appropriate way besides comparison may interesting per se may contribute better understanding specific treated problem illustrate latter point performing compared analysis two correctness proofs obtained separately sophisticated reallife protocol precisely propose comparison two proofs available bit rate abr conformance algorithm protocol designed france telecom 15 context network communications asynchronous transfer mode atm first proof 19 18 obtained theorem proving framework using floydhoare method inductive invariants proof assistant coq 7 second proof 8 based method reachability analysis used modelchecking tool hytech 14 order compare methods easily formulate unified framework pautomata 8 variant parametric timed automata 5 choice framework motivation differences models specific problems discussed end paper section 7 context motivation case study atm flexible packetswitching network architecture several communications multiplexed physical link thus providing better performances traditional circuitswitching networks several types atm connexions called atm transfer capabilities atc possible time according dataflow rate asked paid service user mode may seen generic contract user network one side network must guarantee negociated quality service qos defined number characteristics like maximum cell loss transfer delay side data packets cells sent user must conform negociated traffic parameters among atcs deterministic bit rate connexions operate constant rate statistical bit rate connexions may use high rate recently defined atcs like available bit rate abr allowed cell rate acr may vary session depending current congestion state network atcs designed irregular sources need high cell rates time time may reduce cell rate network busy servomechanism proposed order let user know whether send data mechanism well defined order clear traffic contract user network conformance cells sent user checked using algorithm called gcra generic control cell rate algorithm way network protected user misbehaviors keeps enough resources delivering required qos well behaved users fact new atc cannot accepted international standard without efficient conformance control algorithm evidence algorithm intended behavior paper study particular case abr simple ideal algorithm conformance control given algorithm inefficient terms memory space approximation algorithms implemented practice correctness proof approximation algorithms consists showing outputs never smaller outputs computed ideal algorithm precisely focus algorithm called due christophe rabadan francetelecom part i3711 standard 15 describe algorithm prove correctness respect ideal algorithm using two methods mentioned plan paper follows section 2 gives informal description problem abr conformance control section 3 presents incremental algorithm used henceforth specification section 4 describes general modelling framework called pautomata expresses two different proof methods context description abr algorithms pautomata given section 5 verification two proof methods done section 6 discussion constraints linked modelling pautomata follows section 7 comparison two methods given section 8 conclude section 9 overview abr update dgcra resource management cell user network acr data cell fig 1 conformance control abstract view abr protocol given figure 1 conformance control algorithm abr two parts first one quite simple addressed consists algorithm called dgcra dynamic gcra adaptation public algorithm checking conformance cells checks rate data cells emitted user higher value approximately acr allowed cell rate excess cells may discarded dgcra case abr rate acr depends time current value known time new data cell comes user thus complexity lies second part computation acrt update figure 1 represents arbitrary time future data cell may arrive value acrt depends successive values carried resource management rm cells transmitted network user 1 value corresponds rate acr reached soon possible 21 definition ideal rate acrt consider sequence values r carried rm cells ordered arrival time r slight abuse notation cell carrying r called value acrt depends cells r whose arrival time r occur intuitively acrt last value r received time ie rn ug unfortunately electric propagation time various transmission mechanisms user aware expected value delay taking users reaction time observed control device consideration overall round trip time control device user acrt rn may vary turn itut considers lower bound 3 upper bound 2 established negociation phase abr connection hence cell arriving user time dgcra may legitimately emitted using rate r lastt rate less equal values equivalently less equal maximum allowed therefore acrt taken maximum r successive arrival times rm cells words depend rm corresponding rate values expected rate case obtained new rm cell arrived program conformance control based specification would need compute instant maximum rate values rm actually rm cells sent user transmission network user relevant details available 22 cells received interval may several hundreds atm network large bandwidth itut committee considered exact computation acrt along lines feasible reasonable cost current technologies 22 algorithm efficient computation approximation realistic algorithm called due c rabadan proposed francetelecom adopted i3711 requires storage two rm cell rates time dynamically computes approximation value acrt two auxiliary variables efi ela used program storing two rm cell rates two dates tfi tla associated efi ela respectively current time reaches tfi updated value efi one rm cell rate kept memory efiela tfitla new rm cell arrives auxiliary variables efi ela tfi tla updated according several cases depending position r k wrt tfi tla r k wrt efi ela full description b 0 given section 53 cf pseudocode appendix correctness b 0 accepted international standard norm itu i3711 algorithm b 0 proved correct respect acrt necessary ensure flow control data cells comparison rather acrt never disadvantageous user means data cell arrives time upper approximation acrt 3 incremental computation rate acrt explained correctness algorithm b 0 mainly relies comparison output value b 0 ideal rate acrt initial specification acrt given section 21 turns inadequate automated even manual manipulation therefore convenient express computation acrt algorithmic form close possible b 0 particular updates performed upon reception rm cells monin klay first formulate incremental computation using higherorder functional point view 19 recall algorithm adopt slightly different view suited modelling framework described subsequently 31 higherorder functional view algorithm f consider algorithm called f stores current time estimation e acr updates arrival rm cell precisely receiving new cell r k time r k algorithm f computes new function 0 former function e depending situation r k respect argument e shown value et current time equal ideal rate acrt defined section 21 proof statement found 19 although much shorter one deduced justification section 32 algorithm f thus seen higher order functional program computes firstorder functions e might implemented using general notion closures however functions e constant time intervals b b form r value form b hence encoded using well chosen finite lists pairs e time e rate et lists seen schedulers expected rate current time becomes equal expected rate becomes e length schedulers may several hundreds networks large bandwidth entailing high frequency events r k even relevant pairs e kept contrast algorithm considered using scheduler length two containing pairs tfiefi tlaela 32 parametric view algorithm another way looking f consider parameter written whose value fixed unknown represents target observation time function f becomes ideal algorithm updates value et henceforth written upon reception rm cells follows almost immediate value e computed equal ideal rate acrt defined section 21 indeed increases k takes values takes accordingly values particular e correctness property b 0 respect acrt reformulated follows output value b 0 e value computed algorithm property referred u proved values parameter henceforth parameter left implicit simply write u instead u accordingly write e instead e instead point algorithm plays role specification modelling framework proof methods clear informal definition control conformance algorithm ability reason real time essential expressions e involved property u denote quantities evolve time goes considered functions current time order express prove property u need formal framework model pautomata chosen paper turns sufficient purposes formal description verification considered system describe model hereafter well two proof methods verifying properties context 41 pautomata model parametric timed automata called pautomata short extension timed automata 4 parameters minor difference classical parametric model alurhenzingervardi 5 one clock variable several discrete variables w 1 wn 5 several clocks discrete variable one retrieve close variant alur henzingervardi parametric timed automata changing discrete variable w sgammaw see 12 alternatively pautomata viewed particular cases linear hybrid automata 2 3 20 presentation inspired 14 main elements pautomaton finite set l locations transitions locations family realvalued variables figures usual locations represented circles transitions labeled arrows variables constraints variables pautomaton tuple p parameters tuple w discrete variables universal clock realvalued variables differ way evolve time increases parameter values fixed initial constraint never evolve later discrete variable values evolve either may changed instantaneous updates universal clock variable whose value increases uniformly time parametric term expression form w sigma ff sigma ff constants z usual convention empty set indices corresponds term without parameter convex constraint conjunction strict large inequalities terms pconstraint disjunction convex constraints update relation conjunction inequalities variable term written w 0 fi term w 0 primed copy discrete variable term parametric term usual x implicit x 0 appear update relation locations transitions location 2 l associated convex constraint called location invariant intuitively automaton control may reside location invariant value true invariants used enforce progress executions omitted default invariant location constant true transition pautomaton form h 0 label transition origin location 0 target location guard update relation guard convex constraint guards may additionnaly contain special expression asap model location called urgent transitions origin contain asap guard time allowed pass location otherwise called stable sequence transitions called complete form h stable locations intermediate locations urgent locations usual convention case corresponds single transition stable locations executions executions pautomaton described terms transition system symbolic state q defined formula p w variable ranging set locations pconstraint primarily interested states implies location invariant states called admissible states pzone represented formula pi p w finite disjunction states alternatively regarded finite set states initial state q init pconstraint init initial location init initial location assumed stable since parameter values fixed initial state often omit tuple p parameters formulas pautomaton two kinds moves called action moves delay moves possible admissible state action move uses transition form h 0 reaching admissible state equivalent 9w w w w 0 informally discrete variables modified according update relation automaton switches target location 0 notion action move generalizes natural way notion action move complete sequence transitions note action moves instantaneous value clock evolve delay move corresponds spending time location possible stable invariant remains true resulting admissible state q nothing else changed time successor state q state obtained either delay action move subset q states p ost q set iterated successors states q easily proved class pzones closed p ost operation consequence p ost q pzone q pzone computation p ost terminates notion predecessor defined similar way using operator p synchronization two pautomata representing components system possible build new pautomaton synchronized product let 1 2 two pautomata common universal clock synchronized product parallel composition see eg 14 1 theta 2 pautomaton universal clock union sets parameters resp discrete variables 1 2 set parameters resp discrete variables locations product pairs locations 1 2 respectively stable pconstraints associated locations invariants initial pconstraint obtained conjunction components pconstraints automata move independently except transitions 1 2 common synchronization label case automata perform synchronous action move associated guard resp update relation conjunction guards resp update relations 42 proof methods present two proof methods proving property pi w framework pautomata property assumed involve stable loca tions hold parameter valuations satisfying initial pconstraint modeled system first method based floydhoare method sertions consists proving pi inductive invariant model see eg 27 second one based modelchecking techniques consists characterizing set reachable states system checking element violates pi inductive invariants prove pi inductive invariance one prove pi holds initially preserved move system either action delay move formally prove transition h 0 two stable locations similar formula must also proved complete sequences transitions stable location w reachability analysis since p ost q init represents set reachable states pautomaton property pi holds system p ost q init contained set q pi states satisfying pi equivalently one prove emptiness zone p ost q init set states violating pi also note property expressed using p qpi 5 description system algorithms b 0 naturally represented pautomata however reactive programs react external events occur viz upon reception rm cell current time reaches value eg tfi thus order formally prove correctness property u need model third pautomaton appropriate environment viewed event generator finally full system obtained synchronized product three au tomata explain check correctness property pautomata share universal clock value current time without loss understanding context make clear often use instead 51 model environment observation mentioned pautomaton env modeling environment see figure 2 generates external events receptions rm cells also generates snapshot action taking place time note purpose verification u enough consider snapshot final action system variables involved parameter snapshot time discrete variable r representing rate value carried last received rm cell initial location w ait loop label newrm simulates reception new rm cell rate r updated non deterministic positive value written r 0 hytech 14 snapshot action st guard location w ait assigned invariant order force switch location ende wait newrm r snapshot fig 2 automaton aenv modeling arrivals rm cells snapshot 52 algorithm algorithm computes e incremental way shown table section 32 variable e updated reception rm cell current time becomes equal precisely algorithm involves variable r parameter common env addition two parameters 3 2 representing lower upper bounds transit time interface user back output variable e equates ideal rate acrt initially e r equal algorithm reacts arrival new rm cell rate value r updating e three cases according position arrival time respect 2 3 see section 32 1 2 e updated new value r 2 new rate becomes emaxer avoid using function max computation split two subcases 3 3 rate e left unchanged algorithm terminates snapshot takes place st following sometimes write updated output value e functional form r e automaton ai algorithm naturally modeled pautomaton see figure 3 initial location idle initial pconstraint r reception rm cell modeled transition newrm location idle location upde transition followed urgent asap transition upde back idle updates e depending position wrt 2 3 explained without loss understanding transitions upde idle labeled i1 i2a i2b i3 corresponding operations observation value e corresponds transition snapshot idle final location endi 53 algorithm computation approximation give full description algorithm b 0 cf pseudocode appendix like algorithm b 0 involves parameters 3 2 variable r however note parameter b 0 computes intended approximation e using five specific auxiliary variables tfi tla play role first last deadline respectively efi value taken current time reaches tfi ela stores rate value r carried last received rm cell emx convenient additional variable representing maximum efi ela initially stfitla variables equal algorithm b 0 reacts two types events receiving rm cell event common reaching tfi event specific b 0 idle snapshot newrm i3 fig 3 automaton ai receiving rm cell current time new rm cell value r arrives variables updated according relative positions 3 2 respect tfi tla r respect emx eight cases 1 8 two subcases 1 3 tfi emx r tfi 3 r 6 tfi emx r r ela 8 tfi r reaching tfi current time becomes equal tfi approximate current rate updated efi efi updated ela tfi updated tla operation 9 events reaching tfi stfi receiving rm cell simultaneously occur operation 9 must performed operation 1 8 accounting rm cell reception like algorithm b 0 terminates snapshot time st snapshot occurs simultaneously reaching tfi operation 9 must performed termination b 0 note ordering tfi tla operation 9 depends respective positions tfi tla moment performing 9 case stfitla one still stfitla performing 9 becomes greater tfitla time increases rm cell occurs st case stfitla performing 9 one stfitla immediately automaton ab 0 order implement higher priority operation 9 operations case simultaneous events convenient distinguish case greater tfi case stfi goal introduce two locations greater less operation 9 always occurs location less target location depends whether tfitla subcase 9a tfitla subcase 9b pautomaton ab 0 represented figure 4 significant guards update information like labels used automaton transitions corresponding program operations less greater updal updag stfitla snapshot snapshot stfitla newrm asap 8 newrm asap 1 2 6 fig 4 approximation automaton ab 0 initially ab 0 greater pconstraint stfitla aefielaemxr location less stfi invariant order force execution transition tfitla 9a tfitla reaches tfi less transition goes back less since update stfitla transition 9a switches greater since stfitla time increases reception rm cell corresponds transition newrm two cases depending whether source location less greater less resp greater transition newrm goes location updal resp updag transition followed urgent transition updal resp updag back less updates discrete variables according operations 16 resp 78 explained note transition newrm less updal additional guard stfi order prevent execution newrm 9a 9b stfi forbidden reaching tfi newrm occur simultaneously like observation modeled transition snapshot location less greater endb also note transition snapshot less endb guard stfi order prevent execution 9a 9b stfi forbidden reaching tfi snapshot occur simultaneously 54 synchronized product property u full system obtained product automaton theta ab 0 three pautomata synchronized labels newrm snapshot action moves occur current time reaches tfi upon reception rm cell newrm last case return stable location obtained complete sequence transitions newrm followed transitions i1i2ai2bi3 16 78 ab 0 recall property u expresses terms ideal rate e computed approximate value computed b 0 model snapshot action occurs soon st makes automaton switch final location henceforth respectively locations w ait idle greater w ait idle less actually property e hold locations st due necessary completion actions case simultaneous events thus location gamma sttfi one may e treatment 9 however location appropriate actions completed property u states therefore follows since location 1 reached st action occurs equivalent statement u 6 verification correctness 61 verification inductive invariants order prove u e going prove inv j u inductive invariant system aux auxiliary properties system auxiliary properties viz aux 3 involve additional variable r represents reception date last rm cell variables record history system execution without affecting called history variables 1 27 model easily implemented introducing discrete variable r environment automa ton updating current time value whenever event newrm occurs enriched automaton env represented figure 5 wait newrm r snapshot fig 5 enriched automaton aenv modeling arrivals rm cells snapshot precisely let aux proved inductive invariance ie showing holds initially preserved transition corresponding either complete action move delay move stable locations action moves starting leading one locations associated reception rm cell reaching tfi snapshot case rm cell reception several subcases depending complete sequence actions ab 0 newrm followed 1a 1b subsidiarily sequences newrm followed i3g give details statements involved proof variables inv explicitly mentionned writing inv w vector e efi ela emx r tfi tla note provided encoding locations given integers eg 0 1 2 statements linear arithmetic formula reals involving variables proved arithmetic reasoning done automatically arithmetic theorem prover proof actually done using coq 18 reformulated present context encoding pautomata coq let us recall coq user states definitions theorems proves latters means scripts made tactics scripts proofs produce proofs data terms checked kernel proof assistant tactics used abr described 18 script written abr 3500 lines long required 4 manmonths work crucial part human work consisted identifying relevant invariants around two hundred subproofs automatically produced checked whole proof check takes 5 minutes pc 486 33 mhz linux order give flavour proof structure give typical statements proved case action delay moves action moves example consider reception rm cell subsequent action ab 0 1b corresponds complete sequence transitions location gamma prove e conclusion conjunction 9 tla example let us show prove aux 0 9 ie e assuming tfi aux 10 e ela since tla aux 8 ela efi since tfitla hence transitivity e efi hand ee i3 since tla cases proved similarly one case analysis use transitivity regularity relations delay moves take place stable locations corresponding properties proved respectively formula easily reduce first resp second third implication true conclusion e follows hypothesis using aux 1 conjunct resp aux 2 conjunct u conjunct inv 62 verification reachability analysis order mechanically prove property u compute p ost product automaton starting initial state init pconstraint stfitla reaefielaemx 0 3 2 check p ost q init contain state property u violated recall property u stated state u hold automata env ab 0 directly implemented hytech 14 automatically computes synchronized product modelling protocol property pautomata encoding hytech required 3 manmonths work forward computation p ost q init requires iteration steps intersection q u checked empty takes 8 minutes sun station ultra1 64 megabytes ram memory appendix b display generated pzone 1 achieves automated proof correctness b 0 proof first appears along lines 8 note hytech provide well proof backward reasoning using p instead p ost 7 discussion pautomata tools based timed automata successfully used recent past verifying correcting reallife protocols eg philips audio control protocol 16 bang olufsen audiovideo protocol 13 experiences tools promising observation led us use pautomata close variant timed automata differences pautomata classical timed automata twofold first minor difference pautomata use form updatable time variables instead traditional clocks see 9 proof equivalence two classes second pautomata incorporate parameters essential case study choice hytech associated tool natural context explain new features appear proof protocol using pautomata difficulties encountered process building specification 71 towards pautomata first point significant differences proof invariants stated monin klay 19 18 corresponding proof presented see section 61 representation time work reported 19 18 formalization time aspects though influenced timed automata performed using ad hoc devices appealing readers natural understanding problem settled thanks pautomata include builtin notion clock rely wellunderstood widely accepted notion time use pautomata although introduces additional level encoding thus makes effort specification easier respect note however encoding p automata coq specify priori granularity time evolution allows either continuous discrete underlying model time based minimal underlying theory arithmetic mainly transitivity relations regularity case theory timed automata associated tools like hytech others 6 11 time domain assumed continuous q r sophisticated package manipulating linear constraints real arithmetic used come back difference see section 82 higherorder vs firstorder specifications recalled section 3 monin klay 19 introduced incremental way computing ideal rate acrt higherorder algorithm f recast algorithm f parametric form latter view probably less natural fits better first order framework pautomata reformulating proof invariance also rewrote proof invariance 19 context pautomata order assess proofs uniform framework expressing auxiliary properties needed proof required reintroduce history variable r accounting reception time last rm cell moreover properties concerned stable locations system expressions form included complete sequences actions considered note auxiliary property different counterpart aux 0 found 19 actually aux 0 8 false model subsequently explain discrepancy see section 82 72 specific modelling problems pautomata process constructing pautomata keeping specification face problems listed modelling environment pautomaton addition automata corresponding naturally b 0 third automaton introduced model environment thus providing clear separation external internal events introducing urgent locations class update relations pautomata derived hytech allow simultaneous updates instance choosing random new identical value r e instruction like er0 forbidden order implement update relation urgent intermediate location upde depicted figure 6 introduced idle asap update r newrm instead idle newrm fig 6 reception update two locations instead one introducing two stable locations order implement higher priority operation reaching tfi occuring simultaneously actions system led create two stable locations greater less pautomaton representing algorithm b 0 note overlooked priority requirement preliminary implementation embedding one stable loca tion entailed violation property u detected subsequently running hytech 8 proof comparison assess respective merits shortcomings proof methods invariance reachability analysis within unified framework pautomata regarding abr conformance problem also explain crossfertilize results two methods 81 automated proof vs readable proof wellknown proof modelchecker automatic insight algorithm gained proof theoremprover let us confirm general opinion particular case study already noticed reachability proof done fully automatic manner via hytech outstanding advantage proof inductive invariance required human discovery several nontrivial auxiliary properties justifies posteriori effort translating problem formalism pautomata particular becomes easier validate abr conformance protocols soon formalized terms pautomata actually done recently framework rnrt project calife different variants b 0 easily checked invalidated hytech reachability analysis along lines described possible inductive invariance approach several original auxiliary properties became false others discovered nevertheless several qualifications must done positive side modelchecking let us first stress proof obtained reachability analy sis merely consists long list constraints see appendix b represents whole set reachable symbolic states information hardly exploitable human particular essential fact list complete ie cov ers reachable states impossible grasp hand contrast invariance proofs checked theorem prover humanoriented instructive inspect case analysis automatically performed allows reader convinced property accurateness contrario flaws besides auxiliary properties important per se bring important information algorithm b 0 properties indeed part norm itu i3711 must henceforth fulfilled new abr algorithm candidate normalization explain one go beyond limitations method using fruitful crossfertilizing way 82 crossfertilizing proofs checking output produced hytech proof produced hytech ie finite list p ost symbolic states reached initial one seen fixedpoint associated set transitions product automaton therefore one verify list complete covers reachable states checking invariant action delay moves done using coq system exactly explained section 61 gives course increased confidence modelchecking proof addition may give new insight conditions environment assumed perform proof noticed section 71 coq use flexible model time assuming time increases nothing continuity fact correctness algorithm b 0 holds even discrete time modelling feature cannot derived proof hytech since uses priori assumption continuous time evolution checking invariants used coq way around one check correctness auxiliary properties simply asking hytech reachable states satisfy ie p ost 10 answer always yes gives us another proof aux recall however aux 8 differs counterpart aux 0in 19 8 false pautomata model true original model moninklay see section 71 discrepancy originates different ways two consecutive rm cells follow two models pautomata model two consecutive rm cells may arrive simultaneously precluded model moninklay reception times rm cells must form strictly increasing sequence model presented general original model moninklay relaxes assumption concerning sequence rm cells byproduct provides us better understanding conditions b 0 behaves correctly finally note model pautomata flexible enough incorporate assumption strictly increasing sequences rm cells used 19 suffices use explicitly additional variable r mentioned section 71 date last rm cell reception add guard r newrm transition environment automaton figure 5 modification property aux 0also becomes true model pautomata 83 experiments foreseen limits thus claim checking properties proved one tool using one fruitful examplified may reveal possible discrepancies lead turn discover implicit modelling assumptions may also course detect real flaws originate protocol modelling although case case proof confrontation helps verification work increases confidence human mechanical proofs one wonder general remarks made case study given fact focused one problem correctness algorithm used two specific tools theoremprover coq modelchecker hytech regarding tools believe experience coq hytech specific reproduced equivalent tools well concrete indications sense actually framework project calife pierre casteran davy rouillard university bordeaux performed proof similar proof coq using model pautomata theorem prover isabelle 10 25 concerning hytech know modelchecking tool allowing parameters mentioned appendix c successful experiments gap 12 tool based constraint logic programming works fixedpoint engine much hytech generates p ost concerning studied problem success proof modelchecking comes fact computation p ost computation hytech terminated considered lucky event since analysis parametric algorithm known undecidable 5 means computation p ost always terminate pautomata observation leads us propose appendix c approximate version b 0 belonging subclass p ost guaranteed terminate termination property preserved considering abr conformance algorithms answer ambivalent one hand already mentioned modelchecking experience b 0 successfully reused relatively close algorithms abr conformance framework project calife hand failed mechanically check algorithm abr conformance different kind generic algorithm rabadanklay see eg 26 algorithm involves unbounded list n scheduled dates instead 2 b 0 cannot modeled pautomata due use list data type even restricted version n bound small value eg 3 case get natural model pautomata hytech runs memory fails generate p ost latter experiment recalls us inherent limits modelchecking algorithm uses finite set numeric variables also unbounded data structures lists verification process rely essentially classical methods theoremproving also true program modeled pautomaton space reachable symbolic states big computed existing modelcheckers 9 conclusion recapitulation believe many useful informations realtime programs obtained without resorting new integrated tools possible make joint use wellestablished theorem prover model checker case gained much insight algorithm b 0 important confidence proofs correctness produced coq hytech basically using unified framework pautomata crossfertilizing two proofs particular saw algorithm b 0 robust sense several underlying assumptions relaxed nature time discrete instead continuous measured time interval two received rm cells null moreover basic pautomata model underlying b 0 successfully reused proving correctness variants knowledge first time compared study theorem proving model checking performed industrial problem hope work paves way experiences reallife examples framework project calife currently developing twostep methodology verifying quality new services provided telecommunication networks exploits synergy two proof methods first step based modelchecking yields pautomaton model endowed collection invariants satisfies second step pautomaton recasted algorithmic form better suited enduser verification done via generic proof assistant help invariants r existence refinement mappings algorithmic analysis hybrid systems hybrid automata algorithmic approach specification verification hybrid systems automata modeling realtime systems parametric realtime reasoning uppaal tool suite automatic verification realtime systems timed automata updat able tool kronos closedform evaluation extended timed automata user guide hytech traffic control congestion control b isdn modelchecking realtime systems beyond model checking proving real time algorithm atm coq correctness proof standardized algorithm abr conformance approach description analysis hybrid systems platform combining deductive algorithmic verification labr et sa conformite closedform evaluation datalog queries integer gap order constraints integration model checking automated proof checking mechanical verification generic incremental abr conformance algorithm introduction assertional reasoning concurrent sys tems tr existence refinement mappings introduction assertional reasoning concurrent systems closedform evaluation datalog queries integer gaporder constraints parametric realtime reasoning algorithmic analysis hybrid systems tool kronos uppaalmyampersandmdasha tool suite automatic verification realtime systems automata modeling realtime systems user guide hytech proving real time algorithm atm coq hybrid automata correctness proof standardized algorithm abr conformance automated verification parametric realtime program mechanical verification ideal incremental abr conformance timed automata updatable beyond model checking integration model checking automated proof checking platform combining deductive algorithmic verification modelchecking realtime systems approach description analysis hybrid systems formal modeling analysis audiovideo protocol ctr patricia bouyer catherine dufourd emmanuel fleury antoine petit updatable timed automata theoretical computer science v321 n23 p291345 august 2004
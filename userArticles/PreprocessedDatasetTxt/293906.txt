discrete lotsizing scheduling batch sequencing discrete lotsizing scheduling problem one machine sequencedependent setup times setup costs solved single machine scheduling problem term batch sequencing problem relationship lotsizing problem batch sequencing problem analyzed batch sequencing problem solved branch bound algorithm accelerated bounding dominance rules algorithm compared recently published procedures solving variants dlsp found efficient number items large b introduction certain manufacturing systems significant amount setup required change production one type products another scheduling production lines chemical engineering productivity increased batching order avoid setups however demand different products arises different points time within planning horizon satisfy dynamic demand either large inventories must kept production run large batches frequent setups required inventory levels kept low significant setup times consume scarce production capacity tend complicate scheduling problem discrete lotsizing scheduling problem dlsp wellknown model situation dlsp demand item dynamic backlogging allowed prior production run setup required setup costs setup times depend either next item sequence independent sequence items sequence dependent production meet present future demand latter case also incurs holding costs planning horizon divided finite number short periods period one item produced setup made nothing production optimal production schedule dlsp minimizes sum setup holding costs relationship dlsp scheduling models general motivated us solve dlsp batch sequencing problem bsp derive bsp instances dlsp instances solve dlsp bsp demand item interpreted job deadline processing time jobs corresponding demand item grouped one family items dlsp families bsp jobs must processed single machine time zero respective deadlines switching job one family job another family incurs sequence dependent setup times setup costs early completion jobs penalized earliness costs correspond holding costs dlsp optimal schedule bsp minimizes sum setup costs earliness costs dlsp first introduced lasdon terjung 10 application production scheduling tire company complexity results dlsp extensions examined salomon et al 14 close relationship dlsp job class scheduling problems emphasized broader view lotsizing scheduling problems given potts van wassenhove 13 approach based lagrangean relaxation proposed fleischmann 6 dlsp without setup times fleischmann 7 utilizes ideas solution procedures vehicle routing problems solve dlsp sequence dependent setup costs dlsp sequence independent setup times setup costs examined cattrysse et al 4 recent work salomon et al 15 propose dynamic programming based approach solving dlsp sequence dependent setup times setup costs optimality results 4 7 15 serve benchmark approach solving bsp complexity scheduling problems batch setup times investigated bruno downey 2 monma potts 12 bruno downey show feasibility problem nphard setup times nonzero solution procedures scheduling problems batch setup times studied unal kiran 17 ahn hyun 1 mason anderson 11 17 feasibility problem bsp addressed effective heuristic proposed 1 11 algorithms minimize mean flow time proposed webster baker 20 survey recent results derive properties optimal schedules various batching problems contribution paper twofold first solve dlsp bsp state equivalence models solve either dlsp bsp second present algorithm solves bsp faster known procedures solving dlsp paper organized follows present dlsp bsp section 2 provide numerical example section 3 relationship models analyzed section 4 section 5 presents timetabling procedure convert sequence minimum cost schedule section 6 describe branch bound algorithm solving bsp comparison algorithm solution procedures solving variants dlsp found section 7 summary conclusions follow section 8 model formulations dlsp presented sequence dependent setup times setup costs refer problem sdstsc sdstsc includes dlsp sequence independent setups sistsc sequence dependent setup costs zero setup times sdsc generic dlsp sequence independent setup costs zero setup times cf fleischmann 6 special cases table 1 parameters dlsp index item family denotes idle machine index periods q demand item period holding costs per unit period item st gi setup time item g item gi setup costs per setup period item g item sc gi setup costs item g item st gi g table 2 decision variables dlsp 1 item produced period 0 otherwise time period machine setup item period previous item item g 0 otherwise inventory item end period dlsp parameters given table 1 items families dlsp bsp indexed holding costs per unit item period production fulfill demand q item period setup costs sc gi distributed maxf1 st gi g setup periods defining perperiod setup costs sc p gi decision variables given table 2 set production takes place item period v setup item g item period denotes inventory item end period mixed binary formulation table 3 objective 1 minimizes sum setup costs sc p per setup period st gi inventory holding costs constraints 2 express inventory balance nothing production enforced constraints 3 period machine either produces full unit capacity undergoes setup item idle ie idle period st instantiate v git appropriately constraints 5 couple setup production whenever st gi 0 item produced period item g period tgamma gamma1 decision variable v st gi constraints 6 enforce correct length string setup variables v gitgamma st gi 1 however st gi 0 exclude case setting v done constraints 7 constraints 8 prevent backlogging finally variables v gi initialized 0 constraints 11 due nothing production write dlsp schedule terms perioditem assignment string specifies action period ie st gi 0 bsp family scheduling problem cf eg webster baker 20 parameters cf table related n families index number jobs n family total number jobs j table 3 model dlsp min 1 subject st st st gi st gi st gi st gi 0 table 4 parameters bsp number jobs family number jobs denotes jth job family processing time jth job family ij deadline jth job family w ij earliness weight per unit time jth job family number table 5 decision variables bsp sequence jobs denotes job position k c ij completion time job idle time jobs 0 otherwise table model bsp min zbsp subject st kgamma1 k st 0i k st kgamma1 k st kgamma1 k one unit family inventory one period time setup times st gi setup costs sc gi given pair families g set jobs partitioned families jth job family indexed tuple j associated job processing time p ij deadline ij weight w ij job weights w ij proportional quantity processing time job proportional weights derived h p ij put tuple brackets index job attributes tuple denotes job one entity decision variables given table 5 sequence denotes processing order jobs denotes job position k together completion times c ij job obtain schedule oe conceptual model formulation bsp presented table 6 zbsp oe denotes sum earliness setup costs schedule oe minimized objective 12 earliness weighted w ij setup costs sc kgamma1 k incurred jobs different families job scheduled time zero deadline respecting sequence machine well setup times done constraints 13 constraints one idle time two consecutive jobs setup time st 0i k idle machine rather sequence dependent setup time st kgamma1 k initializations beginning end schedule given 16 17 respectively remark 1 bsp dlsp parameters assume 1 setup times setup costs satisfy triangle inequality ie st gi st gl st li sc gi 2 setups within family ie st teardown times costs ie st 3 binary demand dlsp ie q 2 f0 1g 4 jobs one family labeled order increasing deadlines deadlines interfere ie remark 1 states 1 beneficial perform two setups order accomplish one mason anderson 11 show problems nonzero teardowns easily converted problems sequence dependent setups zero teardowns motivates 2 1 2 st 0i st gi analogously setup costs thus third term objective 12 always nonnegative assumption 3 anticipates nothing production item cf also salomon et al 14 basically assumption 4 jobs one family considered scheduled c main observation motivated us consider dlsp special case bsp q matrix sparse especially setup times significant basic idea interpret items dlsp families bsp regard nonzero demand dlsp jobs deadline processing time bsp order solve dlsp special case bsp derive bsp instances dlsp instances following way setup times setup costs bsp comparison equivalence bsp solution procedure dlsp instances dlsp solution procedures bspdlsp bsputdlsp solution transformation figure 1 comparison dlsp bsp dlsp identical job attributes bsp instances derived q matrix definitions 1 2 defined bsp instance unit time jobs derived dlsp instance family n jobs entry q denotes job defined bsp instance derived dlsp instance sequence consecutive ones q matrix ie q number times sequence consecutive ones appears item defines n figure 1 provides framework bspdlsp comparison transforming dlsp instances bsp instances compare performance solution procedures quality solutions difference approaches follows dlsp decisions made anew individual period represented decision variables v git cf table 2 bsp decide schedule jobs ie decide completion times jobs bsp dlsp address underlying planning problem use different decision variables bruggemann jahnke 3 make another observation concerns transformation instances dlsp instance may polynomially bounded size size bspdlsp instance polynomially bounded account 3 argued q matrix reasonable encoding dlsp instance sense garey johnson 9 bspdlsp describes problem instance concise way 3 numerical example section provide example illustrating generation bsputdlsp bspdlsp also refer example demonstrate certain properties bsp figure 2 illustrate equivalence models corresponding parameters setup times setup costs holding costs given table 7 figure 2 shows demand matrix q dlsp jobs respective deadlines bsputdlsp bspdlsp table 7 numerical example setup holding costs st 3 3 3 3 2 1 1 2 bsputdlsp oe ut bsputdlsp oe ut bspdlsp oe figure 2 dlsp bsputdlsp bspdlsp table 8 bsputdlsp instance solution bsputdlsp interpret entry one job j deadline ij processing times p ij equal one jobs summarize bsputdlsp parameters table 8 optimal dlsp schedule h string figure 2 entries f0 1 2 3g idle time production different items respectively schedule represented oe ut bsputdlsp displayed table 8 schedules optimal objective function value zbsp oe ut bspdlsp consecutive ones demand matrix q linked one job number jobs thus smaller bspdlsp bsputdlsp instance jobs 1 2 1 3 bsputdlsp linked one job 1 2 bspdlsp compare oe ut b oe b however bspdlsp schedule cannot figure 2 since need unit time jobs bspdlsp let cost parameters costs families sc optimal dlsp schedule oe b optimal bspdlsp schedule optimal objective function value zbsp oe b example shows schedules obtained different models next section formally analyze equivalence dlsp bsp 4 relationship bsputdlsp bspdlsp dlsp bsp distinguish sequence schedule bsp schedule may inserted idle time processing order fully describe schedule following say consecutively sequenced job sequenced next position consecutively schedule job idle time jobs ie term brackets constraints 14 equals zero sequence bsp consists groups group ordered set consecutively sequenced jobs belong family hand schedule consists one several blocks jobs one block consecutively scheduled different blocks separated idle time distinguish setup time jobs one block may belong different families block group may consist single job example refer figure 2 oe c oe consist five groups oe c forms two blocks oe one block given sequence bsp schedule oe called semiactive c ij constrained either ij start next job job scheduled later rightshifted semiactive schedule oe derive oe sequence constraints 13 equalities p k set zero costs zbsp oe lower bound costs zbsp oe bsp schedule oe oe optimal schedule relaxed bsp constraints 14 omitted however semiactive schedule may idle time may beneficial schedule jobs earlier ie leftshift jobs save setups concern timetabling procedure section 5 models save setups batching jobs dlsp batch noninterrupted sequence periods production takes place item 6 0 ie bsp jobs one group consecutively scheduled without setup batch batch must preempted idle time figure 2 group family 3 forms two batches schedule oe c whereas group one batch oe b call sequence schedule oe eddwf sequence schedule jobs one family sequenced scheduled nondecreasing order deadlines eddwf abbreviates earliest deadline within families ordering jobs eddwf called ordered batch scheduling problem monma potts 12 considering eddwf sequences reduce search space branch bound algorithm described section 6 first consider bsputdlsp instances following theorem states bsputdlsp restrict eddwf sequences theorem 1 bsputdlsp schedule oe converted eddwf schedule oe cost proof recall jobs one family weights processing times schedule oe let b c represent parts oe consisting several jobs processing times parts consider schedule jobs ordered eddwf ie schedule objective function value w ij 1 completion times parts b c change interchanging jobs repeated oe eddwf schedule completing proof 2 dlsp schedule bsputdlsp schedule oe called corresponding solutions define decision schedule schedule oe corresponding solutions point time following holds oe job processed belongs family setup performed oe iii machine idle oe figure 2 gives example corresponding solutions corresponds oe ut b corresponds oe ut b always derive entries oe completion times oe always derived oe eddwf schedule theorem 2 schedule oe feasible bsputdlsp corresponding solution feasible dlsp oe objective function value proof first prove constraints dlsp bsputdlsp define solution space dlsp constraints 2 8 stipulate q 0 2 8 enforce sequence machine sequence dependent setup times taken account described constraints 3 7 bsp achieved constraints 13 schedule job time zero deadline jobs processed single machine taking account sequence dependent setup times second prove objective functions 1 12 assign objective function value corresponding solutions oe cumulated inventory item planning horizon equals cumulated earliness family job weights equal holding costs ie h bsputdlsp thus terms equal corresponding solutions oe explanation necessary show corresponding solutions oe setup costs consider setup family g g 6 0 without idle time oe sc st gi g st gi consecutive ones v git enforced 6 hand case inserted idle time setup idle machine enforced decision variable p k bsp st 0i consecutive ones v 0it thus terms equal corresponding solutions oe therefore corresponding solutions oe incur holding setup costs proves theorem 2 consequence theorem 2 schedule oe optimal bsputdlsp corresponding solution optimal dlsp constitutes equivalence dlsp bsp bsp utdlsp instances thus solve dlsp solving bsputdlsp general however attractive option solve bspdlsp number jobs smaller definition 3 schedule oe let production start family start time first job batch let inventory family build c ij ij schedule oe called regenerative production start family long still inventory family term regenerative stems regeneration property found wagner whitin 19 similar ideas cf eg vickson et al 18 regenerative schedule also eddwf schedule reverse true schedule oe regenerative jobs batch holds furthermore regenerative bsputdlsp schedule oe jobs consecutive ones q scheduled consecutively recall instance oe ut b oe b figure 2 hence regenerative bsputdlsp schedule represents bspdlsp schedule well figure 2 schedule oe regenerative batch family started still inventory first show lose feasibility restricting regenerative schedules theorem 3 oe feasible bsputdlsp bspdlsp schedule also feasible regenerative schedule oe oe oe figure 3 regenerative schedule proof schedule oe let b family first last job part b belongs consider nonregenerative schedule oe ie one batch though c consider schedule interchanged one batch oe feasible leftshifting b violate feasibility furthermore due triangle inequality st b st st ii b thus b leftshifted p ij time units without affecting ca interchanging jobs repeated oe regenerative proves theorem 2 illustration construction regenerative schedules depicted figure 3 interchanging b obtain oe regenerative schedule oe unit processing times needed proof theorem 3 fact two results first find feasible schedule may consider bspdlsp instead bsputdlsp second bspdlsp need search regenerative schedules find feasible schedule theorem 3 stronger result one found salomon et al 14 unal kiran 17 state first result moreover holding costs equal next theorem extends result optimal schedules theorem 4 oe optimal bsputdlsp bspdlsp schedule h constant 8i also optimal regenerative schedule oe proof analogous proof theorem 3 must consider change objective function value interchanged without loss generality let h zbsp oe zbsp oe denote objective function value oe oe part b leftshifted wb pb processing time part b pb b may contain setups well interchanging b j objective changes follows due triangle inequality setup costs setup times oe larger oe ie gammasc gamma explains leftshift b p ij rightshift j pb wb pb explains ii thus zbsp oe zbsp oe proves theorem 2 considering regenerative schedules achieve considerable reduction search space summarize far obtained following results 1 dlsp bsp equivalent bsputdlsp 2 feasibility bspdlsp implies feasibility dlsp 3 equal holding costs optimal bspdlsp schedule optimal dlsp instances unequal holding costs solved theoretical difference bspdlsp dlsp 3 small effect computational results section 73 show almost always optimal regenerative bsputdlsp schedule found solving bspdlsp 5 timetabling procedure given sequence given sequence following timetabling procedure decides partition blocks equivalently consecutively sequenced jobs consecutively scheduled bsp model formulation table 6 job position k starts new block p blocked preceding job starting new block position k save earliness costs expense additional setup costs figure 2 earliness costs oe b higher oe c save one setup oe b timetabling procedure start semiactive schedule leftshift jobs find minimum cost schedule consider example figure 2 sequence 3 3 2 2 1 2 semiactive schedule oe given figure 4 first consider two special cases omit constraints 14 bsp group batch idle time may preempt batch timetabling trivial semiactive schedule optimal given sequence job rightshifted decrease earliness costs setup costs determined oe timetabling also trivial earliness weights zero ie h case leftshift job without increasing earliness costs resulting schedule one block eg schedule oe figure 2 one block job leftshifted sc gi sc i0 sc setup costs minimized jobs scheduled block optimal schedule consists one block general case need definitions block costs bc k1k2 cost contribution block position k 1 k 2 ie bc k1 block size bs k number jobs consecutively scheduled job included instance figure 4 bs let denote f k b costs schedule position k j bs k costs minimum cost schedule bs k corresponding block size position k recurrence equation determining f k bs f b1bs oe position k figure 4 semiactive schedule table 9 computations equation 18 example figure 4 f equation 18 take minimum cost bs maximum block size position k new block starts kbs 1 given block size b f k b sum block costs position k position k next block minimum cost f kb basically equation 18 must computed every sequence however simplifications possible two jobs consecutively scheduled semiactive schedule optimal increment bs bs equation 18 needs evaluated consequently semiactive schedule one block timetabling trivial group oe equals one batch whole schedule forms block setups sequence independent minimum cost schedule derived less effort follows let group size gs k position k denote number consecutively sequenced jobs positions r k belong family job k j k sequence independent setups equation 18 must evaluated gs k reasoning follows jobs different groups leftshifted blocked save setup cost consecutive groups families g would need sc hold sequence independent setups therefore need decide leftshift within group example computations equation 18 given table 9 semiactive schedule figure 4 see cost parameters table 7 schedule oe contains idle time determine f bs k position k k j consider jobs 22 33 32 positions 65 4 figure 4 position 4 semiactive schedule one block increment bs k denoted entries table 9 job 31 oe inserted idle time positions 3 4 different block sizes must considered find minimum cost schedule table 9 find f ie start new block position split group two batches done oe c figure 2 objective function value add sc 02 f 1 obtain cost zbsp oe c 6 sequencing algorithm section present branch bound algorithm solving bsp optimality denoted sabsp jobs sequenced backwards ie stage 1 job assigned position j stage 2 position stage position assigns jobs last positions sequence addition spartial schedule oe also assigns completion times job partial schedule called completion oe extends oe schedule oe schedules jobs write examine eddwf sequences precedence constraints jobs precedence graph example figure 2 shown figure 5 using eddwf ordering figure 5 eddwf precedence graph backward sequencing table 10 attributes partial schedules consideration stage ub upper bound objective function value current best schedule coe cost oe without setup us set jobs already scheduled unscheduled spartial schedule oe ui set families jobs us belong jobs form first block oe earliness weights jobs g 1 oe ie decide fact stage family schedule job eligible stage precedence related predecessors scheduled spartial schedule corresponding node search tree extended scheduling eligible job stage 1 apply depthfirst search enumeration use bounding branching dominance rules described sections 61 62 prune search tree spartial sequence uniquely defines minimum cost spartial schedule oe timetabling procedure enumeration done sequences stops sequences implicitly examined best solution found optimal implementation sabsp takes advantage fact equation 18 needs recalculated every oe case backtracking computation equation 18 already accomplished partial schedule backtrack table lists attributes spartial schedules scheduling stage identify job consideration start time toe costs coe spartial schedule set currently scheduled unscheduled jobs denoted us ui denotes families jobs us belong ub current upper bound 61 bounding branching rules feasibility bound states given oe currently unscheduled jobs us must scheduled time zero toe furthermore need setup time family ui formally define min fst ij2us oe feasible completion toe cost bound states costs coe spartial schedule lower bound extensions oe completion least one setup family ui must performed define min fsc gi g oe cannot extended schedule improves ub c bounds checked spartial schedule oe clearly c easily updated search also tested sophisticated lower bound unscheduled jobs scheduled edd order without setups way able derive lower bound earliness costs well check feasibility carefully computation times decrease regenerative schedules need considered find optimal schedule cf theorem 4 employ branching rule follows scheduling eligible eddwf precedence graph toe batch consider job extension oe need enumerate partial schedules oe extended job g resulting schedule nonregenerative 62 dominance rules remarkable reduction computation times comes result dominance rules dominance rules sabsp compare two spartial schedules oe oe schedule set jobs notation schedule oe denotes spartial schedule currently consideration oe denotes previously enumerated schedule may dominate oe partial schedule oe dominates oe efficient terms time cost oe starts later schedule jobset ie toe incurs less cost ie coe coe family job scheduled stage differs oe oe make partial schedules comparable setup compare time cost subtract setup times setup costs appropriately schedule oe dominated store job set family pair toe coe likely dominate spartial schedules note number partial schedules exponential number items n storage requirements dominance rules grow rapidly n increases formal description dominance rules need several definitions cf table 10 jobs form block belong set g 1 oe sum earliness weights g 1 oe denoted w 1 oe dominance rules take account block costs extensions oe oe consider oe maximum oe minimum costs incurred blocking oe dominates oe coe plus upper bound block costs less equal coe plus lower bound block costs upper bound block costs oe given sc 0i recall sc 0i sc gi oe starts new block tighter upper bound found start times close toe order save costs leftshift jobs g 1 oe g 1 oe perform new setup idle machine g 1 oe largest block may leftshifted let pbtoe denote time cost increase due leftshift g 1 oe exceeds sc 0i w 1 oe toe define pullbacktime pbtoe spartial schedule oe follows consequently time pbtoe upper bound block costs given leftshifting g 1 oe bounded sc 0i lower bound block costs oe given way oe consider smallest block leftshifted simply job state dominance rule differentiate theorem 5 orem 6 theorem 5 consider two spartial schedules oe oe proof completion oe also feasible completion oe oe feasible due ii schedule oe lower costs oe following consider cost contributions oe oe due leftshifting extend oe oe consider figure 6 illustration situation timecost diagram due eddwf also line represents upper bound block costs oe pbtoe expensive leftshift g 1 oe pbtoe setup idle machine performed broken line represents lower bound block costs oe smallest block leftshifted job order prove oe never less costs oe due blocking check costs points ii iii ii compare costs toe iii compare pbtoe ii iii costs increase linearly pbtoe know monotonous cost increase oe costs oe longer increase thus ii iii fulfilled cost contributions oe less oe ie completion zbsp oe completing proof 2 example figure 2 figures 7 8 illustrate theorem 5 3partial schedules oe 3 oe 3 figure 7 g 1 oe 3 cost oe oe figure illustration theorem 5 oe 3t figure 7 theorem 5 oe 3 dominates oe 3 checking ii 22 iii 22 oe 3 dominated figure 8 illustrates effect block costs modified data follows 103 checking theorem 5 ii fulfilled thus oe 3 dominate oe 3 though coe 3 figure 8 shows coe 4 leftshifted second dominance rule case must consider sc 0i instead sc gi take block costs account theorem 6 given two spartial schedules oe oe st denote family last job completion oe st st st analogously setup costs due triangle inequality thus completion oe also feasible completion oe oe feasible oe feasible due ii schedule oe lower costs oe figure 8 theorem 5 oe 3 dominate oe 3 difference also block costs taken account ii leftshifting g 1 oe extension oe coe upper bound cost contribution trivial lower bound cost contribution oe coe thus oe dominates oe completes oe lower costs completing proof 2 finally alternative way solve bsp dynamic programming approach define jobsets states apply dominance rules way implementation approach less efficient described jordan 8 7 comparison procedures solve variants dlsp analysis section 4 know address planning problem bsp dlsp find corresponding solutions consequently section compare performance algorithms solving bsp procedures solving variants dlsp comparison made dlsp instances used test dlsp procedures take instances provided cited authors solve bspdlsp bsputdlsp instances cf figure 1 exception made reference 7 use randomly generated instances different dlsp variants summarized table 11 dlsp first column reference second dlsp variant displayed fourth column denotes proposed algorithm third column shows whether computational results proposed algorithm reported equal unequal holding costs depending holding costs different dlsp variants solved bspdlsp bsputdlsp instances exception reference 15 dlsp procedures tested equal holding costs regenerative schedules optimal 4 7 71 sequence independent setup times setup costs sistsc cattrysse et al 4 mathematical programming based procedure solve sistsc proposed cattrysse et al 4 refer procedure dual ascent column generation procedure dacgp dlsp first formulated set partitioning problem spp columns represent production schedule one item costs column calculated separately setups sequence independent dacgp computes lower bound spp column generation new table solving different dlsp variants bsp author variant holding costs algorithm instances properties schedules cattrysse et al 4 regenerative fleisch mann regenerative salomon et al 15 one block columns generated solving single item subproblem polynomial dp recursion dacgp feasible schedule ie upper bound may found column generation step calculated enumerative algorithm columns generated far neither case feasible schedule found attempt made simplex based procedure heuristic dacgp generates upper lower bound sabsp solves bspdlsp optimality dacgp coded fortran sabsp coded c dacgp run ibmps2 model 80 pc 80386 processor 80387 mathematical coprocessor implemented sabsp machine make computation times comparable computational results dacgp reported identical holding costs items consequently solve dlsp bspdlsp need consider regenerative schedules theorem 4 furthermore timetabling procedure requires fewer computations equation 18 setups sequence independent dlsp instances nonzero setup times provided authors 4 generated instances itemperiod combinations fn 60g refer instances smaller instances solved much faster sabsp dacgp dlsp instances setup times st gi either 0 1 2 periods average setuptime per item instances approximately 05 making setup times significant item period combination instances different approximate capacity utilizations ae generated low l capacitated ae 055 medium 055 ae 075 high h capacitated instances ae 075 approximate capacity utilization defined ae 1t generated combination amounting 3 instances total table 12 use j denote average number jobs bspdlsp instance size n dlsp dacgp use 4 avg denote average gap percent upper lower bound inf number instances found infeasible different procedures r avg denotes average time seconds needed instances class dacgp values table 12 taken 4 table 12 comparison dlsp bsp algorithms sistsc dacgp sabsp 4 386 pc coprocessor comparison dacgp sabsp bb algorithm solves problems much faster number sequences examine relatively small computation times sabsp order magnitude dacgp 6 60m simplex based procedure dacgp finds feasible integer solution one 10 instances claimed infeasible dacgp thus 6 60m 9 instances remain unsolved dacgp whereas sabsp finds 7 infeasible instances dacgp also fails find existing feasible schedules n ae 260h 460m recall sabsp takes advantage small solution space keeping enumeration tree small thus detecting infeasibility feasible schedule quite quickly dacgp tries improve lower upper bound difficult without initial feasible schedule therefore heuristic solution procedure dacgp may fail detect feasible schedules solution space small problem size n dlsp number jobs j bspdlsp may different therefore solution times differ considerably sabsp table 13 presents frequency distribution solution times every problem class majority instances solved less average time dacgp 72 sequence dependent setup costs sdsc algorithm solving sdsc proposed fleischmann 7 fleischmann transforms dlsp traveling salesman problem time windows tsptw tour corresponds production schedule sdsc fleischmann calculates lower bound lagrangean relaxation condition node visited exactly relaxed upper bound calculated heuristic first constructs tour tsptw tries improve schedule using oropt operation oropt pieces initial tour exchanged obtain improved schedule oropt repeated improvements found refer fleischmanns algorithm tsporopt tsporopt table 13 frequency distribution solution times sabsp number instances solved faster 4 28 386 pc coprocessor coded fortran experiments performed 486dx266 pc original code provided fleischmann fleischmann divides time axis micro macro periods holding costs arise macro periods demand occurs end macro periods thus direct comparison tsporopt sabsp using fleischmanns instances viable instead use randomly generated bsp instances transformed dlsp instances generated instances low l ae 075 high hae 097 capacity utilization note zero setup times ae depend schedule feasibility problem polynomially solvable bsp average number jobs processing time interval 1 4 dlsp average high h low l capacitated instances holding costs identical solve bspdlsp 7 select 2 setup cost matrices s4 s6 satisfy triangle inequality s4 costs equal 100 g 500 g s6 two kinds setups items f1 2 3g f4 5g form two setupgroups minor setup costs 100 within setupgroups major setup costs 500 one setupgroup table 14 results aggregated instances class use 4 avg denote average gap lower upper bound tsporopt r avg r avg denote average time tsporopt sabsp seconds denote 4z best average deviation objective function value heuristic tsporopt optimal one found sabsp table 14 shows 4 avg quite large tsporopt solution times sabsp short high capacitated instances long low ones s4 tsporopt generates good lower bound best deviation optimal objective due poor heuristic upper bound hand s6 lower upper bound close optimum well note sabsp solve large instances sdsc 8 10 items whereas fleischmann reports computational experience instances size well feasibility bound much weaker zero setup times equivalently solution space much larger making sabsp less effective table 14 comparison dlsp bsp algorithms sdsc setup cost tsporopt sabsp best r avg r avg instances table 14 however sabsp yields better performance 73 sequence dependent setup times setup costs sdstsc salomon et al 15 fleischmanns transformation dlsp tsp time windows tsptw extended nonzero setup times order solve sdstsc nodes tsp network represent positive demands nodes must visited within certain time window transformed dlsp solved dynamic programming approach designed tsptw problems cf dumas et al 5 refer procedure 15 tsptwa paths tsp network correspond partial schedules similar dominance rule sabsp tsptwa paths may dominate paths via cost dominance may eliminated cannot extended corresponds feasibility bound tsptwa coded c run hp9000730 workstation 76 mips 22 flops sabsp runs 486dx266 pc order test tsptwa salomon et al 15 use randomly generated instances similar 4 setup times st gi 2 f0 2g unfortunately setup times satisfy triangle inequality triangularization eg floydwarshall algorithm often results setup times equal zero adjusted setup times upwards possible case st gi 2 f0 1 2g result setup times rarely zero added 4 8 units planning horizon order obtain medium capacity utilization 15 way instances supposed degree difficulty tsptwa sabsp smaller solution space due correcting st gi upwards compensated longer planning horizon 15 instances generated take largest instances itemperiod combination fn 60g instances medium capacity utilization 05 ae 075 setup times nonzero n combination without holding costs generated holding costs differ among items consequently solve bsputdlsp furthermore need apply timetabling procedure latter case optimal schedule one block table 15 f number problems solved tsptwa sabsp within time limit 1200 sec 1200 sec memory limit 20 mb 10 mb j denotes average number jobs bsp r avg table 15 comparison dlsp bsp algorithms sdstsc f r avg denotes average time sabsp requires solve instances considering regenerative schedules average time calculated instances solved within time limit r avg put brackets instances solved last column shows results consider regenerative schedules enumeration provides maximal deviation optimal schedule may nonregenerative table 15 demonstrates sabsp succeeds solving problems remained unsolved tsptwa solution times sabsp relatively short compared tsptwa 5 solution times increase instances solved number jobs relatively small instances become difficult nonzero especially unequal holding costs enumerate regenerative schedules solution times sabsp decrease moreover one instance solved optimality n thus even unequal holding costs optimal schedules regenerative cases furthermore n instances would solved within time limit 1200 sec regenerative schedules would considered 8 summary conclusions paper examined discrete lotsizing scheduling problem dlsp batch sequencing problem bsp presented model formulations dlsp bsp dlsp decisions regarding done made individual period bsp decide schedule jobs dlsp solved bsp dlsp instances transformed schedule one model corresponding solution model proved equivalence models meaning optimal schedule bsp corresponding solution dlsp also optimal schedule vice versa order solve bsp effectively tried restrict search subset possible schedules found jobs one family preordered according deadlines furthermore equal holding costs optimal start production family inventory family solving bsp branch bound algorithm optimality face difficulty already feasibility problem difficult must maintain feasibility minimize costs time compared scheduling models objective function rather difficult bsp tight lower bound could thus developed therefore used dominance rules prune search tree difficult objective function complicates dominance rules forces us distinguish different cases order evaluate approach tested specialized procedures solving variants dlsp despite fact effective lower bound approach proved efficient number items small ii instances hard solve ie capacity utilization high setup times significant appropriate schedule jobs decide individual period dlsp time horizon divided small periods parameters based period length bsp parameters also real numbers setup times particular restricted multiples period length different models also result different problem sizes dlsp bsp problem size dlsp essentially number items n periods problem size bsp depends number families jobs conjecture approach advantageous instances items small solution space ie long setup times high capacity utilization job sequence main characteristic solution cases managed solve instances 10 5 families jobs pc dlsp solution procedures thought better suited lower capacitated instances many items setup times significant parameters differ among periods appropriate decide anew individual period future extend bsp multilevel structures multiple machines acknowledgments indebted dirk cattrysse marc solomon made available instances bernhard fleischmann made available code furthermore would like thank three anonymous referees valuable comments earlier versions paper r single facility multiclass job scheduling complexity task sequencing deadlines extensions discrete lotsizing scheduling problem dual ascent column generation heuristic discrete lotsizing scheduling problem setuptimes technical note optimal algorithm traveling salesman problem time windows discrete lotsizing scheduling problem discrete lotsizing scheduling problem sequencedependent setupcosts batching scheduling models methods several problem classes computers intractability guide theory npcompleteness minimizing flow time single machine job classes setup times complexity scheduling batch setuptimes integrating scheduling batching lot sizing review algorithms complexity extensions discrete lotsizing scheduling problem discrete lotsizing scheduling sequence dependent setup times costs batching single operation manufacturing systems batch sequencing batching sequencing components single facility dynamic version economic lot size model scheduling groups jobs single machine tr ctr c k lin c l wong c yeung heuristic approaches scheduling problem plastic molding department audio company journal heuristics v8 n5 p515540 september 2002 satyaki ghosh dastidar rakesh nagi scheduling injection molding operations multiple resource constraints sequence dependent setup times costs computers operations research v32 n11 p29873005 november 2005
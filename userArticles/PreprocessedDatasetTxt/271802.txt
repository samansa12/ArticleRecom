limit control flow analysis regression test selection automated analyses regression test selection rts attempt determine modified program run test behavior old version program run without running new program rts analyses must confront priceperformance tradeoff precise analysis might able eliminate tests could take much longer runwe focus application control flow analysis control flow coverage relatively inexpensive analyses rts problem considering precision rts algorithms affected type coverage information collected define strong optimality condition edgeoptimality rts algorithms based edge coverage precisely captures algorithm report retesting needed actuality reformulate rothermel harrolds rts algorithm present three new algorithms improve culminating edgeoptimal algorithm finally consider path coverage used improve precision rts algorithms b introduction goal regression test selection rts analysis answer following question inexpensively possible given test input programs old new newt observable behavior oldt appear 1998 acmsigsoft international symposium software testing analysis course desired answer question without running program new test rts analysis uses static analysis programs old new combination dynamic information coverage collected execution oldt order make determination rts algorithm either selects test retesting eliminates test static analyses rts come many varieties examine syntactic structure program 6 others use control flow control dependence information 11 12 ambitious analyses examine defuse chains flow dependences program 9 5 typically analyses precise previous greater cost safe conservative rts analysis never eliminates test newt different behavior oldt safe algorithm may select test could eliminated focus application control flow analysis safe regression testing use crts refer control flowbased rts previous work improved precision crts analysis left open question limit analyses crts improved two ways increasing precision analysis applied control flow graph representations programs old new increasing precision dynamic information recorded execution oldt address issues interactions results threefold ffl section 3 building recent work crts rothermel harrold 12 show strong relationship crts deterministic finite state automata intersection regular languages define intersection graph two control flow graphs precisely captures goal crts forms basis family crts algorithms parameterized dynamic information collected oldt ffl section 4 consider power crts dynamic information recorded oldt edge coverage ie whether edge olds control flow graph executed define strong optimality condition edge optimality crts algorithms based edge coverage reformulate rothermel harrolds crts algorithm terms intersection graph present three new algorithms improve culminating edgeoptimal algorithm first algorithm eliminates test whenever rothermelharrold algorithm safely eliminates tests general cost next two algorithms even precise greater computational cost ffl section 5 recording path coverage information rather edge coverage improve upon edge optimal algorithms however path profiling limited tracking paths bounded length motivated concerns efficiency adversary always able choose program new cause crts algorithm based path coverage fail section 6 reviews related work section 7 summarizes paper background assume standard imperative language c c java control flow graph procedure p completely determined compile time ps control flow graph g vertex represents basic block instructions edge represents control transition blocks translation abstract syntax tree representation procedure control flow graph representation well known 1 since g executable representation p talk executing p g test define graph terminology useful sequel x directed control flow graph vertices unique entry vertex vertices reachable exit vertex x successors reachable vertices vertex v labelled bbv code basic block contains two different vertices may identical labels often convenient refer vertex label often distinguishing vertices identical labels necessary edge source vertex v target vertex w via directed edge labelled l outgoing edges vertex uniquely labeled labels values typically true false boolean predicates determine control transfer next execution bbv 2 vertex v one outgoing edge label e shown figures since outgoing edges vertex uniquely labelled edge may also represented pair v l call control transition transition short vertex succv l denotes vertex lsuccessor vertex v path g sequence edges target vertex e source vertex e i1 1 path may represented equivalently alternating sequence vertices edge labels source vertex edge e 1 n v n1 target vertex e n l label edge e given path p n edges n th vertex th edge label 1 n 2 number outgoing edges vertex v labels edges uniquely defined bbv thus different vertices identical basic blocks number outgoing edges identical labels paths beginning designated vertex purposes entry vertex equivalently represented sequence basic blocks labels rather sequence edges vertices labels complete path path x figure 1 shows two programs p p 0 corresponding control flow graphs g g 0 g g 0 entry vertex exit vertex label vertex v denotes basic block bbv graph g one occurrence basic block c graph g 0 two occurrences c graph g 00 intersection graph g g 0 discussed next 3 crts intersection graph control flow analysis graphical structure program alyzed semantics statements program except say whether two statements textually identical implies crts algorithms must assume every complete path graph potentially executable even though may unexecutable paths unexecutable paths cannot affect safety crts algorithms may decrease preci sion compiler optimization crts algorithms must able determine two basic blocks semantically equivalent course undecidable gen eral following rothermel harrold use textual equivalence code conservative approximation semantic equiva lence captured definition equivalent vertices two vertices v w potentially different graphs equivalent code bbv lexicographically identical bbw let equivvw true iff v equivalent w 3 equivalent vertices extend equivalence paths follows paths p q identical p q length equivp v q v true p l p q identical words alphabet basic blocks labels following simple definition restatement found 11 precisely captures power crts graph g run input denoted gt traverses complete path p graph g 0 contains complete path p 0 identical p g 0 traverse path p 0 observable behavior gt definition translates trivially precise computationally expensive crts algorithm record complete execution path gt via code instrumentation traces path 4 compare control flow graph g 0 determine path exists see later section 5 algorithm record complete execution path gt forced adversary choosing appropriate graph g 0 select test could eliminated observe control flow graph g may viewed deterministic finite automaton dfa start state final state x accepts language lg set complete paths g precisely control flow graph g straightforward interpretation dfa vertex v v corresponds two 3 exit vertex x equivalent exit vertices ie vertices successors uu f f f g aa reject accept u c else z else c w u f f z g u c w u f f f g figure 1 example programs p p 0 corresponding control flow graphs g g 0 intersection graph g 00 g g 0 states v 1 v 2 states connected state transition labelled bbv edges e also interpreted state transitions edge v l w interpreted state transition alphabet dfa union basic blocks edge labels 1 start state x 2 final state recognizes precisely complete paths g rather represent control flow graph verbose fashion choose present traditional form keep dfa interpretation mind given insight crts question reduces complete path p lg also lg 0 paths retesting needed let dgg 0 paths retesting needed crts algorithm optimal given path p igg 0 algorithm reports p igg 0 crts algorithm safe given path p dgg 0 algorithm reports p help reason igg 0 dgg 0 define new graph intersection graph also straightforward interpretation dfa 4 graph efficiently constructed g g 0 vertex set v 00 g 00 simply cross product v v 0 two additional vertices use following relation help define essentially optimized version product automaton g g 0 7 edge set e 00 defined terms l equiv relation entry vertex g 00 restrict vertex edge sets g 00 vertices edges reachable vertices 0 edges reachable equivalent pair v v 0 reachable 0 path p g v prefix path igg 0 reject represents reject state corresponds paths dgg 0 represents accept state corresponds paths igg 0 figure 1 shows intersection graph g 00 graphs g g 0 figure see two paths igg 0 corresponding paths g 00 corresponding paths g f c f graph g 00 also shows path begins transition dgg 0 two straightforward results intersection graph g 00 inform rest paper path p igg 0 iff represented path 0 accept g 00 path p dgg 0 iff represented path 0 reject g 00 course every complete path p g either igg 0 dgg 0 theorem 1 let g 00 intersection graph graphs g g 0 path g igg 0 iff g 00 theorem 2 let g 00 intersection graph graphs g g 0 path g dgg 0 iff exists n g 00 figure shows intersection graph graphs g g 0 computed via synchronous depthfirst search graphs procedure dfs always called equivalent vertices v v 0 v v 0 already v 00 pair visited procedure returns otherwise v v 0 inserted v 00 corresponding edge considered turn 5 edges appropriately inserted e 00 reflect whether vertices w w 0 equivalent whether w exit vertex g algorithm recurses w w 0 equivalent w exit vertex g algorithm also computes set vertices v 00 accept accept reachable g 00 used later worstcase time complexity algorithm ojej delta je 0 j note necessary store relation e 00 explicitly since derived demand v 00 e e 0 thus space complexity storing intersection graph well v 00 accept worst case 4 crts using edge coverage limit crts given dynamic information collected gt edge coverage consider complete path p representing execution path gt set edges e p g covers may another complete path q g distinct p e represent set paths including p whose edge sets identical e p determine whether g 0 needs retesting crts algorithm using edge coverage must consider least implicitly paths p p paths members igg 0 crts algorithm eliminate test generated path p however even one paths p p dgg 0 algorithm must select test order safe given insight define means crts algorithm edgeoptimal crts algorithm edgeoptimal path p p p igg 0 algorithm reports p igg 0 5 note v v 0 equivalent w must defined since bbv 0 identical bbv 6 note paths exist g acyclic case complete path different set edges complete paths accept facceptg procedure begin edge else else accept accept fvv 0 g ni od figure 2 constructing intersection graph g g 0 via synchronous depthfirst search two graphs algorithm also determines set vertices v 00 accept accept reachable accept reject accept reject accept reject rothermelharrold algorithm partialreachability algorithm fullreachability algorithm accept reject validreachability algorithm figure 3 four edgebased crts algorithms summarized pictorially intersection graph dotted outline represents v 00 accept vertices g 00 accept reachable algorithm time space precision edgeoptimal rothermelharrold ojej delta je partialreachability ojej delta je fullreachability ojej delta je table 1 comparison four edgebased crts algorithms first present rothermelharrold rh algorithm restated terms intersection graph present three new algo rithms culminating edgeoptimal algorithm figure 3 illustrates rh algorithm four algorithms using intersection graph 7 picture shows start vertex states reject accept dotted outline represents accept vertices g 00 accept reachable ffl rh algorithm detects whether e p covers edge incident reject path p must igg 0 ffl partialreachability algorithm detects whether e p covers path intersection graph edge leaving accept reject vertex path exists p igg 0 surprising result partialreachability reject determined time space complexity equivalent rh algorithm algorithm precise rh algorithm since may case e p contains edge incident reject cover partial path vertex v 00 accept reject ffl fullreachability algorithm determines whether e p covers path 0 reject p igg 0 algorithm precise partialreachability al gorithm greater cost however still edge optimal ffl validreachability algorithm makes use partial order v edges g rule certain invalid paths show p cannot cover valid reaching path reject yielding edgeoptimal algorithm table 1 summarizes time space complexity four al gorithms represents set tests g run edgebased crts algorithms incur storage cost ojej delta jt edge coverage information stored test factor discussing space complexity algorithms 7 equivalent 0 igg 0 empty assume four algorithms initially check simple condition proceeding 41 rothermelharrold algorithm present rh algorithm terms intersection graph rh algorithm first computes set control transitions incident reject using synchronous depthfirst search graphs g g 0 similar figure 2 given edge set e p rh algorithm operates must igg 0 since contains transition required p dgg 0 otherwise conservatively assume p dgg 0 consider intersection graph figure 1 graph g since every path x graph g contains one transitions rh algorithm require tests rerun g 0 however example path p igg 0 rh algorithm edgeoptimal consider path transitions g 00 covered e p shown bold edges figure 1 complete path p covers exactly transitions f ct time space complexity compute clearly depthfirst search algorithm figure 2 compute tests set tests whether set edges covered gt contains transition takes ojej delta jt time thus rh algorithm overall running time ojej delta je space complexity ojv j delta jv 0 j rothermel harrold show g g 0 multiplyvisited vertex algorithm never report p dgg 0 actually igg 0 means algorithm optimal thus edgeoptimal class graphs stated terms intersection graph g 00 vertex v g multiplyvisited vertex figure vertex c graph g multiplyvisited vertex rothermel harrold ran algorithm set seven small aa uu f f f f g reject accept u f f g u f f f g u c else c w u c w figure 4 example shows partialreachability algorithm edgeoptimal programs 141512 lines code 132 modified versions one larger program 49000 lines code 5 modified versions found multiplyvisited vertex condition occur programs versions 12 experimentation clearly needed larger diverse sets programs see often condition arises 42 partialreachability algorithm let us reconsider example figure 1 dotted outline graph g 00 shows set v 00 accept transition leaving set path leading reject must include transition thus transition e p p must igg 0 case path e ctweg consider projection e p onto edge set g graph g 00 results edges e 00 shown bold figure 1 straightforward see general edge v 00 w 00 g 00 reject must reachable w 00 g 00 therefore edge v 00 accept w 00 v 00 accept must case reject reachable w 00 observation leads partialreachability algorithm time space complexity identical rh algorithm yet precise algorithm require construction g 00 p able determine whether reject partially reachable edge leaving v 00 accept similar rh algorithm algorithm first computes set reject transitions g using intersection accept g set reject contains transitions g transfer control accept algorithm operates follows p igg 0 since p must contain transition reject order dgg 0 otherwise conservatively assume p dgg 0 easy see partialreachability algorithm subsumes rh algorithm since whenever reject empty empty stated another way whenever rh algorithm reports p igg 0 partialreachability algorithm report shown figure 2 set v 00 accept determined construction intersection graph ojej delta je 0 space compute reject takes ojej simply requires visiting every edge e 00 e 00 determine e 00 leaves accept transition e g corresponding e 00 added reject reject computed rest algorithm identical rh algorithm test check whether set edges covered test edge reject thus time space complexity algorithm identical rh algorithm 43 fullreachability algorithm figure 4 shows partialreachability algorithm edge optimal example intersection graph g 00 thus path igg 0 p p igg 0 rh algorithm partial reachability algorithm fail report p igg 0 since transition ct covered path p note however g 00 p reject vertex reachable 0 general either reject accept must reachable 0 g 00 fullreachability algorithm simple reject reachable g 00 p igg 0 otherwise conservatively assume p dgg 0 consider graph g figure 4 complete path g containing u g f u u else f f uu f f f 3 g u reject accept figure 5 example shows fullreachability algorithm edgeoptimal transition additionally contain transition therefore path p vertex reject reachable vertex aa g 00 dfs algorithm figure 2 easily modified compute reachability reject g 00 p must run test resulting overall running time ojej delta je j space complexity remains 44 validreachability algorithm edgeoptimal algorithm shown figure 5 fullreachability algorithm edge optimal consider path graph g igg 0 coverage g every path g covers exactly transitions igg 0 nonetheless projection e p onto g 00 yields graph reject reachable uu via path however notice path graph g includes transitions f first occurrence transition path must occur first occurrence f therefore paths p p must property since definition cover f ue set transitions path reject reachable g 00 includes ue include f path cannot p p ignored problem fullreachability algorithm considers paths p p reach reject g 00 refining notion reachability arrive edgeoptimal algorithm define partial order edges graph g follows containing edges e f first instance e p precedes first instance f p leave reader prove v indeed partial order antisymmetric transitive reflexive equivalent constructive definition v follows dominates f 8 f reachable e e reachable f v relation graph g figure 5 ue v v f validreachability algorithm based following observa tion path q contains transition f 2 e p contain transition e 2 e p e v f g path q prefix cannot member p p say path respect v validreachability algorithm first checks reject reachable 0 g 00 p igg 0 0 reachable algorithm computes r 00 set transitions g 00 reachable 0 reject reachable also computes projection r transitions onto g r subset e p e p contains edges e f e 62 r f 2 r e v f algorithm outputs p otherwise algorithm conservatively assumes p dgg 0 straightforward show validreachability algorithm safe following theorem shows also edgeoptimal theorem 3 given graphs g g 0 intersection graph g 00 p p igg 0 complete path p g either ffl reject reachable 0 p proof reject reachable g 00 done instead suppose reject reachable 0 g 00 furthermore assume f 2 r e given assumptions show complete path q e contradicting initial assumption paths edge coverage equal e p igg 0 two parts proof 1 show path q 1 g entry v covers transitions r respects v 8 edge e dominates edge f graph g every path f g contains e u g f u f f f g uu f f f 3 u u v2reject accept figure example crts algorithm based edge coverage cannot distinguish path igg 0 path dgg induces path g 00 reject 2 show path q 2 v x g covers transitions cover transition outside e p concatenation paths yields path q dgg 0 e existence path q 1 follows closure property r respect v f 2 r e 2 e p e v f e 2 r fact r projection r 00 transitions reject reachable 0 g 00 show existence path q 2 let e last edge path q 1 since e p edge coverage complete path p follows edges e f e p either f reachable e g via transitions e p e reachable f via transitions since path q 1 respects v also follows edges f cannot related v former case f reachable e via transitions e p latter case edges e f related v follows e f must reachable via transitions e p completing proof time complexity validreachability algorithm ojej delta j algorithm requires test construction g 00 p set r takes time ojej delta je 0 j dominating steps algorithm using extended version lengauertarjan immediate dominator algorithm 8 immediate v relation g computed nearlinear time space size g determine whether set edges r closed respect e p v requires following steps 1 projecting create v p oe operation 2 visiting immediate relation e v p f check e 62 r f 2 r two constanttime set membership operations performed immediate v p relation oe step takes oe time space complexity validreachability algorithm remains ojv j delta jv 0 j 5 crts using path coverage figure 6 shows crts algorithm based edge coverage forced make incorrect safe decision presents two programs graphs g g 0 intersection graph igg 0 path p g exactly set edges covered path dgg 0 thus impossible determine whether path igg produced edge set e p consider path profiling technique monsballlarus abl 2 applied graphs figure 6 separate paths p q abl algorithm decomposes control flow graph acyclic paths based backedges identified depthfirst search suppose v w backedge abl decomposition yields four classes paths 1 path x 2 path v ending backedge v w 3 path w v execution backedge v w ending execution backedge v w execution backedge v w path w x graph g backedge applying abl decomposition graph g figure 6 yields total four paths corresponding four types listed abl algorithm inserts instrumentation program p track whether four paths covered execution recall paths p q got edgebased crts trouble path p composed paths p 2 followed p 4 abl record two paths covered p executes hand path q composed p 2 followed p 3 followed p 4 thus example edge coverage could distinguish two paths abl path coverage mentioned introduction adversary create graph g 0 controlflowbased rts algorithm records less complete path executed g unable distinguish path igg 0 path dgg 0 true g contains cycles example example figure 6 defeat abl path coverage adding another ifthen conditional basic block outermost conditional program p 0 path igg 0 path occurs one time dgg 0 however paths cover exactly set distinguished unless longer paths tracked cutoff chosen add another level nesting achieve effect 6 related work rothermel harrold define framework comparing different regression test selection methods 11 based four characteristics ffl inclusiveness ability choose modification revealing tests paths dgg 0 ffl precision ability eliminate exclude tests reveal behavioral differences paths igg 0 ffl efficiency space time requirements method ffl generality applicability method different classes languages modifications etc approach shares many similarities rh algorithm three reachability algorithms based control flow analysis edge coverage partialreachability algorithm inclusive rh algorithm precise equivalent effi ciency fullreachability validreachability algorithms even precise greater cost yet considered generalize algorithms handle interprocedural control flow done rothermel shows problem determining whether new program modificationtraversing respect old program test pspacehard 10 intuitively problem involves tracing paths programs execute paths size exponential input program size worse course given complete path old program new program lineartime decision procedure determine new program contains path however defines away real problem size path un bounded considered best crts algorithm amount information recorded programs execution oe edge coverage exponential number edges abl path coverage summary formalized controlflowbased regression test selection using finite automata theory intersection graph partial reachability algorithm time space complexity equivalent best previously known algorithm precise ad dition defined strong optimality condition edgebased regression test selection algorithms demonstrated algorithm validreachability edgeoptimal finally considered path coverage used improve regression test selection crucial question practical relevance work hinges whether multiplyvisited vertex condition defined rothermel harrold occurs practice versions programs condition rh algorithm op timal condition occur shown rh algorithm even edgeoptimal plan analyze extensive version control repositories systems lucent 3 address question acknowledgements thanks mooly sagiv patrice godefroid suggestions pertaining finite state theory thanks also glenn bruns mary jean harrold gregg rothermel mike siff mark staskauskas peter mataga comments r exploiting hardware performance counters flow context sensitive profiling version control system could talk optimally profiling tracing pro grams incremental program testing using program dependence graphs system selective regression testing introduction automata ory fast algorithm finding dominators flow graph using data flow analysis regression testing efficient effective regression testing using safe test selection techniques analyzing regression test selection techniques tr compilers principles techniques tools incremental program testing using program dependence graphs optimally profiling tracing programs analyzing regression test selection techniques safe efficient regression test selection technique testtube exploiting hardware performance counters flow context sensitive profiling fast algorithm finding dominators flowgraph introduction automata theory languages computation efficient effective regression testing using safe test selection techniques ctr amitabh srivastava jay thiagarajan effectively prioritizing tests development environment acm sigsoft software engineering notes v27 n4 july 2002 guoqing xu regression tests selection technique aspectoriented programs proceedings 2nd workshop testing aspectoriented programs p1520 july 2020 2006 portland maine mary jean harrold gregg rothermel rui wu liu yi empirical investigation program spectra acm sigplan notices v33 n7 p8390 july 1998 alessandro orso nanjuan shi mary jean harrold scaling regression testing large software systems acm sigsoft software engineering notes v29 n6 november 2004 gregg rothermel roland j untch chengyun chu prioritizing test cases regression testing ieee transactions software engineering v27 n10 p929948 october 2001 mary jean harrold james jones tongyu li donglin liang alessandro orso maikel pennings saurabh sinha alexander spoon ashish gujarathi regression test selection java software acm sigplan notices v36 n11 p312326 11012001 gregg rothermel mary jean harrold empirical studies safe regression test selection technique ieee transactions software engineering v24 n6 p401419 june 1998 john bible gregg rothermel david rosenblum comparative study coarse finegrained safe regression testselection techniques acm transactions software engineering methodology tosem v10 n2 p149183 april 2001 mary jean harrold david rosenblum gregg rothermel elaine weyuker empirical studies prediction model regression test selection ieee transactions software engineering v27 n3 p248263 march 2001 jianjun zhao tao xie nan li towards regression test selection aspectj programs proceedings 2nd workshop testing aspectoriented programs p2126 july 2020 2006 portland maine guoqing xu atanas rountev regression test selection aspectj software proceedings 29th international conference software engineering p6574 may 2026 2007 nancy j wahl overview regression testing acm sigsoft software engineering notes v24 n1 p6973 jan 1999
methodology generating verified combinatorial circuits highlevel programming languages offer significant expressivity provide little guarantees resource use resourcebounded languages hardwaredescription languages provide strong guarantees runtime behavior computations often lack mechanisms allow programmers write structured modular reusable programs overcome basic tension language design recent work advocated use resourceaware programming rap languages take account natural distinction development platform deployment platform resourceconstrained softwarethis paper investigates use rap languages generation combinatorial circuits key challenge encounter rap approach safely admit mechanism express posteriori postgeneration optimizations paper proposes studies use abstract interpretation overcome problem approach illustrated using indepth analysis fast fourier transform fft generated computations comparable generated fftw b introduction hardware description languages primarily concerned resource use except highend applications verifying supported nsf itr0113569 putting multistage annotations work permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee september 2729 2004 pisa italy correctness hardware systems prohibitively expen sive contrast software languages primarily concerned issues expressivity safety clarity maintainability software languages provide abstraction mechanisms higherorder functions polymorphism general recursion abstraction mechanisms make designs maintainable reusable also keep programs close mathematical definitions algorithms implement helps ensuring correctness hardware description languages vhdl 16 verilog 32 provide limited support abstract mechanisms growing interest reconfigurable hardware invites us consider integration hardware software worlds consider verification techniques one world usefully applied currently programming reconfigurable hardware hard 3 first software developers typically trained design circuits second specifying circuits hand tedious error prone difficult maintain challenge integrating hardware software worlds summarized key question get raw performance hardware without giving expressivity clarity software 11 generators manifest interfaces recent work resourceaware programming rap 30 context software generation suggests promising approach hardware verification rather verifying circuits case bycase basis propose circuit designer express generic specifications automatically generate whole family cir cuits technical novelty approach generic specification verified guaranteed generated circuits correct approach naivelygenerated circuits correct construction efficient circuits correct produced systematic verified improvements correct naive generator verifying naive generator verifying posteriori postgeneration optimizations fix result generator verification point view means replace problem verifying transformations one verifying modifications one program generator classic example generators one used selesnick burrus 11 produce fast fourier transform fft circuits primenumbered sizes extensive survey found frigos account fftw system 8 writing using program generators however challenges cf 27 one challenge manifest interfaces generators hard express traditional type systems example strings algebraic datatypes parse trees even graphs used represent generated program would allow us express manifest interface type circuit type choose represent circuits soon start composing generators example want build circuit computes fft performs multipli cation computes inverse fft run prob lem type circuit provide static guarantees consistency wellformedness composite circuit illustrate assume given two trivial generators take inputs produce andgate inverter meaningless composition arises write connect operator infix operator type circuit circuit circuit wires output first circuit input second circuit problem second circuit one input two type system prevent error circuits type circuit generally desirable circuit type expressive possible time express values circuitrealizable example programmer might want use abstractions lists dynamic data structure describing circuit need know early possible development process uses realized using finite memory 10 30 12 resourceaware programming resourceaware programming rap languages 30 designed address problems described 1 providing highly expressive untyped substrate supporting features dynamic datastructures modules objects higherorder functions 2 allowing programmer express stage distinction computation development platform computation deployment platform convenient notation static type safety ensured using multistage programming msp constructs 29 28 3 using advanced static type systems ensure computations intended execution resourcebounded platforms indeed resourcebounded 30 31 combination three ingredients allows programmer use sophisticated abstraction mechanisms programs statically guaranteed generate resourcebounded programs example rather using one concrete type represent circuits rap languages provide abstract datatype parameterized information generated code type two trivial generators would type connect operator would refined code code code generic type variables must always instantiated consistently extra information type system reject bad declaration type variable cannot instantiated output inv bool input boolbool note type function similar type standard mathematical function composition operation addition ensuring generated programs well typed rap languages also ensure generated programs satisfy various notions resource constraints cf 30 13 problem ensure generated programs welltyped resourcebounded generated code type rap language must remain abstract providing constructs traversing values type jeopardizes soundness decidability static typing 27 complicates reasoning correctness programs written languages 28 time able look inside code means posteriori optimizations cannot expressed within language optimizations still implemented standalone sourcetosource transformations outside language invalidates safety resourceboundedness guarantees distinguish two forms posteriori optimizations generic ones independent application ones specific application generic optimizations generally welltested less likely invalidate guarantees provided rap setting domainspecific optimizations written programmer particular application less likely tested extensively therefore problematic time systems fftw make strong case practical importance domainspecific optimizations 8 therefore faced technical problem implement domainspecific optimizations without losing benefits rap framework contributions paper proposes use abstract interpretation 5 program generators avoid need posteriori optimization allows us generate desired circuits without losing guarantees provided rap languages benefits proposed technique extend untyped setting avoids generation large circuits first place thus reducing overall runtime needed generate acceptable code verification point view approach replaces problem verifying sourcetosource transformation verifying correctness finite set optimizations one specific program generator proposed method abstract interpretation carried four initial standard steps building program generators 27 1 implement inputoutput behavior expressive typesafe language ocaml 15 running example use fft fft step implementing cooleytukey recurrence computing fft 2 verify correctness inputoutput behavior program used expressive language implement fft step reduces making sure first textbook definition cooleytukey recurrence transcribed correctly second program correctly transformed monadic style monadic transformation welldefined mechanizable 21 paper explain monadic transformation style convenient using proposed approach often necessary convert whole program monadic style transformation done hand done needed 3 identify relevant computational stages program cf 27 involves determining parts computation done development platform must left deployment platform 4 add staging annotations step staging constructs hy gienic quasiquotations ensure done semantically transparent manner twolevel type system understands using quasiquotations generate programs cf 31 ensure inconsistent uses first secondstage inputs rap type system 30 goes ensure secondstage computations use features resources available target platform source code resulting generator often concise minor variation result first step quality generated code satisfactory paper proposes following additional step 5 use abstract interpretation techniques shift computations development platform rather deployment platform step generally leads smaller efficient circuits short term technology reduce time effort needed programming reconfigurable hardware reconfigurable hardware 6 17 potential delivering significant performance improvement computationally intensive application mains example najjar et al 22 report speedups 10800 times highlytuned software implementations rather performing numerically intensive kernels native software platform rest application implemented system offshores kernels fieldprogrammable gate arrays fpgas fieldprogrammable hardware wellsuited massivelyparallel implementations computations expressed combinatorial circuits longer term hope proposed approach positive impact vlsi logic design verification related work work builds long tradition using functional programming languages describe hardware circuits ruby 12 lava 2 hawk 14 hml 18 hydra 23 reflect 9 ever none languages provide kind manifest interfaces static types discussed hardwaredescription languages recognize need macros distinguish circuits descriptions circuits example sac 3 singleassignment arraybased language sa cs facility improvement c macro system provides neither expressivity higherorder languages manifest interfaces static guarantees delivered rap type systems mckay singh 19 use partial evaluation automated approach staging dynamic specialization fpgas specialization optimizations circuits use intensional analysis programs partial evaluation system user chose two levels abstraction either treat tool black box case control generation process delegated tool treat tool white box case wellformed correctness guarantees generated code void twolevel static type systems allow programmer safely gain full control generation process safl 26 allows programmer breakdown computation components implemented hardware software safl firstorder monomorphically typed language whole computation must resource bounded thus rap point view whole safl computation performed deployment platform hardwarec 13 similar safl uses clike imperative features 16 organization paper section 2 gives quick introduction basics staging explains basic approach context minimal example though static type system metaocaml checks type correctness circuitrealizability code sufficient present validate idea abstract interpretation code generators section 3 describes fast fourier transform expressed functional language staged section 4 describe generationtime optimizations optimizations enabled abstract interpretation generated code show effectiveness technique comparing number floating point operations results naively staged versions fftw systems section 5 concludes 2 abstract interpretation power staging constructs mechanism distinguishing computational stages program following minimal example illustrates use constructs metaocaml 4 20 let rec power n n0 1 else x power n1 x ignoring staging constructs brackets escapes e code standard definition function computes used define specialized function x 3 without staging last step simply returns function would invoke power function every time gets invoked value x contrast staged version builds function computes third power directly using multiplication see staging constructs work start last statement code whereas term fun x e x value annotated term fun x e outer brackets contain escaped expression still needs evaluated brackets mean want construct future stage computation escapes mean want perform immediate computation building bracketed computation multistage language constructs hints imperatives thus application e must performed even though x still uninstantiated symbol power ex ample power 3 performed immediately repeated every time new value x body definition function power recursive application power escaped ensure immediate execution first stage evaluating definition power3 first results fun x x x x 1 whereas implementing unstaged definition power3 hardware nontrivial staged one evaluates program clearly circuitrealizable 21 abstract give minimal example abstract interpretation generators useful consider presence multiplication 1 body power3 resorting posteriori techniques eliminating unnecessary computations code generated requires making code data type less abstract disadvantage voiding equational reasoning principles computation inside brackets 28 essentially reduces syntactic quotations cf 1 footnote 32 equally importantly ensuring static type safety would necessitate use higherorder types cf 25 abstract interpretation allows us avoid problems still achieve essentially result first step applying abstract interpretation identify concrete domain generally code type used pro gram would like look inside type generally implicit original program second step design abstract domain provides us information code value example use one int code type splits single case concretecode two first indicates information code value namely literal 1 second says additional information code value note terms concrete abstract may seem backwards abstract type approximates second stage value concrete type see abstract type contains information original type need present concretization function converts abstractcode concretecode let conc match c one 1 c c next step lift operators concrete type abstract type useful work done first stage less work left second stage operator power function uses multiplication operator achieve desired effect define corresponding abstract operator follows match xy one one one one x one x x conc x conc seen definition abstractcode type makes possible directly express optimizations would required inspecting concretecode type whereas concretization function expressed within language abstraction function would go way particular latter requires inspecting values abstract type code staged function expressed let rec power n n0 one else x power n1 x evaluating declaration fun x conc power 3 would yield precisely desired result fun x x x x last multiplication eliminated simple example abstract interpretation generated code provides systematic safe approach achieving essentially results posteriori optimization next two sections show scales substantial example fft yielding results comparable produced fftw system 3 staging fft fft finds applications many timecritical embedded applica tions therefore important able generate efficient circuits using fft running example paper section begins showing fft implemented purely functional manner ocaml metaocamls staging constructs used express variant function specialized respect size input vector 31 unstaged fft implementation basic cooleytukey recurrence implemented let rec fft dir l listlength l else l merge dir y0 y1 two parameters direction flag dir input vector l represented list input vector length one simply return otherwise split vector even odd components eo recursively apply fft subvectors merge results 32 complex numbers auxiliary functions complex numbers represented pairs ocaml floats operations complex addition implemented follows let add r1i1 r2 functions split merge used defining fft implemented follows let rec split l match l xyxs let rec merge dir l1 let rec mg l1 l2 match l1 l2 xxs yys zxa zyb function w computes powers nth complex root unity 33 monadic sharing avoid explosion size generated code use monadic library sharing 7 requires rewrite parts fft program monadic style explicit open recursion let fft dir f l listlength ret l else l bind f e fun y0 bind f fun y1 ret merge dir y0 y1 new parameter f used place recursive calls fft dir body original function return ret bind two standard monadic operators 21 33 get exactly functionality original program would use monadic library ret identity function noop bind passes result first argument second one details monadic library monadic sharing beyond scope paper described elsewhere 7 purposes paper reader view library avoids code duplication generation example fft merge functions need converted monadic style 34 staging fft stage fft respect size input vector add staging annotations get staged fft function fft ms staged function takes vector code values denote delayed elements since operation split parametric elements requires explicit staging merge function written monadic style change use staged versions complex arithmetic functions namely w add sub mult rets operator exactly ret operator used staged functions achieved adding staging annotations original ones example add function defined let adds r1i1 r2 let mergems dir l1 let rec mg l1 l2 match l1 l2 xxs yys bind rets mults ws dir n j fun z1 bind rets adds x z1fun zx bind rets subs x z1fun zy bind mg xs ys j1 fun ab rets zxa zyb rets bind mg l1 l2 rets b fft function uses staged monadic version merge let fftms dir f l listlength else l bind f e fun y0 bind f fun y1 mergems dir y0 y1 use fft ms passed monadic fixed point operator sm resulting monadic value passed appropriate monadic run combinator runm fun x run ysm fftms 10 2 n follows focus quality code generated computation improved use abstract interpretation generated code auxiliary functions nonstandard run construct see 7 allow metaocaml output c function code corresponding staged definition specialized size input vector preliminary syntax nonstandard run construct currently trxrun gcc gcc replaced names different backend compilers icc f90 input vector size 4 get following output result translating c int fundefdouble x234 double double double double double double double double x234 return 0 function fundef takes array four complex num bers realized array four pairs doubles two floatingpoint numbers pair represent real imaginary parts complex number respectively function computes fft inplace exit function input array contain computed transform code represents fully unfolded complex fft computation sample size 4 singleassignment straightline code easily translated combinatorial circuits 36 whats wrong generated code generated code points need domainspecific opti mizations suffers obvious problems include repeated computations 1 y1245 0 y2246 appear subexpressions larger expressions statements x1235x2340 assign array elements temporaries temporaries used also statements y1243x1235 kinds statements perform unnecessary moves trivial expensive floating point multiplication factors 10 00 roundoff errors result unnecessary computation multiplication 612303176911e17 exact 4 point fft contain factors exactly zero furthermore replacing factors exact zeros would lead cascade simplifications aggressive compiler optimizations might eliminate problems many ensuring eliminated requires knowledge fft algorithm note mean posteriori optimizations needed follows illustrate point show benefits focusing writing better generators rather fixing results simple generators 4 abstract interpretation fft use abstract interpretation series refinements generator show problems identified end last section addressed key feature modifications extract information secondstage generated computations make available first stage 41 abstraction domain want avoid code duplication want avoid trivial multiplications additions therefore need two abstraction domains stack one top domains successively refine float type used elements vector produced fft first domain exp float code keeps track whether code value cheap duplicate complicated expression tagged exp simple expression float literal example tagged val second domain lit float float maybevalue allows us construct complex arithmetic operators discriminate literals known generation time computations computations values unknown generation stage tagged value represents multiplication known factor keep factor floatingpoint datatypes analogous one discussed section 21 carry information code value must stress information fragment literal simple variable reference etc obtained looking inside code fragment rather make note information generate code fragment data available us generation time never look inside code generated elements types viewed sometimes exact approximations futurestage value note also abstract interpretation respect generated code fragment 42 abstract interpretation section 21 define concretization functions two abstract domains defined val x x exp x x any10x x any10x exp mvconc x anyfactorx exp factor mvconc x functions successively forget information result mvconc opaque code value information value generation stage forgotten function conc internalizes multiplication factor computation yields maybevalue 43 avoiding code duplication trivial bindings butterfly operation offers opportunity avoiding repeated computation operation represented following code snippet appears merge ms bind rets mults ws dir n j fun z1 bind rets adds x z1 fun zx bind rets subs x z1 fun zy multiplication mults ws dir n j used subsequent adds subs operations one might expect binding result value z1 avoids repeating com putation indeed case unstaged program staged program multiplication first line really symbolic z1 used two places computation duplicated already mentioned one technique avoiding forms code explosion monadic sharing 7 butterfly problem points need concise controlled way naming intermediate results generation avoid duplication expressions contain computations achieve defining variant monadic return operator names argument name gets duplicated call variant retn define appendix retn operates single values must deal tuples maybevalue domain represent complex number therefore raise retn work values type using function liftcm retn v defined appendix allows us generate name bindings exp variant avoid generation trivial bindings val variant resultant code merge operation shown let mergemv dir l1 let rec mg l1 l2 match l1 l2 xxs yys bind liftcm retnv x fun x bind liftcm retnv fun bind liftcm retnv fun z1 bind rets addsv x z1 fun zx bind rets subsv x z1 fun zy bind mg xs ys j1 fun ab rets zxa zyb rets bind mg l1 l2 rets b different merge ms function two ways first uses liftcm retn v instead rets wherever opportunity controlled naming expressions second uses complex arithmetic operators viz add sv sub sv mult sv w sv work maybevalue domain rather float domain add sv operator simple change staged add operator add let mvadd x let addsv r1i1 r2 mvadd r1 r2 mvadd i1 i2 generated code results form replacing merge ms merge mv fft ms function avoids duplication ex pressions also avoids generation names trivial expressions 44 avoiding trivial operations case multiplication function section 21 replace code type abstract domain type must lift staged complex arithmetic functions abstract domain essence means study operations defined different cases arise result using abstract interpretation abstract multiplication operator section 21 made use identity x avoid redundant computations generated code similarly use identities avoid unnecessary additions multiplications fft code example addition function add defined abstract domain abstract code use identity x avoid generation unnecessary addition operator function lit variant allows us discriminate zero values others thus perform case analysis given code fragment let rec adda n1 match n1 n2 x lit 00 x similarly know value pairs factors use information avoid generation unnecessary multiplications using identity f x code fragment fxx fyy fy fxmvadd x else case generate code addition mvadd x generate code multiplication common fac tor rather carry factor along multiplication factor generated needed excerpt illustrates information known annotations input fragments used set appropriate annotations output fragments never examine generated code addition operation add individual values used define addition operator complex values let addta r1 i1 r2 adda r1 r2 adda i1 i2 subtraction sub ta multiplication mul ta operators use abstract interpretation avoid generation trivial operations code similarly defined 45 avoiding roundoff errors factors fft algorithm roots unity order n n sample size n known generation time compute factors following function w computation returns result pair lit floatingpoint numbers representing one complex number let wa dir exp dir 2pi jn dir 1 expdir pi exp dir pi2 exp dir 3pi2 8j mod must odd cossigns 10 10 10 10 sinsigns 10 10 1010 else 3 quadrant lit csh cossigns quadrant lit csh sinsigns quadrant else floatofint 2 j pi floatofint n lit cos theta lit sin theta generate exact values possible eg cos exactly zero computing e 4 ensure real imaginary parts identical due specifics library trigonometric functions computed value cos identical computed value sin result successive refinements code function merge defined let mergea dir l1 let rec mg l1 l2 match l1 l2 xxs yys bind liftcm retnva x fun x bind liftcm retnva fun bind liftcm retnva multa wa dir n j fun z1 bind rets addta x z1 fun zx bind rets subta x z1 fun zy bind mg xs ys j1 fun ab rets zxa zyb rets bind mg l1 l2 stepwise refinement earlier merge mv function involves changing operators new operators viz retn va abstracts away sign factor performing name binding similar done retn v earlier mul ta add ta sub ta perform optimized complex arithmetic operations w generates exact float values possible change fft function use merge instead merge mv effect abstract interpretation code generation 46 generated code using staged fft function described generate code 4point fft yields following code int fundefdouble x382 double double double double double double return 0 code contains fewer operations present abstract interpretation problems pointed addressed fact code contains floatingpoint multiplications inspecting generated code 8point complex fft shows uses 4 floatingpoint multiplications 52 floatingpoint additions subtractions exactly number operations code generated fftw table figure 1 summarizes measurements effect abstract interpretation fft first column gives size fft input vector second column gives number floatingpoint multiplicationsadditions subtractions code resulting direct staging third column shows number multiplicationsadditions code resulting using abstract interpretation techniques staging last column shows number multiplicationsadditions code generated fftw various problem sizes table indicates generated fft circuits improved abstract interpretation abstract interpretation produces circuits almost floating point operations fftw 1 1 numbers fftw obtained codelets fftw codelets sample sizes 128 256 values estimates based values smaller sizes general fft algorithm size direct staging abst interp fftw 4 8 figure 1 number floatingpoint multiplicationsadditions fft transforms different sample sizes 5 conclusions proposed methodology writing generators produce family efficient combinatorial circuits building top rap languages programmer guaranteed generated program would welltyped circuitrealizable generator written expressive language easier ascertain correctness generator turn correctness full family generated circuits illustrated using staged memoization abstract interpretation makes possible refine generators series small modifications generate efficient circuits key feature methodology avoids adding constructs intensional analysis generated code ensures static welltypedness resource boundedness guarantees rap language pre served inability traverse generated code severely limits posteriori optimizations running example fft circuits shows abstract interpretation provides promising alternative approach allows us keep nextstage datatype abstract immediate goal future work see optimizations performed fftw achieved using abstract interpretation particular implementation presented performs obvious optimizations broadly interested developing monadic libraries support use abstract interpretation resourceaware programming 6 acknowledgments would like thank jason eckhardt stephan ellner roumen kaiabachev helpful comments 7 r structure interpretation computer programs hardware design haskell mapping single assignment programming language reconfigurable systems implementing multistage languages using asts abstract interpretation unified lattice model static analysis programs construction approximation fixpoints density advantage configurable computing monadic multistage programming fast fourier transform compiler reflective functional language hardware design theorem proving type system bounded space functional inplace update designing arithmetic circuits refinement ruby embedding microarchitectural design language within haskell objective caml seeking solutions configurable computing hml language highlevel design highfrequency circuits dynamic specialisation xc6200 fpgas partial evaluation metaocaml compiled notions computation monads integrating formal methods digital circuit design hydra oregon graduate institute technical reports emir pasalic higherlevel language hardware synthesis sound reduction semantics untyped cbn multistage computation gentle introduction multistage programming generating imperative environment classifiers verilog hardware description language comprehending monads tr comprehending monads notions computation monads fast fourier transform compiler embedding microarchitectural design language within haskell sound reduction semantics untyped cbn mutlistage computation theory metaml nontrival extended abstract mapping single assignment programming language reconfigurable systems abstract interpretation verilog hardware description language structure interpretation computer programs tagless staged interpreters typed languages environment classifiers seeking solutions configurable computing density advantage configurable computing type system bounded space functional inplace updateextended abstract higherlevel language hardware synthesis dynamic specialisation xc6200 fpgas parial evaluation designing arithmetic circuits refinement ruby hardwarec language hardware design version 20 multistage programming highlevel language abstraction reconfigurable computing implementing multistage languages using asts gensym reflection ctr christoph herrmann tobias langhammer combining partial evaluation staged interpretation implementation domainspecific languages science computer programming v62 n1 p4765 september 2006 edwin brady kevin hammond verified staged interpreter verified compiler proceedings 5th international conference generative programming component engineering october 2226 2006 portland oregon usa kedar swadi walid taha oleg kiselyov emir pasalic monadic approach avoiding code duplication staging memoized functions proceedings 2006 acm sigplan symposium partial evaluation semanticsbased program manipulation january 0910 2006 charleston south carolina jacques carette gaussian elimination case study efficient genericity metaocaml science computer programming v62 n1 p324 september 2006 albert cohen sbastien donadio mariajesus garzaran christoph herrmann oleg kiselyov david padua search program generator implement generic transformations highperformance computing science computer programming v62 n1 p2546 september 2006
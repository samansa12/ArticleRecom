codemotion pruning technique global scheduling highlevel synthesis asics code generation asips presence conditionals behavioral description represents obstacle exploit parallelism existing methods use greedy choices way search space limited applied heuristics example might miss opportunities optimize across basic block boundaries treating conditional execution propose constructive method allows generalized code motions scheduling code motion encoded form unified resourceconstrained optimization problem approach many alternative solutions constructed explored search algorithm optimal solutions kept search space method cope issues like speculative execution code duplication moreover tackle constraints imposed advance choice controller pipelinedcontrol delay limited branch capabilities underlying timing models support chaining multicycling tasking code motion account may lead larger search space codemotion pruning technique presented pruning proven keep optimal solutions search space cost functions terms schedule lengths b introduction highlevel synthesis applicationspecific integrated circuit asic code generation applicationspecific instruction set processor asip four main difficulties faced scheduling conditionals loops present behavioral description npcompleteness resourceconstrained scheduling problem 1 leave ineufsc brazil partially supported cnpq brazil fellowship award n 200283944 bthe limited parallelism operations within basic blocks available resources poorly utilized c possibility state explosion number control paths may explode presence conditionals dthe limited resource sharing mutually exclusive operations due late availability test results methods apply different heuristics subproblem basicblock scheduling code motion code size reduction independent heuristic used decide order operations scheduling like many flavors priority lists another decide whether particular code motion worth 1028 yet another reduction number states 31 result approaches might miss optimal solutions propose formulation 29 encode potential solutions interdependent subproblems formulation abstracts lineartime model allows us concentrate order operations availability resources different priority encodings used induce alternative solutions many solutions generated explored basic idea highquality solutions search space code motion speculative execution taken account since number explored solutions controlled parameters search method approach allows tradeoff accuracy search time approach code motions principle unrestricted although constrained available resources code motion typically leads larger search space envisaged technique reduce search time main contribution paper codemotion pruning technique technique first captures constraints imposed downward code motion constraints used criterion select efficient code motions show experimental evidence induced solution space higher density goodquality solutions codemotion pruning applied consequence given local search method number explored solutions application technique typically leads superior local optimum conversely smaller number solutions explored reach given schedule length correlates reduction search time paper organized follows section 2 formulate problem show representation survey existing methods tackle problem described section 3 approach summarized section 4 support global scheduling described section 5 section 6 show constraints imposed code motion captured explain codemotion pruning technique section 7 list main features approach experimental results summarized section 8 conclude paper section 9 remarks suggestions research proof codemotion pruning presented appendix 21 motivation conditionals present behavioral description introduce basic block bb structure instance description figure 1a four bbs depicted shadowed boxes figure i1 i9 represent inputs o1 o2 represent outputs x z local variables operations labeled small letters brackets bbs labeled capital letters i5 i6 else description b c0 1k l figure basic block structure assume adder subtracter comparator available could think scheduling independently nevertheless straightforward approach would efficient amount parallelism inside bb limited example bb adder would remain idle two cycles even though operation q bb l could scheduled step either k l example suggests exploit parallelism across bb boundaries allowing operations move one bb another called code motion operation q allowed move bb l bb cycle saved bb l note operation q always executed regardless result conditional c 1 hand operations n conditionally executed depending result conditional c 1 say operations n control dependent conditional c 1 however operation data dependent operation l could scheduled time step code motion violates control dependence executed evaluation conditional soon outcome c 1 known result either committed discarded technique called speculative execution result conditional turns true cycle saved general case may necessary insert extra code order clean outcome moved operation socalled compensation code example however compensation code needed variable z overwritten operation n consider moving operation q bb k executed parallel operation n however operation q must always executed operations bb k executed result c 1 false copy q placed end bb j result say code duplication takes place example duplication saves cycle result c 1 false impact different application domains controldominated applications normally require path optimized much possible role code motion obvious hand dsp applications unnecessary optimize beyond given global time constraint 20 although highly optimized code might imperative code motions overlooked even dsp applications reduce schedule length longest path consequently tighter constraints important code motions become early phases design flow optimization objectives dictated realtime requirements embedded systems design longest possible execution time piece code must still meet realtime constraints 6 fact motivates formulation problem terms schedule lengths see section 22 moreover early phases tend iterated several times runtime efficiency imperative often need fast accurate estimate terms schedule lengths 14 reasons motivate development technique prevent prune inefficient code motions see section 6 approach advantage taking code motions account bestowed expense much larger search space due codemotion pruning 22 formulation order define optimization problem represent specification data control depen dencies solution problem form graphs defined definition 1 control data flow graph e directed graph nodes represent operations edges represent dependencies assume cdfg special nodes represent conditional constructs example shown figure 1b description figure 1a circles represent operations triangles represent inputs outputs pentagonal nodes associated controlflow decisions branch node b distributes single value different operations merge node selects single value among different ones branch merge nodes controlled conditional whose result carried control edge dashed edge figure 1b detailed explanation symbols semantics found 9 definition 2 state machine graph directed graph nodes represent states edges represent state transitions smg seen skeleton state transition diagram underlying finite state machine whose formal definition found 7 keep track code motion use auxiliary graph condensation cdfg derived using depthfirst search defined definition 3 basic block control flow graph directed graph nodes represent basic blocks edges represent flow control operations cdfg enclosed pair branch merge nodes controlled conditional condensed form basic block bbcg branch merge nodes cdfg controlled conditional condensed single branch merge node bbcg domain input output nodes condensed single input output node instance bbcg depicted figure 1c explicitly shows bb structure description figure 1a circles represent basic blocks bb associated set operations cdfg bbcg domain branch node b represents control selection merge node represents data selection cdfg contains conditionals operations may execute different conditions execution condition operation group operations represented boolean function called predicate whose variables called guards 26 guard g k boolean variable associated output conditional c k description figure 1a conditional c 1 associated guard g 1 conse quence operations n execute predicates g 1 g 1 respectively operations enclosed bb execution condition path bbcg input output defines sequence bbs values guards data dependent taken path determined execution time set operations enclosed bbs given path called execution instance exi path bbcg corresponds exactly one exi cdfg let us formulate resourceconstrained problem addressed paper optimization problem op given number k functional units acyclic cdfg find smg dependencies cdfg obeyed resource constraints satisfied functional unit type function cost f l 1 l 2 l n minimized l schedule length th path bbcg f monotonically increasing function solution op said complete valid schedule exists every possible execution instance since conditional resource sharing affected timely availability guard values solution said causal guard value used time available feasible solution satisfy constraints must causal complete 31 previous highlevel synthesis approaches pathbased scheduling pbs 25 socalled asfastaspossible afap schedule found path independently provided fixed order operations chosen advance due fixed order fact scheduling cast clique covering problem interval graph code motions resulting speculative execution allowed original method recently extended release fixed order 3 reordering operations performed inside bbs reordering allowed across conditional operations would destruct notion interval foundation whole pbs technique consequently although reordering improves handling complex dataflow method cannot support speculative execution limits exploitation parallelism 7with complex control flow 19 limitation released treebased scheduling tbs 15 speculative execution allowed afap approach conserved keeping paths tree however since notion interval lost list scheduler used fill states operations condition vector list scheduling cvls 31 allows code duplication supports forms speculative execution although shown 27 underlying mutual exclusion representation limited approach would possibly remain valid extension original condition vector alternative representations suggested 1 27 hierarchical reduction approach hra presented 18 cdfg conditionals transformed equivalent cdfgwithout conditionals scheduled conventional scheduling algorithm code duplication allowed speculative execution supported 28 approach presented codemotions exploited first bbs scheduled using list scheduler sub sequently code motions allowed one priority function used bb scheduler another code motion code motion allowed inside windows containing bbs keep runtime low iterative improvement needed avoid restricting much kind code motions allowed among methods pbs exact solves partial problem speculative execution allowed tbs cvls address bb scheduling code motion simultaneously use classical list scheduler heuristics 28 different heuristic applied subproblem methods may exclude optimal solutions search space 26 exact symbolic technique presented never theless use exact method early iterative phases design flow unlikely especially pruning presented cope larger search space due code motion 32 previous approaches compiler arena tracescheduling ts 10 main path trace chosen scheduled first independently paths another trace chosen scheduled first resource unconstrained schedules produced heuristically mapped available resources ts allow certain types code motion across main trace downside ts maintracefirst heuristics workwell applications whose profiling shows highly predictable control flow eg numerical applications percolation scheduling ps 23 defines set semanticspreserving transformations convert program parallel one primitive transformation induces local code motion ps iterative neighborhood scheduling algorithm atomic transformations code motions combined permit exploration wider neighborhood heuristics used decide code motions worth priorities assigned transformations application directed first important part code important aspect ps primitive transformations potentially able expose available instructionlevel parallelism another system transformations presented 11 based notion regions controlequivalent bbs operations moved one region another application series primitive transforma tions original ps essentially resource constrained parallelization technique extended heuristic mapping idealized schedule available resources 2225 drawback heuristic mapping resources performed ts ps 22 25 greedy code motions undone 8 21 since accommodated within available resources efficient global resourceconstrained parallelization techniques reported 82130 whose key issue twophase scheduling scheme first set operations available scheduling computed globally heuristics used select best one among 8 global resourceconstrained percolation scheduling grcps technique described best operation selected actual scheduling takes place sequence ps primitive transformations allow operation migrate iteratively original final position global resourceconstrained selective scheduling gss technique presented 21 opposed grcps global code motion selected operation performed instead applying sequence local code motions results presented 21 give experimental evidence although ps gss achieves essentially results gss leads smaller parallelization time 33 contribution relates previous work one hand keep approach major achievements resourceconstrained scheduling recent years follows like global scheduling methods 82130 approach also adopts global computation available operations however implementation different since based cdfg unlike mentioned approaches bwe perform global code motions way similar 21 different 8 11 sequence primitive transformations applied hand distinguishes approach related work following formulation different mentioned methods respect order operations processed allow proper exploration alternative solutions use heuristicbased selection instead selection based priority encoding determined external therefore tunable search engine see section 4 bunlike resourceconstrained approaches 82130 provide support exploiting downward code motion see section 61 c main contribution new codemotion pruning technique takes constraints imposed code motion account prevents inefficient code motions see section 62 envisage approach restriction imposed beforehand neither kind code motion order operations selected scheduled section introduce constructive approach free restrictions outline approach shown figure 2 solutions encoded permutation operations cdfg solution explorer creates permutations solution constructor builds solution permutation evaluates cost explorer based local search algorithm 24 selects solution lowest cost building solu tion constructor needs check many times conditional resource sharing tests modeled boolean queries directed socalled boolean oracle term coined 4 allows us abstract way queries implemented detailed view explorer scope paper way permutations generated according criteria given local search algorithm found 13 focus solution constructor constructor cost explorer boolean oracle figure outline approach keep highquality solutions search space designed constructor following properties hold first neither greedy choices made restrictions imposed code motion see sections 52 74 second pruning used discard lowquality solutions preventing generation solutions certainly lead lower cost see section 62 third every permutation generates complete causal solution see section 73 although method ensure optimal solution always reached consequence localsearch formulation least one optimal solution kept search space proofs claim found appendix 13 general method allows trade cpu time solution quality practice implemented method succeeds finding optimal solution short cpu times tested benchmarks see section 8 51 supporting code motion speculative execution use predicates model conditional execution operations based timely availability guard values distinguish two kinds predicates predicate g said static represents execution condition operation values guards available dynamic predicate represents execution condition operation one guard values may available given time step note static predicate abstracts relative position time completion conditional execution controldependent operation predicates used keep track code motions used check conditional resource sharing g used check whether result speculatively executed operation committed assume operation moves bb bb j let g g j static predicates bbs j respectively product g j gives static predicate operation figure 1 instance operation q duplicated bbs j k copy q bb j executes copy q bb k executes code motion may lead speculative execution gmay represent actual execution condition guard value may timely available new predicate must computed dropping consideration guards whose values available observe necessary prevent speculative execution might lead noncausal solutions figure 1 instance static predicate operation moves bb j bb operation speculatively executed bb actual execution condition given dynamic predicate inside new bb always executed note dynamic predicate condition result produced static predicate g condition result committed algorithm shows obtain dynamic predicate predicate g given time step endc k stands completion time conditional c k assume time slot 0 functions support smooth represent concepts boolean algebra definitions found 7 dynamicpredicateg step slot foreach algorithm 1 evaluation dynamic predicate conditional resource sharing construction solution need check two operations share resource different execution conditions let j denote two operations operations share resource given time step identity j 0 holds boolean oracle used answer query well compute predicates 52 scheduler engine solution constructor takes permutation explorer generates solution construc tor borrow techniques constructive topologicalpermutation scheduler 13 schedule constructed permutation follows scheduler selects operations scheduled one one instant first ready operation unscheduled operation whose predecessors scheduled permutation selected selected operation scheduled earliest time free resource available 13 proven optimum schedule always among created principle topologicalpermutation construction c e b f g c c f f f e f schedule time steps scheduling evolution c f else e description c figure using topological permutation scheduler figure 3 shown lineartime sequence constructed topological permutation scheduler given behavioral description cdfg shown figures 3a 3b utilization resources modeled placing operations entries resource utilization vector ruv shown figure 3a entry ruv different functional unit first apply scheduler without paying attention mutual exclusion show principle see figure 3c second experiment apply mutual exclusion case operation b scheduled second step sharing adder operation c see figure 3d assume outcome available inside first step allow b conditionally share resource resulting schedule length reduced 5 steps exis note however could scheduled two steps thus information mutual exclusion clearly enough limitation lineartime model allow efficient solution mechanism split lineartime sequence exposing flow control mechanism based additional information extracted cdfg explain next section 6 method prune inefficient code motions 61 capturing encoding freedom code motion method want capture freedom code motion without restrictions purpose introduce notion link link connects operation u cdfg bb v bbcg given following interpretation operation u executed predicate defines execution operations bb v operation linked several mutually exclusive bbs may belong many execution instances figure 4 illustrates link concept else e description b figure link concept initial links encode freedom code motion using set initial links given operation initial link points latest bb given path operation still executed initial links obtained follows first look socalled terminal operations terminal either direct predecessor output node direct predecessor branch merge node whose result must available control selection data selection figure 4 conditional terminal result conditional must always available control selection takes place even though operations b direct predecessors branch nodes terminals affect control selection operations c terminals results must available prior data selection operation e obviously terminal terminal attached branch merge output node cdfg linked bb precedes corresponding branch merge output node bbcg figure 4 initial links shown terminals c due data selection due control selection e due output afterwards link non terminal operations predecessor terminal linked bb latter linked operation initial links shown figure bb b bb c operation b single initial link pointing bb c initial links interpreted follows conditional must executed latest bb result must available control selection branch operation c must executed latest bb b operation latest bb c results must available prior selection merge note initial link encodes freedom code motion downwards means operation free executed inside preceding bb path soon data precedence resource constraints allow control dependency satisfied need execute operation latest inside bb pointed initial linkthe underlying idea traverse bbcg topological order trying schedule operations visited bb even operation originally belong observe operation u given initial link bb v v reached traversal u must scheduled inside bb v say assignment operation u bb v compulsory equivalently operation u compulsory bb v notion compulsory assignment operations allows us identify control dependencies violated also notion one keys pruning technique shown next subsection final assignments link called final operation assignment called simply assignment scheduling respective operation inside pointed bb obeys precedence constraints imply need available functional units assignments might increase registers andor interconnect usage included search space assignment operation u bb v given following attributes begin starting time operation u inside completion time operation u inside bb v c g static predicate dynamic predi cate note assignments represent relativetime encoding absolute time controldependent given instant bb v starts executing plus value attribute begin handling redundancies operations may redundant paths behavioral description shown 15 method redundancies eliminated generation initial links operation b figure 4 instance linked bb c even though originally described bb belonged paths tbs 15 uses tree optimization remove redundancies propagating operation latest bb used cvls 31 eliminates using extended condition vectors even though remove redundancies methods care encoding freedom code motion properly code motion determined heuristicbased priority function anyway example order cast controlflow graph tree structure tbs duplicates operations bbs succeeding merge nodes consequence priori duplication tbs looses information freedom code motion due data selection information could used construction solution avoid inefficient code duplication b c e f else e description bbcg b figure linking unconditional operations freedom code motion initial links eliminate redundancies also encode freedom code motion figure 5 f may linked bb bb c bb b bb initial link control dependency satisfied f must execute output available operation f executed bb preceding bb soon resource data dependency constraints satisfied unrestricted code motions exploited 62 codemotion pruning traversing topological order solution constructor follows flow tokens cdfgwhile bbcg traversed topological order operation assigned traversed bb soon data precedence resource constraints allow first ready operation permutation attempted scheduled inside visited bb notice traversal operation may ready given exi another figure 3d instance operation g ready third time step fifth step exi e f g reason say operation ready predicate g given bb operation ready belongs path contains bb given initial link u v assignment operation bb visited compulsory long bb v reached bb v reached traversal u scheduled inside bb v initial link become final assignment however operation u succeeds scheduled inside ancestor w bb v inducing code motion initial link revoked replaced final assignment operations attempted scheduled inside traversed bb according criteria criterion 1 codemotion pruning let operation initial link pointing bb j ready predicate g visited bb ij schedule would require allocation exactly delayo extra time steps accommodate execution operation scheduled inside bb preventing code motion bb j bb criterion 2 constructive scheduling visited bb predicate g first operation ready predicate g rejected criterion 1 scheduled earliest time inside bb claim application criteria 1 2 discard better solutions optimization problem defined section 2 see proofs 13 appendix splitting lineartime sequence note operation allowed allocate extra time steps accommodate execution inside visited bb assignment bb compulsory j make space scheduling noncompulsory operations idle resources ready operation satisfies criterion 1 constructor stops scheduling bb another bb visited observe resulting global schedule lineartime sequence instead sequence split time traversal crosses branch flow control kept exposed criterion 1 responsible splitting lineartime sequence decides stop scheduling bb prior control data selection note decision based constraints resource constraints control data dependencies counterexample heuristic criterion used tbs lineartime sequence split time conditional turns operation higher priority ready queue 15 example figure 6 example used figure 3 scheduled illustrate method first show figure 6b exi would scheduled independently applying topological permutation scheduler note exi e f g scheduled five steps exi g scheduled 2 steps yet possible overlap sequences b cannot share adder b 0 outcome conditional available inside first step tentative solution would noncausal consequence infeasible even though path afap scheduled given conflict one sequence chosen imposed extra step show constructor generates feasible solution figure 6c initial links depicted figures 6d 6k evolution construction process shown operation circles bold mark current bb traversed notice figure 6d even though ready operations e b precede scheduled one operation rejected criterion 1 compulsory current bb scheduled figure 6e step idle adder exists point ready operations scheduled bb would require allocation extra steps criterion 1 another bb taken figure 6f figure 6k shows final result obtained scheduling exi 1 independently figure 6b exi 2 needs extra step note b exchanged solution figure 5b would obtained exi 1 would need extra step conflict happens paths method solves certain way induced exists another permutation induces another solution conflict solved opposite way limitation search space observe assignment operations b first step represents speculative execution allow speculative execution exis need extra step resulting schedule lengths 3 6 c e b f g b f b f c e f c e c e c f e c e c f b c e f g c c c c c c c f figure splitting lineartime sequence notion order dominant notion time step opposed approaches 3118 method use time primary issue decide position operation instead notion order availability resources used assignments incorporate relativetime encoding time used manage resource utilization inside bbs c j unscheduledscheduledpreds asap annotate algorithm 2 solution constructor solution constructor summarized algorithm 2 permutation c set bbs u operation v bb assignment starting time operation u inside bb v function returns bbs arbitrary topological order candidate assignment created pair uv condition unscheduled scheduledpreds evaluated condition holds earliest step bb v free resource found function issuitable decides whether candidate assignment committed revoked checking criterion 1 compulsory operations scheduled room scheduling others new bb taken function solvecodemotion inserts compensation code duplication succeeds runtime complexity let n number operations b number bbs p number paths c number conditionals ready operations kept heap data structure search first ready operation takes olog n search may repeated operation bb worst case complexity algorithm 2 ob n log n runtime efficiency approach depend p grow exponentially c opposed pathbased methods wewill illustrate application codemotion pruning discard better solution goal provide outline proof appendix original solution induced permutation try construct better solution n figures 7 8 operations 1 4 additions 1 3 subtractions 1 multiplication assume one resource type grey entry utilization vector ruv means either resource occupied operation occupied due data dependency grey fields used abstract operations concentrate certain scope figures 7a 8a show different solutions generated constructor means constructed following criterion 1 example operation 1 scheduled inside bb must prevented scheduled p note empty fields mean operations could scheduled idle resources due data dependencies solution wewill construct new solution n shown figures 7b 8b allowing 1 boost bb pwhere allocates exactly steps make room operations bbs move wewill consider two different scenarios code motion show 1 allowed boost bb p better result would reached terms schedule lengths 4 1 2 3 b r 1 2 3 4 r a4 a1 a2 a3 figure first scenario figure 7 assume operation 4 move bb r allocated steps notice even though a4 precedes a1 a2 permutation a4 could scheduled time step either s1 s2 figure 7b possible original solution means scheduler engine must detected data dependencies moreover 3 could moved steps allocated bb p result number steps freed number allocated steps path shortened note figure 7 even though optimistically assumed boosted operations completely freed steps moved better solution could reached figure 8 illustrate case path p q r shortened possible operation a4 moved first step bb p filled entry occupied operations figure 8b notice s1 scheduled time step a4 however possible indicated empty field first step bb q figure 8a means scheduler detected data dependency data dependency violated code motion solution n infeasible 2 4 1 b r 1 2 4 r a4 a1 a2 a3 figure examples suggest given permutation possible obtain feasible solution shorter paths solution generated solution constructor feasible solutions could obtained best good constructed one underlying idea illustrated instead allowing arbitrary code motions generated topologicalpermutation scheduler engine solutions criterion 1 obeyed constructed leads notion codemotion pruning since application criterion 1 prune better solutions appendix topologi 2calpermutation construction guarantees least one permutation returns optimal schedule length 13 conclude codemotion pruning keeps least one optimal solution search space section summarizes main features approach organized follows first two subsections show howwe support constraints imposed advance choice controller third subsection explains method generates complete causal solutions last subsection describes types code motions supported approach 71 supporting pipelinedcontrol delay shown 17 approaches found literature assume fixed controller architecture would produce infeasible solutions different controller architectures one constraints limited branch capability controllers see next subsection another imposed pipelining controller pipeline registers used reduce critical path controller data path 16 delay time step conditional executed time step guard value allowed influence data path guard value available within time slot completion respective conditional figure 9a illustrates effect pipelinedcontrol delay assume single adder pipelinedcontrol delay 2 cycles value guard g 1 available executed early enough shown figure c delay slot b c g 1 b figure 9 effect pipelinedcontrol delay algorithm 1 considers effect delay slot illustrate application figure 9b static dynamic predicates shown operations e conditionally share adder also operations grey speculatively executed respect conditional c 2 example emphasizes importance speculative execution fill time slots introduced pipeline latency 72 supporting limited branch capability simple controllers used eg sake retargetable microcode state transitions underlying fsm limited branch capability chosen controller figure illustrates problem figure 10a show static predicates operations example two different schedules presented figures 10b 10c 1 comparator 1 white resource 1 grey resource available g l b c b b figure effect limited branch capability schedule figure 10b implicitly assumes 4way branch capability shown state machine graph delay execution conditional c 2 one cycle obtain schedule figure 10c requires 2way branch capability n 1 n 2 represent duplication operation n observe operation n share white resource operation l path taken instead path must delayed one cycle makes overall schedule length figure 10c longer figure 10b suggested example method handle limited branch capabilities building solutions controller limits branch capability value k k2 n constructor allow n conditionals time step similar technique presented 16 73 generating complete causal solutions subsection first show methods deal causality completeness illustrate next method generates causal complete solutions pathbased approaches 5 completeness guaranteed finding schedule every path overlapping singlerepresentative solution given operation controldependent conditional causality guaranteed preventing operation executed prior c k however leads limitation model speculative execution allowed symbolic method 26 accommodate overhead trace validation algorithm required ensure completeness causality scheduled traces selected coexist without conflict executable solution method completeness guaranteed traversal bbs predicates g associated bbs investigated makes sure possible execution conditions covered without need enumerate paths causality guaranteed usage dynamic predicates checking conditional resource sharing test performed construction solution time first ready operation attempts use already occupied resource illustrate fact revisit example 26 potential solution generated symbolic technique 26 shown figure 11b cdfg 11a resource type black grey white assumed labels duplication operation n solution complete exi scheduled resource precedence constraints satisfied however solution causal decided whether k 1 n 2 executed value g 1 available first step figures 11c 11d method used construct two solutions two different permutations operations k figure 11c well operations n figure 11d prevented scheduled step checking conditional resource sharing observe g k gm1 0 k m1 0 also g g c l l g g 1 l l figure causality construction approach perform trace validation procedure posteriori like 26 test similar effect done incrementally construction solution described scheduling one operation method evaluates dynamic predicates updates conditional resource sharing information new operation processed new operation detected conflict trace previously scheduled operation scheduling new operation postponed later time step namely earliest time step wherein conflict occur anymore dynamic evaluation predicates combined constructive nature schedules peroperation basis advantage preventing construction noncausal solutions like figure 11b avoids enumeration backtracking infeasible solutions 74 exploiting generalized code motions subsection summarize relationship initial links final assignments code motions detailed analysis code motions found 28 b c duplicationup boostingup unification useful figure motions basic code motions figure 12 illustrates code motions scope single conditional f represents final assignment initial link circle bold represents current bb traversed figure 12a operation initially linked bb assigned bb b via f motion requires code compensation performed inserting assignment f result code duplication takes place figure 12b operation moved across branch node called boostingup may lead speculative execution figure 12c operation initially linked different mutually exclusive bbs succeeds scheduled bb leading unification initial links final assignment finally figure 12d operation moved bbs execution condition called useful code motion even though upward motions explicitly shown downward motions implicitly supported method initial links encode maximal freedom code motions downwards generalized code motions figure 13 shows generalized code motions supported approach arrows indicate possible upward motions origin bb destination bb gray circles illustrate local code motions handled methods either correspond basic code motions figure 12 combinations 28 combinations attempted via iterative improvement inside windows containing bbs black circles illustrate global code motions also supported method note compound motions determined permutation result successive application basic code motions opposed ps 23 search best code motions inside solution search best solution whose underlying code motions induce best overall cost assignment determined permutation may induce code motion unrestricted types code motions possible result search space limited restriction nature amount scope code motions figure generalized code motions nevertheless fact generalized code motions allowed sufficient guarantee generation highquality solutions constraints exploited order avoid generation inferior solutions performed pruning technique described section 62 whose impact shown experiments reported next subsection method implemented neat system 12 using bdd package developed geert janssen boolean oracle current implementation genetic algorithm used explorer table example waka b c 447 347 346 table 1 method compared others example 31 resource constraints adopted chaining shown top table results given shadowed row terms schedule length path solution case good tbs hra 18 case b method tbs hra reach results better pbs case c method tbs better hra pbs experiments summarized following two tables search performed several randomly chosen seeds used generate random populations explorer cpu means average search time seconds using hp9000735 workstation table benchmarks without controller constraints b b table 2 compare results heuristic methods tbs cvls hra one exact method st top table show resource constraints benchmark results shown shadowed row results methods assembled bottom result schedule length longest path shown average schedule length assuming equal branch probabili ties indicated parenthesis note method reach best published results better average schedule length 200 found benchmark parkerb noticed exact method presented 26 guarantee optimality respect schedule length longest path function schedule lengths paths first indication method highquality solutions search space broader class cost functions table 3 show results benchmarks pipelinedcontrol delay constraint approach reach schedule lengths obtained exact method described 26 using currently localsearch algorithm explorer guarantee optimality spite optimal solutions reached cases within competitive cpu times although certainly need perform experiments first results encouraging seem confirm method able find code motions induce better solutions table benchmarks pipelinedcontrol delay rotor 26 b c e f g h latency alu 1cycle alu mult 2cycle pipel multiplier speculative execution allowed also performed experiment evaluate impact codemotion pruning search space order compare sample search space without pruning fifty permutations generated randomly respective solutions constructed first comparison counted number solutions distinguishing based overall cost value figure 14 shows results black without pruning gray height bar represents number solutions counted different cost values waka1 maha1 used cost used waka2 maha2 example waka2 13 different solutions identified without pruning 4 pruning reduction explained fact pruning applied permutations mapped cost another words density solutions cost increases codemotion pruning figure reduction number solutions second comparison performed looking maximal minimal cost values observed maximal cost values closer minimum pruning applied difference maximal minimal cost values called cost range compaction cost ranges shown figure 15 normalized respect pruning case cost range ratio prun ingno pruning 04 waka1 maha1 029 waka2 065 maha2 figure compaction cost range density solutions cost increases figure 14 simultaneously maximal cost closer minimum figure 15 conclude density highquality solutions increase codemotion pruning fact suggests higher probability reaching near optimal solutions exploration whichever choice localsearch algorithm might finally performed experiments larger benchmark presented previous tables benchmark s2r whose cdfg 100 nodes borrowed 26 used different sets resource constraints depicted cases h first rows table 4 compare search spaces without pruning 500 permutations generated randomly respective solutions constructed procedure repeated several randomly chosen seeds accurate average values could evaluated experiments performed first without codemotion pruning enabling sequence permutations used induce solutions cases figure compaction cost range benchmark s2r first measured cost ranges set resource constraints summarized figure 16 normalized respect pruning case note cost ranges reduced least 70 pruning enabled second counted number solutions hit optimum latency evaluated average percentage respect total number solutions percentage represents average density optimal solutions search space presented shadowed rows table 4 nopru pru stand pruning pruning respectively results show code motion pruning increases density highquality solutions search space also show tighter resource constraints impact codemotion pruning results interpreted follows resources scarce cases b e f small fraction potential parallelism accommodated within available resources consequence code motions pruned since would inefficient hand resources abundant like cases c g h potential parallelism accommodated available resources need prune code motions contribute construction highquality solutions table impact codemotion pruning density optima s2r 26 b c e f g h resources latency density nopru 1 1 41 45 1 2 31 34 density pru 41 16 62 62 25 16 45 45 cpu nopru 26 17 09 09 24 17 17 14 cpu alu 1cycle alu mult 2cycle pipel multiplier singleport lookup table since synthesis asics code generation asips want use resources possible likely observe practice huge unbalance potential parallelism exploitable parallelism constrained available resources fact justifies use codemotion pruning technique order compare impact different densities optima search time also measured average time reach given optimum emulated kind random search optimal latencies shown table 4 average search times reported entry cpu results show codemotion pruning leads substantial improvement search time tight resource constraints 9 conclusions future work paper shows scheduling code motion treated unified problem optimal solutions kept search space problem approached point view optimization process construction solution independent exploration alternatives shown permutation used induce unrestricted code motions presence optimal solutions search space guaranteed better control construction procedure shown pruning technique ease optimization process exploiting constraints since control dependencies represent obstacles exploit parallelism might induced violate often possible however conclude control dependencies also exploited combination resource constraints data dependencies order detect prevent inefficient code motions way cast problem experimental results allow us conclude codemotion pruning increases density highquality solutions search space even though paper focuses problem related early phases design flow constructive method accommodate extensions many alternative solutions generated possible extend constructor keep track issues like register interconnect usage number states issues could captured cost function convenient especially late phases design flow optimization take several design issues account future work intend cast loop pipelining constructive approach loops could easily supported method simple extensions modeled conditionals loops could broken scheduling back edges could restored later state machine graph like 5 15 however extensions would allow exploitation parallelism across different iteration loop reason prefer investigate loops topic proof pruning technique theoremlets solution optimization problem described section 22 assume constructed algorithm 2 given let operation assigned bb j let delayo solution n obtained moving bb j bb allocates exactly extra cycle steps accommodate execution proof let lk lk schedule lengths bb k motion respectively let p q r bbs forming path respectively schedule lengths path p n motion assigned q allocates steps inside p lplp assigned r moved allocated steps a2 operation u assigned r moved allocated steps u depends resource conflicts operations assigned q topological permutation construction assigned r allocates steps inside q c assigned r allocates steps inside p depend resource conflicts operations assigned q topological permutation given solution n path lengths greater equal generalized code motions seen compound code motions built basic code motions cost monotonically increasing conclude without loss generality costs n r functional synthesis digital systems tass area performance optimizations path based scheduling controlflow versus dataflowbased scheduling combining approaches adaptive scheduling system efficient orthonormality testing synthesis passtransistor selectors pathbased scheduling synthesis embedded system design synthesis optimization digital circuits global resourceconstrained parallelization technique data flow exchange standard trace scheduling technique global microcode compaction region scheduling anapproach detecting redistributing parallelism neat object oriented high level synthesis interface application genetic algorithms highlevel synthesis pathbased technique estimating hardware runtime hwswcosynthesis treebased scheduling algorithm control dominated circuits unified scheduling model highlevel synthesis code generation global scheduling highlevel synthesis code generation embedded processors scheduling algorithm conditional resource sharing hierarchical reduction approach limits control flow parallelism time constrained code compaction dsps efficient resourceconstrained global scheduling technique superscalar vliw processors making compactionbased parallelization affordable uniform parallelism exploitation ordinary programs algorithms complexity percolation based synthesis new symbolic technique control dependent scheduling representing conditional branches highlevel synthesis applications global scheduling codemotions highlevel synthesis applications constructive method exploiting code motion efficient superscalar performance boosting resource sharing control synthesis method conditional branches global scheduling independent control dependencies based condition vectors tr combinatorial optimization algorithms complexity region scheduling global scheduling independent control dependencies based condition vectors representing conditional branches highlevel synthesis applications percolation based synthesis limits control flow parallelism efficient superscalar performance boosting efficient resourceconstrained global scheduling technique superscalar vliw processors treebased scheduling algorithm controldominated circuits global scheduling codemotions highlevel synthesis applications timeconstrained code compaction dsps pathbased technique estimating hardware runtime hwswcosynthesis efficient orthonormality testing synthesis passtransistor selectors embedded system design controlflow versus dataflowbased scheduling italicglobalitalic resourceconstrained parallelization technique synthesis optimization digital circuits making compactionbased parallelization affordable unified scheduling model highlevel synthesis code generation constructive method exploiting code motion area performance optimizations pathbased scheduling ctr aravind vijayakumar f brewer weighted control scheduling proceedings 2005 ieeeacm international conference computeraided design p777783 november 0610 2005 san jose ca steve haynal forrest brewer automatabased symbolic scheduling looping dfgs ieee transactions computers v50 n3 p250267 march 2001 apostolos kountouris christophe wolinski efficient scheduling conditional behaviors highlevel synthesis acm transactions design automation electronic systems todaes v7 n3 p380412 july 2002
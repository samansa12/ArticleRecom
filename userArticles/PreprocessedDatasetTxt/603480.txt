formal model expressive fragment xslt extension extensible style sheet language xsl variables passing data values template rules generated powerful xml query language extensible style sheet language transformations xslt informal introduction xstl given bases formal model fragment xslt defined formal model spirit tree transducers semantics defined rewrite relations shown expressive power fragment already beyond xml query languages finally important properties termination closure composition considered b introduction xsl 6 current w3c 8 proposal xml extensible stylesheet lan guage original primary role allow users write transformations xml html thus describing presentation xml documents nowadays many people use xsl basic tool xml xml transformations renders xsl xml query language noted database community 9 1 though transformations xsl express rather limited instance xsl joins skolemfunctions hence cannot sophisticated grouping output data words xsl lacks basic property query language relationally com plete however language still development features changed time recently various extensions added language 7 apparent ones addition variables parameter passing template rules show additions together use modes actually states used nite state machines already dened earlier versions xsl render xsl powerful query language indeed xsl becomes relationally complete explicit grouping without skolem functions simulate regular path expressions simulate current xml query languages work author supported ec tmr network getgrats research assistant fund scientic research flanders work partly performed visiting university california san diego contact author submission actually together addition new features xsl split two parts xsl transformations xslt 7 xpath 5 latter contains description xsls associated pattern language former denes real transformation language emphasize focusing transformation part new features refer xsl xslt rest paper main source denition xslt specication 7 bit dicult read especially one wants impression language works capable remedy dene abstract formal model xslt incorporating features necessary simulate say xmlql purpose model twofold clean formal semantics provides necessary mathematical model studying properties xslt ii formal model abstracts away actual syntax xslt emphasizes features way interested reader get feeling language capable next use model gain insight xslt first obtain xslt compute unary monadic secondorder mso structural properties brief mso rstorder logic fo extended set quantication expressive versatile logic trees instance captures many robust formalisms like regular tree languages 25 query automata 20 nite valued attribute grammars 22 moreover mso take inherent order children vertices account desirable property xml pattern languages 13 24 structural patterns mean mso without joins cannot check whether values two attributes see section 4 details fact neven schwentick 19 showed already wrt structural patterns mso expressive fo extended various kinds regular path expressions thus current xml query languages based fo extended regular path expressions already indicates xslt cannot simulated say xmlql next show xslt simulate existing xml query languages study decidability type checking milo suciu vianu 16 dened k pebble treetransducer formalism capturing expressiveness existing query languages including xmlql 9 xql 23 lorel 2 struql 14 unql 4 previous version xsl model take value equation account needed joins instance easily modied obtain xslt simulate model thereby establishing xslt expressive concrete simulations refer interested reader 3 show xmlql queries 9 expressed actual xslt want emphasize provide model xslt instance excluded forloops variables instantiated data values result tree fragments idea want use variables lookahead fetch data values occurring far current node resulting language hence turing complete hopefully ecient evaluate study properties formal model however beyond scope present paper important fact dened language expressive say xmlql opposed previous version xsl 9 1 1 rest paper structured follows section 2 introduce important features xslt means two examples section 3 dene formal model finally section 4 obtain expressibility results 2 xslt example basic xslt program collection template rules rule consists matching pattern mode indicates nite state computation template see example program figure 2 computation document starts root starting mode 2 proceeds roughly follows computation arrives node say u certain mode say q program tries nd template rule mode q whose matching pattern matches u 3 nds template rule program executes corresponding template latter usually instructs xslt produce xml output various positions xml output selects lists nodes processing refer patterns select nodes processing selecting patterns selected nodes processed independently finally documents constructed subprocesses inserted positions subprocesses generated illustrate new features xslt use dtd figure 1 describes organization sequence groups together list top managers group id consists manager list groups consists list employees simplicity identify employees id xslt program figure 2 computes pairs employees top manager dierent bill direct indirect manager e 2 pairs encoded simply pair element attributes topmgrid employeeid face program makes join list top managers group managers ones occurring top manager list ones occurring manager group however rather direct procedural way brief xslt program starts applying rst template rule root mode start rule selects top manager mode selecttopmgr particular pattern organizationtopmgremployee matched current node previous work dened formal model version xsl incorporating data values 15 actually modes optional convenience assume every template one start mode 3 usually examples matching pattern refers label current node fact show section 4 patterns suce organization element organization group topmgrs element topmgrs employee element group mgr group employee element mgr employee attlist group id id required fig 1 dtd describing organization labeled organization selects employee children topmgr children means child selected employee mode selecttopmgr second template rule applied stores employees id say e variable varid veries using latter whether e 1 dierent bill selects descendants group manager id e 1 mode display particular selection pattern second template rule says select employees descendants group child group whose manager id one stored variable varid symbol means descendant expression brackets lter group elements latter selection xslt program passes id e 1 along parameter next employee selected latter selection program outputs element pair attribute values e 1 e 2 attributes topmgrid employeeid respectively program best way xslt compute desired query nicely illustrates three important features xslt modes variables passing data values let us discuss brie modes enables xslt act dierently upon arrival element types instance described program arrives employee element action depends actual mode select display element selected ii variables used two purposes apparent one illustrated query allow perform joins data values less apparent application use lookahead figure 5 give fragment xslt program evaluating binary tree representing boolean circuit truth value essentially use variables allows bottomup computation restriction binary trees expository purposes fact shown xslt evaluate bottomup tree automaton unranked trees 17 brief arriving orlabeled node program returns correct truth value based upon truth values rst second subtree iii passing data values template rules crucial performing joins items joined far apart moreover xsltemplate matchorganization modestart xslapplytemplates selectorganizationtopmgremployee modeselecttopmgr xsltemplate xsltemplate matchemployee modeselecttopmgr xslvariable namevarid xslvalueof selectid xslvariable xslif testvarid bill xslapplytemplates modedisplay selectgroupmgremployeeidvaridgroupemployee xslwithparam namevarid selectvarid xslapplytemplates xslif xsltemplate xsltemplate matchemployee modedisplay xslparam namevarid xslattribute nametopmgrid xslvalueof selectvarid xslattribute xslattribute nameemployeeid xslvalueof selectid xslattribute xsltemplate fig 2 xslt program computing query section 2 group idhr employee idbill group idhrprod employee idedna group idhrprodempl employee idkate employee idronald group idhrqa employee idjohn group idhrqaempl employee idjane employee idjake employee idbill employee idjohn fig 3 xml document conforming dtd figure 1 pair topmgridjohn employeeidjane pair topmgridjohn employeeidjake fig 4 output xslt program figure 2 document figure 3 node ids present xml document 4 use mechanism place pebbles input document enables us complicated grouping operations exactly three features render xslt quite powerful transformation language xsltemplate matchor xslvariable namearg1 xslapplytemplates select1 xslvariable xslvariable namearg2 xslapplytemplates select2 xslvariable xslchoose xslwhen xslvalueof selectfalse xslwhen xslotherwise xslvalueof selecttrue xslotherwise xslchoose xsltemplate fig 5 fragment xslt program evaluating treestructured boolean circuits takes care ornodes next section give abstract formal syntax xslt first restrict matching patterns test label current node already case figure 2 restriction theorem 8 shows test many properties current node body template rule divide template rule two parts variable denition part construction part variables assigned data values particular variable dened value attribute current node xslt applytemplates statement return exactly one data value refer special templates selection template rules construction part template rule actual output dened relative conditions values variables parameters attribute values current node possibly whether current node root leaf rst last child parent 4 xsl capable generating see section 4 3 formal model xslt 31 trees forests start necessary denitions regarding trees forests nite alphabet symbols correspond element names xml document tree represents use trees adequate abstractions actual xml documents extend attributes take values innite domain g set forests denoted f inductively dened follows every 2 forest 2 f 2 f f forest f 1 f f 1 fn forest tree forest form f denote set trees note priori bound number children node forest following whenever say tree forest always mean tree forest reason consider forests even use xsl tree tree transformations sometimes need specify template rules construct forests every forest f 2 f set nodes f denoted nodesf subset n inductively dened follows g thus tree node represents root ui represents ith child u forest node iu represents node u ith tree forest next add xml attributes dened attributes end rest paper x nite set attributes attributed forest domain pair f f 2 function assigning value node f set attributed forests domain denoted f usually take however create output template rules use attributed forests dfx 1 variables refer dened variable dening part template course real xml documents usually element types set attributes obviously convenient necessary restriction analogous way one dene set attributed trees denoted set b f denotes set attributed forests f b symbols b may appear leaves f formal model abstract away particular selection pattern language recall xslt uses pattern language described xpath 5 see 26 formal semantics patterns rather involved illustrated second template rule figure 2 pattern depends value variable varid addition patterns also moving instructions like select parent left sibling right sibling rst child actually proof theorem 9 indicates local selections enough simulate existing xml query languages following assume innite set variables x dene pattern variables x x function denote set patterns x idea follows let p pattern tree variable assignment variables p pt u set selected nodes pattern applied node u 32 syntax denition 1 xslt program tuple alphabet input symbols alphabet output symbols c nite sets construction selection modes start 2 c start mode r nite set construction selection template rules dened mentioned end section 2 distinguish two types template rules constructing selecting ones former used create output result applying forest latter used fetch data val ues one returns exactly one domain element mode determine nature template constructing selecting denition 2 construction applytemplatesexpression r atexpression short form qp z q 2 c p pattern z possibly empty sequence variables x domain elements selection expression dened constructing one restriction p selects single nodes every tree assignment variables node u pt u singleton set denote set construction selection atexpression c instance applytemplates expression second template figure 2 constructing one corresponds model expression p pattern groupmgremployeeidvaridgroupemployee note application pattern eventually leads generation element expression constructing sense eventually produce output denition 3 attribute expression expression form attribute atomic test one following expression attribute expressions variables domain ii expression form root leaf rstchild lastchild finally test boolean combination atomic tests computation expressions evaluate value attribute current node root leaf rstchild lastchild evaluate true whenever current node root leaf rst last child parent selection template rules dened next recall output one domain element denition 4 let q 2 c 2 q selection template rule template q x 1 return xs ys variables former parameters latter local r 2 attribute expression r 2 every variable occurring among 1 c tests containing variables x fx every z domain element variable x selecting atexpression restriction variables occurring belong x denition 5 let q 2 c 2 q construction template rule form selection rule z forest f dx recall forests attributes take values x leaves may labeled constructing atexpression restriction variable occurring atexpression occurring leaf z x keep model total deterministic require existence exactly one q template rule mode ensure xslt program generates tree tree translations require z start construction template rule tree rather forest example 6 illustrate translating program figure 2 syntax patterns p 1 refer patterns rst second template rule respectively second template rule displayp 2 varid tree consisting one node labeled displayp 2 varid denotes empty tree last rule pairtopmgrvarid employeeidmyid denotes tree consisting one node topmgrid employeeid myid readability omitted test true modes constructing template organizationstart return template employeeselecttopmgr return varid 6 bill displayp 2 template employeedisplayvarid return 33 semantics dene semantics need following let w consist sequence variables x domain elements function denote sequence domain elements obtained w replacing occurrence variable x w x x 1 nd denote function maps x next dene semantics xslt program p tree thereto need following concept local conguration element nodest intuitively u q means program selected node u mode q values parameters ease presentation dene result p denoted p direct procedural way latter advantage usual denition terms rather complicated formally correct rewrite relations trans parent drawback deal border case xslt programs get innite cycles however clear p un dened whenever one generated subprocesses computes forever defer formal semantics terms rewrite relations full version paper distinguish two cases let label u suppose q selection mode p 2 let q template rule form specied denition 4 r q p attribute expression intuitively template evaluated follows first values variables 1 dened value attribute value current node dened invoking atrule compute desired data value output determined z c rst test evaluates true suppose variables 1 assigned domain values e 1 atexpression e maps x j j node selected p p attribute expression e u next suppose c rst condition evaluates true interpreting j e j x j j u root leaf rstchild lastchild true u root leaf rst last child parent respectively ensure translation total require least one c exists 5 z determines output value following way z constant variable attribute expression p equals corresponding value z selecting atexpression q 0 p w wxn yne v node selected p pt xn fvg suppose q construction mode p let q template rule form specied denition 5 suppose variables 1 get assigned values e 1 rst condition evaluates true z determines output value following way recall z forest f dx c forest attributes take values x leaves may labeled constructing atexpression p forest obtained z replacing every occurrence j x j value attribute data values e j j respectively every occurrence q 0 p w atexpression leave z forest wxn wxn denotes document order recall p wxn yne returns attributed forest initial local conguration dened start denition 7 result xslt program p tree denoted p dened p start 34 remarks conclude section remarks first note xslt make explicit distinction constructing selecting template rules 5 obviously one could also add otherwise construct rather condition even variable denition part constructing part template rule however feel making explicit programming becomes structured hand incorporate everything xslt oer instance refrained including forloops nevertheless show next section captured powerful fragment capable simulating existing xml query languages even 4 expressiveness next show xslt capable computing expressive structural patterns thereto rst say view attributed trees logical structures sense mathematical logic 10 binary relation symbols e unary relation symbols 2 domain viewed structure equals set nodes ie nodest e edge relation equals set pairs v v every v v 2 nodest relation species ordering children node equals set pairs v nodest set nodes labeled logic mso mso vocabulary mso dened usual way see eg 10 extended atomic formulas form attribute 2 denote latter atomic formula semantics dened follows attribute u value note allow atomic formulas form allow joins clearly mso dene xpath matching patterns even fo denable next theorem says xslt capable expressing unary mso patterns particular means one need matching patterns templates xslt actually allows specify rules like xsltemplate matchp modeq p pattern rather label means rule applied nodes satisfy p next theorem implies one test p body template rule hence need matching patterns theorem 8 let x mso formula exists xslt program p mode q p u q proof due space limitations give brief hint proof refer interested reader 17 start terminology subtree rooted v denoted v envelope v denoted v tree obtained deleting subtree rooted v keeping v note v v v common let quantierdepth k denote unary mso formulas x quantierdepth k hold x interpreted v well known k v nite v xed k whether depends k 6 would case atomic formulas form computed unranked tree automata working v v v respectively 20 v v tree v v distinguished node hence remains show xslt programs compute bottomup unranked tree automata brief done using variables lookahead like xslt program figure 5 study decidability type checking milo suciu vianu 16 dened kpebble treetransducer formalism capturing expressiveness existing xml query languages transducers transform binary trees binary trees 7 next describe deterministic transducers equality tests data values kpebble deterministic treetransducer uses k pebbles mark certain nodes tree transitions determined unique way current node symbol current state mode pres enceabsence various pebbles current node equality tests attribute values nodes pebbles located pebbles ordered numbered 1 k machine place pebbles root move around remove actually use pebbles restricted stack discipline ensures model become powerful accepts nontreeregular languages move transitions output tran sitions move transitions following kind movetoparent movetorst child movetolastchild movetoleftsibling movetorightsibling remainand changestate placenewpebble pickcurrentpebble two kinds output transitions binary output outputs symbol possibly attributes dened attribute value pebbled node spawns two computation branches compute independently left right subtree branches inherit positions pebbles input communicate branch moves pebbles independently nullary output node output leaf output tree possibly attributes computation halts clear apart pebbles described model extremely close xslt xslt equiped modes states local movements simple output transitions assumption node unique id xslt also simulate pebbles 8 indeed use k variables x 1 x k time instance x contains id node ith pebble located discussion immediately leads next theorem implies xslt simulate current query languages like instance xmlql 16 refer interested 7 proving properties xml transformations restricting binary trees usually sucient unranked ones encoded ranked ones course case one tries dene formal model xslt works directly unranked trees 8 actually assumption necessary xslt equiped function generateid generates unique id current node furthermore id depends current node invoked node several times return value need store node ids computed demand reader 3 show xmlql queries 9 expressed actual xslt theorem 9 xslt simulate kpebble deterministic treetransducers equality tests data values point nondeterministic treetransducers simulated giving nondeterministic semantics xslt obvious way although discussion kpebble transducers seem extremely close formal model xslt clear whether former simulate latter indeed theorem 8 shows xslt check mso property root tree know whether deterministic kpebble transducers fact problem closely related seemingly dicult open problem formal language theory treewalking automata without pebbles dene mso denable tree languages 11 12 21 hand theorem 8 hold nondeterministic kpebble transducers furthermore clear whether deterministic transformations express simulated xslt regardless known query languages based rstorder logic extended regular path expressions like xmlql weaker mso 19 hence theorem 8 theorem 9 weaker xslt acknowledgements last author thanks bertram ludascher victor vianu encouraging helpful discussions r data web lorel query language semistructured data examples translations xmlql xslt query language optimization techniques unstructured data xml path language xpath extensible stylesheet language xsl xsl transformations version 10 world wide web consortium querying xml data finite model theory trips trees catching boat strudel experiences website management system structured document transformations based xsl type checking xml transformers design analysis query languages structured documents extensions attribute grammars structured document queries expressive e query automata power treewalkingautomata design xql semistructured data xml formal semantics patterns xslt tr query language optimization techniques unstructured data languages automata logic expressiveness structured document query languages based attribute grammars catching boat strudel query automata macro tree transducers attribute grammars mso definable tree translations data web typechecking xml transformers expressive efficient pattern languages treestructured data extended abstract quilt structured document transformations based xsl extensions attribute grammars structured document queries ctr frank neven automata theory xml researchers acm sigmod record v31 n3 september 2002 michael benedikt wenfei fan gabriel kuper structural properties xpath fragments theoretical computer science v336 n1 p331 25 may 2005 joost engelfriet hendrik jan hoogeboom bart samwel xml transformation treewalking transducers invisible pebbles proceedings twentysixth acm sigmodsigactsigart symposium principles database systems june 1113 2007 beijing china andreas maletti heiko vogler incomparability results classes polynomial tree series transformations journal automata languages combinatorics v10 n4 p535568 january 2005 maarten marx maarten de rijke semantic characterizations navigational xpath acm sigmod record v34 n2 june 2005 martens frank neven frontiers tractability typechecking simple xml transformations proceedings twentythird acm sigmodsigactsigart symposium principles database systems june 1416 2004 paris france martens frank neven complexity typechecking topdown xml transformations theoretical computer science v336 n1 p153180 25 may 2005 frank neven thomas schwentick power treewalking automata information computation v183 n1 p86103 may 25 frank neven power walking querying treestructured data proceedings twentyfirst acm sigmodsigactsigart symposium principles database systems june 0305 2002 madison wisconsin makoto onizuka fong yee chan ryusuke michigami takashi honishi incremental maintenance materialized xpathxslt views proceedings 14th international conference world wide web may 1014 2005 chiba japan martens frank neven frontiers tractability typechecking simple xml transformations journal computer system sciences v73 n3 p362390 may 2007 frank neven thomas schwentick victor vianu finite state machines strings infinite alphabets acm transactions computational logic tocl v5 n3 p403435 july 2004 jan hidders philippe michiels jan paredaens roel vercammen lixquery formal foundation xquery research acm sigmod record v34 n4 p2126 december 2005 thomas schwentick automata xmla survey journal computer system sciences v73 n3 p289315 may 2007
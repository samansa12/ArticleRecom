formal characterization epsilon serializability abstractepsilon serializability esr generalization classic serializability sr paper provide precise characterization esr queries may view inconsistent data run concurrently consistent update transactionsour first goal understand behavior queries presence conflicts show esr fact generalization sr using acta framework formally express intertransaction conflicts recognized esr define esr analogous manner conflictbased serializability defined secondly expressions derived amount inconsistency data item viewed query effects results query inconsistencies arise concurrent updates allowed esr thirdly order maintain inconsistencies within bounds associated query expressions used determine preconditions operations satisfy results query errors depend query possibly inconsistent data viewed one important byproducts work identification different types queries lend analysis effects data inconsistency results query b introduction epsilon serializability esr 21 29 generalization classic serializability sr explicitly allows limited amount inconsistency transaction processing tp esr enhances concurrency since nonsr execution schedules permitted example epsilon transactions ets perform queries may execute spite ongoing concurrent updates database thus query ets may view uncommitted ie possibly consistent data concretely update transaction may export inconsistency updates data item query ets progress conversely query et may import inconsistency reads data item uncommitted updates data item exist correctness notion esr based bounding amount imported exported inconsistency et benefits esr discussed papers cited instance esr may increase system availability autonomy 22 distributed tp systems since asynchronous execution allowed paper restrict attention esr centralized tp system full generality update ets may view inconsistent data way query ets may however paper focus situation queryonly ets run concurrently consistent update transactions update transactions allowed view uncommitted data hence produce consistent database states first goal understand behavior queries presence conflicts show esr fact generalization sr section 2 using 5 6 4 formally express intertransaction conflicts recognized esr define esr analogous manner conflictbased serializability defined second goal quantify amount inconsistency experienced queries end section 3 expressions derived amount inconsistency data item viewed query inconsistencies arise concurrent updates allowed esr section also considers transaction aborts affect inconsistency data esr imposes limits amount inconsistency viewed query third goal find ways bounds maintained using expressions quantifying inconsistency derive preconditions operations satisfy derivation preconditions subject section 4 preconditions point possible mechanisms used realize esr show flexible implementations presented 21 29 possible effects inconsistent view results query depend query viewed data general small data inconsistency translate arbitrarily large result inconsistency fourth goal derive effect inconsistency data read query results produced query derivation done section 5 also shows restrictions need imposed queries updates able bound inconsistency result query lie within reasonable limits helps characterize situations esr applicable thus one important byproducts work identification different types queries lend analysis effects data inconsistency results query related work discussed section 6 section 7 concludes paper offers suggestions work rest introduction provide informal introduction esr define terms used 11 esr ets database set data items data item contains value database state set data values database state space set possible database states database state space sdb metric space following properties ffl distance function distanceu v defined every pair states u v 2 sdb real numbers distance function defined absolute value difference two states account data item instance distance 50 120 70 thus current account balance 50 70 credited distance new state old state 70 ffl symmetry every continuing example suppose current account balance 120 70 debited distance new state old state still 70 ffl triangle inequality every u v w 2 sdb distanceu vdistancev w distanceu w account data clearly satisfies triangle inequality example suppose current account balance 50 70 credited distance new state old state saw 70 suppose 40 debited distance state credit state debit 40 distance initial state account 50 one updates 80 inequality satisfied many database state spaces regular geometry saw banking databases dollar amounts possess properties similarly airplane seats airline reservation systems also form metric space usually term database state space refers state disk implicitly committed values restricted database state disk however since also consider intermediate states database including contents main memory use shorter term data state include intermediate states note magnitude update measured distance old data item state new data item state esr defines correctness consistent states inconsistent states case consistent states esr reduces classic serializability addition esr associates amount inconsistency inconsistent state defined distance consistent state informally inconsistency data item x respect query q defined difference current value x value x updates x allowed execute concurrently q query imports inconsistency views ie reads inconsistent data item conversely update transaction exports inconsistency updates ie writes data item query ets read data item progress esr meaning state space possesses distance function general serializable executions produce answers zero inconsistency nonserializable query returns answer differs serializable result 10000 say amount inconsistency produced query 10000 addition triangle inequality symmetry properties help us design efficient algorithms paper confine attention state spaces metric spaces application designer transaction programmer et classic transaction addition inconsistency limits query et importlimit specifies maximum amount inconsistency imported similarly update et exportlimit specifies maximum amount inconsistency exported since focus queries simplicity presentation examine detail ets importlimits placed individual data items single attribute relational model algorithms extended handle importlimit spans several attributes eg checking accounts savings accounts application designer specifies limit et tp system ensures limits exceeded execution et example bank may wish know many millions dollars checking accounts query executed directly checking accounts banking hours serious interference would arise updates interference irrelevant however since typical updates refer small amounts compared query output unit millions dollars hence must able execute query banking hours specifically esr specify importlimit query et example 100000 query result also would guaranteed within 100000 consistent value produced serial execution transactions example et returns value 357215000 roundoff least one serial transaction executions would yielded serializable query result 325215000sigma100000 interval inconsistency accumulated query reads multiple data items example depends values read used within query percolation inconsistency data items read query results query interesting issue discussed section 5 sections 3 4 focus individual data items let us assume limits imposed amount inconsistency et import export respect particular data item let import limit tx stand importlimit set et respect data x let import inconsistency tx stand amount inconsistency already imported et data item x system supports queries reading inconsistent data must ensure following every et accesses data item x import inconsistency tx import limit tx 1 export inconsistency tx export limit tx 2 call invariants 1 2 safet x brevity query et q reading x safeq x reduces import inconsistency qx import limit qx 3 export inconsistency states query q cannot exceed importlimit q cannot export inconsistency thus execution et system needs maintain amount inconsistency et imported far note amount inconsistency given distance function incremental accumulation inconsistency depends triangle inequality property metric spaces without triangle inequality would recompute distance function entire history time change occurs section 3 derive algorithms necessary maintain specified limit inconsistency imported individual data items end section would like point throughout paper assumed read set query ie set data items read query affected inconsistency data read query 2 formal definition esr use 4 6 introduce notion conflicts operations discuss dependencies induced transactions invoke conflicting transactions given state data item use returns denote output produced operation states denote state produced execution values p denotes value predicate p state given history h h x projection history containing operation invocations data item x h order execution operations precedes i1 well functional composition operations thus state data item produced sequence operations equals state produced applying history h x corresponding sequence operations data items initial state 0 brevity use h x denote state data item produced h x implicitly assuming initial state 0 note h x may depend values read h data items x operations b conflict state produced h x denoted thus two operations conflict effects state data item return values independent execution order let x denote operation invoked data item x x implies x appears b j x h let us first define classic serializability correctness criterion given history h events relating transactions c sr binary relation defined follows x let c sr transitiveclosure c sr ie h conflict preserving serializable iff sr illustrate practical implications definition let us consider case operations perform inplace updates case transactions j c sr invoked operations conflicts previous operation long serlialized j conflict tolerated consider serialization graph corresponding c sr relation induced history definition states history serializable cycles graph serialization order must acyclic following three definitions constitute definition esr whose events recorded history h cesr binary relation transactions defined follows words j related cesr related c sr violate one invariants constitute predicate safe note last term definition cesr makes cesr strictly weaker c c sr denotes ordering requirements due conflicts serializability cesr denotes ordering requirements imposed conflicts epsilon serializability since cesr subset c sr relationship smaller number orderings imposed esr classic serializability consider graph corresponding c sr cesr relations induced history definition 4 cycle formed transactions 0 cesr edge iff next definition shows unlike sr esr tolerate cycles formed c sr relation however graph cycle consisting cesr edge history esr definition 5 history h conflictpreserving epsilon serializable iff graph corresponds c sr cesr relations induced history cycle cesr edge examine practical meaning definitions let us summarize properties esr compared serializability ffl importlimit exportlimit zero cesr reduces c sr cesr c sr esr reduces serializability ffl set transactions may satisfy serializability cycles c sr relation may satisfy esr ffl importlimits exportlimits greater zero cesr c sr given additional term definition 3 esr may allow operations execute concurrently serializability understand practical meaning definitions let us focus query q executing concurrently update transaction suppose q reads x followed ts write x assume ts write violate safetx thus q c sr q cesr true assume q another read x let us consider two scenarios 1 assume qs second read violate safeqx c sr q cesr q cyclic c sr relationship yet read permitted esr reason esr values x read q considered acceptable ie within limits inconsistency specified precisely value x read q concurrently executed within inconsistency limits considering either serialization orderings q q orderings imposed esr since according esr orderings acceptable 2 assume qs second read violates safeqx cesr q imposes ordering requirement though q read x serially thus q serialization order acceptable order conform inconsistency limits implies cannot q c sr since corresponds opposite serialization ordering hence required cycles consisting c sr cesr edges given characterization esr one first tasks quantify inconsistency experienced query check safe predicates hold done section 3 section 4 examine ensure epsilon serializable histories produced one way allow cesr form ie disallow operation violates safe question inconsistency data read query percolates results query studied section 5 different types queries identified view determining amount data inconsistency tolerate order maintain specified limits result inconsistency inconsistency imported query et focus inconsistency single data item x read query q informally inconsistency x respect query q defined difference current value x value x updates x allowed execute concurrently q consider update transactions updates x allow query q read x multiple times updating write x multiple times let us define transaction write interval respect x interval time first write last write read interval defined similarly every query q set concurrent update transactions denoted cutq update write interval intersects qs read interval note lockbased realizations serializability ensure question attempting answer following one say value x read q given cutq main objective bound inconsistency value x read q first establish write intervals transactions cutq totally ordered since consistent update ets serializable theorem 1 serialization order transactions 2 cutq wrt x order enters write interval turn order commit name values x different points time ffl x current current value x final value x committed transaction initial value x transaction cutq begins ie x final initial defined value x transactions cutq begin execution cutq 6 x q values x derive current change initial fcurrent change x g final change initial final clearly final change x max change x current change x position define inconsistency formally initial inconsistency qx inconsistency qx denotes distance x q initial x current inconsistency value x query q progress update ets committed given inconsistency initial initial initial initial initial initial final initial current change final change let committed cutq denote subset cutq containing ets commit ted let current 2 cutq denote update transaction whose write interval begun ended yet current exists null value current change nullx defined 0 discussions state following theorem expresses bounds inconsistency data item read query q read interval intersects write intervals ets cutq theorem 2 inconsistency initial 2committed cutq final change current change currentx 2committed cutq final change 2committed cutq whereas expression 5 exact expression inconsistency expressions 6 8 viewed different bounds inconsistency qx position relate inconsistency bound conflictbased definition esr given section 2 recall definitions c sr cesr pair transactions c sr relationship cesr relationship iff one query update import limits violated let us focus c sr relationships induced operations x given 8 update transactions appears pairs belongs c sr cesr contributes inconsistency max change x value x read q far considered case transactions commit stated following theorem abortion update transactions effect increasing inconsistency imported query without changing value x theorem 3 maximum increase imported inconsistency caused aborted transactions given aborted proof suppose transactions 1 igamma1 committed begins subsequently aborts addition inconsistency due 1 igamma1 derived earlier q reads x time execution experience additional inconsistency aborts whereby changes made obliterated thus subsequent updates increase value x respect resulting 1 igamma1 suppose transactions cutq follow commit max change x increase inconsistency due aborted transactions hence theorem holds suppose instead i1 aborts q reads x j begins x reflect changes done 1 transactions 1 3 bounded max change j x larger increase inconsistency due aborted transactions j hence theorem follows two transaction aborts smaller remains upper bound increase maximum two effective increase inconsistency due two transaction aborts proof extends easily transactions abort ensuring epsilon serializability preconditions operations make sure histories esr per definition 4 ensure cycles formed cesr edges even allow cesr relations like sr realized preventing formation serialization orderings ie c sr relations esr realized preventing formation cesr relations thus ensure query always safe ie import inconsistency qx import limit qx invariant esr guaranteed specifically inequality must hold every read write operation well every transaction transaction management event derive preconditions performing operations sufficient ensure import limits transactions exceeded preconditions turn used show transaction executions managed let begin write tx denote attempt et begin write interval respect x begin read tx invoked begin read interval respect x let end write tx denote completed writes x consider semantics begin write begin read end write end read read write two situations consider first query et q already progress initially committed update transactions write interval begins may followed update ets q commits second update et progress query begins recall attention confined centralized database single transaction manager let q query update et stands assignment query q progress begin write tx j current current null committed cutq committed cutq otherwise begin write tx j end write tx j update transaction progress begin read qx j current cutq otherwise begin read qx semantics operations read tx j read qx j import inconsistency qx inconsistency qx current x current delta parameter write operation denotes amount x modified write occurs important note semantics query imports inconsistency performs read operation inconsistency value x due updates translates imported inconsistency read operations occur establish preconditions necessary maintain 3 ie import inconsistency qx import limit qx case 1 preconditions read qx operations given inconsistency imported q performs read following precondition need maintain 9 inconsistency qx import limit qx 5 implies precondition current x q initial every read operations must intercepted transaction management mechanism ensure precondition holds predicate hold read query aborted delayed q long query performance implications motivation examining possible ways maintain 9 case 2 preconditions write tx operations begin read qx operations suppose satisfy following invariant inconsistency qx import limit qx ie current x q initial note stronger invariant 9 ie maintained 9 maintained negative sideeffect query read x allowable inconsistency x restricted unnecessarily given semantics various operations expression 5 inconsistency following precondition results current initial given x metric space implies precondition initial jdeltaj denotes absolute value delta also use j j denote cardinality set meaning obvious context says write allowed increase inconsistency caused intended increment violate limit imposed inconsistency imported q even though precondition necessary read following precondition required begin read qx invoked update transaction already progress current initial note x q initial q begins read interval ts writes progress says changes already done update transaction exceed import limit imposed q query must allowed begin read x preconditions imply query q maintain x q initial avoided maintaining even stronger invariant corresponding inconsistency bound 6 ie maintaining 2committed cutq final change current change current x import limit qx imposes following precondition write tx 2committed cutq final change current change currentx import limit qx following precondition begin read qx current change current x import limit qx implies write operations update ets requests query ets begin reading monitored ensure allowed preconditions hold invariants require maintenance recent committed state x available anyway however need check every write update et implies increased overheads may also result aborts delays update ets progress avoided shown even stronger invariant maintained case 3 preconditions begin read qx begin write tx operations consider following invariant corresponding inconsistency bound 7 2committed cutq final change current x import limit qx inequality turns precondition begin write tx begin read qx following precondition implies unlike previous case preconditions associated individual writes update transactions reduces transaction management overheads introduce pessimism decision making since worst case changes x assumed precondition begin write tx requires knowledge final change transac tions avoided following invariant corresponding inconsistency bound 8 maintained 2committed cutq current x import limit qx 11 11 also precondition begin write tx 10 stays precondition begin read qx suppose update ets given import limit qx query q translates limit cardinality cutq terms impact derivation implementation esr note progressed preconditions individual read write operations preconditions read write intervals begin latter introduce pessimism assumptions made amount changes done given update transaction modeling query transaction executions terms read write intervals allows us capture different types concurrency control techniques instance begin events correspond acquisition locks end events correspond release locks get lock based protocols assume use preconditions events ensure bounds basis lockbased implementation 29 wherein precondition 11 begin write corresponds lok2 precondition 10 begin read corresponds lok1 however derivation restricted lockbased implementations optimistic concurrency control writes done validation phase case precondition checking writes part validation phase update transaction 5 inconsistency results query since query definition update data affect permanent state database furthermore assumed updates import inconsistency ie operate consistent database states thus assuming update et maintains database consistency updates also affect consistency database effect updates inconsistency data read queries section 3 derived expressions amount inconsistency imported query given inconsistency observable effect query et results produced query words inconsistency imported query percolate results query ways obviously dependent manner query utilizes values read section devoted determining effect inconsistency data read query results general small input inconsistency translate arbitrarily large result inconsistency therefore study properties query make result inconsistency predictable first establish terminology consider situation query q reads data items produces result based values read general results query stated function form g denotes query et f functions f range f assume r f also metric space practice typically r f subset sdb example aggregate functions queries database usually return value sdb focusing monotonic queries section 51 derive inconsistency result query show even though inconsistency bound bound may tight suppose similar import limit export limit limit placed inconsistency result query section 52 derive preconditions et operations imposed limit section 53 class queries called bounded queries considered section 54 examines steady queries discusses queries designed tighter inconsistency bounds thereby requiring less restrictive preconditions 51 monotonic queries first important class queries consists monotonic functions function f monotonically increasing x function g monotonically decreasing function called monotonic either monotonically increasing decreasing without loss generality rest section describe monotonically increasing functions result returned monotonic et q assuming value x read q given x iread max inconsistency x maximum inconsistency value x read q given theorem 2 section 3 x iinitial value x first update et cutq begins x x inconsistency x thus since g f monotonic result query lie min result note f monotonic smallest largest value f need correspond smallest largest value x thus definition inconsistency result inconsistency let us look examples example 1 n1 identity function corresponds single data element case hence inconsistency result q seen given 13 example 2 n20 identity function case one would expect result query according 14 15 lie inconsistency x example 3 n20 predicate value 1 true otherwise 0 case result query according 14 15 lie example 4 concrete case example 3 consider bank database accounts numbered 120 account odd number happens 5001 evennumbered accounts 4999 update transaction system transfers 2 acc acc j query et sums deposits greater 5000 suppose first set transactions executed system transferacc finish following executed transferacc 2i acc update transactions maintain total money database easy see serializable execution query et return 50010 since given exactly 10 accounts 5000 query produce result 0 100080 since exactly example 3 range result include serializable result 50010 however given range tight pessimistic occurs inconsistency caused updates percolate rather drastic manner results query section 54 identify class queries tight bounds results query exist one point note even bound requires knowledge x iinitial value x first et cutq begins practical implications specifically update begun data values may logged order derive inconsistency queries may subsequently begin case systems require undo capability using steal buffering policy 12 given lower bound result query 0 one may tempted take following solution assume x iinitial smallest value x take ie 0 difficult see produce correct range querys result 52 preconditions monotonic queries suppose result inconsistency limit q denotes maximum inconsistency application withstand result query q result inconsistency q result inconsistency limit q invariant derived preconditions maintain import limit qx export limit qx derive preconditions maintain invariant instance consider expression 8 max inconsistency x given 16 semantics et operations see section 3 following precondition begin write tx 2committed cutq 2committed cutq result inconsistency limit q following precondition begin read qx result inconsistency limit q similar manner preconditions derived case expressions inconsistency used 53 bounded queries say function f bounded maximum bound result f easy see calculate bounds inconsistency results query composed bounded functions example 5 consider following variation example 4 query et sums deposits greater 5000 query n20 monotonic x increases 4999 decreases 4999 0 expressions derived result inconsistency section 52 apply easy see serializable execution query et return 49990 since given time exactly 10 accounts balance 5000 also difficult see et query smallest possible result 0 largest possible result 99980 even though f monotonic show possible obtain bounds query results let min f denote smallest value f value denote largest value f value x long g monotonic result query lie let us return example 5 case hence result query lie 0 100000 since actual result query lies 0 99980 using maximum minimum possible f values leads overestimate inconsistency query results generalization bounded functions monotonic functions class functions bounded variation avoid confusion readers familiar mathematical analysis follow closely usual definition functions compact metric spaces definition 6 b finite interval metric space set points satisfying inequalities called partition b interval x called k th subinterval p write deltax definition 7 let f defined b partition b write n exists positive number partitions b f said bounded variation b clear bounded functions bounded variation example 5 furthermore monotonic functions also bounded variation happens monotonically increasing function f deltaf k 0 therefore general function bounded variation bound used overestimate result inconsistency given interval b caused input inconsistency however examples show need restrict forms et queries tighter bounds result inconsistency found without overly restricting type queries allowed 54 steady queries let ds denote set distances defined sdb dr set distances defined r f say f steady every ffl 2 steady functions discrete metric spaces analogous continuous functions compact sets definition similar except exclude fixed number small ffl due discrete nature sdb informally ffl zero importance steady functions application designer may specify limit result inconsistency result inconsistency limit ffl tp system calculate limit imported inconsistency max inconsistency ffi guarantees specified limit result inconsistency section 52 shows calculation done monotonic functions note every monotonic function steady convenient choice ffl 0 however smaller ffl 0 tighter bound ffi following example bound tight ffl example consider query et returns balance bank account update executing say transferring money account query result inconsistency equal imported inconsistency example ffl 0 large consider example 4 account balance actually 5000 input inconsistency 1 may change result 5000 therefore since smaller ffl requires one way handle situation reduce eliminate imported inconsistency data item causes large ffl 0 instance suppose large ffl 0 due x 1 tighten import limit x 1 allow inconsistency x 2 consider following example simple variation example 4 example 7 query et returns checking account balance customers savings accounts balance greater 5000 note example x 1 refers savings account x 2 checking account case may specify import limit 0 savings account balance import limit 100 checking account balance way avoid large ffl 0 respect x 1 maintain tight control result inconsistency since function returns checking account balance steady function ffl example 6 able calculate ffl ffi viceversa properties et queries allow system maintain tight bounds result inconsistency functions bounded variation steady functions abstract classes functions properties clearly elaborate characterization functions defined discrete metric spaces useful 6 related work 61 general weak consistency criteria several notions correctness weaker sr proposed previously taxonomy correctness criteria given 23 contrast closely related esr esr grays different degrees consistency 11 example coarse spectrum consis tency specific interest us degree 2 consistency trades reduced consistency higher concurrency queries since degree 2 allows unbounded inconsistency degree 2 queries become less accurate system grows larger faster general esr offers much finer granularity control degrees consistency garciamolina wiederhold 10 introduced weak consistency class readonly transactions contrast wlca algorithm esr supported many divergence control methods 29 similarly du elmagarmid 7 proposed quasiserializability qsr qsr limited applicability local sr requirements despite unbounded inconsistency korth speegle 16 introduced formal model include transaction preconditions postconditions contrast esr refers specifically amount inconsistency state space sheth rusinkiewicz 26 proposed eventual consistency similar identity connections introduced wiederhold qian 28 lagging consistency similar asynchronously updated copies like quasicopies 1 discuss implementation issues 24 25 comparison esr achieves similar goals general approach based state space properties functional properties barbara garciamolina 2 proposed controlled inconsistency extends work quasicopies 1 demarcation protocol 3 used implementing esr distributed tp systems esr applicable arithmetic kinds consistency constraints 62 asynchronous transaction processing garciamolina et al 9 proposed sagas use semantic atomicity 8 defined transaction semantics sagas differ esr unlimited amount inconsistency revealed compensation may propagate persist database levy et al 19 defined relaxed atomicity implementation polarized protocol esr defined state space properties less dependent application semantics important problem asynchronous tp guarantee uniform outcome distributed transactions absence commit protocol unilateral commit 13 protocol uses reliable message transmission ensure uniform decision carried asynchronously optimistic commit 18 protocol uses compensating transactions 15 compensate effects inconsistent partial results ensuring uniform decision unilateral commit optimistic commit seen implementation techniques esrbased systems another way increase tp concurrency escrow method 20 like escrow method esr also uses properties data state space esr rely operation semantics preserve consistency similarly datavalue partitioning 27 increases distributed tp system availability autonomy esr used modeling management escrow partitioned datavalues conclusions previous esr papers discussed esr informal terms motivating via specific applications 21 22 presenting implementationoriented considerations 29 evaluation performance improvement due esr reported 14 paper examined epsilon serializability esr first principles showed precisely esr related sr example conflicts considered sr ignored esr conflict based specification esr using acta formalism employed bring differences sr esr began formalization query behavior deriving formulae express inconsistency data values read query expressions derived preconditions depend data values import limits read operations invoked transactions transaction management events words precise definition ets esr able derive behavioral specifications necessary transaction management mechanisms form second contribution paper results showed flexible transaction management techniques ones discussed previously possible another important aspect paper derivation expressions inconsistency results queries showed since arbitrary queries may produce results large inconsistency important restrict et queries certain properties permit tight inconsistency bounds towards end came different types queries allow us bound result inconsistency cases find tight bounds well clearly work needed area since generality queries traded tightness result inconsistency among active topics research formal treatment general ets import export inconsistency also effect relaxing assumptions instance read set query unaffected inconsistency needs studied acknowledgements authors thank p chrysanthis hv jagadish v wolfe referees comments previous versions paper r data caching issues information retrieval systems case controlled inconsistency replicated data demarcation protocol technique maintaining arithmetic constraints distributed database systems formalism extended transaction models acta framework specifying reasoning transaction structure behavior acta saga continues quasi serializability correctness criterion global concurrency control interbase using semantic knowledge transactions processing distributed database granularity locks degrees consistency shared data base principles transactionoriented database recovery unilateral commit new paradigm reliable distributed transaction processing performance characteristics epsilon serializability hierarchical inconsistency bounds formal approach recovery compensating transactions formal model correctness without serializability bounded ignorance replicated systems optimistic commit protocol distributed transaction management theory relaxed atomicity escrow transactional method replica control distributed systems asynchronous approach autonomous transaction execution epsilonserializability search acceptability criteria database consistency requirements transaction correctness properties redundant data management bellcore bcc databases maintaining consistency interdependent data multidatabase systems management interdependent data specifying dependency consistency requirements modeling asynchrony distributed databases divergence control epsilonserializability tr ctr lyman prabhu ram pamela drew need distributed asynchronous transactions acm sigmod record v28 n2 p534535 june 1999 kunlung wu philip yu calton pu divergence control algorithms epsilon serializability ieee transactions knowledge data engineering v9 n2 p262274 march 1997 dang depeng liu yunsheng concurrency control realtime broadcast environments journal systems software v68 n2 p137144 15 november lisa cingiser dipippo victor fay wolfe objectbased semantic realtime concurrency control bounded imprecision ieee transactions knowledge data engineering v9 n1 p135147 january 1997 nir shavit dan touitou elimination trees construction pools stacks preliminary version proceedings seventh annual acm symposium parallel algorithms architectures p5463 june 2426 1995 santa barbara california united states teiwei kuo shaojuen ho similaritybased load adjustment static realtime transaction systems ieee transactions computers v49 n2 p112126 february 2000 alexander totok vijay karamcheti modeling concurrent web sessions bounded inconsistency shared data journal parallel distributed computing v67 n7 p830847 july 2007 philip bernstein alan fekete hongfei guo raghu ramakrishnan pradeep tamma relaxedcurrency serializability middletier caching replication proceedings 2006 acm sigmod international conference management data june 2729 2006 chicago il usa man hon wong divyakant agrawal hang kwong mak bounded inconsistency typespecific concurrency control distributed parallel databases v5 n1 p3175 jan 1997 yuanting kao chinfu kuo twoversion based concurrency control recovery realtime clientserver databases ieee transactions computers v52 n4 p506524 april evaggelia pitoura bharat bhargava data consistency intermittently connected distributed systems ieee transactions knowledge data engineering v11 n6 p896915 november 1999 aloysius k mok realtime data semantics similaritybased concurrency control ieee transactions computers v49 n11 p12411254 november 2000 teiwei kuo chihhung wei kamyiu lam realtime access control reservation btree indexeddata realtime systems v19 n3 p245281 nov 2000 krithi ramamritham panos k chrysanthis taxonomy correctness criteria database applications vldb journal international journal large data bases v5 n1 p085097 january 1996 yasushi saito marc shapiro optimistic replication acm computing surveys csur v37 n1 p4281 march 2005
machineadaptable dynamic binary translation dynamic binary translation process translating optimizing executable code one machine another runtime program executing target machine dynamic translation techniques normally limited two particular machines competitors machine hardware manufacturers machine research provides general framework dynamic translations providing framework based specifications machines reused adapted new hardware architectures way developers techniques isolate design issues machine descriptions reuse many components analyses describe dynamic translation framework provide initial results obtained using system b introduction binary translation migration technique allows software run machines achieving near native code performance binary translation grew emulation techniques late 1980s order provide migration path legacy cisc machines newer risc machines techniques developed hardware manufacturers interested marketing new risc platforms mid 1990 binary translation techniques used translate competitors applications desired hardware platform near future expect see techniques used optimize programs within family computers example optimizing sparc architecture binaries ultrasparc architecture binaries uqbt university queensland binary translator developed techniques specification languages complete framework performing static translations code 1419 static binary translation code translated offline program run creating new program uses machine instructions target machine however static translation limitations due nature von neumann machine code data represented way always possible discover code program statically example targets indirect transfers control jumps registers sometimes hard analyse statically therefore fallback mechanism commonly used statically translated program form interpreter interpreter processes untranslated code runtime returns translated code suitable path found limitations static binary translation overcomed dynamic translation expense performance dynamic binary translator code gets translated fly runtime user perceives ordinary execution program target machine oppossed emulation dynamic translation generates native code performs ondemand optimizations code hot spots code optimized runtime increase performance execution code optimizations possible statically possible dynamically paper describe design machineadaptable dynamic binary translator based static uqbt framework uqdbt tool said machineadaptable configured handle different source andor target machines way machineadaptable dynamic binary translator capable configured different source target machines specification properties machines instruction sets words translator bound two particular machines per existing translators capable supporting variety source target machines uqdbt differs dynamic translators provides clean separation concerns allowing machinedependent information specified well performing machineindependent analyses support machineadaptability way uqdbt support variety cisc risc machines low cost support new machine specifications machine need written uqdbt framework reused new machinespecific modules may need added particular feature machine supported uqdbt framework feature generic across different architectures paper structured following way section 2 discusses static dynamic frameworks binary translation section 3 outlines research problems machine adaptable binary translation addressed uqdbt section 4 provides case study translation framework example program section 5 shows preliminary results use framework section 6 discusses effects changing granularity translation conclusions given section 7 work reported herein work progress 11 related work attempt improve existing emulation techniques companies late 1980s began using binary translation achieve native code performance perhaps well known binary translators digitals vest mx1 translate vax mips machine instructions 64bit alpha instructions translators others like apples mae2 digitals freeport express3 runtime environment reproduces old machines operating environments runtime environment offers fallback interpreter processing old machine code discovered translation time example due indirect transfers control recent years seen transition hybrid translators proving extremely successful process mixing translation emulation runtime profiling brought leading performers hybrid translation scene digitals fx324 executor ardi5 suns wabi6 fx32 emulates program initially statically translates background using information gathered profiling embra7 machine simulator built using dynamic translation techniques developed shade fast instructionset simulator execution profiling 17 le8 investigates outoforder execution techniques dynamic binary translators though results based interpreterbased implementation many optimization techniques used dynamic translators derived dynamic compilers self9 tcc10 runtime optimizations compilers provide 09x 2x performance statically compiled programs techniques also used justintime jit compilers java jits sun11 others dynamically generate native machine code runtime date none current binary translators generate code one source target machine pair machinedependent aspects translation hard coded translator making hard reuse translators code another set machines research differs previous research machinedependent issues separated machineindependent translation concerns hence providing way specifying different machines source target machines supporting specifications reusable components implement machineindependent analyses paper shows process feasible therefore enhances reuse code creation dynamic binary translators however machineadaptability translator comes cost performance discussed section 5 2 binary translation frameworks binary translation process lowlevel reengineering decoding higher level abstraction followed encoding lower level abstraction figure 1 gives block view uqbt static translation framework 1419 reengineering process divided initial reverse engineering phase lefthand side forward engineering phase righthand side reverse engineering steps recover semantic meaning machine instructions threestep process decoding binary file decoding machine instructions code segment mapping instructions semantic meaning form register transfer lists rtls highlevel analysis process lifts level representation code machineindependent form performs binary translation specific optimizations code brings level abstraction rtls target machine followed forward engineering process optimizing code encoding instructions machine code storing code data program binary file forward engineering process standard optimizing compiler code generation technology rtl simple lowlevel registertransfer representation effects machine instructions single instruction corresponds registertransfer list uqbt sequential composition effects effect assigns expression location side effects explicit top level expressions evaluated without side effects using purely function rtl operators rtl language collection locations operators machine sublanguage mrtl defined rtls represent instructions machine single rtl previously mentioned problems static binary translation inability find code belongs program limitation optimizations static ones without taking advantage dynamic optimization techniques one hardest problems solve decoding em tic apper p tim izer truc io n truc io n enc oder analy bin ary f ile bin ary f ile enc oder em b ly tr uc tio n ar tr uc tio n tr eam ary tr uc tio n tr eam em b ly tr uc tio n f rw ar e ng ne e r ng reverse e ng ne e r ng ary f ile b ar f ile figure 1 static binary translation framework machine instructions separation code data binarymanipulation tool faces problem unfortunately problem solvable general code data represented way von neumann machines makes static translation incomplete hence runtime support environment needed form interpreter example 21 dynamic binary translation framework dynamic binary translation actual translation process takes place needed basis whereas static binary translation attempts translate entire program figure 2 illustrates typical framework dynamic translator uses basic block unit translation ie granularity lefthand side similar static translator processing code done different level granularity typically one basic block time righthand side little different static translation first time basic block translated assembly code target machine emitted encoded binary form binary form run directly target machines memory well kept cache mapping source target addresses entire program basic block stored map basic block executed several times number executions reaches threshold optimizations code performed dynamically generate better code hot spot different levels optimization possible depending number times code executed optimized code replaces cached version basic blocks code processing basic blocks driven switch manager switch manager determines whether new translation needs performed determining whether entry corresponding source machine address map entry exists corresponding target machine address retrieved translation fetched cache match found switch manager directs decoding another basic block required source address 22 machineadaptable dynamic binary translation framework figure 3 extends figure 2 enable dynamic translator easily adapt different source target machines effort achieved clean separation concerns machinedependent information machineindependent analyses use specifications developer able concentrate writing descriptions properties machines instead rewrite tool use specifications support machinedependent information also generate parts system automatically provide skeleton user work seen figure 3 decoding binary file source bas ic b loc k sem tic mapper imp le op tim izations bas ic b loc k ins tr uc tion dec oder bas ic b loc k ins tr uc tion enc oder ms tr ans lato r bas ic b loc k binaryf ile dec oder op tim ized inary ins truc tions tream ms b inary ins truc tions tream ms b inary file ms rans lation cac add r es mapp ing r ms assemb ly ins truc tions semb ly enc oder ly ins truc tions r sw ch manager figure 3 machineadaptable dynamic binary translation framework bas ic b lo ck sem tic mapper imple izations bas ic b lo ck ins truc tion dec oder bas ic b lo ck ins truc tion encoder bas ic b lo ck ans lato bas ic b lo ck binary file dec oder emb ly truc tio ns ef fic ient ass em bly truc tio ns ary truc tio ns tream ms binary truc tio ns tream ms assemb ly truc tio ns ms binary file msrtls ans lation cache add r es mapping manager figure 2 dynamic binary translation framework machine rtls msrtls requires description binary file format program syntax semantics machine instructions particular processor experimented three different languages reusing sled language developing bff ssl languages bff binaryfile format language supports description binaryfiles structure 15 current formats supported dos exe solaris elf certain extent windows pe srl simple resourceable loader supports automatic generation code decode files specified using bff language sled specification language encoding decoding supports description syntax machine instructions ie binary assembly mnemonic representation 18 sled supported new jersey machinecode toolkit 13 toolkit provides partial support automatically generating instruction decoder particular sled specification current machines specified form include pentium sparc mips alpha ssl semantic specification language allows description semantics machine instructions ssl supported srd 16 srd semantic mapper component supports parsing ssl files storing information form dictionary instantiated dynamically output stage msrtls msrtls converted machineindependent rtls irtls analyses remove machine dependent concepts source machine process identifies source machines control transfers maps general forms irtl example following sparc msrtl call instruction associated highlevel call instruction irtl forms transfers control exist irtl jumps returns conditional unconditional branches irtl supports register transfers stack pushes pops highlevel control transfers condition code functions higherlevel instructions allow abstraction underlying machine irtls converted mtassembly instructions mapping functionality register transfers instructions available target machine assisted ssl specifications instruction encoding process supported sled specification language maps assembly instructions binary form code stored translators cache later reference example figure 4 shows various instruction transformations translation pentium machine instruction sparc machine instruction reverseengineering stage decodes pentium binary code 0000 0010 1101 1000 produce pentium assembly code lifted pentiumrtls finally abstracted irtl replacing machinedependent registers virtual registers forwardengineering phase encodes irtl sparc rtl sparc assembly instructions finally sparc binary code 23 specification requirements dynamic binary translation dynamic translation cannot afford timeconsuming analyses lift level representation stage resembles highlevel language per uqbt 14 uqbt static analyses recover procedure call signatures including parameters return values thereby allowing generated code use native calling parameter conventions target machine analyses used dynamic translation high performance degradation would experienced translation alternative costly analyses remove properties underlying source machine go halfway highlevel representation support inexpensive analyses recover basic form highlevel instructions conditional branches calls without parameters emulate rather abstract away conventions used hardware operating system source machine ie without using native conventions target machine steps possible specification features underlying hardware example emulate sparc architecture register windowing mechanism pentium machine specifying mechanism works sparc machine emulate pentium stack parameter passing convention however emulate sparc processor delayed transfers control support higher level branching instructions clearly compromise performance impact translated code provides fast way translating code optimized runtime becomes hotspot program order support translation msrtls irtls ssl language extended machine instruction level semantics include hardware semantics well example sparc architecture effects changing register windows register current window accessed specified pentium architecture properties stack movement specified information currently used uqbt uqdbt uqbt relies costly analysis abstract higherlevel information without depending lowlevel details underlying hardware addl ebx eax add o1 o2 o1 figure 4 pentium sparc example 3 research problems unlike dynamic binary translators written fixed set source destination machines mind uqdbt designed handle wide range cisc risc machine architectures translators directly map source machinespecific idioms target machine translators bound work sourcetarget pair extend translators support different machines extensive rewriting code needed direct idiom mapping machines different goal uqdbt provide framework modified extended ease support additional source target machines without need rewrite new translator scratch process finding generalization existing future machines nontrivial cannot fully predicted uqdbt uses uqbts approach specifying properties machine instruction sets widely available todays machines allowing user extend specification language support new features future machines reuse rest translation framework uqbt use multiplatform operating systems concentrate fundamental issues instruction translations uqdbts goal address following types research problems dynamic machineadaptable binary translation 1 best way supporting machinedependent machineindependent rtl translation main criteria translation efficiency hence expensive analyses option translation needs supported underlying specification language order generate msrtls contain enough information underlying ms machine 2 much state source machine needed dynamic translation effects specification properties machine 3 best way automating transformation rtls mtassembly code code selector automatically generated target machine specification 4 possible efficiently use specifications contain information operating system conventions calling parameter conventions used os communicate program example order use pentiums stack parameter convention code translated sparc architecture binary passes parameters registers analysis determine parameters needs first performed 31 implementation uqdbt experimenting right level description required order support dynamic translation based specifications experience lowlevel highlevel description underlying machine unsuitable view uqbts semantic specifications machines highlevel description describe machine instruction semantics specify underlying hardware supports control transfer instructions eg register windows delayed instructions sparc architecture uqbt detailed level information needed specification use calling conventions control transfer instruction semantic description languages used describe lowlevel details underlying machine languages suitable emulation purposes contain much information dynamic translation first problem addressed specifying hardware works relation control transfer instructions provides fast translation msassembly instructions informationrich msrtls extended ones avoiding need recover information runtime following types information described sparc pentium processors effects sparc register windowing mechanism stack properties memory alignment parameters return locations sparc machine allocates new set working registers time save instruction called words effectively provides infinite number registers program use effect sparc register windows captured extending ssl specifying registers accessed register windows change save restore instruction hence providing different set working registers provides accurate simulation target machines limited amount usable registers effects stack pointer different different types machines pentium machines stack pointer change indefinitely within given procedure risc machines stack pointer normally constrained preallocated stack frames fixed size includes enough space register spills procedure specifying stack changes original machine suggests ways code generator generate stack manipulation instruction target machine example simulating stack pushing popping sparc machine memory alignment places constraints machine state particular point program sparc frame pointer stack pointer need double word aligned thus code generator needs enforce conditions entry exit call differences machine calling conventions namely parameters passed return values stored play crucial part code generator constructs right setup calling native library functions sparc generally passes parameters registers pentium pushes stack information needed source target machines identify transformation parameters return values differences endianness source target machines requires byte swapping performed loading storing data byte swapping expensive process although pentium byte swapping quite easily takes sparc v8 instructions 32bit swap expensive process avoided possible particular running pentium binary sparc every push pop instruction appears quite often pentium programs require byte swapping heuristics used uqdbt avoid byte swapping pushing popping stack second problem related first one amount source machine state carried across depends effectiveness translation first problem areas easily specified unspecified carried across apparent within machineindependent rtl uqdbt control transfer instructions contain tag indicating process delayed slot instruction architectures support delayed slots third problem current work progress goal automatically construct code generator also determine best performance heuristics selecting target machine instruction encountering similar patterns patterns may never matched may nearly impossible match example trying pattern match sparc save instruction pentiumrtls experiences fourth problem suggest performance gain using native os conventions uqdbt currently simulates calling convention pentium programs sparc machine ie parameters passed stack instead registers remove simulated effect convert use native conventions one needs know much improvement offer direct machine simulation level conversion occur worth analysis dynamic binary translation environment 4 case study section show example small pentium program converted uqdbtps ps postfix indicates translations pentium sparc architectures run sparc machine programs solaris operating system main differences two test machines 1 sparc risc architecture whereas pentium cisc 2 sparc bigendian pentium littleendian 3 sparc passes parameters registers sometimes stack well pentium normally passes stack 41 basic block translations address mappings figure 5 disassembly hello world binary program compiled pentium machine running solaris first column source address seen pentium processor second third columns actual pentium binaries corresponding assembly representation 3 basic blocks 0x43676c8 save sp 132 sp 0x43676cc add sp 4 sp 0x43676d0 add i7 8 l0 0x43676d4 st l0 0x43676d8 mov sp l0 0x43676dc subcc l0 4 l0 0x43676e0 mov l0 sp 0x43676e4 mov fp l0 0x43676e8 st l0 0x43676f0 mov l0 fp 0x43676f4 mov sp l0 0x43676f8 subcc l0 4 l0 0x43676fc mov l0 sp 0x4367704 add l0 0x3f8 l0 0x80493f8 0x4367708 st l0 ld 0x4367714 mov sp l1 0x4367718 sethi hi0xfffffc00 l2 0x4367720 sp l2 sp 0x4367724 fp l2 fp 0x4367728 sethi hi0xef663400 g6 0x4367730 nop 0x4367734 mov l1 sp 0x4367738 mov l0 fp 0x4367740 add g5 0x125 g5 0x4367744 sethi hi0x41bfc00 g6 0x4367748 call g6 0x436774c nop figure 7 generated sparc assembly 1 st bb figure 8048919 8b ec movl espebp 8048920 e8 9b fe ff ff call 0xfffffe9b 8048925 804892a eb 00 jmp 0x0 804892c c9 leave 804892d c3 ret figure 5 hello world x86 disassembly 8048918 push r29 804891b push 134517752 8048925 32 rtmp1 r28 804892a jump 0x804892c figure bbs program first bb 4 instructions 0x8048918 0x8048920 second bb 3 instructions 0x8048925 0x804892a third bb 2 instructions 0x804892c 0x804892d figure 6 shows intermediate representation irtls bbs note translation done incrementally ie bb decoded separately runtime uqdbtps works source machines address space translates basic block time data text source pentium program mapped actual machines source address space even though actually running sparc machine example pentium program data text sections located 0x8040000 0x8048000 mapped exactly addresses even though typical sparc program expects text data addresses 0x10000 0x20000 uqdbtps also simulates pentium machines environment sparc generated code ie pushing popping temporaries parameters pentium machine preserved generated code uqdbtps tries generate code quickly possibly little optimization 42 pentium stack simulation figure 7 sparc code generated first bb figure 6 first four instructions simulate pentium main prologue setting stack storing return address obtained value i7 bytes stack space reserved initial save sp 132 sp space used sparc processor store parameters return structures local variables register spills hence actual simulated pentium stack pointer esp starts sp0x84 see figure 8 pentiums ebp mapped sparc register fp pushing handled subtracting size value pushed sp storing result sp0x84 popping removes sp0x84 increments sp appropriate size 43 function calls stack alignments pentium actual parameters function calls passed stack sparc parameters passed registers printf format string hello world address 0x80493f8 pushed instruction 804891b see figure 5 successfully call native sparc printf function address must stored register o0 instruction 0x436770c figure 7 equivalent printf sparc 0xef6635b8 call function made instruction 0x436772c calls library functions printf assumed uqdbtps exist source well target machine assumption restrictive long mapping source library function equivalent function target machine ie libraries reproduced target machine translation rewriting produce mapping translators fx32 make assumption sparc machines expect sp fp aligned double word 64 bits boundaries therefore calling native library function sp fp need 8byte aligned current values restored function call returns instructions 0x4367734 0x4367738 end basic block control passed back uqdbtps switch manager indication next basic block address processed g5 0x8048925 case role switch manager decide whether start translation indicated g5 fetch already translated bb translation cache case next bb starts 0x8048925 address translation map hence translation starts new address figure 9 shows generated sparc assembly next bb pentium program r e e r r e e r c k p figure 8 sparc stack frame 0x435ff58 sethi hi0x4485c00 l0 0x435ff64 st l1 l0 0x435ff68 mov sp l0 0x435ff6c addcc l0 4 l0 0x435ff70 mov l0 sp 0x435ff74 sethi hi0x42b7000 l0 0x435ff78 add l0 0x3d4 l0 0x42b73d4 0x435ff7c rd ccr l1 0x435ff80 st l1 l0 0x435ff84 sethi hi0x4486000 l0 0x435ff88 add l0 0x18 l0 0x4486018 ld l1 l1 0x435ff98 sethi hi0x4486000 l2 ld l2 l2 0x435ffa4 xorcc l1 l2 l1 0x435ffa8 st l1 l0 0x435ffb4 rd ccr l1 0x435ffb8 st l1 l0 0x435ffc4 sethi hi0x41bfc00 g6 0x435ffc8 call g6 0x435ffcc nop figure 9 generated sparc assembly 2 nd bb figure 6 44 register mapping condition codes translation pentium registers mapped virtual registers ie memory locations access virtual register sparc machine sethi add instruction used example instructions 0x435ff84 0x435ff88 figure 9 used access virtual register representing x86 register eax instructions sparc affect condition codes flags unless explicitly indicated instruction almost pentium instructions affect flags pentium instruction affects status flags simulated using equivalent condition code version instruction sparc machine instructions 0x435ff6c 0x435ffa4 condition codes read instruction 0x435ff7c saved virtual flag register instruction 0x435ff80 instructions preserve current value retrieved later required closer look example shows generated code efficient simple optimizations forward substitutions dead code elimination greatly reduce size generated code optimizations yield better code take longer generate trade code quality speed code generator backend uqdbtps fast despite poor quality generated code currently implementing ondemand optimizations hotspots program well performing register allocation 5 preliminary results uqdbt based uqbt framework frontend reused uqbt changing granularity decoding procedure level basic block level frontend uses extended ssl specifications generates msrtls machine instruction encoding routines backend automatically generated sled specifications using toolkit section shows preliminary results obtained two dynamic translators instantiated uqdbt framework uqdbtps pentium sparc uqdbtss sparc sparc looks types optimizations need introduced order improve performance frequently executed code gives reader idea effort gone development framework amount reuse expected 51 performance microbenchmark results obtained using pentium mmx machine ultrasparc ii 250 mhz machine running solaris operating system results reported herein translation overhead currently make use dynamic optimizations register caching within basic blocks clearly performance generated binaries uqdbt without optimization inferior direct native compilation typical 110 ratio ie 1 source machine instruction 10 target machine instructions expected typical emulatorinterpreter without caching uqdbtps gives figures close ratio example 9 pentium instructions figure 5 95 sparc instructions generated ratio similar emulation speed gained uqdbt comes reusing already translated bbs translation cache piece code executed present form uqdbt still early development hence provide preliminary results uqdbtps pentium sparc translator uqdbtss sparc sparc translator undoubtedly true little practical use sparc sparc translation unless runtime optimizations significantly speed translated programs inclusion translation show effect machineadaptability uqdbt translation sparc binaries irtl removes machine dependencies thus irtl sparc code generation uqdbtss unaware fact source machine sparc also true uqdbtps since little analysis done decoded instructions processing concentrated decoding code generation requested switch manager better reflects performance impact use ondemand techniques prior introducing optimizations test programs showed tables sieve 3000 prints first 3000 prime numbers fibonacci 40 mbanner prints banner elf string 500000 times sieve mainly contains register register manipulation fibonacci lot recursive calls mbanner lot stack operations accesses array data tables show times translation execution programs using uqdbtps uqdbtss compared natively gcc o0 compiled programs source programs also o0 compiled column 2 shows preprocessing time needed actual translation takes place note uqdbtps takes longer start uqdbtss pentium larger instruction set hence larger ssl specification file takes longer process also caused different page alignment sizes pentium sparc result extra steps taken ensure text data sections loaded correctly sparc machine column 3 shows total time spent decoding source instructions transforming irtls generating final sparc code column 4 shows execution time generated sparc code without using register caching ie every register access done virtual registers column 5 shows execution time generated sparc code register caching yields 15 50 percent performance gain column 6 natively compiled gcc version program sparc comparing columns 5 6 gives relative performance translators figures suggest 2 6 times slowdown running programs using uqdbtps uqdbtss slow performance translated fibonacci program uqdbtss caused effects register windowing mechanism sparc carried forth irtls since irtls unaware fact source target machines causes entire register windowing system simulated generated code given ondemand optimizations performed yet quality generated code comparable o0 optimization level traditional compiler tables 3 4 show efficiency translators relative size original program column 2 size programs text area note bytes necessarily represent instructions code necessarily reachable executed runtime column 3 shows actual bytes decoded translator runtime number varies column 2 since valid paths runtime translated sometimes retranslation needed jump middle bb made columns 4 5 show number bytes code generated translator withoutwith register caching register caching done basic block level cached registers copied back memory locations end basic block comparing column 5 column 3 gives relative ratio bytes generated versus bytes decoded figures suggest average byte source machine translates around 7 10 bytes target sparc code last column ratio machine cycles bytes source code gives rough indication performance translation ultrasparc ii 250mhz translators require 180000 machine cycles per byte input source 10 times cycles used traditional o0 compiler 52 optimizations future work programs spend 90 time small section code hotspots worthwhile dynamic binary translator spend time optimizing uqdbt currently perform optimizations next revision uqdbt contain optimizations triggered counters counters inserted basic blocks indicate number times particular basic block executed runtime certain threshold reached indicating program spends significant time piece code optimizer invoked attempt produce efficient code four levels optimization provided uqdbt progressively certain thresholds reached 1 register liveness analysis forward substitution constant propagation improves quality generated code reduces number instructions executed 2 register allocation rigorous process removing access virtual registers replacement allocation hardware registers target machine assisted liveness information rather caching registers basic block level 3 code movement moving joining frequently executed bbs closer together thus reducing transition costs calls jumps 4 customization create specialized versions bbs found fixed range runtime values within bb eg repeated entry bb register variable contains value 90 time 53 effort order give reader idea effort gone development uqdbt effort reusing system quantify effort follows uqdbt effort 1 person period 15 years experimenting amount specification required semantic level different machines effort performed person already familiar uqbt worked ssl past uqdbts current implementation size 18500 lines source code c 3300 lines partiallygenerated code lines 1000 sparc 2500 pentium test programs pre processing translation time execution time without reg caching execution time simple reg caching native gcc compiled test programs pre processing translation time execution time without reg caching execution time simple reg caching native gcc compiled fibonacci 052 007 16223 13935 4118 fibonacci 022 012 25605 19897 4118 mbanner 050 034 19100 12628 2285 mbanner 021 050 20409 9709 2285 test programs original program size source bytes decoded target bytes generated wo reg caching target bytes generated w reg caching 1000 cycles source byte test programs original program size source bytes decoded target bytes generated wo reg caching target bytes generated w reg caching 1000 cycles source byte fibonacci 102 94 1188 1104 186 fibonacci 220 176 1764 1468 170 mbanner 483 467 4548 3816 182 mbanner 748 760 7112 5032 164 table 4 uqdbtss sparc sparc translation table 1 uqdbtps pentium sparc translation second table 2 uqdbtss sparc sparc translation seconds table 3 uqdbtps pentium sparc translation specification files user uqdbt framework would able reuse source code would need write syntax semantics specification files new machines reuse existing ones figures final stage dynamic optimizations implemented yet nevertheless gives indication amount reuse code system 6 discussion preliminary results uqdbt point tradeoffs machineadaptability return writing less code support two particular machines performance penalty generated code seen stage binary translation writer would expected write specifications new machines order thousand lines code reuse good part 18500 lines code reaping benefits reuse time efficiency however stage uqdbt generates code performs speed emulated code therefore user seeing 10x performance degradation translated programs introduction register caching generated code brought factor 6 expect introduction ondemand optimizations hotspots program improve performance generated code bringing performance factor 2x3x one main questions dealt throughout experiments area much specified much supported hand level detail specification make translator faster slower full details machine specified specification suitable generating emulator supports 100 machine however provide means eliminating part emulation process different type specification needed tried achieve semantic specifications use two intermediate languages rtl language describes lowlevel machine specific aspects machine uqdbt finds support specifications perform simple analyses lift level representation irtl aim perform simple transformations code expensive time generic enough suitable intermediate representations irtl different hrtl highlevel intermediate representation used static uqbt framework hrtl expensive analyses recover parameters procedures return values hence allowing code generator use native calling conventions target machine rtl code generator makes use specification stack example order pass parameters stack without ever determining locations parameters procedure calls however notion parameters needed order interface correctly native library functions pass parameters right locations also experience modules may better written hand without specifying complete semantics features machine unique example one could consider implementing sparcspecific module supporting register windowing semantics better register allocation performed case present specified register windowing mechanism generated code puts registers virtual memory locations use register caching memory locations mirrored hardware registers target machine improving somewhat performance program however still large overhead copying registers virtual locations call return reduced dead code elimination perhaps hand written code would achieved better code another aspect take consideration granularity translation uqdbt granularity unit processing basic block bb time code generation link made switch manager exit bb flushing cached registers virtual registers performed needed keep data accurately stored consistent across transitions one bb another transitions one bb next go via switch manager next bb translated yet using bb unit translation restricts effectiveness register allocation since bbs relatively small difficult determine register liveness information data collected across bb boundaries unit granularity changed could yield better code cases worse code others example translation unit might changed bb procedure time would allow code generator reduce amount flushing cached registers hence reduce number instructions need executed runtime would improve effectiveness allocating registers code generation since liveness information could collected using larger unit translation procedure may involve decoding paths may ever taken runtime thus generating code executed obvious granularity unit since types programs benefit using particular granularity unit others may suffer program lot small procedures benefit unit translation procedure suffer program lot conditional branches 7 conclusion uqdbt machineadaptable dynamic binary translator framework capable configured different source target machines specifications properties machines uqdbt framework modified extended ease support additional source target machine architectures without need write new translator scratch case study shows translation process two different architectures complex challenging using machineadaptable dynamic translation techniques nevertheless preliminary results suggest performance implementing ondemand processing dynamic system done efficiently despite research problems remain building fully machineadaptable dynamic translation framework uqdbt appears promising model provide generic dynamic binary translation framework 8 acknowledgments authors wish thank mike van emmerik helpful discussions implementation testing strategies members kanban group sun microsystems inc whose system motivated work work part university queensland binary translation uqbt project information obtained project visiting following url httpwwwcseeuqeduaucsmuqbthtml 9 r binary translation macintosh application environment httpwww digital fx efficiently run mac programs pcs embra fast flexible machine simulation self power simplicity kaashoek tcc system fast michalstrok new jersey machinecode toolkit design resourceable retargetable binary translator specifying semantics machine instructions fast instructionset simulated execution profiling specifying representation machine instructions preliminary experiences use uqbt binary translation framework tr self power simplicity binary translation shade fast instructionset simulator execution profiling embra specifying representations machine instructions fast effective code generation justintime java compiler outoforder execution technique runtime binary translators srl 34a simple retargetable loader design resourceable retargetable binary translator specifying semantics machine instructions ctr naveen kumar bruce r childers daniel williams jack w davidson mary lou soffa compiletime planning overhead reduction software dynamic translators international journal parallel programming v33 n2 p103114 june 2005 lian li jingling xue tracebased leakage energy optimisations link time journal systems architecture euromicro journal v53 n1 p120 january 2007 david ung cristina cifuentes dynamic binary translation using runtime feedbacks science computer programming v60 n2 p189204 april 2006 lian li jingling xue tracebased binary compilation framework energyaware computing acm sigplan notices v39 n7 july 2004 giuseppe desoli nikolay mateev evelyn duesterwald paolo faraboschi joseph fisher deli new runtime control point proceedings 35th annual acmieee international symposium microarchitecture november 1822 2002 istanbul turkey jason hiser daniel williams wei hu jack w davidson jason mars bruce r childers evaluating indirect branch handling mechanisms software dynamic translation systems proceedings international symposium code generation optimization p6173 march 1114 2007 gregory sullivan derek l bruening iris baron timothy garnett saman amarasinghe dynamic native optimization interpreters proceedings workshop interpreters virtual machines emulators p5057 june 1212 2003 san diego california bruening timothy garnett saman amarasinghe infrastructure adaptive dynamic optimization proceedings international symposium code generation optimization feedbackdirected runtime optimization march 2326 2003 san francisco california john aycock brief history justintime acm computing surveys csur v35 n2 p97113 june
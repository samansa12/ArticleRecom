trading conflict capacity aliasing conditional branch predictors modern microprocessors employ deeper pipelines issue multiple instructions per cycle becoming increasingly dependent accurate branch prediction hardware resources branchpredictor tables invariably limited possible hold relevant branch history active branches time especially large workloads consisting multiple processes operatingsystem code problem results commonly referred aliasing branchpredictor tables many ways similar misses occur finitesized hardware cachesin paper propose new classification branch aliasing based threecs model caches show conflict aliasing significant source mispredictions unfortunately obvious method removing conflicts adding tags associativity predictor tables costeffective solutionto address problem propose skewed branch predictor multibank tagless branch predictor designed specifically reduce impact conflict aliasing analytical simulation models show skewed branch predictor removes substantial portion conflict aliasing introducing redundancy branchpredictor tables although redundancy increases capacity aliasing compared standard onebank structure comparable size simulations show reduction conflict aliasing overcomes effect yield gain prediction accuracy alternatively show skewed organization achieve prediction accuracy standard onebank organization half storage requirements b branchpredictor tables although redundancy increases capacity aliasing compared standard onebank structure comparable size simulations show reduction conflict aliasing overcomes effect yield gain prediction accuracy alternatively show skewed organization achieve prediction accuracy standard onebank organization half storage requirements keywords branch prediction aliasing 3 cs classification skewed branch predictor intel microcomputer research lab oregon c 1997 association computing machinery inc permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage new copies bear notice full citation first page copyrights components work owned others acm must honored abstracting credit permitted copy otherwise republish post servers redistribute lists requires prior specific permission andor fee request permissions publications dept acm inc fax 1 212 8690481 permissionsacmorg 1 introduction related work processors speculatively fetch issue multiple instructions per cycle deep pipelines dozens instructions might flight branch resolved conditions mispredicted branch result substantial amounts wasted work become bottleneck exploiting instructionlevel parallelism accurate branch prediction come play important role removing bottleneck many dynamic branch prediction schemes investigated past years offering certain distinctive features however share common characteristic rely collection 1 2bit counters held predictor table entry table records recent outcomes given branch substream 21 used predict direction future branches substream branch substream might defined bits branch address bit pattern representing previous branch directions known branch history combination branch address branch history bits target addresses previous branches 14 7 18 10 8 9 ideally would like predictor table infinite capacity every unique branch substream defined ad dress history pair dedicated predictor chen et al shown twolevel predictors close optimal provided unlimited resources implementing predictors 3 realworld constraints course permit chip diearea budgets accesstime constraints limit predictortable size tables proposed literature constrained directmapped without tags fixedsized predictor tables lead phenomenon known aliasing interference 21 16 multiple address tory pairs share entry predictor table causing predictions two branch substreams intermingle aliasing classified either destructive ie misprediction occurs due sharing predictortable entry harmless ie effect prediction constructive ie aliasing occasionally provides good prediction would wrong otherwise 21 young et al shown constructive aliasing much less likely destructive aliasing 21 recent studies shown large multiprocess workloads strong os component exhibit high degrees aliasing 11 5 require much larger predictor tables previously thought necessary achieve level accuracy close ideal unaliased predictor table 11 therefore expect new techniques removing conflict aliasing could provide important gains towards increased branchprediction accuracy branch aliasing fixedsize directmapped predictor tables many ways analogous instructioncache datacache misses suggests alternative classification branch aliasing based threecs model cache performance first proposed hill 6 cache misses aliasing classified compul sory capacity conflict aliasing similarly caches larger predictor tables reduce capacity aliasing associativity predictor table could remove conflict aliasing unfortunately simpleminded adaptation cache associativity would require addition costly tags substantially increasing cost predictor table paper examine alternative approach called skewed branch prediction borrows ideas skewedassociative caches 12 skewed branch predictor constructed odd number typically 3 5 predictortable banks functions like standard tagless predictor table performing prediction bank accessed parallel different indexing function majority vote resulting lookups used predict direction branch next section explain greater detail aliasing clas sification section 3 quantify aliasing assess effect conflict aliasing overall branchprediction accuracy section 4 introduce skewed branch predictor hardware structure designed specifically reduce conflict aliasing section 5 show skewed branch predictor removes conflict aliasing effects cost redundancy analysis includes simulation analytical models performance considers range possible skewed predictor configurations driven traces instructionbenchmark suite ibs 17 includes complete user operatingsystem activity section 6 proposes enhanced skewed branch predictor slight modification skewed branch predictor enables attractive tradeoffs capacity conflict aliasing section 7 concludes study proposes future research directions aliasing classification throughout paper focus globalhistory prediction schemes sake conciseness globalhistory schemes use branch address pattern global history bits described 18 19 20 10 8 previouslyproposed global history predictors directmapped tagless given history length distinguishing feature predictors hashing function used map set address history pairs onto predictor table gshare gselect schemes 8 studied global schemes gselect corresponds gas yeh patts terminology 18 19 20 gshare loworder address bits global history bits xored together form index value 1 whereas gselect loworder address bits global history bits concatenated aliasing occurs directmapped tagless predictors two address history pairs map entry measure aliasing particular global scheme table simulate structure number entries using indexing function predictor table considered however instead storing 1bit 2bit predictors structure store identity last address history pair accessed en try aliasing occurs indexing address history pair different stored pair aliasing ratio ratio number aliasing occurrences number dynamic conditional branches measured way see relationship branch aliasing cache misses simulated tagged table like cache line size one datum aliasing occurrence corresponds cache miss 1 number history bits less number index bits history bits xored higherorder end section loworder address bits explained 8 benchmark conditional branch count dynamic static groff 11568181 5634 gs 14288742 10935 mpeg play 8109029 4752 real gcc 13940672 16716 verilog 5692823 3918 table 1 conditional branch counts widelyaccepted classification cache misses threecs model first introduced hill 6 later refined sugumar abraham 15 threecs model divides cache misses three groups depending causes ffl compulsory misses occur address referenced first time unavoidable misses required fill empty cold cache ffl capacity misses occur cache large enough retain addresses rereferenced future capacity misses reduced increasing total size cache ffl conflict misses occur two memory locations contend cache line given window time conflict misses reduced increasing associativity cache improving replacement algorithm aliasing branchpredictor tables classified similar fashion ffl compulsory aliasing occurs branch substream encountered first time ffl capacity aliasing like capacity cache misses due pro grams working set large fit predictor table reduced increasing size predictor table ffl conflict aliasing occurs two concurrentlyactive branch substreams map predictortable entry methods reducing component aliasing yet knowledge appeared published literature quantifying aliasing 31 experimental setup conducted tracedriven simulations using ibs ultrix benchmarks 17 benchmarks traced using hardware monitor connected mipsbased decstation running ultrix 31 resulting traces include activity userlevel processes well operatingsystem kernel determined researchers good test branchprediction performance 5 11 conditional branch counts 2 derived traces given table 1 although simulated sdet video play benchmarks exhibited special behavior compared bench marks therefore omit sdet video play results paper interest saving space beq r0r0 used unconditional relative jump mips compiler therefore consider conditional explains discrepancy branch counts reported 5 11 4bit history benchmark substream compulsory misprediction ratio aliasing 1bit 2bit gs 191 015 703 528 mpeg play 183 011 908 724 real gcc 236 028 938 716 verilog 196 013 648 457 12bit history benchmark substream compulsory misprediction ratio aliasing 1bit 2bit groff 714 035 363 256 gs 795 061 371 277 mpeg play 627 037 585 452 real gcc 1290 155 490 393 verilog 924 064 374 266 table 2 unaliased predictor first simulated ideal unaliased scheme ie predictor table infinite size misprediction ratios obtained shown table 2 history lengths 4 12 bits 1bit 2bit predictors include unconditional branches part globalhistory bits address history pair encountered first time count misprediction compulsory miss contribution mispredictions reported last two columns table 2 2bit saturating counter gives better prediction accuracy unaliased predictor table 1bit predictor intuition difference due mainly loop branches also measured substream ratio define average number different history values encountered given conditional branch address see first column table 2 compulsoryaliasing percentage computed number different address history pairs referenced throughout trace divided total number dynamic conditional branches table 2 observe compulsory aliasing 12bit history length generally constitutes less 1 total dynamic conditional branches except case real gcc exhibits compulsoryaliasing rate 155 32 quantifying conflict capacity aliasing quantify conflict capacity aliasing simulated tagged predictor tables holding address history pairs figures 1 2 show miss ratio directmapped dm fullyassociative tables using 4 bits 12 bits global history respec tively two directmapped tables indexed gshare gselectlike function fullyassociative table uses least recentlyused lru replacement policy miss ratio fullyassociative table gives sum compulsory capacity aliasing difference gshare gselect fullyassociative table gives amount conflict aliasing corresponding gshare gselect predictors noted lru optimal replacement policy 15 however bases decisions solely past information lru policy gives reasonable base value amount conflict aliasing removed hardwareonly scheme appears benchmarks gselect higher aliasing rate gshare explains given table size history length gshare lower misprediction rate gselect claimed 8 difference pronounced 12 bits global history case gselect uses small number address bits eg 4 address bits 64kentry table figure 1 shows number entries larger equal 4k capacity aliasing nearly vanishes leaving conflicts overwhelming cause aliasing condition holds figure 2 table sizes greater 16k leads us conclude amount associativity branch prediction tables needed limit impact aliasing 33 problems associative predictor tables associativity caches introduces degree freedom avoiding conflicts directmapped cache tag bits used determine whether reference hits misses associative cache tag bits also determine precise location requested data cache speculative nature directmapped branch prediction table tagless implement associativity however must introduce tags identifying address history pairs un fortunately tag width disproportionately large compared width individual predictors usually 1 2 bits wide another method achieving benefits associativity without pay cost tags needed skewed branch predictor described next section one method 4 skewed branch predictor previously noted behaviors gselect gshare different even though two schemes based address history information illustrated figure 3 represent gshare gselect table 16 entries example conflict gshare gselect address history pairs conflict conclude precise occurrence conflicts strongly related mapping function skewed branch predictor based observation basic principle skewed branch predictor use several branchpredictor banks 3 banks example illustrated figure 4 index different independent hashing functions computed vector v information eg branch address global history prediction read banks majority vote used select final branch direction rationale using different hashing functions bank two vectors v w aliased one bank unlikely aliased banks destructive aliasing v w may occur one bank overall prediction v likely correct v suffer destructive aliasing banks 41 execution model consider two policies updating predictors across multiple banks ffl total update policy three banks updated sole bank traditional prediction scheme ffl partial update policy bank gives bad prediction updated overall prediction good groff gs mpeg play26101418512 1k 2k 4k 8k 16k 32k 64k number entries dm gselect dm gshare fa lru51525 number entries dm gselect dm gshare number entries dm gselect dm gshare fa lru nroff real gcc verilog261014 number entries dm gselect dm gshare fa lru51525 number entries dm gselect dm gshare fa lru51525 number entries dm gselect dm gshare fa lru figure 1 miss percentages tables tagged address history pairs 4bit history groff gs mpeg play515254k 8k 16k 32k 64k 128k 256k 512k number entries dm gselect dm gshare fa lru515254k 8k 16k 32k 64k 128k 256k 512k number entries dm gselect dm gshare fa lru51525 number entries dm gselect dm gshare fa lru nroff real gcc verilog51525 number entries dm gselect dm gshare fa lru5152535 number entries dm gselect dm gshare fa lru515254k 8k 16k 32k 64k 128k 256k 512k number entries dm gselect dm gshare fa lru figure 2 miss percentages tables tagged address history pairs 12bit history gselect history address figure 3 conflicts depend mapping function history address vote majority figure 4 skewed branch predictor wrong predictor considered attached another ad dress history pair overall prediction wrong banks updated dictated outcome branch 42 design space chosing information branch address history etc used divide branches substreams open problem purpose section discuss relevance using combination information show conflict aliasing effects removed using skewed predictor organization remainder paper vector information used recording branchprediction information concatenation branch address k bits global set v functions f0 f1 f2 used indexing three 2 n entry banks experiments proposed skewedassociative cache 13 consider decomposition binary representation vector v bit substrings v3 v2 v1 v1 v2 two nbit strings consider function h defined follows phi xor exclusive operation define three different mapping functions follows information functions found 13 interesting property functions two distinct vectors v 3 v 2 v 1 w3 w2w 1 map entry bank conflict banks 1 function family exhibiting property might used defined implementation skewed branch predic tor position evaluate check behavior conventional globalhistory schemes purposes comparison use gshare global scheme referencing standard singlebank organization skewed branch predictor described earlier also referred gskewed remainder paper 5 analysis 51 simulation results aim section evaluate costeffectiveness skewed branch predictor via simulation skewed branch predictor prediction associated branch history pair recorded three times intuitive impact conflict aliasing lower skewed branch predictor directmapped gshare table however total number predictor storage bits allocated scheme clear gskewed yield better results redundancy makes gskewed work also effect increasing degree capacity aliasing among fixed set predictor entries said differently may better simply build onebank predictor table 3 times large rather 3bank skewed table number entries gshare number entries gshare gskewed74788286994 number entries gshare gskewed nroff real gcc verilog3844244462k 4k 8k 16k 32k 64k number entries gshare number entries gshare number entries gshare gskewed figure 5 misprediction percentage 4bit history groff gs mpeg play3458k 16k 32k 64k 128k 256k number entries gshare number entries gshare number entries gshare gskewed nroff real gcc verilog2535458k 16k 32k 64k 128k 256k number entries gshare number entries gshare number entries gshare gskewed figure misprediction percentage 12bit history history length gshare 16k gskewed history length gshare 16k gskewed 3x4k55657585 history length gshare 16k gskewed 3x4k nroff real gcc verilog263343842 history length gshare 16k gskewed history length gshare 16k gskewed history length gshare 16k gskewed 3x4k figure 7 misprediction percentage 3x4kgskewed vs 16kgshare direct comparison gshare gskewed used 2bit saturating counters partial update policy gskewed varying prediction table size results history size 4 bits 12 bits plotted figures 5 6 respectively large spectrum table sizes interesting region graphs capacity aliasing gshare vanished region skewed branch predictor partial update policy achieves prediction accuracy 1bank pre dictor requires approximately half storage resources benchmarks wide spectrum predictor sizes skewed branch predictor consistently gives better prediction accuracy 1bank predictor noted using skewed branch predictor history length 4 12 little benefit using 3x4k 3x16k entries increasing number entries 64k 256k gshare still improves prediction accuracy notice skewed branch predictor able remove pathological cases appears clearly figure 6 nroff varying history length given prediction table size history length better others figure 7 illustrates miss rates 3x4kentry gskewed vs 16kentry gshare varying history length plots show despite using 25 less storage resources gskewed outperforms gshare benchmarks except real gcc varying number predictor banks also considered skewed configurations five predictor banks simulations results reported showed little benefit increasing number banks five appears 3bank skewed branch predictor removes significant part conflict alias ing costeffective use resources would increase size banks rather increase number update policy verify gskewed effective removing conflict aliasing compare 3lambdanentry gskewed branch predictor fullyassociative nentry lru table figure 8 illustrates experiment global history length 4 bits 2bit saturating counters address history pairs missing fullyassociative table static prediction always taken assumed gskewed partialupdate totalupdate policies shown appears 3nentry gskewed table partial update delivers slightly better behavior nentry fullyassociative table uses totalupdate policy exhibits slightly worse behavior conclude 3xnentry gskewed predictor partial update delivers approximately performance nentry fullyassociative lru predictor reason partial update better total update tuitive partial update 2 banks give good prediction third bank gives bad prediction update third bank updating third bank enable contribute correct prediction different substream effectively increase capacity predictor table whole 52 analytical model although simulation results show skewed predictor table offers attractive alternative standard onebank predictor structure provide much explanation skewed organization works section present analytical model helps better understand technique effective make analytical modeling tractable make simplifying assumptions assume 1bit automatons total update policy begin defining table aliasing probabil ity consider hashing function f maps address history fa lru gskewed tu gskewed pu681012 fa lru gskewed tu gskewed pu758595105 fa lru gskewed tu gskewed pu nroff real gcc verilog3842465512 1k 2k 4k 8k 16k 32k fa lru gskewed tu gskewed pu8101214 fa lru gskewed tu gskewed pu56789 fa lru gskewed tu gskewed pu figure 8 misprediction percentage 3nentry gskewed vs nentry fullyassociative lru pairs onto nentry table aliasing probability dynamic reference address history defined follows let lastuse distance v ie number distinct address history pairs encountered since last occurrence v assuming f distributes vectors equally table ie assuming f good hashing function aliasing probability dynamic reference v n much greater 1 get good approximation n 2 aliasing probability function ratio lastuse distance number entries aliasing probability b probability address history pair biased taken 1 bit predictors entry aliased probability prediction given entry differs unaliased prediction noted aliasing less likely destructive b close 0 1 b close 12 assuming total update policy use different hashing functions indexing three banks events bank correlated events bank consider particular dynamic reference v four cases occur 1 probability aliased three banks prediction unaliased prediction 2 probability aliased one bank two banks resulting majority vote direction unaliased prediction 3 probability 3p aliased two banks remaining one probability predictions aliased banks different unaliased prediction overall prediction different unaliased prediction 4 probability p 3 v aliased three banks probability predictions different unaliased prediction least two prediction banks skewed prediction different unaliased prediction summary probability prediction 3bank skewed predictor differs unaliased prediction contrast formula directmapped 1bank predictor table pdm psk plotted figure 9 worst case psk 4 pdm 2 main characteristic skewed branch predictor mispredict probability polynomial function aliasing probability relevant region curve per bank aliasing probability p low magnifies curve small aliasing probabilities comparable storage resources 3bank scheme greater perbank aliasing probability 1bank scheme bank smaller number entries taking account formula 1 find 3xn3entry gskewed psk lower pdm nentry directmapped table lastuse distance less approximately n n psk exceeds pdm mispredict overhead perbank aliasing probability 3 banks figure 9 destructive aliasing05 mispredict overhead perbank aliasing probability 3 banks figure 10 destructive aliasing highlights tradeoff takes place skewed branch predictor gain short lastuse distance references traded loss long lastuse distance references consider nentry fullyassociative lru table lastuse distance less n hit otherwise miss hence predictor table aliasing short lastuse distance references conflict aliasing aliasing long lastuse distance references capacity aliasing words skewed branch predictor trades conflict aliasing capacity aliasing verify mathematical model meaningful extrapolated misprediction rate gskewed measuring dynamic address history pair applied formulas 1 3 address history pair encountered first time applied formula 3 1 bias probability b evaluated entire trace measuring density static ad dress history pairs bias taken value found fed back simulator applying formula 3 trace finally added unaliased misprediction rate table 2 contribution compulsory aliasing mispredictions appears mispredict overhead results shown figure 11 history length 4 noted model always slightly overestimates misprediction rate explained constructive aliasing phenomenon reported 21 noted made simplifying assumptions devised analytical model difficulty extending model partialupdate policy occurrences aliasing bank depend happens banks modeling effect using 2bit automatons also difficult 2bit automaton removes part aliasing effects prediction despite limitations model effectively explains skewed branch prediction works standard onebank table mispredict overhead increases linearly aliasing probability mbank skewed organization increases mth degree polynomial deal perbank aliasing probabili ties range 0 1 polynomial growth rate preferable linear one 6 enhanced skewed branch predictor using short history vector limits number address tory pairs see substream ratio column table 2 therefore amount capacity aliasing hand using long history length leads better intrinsic prediction accuracy unaliased predictors results large number address tory pairs ideally given fixed transistor budget one would like benefit better intrinsic prediction accuracy associated long history lower aliasing rate associated short history selecting good history length essentially tradeoff accuracy unaliased predictor aliasing probability effect conflict aliasing skewed branch predictor shown negligible capacity aliasing remains major issue section propose enhancement skewed branch predictor removes portion capacity aliasing effects without suffering increased conflict aliasing enhanced skewed branch predictor complete information vector ie branch history address used hashing functions f1 f2 indexing bank 1 bank 2 previous gskewed scheme function f0 indexes bank 0 use usual bit truncation branch address address mod 2 n rationale modification follows consider enhanced gskewed gskewed using history length l address history pair h lastuse distance dl three banks gskewed banks 1 2 enhanced gskewed enhanced gskewed address used indexing bank 0 lastuse distance ds address bank 0 shorter dl two situations occur 1 dl small compared bank size aliasing probability bank either gskewed enhanced gskewed small gskewed enhanced gskewed likely deliver prediction unaliased predictor history length l predictions present least two banks 2 dl becomes large compared bank size aliasing probability pl bank gskewed banks 1 2 enhanced gskewed becomes close 1 formula 2 previous section designs predictions banks 1 2 differ overall prediction equal prediction bank 0 since ds dl aliasing probability ps bank 0 enhanced gskewed lower aliasing probability pl bank 0 gskewed dl high better intrinsic prediction accuracy associated long history bank 0 gskewed cannot compensate increased aliasing probability bank 0 intuition history length short first situation dominate predictors deliver equivalent entriestable extrapol gskewed meas gskewed8101214 entriestable extrapol gskewed meas gskewed95105115125135 entriestable extrapol gskewed meas gskewed nroff real gcc verilog525666468512 1k 2k 4k 8k 16k 32k entriestable extrapol gskewed meas gskewed1012141618 entriestable extrapol gskewed meas gskewed791113 entriestable extrapol gskewed meas gskewed figure extrapolated vs measured misprediction percentage prediction longer history length second situation occur often enhanced gskewed deliver better overall prediction gskewed simulation results figure 12 plots results simulations vary history length 3x4kentry enhanced gskewed 3x4kentry gskewed 32kentry gshare partialupdate policy used experiments curves gskewed enhanced gskewed nearly indistinguishable certain history length point different benchmark curves begin diverge enhanced gskewed exhibiting lower mispredication rates longer history lengths based simulation results 8 10 seems reasonable choice history length 3x4kentry gskewed table enhanced gskewed 11 12 would better choice notice 3x4kentry enhanced gskewed performs well 32kentry gshare benchmarks history lengths less half storage requirements 7 conclusions future work aliasing effects branchpredictor tables recently identified significant contributor branchmisprediction rates better understand minimize source prediction error proposed new branchaliasing classification inspired threecs model cache performance although previous branchprediction research shown reduce compulsory capacity aliasing little done reduce conflict aliasing end proposed skewed branch prediction technique distributes branch predictors across multiple banks using distinct independent hashing func tions multiple predictors read parallel majority vote used arrive overall prediction analytical model explains skewed branch prediction works standard onebank table misprediction overhead increases linearly aliasing probability mbank skewed organization increases mth degree polynomial deal perbank aliasing probabilities range 0 1 polynomial growth rate preferable linear one redundancy skewed organization increases amount capacity aliasing simulation results show negative effect compensated reduction conflict aliasing using partialupdate policy tables 2bit predictors equal lengths global tory 3bank skewed organization consistently outperforms standard 1bank organization configurations comparable total storage requirements found update policy important factor partial update consistently outperforming total update although 5bank greater configurations possible simulations showed improvement 3bank configuration negligible also found skewed branch prediction less sensitive pathological cases eg nroff figure 6 reduce capacity aliasing proposed enhanced skewed branch predictor shown consistently reach performance level conventional gshare predictor twice size addition performance advantages skewed organizations offer chip designer additional degree flexibility allocating die area diearea constraints example may permit increasing 1bank predictor table 16k 32k skewed organization offers middle point 3 banks 8k entries apiece total 24k entries paper addressed aliasing prediction schemes using global history vector technique could applied remove aliasing prediction methods including peraddress history schemes 18 19 20 hybrid schemes 8 2 1 4 skewed branch prediction raises new questions ffl update policies policies partialupdate totalupdate offer better performance skewed enhanced skewed branch predictors 46 history length enh gskewed 3x4k gskewed 3x4k gshare 32k4567 history length enh gskewed 3x4k gskewed 3x4k gshare history length enh gskewed 3x4k gskewed 3x4k gshare 32k nroff real gcc verilog242832364 history length enh gskewed 3x4k gskewed 3x4k gshare history length enh gskewed 3x4k gskewed 3x4k gshare 32k4567 history length enh gskewed 3x4k gskewed 3x4k gshare 32k figure 12 misprediction percentage enhanced gskewed ffl distributed predictor encodings simulations adopted standard 2bit predictor encodings simply replicated across 3 banks exist alternative dis predictor encodings space efficient robust aliasing minimizing capacity aliasing skewed branch predictors effective reducing conflictaliasing effects expense increased capacity aliasing exist techniques like used enhanced skewed predictor could minimize effects r alternative implementations hybrid branch predictors branch clas sification new mechanism improving branch predictor performance analysis branch prediction via data compression using hybrid branch predictors improve branch prediction accuracy presence context switches analysis dynamic branch prediction schemes system workloads aspects cache memory instruction buffer performance branch prediction strategies branch target buffer design combining branch predictors dynamic pathbased branch correlation improving accuracy dynamic branch prediction using branch correlation correlation aliasing dynamic branch predictors case twoway skewedassociative caches skewed associative caches study branch prediction strategies efficient simulation caches optimal replacement applications miss influence branch prediction table interference branch prediction scheme performance coping code bloat alternative implementations twolevel adaptive branch prediction comparison dynamic branch predictors use two levels branch history comparative analysis schemes correlated branch prediction tr twolevel adaptive training branch prediction alternative implementations twolevel adaptive branch prediction improving accuracy dynamic branch prediction using branch correlation case twoway skewedassociative caches comparison dynamic branch predictors use two levels branch history efficient simulation caches optimal replacement applications miss characterization branch classification comparative analysis schemes correlated branch prediction instruction fetching influence branch prediction table interference branch prediction scheme performance dynamic pathbased branch correlation alternative implementations hybrid branch predictors using hybrid branch predictors improve branch prediction accuracy presence context switches analysis dynamic branch prediction schemes system workloads correlation aliasing dynamic branch predictors analysis branch prediction via data compression skewedassociative caches study branch prediction strategies aspects cache memory instruction buffer performance ctr mitchell h clifton logical conditional instructions proceedings 37th annual southeast regional conference cdrom p24es april 1999 shlomo reches shlomo weiss implementation analysis path history dynamic branch prediction schemes ieee transactions computers v47 n8 p907912 august 1998 n eden mudge yags branch prediction scheme proceedings 31st annual acmieee international symposium microarchitecture p6977 november 1998 dallas texas united states marius evers sanjay j patel robert chappell yale n patt analysis correlation predictability makes twolevel branch predictors work acm sigarch computer architecture news v26 n3 p5261 june 1998 chunrong lai shihlien lu yurong chen trista chen improving branch prediction accuracy parallel conservative correctors proceedings 2nd conference computing frontiers may 0406 2005 ischia italy alexandre farcy olivier temam roger espasa toni juan dataflow analysis branch mispredictions application early resolution branch outcomes proceedings 31st annual acmieee international symposium microarchitecture p5968 november 1998 dallas texas united states toni juan sanji sanjeevan juan j navarro dynamic historylength fitting third level adaptivity branch prediction acm sigarch computer architecture news v26 n3 p155166 june 1998 pierre michaud andr seznec stphan jourdan exploration instruction fetch requirement outoforder superscalar processors international journal parallel programming v29 n1 p3558 february 2001 chihchieh lee icheng k chen trevor n mudge bimode branch predictor proceedings 30th annual acmieee international symposium microarchitecture p413 december 0103 1997 research triangle park north carolina united states artur klauser srilatha manne dirk grunwald selective branch inversion confidence estimation branch predictors international journal parallel programming v29 n1 p81110 february 2001 e f torres p ibanez v vinals j llaberia store buffer design firstlevel multibanked data caches acm sigarch computer architecture news v33 n2 p469480 may 2005 veerle desmet hans vandierendonck koen de bosschere clustered indexing branch predictors microprocessors microsystems v31 n3 p168177 may 2007 juan c moure domingo bentez dolores rexachs emilio luque wide efficient trace prediction using local trace predictor proceedings 20th annual international conference supercomputing june 28july 01 2006 cairns queensland australia renju thomas manoj franklin chris wilkerson jared stark improving branch prediction dynamic dataflowbased identification correlated branches large global history acm sigarch computer architecture news v31 n2 may zhijian lu john lach mircea r stan kevin skadron alloyed branch history combining global local branch history robust performance international journal parallel programming v31 n2 p137177 april abhas kumar nisheet jain mainak chaudhuri longlatency branches much matter acm sigarch computer architecture news v34 n3 p915 june 2006 adi yoaz mattan erez ronny ronen stephan jourdan speculation techniques improving load related instruction scheduling acm sigarch computer architecture news v27 n2 p4253 may 1999 jared stark marius evers yale n patt variable length path branch prediction acm sigplan notices v33 n11 p170179 nov 1998 andr seznec stephen felix venkata krishnan yiannakis sazeides design tradeoffs alpha ev8 conditional branch predictor acm sigarch computer architecture news v30 n2 may 2002 tao li lizy kurian john anand sivasubramaniam n vijaykrishnan juan rubio understanding improving operating system effects control flow prediction acm sigplan notices v37 n10 october 2002 timothy h heil zak smith j e smith improving branch predictors correlating data values proceedings 32nd annual acmieee international symposium microarchitecture p2837 november 1618 1999 haifa israel alex ramirez josep l larribapey mateo valero software trace cache ieee transactions computers v54 n1 p2235 january 2005 andre seznec analysis ogeometric history length branch predictor acm sigarch computer architecture news v33 n2 p394405 may 2005 j gonzlez gonzlez controlflow speculation value prediction ieee transactions computers v50 n12 p13621376 december 2001 gabriel h loh exploiting datawidth locality increase superscalar execution bandwidth proceedings 35th annual acmieee international symposium microarchitecture november 1822 2002 istanbul turkey daniel jimnez code placement improving dynamic branch prediction accuracy acm sigplan notices v40 n6 june 2005 daniel jimnez calvin lin neural methods dynamic branch prediction acm transactions computer systems tocs v20 n4 p369397 november 2002 hans vandierendonck koen de bosschere xorbased hash functions ieee transactions computers v54 n7 p800812 july 2005 kevin skadron pritpal ahuja margaret martonosi douglas w clark branch prediction instructionwindow size cache size performance tradeoffs simulation techniques ieee transactions computers v48 n11 p12601281 november 1999
new collapse consequences np small circuits show selfreducible set polynomialsize circuits low probabilistic class zpp np consequence get deeper collapse polynomialtime hierarchy ph zppnp assumption np polynomialsize circuits improves wellknown result karp lipton proceedings 12th acm symposium theory computing acm press new york 1980 pp 302309 stating collapse ph second level sigmap2 assumption furthermore derive new collapse consequences assumption complexity classes like fewp cp polynomialsize circuits finally investigate circuitsize complexity several language classes particular show every fixed polynomial set zppnp osnsize circuits b introduction question whether intractable sets efficiently decided nonuniform models computation motivated much work structural complexity theory research early 1980s present variety results obtained showing impossible plausible assumptions see eg survey 18 typical model nonuniform computations circuit families notation karp lipton 22 sets decidable polynomialsize circuits precisely sets ppoly ie decidable polynomial time help polynomial length bounded advice function 32 karp lipton together sipser 22 proved npcomplete set polynomial size circuits symbols np 6 ppoly unless polynomial time hierarchy collapses second level proof given 22 exploits certain kind selfreducibility wellknown npcomplete problem sat generally shown 8 7 every turing selfreducible set ppoly low second level sigma p 2 polynomial time hierarchy intuitively speaking set low relativizable complexity class gives additional power used oracle class paper show every selfreducible set ppoly even low probabilistic class zppnp meaning every oracle sigma lowness zppnp implies lowness sigma p consequence lowness result get deeper collapse polynomialtime hierarchy zppnp assumption np polynomialsize circuits abteilung fr theoretische informatik universitt ulm oberer eselsberg d89069 ulm germany koeblerinformatikuniulmde department computer science tokyo institute technology meguroku tokyo 152 japan watanabecstitechacjp part work done visiting university ulm supported part guest scientific program university ulm j k obler watanabe least relativized world new collapse level quite close optimal oracle relative np contained ppoly ph collapse pnp 17 39 also derive new collapse consequences assumption complexity classes like fewp cp polynomialsize circuits furthermore lowness result implies new relativizable collapses case modm p pspace exp polynomialsize circuits final application derive new circuit size lower bounds particular shown relativizing proof techniques every fixed polynomial set zppnp osnsize circuits improves result kannan 21 every polynomial class sigma p 2 contains set follows every relativized world exist sets class zpexpnp polynomialsize circuits noted nonrelativizing proof stronger result corollary result 4 proved nonrelativizing technique provable exp coma exp subclass zpexpnp contains non ppoly sets 12 36 explanation work builds prior techniques order proof lowness result heavily uses universal hashing technique 13 34 builds ideas 2 14 24 design zero error probabilistic algorithm help np oracle simulates given zppnpa computation selfreducible set ppoly make use newly defined concept halfcollisions precisely show compute input 0 n expected polynomial time hash family h used decide instances length n strong np computation way h used decide nonmembership checking whether h leads halfcollision certain sets recently bshouty cleve gavalda kannan tamon 11 building result 19 shown class circuits exactly learnable randomized expected polynomial time equivalence queries aid np oracle immediately implies every set ppoly advice function computed fzppnpa ie probabilistic oracle transducer expected polynomial time oracle npa precisely since circuit produced probabilistic learning algorithm 11 depends outcome coin flips computes multivalued advice function ie input 0 n accepts probability least 12 every accepting path outputs circuit correctly decides instances length n wrt using technique 11 able show every selfreducible set ppoly even advice function fzppnp although provides different way deduce zppnp lowness selfreducible sets ppoly prefer give selfcontained proof using halfcollision technique rely mentioned results 11 19 paper organized follows section 2 introduces notation defines selfreducibility use section 3 prove zppnp lowness self reducible sets ppoly section 4 state collapse consequences new circuitsize lower bounds derived section 5 2 preliminaries notation languages binary alphabet 1g usual denote lexicographic order sigma length string x 2 sigma denoted jxj sigma n sigma n set strings length n resp length smaller n language cardinality finite set denoted jaj characteristic function defined otherwise class c sets coc denotes class fsigma gamma j 2 cg encode pairs tuples strings use standard polynomialtime computable pairing function denoted hdelta deltai whose inverses also computable polynomial time intent clear place fhx denotes set nonnegative integers throughout paper base log 2 textbooks 9 10 25 31 33 consulted standard notations used paper basic results complexity theory definitions probabilistic complexity classes like zpp see also 15 machine polynomialtime nondeterministic turing machine assume computation path given input x either accepts rejects outputs accepts input x performs least one accepting computation otherwise rejects x strongly accepts strongly rejects x 26 ffl least one accepting resp rejecting computation path ffl rejecting resp accepting computation paths strongly accepts strongly rejects x said perform strong computation input x np machine every input performs strong computation called strong np machine well known exactly sets np conp accepted strong np machines 26 next define kind selfreducibility use paper definition 21 let irreflexive transitive order relation sigma sequence strings called chain length k x 0 x k relation called length checkable polynomial q 1 x 2 sigma x implies jyj qjxj 2 language fhx chain length k x yg np definition 22 set selfreducible polynomialtime oracle machine self length checkable order relation input x self queries oracle strings oe x straightforward check polynomially related selfreducible sets introduced ko 23 well lengthdecreasing worddecreasing selfreducible sets balcazar 6 selfreducible sense furthermore wellknown see example 9 6 29 complexity classes like np sigma p pspace exp manyone complete selfreducible sets karp lipton 22 introduced notion advice functions order characterize nonuniform complexity classes function h n sigma called polynomial length function polynomial p n 0 pn class c sets let cpoly class sets set 2 c 4 j k obler watanabe polynomiallength function h n x 2 sigma n function h called advice function whereas corresponding interpreter set paper heavily make use hashing technique fruitful complexity theory review notations facts hash families also extend notion collision introducing concept halfcollision central proof technique sipser 34 used universal hashing originally invented carter wegman 13 decide probabilistically whether finite set x large small linear function h sigma sigma k given boolean k mmatrix ij maps string x string inner product ith row x h linear hash function sigma sigma k say x collision wrt h exists string 2 different x generally x subset sigma h family l linear hash functions sigma sigma k say x collision wrt h collisionx h short x 2 x collision wrt every h h x collision wrt h simply say x collision wrt h next extend notion collision following way x family l linear hash functions say x halfcollision wrt h halfcollisionx h short x 2 x collision wrt least dl2e many hash functions h h halfcollisionx important relationship collisions halfcollisions following one x collision wrt h must halfcollision wrt h either 1 2 note predicate collisionx h decided np provided membership x tested np precisely language fhv hi j well set fhv hi j halfcollisionx np sets x v v succinctly represented way languages np denote set families l l linear hash functions sigma sigma k hl k following theorem proved pigeonhole argument says every sufficiently large set must collision wrt hash family theorem 23 34 hash family h 2 hl k set x sigma cardinality jxj l must collision wrt h hand get next theorem called coding lemma 34 upper bound collision probability sufficiently small sets theorem 24 34 let x sigma set cardinality 2 kgamma1 choose hash family h uniformly random hk k probability x collision wrt h 12 also make use following extension theorem 24 proved along lines theorem 25 let x sigma set cardinality 2 kgammas choose family h uniformly random hl k probability x collision wrt h 2 kgammasl1 gavalda 14 extended sipsers coding lemma theorem 24 case collection c exponentially many sets following theorem similar flavor theorem 26 let c collection 2 n subsets sigma cardinality 2 kgammas choose hash family h uniformly random probability x 2 c collision wrt h proof theorem 25 every fixed x 2 c probability collision wrt randomly chosen hash family h 2 hl k 2 kgammasl1 hence probability exists set x 2 c paper make use corresponding result case halfcollisions theorem 27 let x sigma let c collection 2 n subsets cardinality 2 kgammasgamma2 choose hash family h uniformly random hl k probability x halfcollision 2 c wrt h jxj delta 2 ngammasl2 proof every fixed 2 c every fixed x 2 x probability x collision wrt randomly chosen h 2 gammasgamma2 hence probability x collision wrt least half functions randomly chosen hash family h 2 hl k l l probability x halfcollision wrt randomly chosen hash family h bounded 2 gammasl2 hence probability exists 2 c x 2 x x halfcollision wrt h jxj delta 2 ngammasl2 3 lowness selfreducible sets ppoly section show every selfreducible set np conppoly low zppnp let 2 np conp 6 j k obler watanabe interpreter set h advice function construct probabilistic algorithm np oracle following two properties expected running time polynomially bounded b every computation path input 0 n oracle outputs information used determine membership x length n strong np computation sense 26 using properties prove lowness zppnp follows order simulate npa computation first precompute mentioned information length using information simulate npa computation npnp conp computation note precomputation performed done zppnp since remaining computation done np hence implies zppnpa zppzppnp zppnp 41 make term information precise need additional notation let selfreducibility witnessed polynomialtime oracle machine self length checkable order relation polynomial q assume fixed polynomial p 0 following fix n consider instances length qn well advice strings length exactly pn ffl sample sequence hx pairs x instances length qn b ffl sample consistents set advice strings w consistent ie cardinality consistents denoted cs ffl sample instance x let acceptx resp rejectx set consistent advice strings accept x resp reject x ffl let correctx set fw 2 consistents j ix consistent advice strings decide x correctly let incorrectx complementary set fw 2 consistents j ix w 6 axg note sets acceptx rejectx well correctx incorrectx form partition set consistents condition b precisely stated follows b every computation path input 0 n outputs pair hs hi consisting sample linear hash family h x length n consistents halfcollision wrt h correctx incorrectx pair hs hi satisfying condition b determine whether instance x length n simply checking whether consistentx halfcollision wrt h acceptx rejectx since condition b guarantees halfcollision always found checking done strong np computation let us prove main lemma lemma 31 selfreducible set np conppoly exist probabilistic transducer oracle np satisfying two conditions proof use notation introduced far recall qn length bound queries occuring selfreduction tree produced self instance length n pn advice length set instances length qn let l polynomial defined 1 denote sigma n set fy j 9x 2 sigma n xg clear sigma n sigma n sigma qn description given input loop randomly hln pn k collision wrt h k g exists x 2 sigma n consistents halfcollision incorrectx wrt h kmax use oracle find string x determine ax else exitloop end loop output starting empty sample enters main loop execution loop first randomly guesses series pn many hash families computes integer kmax maximum png consistents collision wrt h k notice padding trick assume cs always larger 2ln implying consistents must collision wrt h 1 since particular consistents collision wrt h kmax follows every instance x 2 sigma n consistents halfcollision wrt h kmax either correctx incorrectx exists string x 2 sigma n consistents halfcollision incorrectx wrt h kmax string added sample continues executing loop describe uses np oracle find x case otherwise 8 j k obler watanabe pair hs h kmax fulfills properties stated condition b halts show expected running time polynomially bounded since initial size consistents 2 pn since consistents never becomes empty suffices prove polynomial r eliminates single execution main loop probability least 1rn least 1rnfraction circuits consistents fact show single extension reduces size consistents probability least factor smaller perform 2 7 lnpn loop iterations iteration main loop extends pair hx axi shrink size consistents factor smaller probability event bounded 2 7 lnpn let sample let kmax corresponding integer determined specific execution loop first derive lower bound kmax smallest integer k 1 cs ln2 k1 since either pn consistents collision wrt hash family h kmax 1 using theorem 23 cs ln2 kmax 1 hence since expands strings x 2 sigma n consistents halfcollision incorrectx wrt h kmax since consistentshx probability size consistents decrease factor smaller bounded probability wrt h kmax consistents halfcollision set incorrectx size cs2 7 ln let follows theorem 27 probability consistents halfcollision wrt uniformly random chosen hash family h 2 hln thus probability k 0 consistents halfcollision wrt h k0k set incorrectx size cs2 7 ln bounded finally show determines instance x 2 sigma n exists consistents halfcollision incorrectx wrt h kmax intuitively use selfreducibility test correctness wrt program hs h kmax say ffl pair hs hi accepts instance x consistents halfcollision ffl hs hi rejects x consistents halfcollision rejectx wrt h notice incorrect program might accept time reject instance main idea find whether hs h kmax incorrect instance meaning wrt h kmax consistents halfcollision incorrectx test whether program hs h kmax accordance output self oracle queries self answered according program precise consider np set hi j computation path self input z fulfilling following properties query q answered yes hs hi accepts q query q answered hs hi rejects q accepting hs hi rejects z rejecting hs hi accepts z g shown next claim correctness hs h kmax instance z decided asking whether hz belongs b provided hs h kmax correct potential queries self input z claim assume hs h kmax correct oe z hs h kmax incorrect z hz belongs b proof using fact every instance x 2 sigma n consistents half collision wrt h kmax either correctx incorrectx easy see incorrect z computation path followed self z oracle witnesses hz b converse assume hz belongs b let computation path witnessing fact note queries q answered correctly wrt since otherwise hs h kmax incorrect q oe z hence path followed self z oracle therefore decides z correctly hand since witnesses hz indeed incorrect z define oracle set c phi hi j chain length least k string 2 sigma n string z x hz hi j accepting computation path self input x query q answered yes consistents halfcollision acceptq resp rejectq wrt h g note proof claim also shows z 2 sigma n correct oe z z 2 hz complete description first asks whether string belongs c clear negative answer implies correct sigma n otherwise asking queries form computes binary search max maximum value belongs c similar idea used obler watanabe input loop randomly hln pn k collision wrt h k g else exitloop end loop output 27 knowing determines lexicographically smallest string xmin h0 c since hq holds instances q oe xmin follows inductively claim hs h kmax correct q oe xmin hence must incorrect xmin furthermore determine membership xmin asking whether string hx min belongs theorem 32 every selfreducible set class np conppoly low zppnp proof first show npa zppnp let l set npa let deterministic polynomialtime oracle machine polynomial let sn polynomial bounding length oracle queries input hx yi x length n l accepted probabilistic oracle machine n using following np oracle hi j 2 sigma tjxj input hx yi accepting path query q answered yes consistents halfcollision acceptq resp rejectq wrt h g n accepts l input x n first simulates input 0 sjxj compute pair hs h kmax described asks questions np oracle n asks query hx 0 find whether x l proves npa zppnp since via proof relativizes follows zppnpa also contained zppnp showing low zppnp 4 collapse consequences direct consequence theorem 32 get improvement karp lipton sipsers result 22 np contained ppoly unless polynomialtime hierarchy collapses sigma p corollary 41 np contained np conppoly polynomialtime hierarchy collapses zppnp proof since npcomplete set sat selfreducible assumption np contained np conppoly implies sat low zppnp hence polynomialtime hierarchy collapses zppnp collapse polynomialtime hierarchy deduced corollary 41 quite close optimal least relativized world 17 39 oracle relative np contained ppoly polynomialtime hierarchy collapse pnp rest section report interesting collapses easily derived using standard techniques also pointed independently several researchers second author first straightforward check theorem 32 relativizes oracle b selfreducible set class npb conpbpoly npa contained zppnpb consequently theorem 32 generalizes following result theorem 42 selfreducible set class sigma p poly direct consequence theorem 42 get improvement results 1 20 stating k contained sigma p poly unless polynomialtime hierarchy collapses sigma p corollary 43 let k 1 sigma p k contained sigma p poly polynomialtime hierarchy collapses zppsigma p proof since sigma p contains complete selfreducible languages assumption k contained sigma p poly implies sigma p yap 40 proved pi p k contained sigma p poly unless polynomialtime hierarchy collapses sigma p k2 consequence theorem 42 get following improvement yaps result corollary 44 k 1 pi p poly proof assumption pi p k contained sigma p poly implies sigma p k1 contained sigma p poly sigma p poly hence apply corollary 43 corollaries theorem 42 also similar collapse results many complexity classes follows typical examples corollary 45 k 2 conppoly k low zppnp proof wellknown every set fewp left set 30 worddecreasing selfreducible resp fewp thus assumption np conppoly resp fewp np conppoly follows theorem 32 left set since polynomialtime manyone reducible left set also low zppnp corollary 46 every k 1 cp sigma p poly proof first since cp complete worddecreasing selfreducible languages poly implies cp zppsigma p obler watanabe poly implies ph sigma p k poly therefore ph collapses zppsigma p k corollary 43 finally since cpph bppc p 37 follows cpph ph since 38 get inductively ch ph zppsigma p corollary 47 let k 2 k 1 poly k ph ph collapses zppsigma p proof proof k 2 fexppspaceg immediate theorem 42 since pspace complete lengthdecreasing selfreducible languages since exp complete worddecreasing selfreducible languages 6 proof k 2 analogous one corollary 46 using fact modmp complete worddecreasing selfreducible languages 29 ph bppmodm p 37 35 since proof technique relativizable results hold every relativized world hand known classes stronger collapse consequences obtained using nonrelativizable arguments theorem 48 28 4 3 k 2 fpp modmppspaceexpg k ppoly k harry buhrman pointed us corollary 47 also derived theorem 48 5 circuit complexity kannan 21 proved every fixed polynomial set sigma p cannot decided circuits size sn using padding argument obtained existence sets nexpnp conexpnp polynomialsize circuits theorem 51 21 1 every polynomial set sigma p 2 circuits size sn 2 every increasing timeconstructible superpolynomial function fn set ntimefnnpcontimefnnp polynomial size circuits application results section 3 improve kannans results every relativized world class sigma p 2 zppnp class contimefnnp zptimefnnp respectively zptimefnnp denotes class sets accepted zero error probabilistic machine expected running time ofn relative np oracle note sets class ppoly may fix interpreter set appropriate one p let univ denote fixed interpreter set furthermore ppoly remains class relax notion advice function h wrt univ follows every x univ x hjxj ie hn decide correctly n instead n sequence circuits cn n 0 called circuit family every n 0 cn n input gates nbit strings x 1 wellknown see eg 9 univ chosen way advice length circuit size ie number gates polynomially related precisely assume polynomial p following holds every set ffl h advice function wrt univ exists circuit family cn n 0 size jcn j pn ffl cn n 0 circuit family exists advice function h wrt univ length jhnj pjc n j moreover assume every polynomialtime interpreter set constant c h advice function wrt exists advice function h 0 wrt univ length jh 0 nj n following lemma obtained direct diagonalization cf corresponding result 21 set called printable see 16 polynomialtime oracle transducer oracle set 2 c input 0 n outputs list strings n lemma 52 every fixed polynomial delta p 3 printable set every advice function h length jhnj sn almost n proof given n sequence strings length n enumerated lexicographic order consider two sets haveadvice find defined follows haveadvice 9 j1 delta delta delta since 2 strings w sigma sn least one pair form hn 1 delta delta delta sn contained haveadvice provided sn 2 n let ff n denote lexicographically smallest pair hn 1 delta delta delta sn ie advice length smaller sn accepts strings x according set strings x jx n 1 sn 2 n ith bit ff n ie 1 binary search using oracle find ff n computable polynomial time since haveadvice np thus find npnp follows pnpnpprintable since furthermore almost n n advice length smaller sn lemma follows corollary 53 every fixed polynomial set zppnp circuits size sn proof np polynomialsize circuits take otherwise corollary 41 thus theorem easily follows lemma 52 corollary 54 let f increasing timeconstructible superpolynomial function zptimefnnp contains set polynomialsize circuits 14 j k obler watanabe proof np polynomialsize circuits take otherwise corollary 41 thus follows lemma 52 set b zptimen k np every advice function h b length jhnj n almost n proof technique lemma 52 assume length n strings b 1s occur olog n rightmost positions consider following set n denotes jxj interpreter set clearly belongs zptimefnnp belongs p furthermore h advice function every form 0 bfn 1k cgamman x h 0 n suitable advice function length jh 0 nj thus follows almost n shows length h superpolynomial corollary 55 every relativized world zpexpnp contains sets polynomialsize circuits remark results proved relativizable arguments hand harry buhrman 12 independently thomas thierauf 36 pointed us theorem 48 proved nonrelativizable proof technique used show exp coma exp contains non ppoly sets exp denotes exponentialtime version babais class 5 language l mafn exists set b 2 dtimeon x length n z chosen uniformly random sigma fn corollary 56 12 36 exp coma exp contains sets polynomial size circuits since exist recursive oracles relative sets expnp polynomial size circuits 39 17 possible extend corollary 55 relativizing techniques class expnp 6 concluding remarks interesting question concerning complexity classes c known contained ppoly known complete sets whether existence sets c gamma ppoly constructively shown example corollary 55 know class zpexpnp contains sets polynomialsize circuits able give constructive proof fact best knowledge explicit set known even acknowledgments helpful discussions suggestions regarding work grateful h buhrman r gavalda l hemaspaandra ogihara u schoning r schuler thierauf like thank h buhrman l hemaspaandra ogihara permitting us include observations paper r hiding information oracle queries concept learning arithmetization new method structural complexity randomized proof system hierarchy complexity classes structural complexity theory introduction theory complexity oracles queries sufficient exact learning universal classes hash functions bounding complexity advice functions computational complexity probabilistic complexity classes computation times np sets different densities relativized exponential probabilistic complexity classes hard sparse sets random generation combinatorial structures uniform distribution connections nonuniform uniform complexity classes journal computer system sciences strong nondeterministic polynomialtime reducibilities algebraic methods interactive proof systems sparse hard sets counting classes polynomialtime bounded truthtable reducibility np sets sparse sets computational complexity simultaneous resource bounds complexity theoretic approach randomness probabilistic polynomials counting classes least hard polynomialtime hierarchy complexity classes defined counting quantifiers relativized circuit complexity consequences nonuniform conditions uniform classes robustness probabilistic computational complexity classes definitional perturbations tr ctr christian glaer lane hemaspaandra moment perfect clarity ii consequences sparse sets hard np respect weak reductions acm sigact news v31 n4 p3951 dec 2000 valentine kabanets jinyi cai circuit minimization problem proceedings thirtysecond annual acm symposium theory computing p7379 may 2123 2000 portland oregon united states lane hemaspaandra mitsunori ogihara gerd wechsung reducing number solutions np functions journal computer system sciences v64 n2 p311328 march 2002 rahul santhanam circuit lower bounds merlinarthur classes proceedings thirtyninth annual acm symposium theory computing june 1113 2007 san diego california usa lane hemaspaandra sigact news complexity theory column 32 acm sigact news v32 n2 june 2001 jinyi cai venkatesan chakaravarthy lane hemaspaandra mitsunori ogihara competing provers yield improved karplipton collapse results information computation v198 n1 p123 april 10 2005 piotr faliszewski lane hemaspaandra open questions theory semifeasible computation acm sigact news v37 n1 march 2006 lance fortnow beyond np work legacy larry stockmeyer proceedings thirtyseventh annual acm symposium theory computing may 2224 2005 baltimore md usa johannes kbler rainer schuler averagecase intractability vs worstcase intractability information computation v190 n1 p117 april 10 2004
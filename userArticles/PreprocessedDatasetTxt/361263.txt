tolerance multiple transient faults aperiodic tasks hard realtime systems abstractrealtime systems increasingly used several applications timecritical nature fault tolerance essential requirement systems due catastrophic consequences tolerating faults paper study scheme guarantees timely recovery multiple faults within hard realtime constraints uniprocessor systems assuming earliestdeadlinefirst scheduling edf aperiodic preemptive tasks develop necessary sufficient feasibilitycheck algorithm faulttolerant scheduling complexity on2 cdot k n number tasks scheduled k maximum number faults tolerated b introduction interest embedded systems growing steadily recent past specially ples include autopilot systems satellite launch vehicle control well robots whether collaborating teams systems termed hard realtime systems hrtss consequences missing deadline may catastrophic ability tolerate faults hrtss crucial since task potentially miss deadline faults occur case fault deadline missed time taken recovery faults taken account phase tasks submittedaccepted system clearly accounting recovery faults essential requirement hrtss dealing hrtss permanent faults tolerated using hotstandby spares ks86 masked modular redundancy techniques pra86 addition permanent faults tolerance transient faults important since shown occur much frequently permanent faults ir86 irh86 cms82 study orbiting satellite containing microelectronics test system used measure error rates various semiconductor devices including microprocessor systems cmr92 number errors caused protons cosmic ray ions mostly ranged 1 15 15minute intervals measured high 35 intervals examples safety critical applications found lh94 transient faults dealt temporal redundancy allowing extra time slack schedule reexecute task execute recovery block hlmsr74 problem solved paper follows given set n aperiodic tasks seek determine task set able complete execution deadline edf scheduling even system recover k faults consider uniprocessor system assume task may subjected multiple transient faults simple solution would check feasibility schedules generated possible combination faults using approach described llmm99 schedule high complexity scheme provides impetus searching efficient solution solution presented paper develops optimal necessary sufficient feasibility check runs 2 delta time worst case although consider aperiodic tasks note technique presented paper used verify faulttolerance capabilities set periodic tasks considering instance periodic task aperiodic task within least common multiple periods periodic tasks moreover scheduling aperiodic tasks basis scheduling periodic tasks framebased systems set tasks usually precedence constraints invoked regular time intervals type systems commonly used practice simplicity example trackingcollision avoidance applications motion detection recognitionverification trajectory estimation computation time contact usually component subtasks within given frame period cbm93 similarly realtime image magnification task might go steps nonlinear image interpolation contrast enhancement noise suppression image extrapolation period nc96 even though periodic tasks system period unique therefore scheduling instance corresponding nomenclature aperiodic task done within specific time interval rest paper organized follows section 2 present model notation aperiodic faulttolerant scheduling problem section 3 introduce auxiliary function aid presentation solution section 4 describe feasibility tests set tasks specific fault pattern generalize section 5 fault pattern examining worst case behavior respect k faults section 6 survey related work section 7 finalize paper concluding remarks directions future work model notation consider uniprocessor system submit set n tasks g task modeled tuple ready time earliest start time task deadline c maximum computation time also called worst case execution time set tasks become ready given time denoted rst rst assume edf schedules ties deadlines broken arbitrarily schedule described function edf schedule task time use edf refer edf schedule define e time task completes execution edf define function number free slots number slots edf excluding slot starts 2 edf said feasible e assumed faults detected end execution task time required fault detection mechanism added worst case computation time c task hinder timeliness system many mechanisms proposed fault detection user level operating system level hardware level user level common technique use consistency sanity checks procedures supplied user verify correctness results ha84 yf92 example using checksums checking range results substituting result back original equations used detect transient error many mechanisms exist operating systems computer hardware may used error detection triggering recovery examples detection illegal opcode caused bus error memory corruption memory range violation arithmetic exceptions various timeout mechanisms hardware duplication resources also used detecting faults comparison results noted however mechanisms described designed detecting specific types faults long recognized possible fault detection mechanism accomplish perfect coverage arbitrary types faults fault detected system enters recovery mode recovery action must performed tasks deadline assume task recovers fault executing recovery block hlmsr74 lc88 i1 priority fault occurs execution i1 detected end i1 recovered invoking second recovery block i2 assumed maximum time recovery block execute recovery blocks task may different execution time task words recovery restricted reexecution task recovery blocks used avoiding common design bugs code providing less accurate result view limited time available recovery loading safe state onto memory stable source across network shielded memory shall denote pattern faults set g f number times task 2 recovery blocks fail successful completion use denote edf schedule fault pattern f forced execute f recovery blocks edf f said feasible recovery blocks complete note edf f cannot feasible given task set specific fault pattern f define two functions first function defines amount work execution time remains completed time edf work generated tasks became ready time tasks f specifically gamma operator defined time positive amount work w decreases one period task becomes ready work increases computation time task second function w f defined similar way except include time recovery failed tasks point would completed faultfree schedule specifically two functions defined used reason extra work needed recover faults note although task may complete time different e edf f function w f important property equal zero beginning idle time slot edf f properties two functions defined given next work done time edf means task r finishes time faultfree case property 2 w f work done time edf f means task r finishes time tasks subject fault pattern f property 3 w f amount work incurred faults present never smaller amount work faultfree case slot end task never idle four properties follow directly definition w 3 ffifunction order avoid explicitly deriving edf schedule presence faults define function ffi loosely corresponds extra work induced certain fault pattern f intuitively amount unfinished extra work induced fault pattern f time words work needed beyond required faultfree schedule idle time faultfree edf schedule used extra work ffi function play important role process checking task meets deadline edf f following method computing ffi directly faultfree edf schedule fault pattern f 2 order show form ffit f equivalent w f consider four different cases case 1 task end thus 0 6 e j j definitions w w f implies w case 2 implies w property 3 implies also w f case 3 edf states w states j case ffi case 4 6 e edf implies w property 3 implies also w f hence operations definitions w w f reduce usual subtraction straightforward show illustration figure 1 shows example task set corresponding values function specific f example consider case 1 3 may subject fault note value ffi decreases edf idle increases end task indicated faulty f r c v223000 faultfree edf schedule figure 1 task set edf schedule ffi values f mentioned ffi function abstraction represents extra work performed recovery extra work reduces zero ready tasks complete execution recovery demonstrated following theorem theorem edf edf f task r finishes time proof equation 2 decrease value ffifunction possible edf property 1 leads w equation 1 gives w f proof follows properties 1 2 ffl 4 feasibility test task set specific fault pattern given task set fault pattern f present method checking whether lowest priority task denoted 2 completes deadline edf f theorem given task set fault pattern f lowest priority task completes edf f proof prove part assume 0 smallest value e 0 identical implies completes e schedules however latest time 0 ffit f 0 note first value e definition hence theorem 1 tasks ready finish execution edf edf f moreover ffit means thus edf identical edf f period completes edf e means also completes e edf f prove part contradiction assume finishes edf f e fact lowest priority task executes time means task available execution gamma 1 thus 1 given assumption implies property 1 implies edf leads contradiction ffl next corollaries provide conditions feasibility edf f entire task set corollary 1 necessary sufficient condition feasibility edf f given given f obtained applying theorem 2 n task sets j contains j highest priority tasks proof proof induction base case trivial since single task induction step assume edf f j feasible consider lower priority task j edf f j1 tasks j finish exactly time edf f j since lowest priority hence necessary sufficient condition feasibility edf f j1 equivalent necessary sufficient condition completion ffl corollary 2 sufficient necessary condition feasibility edf f given given f proof note proof part theorem 2 relies property lowest priority task edf means task latest deadline part theorem however true even lowest priority task hence 2 completes edf f proves corollary ffl figure 2 faulttolerant schedule task set figure 1 clarify conditions corollaries examples first show condition given corollary 2 necessary feasibility edf f show given necessary order finish edf f seen example task set fault pattern shown figure 1 value ffit f zero e 7 yet shown figure 2 1 2 finish deadlines edf f words condition stated theorem 2 necessary sufficient feasibility lowest priority task edf f task 4 example next show stated corollary 1 repeatedly apply theorem 2 task sets j obtain sufficient condition feasibility entire task set words sufficient apply theorem 2 demonstrated modifying example figure 1 7 clearly change 3 may still result edf schedule thus change calculation although application theorem 2 guarantees 4 finish deadline edf f recovery 3 finish seen figure 2 assume without loss generality tasks given task set numbered extra work still needs done due fault pattern f time noting ffi f increases equation 2 rewritten using slack function defined section 2 follows application theorem 2 given f requires simulation edf computation e well slacke values ffi computed equations 3 4 used check condition theorem step procedure takes time except simulation edf schedule simulation may efficiently performed using heap keeps tasks sorted deadlines task inserted heap ready removed heap completes execution since insertion deletion heap takes ologn time total simulation edf takes onlogn time thus time complexity entire procedure onlogn hence given task set specific fault pattern f sufficient necessary condition feasibility edf f computed using corollary 1 2 logn time steps less efficient simulating edf f directly done onlogn steps however described next section simulating edf extremely advantageous consider arbitrary fault patterns rather specific fault pattern 5 feasibility test task set fault pattern turn attention determining feasibility given task set fault pattern k less faults use f w denote fault pattern exactly w faults also define function ffi w represents maximum extra work time induced exactly w faults occurred time words extra work induced worstcase fault pattern w faults note although use f w definition specify w faults occur time value reach maximum possible w faults occur time theorem 3 given task set given number faults w fault pattern f w lowest priority task completes edf f w e proof theorem extension theorem 2 proved similar manner ffl order compute ffi w efficiently define values use compute directly derived equation 3 value ffi w defined maximum extra work induced fault pattern w faults maximum value obtained considering worst scenario following two cases ffl w faults already occurred hence maximum extra work e maximum extra work e igamma1 decremented slack available e igamma1 e already occurred additional fault occurs case maximum extra work e increased v recovery time hence noting e function slack derived edf depend particular fault pattern values ffi w computed using following recursive formula gammaslacke computations equation 6 graphically represented using graph g n columns k rows row corresponds particular number faults w column corresponds particular e see figure 3b node corresponding row w column e denoted n w vertical edge n w n w1 represents execution one recovery block task thus labeled v horizontal edge n w n w means faults occur task thus labeled gammaslacke indicate extra work remained e igamma1 decremented slack available e igamma1 e path starting n 0 1 g represents particular fault pattern see figure 4 value ffi w corresponding worst case pattern w faults computed equation 6 corresponds dynamic programming algorithm compute longest path n 0 1 n w r e task set slack b fault free schedule computation of00 04 figure 3 calculation 43 e e d00 figure 4 two fault patterns task set figure 3 corresponding paths g figure 3 depicts example computation ffi w specific task set 2 value ffi w written inside node n w see example equation 5 satisfies condition theorem 3 thus lowest priority task 3 finish presence two faults similar corollary 1 discussed last section necessary sufficient condition feasibility edf f requires repeated application theorem 3 corollary 3 necessary sufficient condition feasibility edf f given r c v1 122 6 29 1 e 14e e 3b fault free schedule computation task set 1202 figure 5 example three tasks fault pattern f k less faults obtained applying theorem 3 n task sets contains j highest priority tasks figure 5 shows computation ffi example three tasks note although application theorem 3 example shows lowest priority task 3 finish deadline presence two faults set three tasks feasible presence two faults 1 since case either 1 2 miss deadline detected theorem 3 applied task set g summarize given task set maximum number faults k following algorithm used optimally check edf f feasible fault pattern k faults algorithm exact highest priority task one earliest deadline lowest priority task task 1 ffl 1 simulate edf j compute e well slack 2 renumber tasks j e 1 e j 3 compute equation 6 4 let e computational convenience 5 ffi w 6 j n edf f feasible exit 7 let highest priority task 8 note lowest priority task j1 hence order determine lowest priority task task set finish deadline presence k faults steps 15 apply theorem steps generate edf j apply equation 6 order determine feasibility repeat loop n times note however care edf j1 derived edf j steps thus resulting total 2 feasibility test compared k1 logn complexity required simulate edf possible k fault patterns algorithm smaller time complexity even indicated corollary 2 sufficient necessary feasibility test may obtained computing ffi simulation edf making sure task ffi equal zero e completed onlognnk time shown following algorithm algorithm sufficient 1 simulate edf compute e well slack 2 renumber tasks j e 1 e n 3 compute equation 6 4 let e computational convenience 5 tee 200 0021 task set b computation figure example f tolerate two faults example shown figure 6 shows task even value ffi computed simulation edf equal zero e example yet easy see shown edf schedule tolerate two faults two faults 1 two faults 2 one fault 1 2 intuitively explain result note although 2 represents maximum recovery work needs done information kept priority recovery work execute edf f specifically given example work ffi 2 execute edf f priority 1 lower priority thus necessary finish deadline general may happen possible lower priority task finish higher priority task j e finally note observation given last paragraph algorithm sufficient provide sufficient necessary feasibility test special case tasks complete execution edf order priorities deadlines computed edf satisfy e e i1 i1 case recovery work ffi w would execute edf f priority higher equal thus necessary work completed complete deadline 6 related work earlier work dealing tolerance transient faults aperiodic tasks carried perspective single fault system lc88 ks86 recently fault models enhanced encompass single fault occurring every interval time uniprocessors multiprocessor systems bjpg89 gmm94 gmm97 tolerance transient faults periodic tasks also addressed uniprocessors rt93 rts94 os94 pm98 gmm98 multiprocessor systems bmr99 os95 lmm98 ks86 processor failures handled maintaining contingency backup schedules schedules used event processor failure generate backup schedule assumed optimal schedule exists schedule enhanced addition ghost tasks function primarily standby tasks since schedules permit additions scheme optimistic details found ks97 duplication resources used faulttolerance realtime systems os92 ever algorithm presented restricted case tasks period adding duplication error recovery doubles amount resources necessary scheduling bjpg89 best effort approach provide fault tolerance discussed hard realtime distributed systems primarybackup scheme used primary backup start execution simultaneously fault affects primary results backup used scheme also tries balance workload processor recently work done problem dynamic dispatching algorithms framebased computations dynamic priorities one considers single fault llmm99 shown simply generating n edf schedules one possible task failure sufficient determine task set scheduled deadlines also work kop97 describes approach taken mars system framebased fault tolerance mars pioneer system timeline dispatching tasks development timetriggered protocols takes account scheduling overhead well need explicit fault tolerance embedded realtime systems however mars requires special hardware perform faulttolerance related tasks voting thus cannot used broad range realtime systems 7 conclusion addressed problem guaranteeing timely recovery multiple faults aperiodic tasks work assumed earliestdeadlinefirst scheduling aperiodic preemptive tasks developed necessary sufficient feasibilitytest faulttolerant admission con trol test uses dynamic programming technique explore possible fault patterns system complexity 2 delta k n number tasks scheduled k maximum number faults tolerated edf optimal scheduling policy task set sense task misses deadline edf schedule deadlines missed edf also optimal faulttolerant scheduling policy specifically edf f fault pattern f equivalent edf 0 0 obtained replacing computation time c task hence work presented paper answers following question optimally given task set feasible schedule allow timely recovery combination k faults acknowledgments authors would like thank sanjoy baruah proposing problem tolerating k faults edf schedules valuable discussions feedback course work authors would also like acknowledge support darpa contract dabt6396c 0044 university pittsburgh r workload redistribution fault tolerance hard realtime distributed computing system layered control binocular camera head single event upset rates space derivation caliberation transient error reliability model implementation analysis faulttolerant scheduling algorithm program structure error detection recovery measurementbased model workload dependence cpu errors measurement modeling computer reliability affected system activity scheduling tasks quick recovery failure faulttolerant scheduling problem architectural principles safetycritical realtime applications global fault tolerant realtime scheduling multiprocessors efficient rms admission control application multiprocessor scheduling imprecise realtime image magnification algorithm algorithm realtime faulttolerant scheduling multiprocessor system enhancing faulttolerance ratemonotonic scheduling allocating fixedpriority periodic tasks multiprocessor sys tems minimum achievable utilization faulttolerant processing periodic tasks fault tolerant computing theory techniques enhancing fault tolerance realtime systems time redundancy scheduling fault recovery operations timecritical applications algorithm based fault tolerance matrix inversion maximum pivoting tr ctr alireza ejlali marcus schmitz bashir alhashimi seyed ghassem miremadi paul rosinger energy efficient seutolerance dvsenabled realtime systems information redundancy proceedings 2005 international symposium low power electronics design august 0810 2005 san diego ca usa alireza ejlali bashir alhashimi marcus schmitz paul rosinger seyed ghassem miremadi combined time information redundancy seutolerance energyefficient realtime systems ieee transactions large scale integration vlsi systems v14 n4 p323335 april 2006 xiao qin hong jiang novel faulttolerant scheduling algorithm precedence constrained tasks realtime heterogeneous systems parallel computing v32 n5 p331356 june 2006
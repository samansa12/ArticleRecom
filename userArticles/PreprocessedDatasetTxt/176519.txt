precise efficient groundness analysis logic programs show precise groundness information extracted logic programs idea use abstract interpretation boolean functions approximations groundness dependencies variables idea new different classes boolean functions used argue however one class positive functions suitable others positive boolean functions certain property inspired langen call condensation property allows rapid computation groundness information b introduction groundness analysis arguably important dataflow analysis logic programs question given program point variable x always bound term contains vari ables important optimizing compiler attempting speed unification practically every programming tool applies kind dataflow analysis reason analyses independence analysis whether instantiation x indirectly instantiates variables occurcheck analysis whether unification safely performed without occurcheck employ groundness analysis improve accuracy example x ground terminological abuse consistently use bound ground term x cannot possibly share variables useful information independence occurcheck many dataflow analyses dataflow analysis logic programs different analysis imperative functional programming languages partly language nondeterministic impor tantly dataflow sense bidirectional owing use unification point variable logic programming language different variable language paradigms sometimes referred logical variable characterized constrainonly since execution logic program proceeds steps continually narrow set possible values variable may take characteristic logic program execution makes dataflow analyses harder ways also opens new views analysis problems example suggests possibility propagating conditional invariants form point variable x ever gets property p variable property r note show applies groundness idea let statement program variable x ground represented propositional variable x groundness dependency whenever becomes ground may represented boolean function case function denoted x use boolean functions approximations runtime states abstract interpretation gives natural way specifying precise groundness analysis sections 2 3 idea new different classes boolean functions used purpose main purpose note show exactly one classes positive functions useful property shall refer condensation section 4 owing property relatively simple efficient implementation possible yielding extremely precise analysis analysis efficient partly queryindependent describe analysis section 5 give novel program transformation makes straightforward extract information runtime call patterns furthermore analysis performed incremental fashion without loss accuracy section 6 dataflow information pertinent module may computed independently predicates imported module class positive functions condensing also closed existential quantification unfortunately quantifier elimination expensive presence boolean functions unknown precisionpreserving extension analysis modular programs may mainly theoretical interest abstract interpretation logic programs consider idea logic program interpreter answers queries returning set answer constraints also thoroughly annotated version program program point lists constraints obtained stage evaluation given query since control may return program point many times evaluation annotation naturally possibly infinite set constraints properly formalized idea leads notion collecting semantics semantics gives precise dataflow information course finitely computable general however replace possibly infinite sets constraints crude approximations descriptions sets constraints may obtain dataflow analysis terminates finite time idea behind abstract interpretation logic programs example 21 program query qa x collecting semantics associates fl crude approximation associates sets greater equal given collecting semantics introduce notation fug set constraints ground u associating fug fl correct approximation though precise still tells us every spawned query ground first argument leads view dataflow analysis approximation collecting semantics p r cousot 6 formalized idea follows standard domain powerset constraints example description domain x powerset variables example complete lattices monotonic giving meaning descriptions x furthermore fl x image x fl moore family closed greatest lower bound operation example 21 grounds every ordering sets variables superset ordering case larger set constraints fewer variables made ground constraints set general ordering lattice descriptions opposite normally used denotational semantics higher description applies larger set constraints less information contents higher means less precise notion approximation made exact follows x write x syntactic objects programs primitive constraints 0 iff finally extend function spaces follows consider define f g iff 8 x formal semantics given laying appropriate semantic domains specifying certain operators domains groundness analysis one important operation add takes term equation set constraints forms possible conjunctions important feature p r cousots adjoined framework given operation standard domain least precise operation description domain approximates descriptions form moore family shall refer precise operations induced operations general unique induced approximation referring induced groundness analysis mean analysis obtained using induced version add 3 groundness analysis using boolean functions seen natural description domain groundness analysis sets variables definitely ground particular program point descriptions introduced mellish used early mode groundness analyzers 11 18 regard set fx 1 x n g representing nplace boolean function x 1 x n attach meaning point program variables x bound ground terms let con set conjunctions variables con simplest useful description domain groundness analysis anything less expressive cannot capture type statements require groundness analysis however con lead precise groundness analysis ignores aliasing dependencies variables witness following example label program points interest example 31 consider following program query qx ra analysis based con deduce x ground b fl fail deduce also ground fact x aliases captured aliasing information captured complex boolean functions implication allowed example constraint query evaluation description x deduced informally formula says x becomes ground z vice versa boolean formulas called dependency formulas introduced dart used groundness analysis deductive databases 7 8 denote set dependency formulas def since correspond boolean functions written definite propositional formulas program example 31 analyzed using dependency formulas descriptions description x description x desired dependency formulas give rise precise groundness analyses however even precise groundness analysis possible pos set positive boolean functions extend allowing disjunction pos suggested groundness analysis marriott sndergaard 14 less suggestive name prop studied cortesi et al 5 example 32 consider following program query qx pa u analysis based cannot deduce either x ground b fl best description produce x however analysis using pos find fl description x conjoining information x r finds b x ground practice common programs require extra precision pos nonetheless feel pos better description domain groundness analysis pos important property allows efficiently implemented somewhat surprising one would expect extra precision come cost efficiency reason pos closed disjunction condensing property discuss section 4 remainder section formalize pos description domains note pos largest class boolean functions makes sense use descriptions groundness analysis since groundness undecidable dataflow analysis operating finite time give approximate groundness information statements produces carry modality x inevitably ground reason positive boolean functions useful associate meaning x inevitably ground formula x x would mean x may always ground contains information exactly information conveyed constant function true definition boolean function function f bool n bool call set nary boolean functions bfun n let ordered logical consequence j function f positive iff f true denote set positive boolean functions n variables pos n simplicity assume fixed number n variables leave subscripts phrase n variables shall also use propositional formulas representations boolean functions without worrying distinction thus may speak formula function case denote f reminder fact propositional formula one class represent given boolean function put square brackets around propositional formulas think result class equivalent formulas slight abuse notation sometimes apply logical connectives classes equivalent formulas well known bfun boolean lattice fact pos forms boolean sublattice bfun terms propositional formulas meet join given conjunction disjunction respectively example 33 boolean functions x pos x convenient include nonpositive boolean function false approximation empty set constraints fact dealing complete lattice ordered logical consequence let sub denote set substitutions let eqn denote set constraints prolog setting note constraints possibly existentially quantified term equations ideas generalize naturally constraint logic languages substitution unifier constraint e iff denote set unifiers e idea using pos constraint e described oe 2 pos exactly case every unifier e truth assignment corresponding variables ground satisfies oe definition substitution let grounds truth assignment maps variable true grounds variable false otherwise grounds defined grounds vars set variables syntactic object function defined thus fl maps oe 2 pos set constraints e property matter become constrained e 0 boolean function corresponding e 0 still satisfy oe example 34 boolean function x describes constraints constraint best description b constraint best description x turn logical consequence x less precise approximation x example let approximated oe proposition 31 17 fl pos moore family let us define con let def largest class positive boolean functions whose models closed intersection let con monotonic functions like moore families con applicable domains groundness analysis well known existential quantifiers eliminated boolean functions 9 x perhaps less obvious fact con closed existential quantification simplifies use groundness analysis since important operation projection away variables become uninteresting projection operation exactly existential quantification condensation sometimes optimizations performed compiler applicable certain types queries reason dataflow analyses suggested logic programs query directed compute approximation collecting semantics particular query description seen collecting semantics gives information program points particular gives information calls predicate answers predicate instance example 32 collects information calls rx b collects information answers qx information calls answers may also computed queryindependent fashion case analysis performed possible queries advantage one analysis performed even information many different queries needed since information particular query efficiently derived result queryindependent analysis unfortunately result twostep process may well less precise obtained separate querydirected analysis apparent example 41 however one point note cases precision lost using queryindependent analysis happens domain condensing name comes condensing procedures introduced langen 12 used jacobs langen 10 work dataflow analysis logic programs think querydirected dataflow analysis function takes program query possibly statement initial state variables query yielding statement answers fixing program p query q may write function f phi phi domain descriptions statements available put superscript phi reminder fact dataflow analysis one induced phi precise denotational definition f phi parametric phi found 17 definition description domain phi condensing iff f phi programs p queries q statements oe oe 0 2 phi note particular f phi pq true means analysis respect program p query q need repeated several different oe needs performed general case true make assumptions instantiation variables whatsoever yields oe 0 required answer oe oe 0 applies toplevel query every call made execution p also note definition condensing considers answers query however shall see condensation also allows us compute information pertaining arbitrary program points example 41 consider program p query q example 32 f con f f pos illustrates relative accuracy three domains furthermore f con f con def condensing use condensing somewhat different jacobs langen notion stronger consider induced analysis f phi pq makes possible consider condensing property domain phi jacobs langen allow suboptimal analyses idea sometimes condensation achieved introducing loss accuracy analysis even though notions differ following result obtained combining theorems 14 65 67 68 langen 12 since operations langen uses pos fact induced operations case domains langens treatment theorem 41 pos condensing saw con condensing fact since closure necessary condensation theorem 42 pos smallest extension con condensing summarize pos condensing groundness analysis using pos modular closed form result calling predicate p need worry context p called compute ps result different environments 5 efficient groundness analysis debray 9 shown analysis using pos effect solving exptimecomplete problem complexity measured terms program size however reasonable assumption number variables clause bounded analysis using pos ptime fact number independent implementations pos indicate accurate groundness analysis perfectly practical realworld programs natural representation boolean functions used example le charlier van hentenryck 13 means ordered binarydecision graphs 1 le charlier van hentenryck report good results instantiating generic ab stract interpreter pos precise groundness analysis performed even efficient way pos condensing want information calls take place topdown execution suffices compute bottomup information gives approximation answers program 16 first explain compute answer information example 51 let p program first step form clark completion 2 straightforward translation yields following recursive definitions boolean functions overlap member solving member first overlap using kleene iteration get member 0 u member 1 u easy verify member 1 overlap 1 make fixpoint least solutions system recursive boolean equations results tell us example memberu called groundness statement oe result oe u far overlap concerned analysis cannot say anything groundness groundness dependencies adequate since overlap fact introduce groundness second example let us compute groundness information wellknown append program naive list reversal program interesting example requires iteration steps example 52 programs corresponding boolean functions defined 9 equation app solved iteration 9 9 least solution recursive definition boolean function app using solve least solution recursive definition rev condensation also allows efficient computation querydirected information calls occurring runtime idea use program transformation augments program predicates whose answers calls occurring original program given program point fl clause define new predicate q n holds call qx spawns call py immediately fl gives rise recursive definition boolean function q compute illustrate two examples example 53 repeat part program example 51 convenience assume interested calls member point fl context query overlap first step construct new predicate overlap overlap two clauses come two original clauses respectively continuing get overlap solving equation get overlap overlap least fixpoint equation defines overlap fl tells us example fl member called ground second argument overlap called ground second argument example 54 assume interested calls app point fl program example 52 context query rev transformation step gives recursive predicate rev rev corresponding boolean function defined rev equation rev solved iteration rev rev rev tells us revx called x ground calls app program point first second arguments ground short queryindependent analysis gives information calls answers owing condensation result contains sufficient information result respect specific query derived efficiently loss accuracy positive boolean functions contain sufficient information groundness dependencies handle every possible call context simply conjoining functions speeds computation simpler general querydirected implementations pos transformation given generalizes wellknown magicset transformation used compute information calls single query see example 19 codish demoen 4 independently investigated queryindependent groundness analysis based pos consider precision codish demoen implemented analysis experimental results encouraging especially codishdemoen approach computation queryindependent information call patterns requires computation fixpoint whereas approach single conjunction required program point 6 incremental groundness analysis groundness analysis using pos may incremental dataflow information pertinent module may computed module independently predicates imports illustrate basic idea two examples example 61 consider definition overlap assume definition member available however still analyze overlap solving recursive equation kleene iteration gives least solution equation overlap later result member arrives plugged giving result overlap example memberu turns description u always grounds arguments description overlapx actually know section 5 memberu approximated boolean function u substituted formula overlap obtain true expected example 62 consider definition ancestor relationship defined terms parent relation analyze ancestor solving recursive equation kleene iteration gives ancestor least solution equation ancestor later result parent substi tuted giving result ancestor example parentx turns description description ancestorx x three observations make method illustrated examples 1 generally applicable even context mutually recursive modules equations combined mutually recursive kleene iteration used solve system case mutually recursive simple substitution suffices 2 always terminate finite number iterations finite approximation descriptions missing predicates functions pos pos closed existential quantification thus perform quantifier elimination remove local variables leaving constants true false nonquantified variables 3 performing analysis incrementally change result accuracy lost pos condensing unfortunately although analysis always terminate clear implemented efficiently practical programs analyzed hand resulting equations large blowup caused applying quantifier elimination missing descriptions difficult see reduced codish et al 3 given general framework incremental analysis based unfold ing semantics particular analysis sketched differs analyses framework two ways first use quantifier elimination need introduce star abstractions analysis always terminate second performing analysis incrementally never loses precision pos condensing star abstraction used general case 3 assumption condensation made performing analysis incrementally may lose precision 7 conclusion groundness analysis important component dataflow analyses constraint logic programs general combination dataflow analyses easy composite analyses turns groundness component may computed separately first groundness results may used analyses without staging negative effects accuracy reason important groundness analysis accurate still efficient pos gives rise one precise groundness analyses know particular achieves accuracy complex analyses based reexecution propagation 15 utilizing condensation possible implement groundness analysis based pos efficiently empirically supported recent implementation codish demoen 4 advantage pos analysis may incremental dataflow information pertinent module may computed module independently predicates imports loss accuracy acknowledgements thank mike codish anonymous referee useful suggestions improved paper r symbolic boolean manipulation ordered binarydecision diagrams negation failure compositional analysis modular logic programs propositional logic programs magic wand abstract domain groundness analysis systematic design program analysis frameworks dependency analysis query interfaces deductive databases derived dependencies connected databases complexity dataflow analysis logic programs static analysis logic programs independent paral lelism semanticsbased framework abstract interpretation prolog advanced techniques approximating variables logic programs groundness analysis prolog implementation evaluation domain prop notes tutorial abstract interpretation logic programs propagationbased analysis logic programs denotational abstract interpretation logic programs global optimizations prolog compiler abstract interpretation kind magic tr derived dependencies connected databases symbolic boolean manipulation ordered binarydecision diagrams static analysis logic programs independent parallelism groundness analysis prolog compositional analysis modular logic programs denotational abstract interpretation logic programs analysing logic programs using myampersandldquopropmyampersandrdquoositional logic programs magic wand abstract interpretation systematic design program analysis frameworks complexity dataflow analysis logic programs advanced techniques approximating variable aliasing logic programs ctr vitaly lagoon peter j stuckey precise pairsharing analysis logic programs proceedings 4th acm sigplan international conference principles practice declarative programming p99108 october 0608 2002 pittsburgh pa usa roberto giacobazzi francesco ranzato francesca scozzari making abstract domains condensing acm transactions computational logic tocl v6 n1 p3360 january 2005 michael codish harald sndergaard peter j stuckey sharing groundness dependencies logic programs acm transactions programming languages systems toplas v21 n5 p948976 sept 1999 francesca scozzari logical optimality groundness analysis theoretical computer science v277 n12 p149184 april 28 2002 andy king lunjin lu backward analysis constraint logic programs theory practice logic programming v2 n45 p517547 july 2002 jacob howe andy king efficient groundness analysis prolog theory practice logic programming v3 n1 p95124 january saumya k debray complexity dataflow analysis logic programs acm transactions programming languages systems toplas v17 n2 p331365 march 1995 agostino complementation abstract interpretation acm transactions programming languages systems toplas v19 n1 p747 jan 1997 giorgio levi fausto spoto pairindependence freeness analysis linear refinement information computation v182 kim marriott harald sndergaard neil jones denotational abstract interpretation logic programs acm transactions programming languages systems toplas v16 n3 p607648 may 1994 maurice bruynooghe michael codish john p gallagher samir genaim wim vanhoof termination analysis logic programs combination typebased norms acm transactions programming languages systems toplas v29 n2 p10es april 2007 marc denecker maurice bruynooghe victor marek logic programming revisited logic programs inductive definitions acm transactions computational logic tocl v2 n4 p623654 oct 2001 roberto giacobazzi francesca scozzari logical model relational abstract domains acm transactions programming languages systems toplas v20 n5 p10671109 sept 1998 roberto giacobazzi francesco ranzato francesca scozzari making abstract interpretations complete journal acm jacm v47 n2 p361416 march 2000 roberto bagnara roberta gori patricia hill enea zaffanella finitetree analysis constraint logicbased languages information computation v193 n2 p84116 15 september 2004
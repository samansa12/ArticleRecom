cooperative strategies solving bicriteria sparse multiple knapsack problem hard optimization problems difficult design heuristic algorithms exhibit uniformly superior performance problem instances result becomes necessary tailor algorithms based problem instance paper introduce use cooperative problem solving team heuristics evolves algorithms given problem instance efficacy method examined solving six difficult instances bicriteria sparse multiple knapsack problem results indicate tailored algorithms uniformly improve solutions compared using predesigned heuristic algorithms b introduction one major goals production facility utilize inventory best possible way satisfy demand maketoorder production systems process industry surplus inventory accumulates due cancellations orders rejection production units failing satisfy quality requirements clearly advantage production facility utilize surplus inventory planning production acitivites raises problem assigning list orders production units inventory objectives maximizing total amount orders assigned minimizing total waste production units manufacturability considerations compatibility orders production units terms quality size etc impose additional assignment constraints production operations involve complex processes larger product variety problem becomes constrained bicriteria sparse multiple knapsack problem consider study motivated application paper focus use team heuristic algorithms cooperate generate nondominated solutions problem short computation time although exist several heuristic approaches solving multiple knapsack problems exist single dominant algorithm moreover performance heuristics vary problem instance result specific heuristic often demonstrate poor aggregate performance set problem instances however heuristics allowed cooperate ffl solution generated one heuristic subsequently improved another ffl appropriate subset heuristics used construct solutions given problem instance aggregate performance collection cooperating heuristics set problem instances may greatly improved purpose developed collection fast heuristics incorporated ateam architecture provides computational framework implementing cooperation strategies among heuristics present results experimental analysis compares effectiveness heuristics working individually cooperating within ateam framework additionally calibration purposes compare results feasible solutions derived using integer programming formulations since important consideration real application computation time required generate solu tions also compare performance cooperative problem solving strategy traditional integer programming techniques paper organized follows first formalize problem section 2 section 3 provide overview related work literature two versions problem single objective present collection heuristics discussion cooperative problem solving strategy used section 4 section 5 summary results experimental analysis finally conclude section 6 problem definition given set items ng set knapsacks item j 2 n weight w j knapsack capacity c associated w j c positive real numbers addition item j 2 n set j knapsacks hold item j specified convenience also specify knapsack set b n items assigned knapsack knapsack need choose subset items n assigned knapsack 1 disjoint item assigned one knapsack 2 subset b assignment restrictions satisfied total weight items assigned knapsack exceed capacity knapsack w j maximized total weight items assigned maximized i2i denotes set indices non empty due unused portion utilized knapsack minimized refer problem bicriteria sparse multiple knapsack problem bsmk without loss generality assume w removed b problem becomes trivial j disjoint p case b disjoint problem decomposes single 01 knapsack problems thus exclude cases consideration note assignment restrictions also represented bipartite graph two disjoint node sets graph correspond sets n let e corresponding bipartite graph exist edge representation sparsity problem refers edge sparsity bipartite graph g bicriteria problem relevant sparser problems constrained problems solution maximum assigned weight necessarily small waste 3 related problems literature single objective versions bicriteria problem slightly modified forms two wellknown problems literature consider objective maximizing total assigned weight alone problem variation multiple knapsack problem call sparse multiple knapsack problem smk objective minimizing total waste alone problem reduces variation variablesize bin packing problem refer sparse bin packing problem sbp classical multiple knapsack problem item go knapsack hence bipartite graph representing problem complete whereas generalize problem allowing bipartite graph hand multiple knapsack problem general objective function exists positive profit p j assigning item j knapsacks objective function maximize total profit assigned items application motivated us profit assigned item assumed proportional weight item hence maximize total assigned weight multiple knapsack problem known np hard strong sense kar72 mt90 reduction 3partition problem still valid objective function coefficients equal weights items instance smk complete bipartite graph representation also np hard strong sense thus objective maximizing total assigned weight problem strongly np hard exists fully polynomial time approximation scheme smk unless multiple knapsack problem several exact heuristic solution methods developed tested literature see martello toth mt90 survey exact solution methods consist branch bound cutting planes branch bound methods use bounds based either lagrangean relaxation 1 hung fisk hf78 surrogate relaxation 2 martello toth mt80 mt81a problem cutting plane methods use minimal cover 1dconfiguration multiple cover inequalities ferreira martin weismantel fmw96 unfortunately exact solution methods cannot solve large instances arising real applications reasonable computation time heuristic methods include fast greedy algorithms followed local exchange heuristics martello toth mt81b well nonpolynomial time approaches solving single knapsack problems successively martello toth mt81a obtaining feasible solution surrogate relaxation hung fisk hf78 considering objective minimizing waste alone produces illposed problem trivial optimal solution assign items hence consider 1 relaxing assignment constraints decomposes problem single knapsack problems getting linear combination capacity constraints results single knapsack problem version impose condition items n specified subset n must assigned goal use knapsacks minimum total capacity problem generalization variablesize bin packing problem allow assignment restrictions addition bin packing problem known np hard ie gj79 thus general problem sbp nphard well binpacking problem extensively studied literature one first problems efficient approximation algorithms developed recent survey cook garey johnson covers worst average case analyses online offline algorithms previous survey authors cgj84 considers also variations problem exact algorithms developed martello toth mt89 variablesize bin packing problem studied friesen langston fl86 provide modifications wellknown bin packing heuristics next fit first fit best fit heuristics cooperative problem solving given nphard optimization problem difficult design heuristic algorithms exhibit uniformly superior performance problem instances alternate approach tackle difficult problems organize collection heuristic algorithms cooperate uniformly exhibit superior performance might possible used separately approach especially attractive collection heuristic algorithms vary performance problem instances unpredictable way another ingredient required cooperative problem solving architecture facilitates cooperation heuristic algorithms control strategy defines rules collaboration among heuristics following paragraphs discuss detail organization ie architecture control strategy used build cooperative problem solving team heuristics multiple knapsack problem also discuss detail collection heuristics used build cooperative problem solving team 41 asynchronous teams architecture asynchronous team ateam tdsm93 architecture facilitates multiple heuristics work together common problem cooperation heuristics allowed shared population candidate solutions figure 1 provides schematic architecture architecture similar blackboard system solutions posted onto blackboard shared heuristic algorithms heuristic access entire population solutions choose appropriate partial solution work heuristics used architecture usually classified three categories based follows ffl constructors heuristics used create initial solutions ffl improvers heuristics take existing partial solutions population modify produce new solution criteria used decide whether solution added population depends choice control strategy purely hill climbing approaches genetic algorithms solutions nondominated would added population variants simulated annealing might allow entry dominated solutions population expectation might allow better solutions created later ffl destroyers heuristics remove redundant solutions population intent managing size population determination whether solution redundant difficult usually destroyer designed retain redundant solution nonzero probability note destroyers typically used control strategies allow inclusion dominated solutions population dominated solution constructors destroyers improvers dominated solution nondominated solution figure 1 schematic ateam architecture typical approach generating solutions using architecture involves creating initial population solutions using constructor heuristics subsequently evolving population solutions repeated application improver destroyer heuristics time set nondominated solutions constitute paretofrontier provide set nondominated solutions problem control strategy solution approach prescribes rules collaboration heuristics control strategy specifies two rules ffl first rule specifies improver heuristic picks solution population improve ffl second rule specifies criteria incorporating new solution created improver heuristic population implementation used stochastic hill climbing approach control strat egy stochastic hill climbing algorithm searches space aim finding state optimal properties algorithm making successive improvements current state ae 2 context paper state ae corresponds population solutions bicriteria multiple knapsack problem algorithm attempts improve current state ae making transition one neighbors ae within ateam implementation transition made randomly picking improver heuristic randomly picking solution population improver work new solution generated improver nondominated added population corresponds new state since hill climbing approach allow nonimproving moves explicitly need worry managing size population result implementation ateam bicriteria sparse multiple knapsack problem require destroyers ateam architecture used obtain good feasible solutions various combinatorial optimization problems tsp problem talukdar de souzatds93 scheduling problems arising steel paper manufacturing industry lee et al lmhm96 murthy et al marw97 reader referred talukdar de souza murthy tdsm93 ateam architecture 42 heuristics aim generating nondominated solutions bsmk developed collection constructor improver heuristics heuristics simple greedy heuristics adapted heuristics literature used multiple knapsack variablesize bin packing problems addition randomized heuristics construction heuristics mainly greedy heuristics various item knapsack selection rules addition couple heuristics round lp relaxation solution smk constructors aim maximizing total assigned weight improver heuristics either local exchange heuristics aim improve objectives heuristics rearrange assigned items among knapsacks unassign items purpose minimizing total waste next two subsections give description heuristic 43 constructor heuristics simple greedy heuristics heuristics first sort items nonincreasing order weight knapsacks nondecreasing order capacity two versions first one next knapsack order say picked next item order say j picked item j allowed go knapsack j ie exceed residual capacity knapsack item j assigned knapsack knapsack picked many items possible packed second version item order picked assigned next feasible knapsack possible heuristics running time log n log mnm call heuristics greedyknapsack greedyitem greedy heuristics various knapsack selection rules heuristics decision pick next knapsack depends assignments made upto point heuristics sort items nonincreasing order weight pick next item j pick knapsack 2 j according one three rules three versions based picking knapsack 1 minimum residual capac ity residual capacity 3 minimum surplus demand called greedyminrc greedymaxrc greedyminsd respectively surplus demand knapsack total weight unassigned items b minus residual capacity knapsack reason picking knapsack minimum surplus demand smaller surplus demand likely item fit knapsack greedymaxrc greedyminsd heuristics tend maximize assignments without considering waste greedyminrc heuristic tends minimize waste addition successive assignment heuristic another greedy heuristic rather picking knapsack item picking items knapsack one one items matched knapsacks successively objective maximizing total weight items matched iteration maximum weight bipartite matching assignment problem solved bipartite graph edge exists weight w j w j exceed residual capacity knapsack initially bipartite graph g used assignments given maximumweight bipartite matching solution performed bipartite graph updated deleting assigned nodes edges j w j exceeds residual capacity knapsack j nodes degree zero heuristic repeated graph remaining edge heuristic called successiveassign randomized heuristics greedy heuristics modified randomly order break pattern greedy choices suppose item j picked greedy heuristics item considered assignment probability p j running items heuristic repeated order assign remaining items two versions based choice p j first one p j proportional weight item j weight itemlambdac c constant factor items larger weight likely picked call heuristic randomweight second version called randomdegree degree g c degj degree node j g idea defer assignment items choices knapsacks give priority items may go knapsacks heuristics based lp relaxation smk heuristics solve lp relaxation problem single objective maximizing total assigned weight construct feasible solution rounding fractional lp solution ip formulation smk follows st p 01 variable x ij denotes whether item j assigned knapsack lp relaxation corresponds relaxing integrality variables although lp relaxation multiple knapsack problem solution constructed easily time 3 lp relaxation solution sparse problem cannot identified immediately however relaxation still solved efficiently maximum flow algorithm continuous problem reduces maximum flow problem directed graph constructed bigraph g follows edge j g directed item node j knapsack node assigned capacity source node connected item node j via arc addition sink node connected knapsack node via arc capacity c maximum flow equals lp relaxation value amount flow arc j divided w j gives value x ij thus flow assigned knapsack 0 1 variable said fractional corresponding solution two versions heuristic first one simple greedy heuristic used assign items corresponding fractional variables remaining 3 amounts solving lp relaxation single 01 knapsack problem items second version fractional variables sorted nonincreasing order values fractional variable order assignment done feasible remaining items assigned greedily first version two heuristics called lpgreedy lpround 44 improver heuristics local exchange heuristics aim improving objectives repeated improvement occurs 1 exchange items assigned different knapsacks consider pairs items assigned different knapsacks swap two items swap feasible allows unassigned item assigned one two knapsacks exchange items performed pick knapsack whose residual capacity increased repetitively assign item maximumweight assignment feasible heuristic called exchange 2 replace assigned items unassigned items replace assigned item pair assigned items single unassigned item pair unassigned items larger weight heuristics called replacesingle replacepair based whether single item pair items replaced 3 rearrange rearrange assigned items different knapsacks aggregate residual capacity one knapsack use aggregated capacity assign new items swap two items assigned two different knapsacks exchange feasible maximum residual capacity knapsacks increases pairs items considered repeat assigning new item maximum weight knapsack maximum residual capacity feasible heuristic called rearrange heuristics reduce waste 1 empty underutilized knapsacks randomized heuristic two parameters picked randomly minimum allowable utilization maximum allowable percentage decrease assigned weight cancel assignments knapsacks utilization less minimum allowable utilization decrease weight less maximum allowable percentage heuristic called empty 2 empty knapsacks randomly reassign items knapsacks utilized empty knapsack probability utilization knapsack reassign items greedyminrc heuristic heuristic called emptyandreassign 3 pack variablesized bin packing heuristics cancel assignments knap sacks reassign originally assigned items first fit decreasing best fit decreasing heuristics ie greedyitem greedyminrc heuristics heuristics called packagainffd packagainbfd respectively heuristics increase assigned weight constructor heuristics used improver assign remaining items feasible implementations used simple greedyitem heuristic purpose refer assignremaining computational experiments section examine performance cooperative problem solving strategy compare behavior traditional integer programming based techniques problem using computational experiments also compare performance cooperative strategy individual heuristics effort quantify improvements gained cooperation finally analyze nondominated solutions identify concatenations heuristics generate good solutions 51 data used real data inventory application problem steel mill industry kdtl97 instances available us number items vary 111 439 number knapsacks 1843 sparsity problems range 10 28 size sparsity instances summarized table 1 52 implementation individual heuristics coded heuristics presented section 4 c language using leda library nu95 performed tests ibm rs4000 machine operating aix first collected solutions output constructor improver heuristic found nondominated solutions among collected solutions running improvers used solution provided greedyknapsack constructor tot cap tot weight d3 393 d4 209 43 106 88921 352804 d6 155 table 1 information reallife data sparsity denotes edge density bipartite graph representation percentage number edges complete bipartite graph last two columns denote total capacity knapsacks total weight items input randomized heuristics run times best solution among runs output ateam incorporated individual heuristics ateam architecture set parameters stopping time probabilities picking constructors improvers initial tests probabilities improvers replacesingle replacepair empty emptyandreassign effective initial runs increased examined convergence solution population running ateam code cycle 100 500 1000 1500 2000 3000 heuristics observing number nondominated solutions output maximum average value assigned weight minus waste nondominated solutions decided cycle length ateam run data set statistics chosen cycle lengths given table 5 appendix ip based approaches order assess performance heuristics computational difficulty problem tried solve two ips single objective general branchandcut method first problem considered compare results sparse multiple knapsack problem smk objective maximize assigned weight ip formulation smk given section 4 second problem considered objective function sum two objectives maximize assigned weight minus waste call problem mkbp combines multiple knapsack bin packing aspects ip formulation follows st p introduce 01 variable z denote whether item assigned knapsack objective function equals 2 p lp relaxation corresponds relaxing integrality variables lp relaxation smk mkbp problems optimal value optimal solution lp relaxation mkbp zero waste hence refer relaxation problems lp relaxation order obtain best bounds possible reasonable computation time added best lower bound obtained heuristics ip formulation smk mkbp solved general integer programming solver cplex403 co94 using default settings 1 hour cpu time added upper bound output cplex formulation ran cplex waited longer larger instances d1 d3 repeated procedure better bounds found 2 hours comparison lp relaxation values upper bounds generated branch bound method data sets d1 d6 given table 2 running times given table 2 also give crude idea computational difficulty solving problems exact methods took 24 hours get optimal solution smk data set d2 could obtain optimal solution problem data lp bound ub gap time hrs ub gap time hrs d1 64185 63970 034 92 63970 034 26 d2 61264 47214 2976 24 40383 5170 44 d3 38537 38499 010 62 38114 111 80 d4 78567 68763 1405 40 60686 2946 69 d6 44401 42420 467 82 41437 715 50 table 2 comparison lp relaxation value best upper bound ub obtained branch bound method smk mkbp problems column gap denotes deviation lp bound best available bound time denotes cpu time obtain given bounds note problem gets sparser gets harder sense solution maximizes assigned weight necessarily small waste hence choice knapsack item assigned becomes critical problem gets relaxed bipartite graph representation gets closer complete graph problem gets closer multiple knapsack problem usually maximizing assigned weight suffices minimize waste time sparsity problem plays role also determining strength lp relaxation sparsity increases gap lp relaxation value optimal value gets larger problems also collected feasible solutions output cplex recorded cpu times obtain solutions runs provide bounds objective function initially reran cplex previously obtained bounds whenever stop due memory problems stopped procedure improvement could obtained till computer ran memory one may also consider using best lower bound output individual heuristics ip formulation opposed cooperative strategy however using heuristics way improve upon performance branchandcut method cplex significantly even using better bounds output cooperative strategy yield optimal solution reasonable computation time seen table 2 addition cooperative strategy advantage generating many nondominated solutions two objectives ip formulations specify one objective function 53 comparative evaluation cooperative strategy quality solutions quality solutions generated using cooperative strategy significantly better ones generated individual runs especially waste objective comparison solutions maximum assigned weight generated ateam implementation individual runs provided table 3 waste solutions also given table see cooperation heuristics useful decrease waste solutions maximum assigned weight also note could obtain solutions better assigned weight exact solution method using cplex problems except d2 solutions maximum value assigned weight waste generated ateam implementation individual heuristics cplex given table 4 observe significant difference assigned weight waste solutions generated cooperative strategy versus generated individual heuristics especially harder instances d2 d4 slightly better solutions could obtained cplex d2 d4 44 69 hours respectively larger instances d1 d3 feasible solutions output cplex significantly inferior data aw ratio waste waste cpu time 63660 09952 525 082 439906 d1 ii 61769 09656 2416 376 3781 iii 47098 09975 10824 1869 7001 iii 47214 10000 11004 1890 823605 38320 09954 564 145 983442 d3 ii 38233 09931 652 168 7232 iii 36610 09509 2274 585 4600914 68699 09990 11097 1391 31817 d4 ii 67339 09793 15554 1876 344 iii 68699 09990 14068 1700 3992320 59233 09899 9692 1406 18370 d5 ii 59023 09864 9902 1437 306 iii 59133 09882 9792 1421 3936016 40612 09574 3095 708 7646 d6 ii 40292 09498 3415 781 163 iii 40297 09500 3410 780 4657032 table 3 comparison solution maximum assigned weight obtained ateam implementation ii individual runs heuristics iii branchandcut aw assigned weight ratio ratio aw best available bound assigned weight objective table 2 waste ratio unused capacity total capacity utilized knapsacks percentage cpu time given seconds output cooperative strategy difference 10 7 best upper bound available respectively collection heuristics able generate significantly nondominated solutions cooperate ateam implementation heuristics able effectively improve objectives time result individual heuristics good enough maximize assigned weight capable minimizing waste time hand using cooperative organization heuristics favor maximizing assigned weight favor minimizing waste chance take output one another input therefore generate solutions better values objectives plots nondominated solutions generated ateam implementation individual heuristics given figures 2 3 4 appendix note problems d1 d3 less sparse compared problems solutions large assigned weight small waste time many nondominated solutions generated attributed fact two objectives almost parallel problems data awwaste ratio aw waste waste cpu time 63135 09869 63660 525 082 439906 d1 ii 59353 09278 61769 2416 376 3781 iii 56562 08842 60374 3811 594 4454333 39672 09835 45059 5387 1068 7001 d2 ii 32648 08094 33814 1166 333 148 iii 39886 09888 47131 7245 1332 1568126 37756 09906 38320 564 145 983441 d3 ii 37581 09860 38233 652 168 7232 iii 35436 09297 37160 1724 443 2872318 59555 09814 65799 6245 867 31817 d4 ii 56641 09333 64901 8261 1129 344 49714 09733 58033 8319 1254 18370 d5 ii 49121 09617 59023 9902 1437 306 iii 46590 09121 56462 9908 1493 2311735 37517 09054 40612 3095 708 7646 d6 ii 36870 08898 40292 3415 781 163 iii 36583 08829 x 40145 3562 815 1820367 table 4 comparison solution maximum assigned weight waste obtained ateam implementation ii individual runs heuristics iii branch andcut ratio obtained using best available upper bound maximizing assigned weight minus waste obtained table 2 cpu time given seconds run time clearly combining heuristics cooperative strategy increases running time cycle 1500 3000 heuristics run however still run times reasonable range significantly smaller compared branchandcut method single run individual heuristic takes seconds depending size problem heuristic used running time individual heuristic given table 6 appendix timeconsuming heuristic replacesingle heuristic takes 45 seconds d3 024 seconds d2 constructor heuristics take little time greedy heuristics run less second lpround lpgreedy heuristics take slightly time 017 131 seconds timeconsuming constructor successiveassign takes 032 425 seconds cpu time ateam implementation takes time approximately 1 minute 3 hours depending size problem still run times significantly small compared branchandcut approach cplex order 3 13 hours run times given tables 3 4 tables run time individual heuristics total time heuristics best solution picked running heuristics concatenation heuristics ateam implementation examining nondominated solutions pareto frontier shown figures 2 identify heuristics sequence applied yield particular solution naturally question arises whether really necessary randomize sequence heuristics act others solutions possible identify one sequences concatenation heuristics yield paretofrontier problem instances might abandon stochastic control strategy constructing solutions section show concatenation heuristics used generate paretofrontier varies significantly problem instance illustrates need tailor solution strategy problem instance automated stochastic control strategy adopted paper nondominated solution generated ateam implementation traced heuristics whose output solutions used obtain nondominated solution conclude heuristics effective repeated nevertheless observed regular patterns sequence agents called across different problem instances justifies use ateam approach concatenation heuristics opposed identifying effective patterns using patterns instead ateam implementation total number occurrences heuristic participates generation nondominated solutions problem instance given table 7 appendix see lpround frequently used constructor local exchange heuristics replacesingle replacepair waste reduction heuristics empty emptyandreassign effective improvers generating nondominated solutions also give heuristics output nondominated solutions individual runs table 8 comparison purposes statistics presented tables clearly indicate patterns used constructing paretofrontier varied significantly across problem instances figures 58 appendix illustrate construction nondominated solutions generated ateam implementation 6 conclusions paper introduced bicriteria sparse multiple knapsack problem characterized computational complexity problem experimentally computing gap lp relaxation best derivable bound showed increased sparsity makes problem difficult integer programming techniques unable generate solutions reasonable amount time new cooperative problem solving technique introduced used collection fast heuristic algorithms embedded cooperative problem solving architecture called ateams solutions generated using approach shown superior derived using heuristics individually feasible solutions derived integer programming techniques cooperative problem solving strategy shown alternative approach automating design heuristics hard combinatorial problems r approximation algorithms binpacking updated survey approximation algorithms binpacking survey variable sized bin packing solving multiple knapsack problems cutting planes computers intractibilitya guide theory np algorithm 01 multiple knapsack problems reducibility among combinatorial problems surplus inventory matching problem process industry primary production scheduling steelmaking industries solution zeroone multiple knapsack prob lem bound bound algorithm zeroone multiple knapsack problem heuristic algorithms multiple knapsack problem knapsack problems lower bounds reduction procedures bin packing problem leda user manual version r 32 asynchronous organizations multi algorithm problems organizations computerbased agents tr ctr jayant r kalagnanam andrew j davenport ho lee computational aspects clearing continuous call double auctions assignment constraints indivisible demand electronic commerce research v1 n3 p221238 july 2001
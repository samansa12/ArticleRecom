local convergence symmetric rankone iteration consider conditions sr1 iteration locally convergent apply result pointwise structured sr1 method used optimal control b introduction symmetric rankone sr1 update 1 quasinewton method preserves symmetry approximate hessian optimization problems jacobian nonlinear equations analysis paper nonlinear equations point view purpose prove local convergence result using concept uniform linear independence 5 extend result structured updates part jacobian computed exactly apply results pointwise sr1 update considered 14 context optimal control begin nonlinear equation r n make standard assumptions nonlinear equations assumption 11 f root x ffi 0 jacobian f 0 x exists lipschitz continuous set lipschitz constant fl f 0 x nonsingular later paper assume f 0 x symmetric near x use sr1 update maintain symmetric approximations f 0 x current approximations iteration computes new point x computing search direction updating x c version may 17 1995 north carolina state university department mathematics center research scientific computation box 8205 raleigh n c 276958205 tim kelleyncsuedu research author supported national science foundation grant dms9321938 north atlantic treaty organization grant crg 920067 computing partially supported allocation time north carolina supercomputing center z universitt trier fb iv mathematik graduiertenkolleg mathematische optimierung 54296 trier germany sachsunitrierde research author supported north atlantic treaty organization grant crg 920067 updated form b setting updating b c obtain update b skipped observations reported 15 4 5 19 10 18 11 20 14 indicate sr1 outperform bfgs context optimization either approximate hessians expected positive definite trustregion framework used 3 4 5 one modification sr1 allows convergence analysis proposed 17 sr1 update considered 2 shown local superliner convergence theory paper apply updates could become undefined preservation symmetry attractive feature possibility storing one vector per iterate matrixfree limited memory implementation however implementations store single vector iteration known broydens method 8 13 bfgs method 21 much better understood convergence properties advantage sr1 method others reduction number iterations reduction observed many authors indicated standard update approximate jacobian oe 2 0 1 fixed many recent papers 5 15 3 sr1 15 arbitrary choice oe one assumptions used prove convergence b n numerical results presented 5 15 3 use small values oe paper done 14 use larger value oe treatments sr1 iteration way improve stability estimates x 2 used rough guide selection appropriate value oe numerical results x 5 illustrate benefits varying oe paper show initial approximations solution jacobian sufficiently good sequence steps satisfy 15 also satisfy uniform linear independence condition 5 iteration locally linearly convergent sequence fb k g remain near f 0 x stronger uniform linear independence condition implies kstep superlinear convergence integer k thus goal different 5 15 3 convergence iteration solution assumption conditions given guaranteed convergence approximate jacobians f 0 x uniform linear independence condition may seem strong reasonable condition small problems problems arise part pointwise sr1 method proposed 14 certain optimal control problems results paper give insight use improve performance pointwise sr1 method x 2 state prove basic convergence results consider structured updates x 3 application pointwise updates x 4 finally report numerical results x 5 2 basic lemmas convergence results deal local convergence paper take full steps use fact direct consequence definition equation quasinewton step b c hence sr1 update use notation errors jacobian solution approximations may happen many iterations take place updates b must introduce notation keep track iterations result change b say n major step x n1 major iteration b n1 major update 1 case b n1 6 b n step minor step major step hence update b takes place local convergence theory must show new approximation b n1 jacobian solution nonsingular proving analog bounded deterioration results used study quasinewton methods however inherent instability must kept check uniform linear independence becomes important 21 stability base main result several lemmas first simply summarizes well known results nonlinear equations 6 13 16 nothing assumption symmetry f 0 x particular quasinewton method lemma 21 let assumption 11 hold let ae 2 0 1 given ffl 0 ffi 0 x c b c satisfy b c nonsingular moreover lemma 22 let hypotheses lemma 21 hold c 1 c major step ks c k ks c proof 22 hence using 26 ks c k ks c k 27 c apply 29 obtain hence 28 follows 26 fact c 1 fl point need consider sequence major steps several minor steps 15 fails could lie two major steps effect estimates approximate jacobians also first place symmetry e hence f 0 x plays important role remark 211 212 differ estimates ke k k used recent papers 5 15 assumption good approximations x f 0 x used crucial way next lemma uses general approach 5 observation 5 15 major steps need considered estimates lemma 23 let assumption 11 hold let ae 2 0 1 let ffl 0 ffi 0 conclusions lemma 21 hold let k 0 x 0 b 0 f 0 symmetric least k major steps taken b k1 nonsingular moreover sequence first k k major steps iterations updates 1 k k also 0 ks proof set note implies ks prove lemma induction k 214 obtain 212 28 213 211 holds k k k 27 214 use induction hypothesis c obtain proves first inequality 211 second inequality 210 apply lemma 21 conclude least k major steps taken k hence ks ks l k assuming 212 holds note 212 consequence lemma 22 oeks k every e k symmetric e 0 hence write combining 216 26 yields hence 215 ks ks proof 211 apply 218 219 induction hypothesis 217 get ks verifying 212 estimates lemma 23 analogs bounded deterioration results common quasinewton method literature however case deviation b k f 0 x exponentially increasing least according bounds lemma 23 eventually become large convergence may lost sr1 update however selfcorrecting property linear case 9 exploited much recent work method 15 3 5 selfcorrection property overcomes instability indicated estimates 211 212 22 uniform linear independence uniform linear independence assumption differs slightly 5 consider major steps concerned point total number major steps required form sequence linearly independent major steps assumption 21 c min 0 k n hypotheses lemma 23 hold moreover sets columns normalized major steps subsequence fv p extracted matrix p columns fv p minimum singular value least c min 23 convergence results using assumptions prove qlinear convergence directly using lemma 23 methods exploitation uniform linear independence 5 theorem 24 let assumptions 21 hypotheses lemma 23 hold let ae 2 0 1 given sufficiently small sr1 iterates converge qlinearly x qfactor ae proof proof based simple observation lemma 23 states iteration may proceed major steps assumption 21 implies iteration may continue 23 implies k 214 ks ks k k note min enough replaced e k e k hence may continue iteration lemmas 21 23 obtaining qlinear convergence qfactor ae 3 structured updates order apply convergence results optimal control problems context pointwise updates next step extend statements previous sections case structured updates use notational conventions 7 formulation suppose jacobian f 0 f split lipschitz continuous computable part cx part ax approximated sr1 update define sr1 update step computed solving choose secant condition b holds obtain 32 33 hence sr1 update written perturbation f f x c use notation errors jacobian next apply lemma 21 obtain similar estimate lemma 31 let assumption 11 hold let ae 2 0 1 given ffl 0 ffi 0 x c b c structured sr1 update satisfy defined satisfies moreover ks c proof note lipschitz constant fl c c holds since lemma 21 holds arbitrary approximations jacobian x exists 38 holds observing ks c k 2 proves 39 completes proof next lemma extension lemma 22 state lemma define update skipped update b oe 2 0 1 fixed definition minor major steps x 2 310 playing role 15 lemma 32 let hypotheses lemma 31 hold c 1 c major step ks c k ks c proof structured updates note ks c k 310 changed accordingly proof lemma 22 f x replaced f next lemma symmetry assumed causes additional changes proof lemma 33 let assumption 11 hypotheses lemma 31 hold let least k major steps taken b k1 nonsingular moreover sequence first k k major steps iterations updates 1 k k also 0 ks proof first part induction proof 315 identical one lemma 23 therefore omitted assuming 316 holds note 316 consequence lemma 32 313 oeks k write 39 combining 318 39 yields note assumption hence definition 36 hence 317 ks x 2 proof 211 apply 320 321 induction hypothesis 319 get ks verifying 316 using definition uniform linear independence x 22 may state structured analog theorem 24 proof essentially identical theorem 24 theorem 34 let assumptions 21 hypotheses lemma 33 hold let ae 2 0 1 given sufficiently small sr1 iterates converge qlinearly x qfactor ae 4 pointwise structured updates optimal control order apply convergence results optimal control problems context pointwise updates next step extend statements previous sections case pointwise structured updates nonlinear equations represent necessary conditions optimal control problem minimize set solves adjoint equation seek solve nonlinear system h u x u tc b satisfy boundary conditions use following assumption assumption 41 f l first second partial derivatives respect x u continuous ir n theta ir theta 0 assumption f frechet differentiable frechet derivative given b dt components multiplication operators two parts f 0 containing information first derivatives az consisting second order derivatives entries depend time az typically approximated family quasi newton updates depending also time use pointwise analog 310 update b 2 0 structured sr1 update order justify use pointwise updates state next lemma lemma 41 b 0 given form 43 b k defined 46 also multiplication operators proof proof via induction show step b c b write note 44 since differentiation operator appears linearly f c cancels h implies differentiability assumption data pointwise holds oe 2 l 1 0 since b c also l 1 decision update formula 46 shows components b measurable functions also essentially bounded either using choice oe 46 47 completes proof next lemma gives pointwise estimates error jacobian context pointwise updates used later uniform estimates lemma 42 assume 2 0 multiplication operator let major step e also multiplation operator following estimates hold ks c tk ks c tkks c tk proof observe rewrite 44 pointwise assumption last term multiplication operator therefore contain differentiation operator first second term parentheses cancels estimate pointwise given smoothness assumptions data ks c hence obtain 313 using 412 pointwise ks c tk ks c tk estimate ke c k recall secant condition therefore 49 holds furthermore 411 ks c k 2 next lemma describes linear rate estimate uniform norm lemma 43 ae 2 0 1 ffl 0 ffi 0 c major step b c pointwise structured sr1 update satisfies defined satisfies moreover fl c ks c k1 ks c k 2415 proof assumptions imply small lemma 21 invoked yield 413 deduce ks c k1 48 gives ks c k1 414 way use 49 410 obtain 415 416 resp 5 numerical results present numerical results illustrate observations previous sections let us consider following class examples first set furthermore set x initial data given update true 14 used discretization parameter comes discretization twopoint boundary value problem trapezoid finite difference scheme used richardson extrapolation achieve 4th order accurate results see eg 12 indicates termination criterion approximate norm discrete case also accuracy order 4 numbers column upd give percentage 121 3 theta 3matrices updated iteration k difference matrices computed follows kbtk f denotes frobeniusnorm r 3theta3 table 51 report results sr1 update choice oe based truncation error discretization scheme h 4 06 theta 10 gamma5 tables 52 53 show effects conservative updating strategies analysis preceding sections indicates larger value oe keep smaller might thereby allow monotone iteration increase factor 100 reduce size ke k k lead improvement overall performance see table 52 increasing oe factor 1000 see table 53 led performance improvement 20 table 52 used less stringent requirement updating hessians table oe increased factor 10 2 note reduced error hessian updates early phase algorithm table 9 072865d04 0002 17 332568 table table r analysis symmetric rankone trust region method testing class methods solving minimization problems simple bounds variables numerical methods nonlinear equations unconstrained optimization convergence theorems least change secant update methods fast secant methods iterative solution large nonsymmetric linear systems john wiley sons algorithm optimizing functions multiple minima numerical solution two point boundary value problems iterative methods linear nonlinear equations pointwise quasinewton method unconstrained optimal control problems theoretical experimental study symmetric rank one update iterative solution nonlinear equations several variables new approach symmetric rankone updating algorithm yield optimization using gaas process simulator coupled physical device model large scale nonlinear least squares calculations compact storage broydenclass quasinewton matrices tr ctr p spellucci modified rank one update converges qsuperlinearly computational optimization applications v19 n3 p273296 september 2001
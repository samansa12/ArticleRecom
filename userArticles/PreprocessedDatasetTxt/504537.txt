normal form algorithms extended contextfree grammars investigate complexity variety normalform transformations extended contextfree grammars extended mean set righthand sides nonterminal grammar regular set study motivated implementation project grama provide c toolkit symbolic manipulation contextfree objects grail regular objects results generalize known complexity bounds contextfree grammars nontrivial ways specifically introduce new representation scheme extended contextfree grammars symbolthreaded expression forest new normal form grammars dot normal form new regular expression algorithms copyright 2001 elsevier science bv b introduction 1960s extended contextfree grammars introduced based backusnaur form useful abbreviatory notation made contextfree grammars easier write recently standardized general markup language sgml 16 used similar abbrevia tory notation define extended contextfree grammars documents currently extensible markup language xml 6 simplified version sgml promoted markup language web instead html specific grammar document type definition dtd specified using sgml developments led investigation notions applicable contextfree grammars could carried extended contextfree grammars appear consolidated effort study extended contextfree grammars right begin investigation basic research supported grant research grants council hong kong sar carried first second authors visiting hkust lerhstuhl fur informatik ii universitat wurzburg hubland d97074 wurzburg germany email albertinformatikuniwuerzburgde z dipartimento di matematica applicata e informatica universita ca foscari di venezia via torino 155 30173 venezia mestre italy email doradsiuniveit x department computer science hong kong university science technology clear water bay kowloon hong kong sar email dwoodcsusthk problems extended contextfree grammars reduction normalform transformations related work directly motivated sgml issues see proof decidability structural equivalence extended contextfree grammars 4 demonstration sgml exceptions add expressive power extended contextfree grammars 17 currently designing manipulation system toolkit grama extended contextfree grammars pushdown machines contextfree expressions extension grail 20 19 similar toolkit regular expressions finitestate machines sult need choose appropriate representations grammars machines admit efficient transformation algorithms well algorithms interest earlier results contextfree grammars obtained harrison yehudai 12 13 26 hunt et al 15 among others harrisons chapter normal form transformations 12 provides excellent survey early results cohen gotlieb 5 suggested specific representation contextfree grammars demonstrated aided programming various operations first define extended contextfree grammars using notion production schemas based regular expressions separate paper 9 discuss algorithmic impact basing schemas finitestate machines since finitestate machines regular expressions firstclass objects grail used interchangeably expect grama next describe algorithms fundamental normalform transformations section 3 propose representation extended contextfree grammars regular expression forests symbol threads discuss algorithmic problems regular expressions tackling various normal forms close presentation section 4 brief discussion ongoing investigations notation terminology treat extended contextfree grammars contextfree grammars righthand sides productions regular expressions let v alphabet define regular expression v language usual way 1 25 kleene plus additional operator symbol denotes null string extended contextfree grammar g specified tuple n sigma sigma disjoint finite alphabets nonterminal symbols terminal symbols spectively p finite set production schemas nonterminal sentence symbol production schema form aea nonterminal ea regular expression contain emptyset symbol string fi 1 fffi 2 derived string fi denote fact writing fifi 1 fffi 2 language lg extended contextfree grammar g set terminal strings derivable sentence symbol g formally denotes transitive closure derivability relation even though production schema may correspond infinite number ordinary contextfree productions known extended standard contextfree grammars describe exactly languages example see texts salomaa 23 wood 25 denote size regular expression e jej define number symbols operators e denote size set also jaj measure complexity grammatical transformation need define size grammar two traditional measures size contextfree grammar generalize extended contextfree grammars follows given extended contextfree grammar define size jgj g x define norm k g k g clearly norm realistic measure grammars size takes account size encoding symbols grammar use size measure however since extension results norm measure straightforward 3 normalform transformations introduce notion expression forest treebased representation set regular expressions appear righthand sides production schemas production schemas righthand side represented expression tree usual way internal nodes labeled operators external nodes labeled symbols addition represent nonterminal lefthand side production schema single node labeled nonterminal node also references root expression tree corresponding righthand side fig 3 give example forest two regular expressions since extended contextfree grammar number production schemas regular expressions represent grammars expression forest tree forest corresponds one production schema tree named corresponding nonterminal naming avoids tree repetition problem add threads thread symbol x connects appearances symbol x expression forest 31 reachability usefulness recall symbol x reachable appears string derived sentence symbol derivation ffxfi ff fi possibly null strings standard contextfree grammars reachable symbols easily identified means digraph traversal precisely construct digraph whose vertices symbols n sigma edge b b labels external node expression tree named assume production schemas contain theta theta aa theta theta theta theta theta theta omega omega omega omega j jj theta theta theta theta figure 1 expression forest extended contextfree grammar production schemas omitted symbol threads clarity emptyset symbol depthfirst traversal digraph starting gives reachable symbols grammar times taken digraph construction traversal linear size grammar nonterminal symbol useful derivation ff terminal string set useful symbols computed recursively follows compute b leb contains string terminal symbols possibly null string useful symbols symbol useful lea contains string terminals currently detected reachable symbols newly useful symbols identified formalize inductive process marking algorithm described wood 24 contextfree grammars major difference previous work approach taken want obtain efficient algorithm yehudai 26 designed efficient algorithm determining usefulness contextfree grammars approach viewed generalization algorithm explain marking algorithm assume one bit available node expression forest indicate marking initialize bits preorder traversal forest follows bits nodes set zero unmarked except nodes labeled kleene star symbol terminal symbol nullstring symbolthe bits nodes set one marked algorithm whenever node u marked useful satisfies condition language subtree rooted u contains string completely marked kleenestar node marked since subtrees language contains null string kleenestar node always useful completing initial marking bubble markings trees propagation phase follows repeatedly examine newly marked nodes follows newly marked nodes obtained newly marked node u pu us parent u root perform one following actions pu plus node pu marked mark pu pu dot node pu marked us sibling marked mark pu pu kleeneplus node mark pu pu kleenestar node already marked u root node expression trees nonterminal symbol marked mark expression trees nonterminal symbol newly marked nonterminals initial round mark appearances expression forest repeat propagation phase bubbles markings newly marked symbols trees newly marked nonterminals algorithm terminates algorithm therefore number rounds beginning round marks appearances newly discovered useful nonterminals discovered previous round bubbles newly marked nonterminals trees long round marks new nodes propagation process repeated implement process efficiently construct beginning round queue newly marked nodes note queue catenation appearance lists first round algorithm repeatedly deletes newly marked node queue using preceding propagation rules may also add newly marked nodes queue round terminates queue empty observe node expression forest visited twice dot node visited twice thus marking algorithm runs ojgj time space recall grammar g reduced symbols useful reachable standard contextfree grammars reduce grammar first identify useful symbols select together corresponding schemas also reachable formally identifying useless nonterminals terminals always useful first remove production schemas g second remove productions schemas contain useless nonterminal righthand sides steps ensure threads maintained correctly first step need remove production schemas also reconnect threads symbol appearances removed use traversal schema identify symbols remove appearances appropriate threads second step use threads useless symbols remove corresponding productions simply replace useless symbol emptyset symbol remove thread apply emptyset removal algorithm regular expressions production schema thus obtain equivalent grammar next identify unreachable symbols g remove production schemas unreachable nonterminals maintain threads correctly observe unreachable terminal symbol appear production schemas unreachable nonterminals reachable symbols appear production schemas reachable nonterminals thus obtain g 0 g linear time summarize result section follows theorem 1 let extended contextfree grammar represented expression forest equivalent reduced extended contextfree grammar g constructed g time ojgj jg represented expression forest 32 nullfree form given reduced extended contextfree grammar determine nullable nonterminals ones derive null string using similar algorithm one used usefulness section 31 algorithm takes ojgj time given nullability information make given grammar null free two steps first replace appearances nullable symbol regular expression step takes time proportional total number appearances nullable symbols gwe use symbol threads fast access second transform production schema aea nullable nullfree production schema 62 le 0 unfortunately step take time o2 jgj worst case use typical textbook algorithm production schema nested dotted subexpressions operand dot produce null string replace dotted subexpression f delta g transformed version f produce null string note least double length dotted subexpressions similar doubling occur subexpressions f g subexpressions obtain exponential worstcase bound note case occurs standard contextfree grammar every nonterminal nullable want however obtain linear blowup size resulting grammar since nested dot expressions cause nonlinearity modify grammar remove nested dot expressions approach first suggested yehudai 13 26 standard contextfree grammarshe converted given grammar chomsky normal form avoid dot problem take similar approach removing nested dot kleeneplus kleenestar subexpressions production schemas removal generates new nonterminals production schemas however size resulting grammar linearly larger original grammar replace dot kleeneplus kleenestar node expression tree dot kleeneplus kleenestar ancestor new nonterminal add new production schema grammar repeat local modification nested nodes exist example given production schema replace new production schemas repeating transformation b obtain repeating transformation obtain ad say resulting grammar dot normal form size order original size number nonterminals increased size original grammar reduced extended contextfree grammar represented expression forest equivalent reduced extended contextfree grammar g dot normal form constructed g time ojgj jg 0 j ojgj jn 0 j ojgj jp 0 j ojgj moreover g 0 also represented expression forest apply simple nullremoval construction grammar g dot normal form produce new grammar size ojgj algorithm runs time ojgj theorem 3 let reduced extended contextfree grammar dot normal form represented expression forest equivalent reduced nullfree extended contextfree dot normal form constructed g time ojgj jg 0 j ojgj jn 0 j ojn j jp 0 j ojp j moreover g 0 also represented expression forest 33 unitfree form unit production production form ab transform extended contextfree grammar unitfree form three steps first identify instances unit productions second remove unitproduction instance schema third last modified schema add unitfree schemas unitproduction instances modified schema discuss three steps detail assume reduced null free extended contextfree grammar g also dot normal form identify instances unit productions observe schema ea roottofrontier path contains one dot kleeneplus node kleenestar nodes assume unitproduction instance b ea ab aea immediately none bs ancestors dot nodes ancestor plus node one ancestor kleeneplus node identify unit productions carry preorder traversal ea identify roottofrontier paths satisfy necessary conditions unitproduction instances also nonterminal frontier nodes step takes ojea whenever traversal meets kleeneplus node plus node continues traversal corresponding subtrees meets dot node terminates part traversal eventually traversal reaches node labeled nonterminal b occurrence b corresponds unit production overall running time first step ojgj second remove instances unit productions schemas transform production schema aea production schema ae 0 define new threading refer unit thread connects occurrences nonterminals correspond unit productions schemas threading constructed identification step used second step furthermore identifying unit productions determine nonterminal set ua nonterminals unit reachable note ua may contain use sets modify production schemas third step traverse expression trees frontiers roots particular follow paths start nodes labeled nonterminals correspond unit productions access following unit threads assume removing instance b ancestors plus nodes possible exception one ancestor kleeneplus node remove unit appearances kleeneplus subtrees globally transform kleene plus subexpressions form f expression forest idea behind global transformation separated unit appearances f nonunit appearances symbols f since unit appearances occur first f nonunit appearances symbols appear subexpression node u kleeneplus node expression tree make two copies us subtree r call ensure maintain threads except unit threads remove kleeneplus node reconnect r r removal unit appearances nonterminal b straightforward arrive node labeled b following unit thread replace b bs parent bs sibling terminate process occurrence b case covered ab production case b parent therefore left temporarily empty expression tree note b 6 since useful time complexity second step first step third last modify production schemas nonterminal nonterminal symbols unit reachable include new production schema resulting grammar size ojgj 2 quadratic blow since must make copies subtrees give expression tree algorithm takes therefore ojgj 2 time theorem 4 let reduced nullfree extended contextfree grammar dot normal form represented expression forest equivalent reduced dotnormalform nullfree unitfree extended contextfree grammar g constructed g time ojgj 2 jg 0 j ojgj 2 ojgj moreover g 0 also represented expression forest note ensure blow linear make multiple copies various subtrees merely provide links one copy distinct subtree approach takes ojn space grammar g 34 greibach form normal form result contextfree grammars established sheila greibach 10 1960s key result use multiplepath syntactic analyzer developed harvard university time extended contextfree grammar greibach normal form productions following form terminal symbol ff possibly empty string nonterminal symbols transformation extended contextfree grammar greibach normal form requires two giant steps leftrecursion removal back left substitution recall grammar left recursive nonterminal grammar string ff consider second step first assume given extended contextfree grammar factored nonterminal string x lea either completely nonterminal single terminal symbol straightforward factor grammar make grammar null free avoid possible introduction unit productions addition second step also assume grammar nonleft recursive since grammar nonleft recursive partial order nonterminals left reachability defined b leftmost derivation usual consider nonterminals enumerated whenever j j observe n already greibach normal form since productions form n 2 sigma convert nonterminals one time ngamma1 1 conversion conceptually simple yet computational expensive converting replace nonterminals appear first positions strings lea schemas thus resulting schema e 0 greibach normal form able carry substitution efficiently first convert schema ea first normal form express schema sum regular expressions begins unique symbol precisely letting using notation e instead ea simplicity replace defined follows nm delta nm conversion must equivalent regular expression greibach normal form need replace first k term k k grammar left recursive first need make nonleft recursive use technique introduced greibach 11 investigated detail hotz coworkers 14 21 22 rediscovered others 7 involves producing nonterminal distinct subgrammar g left linear hence converted equivalent right linear grammar conversion changes left recursion right recursion introduce new left recursion details see woods text 25 important property leftlinear subgrammars every sentential leftmost derivation sequence g mimicked sequence leftmost derivation sequences sentential leftmost derivation sequence one leftlinear subgrammars convert leftlinear grammars rightlinear grammars property weakened mimic original derivation sequence sequence sentential rightmost derivation sequences rightlinear grammars new grammar equivalent g collection distinct rightlinear grammars one nonterminal g modified grammar longer left recursive apply back left substitution obtain final grammar greibach normal form well algorithm perform left recursion removal causes blow jn jjgj worst converting production schemas first normal form causes additional blow jn jjgj use derivative de dx regular expression e symbol x give new expression f lf le derivative regular expression introduced brzozowski 3 defined inductively given schema ea obtain derivatives symbol x 2 n sigma catenate x derivative obtain one terms first normal form since g null free derivative cause exponential blow df dx dx transform g kleeneplus subexpression nested within kleene plus expressiona similar transformation one used conversion dot normal form modification ensures exponential blow occur back left substitution causes worst case additional blow jn jjgj size greibach normal form grammar three operations take time proportional sizes output grammars essentially transformation greibach normal form takes ojn worst case reason jn j 5 term first remove left recursion increases size grammar also squares number nonterminals jn j number nonterminals crucial size bound grammar obtained first normal form conversion back left substitution however reduce worstcase time space using indirection unitproduction removal rather performing back left substitution specific nonterminal use reference schema technique gives blowup jgjjn j 2 thus reduces complete conversion time size ojn j 3 jgj worst case may also apply technique koch blum 18 suggested namely leave unit production removal obtained greibachlike normal form moreover transforming extended contextfree grammar dot normal form appears useful technique avoid undesirable blow grammar size currently investigating approaches results presented truly generalization similar results contextfree grammars time space bounds similar relativized grammar sizes novelty algorithms fourfold first introduced regular expression forest symbol threads efficient data representation contextfree grammars extended contextfree grammars believe representation new previously documented representations cohen gotlieb 5 barnes 2 simplistic second demonstrated indirection using referencing save time space nullproduction removal back left substitution algorithms although use technique novel context well known technique applications application lazy evaluation evaluation demand third introduced dot normal form extended contextfree grammars plays role similar normal form standard contextfree grammars fourth generalized leftlinear rightlinear grammatical conversion extended grammars currently investigating whether obtain greibach normal form efficiently whether improve performance unitproduction removal would like mention applications regular expression forest threads first reduce usefulness determination nullability determination given extended contextfree grammar replace every appearance every terminal symbol null string give g nonterminal g useful nullable g 0 second use algorithm determine length shortest terminal strings generated nonterminal symbol idea replace appearance terminal symbol integer 1 appearance null string 0 repeatedly replace node labeled two integer children minimum two integers node labeled delta two integer children sum two integers node labeled 0 root value required length use generic algorithm compute smallest terminal alphabet terminal strings derived nonterminal ll1 first follow sets last careful reader observed spaceefficient algorithms unit freeness greibach normal form produce output grammars represented expression foreststhey represented set expression dags directed acyclic graphs dags many roots nonterminals surprisingly roottofrontier traversal yields tree since reduced space sharing common subtrees among trees underlying expression forest clearly may also share common subtrees within original trees expression forest although know practical computation would benefit sharing currently investigating complexity transformations discussed given collection expressions dags representation extended grammar although collection dags dag dags dealing three properties first traversal root node yields tree corresponds production schema second many roots nonterminals third dags threaded reason call collection expression dags dagwood 1 r theory parsing exploratory steps towards grammatical manipulation package grampa derivatives regular expressions structural equivalence extended contextfree extended e0l grammars list structure form grammars syntactic analysis w3c web page xml easy proof greibach normal form system manipulating polynomials given straightline programs transition diagram systems normal form trans formations new normal form theorem contextfree phrase structure grammars simple proof standardform theorem contextfree grammars introduction formal language theory eliminating null rules linear time iso 8879 information processingtext office systemsstandard generalized markup language sgml sgml exceptions greibach normal form transformation revisited grail engineering automata c grammar transformations based regular decompositions contextfree derivations general greibach normal form transforma tion formal languages theory computation theory computation complexity grammar language problems tr easy proof greibach normal form formal languages italicgrailitalic c library automata expressions dagwood derivatives regular expressions new normalform theorem contextfree phrase structure grammars list structure form grammars syntactic analysis theory computation introduction formal language theory theory parsing translation compiling sgml exceptions greibach normal form transformation revisited complexity grammar language problems grammar transformations based regular decompositions contextfree derivations ctr marcelo arenas leonid libkin normal form xml documents proceedings twentyfirst acm sigmodsigactsigart symposium principles database systems june 0305 2002 madison wisconsin frank neven attribute grammars unranked trees query language structured documents journal computer system sciences v70 n2 p221257 march 2005 marcelo arenas leonid libkin normal form xml documents acm transactions database systems tods v29 n1 p195232 march 2004
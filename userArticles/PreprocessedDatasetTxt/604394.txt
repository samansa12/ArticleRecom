applicationlevel fault tolerance complement systemlevel fault tolerance multiprocessor systems become complex reliability need increase well paper propose novel technique applicable wide variety distributed realtime systems especially exhibiting data parallelism systemlevel fault tolerance involves reliability techniques incorporated within system hardware software whereas applicationlevel fault tolerance involves reliability techniques incorporated within application software assert high reliability combination systemlevel fault tolerance applicationlevel fault tolerance works best many systems applicationlevel fault tolerance used bridge gap systemlevel fault tolerance alone provide required reliability exemplify rtht target tracking benchmark abf beamforming benchmark b introduction large distributed realtime system high likelihood given time part system exhibit faulty behavior ability tolerate behavior must integral part realtime system associated every realtime application task deadline calculations must completed order ensure deadlines met even presence failures fault tolerance must employed paper consider fault tolerance two separate levels systemlevel applicationlevel systemlevel fault tolerance encompasses redundancy recovery actions within system hardware software system hardware includes computing elements i0 network subsystem system software includes operating system components scheduling allocation algorithms check pointing fault detection recovery algorithms example event failed processing unit component system responsible fault tolerance would take care rescheduling tasks executing faulty node restarting good node previous checkpoint applicationlevel fault tolerance encompasses redundancy recovery actions within application software various tasks application may communicate order learn faults provide recovery services making use dataredundancy certain situations nd fault tolerance applicationlevel greatly augment overall faulttolerance system example tasks checkpoint large applicationlevel fault tolerance help mask fault system moving large checkpoint restarting task another node nmodular redundancy wellknown fault tolerance technique number identical copies software run separate machines output compared majority decision used 1 technique however involves large amount redundancy thus costly recovery block approach combines elements checkpointing backup alternatives provide recovery hard failures 2 tasks replicated single copy task active time computer hosting active copy task fails backup executed task may completely restarted increases chances deadline miss else executed recent checkpoint 4 later option requires active copy task periodically copy checkpoint state backups entail large amount overhead especially state information transferred large case applications dealing another common technique use less precise ie approximate results 3 obtained operating much smaller data set using algorithm data set chosen suciently accurate result obtained greatly reduced execution time smaller data set chosen either prioritizing data set reducing granularity examples applications target tracking image processing better less precise results time rather precise results late recovery technique caters applications exhibit data parallelism involves large data set make less precise result short period time approach makes use facets recovery block technique employs reduced precision state information results order tolerate faults employ certain degree redundancy within parallel processes application whole able make use redundancy event fault ensure required level reliability achieved consider failures render process results erroneous inaccessible case fault redundant elements less precise results used instead failed process way technique provide high degree reliability small computational overhead certain applications section 2 introduces rtht abf benchmarks used demonstrate technique section 3 describe detail applicationlevel fault tolerance technique section 4 analyzes eectiveness technique used conjunction benchmarks section 5 concludes paper 2 benchmarks benchmarks form shown figure 1 multiple parallel application processes fed input data source case source process simulates radar system array sonar sensors parallel computations complete results output sink process simulating system display actuators technique concerned ability withstand faults parallel processes sink collects results random noise source generates input data consisting real points application processes perform computations order track targets form beams process 1 process 2 process 3 process 4 source sink figure 1 software architecture rtht abf benchmarks 21 rtht target tracking benchmark honeywell realtime multihypothesis tracking rtht benchmark 6 7 generalpurpose parallel targettracking benchmark purpose benchmark track number objects moving twodimensional coordinate plane using data radar system data noisy consisting false targets clutter along real targets original nonfaulttolerant application consists two processes running parallel working distinct subset data radar periodically frames data arrive radar source process case split among processes computation hypotheses possible track associated hypothesis includes gure likelihood representing likely real track history data points covariance matrix used generating uptodate likelihood values every frame radar data parallel process performs following steps creation new hypotheses new data point receives 2 extension existing hypotheses making use new radar data existing covariance participation systemwide compilation ranking hypotheses led root application process 4 merging list hypotheses systemwide list resulted compilation step deadline one frames calculations arrival next frame evaluating performance original nonfaulttolerant benchmark run conjunction rapids realtime system simulator 9 became apparent despite inherent systemlevel fault tolerance simulated system benchmark still saw drastic degradation tracking accuracy result even single faulty node even benchmark task successfully reassigned good node fault chances already missed deadline high part due overheads associated moving large process checkpoint network restarting large process process missed deadline unable take part compilation phase start begin building hypotheses anew took time caused temporary loss tracking reliability frames although better nonfaulttolerant system process would simply lost still reliable desired decided address two points order improve performance benchmark presence faults 1 overhead involved moving large checkpoint 2 source hypotheses process start restart measure reliability number real targets successfully tracked application within sucient degree accuracy fraction exact number real targets tracked simplify calculation number targets kept constant targets enter leave system simulation 22 abf beam forming benchmark adaptive beam forming abf benchmark 8 simulation realtime process submarine sonar system interprets periodic data received linear array sensors particular goal distinguish signals noise precisely identify direction signal arriving across specied range frequencies implementation application receives periodic samples data linear sensor array data generated contains four reference beams signals arriving distinct locations 180degree eld view along random noise application consists several application processes attempting locate beams distinct subset specied frequency range frames data frequency scattered periodically source process output form one beam pattern per frequency gathered sink process figure 2 depicts typical beam pattern output shown frame 18 frequency 250hz reference beams 20 60 20 60 degrees application process performs calculations according following loop pseudocode frame input foreach frequency update dynamic weights foreach direction arrival search signal blocking interference directions frequencies magnitude direction arrival angle degrees figure 2 typical beam pattern output frequency process rst updates set weights dynamically modied frame frame applying weights input samples eect forming beam emphasizes sound arriving direction process searches possible direction 90 90 degrees incoming signals granularity direction directly related number sensors addition start run initialization period weights set initial values 15 20 frames necessary learn precisely beams evident sort application faces reliability problems similar rtht benchmark processing element fails output frequencies lost time lost task nally replaced system go startup period data sets processes large creating considerable overhead checkpointing employed avoid delay associated overhead able maintain full output fault provide quick restart fault applicationlevel fault tolerance must employed evaluate quality abf output two tests applied resultant beam pattern placement test check whether direction arrival beam detected within certain tolerance width test aim determine accurately beam detected measuring width beam degrees 3db peak beam passes tests considered correctly detected 3 implementation applicationlevel fault tolerance technique uses redundancy form extra work done process application process takes addition distinct workload portion neighbors workload shown figure 3 process tracks beams targets work overlaps part neighbors makes use redundant information case neighbor becomes faulty explain brie data set divided application might learn faults would recover p3process 1 process 2 process 3 process 424 2 1 frame data arrives node time figure 3 architecture benchmarks applicationlevel fault tolerance 31 division load extent duplication two neighboring nodes greatly aect level reliability achieved duplication arises way divide data set among parallel processing nodes first frame data divided evenly possible among nodes section process takes set data primary task section p assign node n additional work part neighbor n 1 primary task section process takes set data secondary task section words primary task section p refers calculations node n carries part original application secondary task section refers calculations node n carries backup neighbor hosts secondary corresponding primary running highest numbered node secondary section kept synchronization primary p 1 32 detection faults two ways fault detection information reach various application processes rst system informs application faulty node second specic timeouts phase application communication expected former would typically incur cost periodic polling latter could result late detection fault although exact integration applicationlevel fault tolerance would vary depending fault detection technique chosen eectiveness technique 33 fault recovery deadline prior frame node n discovered faulty unable output results node n i1 serving backup send output i1 data place data n unable supply meantime system working replacing restarting process interrupted fault fact systems job made easier fact process restarted another node process data segment longer needs moved process rescheduled make use information maintained secondary behalf order pick left fault way application fault tolerance able work conjunction system fault tolerance help even case transient faults applicationlevel fault tolerance allows leeway postpone restarting process another node hope fault soon disappear 34 extension higher level redundancy technique guarantees required reliability presence one fault could also withstand two simultaneous failures depending nodes hit faults example sixnode system nodes running processes 1 3 5 fail technique would still able achieve required reliability course contingent assumption processes faulty nodes transferred safe node restarted beginning next frame 35 benchmark integration specics next discuss specic details regarding application technique benchmarks 351 rtht benchmark rtht benchmark unit redundancy hypothesis secondary task section creates extends fraction total number hypotheses created extended process secondary amount secondary redundancy expressed percentage number hypotheses extended primary redundancy implemented following way beginning frame source process broadcasts input radar data hypotheses created extended exception additionally secondary extends percentage extended corresponding primary secondary section kept synchronization primary p 1 via compilation process case processlevel broadcast communication extra communication necessary node n discovered faulty unable participate compilation frame node n i1 serving backup make use i1 data compilation process place data n unable supply process rescheduled make use hypotheses extended secondary behalf pick left information obtained secondary process way compilation newly rescheduled process merely listens compilation process copies hypotheses extended secondary 352 abf benchmark two ways integrated applicationlevel fault tolerance abf benchmark dier manner secondary abbreviates calculations primary obtain full set results methods limited field view limited fov method secondary looks beams every frequency primary however searches subsection primarys eld view divided one segments ideally secondary place windows directions beams known arriving impose minimum width windows due fact individual window narrow output could always perhaps erroneously pass widthbased quality test described section 2 amount redundancy expressed percentage eld view searched secondary reduced directional granularity method secondary looks beams every frequency every direction reduced granularity direction amount redundancy expressed percentage original granularity computed primary techniques serve reduce computational time secondary task set maintaining useful system output addition two techniques may employed concurrently order reduce computational time required secondary task implement either variation technique input frame data scattered second time source application processes time rotated process receives input data process secondary process rst carries primary computational tasks carries secondary task frames deadline process detected sink gather output nonfaulty processes including backup results process secondary one faulty event application process restarted fault receive current set weights secondary order jumpstart calculations synchronization primary secondary required limited fov method small periodic communication either sink process primary tells secondary frequencies directions detecting beams synchronization necessary reduced granularity method 4 results 41 rtht benchmark applied rtht benchmark found small amount redundancy primary secondary sections necessary order provide considerable amount fault tolerance furthermore increase system resource requirements even including overheads techniques implementation minimal compared techniques achieving amount reliability points demonstrated figures 4 5 6 run contains 30 targets remain system end simulation 30th frame well number false alarms case systemlevel fault tolerance exists corresponds case secondary extends 0 primary hypotheses figure 4 see number targets successfully tracked two application processes fault occurs frame 15 case roughly alarms per frame data run 15 redundancy allows us track real targets despite fault attribute fact small amount redundancy great eect tracking stability number targets tracked frame number secondary extends 15 primary hyps secondary extends 10 primary hyps secondary extends 5 primary hyps secondary extends 0 primary hyps figure 4 tracking accuracy number real targets tracked given percentage redundancy fact hypotheses extended secondary ones likely real targets beginning compilation phase application process sorts hypotheses placing likely head list compilation thus beginning next frame application process secondary begin extending hypotheses highest chance real targets rene point figure 5 shows average percentage redundancy required given number application processors single fault amount required shows gradual decrease add processors attribute fact chance single process containing high percentage real targets decreases processors added addition proportionately small load imposed processor computation secondary task set seen figure 6 attributed fact hypothesis whose position velocity known precisely take much time extend compared hypotheses less well known since likely hypotheses generally wellknown hypotheses secondary extends amount processor time taken execute secondary task proportionally much smaller percentage secondary overlap required number application processors figure 5 average minimum percentage secondary overlap required miss targets despite one node faulty 42 abf benchmark results integrate applicationlevel fault tolerance abf benchmark nd small amount redundancy necessary ensure complete masking single frame faults either variation reduced granularity limited fov method see secondary redundancy 33 adequate provide complete accurate results faulty frame following frames faulty process restarted combine two techniques see even reduction computational eort imposed secondary order mask fault taken additional network overhead andor latency account gures overhead refer solely computational overhead network overhead depend greatly medium used particular shared medium would allow secondary snoop primarys input output eliminating need additional communication results obtained running simulations 75 sensors four reference input beams 50 frames two application processors fault occurs one frame 30 results presented discussed three redundancy methods limited fov method reduced granularity method combined method combination rst two quality results assessed totalling number beams tracked successfully four input beams frequency 32 frequencies making 128 secondary execution time primary percentage secondary overlap figure 6 ratio time taken compute secondary hypothesis time compute primary hypothesis versus percentage secondary overlap beams example figure 7 presents results several runs abf benchmark utilizing limited fov redundancy method alone single processor fault occurring frame 30 lasting one frame see 30 overlap adequate preserve beam information within system despite loss one processor frame 30 tabulated results three methods table 1 421 abf results limited fov alone see table 1 roughly 30 secondary overlap adequate provide full masking fault computational overhead imposed secondary 30 addition figure 8 shows rather linear increase overhead increase fraction overlap table 1 amount secondary overhead imposed various redundancy methods capable fully masking single fault redundancy technique secondary overlap computational overhead reduced granularity 33 35 limited fov 30 30 combined 30fov50granularity 15 17 total number beams detected time 30 secondary 20 secondary 10 secondary 0 secondary figure 7 number beams correctly tracked frame given levels redundancy limited field view method single process experiences fault duration one frame frame 30 associated technique however potential dependence number beams detected system described earlier order ensure width test applied output fail impose minimum windowwidth minimum width dictates given amount overlap maximum number windows secondary may search beams beams maximum number windows may missed secondary search depending direction arrival however system designer lessen likelihood occurring carefully choosing amount overlap allotted tuning criteria areas searched secondary 422 abf results reduced granularity alone see according table 1 operating secondary 33 granularity primary results complete masking fault imposes 35 overhead processing node figure 8 shows linear relationship computational overhead overlap indicates overhead method bit higher limited fov method considering reduced granularity method see dependence number beams detected although beams could missed peaks within degrees granularity coarse secondary exection time primary percentage secondary field view overlap reduced granularity method limited fov method limited fov 50 granularity limited fov 33 granularity figure 8 ratio secondary primary execution time variations applicationlevel tolerance integrated abf benchmark versus percentage secondary eld view overlap 423 abf results combined methods combine two techniques see greatest reduction computational overhead secondary task shown table 1 30 eld view combined 50 granularity maintains tracking ability similar either one alone yet cuts computational overhead nearly half reduction illustrated figure 8 lower two curves representing overhead imposed vary eld view make use 50 33 granularity respectively 5 conclusions high degree fault tolerance may obtained minimal investment system resources applications exhibiting data parallelism abf rtht benchmarks achieved combination applicationlevel systemlevel fault tolerance prioritized ordering within data set rtht benchmark reduced granularity abf benchmark made use decrease computational overhead technique processes benchmarks large moving checkpoint restarting task may take signicant amount time applicationlevel fault tolerance able ensure despite temporary loss task required reliability maintained since primary secondary task sets incorporated within single application process primary always executed rst secondary next primary completed may alert scheduler indicating secondary need executed useful necessary secondary still executed allows better synchronized primary counterpart fault detected priority secondary could raised ensure complete without missing deadline provide necessary data compilation technique substantial improvement complete system duplication require 100 system redundancy merely adds small amount load existing system achieving amount fault tolerance diers recovery block approach secondary coldstarted ready execution failure primary detected addition level reliability may varied varying amount redundancy order integrate applicationlevel fault tolerance designer need rst determine prioritize data set andor reduce granularity order dene secondarys dataset second designer choose mechanisms secondary gets input data needs able output results necessary able communicate primary synchronization purposes naturally sort fault detection used well designer must carefully weigh overheads imposed various methods achieve fault tolerance quality results may obtained conclusion believe steps integrate technique application taken right early stages design order approach eective acknowledgments eort supported part defense advanced research projects agency air force research laboratory air force materiel command usaf agreement number f306029610341 order e349 government authorized reproduce distribute reprints governmental purposes notwithstanding copyright annotation thereon views conclusions contained herein authors interpreted necessarily representing ocial policies endorsements either expressed implied defense advanced research projects agency air force research laboratory u government r system structure software fault tolerance imprecise computations using passive replicates delta4 provide dependable distributed computing faulttolerant scheduling problem implementation results hypothesis testing c 3 parallel benchmark suite honeywell technology center rapids simulator testbed distributed realtime systems tr faulttolerant scheduling problem reliable computer systems 2nd ed implementation results hypothesis testing c3i parallel benchmark suite ctr osman unsal israel koren c mani krishna towards energyaware softwarebased fault tolerance realtime systems proceedings 2002 international symposium low power electronics design august 1214 2002 monterey california usa
realtime multitasking software synthesis information processing systems abstract software synthesis new approach focuses support embedded systems without use operating systems compared traditional design practices better utilization available time hardware resources achieved static information provided system specification fully exploited applicationspecific solution automatically generated ongoing research software synthesis approach realtime information processing systems presented starts concurrent process system specification tries automate mapping description single processor internal representation model wellsuited support concurrency timing constraints proposed together flexible execution models multitasking realtime constraints method illustrated personal terminal receiver demodulator mobile satellite communication b introduction target application domain approach advanced realtime information processing systems consumer electronics personal communication systems distinctive characteristic systems coexistence two different types functionalities namely digital signal processing control functions require different timing constraint support specifically signal processing functions operate sampled data streams subject realtime constraint derived required sample frequency throughput control procedures vary nature executed soon possible like eg manmachine interface eventual execution delay usually compromise integrity entire system soft deadline stringent constraints like eg critical feedback control loop hard deadline traditionally realtime kernels ie specialized operating systems used software support design embedded systems 5 small kernels often strippeddown versions traditional timesharing operatingsystem first place designed fast eg fast context switch realtime kernels provide runtime support realtime multitasking perform software scheduling primitives interprocess communication synchronization accessing hardware resources since processes considered black boxes workwas supportedby europeancommission undercontract kernels apply coarse grain model process schedul ing kernels tend use fixed priority preemptive scheduling mechanism process priorities used mimic timing constraints alternatively traditional process scheduling approaches use timing constraints specified process period release time deadline 11 designer viewpoint however constraints naturally specified respect occurrence observable events moreover scheduler knowledge time stamps events generated processes consequently exploit assignment process priorities case fixed priority scheduling scheme manual task performed without tool support typically iterative errorprone design cycle lot code priority tuning quired inflexible time consuming also restricts proof correctness selected stim uli additionally behavior scheduler peak load conditions hard predict resulting often underutilized systems stay safe side safer guarantee timeliness preruntime new family kernels tend attain 5 moreover kernels trade optimality general ity causing associated runtime memory overhead software synthesis 127 alternative approach realtime kernels starting system specification typically composed concurrent communicating processes aim software synthesis automatic generation source code realizes 1 specified functionalities satisfying timing constraints 2 typical runtime support required realtime systems multi tasking primitives process communication synchronization better utilization available time hardware resources achieved software syn thesis static information provided system specification fully exploited consequence automatically generated runtime support customized dedicated particular application need general case realtime kernels moreover accurate static analysis provides early feedback designer feasibility input specifications way iterative design cycle typical realtime kernels avoided satisfaction timing constraints guaranteed automatically besides transformations optimizations envisioned software synthesis approach try automate code tuning finally since output software synthesis source code portability easily achieved means retargetable compiler 6 software synthesis approach vulcan framework allows specify latency rate timing con straints program threads extracted system specification order isolate operations unknown timing delay simple nonpreemptive controlfifo based runtime scheduler alternates execution provides restricted support satisfying constraints since threads executed put runtime fifo reordered moverover interrupts supported due choice nonpreemptive scheduler approach taken chinook 2 system suffers similar restriction although preemption allowed based watchdog paradigm resuming preemption point difficult hence interrupts supported system targetted towards reactive control systems supports timing constraints state transitions latency operations rate constraints supported typical dsp applications rest paper structured follows section 2 introduces system representation concepts used section 3 two different execution models steps possible software synthesis script discussed reallife illustration approach subject section 4 fi nally section 5 draws conclusions system representation model assume target application modeled concurrent process description captures operation havior data dependencies operations concurrency communication 89 precise semantics specification beyond scope paper specification constraint graph derived contains sufficient information software synthesis problem introduced define program thread linearized set operations may may start nondeterministic time delay operation 7 examples ndoperations synchronization internal external events wait communication unbounded loops purpose extracting program threads concurrent process input specification isolate uncertainties related execution delay given program beginning program threads program threads executed using single thread control present contemporary processors property execution latency computed statically besides defined ndoperations program threads also capture concurrency multirate transitions new representation model based constraint graphs 10 built extracted threads model allows static analysis imposed timing constraints thread scheduling vertexes represent program threads edges capture data dependency control precedence timing constraints threads specifi cally let ffi v execution delay thread represented vertex represents minimum timing constraint v v j event 1 event 2 event 1 event art event art event 2 artificial events art event 1 art event 2 minimum maximum timing constraints frame clustering event event event 4 b frame 1 frame 2 frame 3 frame 4 frame 5 frame 6 10event 4 figure 1 example constraint graph ie requirement start time v j must occur least w ij units time later v similarly maximum timing constraint two threads v v j indicated backward edge negative weight w ij representing requirement end time v must occur later j w ij j units time later end time finally ndoperations represented separate event nodes example given figure 1 model differs 10 abstraction level cg node approach cg node isolates group operations corresponds static program parts 10 individualoperations cg entities moreover 10 cg restricted single connected graph able capture process concurrency restriction lifted approach internal events introduced synchronize concurrent graphs capturing process concurrency also support multirate placing relative execution rate numbers control edges definition uncertainties related timing behavior system specification captured event nodes since arrival time event unknown compile time event nodes limit extent analysis synthesis performed statically second step threads clustered socalled thread frames figure 1 b purpose identifying thread frames partition initial constraint graphs disjoint clusters threads triggered single event static analysis synthesis eg scheduling performed cluster relatively associated event remark sequence edges exist frames according original system specification event set ev node v defined set event nodes predecessors v artificial events introduced threads event set contains least two elements exist path graph events fact internal events must observed taken care execution model similar way external events triggered directly environment execution model take care activation runtime different thread frames according original specification taking account sequence occurred events imposed timing constraints way unknown delay executing program thread appears delay scheduling program thread considered part thread latency 3 execution models implementation section execution models implementa tion ie mapping representation model single thread control target processor described although cg model target independent paper focuss single processor target 31 execution models blocking model cyclic executive combined interrupt routines simple cost effective solution runtime thread frame activation consists using simple event loop background combined tying different thread frames processor interrupts assignment frames event loop internal scheduling frames done compiletime event loop background polls roundrobin fashion occurrence events triggering different thread frames accordingly starts executing appropriate frames sequentially processor interrupts present cheap way supported hardware asynchronously start thread frames suspend currently executing frame processor interrupt masking priority levels used selectively allow interruption time critical thread frame sections favor high priority frames frames triggered event corresponding interrupts either external hardware internal peripheral interrupts started asynchronously frames placed background event loop moreover background frame started event loop block processor till end execution preventing frames event loop started hence name blocking execution model execution length frames limits response time events event loop therefore limits scope model nonblocking model using runtime scheduler figure outlines execution model takes twolevel scheduling approach static scheduling ie compiletime performed thread clustering determine relative ordering threads within thread frame assumption ordering changed anymore dynamic scheduling phase runtime small preemptive timedriven scheduler takes care composition interleaving different thread frames according system evolution timing constraints ad ditionally tries avoid active waiting scheduling frames next frame ready executed way maximizing processor utilization runtime behavior illustrated lower part fig b frame slack frame slack l b l 3static scheduling static scheduling 2 runtime 1 compiletime event runtime scheduler time event1 event2 b1 frame 2 frame time l l b event figure 2 runtime execution model frame slack scheduling metric b ure 2 starting idle state suppose event 1 occurs event activates runtime scheduler since frames currently active threads first frame executed order determined previously static scheduling order 132 occurrence event 2 executing thread 3 first frame causes following actions 1 thread 3 interrupted 2 runtime scheduler invoked determining subsequent execution der example rest thread 3 b 2 execution proceeds newly determined thread ordering indicated relative ordering threads frame changed allowing efficient implementation runtime scheduler must necessarily fast scheduling metric used runtime scheduler frame slack time information derived statically based imposed timing constraints relative thread ordering within frame frame slack indicates amount time end individualthread thread frame postponed relatively static schedule violating timing constraint illustrated figure 2 b frame slack defined minimum thread slacks ie remaining time end thread timing constraint succeeding threads static schedule frame slack derived compile time used updated runtime formally description model refer 3 32 script figure 3 gives overview proposed approach concurrent process specification different program threads extracted nondeterministic timing delay isolated event nodes step code generator provide static estimate thread execution times execution times placed together timing constraints constraint graph abstraction model used sequel approach assignment external processor interrupts event nodes constraint runtime executive execution model selection thread transformations thread frame buffer allocation machine code concurrent process specification code generation code generation constraint graph thread extraction estimation estimation scheduled thread frames assignment external events figure 3 possible software synthesis script graph determined context system provided user selection one two execution models explained five tasks phase coupled per formed thread frame clustering tries cluster constraint graph disjoint groups threads triggered event set thread frames activated runtime selected execution model since events introduce overhead frame scheduling also want minimize number clusters without violating timing constraints static frame scheduling determine compiletime relative order threads inside identified thread frames occasionally timing constraints met identified frames case transformation step threads frames resolve problem provide optimal solu tion example transformations given illustration section 4 buffer allocation insert required buffers communicating frames deriving buffer sizes execution rates frames timing analysis used different phases upon entry tool check consistency user specified timing constraints subsequently execution tool verify whether result synthesis task still satisfies constraints outcome software synthesis scheduled thread frames possibly depending execution model cho sen small runtime executive activates appropriate frames runtime compiled code generator linked together afterwards 4 illustration approach system description concurrent communicating process specification figure 4 outlines process specification mobile terminal receiver demodulator used msbn satellite communication network 4 network allows bidirectional data voice communication star network consisting fixed earth station multiple mobile stations two different data channels called pilot traffic channel sent transmission carrier using cdma technique ie correlating channels orthogonal pseudonoise codes enabling use frequency spectrum without interference former channel carries network system information eg average channel bit error rate latter carries actual user data acquisition tracking transmission carrier performed pilot channel cooperation intelligent antenna triggered external interrupt read decorr process reads periodically rate 34 khz memory mapped decorrelator fpga process sends data track pilotdemod traffic demod pro cesses perform tracking transmission carrier demodulation ie gain carrier phase bit phase correction 13 rate conversion demodulated traffic data formatted traffic manage data process via send vocoder process transmitted second memory mapped processor contrast demodulated pilot data processed processor track pilotdemod process delivers demodulated data pilot manage data process steers frequency nco numerical controlled os cillator preceeding analog demodulation part use onchip serial peripheral moreover together traffic demod process sends information concerning carrier synchronization display leds process write antenna process channel decoding demodulated pilot data carried pilot dsp functions process operates 1024 element frame basis multirate transition present pilot manage data latter process output data pilot channel decoding sent pc computer using onchip dma engine setup dma process triggered output data available pilot dsp functions process sets starts dma process asynchronously chain periodic processes read sys cmd read antenna process control internal parameters demodulation processes respectively perform manmachine interface connected system using memory mapped flag allowing user alter system operating parameters interface antenna controller connected via external terrupt former sporadic process since user adapt parameters allowed large response time latter timecritical pro cess antenna controller looses beam signal immediately demodulator must take special retracking actions constraint graph representation figure 5 outlines constraint graph thread frame clustering demodulator capturing threads dependency timing constraints reasons clarity thread execution times indicated three event nodes introduced capture timing uncertainty periodic interrupt decorrelator interrupt antenna controller ev ant setting polling flag manmachine pilot managedata corrsymbols trackpilot rsdecode pilot dsp function compose packet readdecorr8from decorrelator read 8 bytes modify parameters pc mem mapped readsyscmd pc cmd nco serial peripheral serialperiph control flow data flow peripheral process wait data io port parameter rate conversion pc via serial2 fpga dma process dma dmainterrupt antenna leds traffic demod displayleds trafficstatuspilotstatus 1to 2nd dsp proc mem mapped traffic sendvocoder antenna readantenna reset ready acqu set para figure 4 concurrent process specification msbn demodulator readsys cmd readantenna readdecorr trackpilotdemod formatdata traffic demod pilotdspfunctions managedata sendvocoder wait event timing constraint framedemodulate framepilotdspfunctions framereadantenna display leds antenna ev cut ev ant ev sys ev decorr framereadsyscmd figure 5 constraint graph msbn demodulator frame clustering terface ev sys extra event ev cut present original cg introduced frame clustering see remark event nodes make abstraction whether implemented interrupt polling loop program threads capture also concurrency rate conversion processes original user specification combined one program thread eg manage datasend vocoder timing constraints added backward edges eg edge manage datasend vocoder pe riodic event node expresses end thread must executed start occurrence next event thus next period thread frame clustering transformations first instance cyclic executive based execution model tried proved satisfactory application thread frame clustering transformation already added cg figure 5 four different thread frames identi fied three according original events one artificial event introduced frame cutting transformation although event set pilot dsp functions setup dma thread eg track pilot demodformat data thread placed separate frame timing constraints execution time frame triggered decorrelator event 1024th execution according relative rate 11024 last thread would become longer period periodic event thus conflicts timing constraints cutting pilot dsp functions setup dma frame introducing artificial event ev cut checks 1024th execution preceeding frame allow execution model overlap 1024 executions frame demodulate frame pilot dsp functions another transformation called rate matching applied manage data send vocoder thread inserting rate counter checks relative event occurrence based causes conditional execution rate thread matched frame rate implementation final implementation static frame scheduling introduction communication buffers inclusion execution model shown figure 6 frame read sys cmd frame pilot dsp functions frame placed background event loop cyclic executive based execution model thus roundrobin schedule manmachine frame possible nonstringent timing constraint response time user setting new system commands limited execution time frame pilot dsp functions two frames triggered activated environment using corresponding hardware interrupt remark frame frame demodulate interrupts unmasked target processor default allow interrupt nest ing allow interrupt frame read antenna order reduce response time antenna loosing carrier bottom figure 6 behavior cpu processor peripherals outlined timeaxis seen clearly frame pilot dsp functions frame processing previous data frame background frame demodulate frame activated hardware interrupt processing consecutively 1024 data samples next frame considered kind process timefolding also seen command read 8 bytes modify parameters pc mem mapped cmdready roundrobin event loop antenna mem mapped framereadantenna antready reset ready acqu trackpilot traffic demod antenna traffic managedata 2nd dsp proc pilot managedata displayleds leds nco serial peripheral framedemodulate decorrelator fpga corr symbols readdecorr sendvocoder int data 3 3unmask intframeread syscmd sequence edge assignment int data flow added source code dma process pc serial function dma setupstart dma1024sendbuffer framepilot dspfunctions dma int data dma serial port read antenna interrupts unmasked dma int 1024 activations demodulate1 1 start pilot dsp functions start pilot dsp functionswrite pilot data cpu peripherals1024 dma disable interrupt figure final implementation msbn demodulator terrupt nesting frame read antenna frame dma interrupt routine disables dma engine transfer completion occur frame demodulate frame results overhead implied use blocking execution model minimal requires infinite loop two conditional tests background event loop register context saverestore supported processor hardware interrupt routine overhead compared situation realtime kernel used implement runtime behavior figure 4 original specification consists twelve concurrent user processes hierarchy straightforwardly implemented using kernels semaphore primitives signal two tasks data available result considerable runtime overhead compared solution proposed additionally requires extra program memory hold kernels program code however careful manual tuning orginal specification collapsing number user processes kernel solution could approach tuning however manual task contrast automated tuningand transformation process approach whichworks across division specification processes user conclusions approach paper tackles software support problem source level contrast contemporary coarsegrain blackbox approaches proposed approach tries exploit knowledge application hand applies transformations optimizations specification generates application specific solution automatic support timeliness method based representation model composed program threads constraint graphs features selectable execution model combines detailed static analysis input specifications resulting static partitioning input specifications static schedule parti tion runtime activation dynamic composition specification partitions r hardwaresoftware codesign embedded sys tems software scheduling cosynthesis reactive realtime systems software synthesis realtime information processing systems mobile satellite business network msbn system requirement specification survey realtime operating systems chess retargetable code generation embedded dsp processors cosynthesis hardware software digital embedded systems concurrent c programming lan guage ieee standard vhdl language reference manual relative scheduling timing con straints schedulingprocesses release times dead lines precedence exclusion relations tr concurrent c programming language scheduling processes release times deadlines precedence exclusion relations relative scheduling timing constraints cosynthesis hardware software digital embedded systems software scheduling cosynthesis reactive realtime systems hardwaresoftware codesign embedded systems ctr youngsoo shin kiyoung choi software synthesis task decomposition dependency analysis proceedings 1996 ieeeacm international conference computeraided design p98104 november 1014 1996 san jose california united states marco sgroi luciano lavagno yosinori watanabe alberto sangiovannivincentelli synthesis embedded software using freechoice petri nets proceedings 36th acmieee conference design automation p805810 june 2125 1999 new orleans louisiana united states bill lin compiling concurrent programs embedded sequential execution integration vlsi journal v40 n2 p106117 february 2007 jordi cortadella alex kondratyev luciano lavagno marc massot sandra moral claudio passerone yosinori watanabe alberto sangiovannivincentelli task generation compiletime scheduling mixed datacontrol embedded software proceedings 37th conference design automation p489494 june 0509 2000 los angeles california united states f thoen j van der steen g de jong g goossens h de man multithread system model realtime embedded software synthesis proceedings 1997 european conference design test p476 march 1720 1997 steven vercauteren bill lin hugo de man strategy realtime kernel support applicationspecific hwsw embedded architectures proceedings 33rd annual conference design automation p678683 june 0307 1996 las vegas nevada united states b lin efficient compilation processbased concurrent programs without runtime scheduling proceedings conference design automation test europe p211217 february 2326 1998 le palais des congrs de paris france bill lin software synthesis processbased concurrent programs proceedings 35th annual conference design automation p502505 june 1519 1998 san francisco california united states
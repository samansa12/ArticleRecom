visual execution model ada tasking visual execution model ada tasking help programmers attain deeper understanding tasking semantics illustrate subtleties semantic definitions apparent natural language design describe contour model ada tasking depicts asynchronous tasks threads control relationships environments tasks execute manner tasks interact use highlevel execution model makes possible see happens execution program paper provides introduction contour model ada tasking demonstrates use b introduction ada programming language intended use realtime applications flight navigation process control software reason tasking figures prominently language design semantics tasking however extremely complex time tasking provides flexibility control required implementation realtime embedded software undoubtedly difficult ada language features understand learn use effectively paper describes visual execution model designed help software practitioners attain deeper understanding semantics ada tasking derived johnstons contour model blockstructured languages 17 model helps programmer visualize effects executing tasking statements illustrates subtleties semantics tasking apparent copyright 1993 c acm inc permission copy distribute document hereby granted provided notice retained copies copies altered acm credited material used form copyright policies standard natural language descriptions ada motivation nuances definitions tasking primitives ada language reference manual alrm 21 definitive reference ada language features including tasking variety ada language text books eg 3 10 describe language tutorial format least one specializes ada tasking 11 descriptions however lack concreteness purposely vague allow variations language imple mentations textual descriptions typically group language constructs according general features eg declarations statements subprograms packages exception handling tasking combine informal explanation example program fragments descriptions tend incomplete ambiguous moreover style presentation obscures subtleties interaction different language features making difficult recognize inconsistencies among definitions separate language features existence ada issues 1 hundreds requests clarifications tasking semantics alone attest inadequacy natural language descriptions formal semantic specifications based axiomatic denotational techniques 7 address many shortcomings natural language descriptions use rigorous mathematical notations results specifications precise unambiguous analyzed consistency complete ness however also results highly abstract mathematical specifications ordinary programmers may find difficult understand notations chosen mathematical properties visual clarity typically little help visualizing execution programs moreover axiomatic denotational specifications poorly suited describing programs terminate operating systems process control systems functionbased semantic techniques nonterminating program equivalent trivial program true null endwhile found johnstons contour model effective teaching semantics blockstructured languages model employs data structure diagrams depict program states executing program represented visually series evolving diagrams johnstons model uses natural simple data structures easily interpreted programmers automated version model supplies visual semantics algol programs 20 model also forms basis textbook programming language structures 18 description multitasking pl1 4 contour model used illustrate clarify semantics parameter passing paper axiomatic semantics 6 section 2 gives brief overview ada tasking section 3 presents program calculating prime numbers illustrates use major tasking fea tures give overview contour model section 4 illustrate concepts introduced overview concretely next two sections using example program section 3 section 5 shows encode program collection nested contour diagrams section 6 describes particular program execution compare model johnstons model common stackbased execution models section 7 finally discuss conclusions future work section 8 tasking ada restrict attention subset ada order focus parallel execution tasks particular consider packages generics exception handling largely independent tasking anyway work discussion semantics ada tasking requires understanding distinction scope units declarative regions defined program runtime instances scope unit static portion program text block function procedure task encapsulates computation local data required computation virtually blockstructured programming languages make use blocks functions procedures therefore limit discussion constructs relationship tasking case task task type determines tasks interface computation declaration task type consists specification body specification defines set entries called within scope units establish rendezvous tasks type body consists declarative part sequence statements executed tasks type accept statements within body define remote procedures tasks type execute response calls entries discuss semantics task execution including call accept statements detail instances scope units program dynamic objects unlike scope units exist runtime execution program begins single thread control creates instance top level procedure executes body executing body scope unit thread control may create new instances procedures functions block statements spawn new threads control execute instances task types task instances exist point execution program root instance main procedure determine active threads control point view top level procedure defining special root task type entries permits us identify threads control task instances instance task type created one two ways elaborating task declaration evaluating task allocator expression form new tt tt designates task type called designated type latter case task allocator returns access pointer value designating new task instance task instance said belong collection task instances associated corresponding access type refer instance task type elaborated created elaborating object declaration allocated created task allocator classification task instance elaborated allocated affects manner synchronizes instances creation termination described instance given scope unit performs computation referencing environment binding identifiers program objects may differ instance instance lifetimes instances may disjoint instance nonrecursively invokes procedure may overlap instance spawns several tasks task type execution instance p causes creation instance refer p parent child p various points execution program instance pre cisely thread control executing instance may wait occurrence certain events order make progress instance said blocked points example instance issues entry call blocks task instance owns entry accepts call executes rendezvous instance task type regarded passing several different phases lifetime 2 14 distinguish five phases referring task instance activating running completed terminated abnormal depending phase instance task type begins activating created first phase lifetime task instance consists elaboration declarative part activated instance normally begins running roughly corresponds executing sequence statements appear body task type instance becomes completed upon finishing execution task body completed instance perform processing simply waits terminate instance blocked ready execute first three phases final phase lifetime task instance begins termination semantics termination ada ensure implementation deallocate local data associated instance block function procedure task upon terminating 1 lifetime task instance however extends past termination instances interrogate attributes associated task instance invoke entries regard lifetime task instance elaborated ending execution leaves instance lifetime task instance allocated ending execution leaves scope associated access type coincides deallocation collection contains instance normal circumstances therefore task instance progresses four phases activates runs algorithm 1 alrm requires instances pass completion phase instance may temporarily blocked terminating also talks leaving functions procedures blocks rather terminating view leaving instance equivalent terminating completes terminates lifetime begins creation ends deallocation sometime termination exception normal progression occurs instance explicitly aborts concurrent task instance aborting task instance activating running causes enter abnormal phase task instance abnormal may continue executing statements reaches next synchronization point point must complete instance task type already completed terminated aborting effect ada semantics require instance task type synchronize parent beginning ending activation task instance elaborated blocks immediately upon created parent continues elaborating declarative part parent blocks finishes elaborating time child instances elaborated unblocked begin activating parallel parent remains blocked last child instances finishes activating point parent unblocked task instance allocated synchronizes parent slightly different fashion allocated instance block upon creation begins activating immediately part evaluation allocator parent allocated instance blocks call task allocator instance finishes activating rules determine instances terminate make use certain master dependence relations instance task type depends one concurrent instances collectively referred masters alrm defines direct dependence elaborated instance task type instances parent allocated instance task type instance elaborates declaration associated access type could parent could instance global scope unit direct dependence identifies direct master task instance dependences indirect alrm defines indirect dependences task instance instance dynamic chain reverse call chain one task instances masters task instance master one task instances masters dependents instance may need access instances local data execution may logically constitute part algorithm thus alrm extends notion completion arbitrary scope units instances complete upon finishing execution bodies stipulates instance completed cannot terminate dependents terminated rule ensures implementation safely deallocate data associated instance upon terminating alrm states instance declares access type collection associated access type deallocated instance terminates case rule termination also guarantees task instances collection terminate prior deallocated although instances may communicate shared environments preferred method synchronization communication rendezvous entries associated task instances ada instance requests rendezvous calling entry belonging concurrent task instance entry call semantics remote procedure call caller blocks task instance owns entry accepts call executing accept statement designating entry accept statement specifies modes types formal parameters sequence statements null called instance executes behalf caller rendezvous finished caller resumes execution statement following call entry called asynchronously multiple threads control situations ada semantics require called instance service entry calls firstcomefirstserved basis implementation must therefore provide entry queues place callers calls accepted instance executes accept statement blocks calls pending entry brevity restrict attention paper single version ada select statement selective wait statement terminate alternative version select statement allows instance selectively accept call one set entries conditions described ter minate sequel therefore assume one branches select statement designate potential accept alternatives one distinguished branch designates terminate alternative context sequence statements begins accept statement constitutes accept alternative terminate alternative consists single terminate statement accept alternative terminate alternative may also preceded boolean guard determines alternative candidate execution first step executing select statement consists evaluating guards determining set open alternatives consisting alternatives guards alternatives whose guards satisfied treat absence open alternative runtime error 2 instance executing select statement nondeterministically selects open alternative also passable executes passable alternatives instance blocks open alternative becomes passable upon unblocking selects one open passable alternative execute accept alternative passable caller waiting rendezvous entry named accept statement beginning accept alternative thus leading accept statement passable accept alternative nonblocking terminate alternative passable instance executing select statement depends master completed every dependent master either terminated blocked open terminate alternative conditions ensure caller waiting engage rendezvous instance 21 thus ada executing select statement open alternatives raises exception treatment consistent semantics propagation exceptions terminate alternative select statement passed select statement passable accept alternatives say master asleep completed dependents either terminated open terminate alternatives 3 asleep stable sense sleeping master remains asleep terminates master dependents finished executing algorithms waiting terminate alrm states executing terminate alternative one dependents sleeping master results termination dependents prefer however view execution passable terminate alternative completing dependents ultimately completing dependents effect terminating require us treat distributed termination special case dependents terminate usual orderly fashion starting bottom dependency hierarchy working upwards sleeping master abort statement ada allows instance abort concurrent task instance aborting task instance causes dependents either complete become abnormal unless already completed terminated abnormal task instance completes reaching next synchronization point cannot engage rendezvous 3 example tasking program example program 13 illustrates major tasking features ada program implements algorithm generating prime numbers using dynamically created pipeline checker task instances instance stage n pipeline checks numbers relative primeness nth prime sending numbers pass check instance stage positive numbers fed pipeline order thus number moves pipeline either fails check reaches end pipeline number passes relative primeness check final stage pipeline accepted prime results new stage added pipeline procedure primes implements algorithm statement labels p1 p2 etc used reference part program readability show procedure task bodies separately p1 procedure primes p2 task fdr feeds pipeline checks values p4 entry get numnum integer divisibility num 3 terminology borrowed 2 definition however require master completed p5 entry chk itval integer p6 end chkr type chkr ptr access chkr p8 procedure make chkrnew pri integer new chkr chkr ptr creates new chkr check relative primeness new pri p9 front chkr ptr front pipeline procedure task bodies shown separately static task fdr declared primes feeds pipeline positive num bers require single instance task declare fdr directly without first introducing task type however direct declaration fdr equivalent first declaring anonymous task type declaring single object type pipeline composed task instances type chkr created dynamically procedure make chkr instance type chkr receives prime number use get num entry receives numbers check relative primeness chk entry access type chkr ptr provides values designating instances type chkr collection associated chkr ptr contains instances type chkr front designates first task instance pipeline instance type chkr contains chkr ptr variable linking next task instance pipeline show procedure task bodies simplicity assume primitive operations called get put performing input output m1 procedure make chkrnew pri integer new chkr chkr ptr m3 new chkr new chkr make new chkr task m4 new chkrget numnew pri tell task number print prime number f1 task body fdr f2 max integer maximum prime test generate first prime f6 ctr 3max loop feed pipeline c1 task body chkr c2 num new val integer c3 nxt chkr chkr ptr c4 begin c5 accept get numnum integer c6 num num c8 loop select c10 accept chk itval integer c13 c17 nxt chkr null pass new value else prime c22 end sections 5 6 show contour model describes particular execution program first however give brief overview model 4 overview contour model contour model defines simple interpreter generating sequences snapshots representing progression computation series instantaneous machine states every sequence snapshots generated initial snapshot given program given set inputs describes potential execution program interpreter nondeterministic sense produce different snapshot sequences program set inputs model nondeterminism program snapshot consists algorithm remains fixed throughout exe cution record execution changes dynamically algorithm representation ada program consists collection algorithm contours representing scope units program algorithm contour scope unit u contains declaration array describes local data required instances u flow chartlike network instructions defines computation instances u perform successor link designates algorithm contour scope unit lexically encloses u algorithm encodes information required execute program execution affect algorithm therefore snapshots record execution describes contents memory cells registers consists collection execution contours represent instances scope units exist point execution collection processors depict active threads control execution contour c scope unit u contains data array store cs local data successor link interpreter uses declaration array within algorithm contour u template generating data array c successor link also called static link designates execution contour instance defines global referencing environment c thus instance finds local data execution contour global data execution contours static chain formed following static links processor abstraction hardware cpu associate processor task instance program including root instance toplevel procedure processor associated state indicates current phase instances lifetime values act run com term abn represent activating running completed terminated abnormal phases respectively various components processor encode information required execute task instance particular instruction pointer describes instances locus control environment pointer determines referencing environment expression stack provides temporary storage intermediate values values actual parameters execution status indicates instance blocked eligible execute describe additional components used primarily task management section 6 identify scope units algorithm contours instances scope units execution contours task instances processors machine cycle contour model interpreter consists nondeterministically selecting processor among processors current snapshot blocked terminated fetching instruction designated processors instruction pointer updating processors instruction pointer references next instruction algorithm executing fetched instruction produce new snapshot processor selected particular machine cycle said executing contour model information structure model 23 uses storage cells represent units memory abstract machine storage cells two important features may contain number components components may reference storage cells concept storage cell used give precise specification contour model similar described 17 describe contour model level manipulation individual storage cells paper instead use diagrams 17 18 describe snapshots higher level abstraction explain executing instructions transforms diagrams snapshot contains two main contour diagrams corresponding algorithm record execution several additional diagrams show information associated processors describe environment program executes algorithm program remains constant however adopt johnstons convention presenting algorithm separate diagram omitting individual snapshot diagrams next two sections illustrate concepts concretely highlight important aspects model describe algorithm primes section 5 record executions simulate particular execution primes section 6 5 algorithm primes contour diagrams figures 13 express primes program section 3 algorithm figures illustrate notational conventions used throughout example attach lowercase italic labels contours instruction boxes reference purposes labels part algorithm show explicit successor links contours instead represent successor links implicitly nesting contours thus nesting algorithm contours mirrors nesting scope units program declaration array contour shown upper left hand corner write contour model instructions lowercase program names identifiers uppercase described contour model may extend scope unit certain implicit declarations choose names begin percent sign eg ret fdr implicitly declared data arrows connecting instruction boxes describe control flow outermost contour primes figure 1 represents toplevel procedure primes regard direct declaration fdr implicitly declaring task type called fdr declaring fdr type thus declarative part primes determines six declarations represented six rows declaration array contour primes row declaration array specifies name declared object gives descriptive tag table figure figure primes make chkr chkr fdr return put new pri ecall new chkrget num activate new chkr chkrchkr ptr create new chkr acc int task enter task enter terminate task complete null activate fdr elaborate task enter fdr chkr chkr ptr front acc fg proc enter figure 1 algorithm contour primes r gammapsi oe fdr terminate exit int int ctr int ecall compare enter 3 max call make chkr2front get max activation elaborate task enter int figure 2 algorithm contour fdr r gammapsi phi c19 c6 chk get num chkr int rend exit rend enter chk select truec10 truec14 loop rend enter get num accept get num activation elaborate task enter numnum rend exit num int num int int terminate call make chkr ecall nxt chkrchk compare compare figure 3 algorithm contour chkr tag associated object acc access object atype access type int integer lab label proc procedure ttype task type figure 4 descriptive tags used primes example figure 4 summarizes meanings tags appear example declaration array also contains information required initializing data objects shown rows fdr fdr chkr make chkr instructions p1p121 describe algorithm performed primes every algorithm begins enter instruction case top level proce dure use task enter instruction entering scope task type elaborate instruction p2 elaborates declaration array primes elaborate instruction arguments abbreviation series elaborate instructions one row declaration array enclosing algorithm contour activate instruction p10 activates instance fdr remaining instructions algorithm primes correspond executing body primes p11 completing instance primes p120 finally terminating instance primes p121 contour make chkr represents procedure make chkr john stons model extend procedure implicit formal input param eter called ret used label transferring control back caller first row declaration array make chkr represents implicit declaration ret last two rows represent declarations formal parameters new pri new chkr appear specification make chkr rows representing formal parameter declarations specify parameter passing mode algorithm make chkr begins proc enter instruction entering scope procedure m1 require elaborate instruction declarative part make chkr empty next four instructions model statements body make chkr create instruction m30 creates new task instance type chkr collection associated chkr ptr assigns reference new instance new chkr instruction m31 activates new instance instructions m4 m5 implement entry call statement output statement body make chkr algorithm make chkr require complete instruction since pi run task information blocks dependencies io entries ready snapshot 1 initial snapshot make chkr dependents hence final instruction returns control caller figures 2 3 show algorithm contours fdr chkr contours figures actually nested within contour primes figure 1 shown separately readability algorithms require end activation instruction signals parent child instance done activating forloop body fdr produces forblock represented contour figure 2 forblock contains three local data objects loop parameter two implicit parameters used initialize loop parameter determine loop left contours get num chk figure 3 represent accept statements body chkr refer contours rendezvousblocks rend exit instruction terminates rendezvous leaves rendezvousblock select instruction c9 models select statement body chkr selective wait alternative produces pair arguments specifying associated guard flow control 6 executing algorithm primes snapshot 1 shows initial record execution program primes contains single processor denoted greek symbol pi subscript processor provides unique name use notational convenience identify processor superscript gives state horizontal arrow processor represents instruction pointer bent arrow represents environment pointer null dashed boxes left processor show program inputs top left box outputs bottom left box direct dependences middle box task information blocks right box identify entry queues associated tasks top half task information blocks execution status bottom half 4 example execution hypothesize single input value 10 initially output direct dependences task instance pri1 entries ready execute snapshot 2 shows record execution produced snapshot 1 executing task enter instruction p1 elaborate instruction p2 computation primes task enter instruction allocates initializes execution contour primes moves executing processor new contour elaborate instruction assigns initial values local data new contour described contour created task enter instruction defines base contour executing processor convention use name processor label base contour data array shown upper left corner execution contour interpreter copies program names first column data array declaration array algorithm contour part initialization new execution contour initializes static link new contour environment pointer executing processor thus referencing environment executing processor determines global environment new instance interpreter sets environment pointer executing processor reference new contour completing execution task enter instruction interpreter next executes elaborate instruction p2 elaborates row declaration array primes elaboration row fdr initializes value task type fdr data array contour pri1 task types ada local constants implicit initial values value task type identifies computation global environment required computation names entries declared task type first two components value task type form completed label binds first instruction algorithm task type environment executed 5 interpreter completes instruction pointer given declaration array algorithm contour binding environment pointer executing processor copies set entry names declared task type declaration array obtain fact contour model extends processors special components describe information shown dependencies diagram task information blocks display information separate diagrams help organize snapshot make easier read 5 also use completed labels represent procedure values even though full generality completed label actually needed representing either task types procedure values ada permit assignment procedures task types allow passed parameters environment pointer completed label represents procedure task type always references execution contour found use completed labels instead simple instruction pointers generality consistency johnstons model pri1fdr1task information blocks dependencies io entries ready entries act pi run r f get num chk g null front chkr ptr chkr fdr snapshot 2 processor pri1 executes instructions p1 p2 code indication act task instance activating designated children com task instance completed awaiting termination designated dependents cre task instance created waiting activate ecall task instance waiting designated entry queue call accepted rend task instance rendezvous designated task sacc task instance selectaccept statement designated alternatives open figure 5 blockedwaiting codes initial value task type elaboration row fdr creates initializes new processor assigns fdr pointer new processor interpreter uses label associated task type initialize instruction pointer environment pointer new processor creates task information block containing entry queues needed new task instance interpreter starts new processor activating state blocks since activation new instance must await elaboration parent circle processor blocked maintain information conditions upon blocked bottom half task information block figure 5 summarizes blockedwaiting codes used purpose upon creating new processor interpreter must also establish dependency new processor direct master environment pointer executing processor designates direct master task instance elaborated finally pointer new processor assigned fdr use broken arrow represent task value elaboration remaining rows declaration array primes straightforward elaboration row chkr associates completed label set entry names chkr described elaboration row chkr ptr assigns empty collection set chkr tasks chkr ptr elaboration row make chkr creates completed label associate make chkr finally elaboration row front assigns front null access value default initial value access objects ada snapshot 2 depicts two independent threads control represented processors pri1 fdr1 nevertheless execution must continue pri1 fdr1 blocked snapshot 3 shows result executing activate instruction p10 blocks executing processor unblocks proces pri1fdr1task information blocks dependencies io entries entries ready act pi run r f get num chk g null front chkr ptr chkr fdr snapshot 3 processor pri1 executes instruction p10 sor designated argument thus fdr1 ready execute pri1 blocked task information block pri1 associates act blocked waiting code activationwaiting set pri1 identifies tasks must finish activating blocked processor proceed computation processor fdr1 processor ready execute next three machine cycles executing instructions f 1f3 produces snapshot 4 task enter instruction f1 creates base contour fdr1 updates environment pointer executing processor elaborate instruction f2 elaborates row max declaration array fdr effect max initial value finally end activation instruction f3 changes state executing processor activating running removes processor activationwaiting set associated parent produces empty activationwaiting set interpreter also unblocks parent snapshots presented show conventions govern placement contours processor symbols enhance visual utility diagrams particular nest execution contour directly inside contour designated static link place processor symbol immediately within contour referenced environment pointer conventions imply referencing environment processor determined visually processor access data execution contours enclose processor cannot see data nonenclosing contours thus static chain processor consists contours enclose processor symbol beginning innermost enclosing contour moving outward enclosing contours conventions also eliminate need explicit static links environment pointers therefore omit subsequent diagrams either processors pri1 fdr1 selected execute snapshot 4 assume interpreter selects pri1 execute next two machine cycles producing snapshot 5 execution complete instruction task completes executing processor base contour 6 shown snapshot complete processor changing state complete execution contour attaching superscript com contour name dependency diagram complete instruction also blocks executing processor case pri1 contour completed dependents yet terminated next machine cycle interpreter selects processor fdr1 snapshot 6 shows record execution produced executing instructions f4 f5 m1 get instruction f4 assigns first input value variable max removes input value input diagram call instruction f5 first pushes data required called procedure values actual input 6 state processor change execution complete instruction procedure block fdr1task information blocks dependencies io entries ready entries ready fget num chk itg fg null front chkr ptr chkr fdr pi run r pi run r snapshot 4 processor fdr1 executes instruction f3 pri1 comfdr1task information blocks dependencies io entries com entries ready fget num chk itg fg null front chkr ptr chkr fdr pi com pi run snapshot 5 processor pri1 executes instructions p11 p120 task information blocks dependencies io entries com entries ready fget num chk itg fg null front chkr ptr chkr fdr pi com pi run pri1front snapshot executes instruction m1 parameters references actual output parameters return label etc onto expression stack executing processor retrieves label value associated procedure transfers control label assigning instruction pointer environment pointer label instruction pointer environment pointer executing processor effectively moves processor global environment contour pri1 required new procedure instance transfers control proc enter instruction algorithm procedure proc enter instruction like task enter instruction allocates initializes new execution contour moves processor new contour however proc enter instruction also transmits parameter values pushed onto expression stack executing processor call instruction assigns default initial values parameters require eg second component new chkr first component new chkr illustrates notation designating reference cell within data array pri1front denotes cell front contour pri1 contour created proc enter instruction base contour construct new label point fdr1 processor ready execute snapshot 7 shows result executing instructions m30 m31 simulate call task allocator create instruction m30 creates initializes new processor task type chkr adds new processor collection associated chkr ptr assigns new chkr reference new processor represented solid arrow points processor sym bol initialization processor chkr1 follows steps outlined discussion initialization processor fdr1 time however new task instance requires two entry queues one queuing tasks call get num entry queuing tasks call chk entry entry queues maintained ordered lists processor names additionally direct master allocated task instance contour elaborates access type chkr ptr activate instruction m31 blocks executing processor unblocks processor designated new chkr producing snapshot snapshot 8 interpreter gone execute task enter instruction c1 elaborate instruction c2 end activation instruction c4 processors chkr1 fdr1 ready execute assume interpreter selects processor fdr1 executes ecall instruction m4 next machine cycle producing snapshot 9 like call instruction ecall instruction first pushes data required accept statement remote procedure onto expression stack executing processor however places executing processor designated entry queue blocks processor ecall blockedwaiting code note entry queue processor suspended beside blockedwaiting code also extend task information block stack diagram cases expression stack processor nonempty thus get numhi ready fget num chk itg fg null front chkr ptr chkr fdr pi com pi run pri1front act snapshot 7 processor fdr1 executes instruction m31 ready get numhi ready fget num chk itg fg null front chkr ptr chkr fdr pi com pi run pri1front pi run null num snapshot 8 processor chkr1 executes instructions c1 c2 c4 ecall chkr1get num get numhfdr1i ready fget num chk itg fg null front chkr ptr chkr fdr pi com pi run pri1front pi run null num snapshot 9 processor fdr1 executes instruction m4 stack diagram task information block fdr1 shows value passed rendezvous get num show rendezvous progress processors fdr1 chkr1 snapshot 10 snapshot obtained selecting processor chkr1 next three machine cycles executing instructions c50c6 accept instruction c50 checks entry queue associated get num case presence processor entry queue shows calls pending entry chkr1 block execution rend enter instruction c51 proceeds follows interpreter first creates new contour get num1 moves processor new contour executing proc enter instruction removes processor fdr1 entry queue associated get num retrieves value formal input parameter num expression stack fdr1 updates blocked waiting status processor fdr1 finally instruction c6 assigns current value num num producing snapshot point assume interpreter selects processor chkr1 three machines cycles executing instructions c7c9 selects processor fdr1 four machine cycles executing instructions m5 m6 f60f62 snapshot 11 shows resulting record execution rend exit instruction c7 deallocates contour get num1 created rendezvous moves processor chkr1 contour chkr1 held deallocated contour unblocks processor fdr1 engaged rendezvous processor chkr1 select instruction c9 blocks processor chkr1 sacc blockedwaiting code associates selectwaiting set processor although selective wait alternatives represented arguments select instruction open guards trivially satisfied neither alternatives passable accept alternative cannot passed call pending chk terminate alternative cannot passed master chkr1 asleep selectwaiting set encodes information open selective wait alternatives needed complete execution select statement first element selectwaiting set chkr1 indicates presence open accept alternative instruction c10 begins accept statement entry chk second element signals presence open terminate alternative instruction c14 next instruction processor chkr1 execute known point depends open alternatives becomes passable reflect uncertainty snapshot listing statements processor may next execute beside instruction pointer execution processor fdr1 commences put instruction m5 output diagram shows value printed instruction return instruction m6 simulates return procedure call interpreter first copies value new chkr back location pri1front uses label stored ret reset instruction pointer environment pointer executing processor deallocates contour make1 enter get numhi ready fget num chk itg fg null front chkr ptr chkr fdr pi com pi run pri1front null get pi run snapshot 10 processor chkr1 executes instructions c50 c51 c6 ready get numhi fget num chk itg fg front chkr ptr chkr fdr pi com fdr110ctr pi run pi run null snapshot 11 processor chkr1 executes instructions c7 c8 c9 processor fdr1 executes instructions m5 m6 f60 f61 instruction f60 produces contour for1 moves executing processor new contour passes values x lim instruction f61 assigns value x ctr compare instruction f61 transfers control instruction f7 snapshot 12 shows record execution produced executing ecall instruction f7 fdr1 described interpreter pushes value formal input parameter expression stack executing processor places processor designated entry queue blocks processor time however since task information block called processor chkr1 indicates chkr1 wating accept call chk interpreter updates chkr1s instruction pointer unblocks illustrated main tasking features model speed execution snapshot 13 shows processor fdr1 passes number 3 processor chkr1 rendezvous chk completes another iteration forloop calls frontchk time check 4 processor chkr1 tested 3 relative primeness 2 call make chkr create new chkr task 3 processor chkr2 created execute new chkr task activated executed accept instruction c50 blocks chkr2 shown snapshot treat accept statement select statement two alternatives unguarded accept alternative terminate alternative guarded false ensuing rendezvous chkr1 chkr2s get num entry assigns 3 cell num contour chkr2 rendezvous completes processor chkr1 outputs new prime number returns call make chkr return instruction copies value new chkr cell nxt chkr contour chkr1 next snapshot shows effect passing first 4 5 pipeline number 4 fails check relative primeness 2 5 passes checks relative primeness 2 3 results creation new instance chkr task similar snapshots constructed show results passing numbers 6 7 8 pipeline 6 8 fail relative primeness check first stage pipeline 7 passes checks three stages adds new chkr task snapshot 15 shows record execution produced fdr1 feeds 9 chkr1 passes 9 chkr2 fdr1 feeds 10 chkr1 exits forblock terminates exit instruction f81 deallocates contour for1 moves processor enclosing contour fdr1 terminate instruction f9 deallocates processor fdr1s base contour changes state processor terminated note deallocate processor front still designates task albeit terminated one thus tasks may call entries belonging terminated task evaluate attributes eg terminated attribute also place superscript term name terminated processor dependency diagram make evident dependents pri1 must terminate omega omega omega oe task information blocks dependencies io entries entries ecall get numhi ready fget num chk itg fg front chkr ptr chkr fdr pi com fdr110ctr pi run pi run null snapshot 12 processor fdr1 executes instruction f7 chkr2 task information blocks dependencies io entries entries ecall get numhi ready chkr2 get numhi fget num chk itg fg front chkr ptr chkr fdr pi com fdr110ctr pi run make2 pi run chkr1nxt chkr null chkr2 pi run chkr2 null num snapshot 13 processor chkr1 executes instructions c10c12 c16 c17 c19 m1m31 processor chkr2 executes instructions c1 c2 c4 c50 processor fdr1 executes instructions f80 f61 f7 chkr2 pri1 com entries com entries ready ready get numhi chkr2 ready get numhi chkr3 ready get numhi fget num chk itg fg front chkr ptr chkr fdr fdr110ctr pi run pi run chkr15 num chkr2 pi run chkr25 num chkr3 pi run num pi com snapshot 14 result passing 4 5 pipeline chkr3 chkr2 pri1 com entries com entries ready get numhi chkr2 ready get numhi chkr3 ready get numhi chkr4 ready get numhi fget num chk itg fg front chkr ptr chkr fdr pi run num chkr2 pi run chkr29 num chkr3 pi run chkr37 num chkr4 pi run num pi com snapshot 15 fdr1 terminated 9 10 pipeline unblocked pipeline consists four stages front designates processor implementing first stage pipeline processors implementing remaining stages found following references nxt chkr cells value num base contour processor determines prime used processor relative primeness checks value new val shows next number processor check processor completed check yet received request another check last number checked snapshot shows pipeline two numbers checked concurrently first stage checking 10 relative primeness 2 second stage checking 9 relative primeness 3 9 10 fail primeness check execution continues add additional stages pipeline four chkr tasks eventually execute select instructions c9 snapshot 16 show chkr1 chkr3 chkr4 executed select instructions chkr2 executes select instruction first three processors execute select instructions block accept alternative passable master asleep obtain snapshot 17 executing select instruction c9 chkr2 terminate instructions chkr task instances time master pri1 put sleep execution select instruction interpreter therefore updates instruction pointers blocked dependents executing processor reference terminate instructions unblocks chkr1 chkr3 chkr4 terminate instructions deallocate base contours chkr task instances change state pro cessors last chkr task instances terminates interpreter unblocks pri1 finally pri1 executes terminate instruction producing snapshot 18 deallocating contour deallocate elaborated tasks allocated tasks collections contains example therefore processors fdr1 chkr1 chkr2 chkr3 chkr4 deallocated part deallocation contour pri1 completes sample execution program primes 7 relationship information structure models section highlights main differences contour model ada tasking described johnstons contour model block structured languages 17 discusses relationship model stackbased execution models johnstons contour model berrys clarifications model 5 omega omega omega omega oe hy phi phi phi phi phichkr4 chkr3 chkr2 pri1 com entries com entries get numhi chkr2 ready get numhi chkr3 get numhi chkr4 get numhi fget num chk itg fg front chkr ptr chkr fdr pi run num chkr2 pi run chkr29 num chkr3 pi run chkr37 num chkr4 pi run num pi com snapshot 16 chkr1 chkr3 chkr4 blocked select instructions chkr2 preparing execute select instruction omega omega omega omega omega omega oe hy phi phi phi phi phichkr4 term chkr3 term chkr2 term pri1 com entries ready entries get numhi chkr2 get numhi chkr3 get numhi chkr4 get numhi fget num chk itg fg front chkr ptr chkr fdr chkr2 chkr3 chkr4 pi com snapshot 17 chkr task instances terminated pri1 ready terminate pi run task information blocks dependencies io entries snapshot 18 terminal snapshot form basis contour model ada tasking altered aspects basic model accommodate semantics ada tasking example refine notion state processor coincide closely phases lifetime task associate separate execution status processor model therefore state processor determine whether eligible execute blocking processor affect state contrast original contour model distinguishes three processor states states determine execution status johnstons model processor either awake eligible execute asleep blocked terminated finished executing algorithm also modified details protocol subprogram call return protocol illustrated berry 5 procedure call instruction allocates initializes contour new procedure activation evaluates actual parameters copies parameter values new contour transfers control enter instruction moves executing processor new contour protocol procedure call instruction evaluates actual parameters pushes onto executing processors expression stack transfers control appropriate enter instruction procedure enter instruction allocates new contour moves executing processor new contour passes parameter values modifications allow us treat calls subprograms calls entries uniformly entry call instruction cannot allocate contour required rendezvous pass parameter values called task may ready execute rendezvous may accept calls one explicit elaboration declarations program unit required model ada tasking accurately model semantics task creation activation particular explicit elaborations allow us model erroneous executions caused race conditions occur activations tasks share global variables also allows us model programs activation certain tasks must interleaved activation andor execution tasks avoid deadlock 22 additional data structures instructions realizing specific requirements ada tasking mentioned discussion example associate direct master entry queues blockedwaiting information processor include instructions activating tasks signaling end tasks activation parent initiating completing rendezvous selective acceptance entry calls contour model retention model program objects cells retained long accessible automatically reclaimed become inaccessible presentation model gives explicit rules reclaiming storage execution often visually apparent complex object processor contour becomes inaccessible way deallocation also viewed driven execution various contour model instructions however model designed cause effect rules equivalent retention model particular contour model therefore equivalent stackbased implementation models described 12 16 19 contour record execution corresponds activation record runtime stack processor creates nested contours enclosing processor determine static chain sequence contours obtained starting innermost enclosing contour following environment pointers within contours return labels processors base contour determine dynamic chain stack model multiprocessing processor runtime stack model base contour processor corresponds activation record base runtime stack processor 8 conclusions future work visual execution model ada tasking help programmers gain deeper understanding tasking semantics contour model depicts asynchronous tasks relationships environments tasks execute manner tasks interact making possible see happens execution program example shows precisely activation task instance begins ends instance synchronizes parent entries invoked similarly shows relationships referencing environments concurrent instances various properties snapshots established motivate definitions task dependence termination ada demonstrate interplay definitions basic runtime management concerns 9 presented snapshots level abstraction appropriate programmer trying understand semantics ada tasking higherlevel diagrams required understanding complex tasking programs might involve large numbers interacting task instances example higherlevel instructions defined expand control flows conventions established allow programmer identify segments code treated atomic instructions information within execution contours also suppressed focus attention data important understanding execution unfolds example references task instances key data values computed instance might shown data arrays return labels values task types procedures might suppressed similarly task information blocks shown using icons circular configuration directed edges icons representing blockedwaiting conditions order highlight information required detect deadlocks icons expanded necessary show additional information relating status task instances mechanical implementation contour model essential become practical tool automated interpreter level described paper would provide valuable visual aid teaching ada tasking sophisticated interpreter capabilities viewing programs abstract levels would allow programmer explore various executions program investigate potential interaction among tasks understand effects different algorithms scheduling ready tasks fairly minor extensions automated interpreter would provide natural interface tasking debugger 8 interleaving symbolic executor 15 acknowledgements would like thank dan berry generous advice thoughtful reviews many drafts paper r approved ada language commentaries ada tasking semantics efficient implementation programming ada notes pl1 notes contour model treatment ada procedures aliasing oest editors towards formal description ada debugger ada tasking task dependence termination ada concurrent programming programming language concepts ada tasking demo task state transitions ada interleaving symbolic execution approach formal verification ada programs task ing fundamentals programming languages contour model block structured processes programming language structures programming languages design implementation visible semantics programming languages united states department defense contour model ada tasking programming languages tr ada concurrent programming ada advanced introduction programming language concepts 2e programmming languages design implementation 2nd ed fundamentals programming languages 2nd ed ada tasking demo debugger ada tasking towards formal description ada programming ada ctr laura k dillon task dependence termination ada acm transactions software engineering methodology tosem v6 n1 p80110 jan 1997
synchronous approach designing reactive systems synchronous programming available several formally defined languages different characteristics esterel imperative lustre signal declarative style statecharts argos graphical languages allow one program constructing hierarchical automata motivation taking synchronous design paradigm integrating imperative declarative dataflow graphical programming styles real systems typically components match profiles paper motivates interest mixed language programming embedded software around number examples sketches semantical foundation synchronie toolset ensures coherent computational model toolset supports design trajectory incorporates rapid prototyping systematic testing early design validation object oriented development methodology long term software management formal verification level automatically generated object code b introduction reactive computer systems continuously respond external stimuli generated en vironments critical components technology dominated lives control systems abs cars flybywire aircraft railway signalling power gen eration shopfloor automation mundane things washing machines video recorders mastering design systems reducing time needed bring market becomes utmost economic importance times increasing market dynamics paper advances paradigm synchronous programming means match goals several programming languages originally emerged engineering notations defined iec standard 11313 18 languages designed specifically embedded software applications mainly process control industry increasing influence sectors unfortunately iec 1131 languages designed benefit formal semantics yet advance state practice embedded software design important provide tools support highlevel specification rapid prototyping integrate testing formal verification achieve early design validation encourage modular software developmentto ease review maintenance certification languages precise mathematical semantics required synchronous programming languages like discussed paper potential introduce rigour embedded software design languages distinctive characteristics esterel 4 imperative style lustre 13 signal declarative statecharts 15 argos 26 graphical notations enable one program directly constructing hierarchical automata languages share common communication metaphor synchronously broadcast signals sections 2 3 introduce key ideas behind synchronous approach embedded soft ware outline programming constructs available lustre esterel argos simple examples longer introduction languages found 12 specific profiles languages reflects fact developed response problems emerging different application areas lustre signal derive requirements industries mainly aware electrical electronics engineering methods wanted manage increasing complexity applications gain greater flexibility design introducing software languages therefore designed discrete handling continuous phenomena invoke metaphors commonly used electrical engineers control theory thus suited signalbased applications navigation digital signal processing often sampling different related frequencies found contrast esterel graphical languages like argos better suited scheduling complex operating modes handling intricate patterns events describing interruptdriven behaviours however difference bestsuited application profiles qualitative assessment since languages broadly similar expressive power motivation taking synchronous design paradigm wholesale integration imperative declarative dataflow graphical programming styles real systems typically components match profiles argued gajski 11 construction embedded systems requires combination state based dataflow models support hierarchical structuring behaviour concurrency exception handling believe semantical combination languages described definitely satisfy requirements unique feature synchronie workbench active development embedded software design group gmd success venture rests underlying computational model sketched section 4 greater rigour section 5 provides coherent mathematical framework yields compact verifiable code main functions synchronie workbench described section 6 synchronous programming languages already evaluated industries particularly aviation power generation problems realtime constrained safety critical commercial interest synchronous languages lies style seamless integration existing software development practices programming environments provided short overview marketed environments support language industrial applications found 2 19 addition project management facilities editing facilities mix text graphics commercial environments provide advanced features design vali dation backend compilation various languages like c vhdl synchronie workbench also provides features offers system designers addition much greater freedom choice programming language unique option freely mix various synchronous programming modes part synchronous languages provide primitive datatypes operations emphasis gaining intellectual control programs often intricate control logic rather data processing issues compound datatypes need used synchronous language hosted common language c fortran ada synchronous languages achieve good separation concerns data control logic novel fusion synchronie object oriented construction techniques 7 8 offers right kind design encapsulation abstraction mechanisms achieve much needed transparency software development lifecycle 2 reactivity synchrony contrast interactive system say text editing program reactive system fully responsible synchronisation environment system reactive fast enough respond every input event reaction latency short enough environment still receptive responses control systems systems digital signal processing used industry telecommunications reactive according characterisation common features reactive systems concurrency typically consist several concurrent components cooperate realize intended overall behaviour realtime supposed meet strict constraints regard timing response time availability determinism systems reaction uniquely determined kind timing external stimuli heterogeneity often consist components implemented quite different technologies like software hardware distributed architectures reliability requirements include functional correctness well temporal correctness behaviour also robustness fault tolerance fundamental idea synchronous approach simple reactive systems idealised assuming stimulation reaction simultaneous reaction takes zero timemeaning observable amount time system stimulated events environment responds instantaneously physical time play special role time considered sequence particular kind external events point view statement train must stop within 10 seconds essentially different statement train must stop within 100 metres cases something said occurrence events 12 event stop must precede 10th 100th next occurrence event second metre events manifest signals broadcast throughout system instantaneously system reacts emitting broadcasting signals well statement could modified signal train stops must emitted signal second emitted abstracting physical time offers number advantages granularity time may changed without affecting sequence events system components composed decomposed subcomponents without changing observable behaviour particularly beneficial proving system properties practical terms synchrony hypothesis states system reacts fast enough record external events proper order property realistic insofar checked corresponds hardware point view time needed operation importance long exceed duration clock cycle vice versa clock cycle determined operation consumes time synchronous approach therefore advances twostage design reactive systems physical time first abstracted focus functions maintained validity abstraction actually verified systems implemented 3 synchronous languages section sketch typical synchronous programming styles focusing subsections follow esterel argos lustre larger example described section 41 uses languages together solve programming problem natural way wish give reader feeling synchronous programming general examples necessarily rather simple 31 imperative programming esterel suppose following informal specification given second mouse click succeeds first one within 5 milliseconds double click otherwise single click assuming time units specified signal tick required behaviour captured esterel program shortest figure 1 first program waits click signal produced environment two programs executed parallel upper subprogram broadcasts single signal five ticks provided loop trap done await click await 5 tick present double else emit single exit done await click emit double exit done loop figure 1 esterel mouse controller double emitted simultaneously raises exception trap signal done terminates conditional programming construct present end interpreted double signal present nothing otherwise emit single exit subprogram emits double signal click occurs second time exits trap signals exceptions raised abort programs within scope declaration net effect raising done either parallel branches mouse program body loop terminated esterels semantics cause loop restart immediately program returns await click top loop note priority given double single second click happen fifth tick clock contrast trap statement construct halt watching click await click actually abbreviates involves second stronger kind preemption mechanism halt statement one esterel consume time fact halt starts never terminates however body watching construct preempted whenever watchdog condition becomes true whenever signal click present example language constructs esterel instantaneous apart halt statement derived constructs like await saw loop restarts immediately terminates sequential composition likewise reckoned take zero time tests conditional statements thus second click coincide fifth tick present test first subprogram example executed logical instant click aborts await second subprogram course assumptions made behaviour respect physical time represented explicitly tick signal supplied environment 32 graphical programming argos illustrate graphical notation program previous section coded argos see figure 2 states represented rounded boxes automata hierarchic states contain subautomata example state two two subautomata automata run parallel indicated dashed line finally scope signals restrictedthis indicated square cornered box instead rounded one mouse done two four three one click doubledone click timeout five timeoutdouble singledone done figure 2 argos program mouse controller list signals glued default arrow indicates initial state subau tomaton eg labelled one three count5 started mouse automaton enters initial state labelled one occurrence click signal causes jump state two initialises parallel subautomata label arrow form indicates transition take place signal arrives cause signal emitted simul taneously generally guard transition list specifies presence absence number signals output action list signal names omit ted list empty subsequent transition state count5 state five fire timeout signal present double signal present causes single done emitted add refinement state count5 contains subautomaton displayed figure 3 fifth tick timeout signal emitted subautomaton comes tick tick tick tick timeout tick figure 3 argos 5 tick counter ie await 5 tick emit timeout halt tick implicit guard every transition argos mentioned explicitly guard would otherwise empty meanwhile second click occurs transition state three state four takes place causing simultaneous emission double done however second click occurs fifth tick transition state five possible double occurs negatively guard transition hence exactly one single double emitted state two either case accompanied local signal done signal causes state two abandoned emitted appears guard transition ei0bkjml n i0o 90 9p jqf 88 statewhatever individual states subautomata signal occurs abandoned control flow similar preemption mechanisms esterel program therefore returns state one waits next click 33 declarative programming lustre l mn l l l prq ev e prq figure 4 first order digital filter illustrate declarative synchronous programming style shall implement recursive digital filter lustre first order digital filter may specified signal flow graph 32 figure 4 quantities incoming edges nodes graph summed result broadcast along outgoing edges labels pqs ev e arcs denote delay shift register multiplications respective constants linear form would equation uyxz ev wx e wx qs uyx qs denotes time index boundary condition z ev v equation boundary condition translates lustre node node filter let one instantiate constants specific real values course equation evaluated every program cycle marked lustre implicit clock tick rather explicit tick seen earlier lustre program started runs forever without terminating executing every equation cycle case first tick term a0 x evaluated later times term a0 x b1 prey evaluated gives semantics followedby operator pre operator allows access previous value expression operates lustre operators upsampling downsampling operations illustrated timing diagram downsampling means operator upsampling means current takes value x clock signal b true undefined otherwise currentz latches value z next sampling signal ie next instant b becomes true explained section 5 mechanism allows one easily define digital filter regard different base frequency node bfilter b let declarative synchronous languages include signal silage 22 16 latter mainly used specification language cathedral 21 toolset synthesis dsp chips languages quite similar lustre style use slightly different mechanisms upsampling downsampling concludes survey synchronous programming styles features argos lustre mentioned esterel slightly richer language mouse controller example illustrates since particular signals carry data may tested modify control flow languages share communication principle synchronously broadcast signals scoping mechanisms shown ever fact signals tested emitted simultaneously parallel branches synchronous program sometimes give rise confusion cause effect signals activation causality cycles correspond short circuits sequential programming errors detected statically compilers affect semantics individual languages class acceptable programs detection causality cycles intricate however falls outwith scope present paper see 25 35 example 4 integration synchronous languages since complex systems often components match different profiles sketched natural wish express appropriate language rather shoehorning solutions single language illustrate useful interaction synchronous languages reprogrammed production cell case study 23 used evaluating comparing software development methodologies tools successful design verification controller discussed independently contexts esterel signal lustre 23 dwell details specification section 41 rather overall organisation section 42 outlines aspects underlying computational model makes possible idea integrating languages single coherent mathematical framework formalities drawn section 5 41 multimodal programming production cells input arrives via feed belt conveys metal plates elevating rotary table table lifts plate position robot picks first arm transferring press plate forged press removed deposit belt second arm robot circuit completes crane unloads forged plates end deposit belt although circuit one item quite simple design cells control software maximise throughput meeting various constraints devices cells controller short initialisation phase various devices set specific safe states followed endlessly looping process controls actual production cycle production phase divides naturally six components run parallel one physical device represent design highest level organisation used argos illustrated figure 5 graphical nature lan production cell done production deposit belt crane feed belt table robot press initialise ictrl idata done figure 5 production cell argos guage makes suitable presenting highlevel design choices reader appreciate glance overall structure control program graphical style eases communication partners development software others involved constructing production cell including management mechanical electrical engineers designing physical components system safety analysts initialisation phase sets arms robot retracted state ready handle first plate arrive safety since might otherwise damaged press switched behaviour implemented first emitting signals rretract1 rretract2 actuators robot waiting arms reach desired positions reaching positions signalled outpress1 outpress2 occurs stop command emitted respective arm means signals rstop1 rstop2 arms reached desired positions signal done emitted transferring control unending production phase programming argos statecharts matter would little choice implement initialisation logic program similar figure 6a drawback graphical formalism becomes apparent control flow ictrl outpress1 tick outpress2 tick rstop2 done rstop1 done rstop1 rstop2 done rstop1 argos initialisation module ictrl input outpress1outpress2 output rretract1rstop1 rretract2 rstop2 done emit rretract1 await outpress1 emit rstop1 emit rretract2 await outpress2 emit rstop2 emit done module b esterel initialisation figure 6 initialisation phase production cell confused fact one explicitly manage synchronisation emit done arms retracted via process lower part figure also reader may forgiven wondering whether external process running parallel initialise interfere emitting rstop1 signal say process cannot inferred simply looking figures 5 6 level detail graphical programming becomes cumbersome therefore error prone one quickly loses sight flow information instead refine state ictrl figure 5 esterel program shown figure 6b makes natural control flow explicit semicolon concurrent initialisation two arms esterels powerful parallel operator handles synchronisation behalf ensure done emitted branches terminated program handles pure signals say signifying events dataeven though position arms reality provided potentiometer delivering real value next section shall describe one method handling data refining state idata complete initialisation program rest program implemented lustre described holenderski 17 discussed steady state behaviour press robot physical components adequately expressed lustre since interlocked nonterminating parallel processes however specifying sequential composition initialisation production phases lustre leads obscure program since sequential composition operator simply available avoid implementation holenderski programmed sequence level c interface simulator provided case study ad hoc approach highly error prone general undermines formal definition synchronous language lustre case preempts performing formal verification full program 42 synchronous automata performing sequential composition argos contrast fully formal long meaning combination synchronous languages clear aided relative simplicity eg compared ada c though different look feel esterel lustre argos interpreted computational model section introduces main notions behind synchronous automata formal presentation deferred section 5 421 boolean automata boolean automata easier understand fact particular instance synchronous automata capture essence synchronous languages boolean automata two kinds statements signal emitted condition satisfied control register h true set next instant satisfied synchronous program represented collection statements defining signals represent transient information registers represent persistent information operational semantics boolean automata defined two successive phases given val uation assigns truth value tt ff registers inputs inputs represented free variables reaction solution system equations solution extends cover signals use compute assignments yield next state machine solution signal equations input patterns reachable states must proved exist compilation time guarantee program reactive may respond every input stimulus addition solution must unique guarantee program deterministic issues common synchronous programming languages example behaviour esterel statement await outpress1 defined boolean automaton register h captures pause await construct registers initially false set boolean automaton initialisedthat special start signal present present true first clock cycle thereafter h set every program cycle signal outpress1 occurs point automaton terminates h becomes stays false termination signified special signal note outpress1 ignored first clock cyclereaders familiar esterel realise immediate needed handle event boolean automaton captures behaviour statement emit rstop1 automaton emits signal terminates immediately sequence await outpress1emit rstop1 specifies former statement terminates control passes instantaneously latter control flow tracked compiler substitutes start condition boolean automaton associated second command sequence termination condition first hence upper parallel branch figure 6b obtain cannot sketch translation language constructs hopefully provided feeling translation proceeds argos boolean lustre also natural compact interpretations boolean automata full translation pure esterel along proof correctness respect published semantics given 34 422 synchronous automata synchronous automata represent enhancement model handle data boolean automata capture pure control synchronous languages focusing synchronisation issues ignoring data carried signals actions upon intuitively enhancement achieved coupling presence signal unique datum earlier notion refined thus satisfied signal emitted value returned function satisfied register h set next instant result function framework boolean automata synchronous automata domain values restricted singlepoint set denoted signals referred pure signals also pure control registers values little interest earlier boolean equations assignments h given way conditional equations guarded commands h automata thus pure synchronous automata illustrate idea let us specify discretisation position arms robot production cell initialisation phase thus node idata arm1 arm2 real returns let lustre node emits outpress1 outpress2whenever sensors arms robot indicate safe distance press defined synchronous automaton outpress1 outpress2 idata first two statements translate equations lustre node latter represents implicit control declarative programs register h idata initially inactive gets set becomes active program started remains set thereafter persistence indicated h idata appearing statement guard refers active status register value since never changes state h idata might thought redundant nevertheless captures nonterminating property declarative programs declarative program gets started via retains control executed every later instant time anticipate may lose control well idea required integrate declarative imperative styles formally captured synchronous automata control axiom 423 control axiom control axiom states synchronous automaton react control synchronous automaton control either present registers process set way nonexample following statement alone define synchronous automaton since presence outpress1 neither depends state latter dependency exists implicitly lustre programs main loop outpress1 control axiom appears contradict notion reactive system must maintain ongoing relationship environment thus must always react even true complete reactive system whole program subcomponents may active particular may preempted production cell esterel module ictrl terminates emitting done lustre node idata never terminates respect semantics argos initialise state figure preempted done therefore aborts lustre node performed compiler redefining h idata thus idata done h idata guarding register statements translates weak preemption mechanism 3 similar esterels trap construct preemption mechanism argos strong preemption mechanism captured guarding kinds statements longer presentation synchronous automata algebra given 24 whence summary formal semantics next section drawn 5 semantics nutshell evident synchronous programming paradigm dual nature one hand languages lustre descriptive constrain possible behaviours one hand languages like esterel argos foster constructive point view automaton specified prescribes transformation given state another argued informally synchronous automata useful intermediate representation structures reasonably unsophisticated mathemat ically match programming styles well enough serve kind synchronous object code though course originating tradition deterministic automata wishing lose light presentational style previous sections burden reader undue formality shall try shed light formal semantics slightly rigorous manner subsections follow first address descriptive prescriptive aspects synchronous programming merging dataflow controlflow synthesis end 51 declarative aspect constraining dataflow behaviour manifest possible observe classify observations attributing name moment referred signal signal may present value taken set may absent particular signal observed time flow values misses signal absent obtained ei0bkjml n i0o 90 9p jqf 88 flow characterised subset natural numbers sampling rate valuation present instant takes value 0 example z dy0y refer set flows synchronous process instant time require least one signal synchronous process present requirement allows us identify observed external time natural numbers conceptually synchronous dataflow programs deal specification pro cesses example lustre equation specifies constraints upon corresponding flows u sampling rates instant p values taking second example memoisation operator pre prex introduces delay value x observed one sampling point observed next prex first sampling point value x observed beforehand insert nonvalue indicates even present value undefined course compiler must guarantee programs reaction ever depends nonvalue phenomenon similar program variables languages used runtime initialised lustres followedby operator discussed section 33 allows one initialise signals properly formal definition pre quite elaborate since depends sampling points skipping exact definition let us use notation w refer th sampling point sequence counting 0 sampling points w z synchronous automata introduced elementary language specifying constraints dataflows statement specifies whenever pure signal present signal must present value must equal w formal terms u notation somewhat overloaded precise subset onetoone correspondence characteristic function z tt iff hence boolean operators used control expressions guards 89a b0cdbef0gh well justified unambiguously interpreted boolean operators operators subsets point note although definition forces u value instant may still values instants furthermore require signal w present instants otherwise constraint idea naturally generalises complex statements data expression control expression closely related pre operator second type statement found synchronous automata namely delays observation w one instant upsamples time ever whatever observed instant observed u instant figure interprets formal definition u zw 0 z however totally trivial exercise prove provided attention restricted signals w u synchronous automaton init z equivalent lustre statement prex introduces third final clause synchronous automata viz init used initialise dataflow would otherwise take value z proof automaton implements pre little tricky reader easily verify semantics compute flows adjacent diagram shows last value w stored next sampling point note turns z diagram supposed ei0bkjml n i0o 90 9p jqf 88 52 imperative aspect managing control imperative synchronous languages inherently based idea distributed state esterel instance halt statement used indicate local sequence control within parallel branches program halts behaviour defined ff abbreviates introduced specific control register halt synchronous automaton activated register remains active forever automaton never terminates precisely reflected formal semantics yields z r means z discussion revert boolean automata control specified terms pure signals apologise terminological confusion may troubling reader point stated earlier flows represent observations made certain tributes namely signals speak terms registers reconcile nomenclature shall also relate flows registers stipulate registers unobservable one might expect registers may active thus possessing value though may case control registers inactive order model preemption synchronous automata simple idea guard reac tivation automaton modified control register activated remains activated instant signal present termination signal emitted later instant note requires control ie active clauses capture precisely semantics esterels await statement cf section 31 await click defined halt watching click construct generalises p watching p arbitrary program state ment addition preemption halts esterels semantics require signal emitted p watchdog signal present also ignored p instant commences execution 4 preemption effect achieved guarding emittance signals typical clause p depends register may e v0rg meaning emitted e present first control register active g present emission preempted watchdog action thus e v0rgv note still emitted first instant e present contrast argos allows preemption registers regard figure 2 emmittance signal done preempt states inside state two including state two reader note preemption signals must avoided otherwise signal done cause preemption case would emitted preemption registers achieved guarding mechanism guard done working details reader may quickly check h one done h two click h two click done h two relates transitions state one state two conversely building informal description section 32 easy check behaviour subprocess state two captured synchronous automaton double click single timeout double done timeout double click h three click timeout double omitting register clauses refining state count5 timeout signal defined h four h five since terminal states respective argos subautomata never become activated guarding registers done therefore clauses change repeated obtain h one done h two click h two click done h two h three click click done click timeout double done h count5 fairly precise account wasdescribed informally section 32 course structural compositional treatment needed argos compiler synthesis general thus example argos compiler must bind h four h five since context surrounding subautomata known becomes clear registers never become activated compositional semantics argos terms synchronous automata allows us make optimisations rather easy establish cannot said compositional semantics esterel much complex lan guage however give flavour approach let us return discussion sequential composition begun section 42 assume p q translated synchronous automata respectively use common trick modelling pq within parallel calculus see eg 29 placing parallel preventing starting signifies terminated start signal suspends control axiom activation emits notation means given fresh name replaces beauty synchronous automata textual juxtaposition concatenation since broadcast starts instant terminates formally termination requires control registers become inactive end instant emits defining property synchronous automata like control axiom discussed section 423 fortunately turn invariants compositional semantics esterel specifically 34 prove given translation synchronous automata esterel statement p 1 emits next instant control register active 2 control register active signals emitted results support main theorem 34 states synchronous automata semantics coincides official behavioural semantics pure esterel 4 53 merging control dataflow basic question control dataflow seems calling dataflow program magically transfers control program killing resulting endless process withdraws control get grasp issue recall system reactive fast enough respond every input event reaction latency short enough environment still receptive responses implicit point view notion without input event response giventhat signal present input signal must present hence possible control synchronous process guarding input let x input signals lustre program node consisting single equation behaviour lustre program equivalent level observable signals preemption may applied since cheerfully abusing syntax watching simple trick adding control reconciles declarative imperative programming styles least regard preemption dataflows another facet interaction dataflow controlflow emerges example discussed section 42 recall lustre node idata placed parallel esterel module ictrl order realise initialisation phase production cell already seen terminate lustre node done emitted outpress1 signal say handled esterel control program point outpress1 section 422 boolean flow modulo preemption always present boolean value pure signal required 7 89a b0cdbef0gh section 421 difficulty lustre distinguish clocks boolean flows although signal esterel example strict formality therefore obliged sample boolean flows true outpress1 true natural projection true z dv z tt ultimately course control expressions implemented boolean functions target program ming language synchronous automaton compiled true thus detail required consistency model rather implementation detail closes discussion mathematical underpinnings synchronie work bench course many technical details formal translations omitted semantics nutshell hope reader grasped basic rather simple ideas however one important issue synchronous programming languages dwelt upon deserves mention least guaranteeing determinism reactivity formal translations may well generate clauses u inconsistent allow nondeterministic behaviour compilers report mishaps indicate went wrong synchronous automaton free problems comes name causality analysis clock calculus guaranteed specify deterministic mealy machine may implemented either hardware boolean automata software 6 architecture synchronie synchronie project gmd 33 organised around construction workbench mixed synchronous language programming combines editors compilers code generators tools simulation well tools testing verification animation integration languages based synchronous automata sketched play pivotal role system architecture synchronie see figure 7 page 21 since backend tools based common representation synchronous programs essential tool intrinsic workbench linker merges synchronous automata various sources approach guarantees maximum independence regard specific language constructs improves modularity translating programs synchronous automata kernel function causality analyser implements sound heuristics guarantee reactivity determinismthe algorithm implemented similar shiple et al 35 editor lustre translator lustre editor translator esterel argos editor translator argos esterel embedded eiffel embedded eiffel synchronie kernel causality analyser linker synchronous automata validation testing vis verifiers timing analysis netlist optimisers code generators compilation simulation esterel argos lustre viewers simulator animator project management figure 7 synchronie workbench project management increasing trend electrotechnical systems hardware components replaced software provides advantage device easily adjusted individual customers needs enterprise synchronous languages address delicate parts design problem managing often convoluted control flow synchronisations distributed elements control inputs recognised part software problem overall appropriate flexibility software design best achieved using object oriented techniques although space elaborate important part synchronie toolset developing object oriented design environment realtime applications based fusion argos esterel programming control flow object oriented language eiffel arithmetic data manipulations call hybrid language embedded eiffel thus project may multiple components written variety synchronous languages hosted c embedded eiffel present visible layer synchronie workbench provides programmers editing browsing project management facilities amongst components written different languages control frontend functions synchronie compilation compilation functions provide link towards executing synchronous automata various platforms particular function produces code simulation analysis tools rapid prototyping design validation encompasses optimisers may reorganise generated code variously optimisations performed depend ultimate destination code instance optimisations eliminate internal signals inhibited code simulators symbolic debuggers required however experience indicates optimisation minimise number registers desirable formal verification tools code generators exploit close relationship boolean automata sequential circuits makes straightforward generate netlist formats exported hardware synthesis analysis tools sis 5 generating portable executable code like c exploits hierarchical representation synchronous automata runtime efficiency resulting code ultimately aim produce code particular target architectures like pic processors microcontroller applications optimisation applied care particularly safety critical applications often requirement readable code meaning requirements traced executable code validation analysis functions intended improve confidence throughout steps development chain helping designers programmers reduce cost errors finding early possible several types analysis function identified verifiers support design validation formal proof logical specifications quirements part provide links interfaces third party tools instance boolean automata equate sequential circuits use among many adequate alternatives smv model checker nptools propositional logic verifier aspects design 28 36 testing improves product confidence simulation testing tool allows selection several criteria like path boundary values testing prototype test specification environment support systematic testing sense 30 designed around workbenchs graphical argos editor second type verification tool complements formal verification tools focuses behavioural specification 31 synchronous automata particularly boolean automata simple execution model supports fine grained timing analysis important verifying program meet strong timing constraints ie satisfy synchrony hypothesis simulation simulation functions provide stepwise interpretation synchronous au tomata means effect rapid prototyping two simulation tools distinguished simulators illustrate execution synchronous programs source level highlighting syntactical entities programs correspond active signals registers source viewers like editors provide browsing facilities among different components program animators support rapid prototyping simple environments executing programs animators based toolbox basic components generating inputs displaying outputs via waveform diagrams etc production cell control program described section 4 developed entirely using prototype tools synchronie toolset figures created using argos editor program moderately complex several hundred signals 140 control registers easily handled vis ctl 9 model checker verilog simulation hardware synthesis environment 6 simple backend code generator 7 conclusions work embedded eiffel already used develop two smallscale industrial products marketed germany first massflow meter sensitive coriolis device measuring fluid flow 8 second small electronic lock system based radio frequency technology 7 developed using synchronie tools highlevel esterel specification hand translated assembler latter case since target technology pic16c86 microcontroller meager 2k romwas accessible automatically generated c code automatically producing code limited hardware highlevel specifications formidable challenge represents next design goal synchronie project synchronie project member european eureka project synchron bringing synchronous technology realtime design 1 dedicated promoting synchronous programming languages industry synchronie workbench therefore developed isolation current generation synchronous programming environments promote respective languages independently links export synchronous automata existing tools model checkers like lesar 14 industrial strength verification tools like nptools 36 emerge due course since plan fully compatible dc declarative code format 10 principal deliverable synchron project idea integrating synchronous programming languages entirely without precedent therefore although efforts date mainly focused providing common exchange format downstream analysis tools halbwachs gives good summary common formats predating dc 12 jourdan others proposed semantical integration argos lustre based translation argos lustre 20 first attempt flawed causally correct argos programs would produce causally incorrect lustre recently maraninchi halbwachs shown encode argos dc 27 offers robust method merging two languages declarative code name suggests largely influenced dataflow synchronous programming community yet doubt suitability full esterel synchronous automata contrast supply uniform mathematical framework able freely intermix declarative imperative textual graphical programming styles acknowledgments work reported paper named authors like take opportunity thank colleagues embedded software design group gmd give credit efforts guaranteeing success synchronie group led throughout axel poigne significant input reinhard budde leszek holenderski karlheinz sylla jointly budde designed embedded eiffel paradigmatic example combination objectoriented design techniques synchronous programming several industrial case studies design realtime systems provided insights whole group profited maciej kubiczek working closely leszek holenderski professionally wrote compilers argos lustre supporting software present version work bench agathe merceron many case studies verification using prototype tools developed workbench monika mullerburg takes responsibility activities related testing hans nieters presented first full version presentation layer including argos editor spring 1996 put ideas work r synchron project proposal synchronous languages provide safety reactive system design preemption concurrent systems esterel synchronous programming language design vis system verification synthesis eingebettete echtzeitsysteme design verification synchronizing skeletons using branching time temporal logic common formats synchronous languages declarative code dc specification design embedded systems synchronous programming reactive systems synchronous data flow programming language lustre programming verifying realtime systems means synchronous dataflow language lustre visual formalism complex systems production cell lustre software computers application industrial safetyrelated systems formal approach reactive systems software telecommunications application esterel multiparadigm language reactive systems architectural synthesis medium high throughput processing new cathedral environment programming realtime applications sig nal formal development reactive systems synchronous automata reactive analysis cyclic combinational circuits operational compositional semantics synchronous automaton compositions compiling argos boolean equations symbolic model checking interpreting one concurrent calculus another systematic testing means validating reactive systems systematic testing formal verification validate reactive systems specification complex systems boolean automata implementing esterel constructive analysis cyclic circuits modelling verifying systems software propositional logic tr ctr per bjurus axel jantsch modeling mixed control dataflow system mascot ieee transactions large scale integration vlsi systems v9 n5 p690703 october 2001 axel jantsch per bjurus composite signal flow computational model combining events sampled streams vectors proceedings conference design automation test europe p154160 march 2730 2000 paris france klaus winkelmann formal methods designing embedded systemsthe sacres experience formal methods system design v19 n1 p81110 july 2001
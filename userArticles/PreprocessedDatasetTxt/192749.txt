highperformance microarchitecture hardwareprogrammable functional units paper explores novel way incorporate hardwareprogrammable resources processor microarchitecture improve performance generalpurpose applications coupling compiletime analysis routines hardware synthesis tools automatically configure given set hardwareprogrammable functional units pfus thus augment base instruction set architecture better meets instruction set needs application refer new class generalpurpose computers programmable instruction set computers prisc although similar concept prisc approach differs dynamically programmable microcode prisc define entirelynew primitive datapath operations paper concentrate microarchitectural design simplest form prisca risc microprocessor single pfu evaluates combinational functions briefly discuss operating system programming language compilation techniques needed successfully build prisc present performance results proofofconcept study inclusion single 32bitwide pfu whose hardware cost less 1 kilobyte sram study shows 22 improvement processor performance specint92 benchmarks b introduction number studies shown use hardwarepro grammable logic fpgas improve application performance tailoring hardware paths match particular characteristics individual application 45617 overall architectures studies work well specialpurpose domains logic simulation large number multiplication effectively use hardwareprogrammable resources generalpurpose environment must develop new approach costeffective automatic applicable vast majority applications architectural approach achieve goals called programmable instruction set computers prisc cost effec tive implement prisc top existing highperformance processor microarchitecture paper use risc architecture base though prisc techniques equally applicable cisc architecture prisc augments conventional set risc instructions applicationspecific instructions implemented hardwareprogrammable functional units pfus pfus carefully added microarchitecture maintain benefits highperformance risc techniques eg fixed instruction formats minimally impact processors cycle time generate applicationspecific pfu instructions automated fashion developed compilation routines analyze hardware complexity individual instructions using information compiler interacts sophisticated logic synthesis programs select sequences instructions execute faster implemented pfu hardware since pfu instruction generation process driven specific computations found application prisc approach avoids semantics gap problems cisc architectures 14 furthermore complexity approach completely hidden userprogrammer general computational model pfu multicycle sequential state machine iterative hardware solutions squareroot transcendental function evaluation good examples class pfu general model however introduces synchronization complexities pfu risc functional units paper discuss simpler model implements combinational function two inputs one output synthesis routines constrain complexity combinational function delay equal delay alu already processor datapath two restrictions pfu use synchronization mechanisms risc functional units refer first implementation prisc architecture prisc1 originally meant proofofconcept vehicle would allow us develop basic prisc compilation synthesis environment surprise prisc1 microarchitecture exhibited noticeable performance benefits computeraided design cad applications specint92 benchmark suite applications well even though pfu significantly slower highlycustomized risc functional unit automatically find opportunities use pfu typical custom functional unit adequate prisc environment makes mips 1 rule work per application basis 18 next section summarizes work related use programmable logic processor design automatic generation instruction sets section 3 describes microarchitecture prisc1 section 4 overviews prisc compilation environment hardware extraction techniques section 5 discusses performance modeling environment results obtained proofofconcept experiment finally section 6 presents conclusions describes future work related work highlevel synthesis 10 automated instruction set generation 131516 active areas research cad community although recent work areas relevant work group trying solve slightly different problems unlike work highlevel synthesis typically attempts build applicationspecific processor automatically work adds programmable logic generalpurpose processor relies compiler runtime system dynamically reconfigure programmable logic application unlike work automated instruction set design systematically analyzes set benchmark program define entirelynew instruction set given microar chitecture work simply extends existing instruction set explores microarchitectures effectively adapt asyet unseen applications overall key aspect work produce complete system compilergenerated information used dynamically reconfigure relatively small amount hardwareprogrammable logic perapplication basis organize hardwareprogrammable logic augments highperformance techniques found todays microarchitectures interacts cleanly functionality todays operating systems many ways work similar earlier work writable microcode stores 1202429each technique dynamically augments base instruction set new applicationspecific instructions improve application performance writable microcode approach creates new instructions grouping together primitive datapath operations performance improves reduce instruction fetch requirements use faster data storage increase overlap operations however holmer 16 points benefits already obtained use pipe lining multiple issue large register files todays architec tures work also creates new instructions grouping together individual operations base instruction set since approach optimizes hardware level lower existing functional units obtain performance benefits beyond captured pipelining multiple issue techniques effect pipeline operations granularity smaller existing cycle time additionally work addresses issues involved dynamically extending instructionset architecture microprocessor used multitasking environment previous work use hardwareprogrammable logic generalpurpose computing sparse iseli sanchez 17 propose vliw microarchitecture consisting solely pfus processor include custom vlsi functional units typical integer floatingpoint operations programmable logic significantly slower custom logic prototype maximum clock frequency 5 mhz 5 mhz clock rate significantly clock frequencies todays risc microprocessors typically 60 mhz addition iseli sanchez 17 offer techniques compile programs generalpurpose language c totally programmable environ ment shortcomings make type approach inappropriate generalpurpose microprocessors athanas silverman 5 propose instructionset augmentation process generalpurpose computing goals similar like approach describe compilation process coupled logic synthesis steps compilation process converts entire c functions programmable hardware granularity much larger approach considers grouping instructions candidates hardware synthesis expect general approach would find greater opportunities hardware synthesis even athanas silverman 5 report impressive speedups number specific c routines run prism1 prototype overall number shortcomings initial work work attempts come particular prototype compiler requires user interaction prototype compiler fully automated report performance results hardwareoptimized routines report results entire applications add programmable logic relativelyslow microprocessor 10mhz experiment fast cycle times 200 mhz contrast sparse work generalpurpose applications programmable logic great deal research programmablelogic solutions solve domainspecific prob lems work pioneered pam group paris 6 system contains xilinx 31 programmable boards bus generalpurpose workstation approach partitions computation particular problem xilinx boards workstation processor pam system shown good results ten applications 7 including long integer multiplication 25 rsa decryption 26 splash group brown university 4 mimicked pam model successful solving problems text searching dna comparison edge detection graphics applications unfortu nately boardbased methods incur high overhead communicating host cpu programmable logic board significant overhead limits applicability approach class algorithms combination high computational complexity low communication overhead offers relatively small amount hardwareprogramma ble resourcestypically 10times less found existing boardlevel designs figure 1 shows attach hardware programmable resources directly cpu datapath form pfu general implementation particular function pfu significantly slower 1 implementation function highlycustomized functional unit pfus added parallel existing functional units augment replace replicate existing datapath functionality even though pfus offer hardwareprogrammable resources resources reside inside cpu chip design decision minimizes communication costs bandwidth latency loading accessing pfu prisc1 pfu data communication handled like functional unit pfu two input ports accepts operands single output port drives results hope efficient communication mechanism hardwareprogrammable logic useful 1 example lewis 19 reports factor three performance difference programmable circuits maskprogrammed gate array circuits figure 1 prisc1 datapath register file source operand buses operand bus pdata paddr bypass logic larger class applications pfu also contains two programming ports operation described section 32 next two subsections discuss design pfu extensions instruction set architecture needed program use pfu section 4 describes overall software architecture prisc1 31 pfu design design pfu interesting nontrivial hardware design problem prisc1 primary pfu design constraint build functional unit delay fits within evaluation phase base cpu pipeline within constraint must choose design maximizes number interesting functions implemented pfu function interest ing evaluate faster pfu base cpu instructions figure 2 illustrates example implementation pfu combinational functions ie prisc1 pfu comprised alternating layers two basic components interconnection matrices logic evaluation units possible interconnection point interconnection matrix implemented cmos nchannel transistor controlled memory cell 2 appropriately setting value memory cell connect disconnect two lines logic evaluation unit implements hardware truth table called lookup table lut ninput 1output lut consists multiplexer connected 2 n memory cells one memory cell per truth table entry memory cell pfu addressable fact pfu memory cells viewed large sram loaded using pfus paddr pdata ports programming pfu implement particular function consists loading appropriate values interconnection matrix memory cells lut memory cells interconnection matrix logic evaluation units make prodigious use memory cells memory cells dominate layout cost pfu found symmetric pfu 3 alternating layers interconnect luts requires 30528 transistors 32bit datapath 61056 transistors 64 bit datapath memory cells comprise 90 tran 2 use sramfuse technology programmable logic basic fuse primitive pfus since types fuses easy reprogram sistors 22 predominance memory cells layout cost pfu tracks layout cost sram comparison 30528transistor pfu takes considerably less silicon area 1 kilobyte sram requires approximately 50000 transis tors current microprocessors easily include 16 kilobytes sram cache 12 many translation lookaside buffers tlbs larger pfu mentioned earlier constrain latency prisc1 pfu latency pfu execution fits within cycle time todays highspeed microprocessors straightforward determine worstcase delay pfu design figure 2 thus limiting number logic levels pfu easily bound delay assuming todays deeply pipelined processors tolerate approximately 1520 levels 2input logic gates per clock cycle 3layer pfu fit comfortably within 200 mhz cycle time 22 inclusion pfu within datapath places extra capacitive loading operand buses increases size multiplexer feeds pipeline latchregister end pipeline evaluation phase delay evaluation phase defines cycle time inclusion pfu increase cycle time slightly designs cycle time defined cache access time branch delay probably add pfu without affecting cpu cycle time 32 instruction set extensions program operate pfus define single new user instruc tion execute pfu expfu instruction figure 3 presents format instruction mips 18 notation 32bit expfu instruction evaluates boolean function two inputs one output compilationsynthesis system assigns logicalpfu number boolean function extracts application lpnum field expfu instruction specifies particular extracted function execute 11 bits lpnum field allow maximum 2048 different pfu programming configurations per application 3 explained section 4 programming information logicalpfu function part data segment applications object file use logical pfu number index data segment find appropriate programming information course program pfu every time used latency pfu operation would much greater expected value single cycle thus associate 11bit regis ter pnum register pfu pnum register contains logicalpfu function currently programmed physical pfu lpnum instruction matches value pnum register expfu instruction executes normally single cycle mismatch however exception raised exception handler loads pfu correct programming 3 current compilation system typically extracts fewer 200 pfu functions per application figure 2 example symmetric layered pfu symmetric pfu implements amount hardware bit position inputs operand buses outputs result bus figure 3 format 32bit execute pfu instruction rs rt fields specify source operands registers rd field specifies destination register lpnum number indicating requested logical pfu function expfu rs rt rd lpnum information software sophisticated enough determine beneficial insert expfu instructions eg usually bad idea insert two expfu instructions within single loop hardware contains single pfu resource beauty approach lies fact pfu add extra process state would need save context switch reserving lpnum zero represent unprogrammed pfu hardware 4 clear pnum register exception system call guaranteed force reprogramming pfu next use thus similar handling tlbs virtual caches without process id tags cost context switch include penalty pfus reprogrammed context switch latency expfu exception handler depends density programming memory hardware resources allocated pfu programming practice pfu programming memory sparsely populated typically less 15 bits asserted scheme relies hardware reset mechanism deassert pfu memory bits programs asserted memory locations would significantly reduce overall latency program pfu even use optimization still range programming options widely different hardware cycle count costs simple solution pfu programming might use implementationspecific loadstore instructions privileged routine eg alpha pal routine 11 sequentially load pfu programming memory higher performance solution might rely dedicated programming hardware combination high bandwidth path memory example need program 20 pfu memory bits expfu exception handler latency pal approach could high 600 cycles highperformance solution could bring latency 100 cycles compilation techniques despite fact pfu optimized particular boolean function pfu improve overall application performance evaluating several boolean functions low hardware complexity single cycle functions included instructions base instruction set provide significant performance gain across wide variety applications section 41 briefly presents structure prisc1 compilation hardware synthesis system extracts applicationspecific functions creates expfu instructions section 42 describes key analysis step system keeps compile time reasonable even though aggressively search groups instructions implement pfu section 43 presents current routines extracting expfu instructions section 44 discusses additional techniques improve system effectiveness 41 software architecture figure 4 shows overall structure prisc1 compilation sys tem left side figure similar highlevel language compilation system application hll parsed opti mized translated target machine instructions instructions assembled scheduled produce binary executable compilation environment uses profile information performance analysis tools pixie 27 improve results optimization instruction scheduling passes unlike conventional compilers however prisc1 compiler inserts step code generation called hardware extraction 4 alternatively operating system could selectively clear bit system calls use pfu resources identifies sets sequential instructions could potentially implement pfu instruction identified set mapped boolean operations entire group boolean operations given hardware synthesis package logic synthesis routines take input combinational function output netlist luts step logic minimization algorithms reduce number luts interconnect resources used input function finally placement routing routine run determine lut netlist fits resources offered physical pfu result placeandroute step fed back hardware extraction routines compiler automatically reduce input function requirements exceed physical pfu resources 5 produced appropriate hardware software images images linked together straightforward manner hardware images pfu programming information simply occupy part data segment resulting aout razdan 22 describes scheme maintaining binary compatibility across family prisc machines 5 detailed discussion algorithms used logic synthesis lut minimization lut placementandroute beyond scope paper briefly augmented standard algorithms 8930 task pfu synthesis general standard algorithms worstcase performance behavior exponential since extracted functions combinational quite small existing algo rithms augmented simplifications quickly synthesize input functions figure 4 major passes prisc1 compilation system hardware extraction routine sends sequences instructions hardware synthesis system generates corresponding pfu programming image synthesis system also indicates extraction routine whether resulting image larger physical pfu frontend processing localglobal optimization application code hll performance analysis information hardware extraction hardware synthesis system pfu model instruction scheduling instruction sequences software image linker aout hardware image code generation instructions machine hardware extraction uses profile information determine instructions executed often enough justify expense programming pfu actuality routine require profile information correct operation without profile information aggressive compiletime optimizations hardware extraction routine simply conservative selection optimizations 42 functionwidth analysis even modifications hardware synthesis routines still relatively expensive check instruction sequence fit physical pfu resources consequently developed analysis step called functionwidth analysis quickly separates instructions two classes may benefit pfu conversion definitely analysis step based observation pfu less efficient custom functional unit ie pfu unable evaluate dense boolean function fast custom functional unit since density boolean function related number literals input variables function quickly eliminate instruction whose boolean function requires large number input literals example bitwise requires two input literals per output bit thus ideal candidate implementation pfu similarly bytewide add requires 16 input literals mostsig nificant output bit thus another excellent candidate wordwide 32bitwide add hand good candidate implementation pfu even though bytewide add fullword add software costs vastly different hardware costs routine functionwidth analysis performs iterative algorithm similar used dataflow calculations 2 algorithm uses ternary algebra goes follows output variable unmarked instruction initialized x every bit position combination forward backward traversals made control flow graph reduce number bits forward traversals evaluate instruction check see evaluation changes output bit vector example unsigned byte load zeros lower 8 bits result backward traversals indicate unnecessary bit calculations example variable stored memory using byte store instruction variable used elsewhere instruction generated store input need generate lowest 8 bits informa tion algorithm ends bits change iteration given bit values variables application heuristically calculate hardware complexity individual instructions mark every operation easily implemented pfu pfulogic candidate risc instruction set typically memory operations floatingpoint operations wide adds multiplies divides variablelength shifts marked pfulogic 43 hardware extraction compiler marked potential pfulogic instructions application ready select sequences instructions conversion expfu instructions though considered many different ways select instruction sequences current hardware extraction routine follows simple bottomup greedy approach basically approach starts pfu logic instruction walks backward flow control control flow graph far possible backward walk terminates next instruction pfulogic instruction inclusion next instruction would produce function requiring two source operands one result corresponding boolean function maximal 6 instruction sequence fit within pfu resources extraction routine simply prunes instruction time top beginning instruction sequence first example operation extraction routine figure 5 illustrates two sample code sequences extracted automatically espresso benchmark 28 example simply sequence datadependent pfulogic instructions pfu evaluate single cycle code sequences mips r2000 instructions 18 sequence would require multiple instructions thus multiple cycles execute reference results section refer optimization pfuexpression optimization slightly less obvious type data flow optimization involves conversion table lookups referred pfutablelookup table lookups used instance logic expressions become complex inefficient evaluate directly processors instruction set extraction algorithm recognize constant array data structure represents truth table minimize table represent functional form evaluated efficiently pfu 7 illustration figure 6 shows truth table mips r2000 code pfu logic required evaluation ternary nand gate mips r2000 instruction set requires least four instructions evaluate twoinput ternary gate table lookup techniques figure shows however pfu easily evaluate ternary gate single cycle fact single 4input lut evaluate ternary 2input gate razdan 22 describes number example pfutablelookup optimizations addition simple sequences datadependent pfulogic instructions hardware extraction routine also recognizes opportunities optimize control flow application one 6 simple bottomup greedy algorithm attempt increase size instruction sequence rearranging order instructions obvious next step would integrate hardware extraction routine instruction scheduling routines 7 course type programmerapplied optimization life would much easier undo optimization apply section 44 discusses issues related topic figure 5 examples pfuexpression optimization pfu evaluate either sequences boolean instructions single cycle rs rt rd rs 0x0 rd opportunity pfupredication optimization transforms ifthenelsestructured portion control flow graph cfg set boolean equations effect optimization provides support limited form predicated execution see mahlke et al 21 information hardware software support predicated execution apply optimization candidate portion cfg must adhere following charac teristics must one one entry point portion cfg must one one exit point selected portion every block excluding entry exit block must contain pfulogic instructions selected portion cannot contain backward cfg edges ie loops met constraints process conversion proceeds three basic steps predicate assignment boolean transfor mation boolean minimization assignment predicates basic blocks well understood problem 3 calculated basic block predicates compiler transforms individual pfulogic instructions basic block include effects predicate given basic block predicate p assignment form op pfu logic operations boolean transformational rule expressed cstyle logical variables z old z new values output variable assignment immediately assignment respec tively n function takes boolean bit generates nbit vector containing n copies bit transformation execute operations independent actual control flow operations asserted predicate affect value result figure 7 illustrates result pfupredica tion optimization translates example code segment set boolean equations obvious benefit pfupredication optimization reduces execution time portion cfg single cycle another important benefit optimization eliminates conditional branches instruction stream conditional branches major impediment higher performance instruction scheduling unfortunately ifthenelse structures use nonpfulogic instructions multiple exit points cannot benefit pfupredication optimization even able use pfus another way also beneficial reducing execution time branch impediments code motion new technique called pfujump optimization attempts convert set ifthenelse statements switch statement optimization based observation significant portion programs branches branch short distance 14 thus branch thought sparse boolean functiona pfu evaluate switch condition generate appropriate target address order use pfujump optimization subset cfg must one one start basic block contain pfu logic instructions conditional expressions contain backward edges loops figure 8 shows example pfu jump optimization massivecounts routine espresso figure example pfutablelookup optimization truth table evaluates ternary nand gate 00 illegal state 01 logic zero 10 logic one 11 logic x mips r2000 code base address fullydecoded table truth table r2000 code pfu logic orr1 b r1 addr1 r1 example c code c b else c else c w else figure 7 example pfupredication optimization pfu output bits n shown tied logic 0 boolean pfu equations benchmark since code uses load store instructions non pfulogig instructions incrementing array locations bodies cannot use pfupredicate optimization conditional evaluation however requires pfulogic instructions thus replace three conditional branches single dynamic jump whose target address generated expfu instruction 8 since 2 3 different possible execution paths code figure 8 compiler optimizes 8 different target instruction sequences figure 8 also shows possible negative ramifications pfu jump optimization first significant increase code size increase may degrade instruction cache performance second technique forces premature evaluation conditional expressions cfg graph premature evaluation degrade performance cfgs shortest path executed highest probability though tempered fast evaluation switch condition pfu use branch probability data determine pfujump optimization mostlikely improve performance last significant restriction use pfu optimize control flow neither previous two techniques contain loop however optimizations interact well loop unrolling techniques 14 razdan 22 describes extend simple loop unrolling algorithm take advantage pfu resource called pfuloop optimization 44 optimization opportunities effectiveness pfu optimizations described previous subsection limited compilers ability determine precise functionality set instructions example function implemented truthtable lookup easily converted expfu instruction compiler able identify programmer applied optimization similarly number character manipulation stringtonumber conversion routines c runtime library could definitely benefit pfu resource however handtuning routines individual instruc 8 actually generate target address expfu instruction requires system function also linktime optimization cannot know final target addresses time tion set architectures made difficult reconstruct automatically logical intent general found possible structure wide variety applications achieve dramatic increases performance pfu resource 23 performance modeling results complete analysis prisc1 approach would involve detailed design pfuaugmented datapath development full compilationsynthesis system described section 41 investing heavily two activities constructed proofofconcept system gave us rough first estimate potential performance benefit prisc1 computer section 51 describes performance modeling environment section 52 presents results simulation study 51 performance model base proofofconcept study mythical 200mhz mips r2000 datapath augmented single prisc1 pfu datapath microarchitecture pfu design match descriptions given section 3 particular pfu symmet ric layered pfu designed meet requirements 200mhz cycle time ie 1994 technology since real hardware need develop complete compilation environment current software system contains implementations hardware extraction function width analysis algorithms described section 4 unlike section 41 description ideal compilation system input current routines mips object file output change cycle count object file basic block using object file input limit effectiveness extraction routines due lack complete type information example extraction routines use pfu eliminate need temporary registers expression evaluation temporary registers spilled main memory due register congestion original object file current algorithms cannot optimize awayresulting pessimistic performance results similarly lack type information usage enumerated type greatly limits effectiveness functionwidth analysis step thus limits number candidate pfulogic operations finally keep duplicating existing compiler functionality current software perform compiletime optimizations procedure inlining instruction sched uling compiletime optimizations could increase applicability various pfu transformations described section 41 integrate analysis extraction system routines hardware synthesis since real hardware perform hardware synthesis except lut placement routing determine extracted function fit physical pfu resources system implements following simple rule maximum depth gate level network less 6 levels pfu function allowed replace software code estimate pfu programmability lead optimistic results 5level networks could fit pfu resources pessimistic results 6 7level networks could fit physical pfu generated performance numbers next subsection combining basic block cycle counts compilation system basic block execution counts pixie profiling tool 27 like performance modeling strategies particular strategy several shortcomings since performance numbers based basic block profile trace impossible us know often really need program pfu currently though software system adds single expfu instruction per figure 8 example pfujump optimization espresso benchmark register t1 temporary register r0 contains integer value 0 example c code val 1 a0 val val code pfu optimization expfu t1valr0pfnum jr t1 loop loops without procedure calls thus easily assume worstcase scenario performance results specifi cally assume pfu takes 500 cycles program must reprogram pfu every time enter enclosing loop words assume pfu never programmed correctly enter loop containing expfu instruction proofofconcept system models cpu performance memory system penalties ignored similarly profile data application execution onlyoperating system issues performance ignored previous limitations software performance modeling one view results lower bound potential decrease application cpu cycles 52 performance results since one original goals develop approach applicable wide variety applications selected benchmark suite 28 first cut set diverse applications performed experiments decstation 5000240 using mips c compiler v210 benchmark table 1 lists number times invoked hardware extraction optimizations software system would apply individual optimization profile information indicated optimization would increase application performance least 01 compilationsynthesis time pfu optimizations typically measured singledigit minutes table 2 lists performance gain obtained applications calculate performance gain dividing number cycles taken pfu optimization number taken pfu optimization benchmarks shown tables 1 2 compress cps eqntott eqn espresso exp gcc gcc li li sc sc system found many instances pfuexpression pfu jump optimizations four six benchmarks relatively sparse number pfu optimization instances found low performance improvement li due large number short procedure calls interpreter loop table 2 shows eqntott exhibits excellent speedup even though static pfu optimization instances significant speedup due single pfu optimization cmppt routine routine accounts 85 applications cycles cycle count decreases routine greatly reduce overall cycle count basic data type cmppt 16bit integer seen 213 improvement performance changing data type short 16bit integer char 8bit integer pfutablelookup optimization never invoked benchmarks constant arrays declared constant application source code unfortunately modifying application source code constant qualifiers improve situation mips c compiler retain readonly nature constant information object file finally noted number pfus generated current system less 200 functions per application even approach expfu instruction format limit 2047 logicalpfu numbers specint92 benchmarks performance gain single pfu seems significant comparison generalpurpose architectural alternatives example consider addition onchip cache memory many todays commercial microprocessors contain least 8 kilobytes onchip instruction data cache 12 doubling size instruction cache kilobytes decreases average instruction cache miss rate average 2 specint92 benchmarks fairly optimistic conditions ie cpi execution equal 10 25 cycle miss penalty doubling instruction cache provides average performance improvement approximately 15 hardware cost eight times pfu 9 6 conclusions future work paper described novel microarchitecture compila tionsynthesis system automatically exploits hardwarepro grammable resources improve performance generalpurpose applications paper also presented encouraging results proofofconcept experiment shown respectable performance gains 22 specint92 benchmark suite modest hardware investment single combinational pfu based encouraging results begun port extraction routines generalpurpose com piler future hope develop detailed hardware model prisc1 datapath aggressive compilation environment able explore impact techniques superscalar processors pfu optimizations often reduce register pressure eliminating temporary variables increase size basic blocks eliminate conditional branches predication side effects potential improve benefit superscalar design furthermore foresee excellent opportunities synergistic interactions hardware extraction algorithms existing global instruction scheduling algorithms acknowledgments research assistance four individuals invalu able would like thank bill grundman insightful discussions custom cmos implementation techniques ramification techniques pfu microarchitecture design also would like thank mark firstenberg ed mclellan 9 program like eqntott get large benefit addition pfu nearly benefit increasing instruction cache end spec trum program like gcc gets large benefit doubling instruction cache currently small benefit pfu still case found benefits fairly equivalent added 1kb instruction cache optimization cps eqn exp gcc li sc pfuexpression 9 0 48 13 4 12 pfupredication table 1 static pfu optimization instances specint92 cps eqn exp gcc li sc table 2 cycle count speedup prisc1 microarchitecture single pfu resource speedup application arithmetic average defined spec data sets application detailed information provided microarchitectures two recent high performance vax alpha architecture implementations finally steven morris suggested pal approach programming pfu digital equipment corporation provided funding rahul razdans graduate work mike smith funded part nsf young investigator award r heuristic synthesis microprogrammed computer architecture conversion control dependence data dependence splash 2 processor applications processor reconfiguration instructionset metamorphosis introduction programmable active memories programmable active memories performance assessment mis multiplelevel logic optimization system digital equipment corp using computer design computer instruction sets computer architecture quantitative approach viewing instruction set design optimization problem automatic design computer instruction sets beyond superscalar using fpgas mips risc architecture field programmable accelerator compiledcode applications techniques program execution writable control memory effective compiler support predicated execution using hyperblock prisc programmable reduced instruction set computers prisc software acceleration techniques dynamic problemoriented redefinition computer architecture via microprogram ming hardware speedups long integer multiplication fast implementation rsa cryptography tracing pixie standard performance evaluation corporation spec news letter vertical migration performance enhancement layered hardwarefirmwaresoftware systems programmable gate array book tr compilers principles techniques tools mips risc architecture computer architecture quantitative approach introduction programmable active memories hardware speedups long integer multiplication viewing instruction set design optimization problem fieldprogrammable gate arrays effective compiler support predicated execution using hyperblock conversion control dependence data dependence highlevel vlsi synthesis algorithmic registertransfer level synthesis processor reconfiguration instructionset metamorphosis prisc software acceleration techniques programmable active memories using computer design computer instruction sets ctr daniel benyamin william h mangionesmith function unit specialization code analysis proceedings 1999 ieeeacm international conference computeraided design p257260 november 0711 1999 san jose california united states maya b gokhale janice stone edson gomersall cosynthesis hybrid riscfpga architecture journal vlsi signal processing systems v24 n23 p165180 mar 2000 cesare alippi william fornaciari laura pozzi mariagiovanna sami dagbased design approach reconfigurable vliw processors proceedings conference design automation test europe p57es january 1999 munich germany mihai sima sorin cotofana stamatis vassiliadis jos j van eijndhoven kees vissers reconfigurable functional unit trimediacpu64 case study embedded processor design challenges systems architectures modeling simulationsamos springerverlag new york inc new york ny 2002 stephan wong stamatis vassiliadis sorin cotofana microcoded reconfigurable embedded processors current developments embedded processor design challenges systems architectures modeling simulationsamos springerverlag new york inc new york ny 2002 jeffrey jacob paul chow memory interfacing instruction specification reconfigurable processors proceedings 1999 acmsigda seventh international symposium field programmable gate arrays p145154 february 2123 1999 monterey california united states andrea lodi mario toma fabio campi pipelined configurable gate array embedded processors proceedings acmsigda eleventh international symposium field programmable gate arrays february 2325 2003 monterey california usa ricardo e gonzalez xtensa configurable extensible processor ieee micro v20 n2 p6070 march 2000 francisco barat rudy lauwereins geert deconinck reconfigurable instruction set processors hardwaresoftware perspective ieee transactions software engineering v28 n9 p847862 september 2002 jeffrey arnold architecture development flow s5 software configurable processor journal vlsi signal processing systems v47 n1 p314 april 2007 nathan clark hongtao zhong wilkin tang scott mahlke automatic design application specific instruction set extensions dataflow graph exploration international journal parallel programming v31 n6 p429449 december michael dales managing reconfigurable processor general purpose workstation environment proceedings conference design automation test europe p10980 march 0307 sandra j weber joann paul donald e thomas coram combinational logic synthesis applied software partitions mapping novel memory device ieee transactions large scale integration vlsi systems v9 n6 p805812 1212001 rama sangireddy huesung kim arun k somani lowpower highperformance reconfigurable computing cache architectures ieee transactions computers v53 n10 p12741290 october 2004 timothy j callahan john r hauser john wawrzynek garp architecture c compiler computer v33 n4 p6269 april 2000 partha biswas nikil dutt paolo ienne laura pozzi automatic identification applicationspecific functional units architecturally visible storage proceedings conference design automation test europe proceedings march 0610 2006 munich germany alberto la rosa luciano lavagno claudio passerone hardwaresoftware design space exploration reconfigurable processor proceedings conference design automation test europe p10570 march 0307 xiaoyong chen douglas l maskell supporting multipleinput multipleoutput custom functions configurable processors journal systems architecture euromicro journal v53 n56 p263271 may 2007 partha biswas sudarshan banerjee nikil dutt laura pozzi paolo ienne isegen generation highquality instruction set extensions iterative improvement proceedings conference design automation test europe p12461251 march 0711 2005 partha biswas vinay choudhary kubilay atasu laura pozzi paolo ienne nikil dutt introduction local memory elements instruction set extensions proceedings 41st annual conference design automation june 0711 2004 san diego ca usa kubilay atasu laura pozzi paolo ienne automatic applicationspecific instructionset extensions microarchitectural constraints international journal parallel programming v31 n6 p411428 december maya gokhale jan frigo kevin mccabe james theiler christophe wolinski dominique lavenier experience hybrid processor kmeans clustering journal supercomputing v26 n2 p131148 september john regehr usit duongsaa deriving abstract transfer functions analyzing embedded software acm sigplan notices v41 n7 july 2006 nahri moreano guido araujo zhining huang sharad malik datapath merging interconnection sharing reconfigurable architectures proceedings 15th international symposium system synthesis october 0204 2002 kyoto japan mitsuru tomono masaki nakanishi katsumasa watanabe shigeru yamashita eventoriented computing reconfigurable platform proceedings 2005 conference asia south pacific design automation january 1821 2005 shanghai china hamid noori farhad mehdipour kazuaki murakami koji inoue maziar goudarzi interactive presentation generating executing multiexit custom instructions adaptive extensible processor proceedings conference design automation test europe april 1620 2007 nice france ruby b lee michael smith guest editors introduction media processing new design target ieee micro v16 n4 p69 august 1996 alberto la rosa luciano lavagno claudio passerone software development tool chain reconfigurable processor proceedings 2001 international conference compilers architecture synthesis embedded systems november 1617 2001 atlanta georgia usa alberto la rosa claudio passerone francesco gregoretti luciano lavagno implementation umts turbodecoder dynamically reconfigurable platform proceedings conference design automation test europe p21218 february 1620 2004 kubilay atasu laura pozzi paolo ienne automatic applicationspecific instructionset extensions microarchitectural constraints proceedings 40th conference design automation june 0206 2003 anaheim ca usa miljan vuleti laura pozzi paolo ienne virtual memory window applicationspecific reconfigurable coprocessors proceedings 41st annual conference design automation june 0711 2004 san diego ca usa zhining huang sharad malik nahri moreano guido araujo design dynamically reconfigurable datapath coprocessors acm transactions embedded computing systems tecs v3 n2 p361384 may 2004 sequences dependent instructions functions approach improving performance without ilp speculation acm sigarch computer architecture news v32 n2 p238 march 2004 arvind krishnaswamy rajiv gupta dynamic coalescing 16bit instructions acm transactions embedded computing systems tecs v4 n1 p337 february 2005 jorge e carrillo paul chow effect reconfigurable units superscalar processors proceedings 2001 acmsigda ninth international symposium field programmable gate arrays p141150 february 2001 monterey california united states john regehr alastair reid kirk webb eliminating stack overflow abstract interpretation acm transactions embedded computing systems tecs v4 n4 p751778 november 2005 seth copen goldstein herman schmit matthew moe mihai budiu srihari cadambi r reed taylor ronald laufer piperench coprocessor streaming multimedia acceleration acm sigarch computer architecture news v27 n2 p2839 may 1999 scott hauck thomas w fry matthew hosler jeffrey p kao chimaera reconfigurable functional unit ieee transactions large scale integration vlsi systems v12 n2 p206217 february 2004 anne bracy prashant prahlad amir roth dataflow minigraphs amplifying superscalar capacity bandwidth proceedings 37th annual ieeeacm international symposium microarchitecture p1829 december 0408 2004 portland oregon timothy sherwood brad calder automated design finite state machine predictors customized processors acm sigarch computer architecture news v29 n2 p8697 may 2001 exploring design space lutbased transparent accelerators proceedings 2005 international conference compilers architectures synthesis embedded systems september 2427 2005 san francisco california usa herman h schmit srihari cadambi matthew moe seth c goldstein pipeline reconfigurable fpgas journal vlsi signal processing systems v24 n23 p129146 mar 2000 nathan dean cooprider john david regehr offline compression onchip ram acm sigplan notices v42 n6 june 2007 zhi alex ye andreas moshovos scott hauck prithviraj banerjee chimaera highperformance architecture tightlycoupled reconfigurable functional unit acm sigarch computer architecture news v28 n2 p225235 may 2000 nathan clark manjunath kudlur hyunchul park scott mahlke krisztian flautner applicationspecific processing generalpurpose core via transparent instruction set customization proceedings 37th annual ieeeacm international symposium microarchitecture p3040 december 0408 2004 portland oregon nathan clark amir hormati scott mahlke sami yehia scalable subgraph mapping acyclic computation accelerators proceedings 2006 international conference compilers architecture synthesis embedded systems october 2225 2006 seoul korea bruce r childers jack w davidson custom wide counterflow pipelines highperformance embedded applications ieee transactions computers v53 n2 p141158 february 2004 mahim mishra timothy j callahan tiberiu chelcea girish venkataramani seth c goldstein mihai budiu tartan evaluating spatial computation whole program execution acm sigops operating systems review v40 n5 december 2006 nathan clark hongtao zhong scott mahlke processor acceleration automated instruction set customization proceedings 36th annual ieeeacm international symposium microarchitecture p129 december 0305 david brooks margaret martonosi valuebased clock gating operation packing dynamic strategies improving processor power performance acm transactions computer systems tocs v18 n2 p89126 may 2000 manfred glesner thomas hollstein leandro soares indrusiak peter zipf thilo pionteck mihail petrov heiko zimmer tudor murgan reconfigurable platforms ubiquitous computing proceedings 1st conference computing frontiers april 1416 2004 ischia italy john regehr alastair reid hoist system automatically deriving static analyzers embedded systems acm sigops operating systems review v38 n5 december 2004 seng lin shee sri parameswaran newton cheung novel architecture loop acceleration case study proceedings 3rd ieeeacmifip international conference hardwaresoftware codesign system synthesis september 1921 2005 jersey city nj usa nathan clark hongtao zhong scott mahlke automated custom instruction generation domainspecific processor acceleration ieee transactions computers v54 n10 p12581270 october 2005 mark oskin frederic chong timothy sherwood active pages computation model intelligent memory acm sigarch computer architecture news v26 n3 p192203 june 1998 alireza shoa shahram shirani runtime reconfigurable systems digital signal processing applications survey journal vlsi signal processing systems v39 n3 p213235 march 2005 alireza shoa shahram shirani runtime reconfigurable systems digital signal processing applications survey journal vlsi signal processing systems v39 n3 p213235 march 2005 mihai budiu girish venkataramani tiberiu chelcea seth copen goldstein spatial computation acm sigarch computer architecture news v32 n5 december 2004 philip garcia katherine compton michael schulte emily blem wenyin fu overview reconfigurable hardware embedded systems eurasip journal embedded systems v2006 n1 p1313 january 2006 katherine compton scott hauck reconfigurable computing survey systems software acm computing surveys csur v34 n2 p171210 june 2002
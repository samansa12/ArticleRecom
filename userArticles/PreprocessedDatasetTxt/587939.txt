lower bounds selecting median present reformulation 2non lower bound bent john proceedings 17th annual acm symposium theory computing 1985 pp 213216 number comparisons needed selecting median n elements reformulation uses weight function apart giving intuitive proof lower bound new formulation opens possibilities improving use new formulation show pairforming median finding algorithm ie median finding algorithm starts comparing lfloor n2rfloor disjoint pairs elements must perform worst case least 201 n comparisons provides strong evidence selecting median requires least cnon comparisons c 2 b introduction sorting selection problems received extensive attention computer scientists mathematicians long time comparison based algorithms solving problems work performing pairwise comparisons elements relative order elements known case ith largest element among n input elements found case selection sorting comparison based computational model quite well understood deterministic algorithm modeled decision tree internal nodes represent comparison two elements every leaf represents result computation since must least many leaves decision tree possible reorderings n elements algorithms sort n elements use least dlog ne n log n n log e comparisons worst case logarithms paper base 2 logarithms best known sorting method called merge insertion knuth 9 due lester ford jr selmer johnson 7 sorts n elements using n log n 133n thus gap upper lower bounds narrow error second order term bounded 011n problem nding median special case selecting ith largest ordered set n elements although much eort put nding exact number required comparisons still annoying gap best upper lower bounds currently known knowing sort could select median rst sorting selecting middlemost element quite evident could better much better question received somewhat surprising answer blum et al 3 showed 1973 determine median linear time using 543n comparisons result improved upon 1976 schnhage paterson pippinger 13 presented algorithm uses 3n school computer science raymond beverly sackler faculty exact sciences tel aviv university tel aviv 69978 israel email doritcheckpointcom zwickposttauacil department numerical analysis computing science royal institute technology 100 44 stockholm sweden email fjohanhstaffanugnadakthse dor j h astad ulfberg u zwick main invention use factories massproduce certain partial orders easily merged remained best algorithm almost 20 years dor zwick 5 pushed number comparisons little bit 295n adding green factories recycle debris merging process used algorithm 13 rst nontrivial lower bound problem also presented 1973 blum et al 3 using adversary argument 15n lower bound subsequently improved 175n pratt yao 12 1973 yap 14 later munro poblete 10 improved 38 43 no1 respectively proofs last two bounds long complicated 1979 fussenegger gabow 8 proved 15n lower bound median using new proof technique bent john 2 used basic ideas gave 1985 short proof improved lower bound 2n currently best available thus uncertainty coecient n larger nding median sorting even though linear term second order term case sorting since methods based proof bent john let us describe detail given decision tree comparison based algorithm invented method prune yields collection pruned trees lower bounds number pruned trees number leaves obtained nal argument saying leaves pruned trees almost disjoint gives lower bound size decision tree section 2 reformulate proof bent john assigning weights node decision tree weight node v corresponds total number leaves subtrees root v pruned trees v occurs proof bent john weight root approximately 2 2n show every node v decision tree child whose weight least half weight v weights leaves small proof formulated way becomes transparent one easily study individual comparisons rule bad algorithms point view many problems nding maximal minimal element ordered set nding maximal minimal element ordered set optimal algorithms start making bn2c pairwise comparisons singleton elements refer algorithms start way pair forming discussed whether optimal pairforming algorithms partial orders particular question posed open problem aigner 1 examples found chen 4 showing pairforming algorithms always optimal interesting note algorithms 5 13 pairforming still open problem whether optimal pairforming algorithms nding median section 3 use new approach prove pairforming algorithm uses least 201227n comparisons nd median dor zwick 6 recently able extend ideas described obtain 2n lower bound tiny 0 number comparisons performed worst case median selection algorithm lower bounds selecting median 3 2 bent john revisited bent john 2 proved 2n comparisons required selecting median result fact general provides lower bound number comparisons required selecting ith largest element 1 n concentrate median selection although results like bent john extended general although proof given bent john relatively short simple present reformulation two reasons rst proof gets transparent second formulation makes easier study eect individual comparisons theorem 21 bent john 2 finding median requires 2n comparisons proof deterministic algorithm nding median represented decision tree internal node v labeled comparison b two children node v ab v ab represent outcomes b b respectively assume decision trees contain redundant comparisions elements whose relative order already established consider universe u containing n elements every node v subset c u make following denitions every comparison b v b 2 c outcome b every comparison b v b 2 c outcome b proceed proof selecting median requires 2n parisons present proof somewhat weaker result assume u contains show selecting two middlemost elements requires comparisons proof case slightly simpler yet demonstrates main ideas used proof theorem dene weight function nodes weight function satises following three properties weight root 2 2non ii internal node v child whose weight least half weight v iii weight leaf small every node v decision tree keep track subsets size may contain largest elements respect comparisons already made let av contain sets called upper half compatible v assigned weights estimate far solution algorithm assuming elements largest weight every 2 av dened weight node v dened superscript 1 w 1 used shall shortly dene second weight function w 2 b 4 dor j h astad ulfberg u zwick case w 1 2 b 2 1 2 b 2 2 2 table weight set 2 av children node v relative weight v root r subsets size u upper half compatible r also 2 ar weight 2 2m nd promised 2m consider weight w 1 set 2 av node v labeled comparison b weights vs children depends elements b belongs minimal maximal four possible cases considered table 21 weights given relative weight w 1 v zero indicates longer compatible child thus contribute weight weight w 1 vab example 1 w 1 otherwise seen v always least one child weight least half weight v furthermore one four cases w 1 leaf v decision tree corresponds state algorithm two middlemost elements found therefore one set left av since identied minimum element maximum element get w 1 4 follow path root tree repeatedly descend child largest weight eventually reach leaf performed least 2n prove selecting median also requires least 2n isons make median well dened assume 1 problem arises argument weights leaves selection median two middlemost elements considered necessarily small enough possible know median without knowing relations elements contains 1 elements remedied follows node v algorithm close determining minimum element essentially force determine largest element instead done moving element 0 creating set g set lower half compatible v median maximum element b suitable choice 0 max v max v b set b lower half compatible v may contain smallest elements u keep track bs multiset bv root r let ar contain subsets size u let br empty exchange bs algorithm proceeds lower bounds selecting median 5 case 2 2 table weight set b 2 bv children node v relative weight v weight set b dened weight b estimates far algorithm solution assuming elements b smallest elements weight node v dened beginning algorithm upper part decision tree weight node still sum weights therefore dene av bv rest exactly node v except root simply copy av bv parent node remove sets upper lower half compatible v respectively ensure weight every leaf small following 2 av ne select element 0 2 min v compared fewest number elements remove set av add set bv note root jmin r quantity decreases one comparison leaf reached leaf v median known thus av empty lemma 22 let av bv dened rules described every internal node v labeled b child least half weight v ie wv ab wv2 wv ab wv2 proof table 21 gives weights set 2 av vs children relative weight v similarly table 22 gives weights set b 2 bv vs children relative weight w 2 v v b v w 1 v b every 2 av b 2 bv remains checked weight decrease lower half compatible set b replaces upper half compatible set covered lemma 23 lemma 23 removed av b added place bv fewer 4n comparisons performed path root v proof set 2 av replaced set ne element 0 case element min v compared fewest number elements 0 compared least 2 n elements get element min v compared 6 dor j h astad ulfberg u zwick least 2 n elements least 4n comparisons performed path root v contradiction get therefore 0 compared fewer 2 n elements thus jmax v bj jmax v n consequence get 4 aj thus 2 4 required know weight root large weight decrease fast remains shown weights leaves relatively small established following lemma lemma 24 leaf v median known wv 2m2 4 proof clearly sets compatible leaf set containing largest elements set b containing smallest elements since get w 2 since exactly elements removed b obtain corresponding copies b bv let comparison tree corresponds median nding algorithm height least 4n done otherwise starting root repeatedly descending child whose weight least half weight parent trace path whose length least 2n theorem 21 follows let us see current formalism gives room improvement exist original proof 2n lower bound obtained showing node v decision tree corresponds median nding algorithm child whose weight least half weight v consider nodes v along path obtained starting root repeatedly descending child larger weight leaf reached could show suciently many nodes path weights strictly larger half weights parents would obtain improved lower bound median selection wv length path therefore depth least 2n 3 improved lower bound pairforming algorithms let v node comparison tree element x singleton v compared v element two elements x form pair v elements x compared v neither compared element pairforming algorithm algorithm starts constructing concentrating comparisons involve elements part pairs obtain better lower bound pairforming algorithms theorem 31 pairforming algorithm nding median must perform worst case least 200691n proof easy see comparison involving two singletons delayed one compared second time therefore restrict attention comparison trees partial order corresponding node contains two pairs allowing one pair enough algorithms allowed construct two pairs fa bg fa compare element fa bg element fa g focus attention nodes decision tree element pair compared second time number nonsingletons 1 v node number nonsingletons lower bounds selecting median 7 r r r r r r r r fig 31 six possible ways b c may divided note c necessarily singleton element may part larger partial order 1 bv empty thus consider table 22 rest section recall av denotes collection subsets u size upper half compatible v hl u subsets u arbitrary size let ag let whl v contribution sets ahl v weight v ie brevity write v fh1 h r gfl1 l g v w v w fh1 h r gfl1 l g v proceeding describe intuition lies behind rest proof consider table 21 last section node v decision tree two cases 2 b 2 2 equally likely precisely contributions w ab v w ba v two cases total weight v equal must least one child v whose weight greater half weight v diculty improving lower bound bent john lies therefore nodes contributions two cases 2 b 2 2 almost equal fact easily seen looking original proof given 2 suppose v node element pair fa bg compared arbitrary element c number nonsingletons v assume without loss generality b weights set 2 av vs children depend elements b c belongs whether c minimal maximal six possible ways dividing elements b c shown figure 31 weights set vs children relative weight w 1 v one six cases given table 31 table 31 similar table 21 previous section c playing role b one important dierence however b c 2 rst row table 31 weight v ac equal weight v weight halved may case rst row table 21 contribution w abc v case b c 2 weight v negligible must least one child v whose weight greater half weight v improved lower bound obtained showing contributions cases 2 b 2 2 roughly equal elements partial order singletons contribution case b c 2 non negligible larger number singletons partial order larger relative contribution weight w abc v weight wv v thus whenever 8 dor j h astad ulfberg u zwick case w 1 2 b 2 2 b 2 c 2 2 b 2 2 11 table weight set 2 av children node v relative weight v element pair b compared arbitrary element c element pair compared second time make small gain intuition made precise following lemma lemma 32 v node element pair b compared element c number singletons v least 2 p w ac v w ca v proof inequalities follow easily considering entries table 31 obtain second inequality example note wv ac w cab w ac v second inequality follows worth pointing table 31 lemma 32 need assume b use stronger condition b pair stronger condition crucial however sequel especially lemma 34 make use lemma 32 need bounds relative contributions dierent cases following lemma useful tool determining bounds lemma 33 let e bipartite graph let 1 2 minimal degree vertices v 1 v 2 respectively let 1 2 maximal degree vertices v 1 v 2 respectively assume positive weight function w dened vertices g wv 1 v r proof let denote two vertices connected edge e lower bounds selecting median 9 inequality follows exchanging roles v 1 v 2 using lemma 33 obtain following basic inequalities lemma 34 v node b pair number non singletons v then2 one inequalities relates weight w abc v weight w acb v obtained moving one elements pair b inequality lose factor 1 elements b joined together factor 2 introduced elements b separated factor 1is introduced proof present proof inequality w abc v 1 v proof inequalities almost identical construct bipartite graph e whose vertex sets v dene edge acb v singleton 2 1 suppose edge 62 min v elements extremal respect 1 extremal respect 2 note b 2 min v 2 get w 1 every set size number singletons least 1 get therefore minimal degrees vertices v 1 v 2 maximal degrees v 1 v 2 1 2 inequality w abc v 1 therefore follows lemma 33 using basic inequalities obtain lemma 35 v node b pair number non singletons 1 proof present proof rst inequality proof two inequalities similar using inequalities lemma 34 get rst inequality follows dor j h astad ulfberg u zwick ready show v node element pair compared second time v child whose weight greater half weight v combining lemma 32 lemma 35 get that2 wv ac wv consequence get coecient wv right hand side minimized two expressions whose maximum taken equal happens plugging value two expressions get easy check f 1 0 1 pairforming comparison comparison two singletons compared form pair pairtouching comparison comparison element pair compared second time pairforming algorithm number singletons decreased pairforming comparisons pairforming comparison decreases number singletons exactly two explained pairforming comparisons always delayed pairforming comparison immediately followed comparison touches pair fa bg pairforming comparison comparison touches pairs g consider path traced root repeatedly descending child larger weight consequence discussion get ith pairtouching comparison along path performed number nonsingletons partial order 4i follows therefore remark made end previous section depth comparison tree corresponding pairforming algorithm least log lower bounds selecting median 11 r r r r r r r r r r r r r c r r c r r c r r c r r c r r c r r c r fig 32 nine possible ways b c may divided case w 1 table weight set 2 av children node v relative weight v element pair b compared element pair c completes proof theorem 31 worst case proof obtained algorithm converts elements quartets quartet partial order obtained comparing elements contained two disjoint pairs proof analyzed cases element pair b compared arbitrary element c element c also part pair tighter analysis possible performing anaylsis improve theorem 31 theorem 36 pairforming algorithm nding median must perform worst case least 201227n proof consider comparisons element pair b compared element pair c nine possible ways dividing elements b c among depicted figure 32 may assume without loss generality element compared either c let v node comparison tree b c pairs one comparions c performed let 2 av weights set vs children relative weight w 1 v one nine cases given table 32 two possible comparisons c considered separately following equalities easily veried lemma 37 b c pairs v 12 dor j h astad ulfberg u zwick following inequalities analogous inequalities lemma 34 lemma 38 b c pairs v number nonsingletons v 1 then2 consider rst comparison c examining table 32 using equalities lemma 37 get wvacwvac w abcd v minimizing expression subject equalities lemma 37 inequalities lemma 38 fact weights nine cases sum wv amounts solving linear program solving linear program get seems intuitively clear comparison bad comparison algorithms point view adversary likely answer indeed solving corresponding linear program get wvad every 0 1 may disregard comparison consideration easy verify 1f 1 result get lower bound completes proof theorem 36 lower bounds selecting median 13 4 concluding remarks presented reformulation 2n lower bound bent john number comparisons needed selecting median n elements using new formulation obtained improved lower bound pairforming median nding algorithms mentioned dor zwick 6 recently extended ideas described obtained 2n lower bound general median nding algorithms tiny 0 believe lower bound pairforming algorithms obtained substantially improved improvement seems require however new ideas obtaining improved lower bound pairforming algorithms may important step towards obtaining lower bound general algorithms signicantly better lower bound bent john 2 paterson 11 conjectures number comparisons required selecting median log 43 2n 241n r producing posets finding median requires 2n comparisons time bounds selection partial order productions selecting median median selection requires 2 tournament problem counting approach lower bounds selection problems art computer programming lower bound determining median progress selection lower bounds computing ith largest element new lower bounds medians related problems tr ctr krzysztof c kiwiel floyd rivests select algorithm theoretical computer science v347 n12 p214238 november 2005
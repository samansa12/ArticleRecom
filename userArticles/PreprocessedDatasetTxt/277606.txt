concurrency control view notification algorithms collaborative replicated objects abstractthis paper describes algorithms implementing highlevel programming model synchronous distributed groupware applications model several application data objects may atomically updated objects automatically maintain consistency replicas using optimistic algorithm changes objects may optimistically pessimistically observed view objects taking consistent snapshots algorithms update propagation view notification based upon optimistic guess propagation principles adapted fast commit using primary copy replication techniques main contribution paper synthesis two algorithmic techniquesguess propagation primary copy replicationfor implementing framework easy program well suited needs groupware applications b introduction synchronous distributed groupware applications finding larger audiences increased interest popularity world wide web major browsers include loosely integrated groupware applications like chat whiteboards browser functionality extensible programmability java applets plugins activex additional groupware applications easily introduced large community potential users applications may vary simple collaborative form filling collaborative visualization applications group navigation tools synchronous collaborative applications built using either nonreplicated application architecture replicated application architecture nonreplicated architecture one instance application executes gui events multicast clients via systems shared x servers 1 replicated architecture user runs appli cation applications usually identical state gui shared synchronously mirroring changes state one copy others 6 13 research center hawthorne ny 10532 usa email fstrom banavar klm mjwgwatsonibmcom 2 department electrical engineering computer sci ence university michigan ann arbor mi usa email aprakashumichedu paper assume replicated architectures used generally potential provide better interactive responsiveness faulttolerance users join leave collaborative sessions however domain synchronous collaborative applications broader supported fully replicated application architecture example ffl applications may different guis even different functionality sharing replicated state ffl shared state may entire application state ffl application may engage several independent collaborations eg one financial planner another accountant collaboration may involve replication different subset application state order support development large variety applications clearly beneficial build general application development framework identified following requirements framework endusers perspective collaborative applications built using framework must highly responsive gui must responsive single user gui sites initiate updates response latency remote sites must minimal second collaborative applications must provide sufficient awareness ongoing collaborations perspective developer collaborative applications framework must applicationindependent highlevel must capable expressing wide variety collaborative appli cations second developer required proficient distributed communication proto cols thread synchronization contention complexities concurrent distributed programming implemented framework called decaf distributed extensible collaborative application framework meets requirements framework extends wellknown modelview controller paradigm objectbased application development 10 mvc paradigm used gui oriented systems smalltalk interviews 12 view objects attached model objects order track changes model objects views typically gui components eg graph win dow display state attached model objects contain actual application data controllers typically event handlers receive input events gui components response invoke operations read write state model objects updated model objects notify attached views change view may recompute based new values mvc paradigm several beneficial properties 1 modular separation application state components presentation components 2 ability incrementally track dependencies components support groupware applications decaf extends mvc paradigm indicated figure 1 first framework supplies generic collaborative model objects integers strings vectors etc application developers model objects replica relations model objects across applica tions replicated groupware applications easily built second provides atomicity guarantees updates model objects even multiple objects modified part update framework automatically atomically propagates updates replicas model objects attached views third writers choose whether views see updates model objects occur optimistic commit pessimistic fourth applications dynamically establish collaborations selected model objects local site model objects remote applications finally users may also code authorization monitors restrict access sensitive objects paper first introduce basic concepts decaf framework section 2 next describe distributed algorithms implement consistent update propagation section 3 view notification section 4 present comparison related work experience using decaf section 5 finally concluding remarks sec tion 6 2 decaf framework mentioned earlier decaf extends model viewcontroller paradigm 10 decaf model object classes supplied framework application programmer simply instantiates model objects replica update notifications updates reads replica model objects transaction view collaborative application a2 reads application framework figure 1 typical structure decaf applications shown horizontal line separates framework application figure 1 application programmer writes views controllers initiate transactions shown horizontal line figure 1 following subsec tions describe key concepts framework atomicity guarantees access model objects provided decaf infrastructure 21 model objects model objects hold application state model objects allow reading writing attaching views three kinds model objects 1 scalar model objects currently types integer real string 2 composite model objects support operations embed remove model objects called children may either lists linearly indexed sequences children tuples collections children indexed association model objects used track membership collaborations model objects join leave replica relationships model objects value association object set replica relationships bundled together application purpose replica relationship association object contains set model objects joined together sites object descriptions operations association objects relevant paper join leave model object joins leaves particular replica relationship described section 27 22 replica relationships replica relationship collection model ob jects usually spanning multiple applications required mirror one anothers value replica relationships symmetric transitive 23 controllers controller object responds enduser initiated actions typing keyboard clicking dragging mouse etc controller may initiate transactions update collaborative model ob jects controller may also perform external interactions end user 24 transactions transactions model objects executed invoking execute method transaction object application programmers may define transaction objects associated execute method actions need execute atomically respect updates users execute method may contain arbitrary code read write model objects within application changes model objects automatically propagated replicas execution transaction atomic ac tion behaves operations execute method propagate changed values replicas take place single instant time totally ordered respect times atomic actions system atomicity implemented optimistically decaf transactions may abort eg two transactions originated different sites transaction guessed read updated certain value object transaction one transactions abort aborted transactions reexecuted originating site effects aborted transactions invisible pessimistic views automatically undone seen optimistic views 25 view objects view object userdefined object dynamically attached one model objects view attached model object view object able track changes model object receiving update notifications calls update method view object attached composite model object receive notifications changes composite well children purpose view object compute function eg graphical rendering model objects attached view object receives update notification update method may take state snapshot reading model objects attached state snapshots guaranteed infrastructure atomic actions behaving instantaneous besides taking state snapshot update method may initiate new transactions perform arbitrary external teractions rendering display printing playing audio data etc update notification contains list ob jects objects changed value since last notification objects list may assumed changed value information allows view objects recompute function efficiently part large value changed example large composite objects changed update notification specify composite object changed also parts changed allow incremental recalculation 26 optimistic pessimistic views view objects either optimistic pessimistic optimistic pessimistic views differ protocols delivery update notifications optimistic view receive update notification soon possible attached model objects changed however state snapshot may inaccurate inconsistent messages arrived order transactions abort optimistic view ever takes incorrect snapshot infrastructure eventually execute superseding update notification therefore long system eventually quiesces final snapshot taken system quiesces correct optimistic view receive commit notification call commit method whenever recent update notification known correct committed state snapshots always correct always occur monotonic order optimistic view therefore trades accuracy risk wasted work exchange responsiveness pessimistic views receive update notifications transactions updating attached model objects committed view able see consistent values system makes two guarantees pessimistic view 1 never show uncommitted inconsistent values 2 show committed values monotonic order applied updates 27 collaboration establishment users may create replica relationships cause model objects join leave replica relationships dy namically order object one site join replica relationship involving object b another site following steps must occur ffl bs owner must create association object bas soc containing least one replica relationship joined b ffl bs owner must publicize right collaborate b creating external token called invitation including reference bassoc export somewhere owner access eg bulletin board ffl owner must import invitation use instantiate association object aassoc object aassoc must authorized reveal bassocs replica relationships ffl owner read aassoc discover existence replica relationship involving b wishes join issue join relationship since association objects also model objects views attached changes membership associations signalled exactly way changes values data objects 3 concurrency control section describes optimistic concurrency control algorithms propagating updates among model objects replica relationships transaction started originating site assigned unique virtual time execution v computed lamport time 11 including site identifier guarantee uniqueness transaction initiated transaction implementation object created originating site updates propagated remote replicas transaction implementation objects created sites transaction implementation object site contains v transaction references model objects updated transaction site additional state information model object holds ffl value history value history set pairs values v sorted v value latest v called current value ffl replication graph history similarly indexed set replication graphs replication graph connected multigraph whose nodes references model objects whose multi edges replication relations built users includes current model object model objects directly indirectly required replicas current model object result replication relations since replication graphs change infrequently practice history frequently contain single graph histories garbagecollected transactions com mit committal makes old values longer needed view snapshots rollback abort thus discarded function maps replication graphs selected node graph node called primary copy site node called primary site adapting replication technique used chu hellerstein 4 others correctness concurrency control algorithm based upon fact order reads updates replicas guaranteed match order corresponding reads updates primary copy whenever originating site transaction primary site objects read written transac tion transaction executes optimistically guessing reads updates performed originating site execute way reexecuted primary sites guesses eventually confirmed transaction said commit effects transaction undone sites transaction retried originating site 31 concurrency control scalar model objects transaction first executed assigned v call executes transaction reads andor modifies one model objects originating site model object records operation transaction implementation object model object read transaction implementation object records read r r defined v current value written blind writes writes objects read transaction r defined equal transaction object additionally records graph time g defined v replication graph last changed consider transaction given figure 2 originated site assigned v current values w x z 4 written v 80 3 written v 70 assume replication graphs initialized v shown figure end transaction execution transaction implementation object records following read object w w read object x x x z z transaction figure 2 example transaction execution update object update object z z observe update blind write since read transaction hence transaction implementation object next distributes modifications replicas model objects transaction requests primary copy reserve region time r writefree since replica graphs also change al beit slowly transaction must also reserve region time g free graph updates mentioned earlier originating site transaction executed optimistically guessing reads updates conflictfree primary copy specifically validity transaction depends upon following types guesses ffl read committed rc guesses model object value graph read transaction written committed transaction ffl read latest rl guesses value graph model object read transaction write another transaction occurred occur primary copy r g transactions guess implies primary site would read version object transaction executed pessimistically ffl conflict nc guesses model object value graph written transaction transaction reserved primary copy writefree region time containing transactions v guess implies primary site would invalidate previous reads confirming write confirm z confirmread commit commit confirm figure 3 example update propagation execution transaction takes place op timistically using strategies derived optimistic guess propagation principles defined strom yemini 15 applied number distributed systems eg optimistic call streaming 2 hope 5 however algorithm makes certain specializations reduce message traffic rc guesses originating site simply records v transaction wrote uncommitted value read originating site commit transaction transaction recorded v commits uncommitted transaction site list transactions site guessed commit maintained rl nc guesses checked site primary copy object rl guess checks value graph update occurred r g check succeeds creates writefree reservation interval conflicting write made future nc guess checks writefree reservation made interval including object read written message sent primary copy remote site message contains g primary copy object verifies rl guesses values graphs confirmation message sued confirming denying guess general approach hope confirmation message would broadcast sites decaf implementation confirmation sent originating site property decaf implementation originating site always knows totality sites affected transaction com mitabort time therefore originating site position wait confirmations arrive forward summary commit abort transaction whole sites avoids need primary copy communicate nonprimary sites avoids needs nonprimary remote sites aware guesses summary guess transaction virtual object modified send message relevant sites containing new value however sites primary site simply apply update appropriate primary site additionally performs rl nc guess checks sends confirmation message originating site originating site waits confirmations guesses remote primary sites guesses transaction confirmed originating site commits transaction sends commitmessage remote sites received update messages guess denied originating site aborts transaction sends abort message remote sites originating site reexecutes transaction site detects transaction v com mitted modified model objects site formed notification used schedule view notifications eventually garbagecollect histo ries site retains fact transaction committed future update messages arrive updates considered committed transaction aborted modified model objects informed value v purged history site retains fact transaction aborted future update messages arrive updates ignored let us examine algorithms would apply example shown figure 3 suppose four sites w x replicated sites 1 2 3 z replicated sites 2 3 4 suppose initiated site 2 suppose primary site w x 1 z 4 ignoring graph times graph updates assuming three current values read transaction committed hence rc guesses following messages sent site 2 transaction applied locally perform obvious optimization sending messages relevant sites 1 site 1 confirmread 2 sites 3 4 checks w writefree v range 80 100 rl guess check x write free v range 60 100 rl guess check reserves times writefree sends confirm site 2 simply applies updates z replica objects site 4 checks z writefree v range 40 100 rl guess check reserves times writefree also checks writing z v 100 conflict previously made read reservations nc guess checks checks succeed applies updates sends confirm site 2 responses confirma tions sends commit 100 sites involved 32 concurrency control composite model objects although concurrency control algorithm composite objects scalar objects desirable save space keeping separate replication graph object inside composite composite replica composite 0 00 see figure 4 wish avoid encoding inside object a103 replica objects 0 103 00 103 approach default object embedded within composite inherits replication graph root eg a103s replicas would sites replicas corresponding index 103 similarly a103 composite object embedded objects eg a103john12 would replicated sitesjohna johna figure 4 replicas composite model objects set indices root given object called path object a103john12 modified change path sent replicas 0 00 use path name 103john12 propagate update corresponding components 0 103john12 00 103john12 call technique indirect propagation updates contrast direct propagation technique discussed earlier object holds replication graph communicates directly replicas addition saving space indirect replication avoids problem direct replication small changes embedding structure could end changing large number objects example indirect replication used adding new replica 000 set fa 0 00 g would entail updating replication graph every object embedded within replicas similarly removing a103 would entail updating replication graph every object embedded within a103 321 adjustments support indirect propa gation two adjustments made ensure correctness concurrency control algorithm presense indirect propagation first relative order list items transaction v 100 may modify seen earlier transaction v 80 deleted a5 originating site thinks a103 may appear sites a102 concurrency control conflict simply consequence fact path names like 103john12 fragile overcome rather using actual list index path name propagation algorithm uses transaction v unique identifier eg a103 embedded v 40 40 used index several embeds performed v 40 distinguished subtime eg 401 408 composite object receiving indirect propagation message always propagate tree regardless order received structurechanging operations propagation determined using transaction earlier path changing update yet received propagation block earlier update received second adjustment guesses associated paths indirect object propagation updated model objects must make rc guesses ensure transactions created paths committed rl guesses straggling transactions removed component paths 322 indirect propagation possi ble indirect propagation default mode propagating value updates objects within composites however indirect propagation always possible consider configuration figure 5 case node c indirectly propagate changes c 0 node b cannot different set replicas rest tree therefore use direct replication objects b b 0 b 00 b figure 5 indirect propagation possible case 33 dynamic collaboration establish ment set replica relations objects remains relatively static transactions change values objects rather replication graphs replication graphs change users join leave collaborations direct propagation graphs embedded objects inside composites also change result deleting objects composites embedding elsewhere dynamic collaboration establishment transactions need especially fast must work correctly conjunction transactions already seen effects dynamic collaboration establishment algorithms described replication multigraphs timestamped transaction v changed negotiation primary copy node able map given multigraph identity primary site configuration primary copy always confirms rl guess graph hasnt changed well confirming whatever else asked check guards possibility originating site propagating wrong set sites asking wrong primary copy graph change hasnt seen yet primary copy always reserves graph changes region time previously confirmed transaction assumed changefree 4 view notification section describes algorithms implementing view notification semantics given section 25 transaction implementation object completes executing site decaf infrastructure initiates view notifications sent view objects attached model objects updated transaction view object attachments always lo cal ie views always attached model objects site thus view notification simply method call update method implemented view object update method contain arbitrary code takes state snapshot reading views attached model objects recomputes dis play infrastructure guarantees state snapshot implicitly consistent atomic action every view notification initiated snapshot object created internal decaf infrastructure snapshots associated particular user level view object managed internally view proxy object model object contains set view proxies corresponding views notifies upon receiving update commit since snapshot atomic action assigned virtual time snapshot assumed read model objects attached view v reads may optimistic hence described section 31 validity depends upon read values latest rl guess read values committed rc guess confirming rl guesses involves remote communication primary copies objects read snapshot rl rc confirmed snapshot said commit optimistic pessimistic views differ two spects first differ time view notifications scheduled optimistic notifications scheduled early possible ie soon model updated snapshot thus initiated whereas pessimistic notifications scheduled known snapshot valid ie view read consistent committed values second differ lossiness notifications pessimistic views notified losslessly every single update monotonic order updates whereas optimistic views notified latest update subsections 41 42 describe behaviors detail described section 25 view notifications incremental ie notification provides part attached model object state changed since last notification however sake simplicity algorithms presented section incorporate incrementality snapshot assumed read set attached model objects entirety furthermore notifications may bundled enhance performance ie single view notification may delivered multiple model objects updated single transaction 41 optimistic views figure 6 shows optimistic view v attached model objects b view proxy object v p represents v internally b committed current values ie values latest v v 100 80 repectively transaction runs v 110 updates notifies view proxy v p primary requirement optimistic views fast response consequently soon v p notified performs following 1 creates snapshot object assigns v equal greatest v current values attached model objects case 2 schedules view notification ie calls views update method figure view notification end snapshot snapshot object records attached model objects read order snapshot example com mit two guesses must confirmed ignore guesses related graph 1 rc guess update transaction 110 committed requires receiving commit message site originated transaction 2 rl guess v interval 80 110 update free b requires sending confirmread message bs primary copy waiting response eventually guesses confirmed snapshot commits commit notification sent v ie commit method called hand rc guess turns false view proxy reruns snapshot new example figure 6 rc guess denied result transaction v 110 aborting new snapshot run snapshot since greatest v current values attached model objects notice example optimistic view notifications necessarily monotonic v order case rl guess denied primary copy means requested interval update free thus straggler update yet arrive guessing site case straggler eventually arrive cause rerun view notification example figure 6 rl guess denied result straggler update b v 105 update v 105 trigger new view notification algorithm implements liveness rule optimistic views update notification followed either commit notification case invalid optimistic guess subsequent update new update notification optimistic view proxy maintains one uncommitted snapshot one latest given time new update arrives current snapshot committed obliged notify new update view due responsiveness requirement system may well discard old snapshot since way notify view commit dont expose v views result optimistic view gets commit notification system quiesces new updates initiated system existing updates committed 42 pessimistic views recall system makes two guarantees pessimistic view 1 never show uncommitted values 2 show committed values monotonic order applied updates pessimistic view proxy initiates snapshot every v one attached model objects receive committed update however nt schedule view notification snapshot snapshot commits snapshot committal depends 1 validity model object reads snap shots 2 whether preceding snapshots already committed due monotonicity requirement one snapshots commit view notified committed snapshot v sequence thus unlike optimistic proxy pessimistic proxy manages several uncommitted snapshots pessimistic view proxy thus contains list snapshot objects sorted v also contains field lastnotifiedvt v last update notification illustrate pessimistic view notification let us say view v example figure 6 pessimistic view suppose lastnotifiedvt 80 suppose snapshot v 100 yet uncommitted thus committed update v 100 yet notified transaction v 110 commits informs model object turn informs pessimistic view proxy v p v p creates snapshot object assigns records following guesses 1 snapshot committed guess sc guess preceding snapshot v 100 commit stems monotonicity requirement 2 rl guess v interval 100 committed updates also stems monotonicity requirement requires sending confirmread message primary copy waiting response 3 rl guess v interval 100 110 free committed updates b requires confirmread message eventually guesses made particular snapshot object confirmed commits confirm sc guess successor snapshot snapshot commits contiguous committed snapshots lastnotifiedvt notified lastnotifiedvt updated straggling committed update say b example may cause rl guess negated case straggling committed update notified proxy new snapshot created v 105 given additionally rl guess made succeeding snapshot v 110 guess 3 revised v interval 105 110 b algorithm implements consistency monotonicity requirements pessimistic views 51 related work decaf framework designed collaborative work among small possibly widely distributed collection users consistency responsiveness ease programming important objectives isis 3 provides programming primitives consistent replication although implementation strategies pessimistic interactive groupware systems different performance requirements usage characteristics databases leading different choices concurrency control algorithms first almost databases use pessimistic concurrency control gives much better throughput major goal databases interactive groupware systems hand pessimistic concurrency control strategies always suitable impact response times user actions ensuring interactive response time often important throughput second possibilities conflicts among transactions lower groupware systems people typically use social protocols avoid conflicts parallel work optimistic protocols based jeffersons time warp 8 originally designed distributed simulation environments successfully applied application areas well7 however one important characteristic distributed simulation usually urgency compute final result necessarily commit intermediate steps protocols primary purpose committing free space logs make system state accessible view cooperative work environment fast commit essential delay associated waiting single primary site per model object decaf typically considerably less time warp style global sweep system would oreste 9 implementation provides useful model programmers define highlevel operations specify commutativity masking lations one drawback highlevel operations multiple objects ways combining multiple highlevel operations transac tions get effect transactions one must combine normally thought multiple objects single objects define new singleoperand operations whose effects equivalent effects transaction one must explicitly specify interactions new operations operations also subtle difference correctness requirements decaf oreste difference results fact oreste considers quiescent state analysis consider read transactions eg snapshots coexist update transactions instance oreste model transaction changes objects color reasonably said commute transaction moves object container container b since example starting red object applying change blue move b yields blue object b regardless order operations ap plied viewers readonly transactions system state nonquiescent conditions taken account sites might see transition blue object others transition red object b finally oreste state cannot committed external viewer known straggler involves global sweep analogous jeffersons global virtual time algorithm system single group collaborating applications may severe problem worldwide web sites b c collaborating independently sites c e collaborating f collaborating etc preferable commit depend global state net work rather small number objects recent system coast 14 also attempts use optimistic execution transactions mvc paradigm supporting groupware applications key differences system following first coast supports optimistic views second concurrency algorithms used coast assume model objects application shared among participants furthermore optimistic algorithm implemented coast based variation algorithm discussed 52 status experience substantial implementation decaf framework completed java programming language framework currently supports scalar model objects transactions optimistic pessimistic views implementations objects use algorithms described paper several optimizations forthcoming including commit del egation faster commit snapshots incremental propagation currently implementing composite model objects several collaborative applications successfully built using current prototype implemen tation include several groupware applications allow insurance agent help clients understand insurance products via data visualization fill insurance forms multiuser chat program simple games preliminary experience easy write new applications modify existing programs use mvc programming para digm optimistic views useful due fast response also due low conflict rate typical use pessimistic views also useful viewers want track changes values model object 6 conclusions decaf frameworks major objectives ease programming responsiveness context systems collaborating applications ease programming achieved primarily hiding concerns distribution multi threading concurrency users programmers write high level using modelviewcontroller paradigm implementation transparently converts operations model objects operations distributed replicated model objects view notification algorithm automatically schedules view snapshots appropriate times also allows viewers respond efficiently small changes large ob jects model objects standard data types inte gers strings etc collections eg vectors provided part decaf infrastructure responsiveness results use optimism combined fast commit protocol primary copy algorithm transaction updates objects b viewer b 0 replica b sees commit soon primary site bs primary site notified originating site updates nonconflicting originating site notified b 0 site transaction com mitted small delay even pessimistic view users get even rapid response time using optimistic views time optimistic view later committed speed pessimistic view experience using decaf shown architecture algorithms well suited variety groupware applications acknowledgements gratefully acknowledge gary andersons input design framework also built several collaborative applications components top framework r xtv framework sharing x window clients remote synchronous collaboration optimistic parallelization communicating sequential processes pat stephen son exclusive writer approach updating replicated files distributed processing systems concurrency control groupware systems time warp mechanism database concurrency control virtual time algorithm distributed groupware applications cookbook using modelviewcontroller user interface paradigm smalltalk80 support building efficient collaborative applications using replicated objects jan schum mer synthesizing distributed parallel programs optimistic transformations tr ctr sumeer bhola mustaque ahamad 1k phase stamping continuous shared data extended abstract proceedings nineteenth annual acm symposium principles distributed computing p181190 july 1619 2000 portland oregon united states guruduth banavar sri doddapaneni kevan miller bodhi mukherjee rapidly building synchronous collaborative applications direct manipulation proceedings 1998 acm conference computer supported cooperative work p139148 november 1418 1998 seattle washington united states christian schuckmann jan schmmer peter seitz modeling collaboration using shared objects proceedings international acm siggroup conference supporting group work p189198 november 1417 1999 phoenix arizona united states james begole randall b smith craig struble clifford shaffer resource sharing replicated synchronous groupware ieeeacm transactions networking ton v9 n6 p833843 december 2001 wanlei zhou li wang weijia jia analysis update ordering distributed replication systems future generation computer systems v20 n4 p565590 may 2004
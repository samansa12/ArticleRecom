semantics constraint logic programs optimization many applications constraint logic programming clp languages require testing set constraints satisfiable also finding optimal solution satisfies unfortunately standard declarative semantics clp languages consider optimization constraint satisfaction give model theoretic semantics optimization simple extension standard semantics corresponding operational semantics may efficiently implemented b introduction one promising innovations recent programming language design amalgamation constraint programming logic programming 8 constraints provide powerful natural programming paradigm objects computation explicitly constructed rather implicitly defined using constraints applications constraint logic programming languages many diverse areas include electrical circuit analysis 18 synthesis diagnosis 6 options trading financial planning 13 applications traditional operations research problems cutting stock scheduling pure constraint logic programming languages provide testing constraint satisfaction however many applications desire optimal solution reason although standard semantics clp languages 8 include optimization operators existing clp languages provide ad hoc nonlogical optimization 3 languages optimization may obtained using metalevel facilities 7 address problem giving simple declarative semantics optimization corresponding operational semantics allows efficient implementation main contribution model theoretic operational semantics optimization clp languages simple extension usual semantics features operational semantics allow given corresponding declarative semantics current best optimum used prune search space allowing operational semantics find optimums subgoals ostensibly infinite derivations optimization subgoals selected global variables ground novel feature operational semantics optimization subgoals return constraints optimal value occurs range points give soundness completeness results operational semantics terms 3valued completion program translating optimization negation example major application clp languages constraint satisfaction problems csps requires constructing set constraints determining whether set satisfiable whether answer however csps contrary name often include optimization component must answer satisfy required constraints also best answer consider following clpr program determining values stock options adapted 13 call contract allow holder option buy stock exercise price x later date desired obviously later stock price greater exercise price call value stock price lower exercise price call worthless put contract allow holder sell exercise price total value call put must consider cost purchase contract interest cost purchase exercising option call values x v x call values x v put values x v x put values x v valuecall buy sell stockpricecostinterestrateexercisepricevalue call valuestockprice exerciseprice option value valueput buy sellstockpricecostinterestrateexercisepricevalue put valuestockprice exerciseprice option value program used answering many varied questions relating values stock options instance following query asks value combination selling call put option query1stockprice wealth answers constraint logic programs provide capability asking existential questions however many applications desire optimal solution obvious query program given nature problem ask conditions maximize wealth minimize loss would like able write query form min query1s w w w maxstock maxwealth read find values maxstock maxwealth variables w minimize expression w answers query query1s w returns answer constraint reason existing clp languages eg chip provide ad hoc nonlogical optimization languages optimization may obtained using metalevel facilities 7 cases advantages simple declarative semantics clp language lost wish provide language facilities asking optimal solutions admit efficient implementation also simple declarative semantics case maximum wealth achieved exactly one stock price option combinations maximum may occur range rather returning one position returning infinite number answers representing positions would like keeping spirit constraint logic programming return constraints determining maximum occurs following goal asks maximum profit combination two put two call options min query2s w w w maxstock maxwealth query2stockprice wealth valueput buy stockprice 10 20 wealth1 valuecall buy stockprice 10 80 wealth4 returns answer constraints representing stock prices maximum wealth achieved note two answers could represented one computed manner arise two distinct answer constraints query2 existing constraint logic programming languages ideally suited answering satisfaction questions core operational behavior however solving optimization problems clp language problematic importance optimization languages like chip 3 provide ad hoc optimization facility destroys underlying declarative semantics remainder paper show introduce refinement optimization operator used clp language without compromising usual model theoretic semantics 3 naive operational semantics optimization section first give usual operational semantics clp programs extend simple way include minimization show simple extension number problems 31 standard operational semantics clp predicates clp program divided two classes primitive constraints prim programmerdefined atoms atom primitive constraints predefined sense intended meaning interpretation efficiency built solver language example primitive constraints clpr linear arithmetic equalities inequalities real numbers syntactic equalities terms let intended model primitive constraints simplicity require atoms form px 1 x n x distinct variables primitive constraints however terms constructed predefined function symbols arguments literal atom primitive constraint constraint conjunction primitive constraints differentiate two constraints logically equivalent let 9 constraint restricted variables 9 9 function vars takes syntactic object returns set free variables occurring let 9 8 stand existential universal closure respectively hence 9 denotes whether satisfiable set constraints assumed closed existential quantification constraint logic program finite set clauses form h b head h atom body b sequence literals goal possibly empty sequence literals renaming bijective mapping variables naturally extend renamings mappings atoms clauses constraints syntactic objects 0 said renamings renaming ae definition atom program p respect variables w defn p w set renamings clauses p renaming head variables disjoint w gamma varsa operational semantics program terms answers derivations reduction sequences states state tuple consisting current constraint current literal sequence goal state h gi reduced follows fixed selection rule used choose literal l g 1 l 2 prim 9l state reduced hl g n li 2 l 2 atom state reduced h b note denotes concatenation sequences n deletes element sequence derivation state program p sequence states reduction i1 derivation successful last state empty sequence atoms let constraint last state successful derivation state constraint restricted variables said answer state denote set answers state answers informally talk answers goal g meaning answers state htrue gi state finitely evaluable infinite derivation 32 naive operational semantics optimization optimization make sense must partial order intended model compare elements case reals usual arithmetic inequality technical convenience assume ordering total thus minimum exists unique ground terms language representing possible minimum values also extend ordering include two new elements respectively smaller larger every element thus ensuring lubs glbs always exist point optimization find solutions constraint set optimal respect underlying ordering exactly mapping ff variables domain solution constraint j ff let soln denote set solutions greatest lower bound expression context constraint glbm solng minimum wrt defined minimum dually define least upper bounds maximums however ignore maximal solutions usual constraint domains rewrite maximization minimization regardless treatment dual minimization syntax clp programs goals extended allow optimization subgoals literals body goal optimization subgoal form g goal arguments expressions intuitive reading subgoal find value e 0 expression e gives minimal value context answers g easiest way incorporate optimization clp operational semantics evaluate optimization subgoals whenever selected intuitive idea first find answers state h gi current constraint compute minimum value answers considered disjunction constraints find value e e takes minimum finally e reflecting result minimization subgoal added current constraint unfortunately problem intuitive idea problem particular minimum may possibly infinitely many different values e solution problem keeping design philosophy clp languages return disjunction constraints representing possible different values long finitely many answers original query compatible minimum value finite disjunction suffices represent different values e considerations give rise following definitions partial function minimize l l minimization subgoal h gi finitely evaluable defined case minimize note minimum wrt pi definition makes minimize unsatisfiable 0 2 pi case corresponds h gi answer constrain h gi answers example 31 consider following program operational semantics modified adding following reduction step selected literal l g minimization subgoal state h gi reduced h 0 note goal g 0 answers h gi cannot reduced conceptually subprocess spawned compute answers g 0 subprocess terminate g 0 infinite derivation original derivation terminate considered infinite derivation unfortunately simple operational semantics number undesirable properties first answers dependent order literal evaluation example 32 consider program p lefttoright selection rule goal py single answer 2 however righttoleft selection rule goal single answer second give answers programs goals intuitively obvious meaning example 33 evaluation goal py program terminate however intuitively clear correct answer constraint second clause changed 0 x clearly minimum goal finitely fail 2 therefore difficult find model theoretic semantic basis optimization simple operational semantics reason develop slightly complex operational semantics model theoretic basis 4 safe operational semantics optimization problem example 32 variables affecting optimization result constrained optimization means optimization performed later execution gives different result problem example 33 derivations cannot possibly lead smaller minimum pruned especially infinite motivate following three changes first add argument optimization subgoal contains set variables local minimization problem variables implicitly universally quantified convenience assume disjoint variables clause thus optimization subgoal form w set local variables g goal arguments expressions intuitive reading subgoal find value e 0 expression e gives minimal value context answers g minimum taken values variables w allows us clearly distinguish local variables cannot constrained optimization global variables optimization constrained outside optimization second modify operational semantics optimization uses safe selection rule selection rule safe sense optimization subgoal selected sure subsequent execution cannot change result optimization true whenever global variables unique value precisely let l minimization subgoal minw boolean function delay delay l take unique value thus delay l holds result evaluating l context could changed adding constraints global variables selection rule safe never selects minimization subgoal l state h gi delay l holds third modification change evaluation optimization subgoal derivations ignored cannot lead smaller minimum value following function captures intuition partial function minimize l l minimization subgoal minw defined minimize finitely evaluable h gi finitely evaluable restriction h mgi finitely evaluable weakest restriction ensures found minimum proof minimality finite section 6 show efficiently implement minimize putting modifications together define safe operational semantics optimization fol lows extends usual operational semantics allowing optimization subgoals selected literal l g minimization subgoal state h gi reduced h 0 g n li selection rule must used derivation flounders last state nonempty sequence delayed optimization subgoals derivation optimization subgoal flounders goal state flounders derivation flounders show safe operational semantics overcomes difficulties associated naive semantics example 41 consider programs p example 32 variable x local variable minimization subgoal therefore p rewritten using safe operational semantics goal py single answer 2 minimization subgoal cannot selected global variable z constrained value 1 2 example 42 consider program example 33 rewritten evaluation goal py program terminate desired answer found possible minimum using first clause derivations using second clause pruned similarly constraint second clause becomes 0 x terminate failure5 declarative semantics section give declarative semantics minimization based translating minimization subgoals subgoal negation usual semantics programs negation used give declarative semantics resultant program first study obvious translation based fact minimum value x goal px iff pm holds z smaller pz holds give refinement translation allows stronger completeness result definition 51 let f formula possibly containing minimization subgoals define minimization translation f written mtf formula obtained replacing minimization subgoal subformula simple translation captures 0 minimum goal g compatible answer g answer g none compatible value less similar translation used 5 2 example 52 consider following program goal py unique answer 0 minimization translation first clause substituting usual declarative semantics logic program negation given three valued models programs clark completion 12 clark completion 2 captures reasonable assumption predicate fully defined clauses program ifandonlyif definition predicate obtained combining reason three valued logic used rather usual two valued logic nontermination goal succeeds truth value true goal fails truth value false goal terminate truth value undefined following 19 extend notions constraint logic programs definition 53 completion compp program p domain defined follows rules p defining p assumed share variables except x p contains rules defining p p contains 8 theory first order sentences true compp note assume kleenes strong three valued interpretation 11 connectives except given lukasiewiczs interpretation x true iff x truth value including undefined false otherwise combining minimization translation completion gives rise simple declarative semantics programs minimization definition 54 declarative semantics program p containing minimization subgoals constraints threevalued consequences theory compmtp thus write f holds every three valued model compmtp awe wish relate operational semantics declarative semantics given completion following theorem corollaries relates two queries interest programmer namely terminate theorem 55 soundness completeness minimization let p program l minimization subgoal state h li finitely evaluable nonfloundering proof sketch induction depth minimization subgoals simultaneously proving following intermediate result h gi state fh 1 ig possibly empty set states modulo variable renaming h gi reduced one step corollary 56 soundness completeness finitely evaluable goals let h gi non floundering finitely evaluable state answers another corollary proof strong soundness result evaluated minimization subgoals successful derivation obviously nonfloundering finitely evaluable successful derivation returns correct answer similarly goals g every derivation finitely failed formally corollary 57 soundness success finite failure g successful nonfloundering derivation answer constraint compmtp mtg every derivation g finitely failed compmtp would also like completeness result goals finitely evaluable use constructive negation implement optimization completeness respect threevalued consequences immediate 19 however even case goals flounder completeness result holds efficient operational semantics considered two problems first problem arises completeness finite failure requires use fair selection rule selection rule fair infinite derivation subgoal remains unselected forever however safeness may force selection rule unfair easily illustrated using example involving negation usual operational semantics negation safe sldnf safe sense ground negative literals may selected thus also suffer interaction fairness safeness example 58 consider following program goal tx rx t1 clearly goal answers since tx even though safe sldnf derivation tree goal flounderfree finitely failed negative goal rx selected answer tx found 2 similar problem occur minimization subgoals consider execution goal using definition minimize infinite number minimal answers goal incompatible constraints goal however safe operational semantics finitely fail overcome lack fairness must make small change operational semantics complete operational semantics safe operationals semantics except uses following rule reducing minimization subgoals selected literal g minimization subgoal state h gi reduced h mgi finitely evaluable complete operational semantics essentially behaves safe operational semantics except minimization subgoal infinite number answers however less efficient repeated computation calculation execution second problem arises operational semantics constraints environment places e 0 applied minimization subgoal returns terminate constraints considered even though may incompatible derivations causing nontermination example 59 let p program consider derivation goal p clearly minimization subgoal runs forever completion mtp hence operational semantics incomplete 2 second example illustrates simple translation minimization negation agree operational semantics obtain completeness result nonterminating computations require complex translation makes translation minimization subgoal undefined whenever subgoal finitely evaluable following translation achieves definition 510 let f formula possibly containing minimization subgoals define complex minimization translation f written cmtf formula obtained replacing minimization subgoal form minw subformula reason translation gives desired behavior 9 truth value undefined whole subformula otherwise subformula equivalent original translation thus preceding theorems soundness completeness finitely evaluable subgoals still hold new translation cases translations equivalent examining program p previous example undefined compmtcp undefined rather false given new translation minw assuming evaluation complete operational semantics give desired completeness result theorem 511 completeness success finite failure p program constraint domain exists safe fair selection rule derivations g p flounder free compcmtp g successful derivations answers b compcmtp every fair derivation g finitely failed 2 proof sketch proof relies results constructive negation 19 show compcmtp using constructive negation goal cmt g totally successful ie answer constraints 9cmt using constructive negation goal cmtg finitely failed proof induction least depth breadth first derivation tree makes cmt g totally successful finitely failed essentially prove cmtg totally successful finitely failed wrt cmtp iff g totally successful resp finitely failed wrt p 2 6 implementation section sketch extended existing clp compiler provide optimization compiler language clpr 9 10 constraints linear arithmetic equations inequalities adding optimization useful means linear programming problems operations research naturally expressed simple programs three features note implementation first feature simple modification clpr solver testing satisfiability linear inequalities obtain low level minimization function min exp computes greatest lower bound arithmetic expression e current constraint store gamma1 bound exists simplex algorithm already employed solver testing satisfaction also used minimization second feature implementation note efficiently prune useless derivations computing minimal value expression respect goal done function min goal uses type branchandbound algorithm current best value minimum used prune search definition min goal makes use function get first answerg returns tuple h constraint store finding first answer state h gi b backtrack information subsequent answers goal g found using get next answerb backtracks finds new answer g returns tuple containing new constraint store new backtrack information procedure add constraint adds constraint 0 current store way subsequent backtracking inside min goal remove cmin 1 h bi get first answerg min exp cmin min exp add h bi get next answerb return cmin final feature implementation note using metalevel constructs clpr projection access current constraints store possible write function minimize l using function min goal fact current implementation program optimization subgoals translated equivalent program contains metalevel calls calls function min exp current implementation compromises completeness two ways first uses lefttoright selection rule unfair leftmost literal optimization subgoal whose global variables ground runtime error second uses depthfirst traversal derivation tree means terminate encounters infinite branch cannot pruned current estimate cmin restrictions improve efficiency practice severe resembling used prolog implementations course implementation still sound 7 related work declarative semantics based completion semantics developed negation kunen 12 logic programs extended constraint logic programs stuckey 19 operational semantics related proposed naish 17 negation aggregation optimization subgoals must delay global variables fixed value using current best optimum prune search space related operational semantics optimization 2lp 16 chips minimizegm predicate 3 proofs based expressing optimization terms negation emphasize although negation used formalize optimization replacement minimization negation lead operationally feasible approach minimization using safe sldnf translation clause example 52 normal program gives safe sldnf execution program flounders goal py operational semantics succeeds use constructive negation translation lead executable programs furthermore need safe selection rule unfortunately implementations constructive negation exist general severe efficiency problems reason operational semantics give quite different efficient usual operational semantics constructive negation deductive database researchers studied aggregation particular minimization 5 example goal groupbypxy x corresponds intent minimization subgoal although apparently related cannot make use results setting bottomup operational paradigm used deductive databases research considered building interactive querying facility clp program allows optimization queries 15 however setting optimization part language rather sits top recently made aware work fages 4 independently suggested number related operational semantics optimization clp languages also provides declarative semantics based translation minimization negation similar mt give explicit soundness completeness results operational semantics seems suggest soundness completeness follows immediately results constructive negation 19 however need complex translation cmt suggests completeness difficult prove r extension constructive negation application coroutining negation failure constraint logic programming language chip semantics optimization predicates clp languages minimum maximum predicates logic programming mockingbird logical methodology testing metaprogramming clpr clpr language system abstract machine clpr introduction metamathematics negation logic programming constraint logic programming options trading foundations logic programming 2nd expanding query power constraint logic programming 2lp logic programming linear programming system negation control prolog using extended prolog digital circuit design constructive negation constraint logic programming tr negation control prolog negation logic programming constraint logic programming mockingbird logical methodology testing minimum maximum predicates logic programming clpinlineequation f scrscf inlineequation language system abstract machine clpscprscp ctr kannan govindarajan bharat jayaraman surya mantha optimization relaxation constraint logic languages proceedings 23rd acm sigplansigact symposium principles programming languages p91103 january 2124 1996 st petersburg beach florida united states p dasgupta p p chakrabarti dey ghose w bibel solving constraint optimization problems clpstyle specifications using heuristic search techniques ieee transactions knowledge data engineering v14 n2 p353368 march 2002 jan chomicki semantic optimization techniques preference queries information systems v32 n5 p670684 july 2007
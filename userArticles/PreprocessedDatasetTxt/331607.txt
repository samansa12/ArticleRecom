parallel rams owned global memory deterministic contextfree language recognition identify study natural frequently occurring subclass concurrent read exclusive write parallel random access machines crewprams called concurrent read owner write crowprams machines global memory location assigned unique owner processor processor allowed write considering difficulties would involved physically realizinga full crewpram model demonstrate stability several definitional changes second precisely characterize power crowpram showing class languages recognizable time olog n implicity polynomial number processors exactly class logdcfl languages log space reducible deterministic contextfree languages third using basic machinery show recognition problem deterministic contextfree languages solved quickly deterministic auxilliary pushdown automation random access input tape log n space work tape pushdown store small maximum height example time on1 egr achievable pushdown height olog2 n result extend unify work von braunmhl cook mehlhorn verbeek klein reif rytter b several definitional changes second precisely characterize power crowpram showing class languages recognizable time olog n exactly class logdcfl languages log space reducible deterministic context free languages third using basic machinery show recognition problem deterministic contextfree languages solved time 1ffl sn ffl 0 log 2 n sn n deterministic auxiliary pushdown automaton log n space work tape pushdown store maximum height sn random access input tape results extend unify work von braunmuhl cook mehlhorn verbeek klein reif rytter 1 introduction related work fairly large body literature parallel random access machine pram models algorithms nearly many definitions model papers subject agree general features models collection less ordinary sequential processors private local memories access shared global memory model synchronous time unit processor executes one instruction much diversity regarding features model example differences whether model single multipleinstruction streams many processors numbered activated instruction set input convention used simultaneous read write requests single global storage location arbitrated variations make little difference power model two features seem substantial impact power model one uniformity general consider uniform models paper ie ones single program suffices input lengths single processor initially active creating processors desired second sensitive feature arbitration memory access conflicts two main variants intensively studied following nomenclature introduced vishkin 37 crcw concurrentread concurrentwrite pram allows memory access conflicts processors reading given location given step receive value among processors crowprams dcfl recognition 3 writing given location given step one allowed succeed eg one lowest processor number resolution rules write conflicts proposed known equivalent power constant factors running time polynomial factors number processors global memory size although models separated processors memory tightly constrained crew concurrentread exclusivewrite model concurrent reads allowed concurrent writes crew algorithms must arrange two processors attempt write global memory location time paper introduce third variant argue natu ral model crew pram give surprising characterization power several reasons study restriction crew pram crewpram model criticized powerful serve realistic model physically realizable parallel machines due unbounded fanin anderson snyder 1 point twostage programming process first using crewpram model develop straightforward fully parallel algorithm eg n bits emulating algorithm physically realizable network could lead suboptimal algorithm thetalog n 2 example nevertheless crewpram arguably popular theoretical model design specification analysis parallel algorithms due principally simplicity usefulness global memory model programmers useful therefore consider power restricted crow pram model order understand feasibility model parallel programming noted crewpram algorithms fact crowpram algorithms easily modified crewpram algorithm ensure obeying exclusivewrite restriction two exceptions discussed crewpram algorithms considered achieve easily modified achieve write exclusion following simple stratagem global memory location owned one processor processor ever allowed write cell mapping global memory addresses processor numbers easy compute processor difficulty determining cells owns ex 4ample processor p might block k consecutive cells beginning global memory address kp call ownerwrite restriction call prams obey restriction concurrentread ownerwrite prams crowprams ownership restriction seems natural framework design exclusivewrite algorithms similar identical notions ownership appeared earlier lower bound work cook et al 7 also proven useful practice certain cache coherence protocols see eg archibald baer 2 many current architectures parallel systems machines provide global memory programming model implemented using physical hardware every memory cell local processor caching techniques used ameliorate cost access nonlocal memory nonlocal writes prohibited necessary cache coherence algorithms simplified fact positive solution crow versus crew problem discussed section 3 would presumably suggest interesting new approach cache coherence problem give precise definition crowpram model section 2 main goal paper investigate power crow pram unexpectedly question turns intimately related complexity deterministic contextfree language dcfl recognition recognition problem deterministic contextfree language l decide given word x whether x 2 l sequential complexity problem wellstudied many practical sequential algorithms solving space time smallspace parallel time complexities problem less wellunderstood two main results areas von braunmuhl cook mehlhorn verbeek 5 38 klein reif 20 cook 5 presents sequential algorithm dcfl recognition problem runs polynomial time turing machine using polynomial log n space result improved von braunmuhl et al 38 give turing machine algorithms optimal timespace product space bound range log n 2 n building somewhat ideas 5 38 klein reif 20 present olog n time crewpram algorithm dcfl recognition known results stockmeyer vishkin 35 combined crowprams dcfl recognition 5 algorithm ruzzo 32 yield olog n time algorithm general cfl recognition powerful crcwpram model main result following characterization crowprams theorem 1 language l accepted crowpram olog n time l logspace reducible dcfl class logdcfl languages logspace reducible dcfls first defined studied sudborough 36 showed equal class languages recognizable polynomial time logspace bounded deterministic auxiliary pushdown automata dauxpdas defined cook 4 result appears first precisely characterize parallel time complexity class constant factors terms sequential one example sudboroughs hardest dcfl 36 provides natural example problem complete crowpram time olog n complete problems discovered chandra tompa crcwpram time classes 3 know analogous natural problems complete crew classes following earlier version paper 12 lange niedermeier 22 established characterizations pram variants terms sequential complexity classes use dcfl characterization demonstrate stability crowpram complexity classes definitional changes example follows dcfl simulation crowpram simulated time loss parallel machine global memory processor contains single externally visible register may read written processor model seems closer way parallel machines actually constructed models independent global memory associated processor dcfl recognition algorithms von braunmuhl et al 38 klein reif 20 difficult ones use superficially different approaches third goal paper provide unified approach problems although based believe simpler either obtain small time parallel algorithm small space sequential algorithm dcfl recognition using basic approach small space algorithm provides improvement result rytter 33 technical refinement optimal results von braunmuhl et al 38 rytter shown using sequential implementation 20 possible obtain polynomial time olog 2 n space algorithm dcfl recognition using space mainly pushdown store precisely log n space dauxpda olog 2 n bounded pushdown rather unrestricted olog 2 n space 38 improve results performing simulation dauxpda like rytter attaining timespace product similar von braunmuhl et al section 2 presents crowpram model discusses variations definition section 3 presents simulation deterministic auxiliary pushdown automata establishing crowpramtimelog n logdcfl section 4 introduces definitions notation needed dcfl recognition algorithm section 5 presents high level description correctness proof dcfl recognition algorithm section 6 discusses crowpram implementation algorithm establishing inclusion needed theorem 1 ie logdcfl crowpram timelog n finally section 7 refines simulation section 5 obtain faster sequential algorithm obtained combining crow pram algorithm section 6 general simulation section 3 work involving owned global memory concept prams appeared following preliminary version paper 12 fich wigderson give lower bound separating erow crow prams 14 rossmanith introduces studies owner read owner write prams showing example list ranking olog n time 31 nishimura considers owner concept crcwprams 29 nieder meier rossmanith 27 26 considered owner concept pram variants lin et al show crowprams sufficiently powerful execute variant coles parallel merge sort algorithm time olog n 23 work restrictions crowpram model lam ruzzo 21 dymond et al 11 described end section two crowprams dcfl recognition 7 2 definition crowprams start defining crewpram model use mentioned details definition critical specificity use definition fortune wyllie 15 called simply pram unbounded global memory unbounded set processors accumulator instruction counter unbounded local memory memory cell hold arbitrary nonnegative integer instruction repertoire includes indirect addressing load store add subtract jump jumpifzero read fork halt input placed sequence special readonly registers one bit per register read instruction allows processor read input bit concurrent reads allowed fork instruction causes new processor created local memory cells zero accumulator initialized value accumulator creator initially one processor active local memory zero length input given accumulator model accepts initially active processor halts one accumulator rejects two processors attempt write global memory location time crewprams processor numbers ids builtin concept need adopt following processor numbering scheme unique processor active initially numbered 0 first child processor created processor numbered 2i second numbered 2 1 corresponds natural embedding arbitrary tree processor activation tree binary tree rule eldest child becomes right child next younger sibling becomes left child reversepreorder traversal activation tree binary tree identical see many numbering schemes also work one fairly natural processors automatically know number easy program compute needed algorithm crewpram algorithm exists function owneri n computable deterministic space olog n input length n processor p attempts write global memory location intuitive definition given earlier said owner function simple particularized requiring logspace computable oblivious ie independent input except length required model detect illbehaved programs ie ones attempt global writes violation ownership constraint programs simply crow programs seem natural choices also show main results fairly insensitive issues could generalize model following ways g1 allow owner function depend input g2 allow owner function depend time g3 allow bounded multiple ownership ie owneri n set size o1 processor numbers g4 allow illbehaved programs defining model halt reject attempted write violates ownership constraint g5 allow processor numbering scheme gives processors unique numbers allows one compute logarithmic space parent given processor p number older siblings number k th child g6 allow owner parent sibling functions computable deterministic logspace auxiliary pushdown automaton runs polynomial time alternatively could restrict model following ways r1 require owner function identity equivalent saying machine global memory instead collection processors private local memory one globally readable communications register r2 require processors use o1 local memory locations crowprams dcfl recognition 9 r3 require machine writeoblivious ie times locations writes global memory independent input except length one consequence results crowprams even ones satisfying relatively weak conditions g1g6 simulated crow prams satisfying strict conditions r1r3 constant factor increase time polynomial increase number processors possible crew crowprams equivalent power positive side conditions g1g6 fairly generous difficult imagine protocol pram algorithm could achieve writeexclusion would covered example note general crew pram algorithm considered crowpram algorithm owner function allowed input timedependent conditions g1 g2 sense computable crewpram real time know say crewpram time olog n simulated logarithmic space deterministic auxiliary pushdown automaton runs time n olog n realtime crewpram computable functions may different n o1 dauxpda computable ones thus seems possible time crowprams crewprams might identical least provides intuitive support empirical observation known crewpram algorithms crowpram algorithms one context know two models equivalent following appearance extended abstract paper 12 ragde personal com munication see also fich 13 nisan 28 observed nonuniform crow prams ie ones arbitrary instructions exponentially many processors initially active allowing different programs value n running time equivalent boolean decision trees depth 2 nisan 28 established set recognized nonuniform crew pram time olog n n equivalent boolean decision tree problem depth 2 tn taken together results show time two models constant factor nonuniform setting leaves open stronger conjecture set recognized crewpram time log n recognized crowpram time olog n ordinary uniform variety using polynomially many processors note nisans simulation crew crow uses nonuniformity fundamental way uses 2 2 tn initially active pro cessors nonuniform model languages recognizable olog n steps one restricted setting know two uniform nonuniform models different suppose processors 1 n active knows one bit b want compute bits given one b 1 crewpram solve one step processor 1 bit writes global location 0 writeconflict happen since one 1 bit however marc snir personal communication shown crowpram n steps solve problem initial state snirs result settle general question however problem discussed defined one input bit one called partial domain fich contrast usual situation algorithm required produce correct answer nbit input sequences know results cook et al 7 even crewpram requires time omegagammame n test whether input contains one 1 bit conceivably crew algorithm exploited something like snirs could always transformed crow algorithm using preprocessing time better advantage full domain problem known us uniform crew prams seem powerful crowprams recognition problem unambiguous contextfree languages problem rytter 34 given olog n crewpram algorithm appears use power nonowner exclusive writes fundamental way loosely speaking seems unambiguity underlying grammar allows one repeatedly exploit feature like snirs crowprams appear nearly powerful crew prams interesting compare possibly weaker parallel model parallel pointer machine dymond cook 10 ppms consist unbounded pool finitestate transducers finite set pointers processors ppm operates sensing outputs neighboring processors moving pointers processors adjacent current neighbors cook proposed model example simplest possible parallel machine variable structure 6 crowprams dcfl recognition 11 lam ruzzo 21 establish time ppms linearly related time restricted version crowpram doubling adding one arithmetic operations permitted fact also showed simultaneous linear relationship amounts hardware used two machines conjecture crowprams ability access twodimensional arrays constant time cannot directly emulated crowpram whose arithmetic capability limited proved recently dymond et al 11 since twodimensional arrays appear play important part dcfl simulation algorithm section 6 suggests quite different techniques would needed recognize dcfls time olog n ppm indeed possible analogous nonconstant lower bound two dimensional array access proved sequential unit cost successor rams dymond 9 3 simulation crowprams dauxpdas section prove first half theorem 1 namely theorem 2 set recognized time olog n crowpram logdcfl recall logdcfl class languages log space reducible deterministic contextfree languages sudborough 36 defined class characterized set languages recognized polynomial time logarithmic space deterministic auxiliary pushdown automaton main construction similar analogous ones given pratt stockmeyer 30 fortune wyllie 15 goldschlager 17 showing pram time log n contained dspacelog 2 n define three mutually recursive procedures statet p returns state processor p time ie th instruction executed localt returns contents location local memory processor p time globalt returns contents global memory location time depends values procedures time gamma 1 recursion depth furthermore procedure require olog n bits local storage wellknown techniques procedures implemented logarithmic space deterministic auxiliary pda whose pushdown height olog 2 n much proof essentially 15 17 30 main novelty proof algorithm runs polynomial time rather time n log n earlier results possible owner function allows us globalt directly identify possible writer global memory location time gamma 1 allows procedures make recursive calls per invocation gives polynomial running time simulating general crewpram algorithm would appear necessary check processors time gamma 1 see whether wrote whether one appears require polynomial time extensions basic procedures accommodate generalizations g1 g6 quite direct except g4 illbehaved programs g4 also possible delicate since effect must check step none many nonowners attempts write global cell maintaining property algorithm makes o1 recursive calls per invoca tion possible similar generalization crew model would increase power proof theorem 2 detailed descriptions three procedures follow typical pram instruction global indirect store l whose meaning store accumulator global memory location whose address given contents local memory location l describe rest prams instruction set great detail see fortune wyllie 15 state processor p time ordered pair containing instruction counter contents accumulator p end th step define three auxiliary functions accumulators instructioncounters instructions state give accumulator portion instruction counter portion instruction pointed instruction counter respectively assume value 0 instruction counter designates halt instruction crowprams dcfl recognition 13 convention instruction executed step processor p activated halted also assume instructions halt instruction otherwise defined eg jump location beyond end program convenient assume local memory processor set zero soon halts accumulator retains last value assume processor 0 initially executes instruction 1 processor activated fork l instruction initially executes instruction l also assume processor maintains local memory location 0 count number fork instructions executed count initially 0 incremented immediately fork executed easy modify pram algorithm achieve also use two functions parentp siblingcountp processor number p return processor number parent p number older siblings p respectively processor numbering scheme chosen functions easy compute namely k largest integer p evenly divisible 2 k procedure simulatecrowpram comment main program begin ne comment upper bound running time pram statet function globalt comment returns contents global memory location time begin store l return accumulators else return function localt comment return contents local memory location processor p time begin case local store return accumulators indirect local store l return accumulators return crowprams dcfl recognition 15 function statet p comment return state processor p time begin comment ac initially length input return 1 n else comment processors idle time 0 return 0 ac accumulators ic instructioncounters case indirect load l return ic global indirect load l add sub read similar load return l ac else return ic parent activated p step return l accumulators 0 else comment p activated pass ac return 0 ac correctness simulation straightforward induction implementation procedures dauxpda also easy note procedure local variables requiring olog n bits storage dauxpda needs much space work tape recursion depth equal prams running time ie olog n pushdown height product two quantities ie olog 2 n procedure makes o1 recursive calls per recursive level running time simulation o1 olog n n o1 completes proof theorem 2 2 simulation given easily adapted accommodate generalizations g1g6 definition crowprams proposed earlier allowing general owner function say depending input time g1g2 trivial add appropriate parameters call using different processor numbering convention equally easy provided parentp siblingcountp easily computable g5 allowing functions logspace polynomial time dauxpda computable effect asymptotic complexity bounds g6 bounded multiple ownership g3 also easy global procedure check whether owner global memory cell wrote would need check among set owners see wrote since set size o1 running time would still polynomial changing procedures accommodate illbehaved pram algorithms g4 subtle first change required must determine exact running time algorithm using upper bound cause us falsely reject due invalid global store processor value easily determined evaluating statet halts accepts accept need worry ownership violations second interesting change check store instructions active processors p time basically depthfirst search processor activation tree crowprams dcfl recognition 17 procedure simulateg4crowpram comment modified main program incorporating g4 begin instructionstatet 0 6 halt accumulatorstatet 0 6 1 halt reject treewalk0 halt accept procedure treewalkt p comment visit processor p time descendants created interval verify nonowner writes occur begin store l halt reject comment owner violation quit correctness procedure argued follows crowpram algorithm owner write violations procedure correct hand suppose violation say time processor p procedures correctly determine state pram time state pram undefined whereas procedure calls return values violation occurred ever eventually treewalk detect fault may reject evaluating branch processor activation tree happens explored ps branch latest however detect fault evaluating statet p count since simulation faithful time state pram time contains information need deduce processor p active time execute store violation ownership constraint hence eventually evaluate statet p detect fault halt running time algorithm still polynomial since treewalk p called exactly active processor p polynomially many processors checked thus shown following theorem 3 set recognized time olog n generalized crowpram ie one satisfying generalizations g1g6 basic defi nition logdcfl completes proof direction theorem 1 converse shown following sections 4 dpda definitions notation assume familiarity deterministic pushdown automata dpda defined example harrison 19 well standard variations model dpdas state set q input alphabet sigma pushdown alphabet gamma empty string denoted ffl length string jsj string concatenation delta step either current topmost pushdown symbol popped pushdown single new symbol pushed onto pushdown current symbol assume transition function defined every possible state input symbol pushdown symbol thus dpda begins state q 0 initial pushdown contents input head left input accepts entering state q fl pushdown contents advanced input head right end input assume dpda never fails read crowprams dcfl recognition 19 input always empties pushdown symbols except fl end computation furthermore assume oe 2 gamma transition pushing oe standard techniques see eg harrison 19 section 56 constant c 0 dpda assumed properties halt time c delta n maximum pushdown depth n input length n efficient simulation dpda described makes use concepts surface configuration instantaneous description defined relative particular input configuration triple q oe q state integer coded binary 0 n representing position input head oe represents topmost pushdown symbol set surface configurations denoted u instantaneous description id dpda pair hu si u surface configuration string representing topmost symbol pushdown bottommost pushdown represented rightmost position convenience refer stack thus initial id hq unique accepting id hq n fl ffli id stack component ffl called fflid note fflid corresponds pushdown one symbol surface configuration id hu si define heighti jsj define projection functions surface configuration said popping transition defined q x oe pops pushdown pushing otherwise id popping pushing surface configuration popping pushing write 1 2 id 2 follows id 1 one step dpda input x 1 2 2 follows 1 exactly steps 1 2 1 2 0 definition ids represent configurations machine least one pushdown symbol 1 popping fflid id 2 1 2 thus popping fflid said blocked true even though dpda makes one final move 1 depending input state single pushdown symbol surface configuration empty pushdown convenience assume final accepting configuration defined pop blocked id denote hu id modified symbols 2 placed symbols 1 stack illustrate notation three useful propositions proposition 4 bottompadding surface configurations u v strings note converse true general following case proposition 5 bottomunpadding surface configurations u v strings 1 proposition 6 blockcontinuation surface configurations addition restrictions dpdas discussed assume id occur twice computation dpda started given id 19 section 56 justifies using ids references particular points computations eg j could refer id j uniquely identify point computation steps id crowprams dcfl recognition 21 5 basic dpda simulation algorithm describe procedure efficiently simulate dpda input x length n algorithm motivated repeated doubling idea used eg fortune wyllie 15 39 klein reif 20 described setting follows suppose computed surface configurations u 2 u strings si could easily compute 2 k1 step transition function k1 composing k however efficiency considerations preclude defining k possible stacks observing computation 2 k steps top 2 k symbols stack accessed split writing contains everything first 2 k symbols 2 empty length could rewritten although could used limit number stacks considered length 2 k still many polynomial number processors compute olog n time key observation constructing efficient algorithm number stacks need considered much limited suggested shown sufficient consider polynomialsized set stacks provided use stack splitting somewhat complicated doubling technique simplify set stacks considered compute function delta k place described gives result least 2 k steps rather exactly steps advantage use appropriately chosen break points keep stacks simple first describe algorithm assuming stacks explicitly manipulated section 6 describe pram implementation avoids using succinct representation stacks selves two functions ids used delta k low k defined inductively parameter k id returns id 2 results steps dpda starting id 1 value implicitly determined algorithm shown blocked id reached 1 less 2 k steps case number steps needed reach blocked id formally ids 1 2 delta k satisfy 2 blocked 1 function low k returns id 2 id lowest height among ids computation 1 delta k inclusive one id minimal height computation earliest id ie one closest 1 formally 1 c given definitions determine dpda accepts x sufficient check whether since dpda runs time c delta n input length n discussed necessary restrict number stacks must defined careful definition delta information needed compute delta k1 delta k restricted consideration ids whose stack contents suffixes stacks produced delta k operating fflids polynomially many fact state precisely define ss k mnemonic simple stacks set strings represent bottom portions stacks ids range delta k operating fflids ie suffix stack contains 2 elements one u 2 u suffix unique stack determined u motivate crowprams dcfl recognition 23 pp pp ppp pp ppp ppp pppp pppppppppp ppppp pp ppp ppp ppppp pp pp pppp pppppp pppp pp time height stack figure 1 illustrating ss k definition ss k consider diagram figure 1 plotting stack height versus time part computation dpda diagram shows stack 1 built delta k computation starting hu ffli must complementary computation starting hv 1 eventually empties stack figure 1 part 1 removed computation starting continuing hw 2 rest 1 consisting 2 removed later beginning hy 2 note 2 suffix 1 illustrates ss k contains stacks arising delta k operating fflids also suffixes stacks show later k 0 stacks ss k1 restricted concatenation two strings ss k ie ss technical reasons important maintain information specifying stack ss k1 split two stacks ss k rather simply treating stacks undifferentiated character strings interest simplicity however largely ignore issue current section treated fully section 6 arguing correctness algorithm prove following induction k welldefined ids stacks ss k ss k satisfy properties 1 2 3 respectively crux algorithm correctness proof captured following lemma shows progress least 2 k steps simulation simultaneously restricting attention limited set stacks applying delta k selected low points lemma 7 id 2 ss k let j 0 b j unblocked 2 k c stackj 2 ss k delta ss k proof see figure 2 plots stack height versus time computation dpda three distinct cases first simplest shown diagram dpda blocks attempting pop stack height zero completing 2 k steps second computation hsurfacel ffli blocks completing 2 k steps argue overall lowdelta computation complete least steps third case none subcomputations block part follows directly properties 1 2 correctness property 2 l lowest point computation l least stackl must suffix ss k assumption thus stackl ss k definition also ss k thus stackj ss k delta ss k satisfying c assume j unblocked let delta stackl unblocked correctness property j least 2 k steps past l part b follows hand blocked j unblocked stackl must nonzero height case j cannot precede delta k since otherwise id succeeding j would point lower height l range crowprams dcfl recognition 25 height stack pp ppp ppppp ppppp pp ppp pp ppp ppp ppppp pp pppp ppppppppppp ppppp ppp pp time stack j 2 ss k1 stack stack figure 2 lowdelta lemma delta k inclusive contradicting correctness property 2 follows unblocked part b follows correctness property 1the expression j lemma occurs frequently convenient introduce special notation define e l stackl example lowdelta lemma shows e steps blocks note l j lowdelta lemma heightl 0 j necessarily unblocked e necessarily progresses 2 k steps lemma applies id stack ss k need analogous result stack consisting two three segments ss k desired low point stack found following iterated low function useful later define function handle constant number stack segments rather three see figure 3 ppp pp pp pp pppp pp ppp ppppp pppp pp pp pppppp pp ppp ppp ppppppp ppppp pp time e sd stack height e figure 3 ilow k function ilow k returns id comment assuming 2 u theta ss k return id low k point nonzero height computation one exists return resulting fflid begin return comment every segment emptied return hu ffli desired generalization lowdelta lemma following crowprams dcfl recognition 27 id 2 j 0 b j unblocked 2 k c stackj 2 ss k d1 proof part follows propositions 1 2 let modifies stack argument calling stackl suffix stacki hence hypothesis ss k stack segment added call e k establishing part c key point establishing b low k point hence lowdelta lemma applied specifically let 0 last value taken loop let u 0 value taken u last call low k let l last value taken hu si return letting j easy see 0 delta lemma applies 0 particular j 0 unblocked least 2 k steps past 0 hence j least 2 k past satisfying part b thus suffices show j 0 unblocked whenever j unblocked two cases consider first suppose ilow k returns heightl necessarily unblocked hand ilow k returns heightl 0 inspection thus either case j unblocked j 0 unblocked part b follows 2 code ilow k given indicate determine decomposition stack parameter segments ss k brief suggested remark following definition ss k retain decomposition information stacks initially computed detailed explanation issue deferred next section defining low k convenient use auxiliary function min takes argument sequence ids returns id minimal height sequence several minimal height returns leftmost applications always earliest time construction finally ready define delta k low k correctness following parts definitions functions provide enclosed square brackets appropriate parts correctness arguments establishing basis j 9 j j otherwise ie blocked correctness assumption oe 2 gamma state pushing oe see ss 0 must exactly gamma ffflg exactly set stacks domain delta 0 low 0 inspection domain blocked thus 1 satisfied 2 holds two points range points consideration min selects lower 3 holds vacuously inductive definition delta k1 low k1 done two phases first considering ids empty stacks determine ss k considering ids stacks ss k gamma ffflg inductive definition delta k1 low k1 empty stacks see figure 4 k 0 u basically procedure computes deltalowdelta assuming computation block id reached first delta 2 k steps past starting point satisfies hypothesis lowdelta lemma thus subsequent lowdelta pair achieves another 2 k steps progress keeps resulting stack simple ie ss k1 argument main ingredient correctness proof case initial id crowprams dcfl recognition 29 ppp pp pp ppp ppppppp pppp pp pp ppppppppp pppp pp ppp pppp ppppppp ppp ppp pppp pp pp ppp pppppp ppppppppp ppppppp pppp ppppp pp pppp pp pp ppp pp pp height stack time e figure 4 delta k1 hu ffli nonempty stack turn similar except need precede another low two correctness let delta k hu ffli note definition ss k hypothesis lowdelta lemma satisfied delta k1 hu ffli blocked 1 immediately satisfied blocked neither least 2 k steps past hu ffli property 1 applying lowdelta lemma e least 2 k steps past hence 2 k1 past hu ffli thus delta k1 hu ffli also satisfies 1 clearly hu ffli earliest id height zero property 2 trivially satisfied low k1 hu ffli property 3 follows directly lowdelta complete definition delta k1 low k1 must define ids nonempty stacks 2 ss k1 defined delta k1 action fflids inductive definition delta k1 low k1 nonempty stacks using ilow k define delta k1 low k1 hu si result following computations see time pppp pp ppp pp ppp pp ppppp pppppp pp ppp ppp pppp ppp ppp pp ppppppp pppppp ppp ppp pp ppp ppppppppppp ppp pppp ppppppp ppp pp height stack ilow k e e e figure 5 figure correctness property 1 follows immediately applying ilowdelta lemma twice property 2 satisfied low k1 since two points min applied subsume low points subcomputations comprising delta k1 property 3 inapplicable remark ilowdelta lemma stackj may consist three stack segments even though stacki contains two main reason defining ilow k two stack segments finally remark ilow k identity function ids empty stack equal low k crowprams dcfl recognition 31 definition reduces exactly computation given earlier empty stack case since case similarly definition low k1 also suffices case ffl thus one could use general definitions handle cases completes definitions delta low proof correctness summarize key features construction low k1 delta k1 require constant number calls level procedures guarantee least 2 k1 progress simulation need defined domains polynomial size next two sections exploit features give fast implementations prams small space implementations pdas 6 crowpram implementation one important issue ignored discussion far question efficiently handling stacks obtain desired olog n running time need manipulate stacks lengthomegagamma n unit time particular defining ss k necessary able split two segments stack ss k done retaining information splitting components originally constructed fact decomposition information really information needed apply inductive definitions actual contents stacks never consulted definitions except base cases fact allows us replace actual stacks abbreviations avoiding explicit manipulation long character strings provided decomposition information kept available introduce succinct notation stacks revise algorithms using notation discuss crowpram implementation using notation definition stack 2 ss k suffix stack surface configuration u name specifying k u value h giving length suffix considered stack reference level k 0 abbreviated kreference pair u h stack reference said valid kreference u h said base u height h level k convenience ffl also considered valid kreference denoting empty stack height 0 k 0 algorithm maintain array summary k indexed surface configurations value stored summary 0 u actual symbols stack ffli value summary k1 u pair valid kreferences turn recursively specify actual symbols stack delta k1 hu ffli valid kreference u h may refer suffix stack thus convenient extend summary notation handle references summary valid kreference length h suffix summary 0 u k 1 pair kreferences summary k u adjusted height h adjustment carried follows suppose summary k u ordered pair kreferences v ordered pair v 1 single kreference v 2 h corresponds popping referenced stack desired height h reached define variants r k l k il k min functions delta k low k respectively section 5 operate using stack references summary information place stacks function min behaves like version section 5 except returns surface configuration height rather full id leftmost earliest arguments minimum height code r k needs provided case empty stack definition delta k hu si 6 ffl given section 5 support definition low k hu si associated correctness assertions otherwise used finally note code contents global array summary k always set function r k referenced l k crowprams dcfl recognition 33 function r 0 u surface returns surface 0reference comment returns surface reference corresponding side effect stores stack global array var begin u popping return u ffl let hu ffli hv oei oe r u 1 return v r function l 0 u surface r 0reference returns surface 0reference comment returns surface reference low point interval u r r 0 u r var string begin return v ffl function il k u surface r 1 sequence kreferences returns surface sequence kreferences comment returns surface sequence kreferences defining stack unblocked low point computation starting u r 1 procedure handles fixed number kreferences var r kreference begin return u ffl function r k1 u surface returns surface comment returns surface reference corresponding side effect stores summary stack var 1reference begin return v 3 r crowprams dcfl recognition 35 function l returns surface comment returns surface reference corresponding low point interval u r r k1 u r var sequence kreferences 1reference begin let r w h result prepending r 2 sequence 1 return correctness follows argument given section 5 using correspondence elucidated inductively define string b r associated valid kreference r follows valid 0reference string b r consists length h suffix string stored summary 0 u furthermore k 0 valid associate inductively string b induction k one show r string associated kreference r returned r k u exactly stack defined section 5 provided algorithm section 5 stack b decomposed specified summary call exact decomposition used ilow k left unspecified section 5 note proofs given particular proof lemma 8 ilowdelta lemma hold decomposition stack substrings ss k although need proofs hold specific decomposition given summary finally functions r k l k defined used time olog n parallel algorithm dcfl recognition crowpram algorithm tabulates r k summary k l k successively higher values k k 0 dlog cn e u 2 u parallel compute store table global memory side effect store summary k u u v 2 u h 0 valid kreference parallel compute store table global memory iteration loop performed constant number references previously stored values r k l k summary k implementation tables indexed surface configurations ref erences initialization unique processor every array entry done using nowstandard parallel ram programming techniques see gold schlager 17 wyllie 39 examples surface reference coded integer olog n bits used table sub script techniques also suffice implement algorithm crowpram satisfying restrictions r1r3 since surfaces 2 references number array entries hence number processors kept 3 reusing array space rather separate arrays value k 0 log n values summary k example discarded soon values summary k1 computed thus shown following theorem theorem 9 every dcfl recognized crowpram satisfying restrictions r1r3 time olog n 3 processors theorems 2 9 together establish theorem 1 also obtain following corollary crowprams dcfl recognition 37 generalizations g1g4 simulated crowprams subject restrictions r1r3 constant time loss polynomial increase number processors proof shown section 3 generalized crowprams satisfying g1g6 simulated deterministic auxiliary pdas log n space polynomial time thus languages recognized machines sudboroughs class logdcfl languages log space reducible deterministic contextfree languages log spacebounded reduction done crowpram time olog n using deterministic pointer jumping technique fortune wyllie 15 see cook dymond 8 detailed description simulation log space parallel pointer machine olog n time see lam ruzzo 21 simulation later model olog n timebounded crowpram simulation easily made obey restrictions r1r3 finally theorem 9 resulting language recognized crowpram also obeying restrictions following appearance earlier version paper monien et al 25 gave crewpram algorithm dcfl recognition ffl 0 uses olog n time n 2ffl processors algorithm uses functions similar suggests approach improving processor bound crowpram algorithm theorem 9 7 small space sequential implementation section 3 presented algorithm simulating olog n time crowpram deterministic auxpda using polynomial time olog 2 n stack height combined theorem 9 yields alternate proof following result rytter theorem 11 rytter 33 l accepted polynomial time logarithmic space dauxpda l accepted machine furthermore uses stack height olog 2 n analogous result previously known nondeterministic pdas ruzzo 32 best result previous rytters stack height reduction dauxpdas required superpolynomial time harju 18 cf 32 alternative proof corollary 12 harju 18 dcfls dauxpda space olog n stack height olog 2 n following result also corollary corollary 13 cook 5 von braunmuhl et al 38 dcfls time bound algorithm sketched polynomial particularly attractive shown von braunmuhl cook mehlhorn recognition simultaneous space sn time 1ffl sn dtms random access input tapes log 2 n sn n algorithm makes general use space resource ie used pushdown store even stack stack automaton sense ginsburg greibach harrison 16 goal remainder section sketch improvement algorithm achieve time bounds matching von braunmuhl et al still using dauxpda modifications borrow key ideas von braunmuhl et al constructions first outline direct algorithm bypassing simulation general crowpram sections 5 6 presented algorithm simulating dpda based procedures r k l k procedure r k sets global summary k array side effect l k reads easy reformulate procedures recursively fully recursive version r k would return summary information additional component function value accesses summary k l k would replaced appropriate calls r k recompute desired stack summaries recursive procedures straightforward implementation spacebounded deterministic auxiliary pda auxpdas work tape needs long enough hold local variables procedure pushdown crowprams dcfl recognition 39 height must times large depth recursion hold stack frames holding copies local variables return address etc procedures local variables consist integers plus bounded number surfaces requiring olog n space recursion depth dlog 2 cne thus procedures implemented dauxpda using space olog n pushdown height olog 2 n furthermore procedures level k makes bounded number calls level k procedures since depth recursion olog n total number calls o1 olog n n o1 exclusive recursive calls procedure takes time olog n manipulate surfaces etc plus necessary read inputs thus total time algorithm polynomial main idea improving time bound generalize construction section 5 give integer 2 procedures r k etc reflect computations length least k rather 2 k easily done machinery already developed example basically dfold composition f r k delta level od calls level k procedures thus number recursive calls main component running time log keep induction simple arrange stacks need considered suffixes built r k1 u turn concatenation suffixes stacks built r k v various vs important list vs provides succinct useful summary stack contents one final refinement idea simulate sn steps dpda base case procedures rather one step r k simulate least sn delta k steps implementation procedures dauxpda olog n work tape olog 2 n stack height straightforward random access input tape useful algorithm von braunmuhl et als following reason simulation pop moves requires recomputation portions stack necessitating access portions input read corresponding push moves ordinary sequential access input tape even though repositioning tape head may timeconsumingomegagamma n von braunmuhl et al show dcfl recognition possible simultaneous space sn time 2 sn log provably optimal techniques appear likely useful case well although pursued acknowledgements thank michael bertol philippe derome faith fich klausjorn lange prabhakar ragde marc snir careful reading early drafts useful discussions special acknowledgement due allan borodin without would never begun research r comparison shared nonshared memory models parallel computation cache coherence protocols evaluation using multiprocessor simulation model complexity short twoperson games characterizations pushdown machines terms timebounded computers deterministic cfls accepted simultaneously polynomial time log squared space towards complexity theory synchronous parallel compu tation upper lower time bounds parallel random access machines without simultaneous writes parallel pointer machines indirect addressing time relationships models sequential computation hardware complexity parallel computa tion pointers versus arithmetic prams parallel random access machines owned global memory deterministic contextfree language recognition complexity computation parallel random access machine towards understanding exclusive read parallelism random access machines stack automata com piling universal interconnection pattern parallel comput ers simulation result auxiliary pushdown automata introduction formal language theory parallel time olog n acceptance deterministic cfls exclusivewrite pram power parallel pointer manipulation implementing coles parallel mergesort algorithm ownerwrite parallel random access machines logic algorithmic fast recognition deterministic cfls smaller number processors optimal orowpram algorithms computing recursively defined functions prams towards realistic parallelism brams crew prams decision trees restricted crcw prams characterization power vector machines owner concept prams recognition contextfree languages parallel time olog n recognition unambiguous contextfree languages simulation parallel random access machines circuits tape complexity deterministic contextfree lan guages synchronous parallel computation survey recognition deterministic cfls small time space complexity parallel computations tr cache coherence protocols evaluation using multiprocessor simulation model upper lower time bounds parallel random access machines without simultaneous writes parallel rams owned global memory deterministic contexfree language recognition parallel time italico log italicn recognition unambiguous contextfree languages parallel time italicolog italicn acceptance deterministic cfls exclusivewrite pram power parallel pointer manipulation complexity short twoperson games toward understanding exclusive read owner concept prams crew prams decision trees fast recognition deterministic cfls smaller number processors restricted crcw prams parallel pointer machines pointers versus arithmetic prams stack automata compiling characterizations pushdown machines terms timebounded computers tape complexity deterministic contextfree languages universal interconnection pattern parallel computers introduction formal language theory dataindependences parallel random access machines prams towards realistic parallelism parallel merge sort concurrentread ownerwrite pram parallelism random access machines deterministic cfls accepted simultaneously polynomial time log squared space complexity parallel computations ctr bertsch mj nederhof fast parallel recognition lr language suffixes information processing letters v92 n5 p225229 december 2004
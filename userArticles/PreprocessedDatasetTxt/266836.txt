resourcesensitive profiledirected data flow analysis code optimization instruction schedulers employ code motion means instruction reordering enable scheduling instructions points resources required execution available addition driven profiling data schedulers take advantage predication speculation aggressive code motion across conditional branches optimization algorithms partial dead code elimination pde partial redundancy elimination pre employ code sinking hoisting enable optimization however unlike instruction scheduling optimization algorithms unaware resource availability incapable exploiting profiling information speculation predication paper develop data flow algorithms performing optimizations following characteristics opportunities pre pde enabled hoisting sinking exploited ii hoisting sinking code statement driven availability functional unit resources iii predication speculation incorporated allow aggressive hoisting sinking iv path profile information guides predication speculation enable optimization b introduction data flow analysis provides us facts program statically analyzing program algorithms partial dead code elimination pde copyright 1997 ieee published proceedings micro30 december 13 1997 research triangle park north carolina personal use material permitted however permission reprintrepublish material advertising promotional purposes creating new collective works resale redistribution servers lists reuse copyrighted component work works must obtained ieee contact manager copyrights permissions 9085623966 supported part nsf pyi award ccr9157371 nsf grant ccr9402226 intel corporation hewlett packard 16 6 4 20 partial redundancy elimination pre 17 solve series data flow problems carry sinking assignments hoisting expression evaluations sinking assignment eliminates executions assignment compute values dead ie values never used hoisting expression eliminates evaluations expression prior evaluation expression performed using operands existing algorithms optimizations suffer following drawbacks limit usefulness realistic compiling environment optimization phase precedes instruction scheduling phase ffl optimization algorithms insensitive resource information thus possible instructions require functional unit resource execution moved next code motion beneficial since instruction scheduler separating instructions may undo optimization ffl data flow analyses used algorithms incapable exploiting profiling information drive code sinking hoisting instruction schedulers hand use profiling information drive code hoisting sinking ffl data flow analyses incorporate speculation predication enable code hoisting sinking instruction schedulers modern processor architectures exploit speculation 18 predication 13 14 hoisting sinking paper present solutions problems developing data flow analysis techniques pre pde incorporate resource availability path profiling 1 information fur thermore formulations hoisting sinking generalized incorporate speculation based hoisting predication enabled sinking approach performs code motion pre pde optimizations code motion restricted situations resulting code placement points required functional unit resources avail able moreover able perform code motion freely existing pde pre algorithms 16 17 21 5 15 speculative hoisting predication enabled sinking finally path profiling 1 information used guide speculation pred ication particular speculation predication applied overall benefit form increased code optimization along frequently executed program paths greater cost terms introducing additional instructions along infrequently executed program paths a8 9614 5 b c figure 1 resource sensitive code sinking example figure 1 illustrates approach code sinking flow graph figure 1a contains statement node 8 partially dead since value x computed statement used along paths 108731 10876421 sinking statement node 5 shown figure 1b completely eliminate deadness statement note order enable sinking past node 7 necessary predicate statement furthermore sinking performed paths 108731 10876421 along dead code eliminated executed frequently path 10976521 along additional instruction introduced functional unit multiply operation expected busy node 5 idle node 6 resource sensitive sinking place statement node 6 shown figure 1c predication statement required perform sinking past node 7 however sinking past 7 performed frequency path 108731 along dead code eliminated executed greater sum frequencies paths 10976421 10976521 along additional instruction introduced executed solution essentially places statement point required resource available eliminates much deadness possible process also performs predication enabled sinking whenever useful example figure 2 illustrates approach code hoisting flow graph figure 2a contains partially redundant evaluation expression xy node 8 since value x already available node 8 along paths 137810 124678 10 hoisting expression node 5 shown figure 1b eliminate redundancy note order enable hoisting node 7 necessary perform speculative motion x furthermore hoisting performed paths 137810 12467810 along redundancy eliminated executed frequently path 12567910 along additional instruction introduced2 hxy hxy hxy2 hxy hxy hxy c2 hxy hxy xy figure 2 resource sensitive code hoisting functional unit add operation expected busy node 5 idle node 6 resource sensitive hoisting place statement node 6 shown figure 1c speculative execution statement required perform hoisting node 7 however hoisting past 7 performed frequency path 137810 along redundancy eliminated executed greater frequency paths 12467910 12567910 along additional instruction introduced executed solution places expression point required resource available eliminates much redundancy possible process also performs speculative code hoisting whenever useful remainder paper organized follows section 2 first present extensions pde solutions developed knoop et al 16 17 achieve resource sensitive pde pre section 3 present extensions resource sensitive pde pre algorithms incorporate path profiling information drive speculation predication concluding remarks given section 4 resourcesensitive code motion optimization basic approach used algorithms first perform analysis determines whether resources required code statement involved sinkinghoisting available along paths origi natingterminating point information used algorithms pdepre inhibit sink inghoisting along paths required resource free therefore optimization opportunities exploited permitted resource usage characteristics program algorithms presented paper assume program represented using flow graph intermediate code statement appears distinct node nodes introduced along critical edges allow code placement along critical edges first assumption simplifies discussion data flow equations essential techniques work given repre sentation next describe determine whether resource locally free exit entry node local information propagated flow graph determine global resource availability formation subsequent sections present resource analysis applicable acyclic graphs extension loops straightforward based upon following observation resource free loop available hoistingsinking instructions outside loop since instructions never propagated outside loop inside loop functional unit resource fu instruction may issued every c cycles free node n instructions issued c gamma 1 cycles prior n following n issued fu definition guarantees instruction placed n uses fu issuing blocked due unavailability fu notice definition easily extended consider situations one copy resource fu available architecture 21 code sinking pde partial dead code elimination performed sinking partially dead assignments sinking partially dead assignment migrate program points resources required available time remove paths along dead value computed used order ensure sinking performed guaranteed placement points sinking ones resource required execution available first develop resource anticipatability analysis results analysis guide sinking subsequent phase performs resource sensitive code sinking pde resource anticipatability analysis resource anticipatability data flow analysis determines nodes past sinking assignment inhibited lack resources functional unit resource required execute assignment statement anticipatable entry node n path p ns entry terminating node flow graph one following conditions true ffl value variable defined ns entry dead along path p resource needed along path since assignment removed ffl node b along p required resource locally free statement sinkable b required resource available sinking perform resource anticipatability analysis assignment associate following data flow variables node pres n 1 given resource required anticipatable ns exit also anticipatable ns entry otherwise 0 particular pres n 1 statement n define variable referenced defined used n 1 variable defined dead ns entry ie value variable ns entry never used variable dead value dead n 0 n 1 resource required free use moved n sinking otherwise 0 n 1 resource required anticipatable ns exitentry otherwise 0 order compute resource anticipatability perform backward data flow analysis confluence operator shown data flow equations given resource used anticipatable ns exit anticipatable entries successors n resource anticipatable ns entry resource free use n variable defined dead ns entry resource anticipatable ns exit preserved n ngammarants xgammarants n pressn assignment sinking assignment sinking pde framework use next extension framework developed knoop et al 16 pde performed following steps assignment sinking followed assignment elimination first step modified incorporate resource anticipatability information second step remains unchanged assignment sinking consists delayability analysis followed identification insertion points statement moved data flow equations delayability analysis computation insertion points specified analysis xgammadly assignment delayed exitentry node n block n 1 node blocks sinking due data dependences otherwise 0 see delayability analysis allows sinking entry node n required resource anticipatable ns entry allows sinking entry exit n blocked n assignment removed original position inserted points determined follows assignment inserted ns entry delayed ns entry exit inserted ns exit delayed ns exit entries ns successors assignment deletion eliminates inserted assignments fully dead xgammadlys n ngammadlys n xgammadlys owise ngammadlys example figure 3 illustrates algorithms considering sinking assignment node 1 figure 3a control flow graph results resource anticipatability analysis shown node 7 partially shaded indicate resource anticipatable nodes exit entry figure 3b shows outcome delayability analysis notice sinking assignment past node 3 inhibited since resource anticipatable 3s suc cessors insertion point computation identifies three insertion points exit 3 entry 7 exit 8 points assignment dead 7s entry therefore deleted deadness assignment along path 12471011 removed along path 123 5911 removed notice finally placed nodes 3 8 resource locally free 22 code hoisting pre partial redundancy elimination performed hoisting expression evaluations hoisting partially redundant expression e migrate e program points resources required e available time remove e evaluations paths along e computed multiple times making later evaluations e along path redundant order ensure hoisting e performed guaranteed placement points e hoisting ones resource required es execution free perform resource availability analysis results used guide hoisting subsequent phase performs resource sensitive code hoisting pre resource availability analysis resource availability data flow analysis determines nodes hoisting statement inhibited lack resources functional unit resource needed execute operation expression e available entry node n path p start node ns entry one following conditions true ffl node b resource locally free along path b node ns entry variables whose values used e rede fined condition ensures upon hoisting expression along path point would found resource free ffl node b computes e computation variables whose values used e redefined condition essentially c insertion point selection assignment deletion p2 9 10x x resource anticipability analysis resource locally free resource globally anticipable xab p2 9 10x xab x b delayability analysis p2 9 10x x xab xab insertion points xab delayable figure 3 example resourcesensitive pde implies earlier evaluation expression exists along path additional use resource required hoisting along path since expression hoisted eliminated along path perform resource availability analysis expression e associate following data flow variables node n 1 given resource required e available ns entry also available ns exit otherwise 0 particular pres e n 1 statement n define variable used e used e n 1 statement n evaluates expression e evaluation e available ns exit variables used e redefined n es evaluation n 1 required resource free use e n e moved n hoisting otherwise 0 n 1 resource required e available ns entryexit otherwise 0 order compute resource availability perform forward data flow analysis confluence operator resource used expression e available ns entry available exits predecessors n resource available ns exit available ns entry preserved n expression computed n available ns exit resource locally free n xgammaravle expression hoisting expression hoisting pre framework use next modification code motion framework developed knoop et al 17 pre performed two steps downsafety analysis determines points expression evaluations hoisted earliestness analysis locates earliest points expression evaluations actually placed achieve pre steps modified incorporate resource availability information modified equations downsafety earliest ness analysis given equations expression hoisted entryexit node n otherwise expression downsafe node long anticipatable along paths leading node required resource available along paths leading node earliestness analysis sets n 1 including first downsafe point required resource free expression evaluation exists along path expression evaluation placed earliest downsafe point points identified boolean predicates ngammadsafeearliest e xgammadsafeearliest e resource availability analysis2 9 10resource locally free resource globally available b safety analysis ab safe2 9 10earliest points pre transformation c earliestness analysis figure 4 example resourcesensitive pde ngammaerlye n usedem xgammaerlye example figure 4 illustrates al gorithms figure 4a results resource availability analysis shown since resource available node 11 downsafety analysis propagate backwards shown figure 4b node 6 downsafe resource available node hand node 8 downsafe resource available node earliest ness analysis identifies nodes 5 9 7 8 first nodes downsafe either resource expression evaluation exists node 5 7 final placement expression shown figure 4c traditional approach would hoisted expression node 9 node 6 3 profiledirected resourcesensitive code motion optimization section show additional opportunities pre pde optimizations exploited enabling aggressive code hoisting sink ing speculative code hoisting performed enable additional opportunities pre predication based code sinking employed enable additional opportunities pde however speculative hoisting predication based sinking result greater degree optimization along program paths result introduction additional instructions along program paths words greater degree code optimization achieved program paths expense introduction additional instructions along program paths generating code vliw superscalar architectures speculation predication routinely exploited generate faster schedules along frequently executed paths expense slower schedules along infrequently executed paths 7 12 11 however optimization frameworks today unable exploit principle section show perform pre pde optimizations using speculation predication frequently executed paths optimized greater degree expense infrequently executed paths path profiling information used evaluate benefits costs speculation predication program paths subsequent sections describe code hoisting sinking frameworks use path profiling 1 information enable speculation predication based hoisting sinking inhibiting hoisting sinking using resource availability anticipata bility information results optimization algorithms aggressive traditional algorithms 16 17 time appropriate vliw superscalar environment resource sensitive tradeoff quality code frequently executed paths infrequently executed paths although techniques describe based upon path profiling information also adapted edge profiles since estimates path profiles computed edge profiles 19 furthermore present versions algorithms apply acyclic graphs however extensions required handle loops straightforward found 10 9 algorithms based upon following analysis steps first resource availability anticipatabil ity analysis performed next determine cost benefit enabling speculation predication various spilt points merge points flow graph respectively benefit estimation increased optimization program paths cost estimate increase number instructions along program paths selectively enabling hoisting sinking program points based upon costbenefit analysis exploit optimization opportunities traditional algorithms knoop et al 16 17 exploit inhibiting optimization opportunities result movement code program points resource required instructions execution free 31 path profile directed pde mentioned earlier resource anticipatability analysis described section 21 remains unchanged must performed first next costbenefit analysis incorporates resource anticipatability information uses path profiles performed results analysis used enable predication enabled sinking selected join points next phase finally extension sinking framework presented section 21 used perform resourcesensitive profileguided pde costbenefit analysis consists three steps availability analysis identifies paths leading node along statement available sinking ie sinking blocked data dependences various program points b optimizability analysis identifies paths originating node along statement optimized value computed live sinking required removal inhibited lack free resource presence data dependences c costbenefit computation identifies paths join point along additional optimization achieved additional instruction introduced predication based sinking enabled join point summing frequencies respective paths provided path profiles values cost benefit obtained set paths identified availability optimizability analysis represented bit vector bit corresponds unique path entry exit acyclic flow graph facilitate computation sets paths node n flow graph associate bit vector onp sn bit corresponds unique path set 1 node belongs path otherwise set 0 steps analysis described next availability analysis data flow equations availability analysis given n one bit variable 1 path n along available sinking ns entryexit otherwise value bit vector holds set paths along value n gamma av l 1 ns entryexit forward data flow analysis confluence operation used compute values entry point flow graph availability value set 0 changed 1 statement encountered set 0 statement blocks sinking encountered equations pres n one bit variable 10 preserves n data anti output flow dependent upon entry node n n 0 set paths set null 0 otherwise paths n gamma aps computed unioning sets paths along available exit one ns predecessors ie unioning p p predecessor n order ensure paths pass n considered result intersected onp sn value x gamma aps n onp sn n contains n gamma aps n n block onpsn xgammaavl m1 optimizability analysis n one bit variable associated ns entryexit 1 path n along dead sinking may required remove deadness feasible ie inhibited lack resources presence data dependences otherwise value 0 backward data flow analysis confluence operation used compute values order ensure sinking feasible results availability analysis resource antici patability analysis used example variable v computed dead ns exit set true n true deadness eliminated sinking ns exit blocked data dependences v dead among conditions also check n true sinking allowed resource required execution along paths v dead free data flow equations one bit variable 1 variable v fully dead ns entryexit path starting n along current value v used otherwise value 0 n bit vector holds set paths along value opt 1 ns entryexit entryexit node n n n gamma av l 1 n set onp sn otherwise paths x gamma ops n computed unioning sets paths along partially dead removable entry one ns successors ie unioning gamma rps p p successor n order ensure paths pass n considered result intersected onp sn let v variable defined ie onpsn ngammaopt m1 computation cost enabling predication partially dead statement allow movement merge point n determined identifying paths merge point along unoptimized program executed optimized program predicated version executed furthermore resource anticipatability analysis indicates along paths predicated version placed resource needed available sum execution frequencies paths indicated path profiles cost benefit enabling predication partially dead statement allow movement merge point n determined identifying paths merge point along unoptimized program executed optimized program executed furthermore resource anticipatability analysis indicates sinking required achieve benefit inhibited lack resources sum execution frequencies paths indicated path profiles benefit code sinking framework results costbenefit analysis incorporated code sinking framework predication code statement enabled respect merge points resources available benefit predication enabled sinking determined greater cost predication enabled sink ing framework extension code sinking framework presented section 21 data flow equations enabling predication presented next predication enabled sinking allowed join nodes cost sinking less benefit derived sinking addition sinking also enabled join node enabled earlier join node ensure benefits sinking computed earlier join node fully realized epreda join point delayability analysis section 21 modified incorporate results enabling predication shown join point predication based sinking enabled long assignment available along path opposed paths section 21 allowed propagate join node ngammadlya n presa n owise ngammadlya n n join consider paths contribute cost benefit sinking assignment x b node 8 past join node 7 flow graph figure 1a availability analysis determine paths initially contain subpath 1087 ones along statement available sinking join node 7 optimizability analysis determine paths end subpath 731 optimizable paths end 76421 76521 unoptimizable although x b dead along subpath 76421 lack resources inhibits sinking necessary eliminate deadness eliminate deadness along path x b must sunk past node 6 make fully dead prevented lack free resource based upon analysis path benefits sinking past node 7 108731 paths along cost additional instruction introduced 10976421 10976521 let us assume execution frequency path benefits greater sum frequencies two paths experience additional cost case predication based sinking enabled node 7 modified sinking framework allow sinking past node 7 resulting code placement shown figure 1c 32 path profile directed pre resource availability analysis described section 22 remains unchanged must performed first next costbenefit analysis incorporates resource availability information uses path profiles performed results analysis used enable speculation based hoisting selected split points next phase finally extension hoisting framework presented section 22 used perform resourcesensitive profileguided pre costbenefit analysis consists three steps anticipatability analysis identifies paths originating node along expression anticipatable thus hoisted ie hoisting blocked data dependences lack resources needed execute expression b optimizability analysis identifies paths leading node along expression optimized prior evaluation expression exists along paths values variables used expression modified since computation expres sion c costbenefit computation identifies paths split point along additional optimization achieved additional instruction introduced speculation based hoisting enabled split point summing frequencies respective paths provided path profiles values cost benefit obtained due space limitations omit detailed data flow equations first two steps costbenefit analysis compute sets paths ops e n however principles used computation analogous used section 31 cost enabling speculation partially redundant expression e allow movement conditional split point n determined identifying paths conditional along e executed optimized program executed unoptimized program furthermore resource availability analysis indicates required resource available allow placement e along path sum execution frequencies paths indicated path profiles cost benefit enabling speculation partially redundant expression e allow movement conditional split point n determined identifying paths conditional along redundant execution e eliminated furthermore hoisting required remove redundant execution e paths inhibited due lack resources sum execution frequencies paths indicated path profiles benefit incorporation speculation partial redundancy framework section 22 carried follows results costbenefit analysis incorporated code hoisting framework speculation expression enabled respect conditionals resources available benefit speculation enabled hoisting determined greater cost speculation enabled hoisting equations enabling speculation quite similar enabling predication modification downsafety analysis section 22 follows split point speculative hoisting expression enabled long expression anticipatable along path opposed paths section 22 allowed propagate split point consider paths contribute cost benefit hoisting expression xy node 8 past split node 7 flow graph figure 2a anticipatabil ity analysis determine paths ending subpath 7810 ones along expression xy anticipatable hoisting split node 7 opti mizability analysis determine paths start subpath 137 optimizable paths start 12467 12567 unop timizable although x evaluated along subpath 12467 lack resources inhibits hoisting necessary take advantage evaluation eliminating redundancy eliminate redundancy along path x must hoisted node 6 make fully redundant prevented lack free resource based upon analysis path benefits hoisting node 7 137810 paths along cost additional instruction introduced 12467910 125679 10 let us assume execution frequency path benefits greater sum frequencies two paths experience additional cost case speculation based hoisting enabled node 7 modified hoisting framework allow hoisting node 7 resulting code placement shown figure 2c 33 cost profile guided optimization important component cost analysis described preceding sections depends upon number paths considered costbenefit analysis general number static paths program millions ever practice number paths need considered costbenefit analysis quite small first paths nonzero execution counts need considered second paths given function considered one time figure 5 characteristics path profiles spec95 integer benchmarks shown bar graph shows 65 functions executed 5 paths nonzero frequency found 14 functions 100 paths moreover function greater 1000 paths nonzero execution count one approach reducing number considered analysis include enough paths nonzero frequency paths account majority execution time program first table figure 5 shows number functions contain 5 10 50 100 1000 paths nonzero frequency changes consider enough paths account 100 95 80 program execution time see number functions require 5 paths increases substantially 1694 2304 number functions require hundred paths reduces significantly 35 1 second table shows maximum number paths considered among functions maximumvalue reduces sharply 1000 103 paths conisdered account less 100 program execution time 10 9 illustrate solution costbenefit analysis described earlier easily adapted situation subset paths nonzero frequency considered concluding remarks paper presented strategy pre pde code optimizations results synergy code placements found optimization instruction scheduling considering presence selection code placement points addition optimization driven code hoisting sinking also takes advantage speculation predication till performed instruction scheduling finally data flow algorithms drive application speculation predication based upon path profiling formation allows us tradeoff quality code favor frequently executed paths cost sacrificing code quality along infrequently executed paths techniques described also adapted application optimizations elimination partially redundant loads partially dead stores loops 3 8 extending algorithms consider register pressure optimization number paths nonzero execution frequency number functions 649 86 4 14 number number functions paths 100 95 80 15 1694 2022 2304 total max exe time paths 100 1000 figure 5 characteristics path profiles spec95 integer benchmarks r efficient path profiling partial dead code elimination using slicing transformations array dataflow analysis loadstore optimizations superscalar architec tures using profile information assist classic code optimiza tion practical adaptation global optimization algorithm morel renvoise vliw compilation techniques superscalar environment trace scheduling technique global microcode compaction code optimization side effect instruction scheduling path profile guided partial dead code elimination using predi cation path profile guided partial redundancy elimination using spec ulation region scheduling approach detecting redistributing paral lelism superblock effective technique vliw superscalar compilation highly concurrent scalar processing hpl playdoh architecture specification version 10 global optimization suppression partial redundancies partial dead code elimination lazy code motion sentinel scheduling vliw superscalar pro cessors data flow frequency analysis critical path reduction scalar processors data flow analysis model checking tr highly concurrent scalar processing region scheduling using profile information assist classic code optimizations lazy code motion sentinel scheduling superblock vliw compilation techniques superscalar environment partial dead code elimination practical adaption global optimization algorithm morel renvoise critical path reduction scalar programs data flow frequency analysis efficient path profiling array data flow analysis loadstore optimizations finegrain architectures partial dead code elimination using slicing transformations global optimization suppression partial redundancies data flow analysis model checking path profile guided partial dead code elimination using predication code optimization side effect instruction scheduling ctr j adam butts guri sohi dynamic deadinstruction detection elimination acm sigops operating systems review v36 n5 december 2002 sriraman tallam xiangyu zhang rajiv gupta extending path profiling across loop backedges procedure boundaries proceedings international symposium code generation optimization feedbackdirected runtime optimization p251 march 2024 2004 palo alto california max hailperin costoptimal code motion acm transactions programming languages systems toplas v20 n6 p12971322 nov 1998 youtao zhang rajiv gupta timestamped whole program path representation applications acm sigplan notices v36 n5 p180190 may 2001 raymond lo fred chow robert kennedy shinming liu peng tu register promotion sparse partial redundancy elimination loads stores acm sigplan notices v33 n5 p2637 may 1998 vikki tang joran siu alexander vasilevskiy marcel mitran framework reducing instruction scheduling overhead dynamic compilers proceedings 2006 conference center advanced studies collaborative research october 1619 2006 toronto ontario canada mary lou soffa complete removal redundant expressions acm sigplan notices v33 n5 p114 may 1998 john whaley partial method compilation using dynamic profile information acm sigplan notices v36 n11 p166179 11012001 mary lou soffa loadreuse analysis design evaluation acm sigplan notices v34 n5 p6476 may 1999 mary lou soffa complete removal redundant expressions acm sigplan notices v39 n4 april 2004
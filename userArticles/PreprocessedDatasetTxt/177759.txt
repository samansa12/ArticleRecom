controlled grammatic ambiguity new approach ambiguity contextfree grammars presented within approach lr techniques generalized solve following problems large classes ambiguous grammars construction parser accepts sentences generated grammar always terminates linear time identification structural ambiguity finite set pairs partial parse trees constructed pair two partial parse trees semantically equivalent ambiguity grammar semantically irrelevant user may control parser generation get parser finds specific parse trees sentences generalized lr techniques still guarantee resulting parser accepts sentences terminates linear time input b introduction unambiguous grammars powerful lr techniques large classes verify unambiguity construct complete linear time parsers ie parsers accept full languages terminate linear time inputs new approach ambiguity generalize lr techniques deal large classes ambiguous grammars well thus characterizing ambiguity constructing complete linear time parsers homemade reprent typeset using l e x document style acmtrans shows published version intended page references still intact figures text fonts theoretically important material deferred electronic appendix work done author oxford university dimacs supported mainly nato grant danish research council partly danish research academy authors address university copenhagen department computer science univer sitetsparken 1 2100 kbenhavn denmark email mthorupdikudk permission copy without fee part material granted provided copies made distributed direct commercial advantage acm copyright notice title publication date appear notice given copying permission association computing machinery copy otherwise republish requires fee andor specific permission c ambiguous grammars long considered relevant connection programming languages noticed aho johnson ullman 1975 ambiguous grammars often simpler natural unambiguous counterparts moreover often parsed efficiently due smaller parse trees aho johnson ullman 1975 independently earley 1975 standard approach developed construction linear time parsers ambiguous grammars approach starts applying lr technique grammar ambiguous resulting parser nondeterministic due conflicts action table deterministic lr parser obtained resolving conflicts possibly semiautomatic way using disambiguating rules stated aho johnson ullman 1975 problem approach resolved parser might complete fact noticed soisalonsoininen tarhio 1988 might even terminate input simple example problematic grammar 1 lll llll idea behind last production reduce number productions large parse trees roughly factor five applying lr1 technique grammar get following nondeterministic lr1 parser state action goto l suppose resolve conflicts using heuristic classic parser generator yacc johnson 1975 choosing shifts reductions presented sentence like resolved parser make two shifts arriving state 4 input stuck thus resulting parser complete paper present general techniques resolving conflicts nondeterministic lr parser resulting deterministic parser guaranteed complete work linear time even problematic grammar 1 techniques find good lr1 parser example could parser p 1 entry selects first action alternative good resolution instead shifting state 2 input l choose reduce lll despite fact grammar 1 leftrecursive possible us find good parser lookahead length 2 needed given nondeterministic parser constructed canonical ll2 technique grammar 1 techniques find good resolution fact selects exactly parse tree lr1 parser p 1 basic idea testing resolved parser good see set simple parse tree rewriting rules rewrite parse tree parse tree sentence found parser trivially existence rewriting rules implies resolved lr parser complete moreover turns case resolved parser always terminate linear time controlled grammatic ambiguity delta 3 simple rewriting rules pairs u v partial parse trees u v root frontier parse tree rewritten replacing occurrence v u v occur u v rewrite loosely speaking show decidable exists finite set rewriting rules whose embedding original nondeterministic parser implies rewrite parse tree parse tree sentence found parser case parser complete always terminates linear time continuing example 1 connection resolved parser p 1 techniques construct following set rewriting rules using rewriting rules techniques prove p 1 complete works linear time mentioned specialized techniques presented recognition resolved lr parsers complete work linear time aho johnson ullman 1975 found simple combinatorial test works classes parsers demers 1974 contains test based merging nonterminals removing trivial productions neither techniques apply grammar 1 test good resolutions generalized lr techniques construct complete linear time parsers large classes ambiguous grammars also finite sets rewriting rules characterizing structural biguity knuth 1965 presented canonical lr technique knuth 1965 described general known technique testing unambiguity grammars similarly techniques general known characterizing finitely generated ambiguity obvious application follows suppose want use ambiguous grammar semantic definition formal language example programming language specification language want refer specific parser need ensure ambiguity grammar semantically irrelevant ie parse trees sentence semantically equivalent example need avoid ambiguity based dangling else ambiguity based algebraic identities like associativity perfectly okay far proving ambiguity ambiguous grammar semantically irrelevant done hand blikle 1989 however rewriting rules need verify two partial parse trees semantically equivalent rewriting preserves semantics hence parse trees sentence must semantically equivalent advantages semantically irrelevant ambiguity theoretical semantically irrelevant ambiguity exhibits real freedom parsing freedom exploited current paper acm transactions programming languages systems vol 16 3 may 1994 pages 10241050 construction deterministic parsers considered however technical report thorup 1992 based results paper theory developed construction nondeterministic complete linear time parsers parsing freedom parsers used example connection incremental parsing evaluation set rewriting rules provides exact description canonical parse trees selected parser sentences firstly canonical parse trees exactly parse trees cannot rewritten ie set parse trees rewriting rule u v contains occurrences v secondly construc tively given parse tree sentence corresponding canonical parse tree found repeated rewriting rewriting rules thus e 1 read p 1 right associative use llll techniques allow user state priorities supplying rewriting rules thereby controlling parser generation towards desired set canonical parse trees always techniques guarantee generated parser complete works linear time comparing ambiguity resolution based priorities traditional disambiguating rules facilitated yacc aho sethi ullman 1986 johnson 1975 one difference course already mentioned guarantees completeness termination given techniques hand grammars techniques report failure despite existence good resolutions would never happen yacc yacc takes responsibility generated parsers another difference rewriting rules independent actual parsing technique example set e 1 used lr1 ll2 techniques independence makes rewriting rules resemble ambiguity resolutions like given syntactic metalanguage sdf heering hendriks klint rekers 1990 ambiguity resolution achieved discarding parse trees nonminimal respect fixed priority ordering parse trees parameterized rewriting rules usersupplied partial ordering productions however sdf doesnt guarantee unique minimal parse also besides ordering productions mechanism sdf allows certain parses disallowed outright priority conflicts consequently disambiguated parser may incomplete nondeterministic moreover exponential bounds complexity paper basically theoretical classes grammars deal defined mathematically future experience tell well cover practical applications examples simple showing techniques enriched class grammars handled automatically several nice ambiguous constructs examples would easy hand identify ambiguity construct complete linear time parser fact might case single naturally occurring ambiguity problem dealing ambiguous grammars lie deliberate use ambiguous constructs designer grammar rather problem ensure hidden ambiguity real life problem could occur say grammar big written parts several different authors even compiler experts claim deal acm transactions programming languages systems vol 16 3 may 1994 pages 10241050 controlled grammatic ambiguity delta 5 grammars occurring practice problem still relevant dynamic systems like obj futatsugi goguen jouannaud meseguer 1985 compiler tyros may define languages problem solved lr techniques large classes unambiguous grammars generalization solved large classes ambiguous grammars well order keep presentation short paper focussed around canonical lr1 technique knuth 1965 theoretically beautiful lr techniques however difficult translate results techniques moreover touch semantic aspects peripherally key handling ambiguity generalize focus sentences derived productions x grammar symbol deriving string ff grammar symbols x ff derived production paper divided follows section 2 describes basic notion grammars terms derived productions section 3 reviews parsing modified deal derived productions two preliminary sections section 4 formalizes idea rewriting rules rewriting parse trees canonical parse trees found parser section 5 contains exact statement main result includes precise definition meant embedding rewriting finite nondeterministic parsers constructed lr techniques section 6 discusses relation traditional disambiguating rules priorities section 7 discusses problems dangling else section 8 gives general outline generalizations lr techniques moreover gives overview appendices paper appendices contain details generalization canonical paper selfcontained preliminary definitions rather dense reader referred aho sethi ullman 1986 sippu 1988 sippu soisalonsoininen 1990 standard text grammars parsing paper shortened version thorup 1993 part reader referred examples discussions 2 grammars terms derived productions first noticed algebraically blikle thorup 1990 blikle tarlecki thorup 1991 key working formally ambiguity grammars focus derived productions natural generalizations sentential forms turn generalizations sentences review basic concepts contextfree grammars terms derived productions grammar g consists finite set v symbols together finite set p pairs x ff x belongs v ff possibly empty string symbols v refer symbols v grammar symbols pairs p productions production x ff written xff refer x leftside ff rightside production grammar symbols divided terminals nonterminals one latter distinguished start symbol grammar wellformed leftside symbols productions nonterminals always understand underlying grammar talk grammar symbols productions etc moreover adopt following notational convention aho sethi ullman 1986 b c stand nonterminals xy z acm transactions programming languages systems vol 16 3 may 1994 pages 10241050 grammar symbols ff fi fl possibly empty strings grammar symbols generally reserved denote empty string thus following simple example grammar later examples productions grammar given explicitly grammar symbols understood symbols used productions start symbol leftside first production terminals grammar symbols typewriter font thus grammar 2 nonterminals start symbol terminals b c definition 1 derived productions pairs x ff x grammar symbol ff string grammar symbols derived production x ff written x ff set derived productions defined recursively follows x grammar symbol x x derived production x ffy fl derived production fi production x fffifl derived production example bc derived production grammar 2 notice derived productions required leftside nonterminal productions leftside rightside refers first second coordinate respectively dropping distinction terminals nonterminals turns convenient following definitions algo rithms proofs besides used algebraically blikle thorup 1990 blikle tarlecki thorup 1991 concept derived productions used ballance butcher graham 1988 connection gram matical abstraction often ignore notational difference derived productions productions writing statements like productions derived productions formally written something like productions xff x ff derived production terms derived productions sentential form string ff grammar symbols denoting start symbol ff derived production sentence sentential form consisting terminals thus claimed derived productions general sentential forms sentences sentences interested way derived production generated recursive definition done terms parse trees parse trees derived productions form base reasoning remainder paper therefore introduced care terminology usual parse tree ordered rooted tree node labeled either grammar symbol since parse tree ordered sons nonleaf node n given ordered sequence nodes labeled play special role allowing us internal nodes empty sequences sons precisely leaf may labeled single son node n single son labeled interpret sequence sons empty concerning general labeling required internal node labeled x sons labeled production root acm transactions programming languages systems vol 16 3 may 1994 pages 10241050 controlled grammatic ambiguity delta 7 symbol parse tree refer label root frontier refer sequence labels non leaves parse trees depicted root top sons ordered left right thus grammar 2 following parse trees root symbol frontier b clearly x ff derived production parse tree root symbol x frontier ff case say parse tree x ff x ff derived production generated example 2 u 2 generate b correspondingly parse trees sentential forms parse trees root symbol start symbol parse trees sentences parse trees moreover frontier consists terminals two parse trees like 2 u 2 generating derived produc tion say equivalent underlying grammar said ambiguous thus grammar 2 ambiguous traditionally one says grammar ambiguous grammar two parse trees sentence clearly grammar 2 ambiguous also respect notion ambiguity notice however traditional notion ambiguity strictly weaker possible grammar ambiguous respect derived productions respect sentences grammar symbols used parse tree sentence study parse trees plays major role paper need precise definitions parse tree related concepts parse tree said trivial contains one node subparse tree relation parse trees defined least partial ordering ie least reflexive transitive relation following property let parse tree n non node moreover let 1 subtree excluding nodes strictly descending n let 2 subtree containing nodes descending n including n 1 2 subparse trees construction illustrated x label common node n 1 2 notice n leaf 2 trivial similarly n root n say obtained rooting 2 leaf n 1 important notice subparse tree relation contrast normal subtree relation respects production structure parse trees example u 2 subtree subparse tree 2 according definition sub parse tree relation say parse tree minimal set parse trees proper subparse tree hence example set parse trees minimal parse trees trivial parse trees finally convenient introduce constructor pt parse trees x grammar symbol ptx denote trivial parse tree whose single node labeled x let production parse trees root symbols denote parse tree root symbol x subparse trees descending sons root thus continuing example grammar 2 3 parsers section review concepts parsing modified deal derived productions modification straightforward using ideas incremental parsing error recovery ghezzi mandrioli 1979 pennello deremer 1979 however knowing exact way modification done crucial understanding rest paper thus parsing process recognizing derived productions sentences selecting parse trees generate parser automaton takes input input production meaning pair x ff sometimes written x ff x grammar symbol ff sequence grammar symbols three possibilities 1 parser successfully accepts input production derived production return parse tree generating x ff 2 parser terminates unsuccessfully might case even input production derived production 3 parser even terminate parser linear time parser terminates inputs time linear length input production moreover parser complete successfully finds canonical parse tree derived production always want parsers complete linear time parsers refer parsers implementations grammar given parser p refer parse trees return successfully pcanonical parse trees possibly dropping p specific parser un derstood thus completeness p means derived production generated pcanonical parse tree traditional lr parsers easily modified parse derived productions instead sentences paper focus lr1 parsers review definition lr1 parsers modified derived productions parser p grammar characterized following components finite set states table init grammar symbols states partial table goto states grammar symbols states action table action states input symbols actions controlled grammatic ambiguity delta 9 input symbols mean grammar symbols plus extra symbol actions mean members set productiong notice relative traditional lr1 parsers sentences introduced table init take care leftside longer fixed specific start symbol moreover tables goto action defined grammar symbols regardless whether terminals nonterminals parsing p proceeds series configurations form grammar symbols states first component configuration called stack second component called input buffer last state stack referred state first input symbol xm1 input buffer referred input symbol action refer actionim xm1 ie entry action table given state input symbol ff input production initial configuration configuration 0 initx ff next configurations determined action current configuration effects different actions follows accept valid current configuration form parsing completed suc cessfully accepting input production derived production parse tree input production constructed parsing described later shift valid current configuration form ff xfi x grammar symbol gotoi x defined next configuration becomes ff x gotoi x fi reduce valid current configuration form subsequent configuration becomes ff x gotoi error simply means terminate unsuccessfully giving input production parser p wellformed input production ever try invalid action notice parsing input production leftside x encounter configuration state sequence x grammar symbols stack order define parse tree constructed accepting parsing associate parse tree grammar symbol stack grammar symbol x parse tree always x root symbol recall initial configuration grammar symbols stack parsing shifts symbol x input buffer stack associate ptx x interesting case parser reduces production xx 1 reduction final segment sequence grammar symbols stack reduction replace x acm transactions programming languages systems vol 16 3 may 1994 pages 10241050 parse trees associated reduction reduction parse tree associated x parsing accepts returns parse tree associated single grammar symbol stack definition lr1 parsers derived productions illustrated example based grammar consider following lr1 parser grammar 3 r stands accept shift reduce respectively init state action goto given input production b 1lambdab lambdab carry following parsing stack inpbuf action thus following parse tree p 3 canonical parse tree b traditional techniques construction lr parsers work classes unambiguous grammars however section 8 appendices acm transactions programming languages systems vol 16 3 may 1994 pages 10241050 controlled grammatic ambiguity delta 11 generalized construct complete linear time lr parsers large classes ambiguous grammars well notice generalization parsers work derived productions rather sentences rightly viewed simplification example seminal paper knuth 1965 knuth showed grammar unambiguous grammar symbols used parse trees sentences complete linear time lr1 parser sentences constructed exists context derived production statement simplifies grammar unambiguous complete linear time lr1 parser derived productions constructed exists words get rid nojunk requirement original formulation 4 prioritized parsing done prelimary sections ready introduce prioritized pars ing key concept automatic verification completeness parsers formalizes rewritings discussed introduction parse tree pair ordered pair equivalent parse trees ie parse trees root frontier loosely speaking parse tree pair 0 substitution parse tree pair 0 results 0 1 replacing 0 occurrence 1 0 1 formally speaking case exists numbers k p parse trees u parse tree 0 results first rooting u ith non leaf subsequently rooting obtained parse tree kth non leaf u figure illustrates construction figure x derived production generated 0 1 derived production generated 0 1 given set e parse tree pairs e oe denote closure e substitution transitivity definition 2 set e parse tree pairs prioritizing e oe wellfounded infinite descending sequence ie infinite sequence 0 parse trees strict partial ordering two e oe minimal parse trees equivalent moreover p parser pcanonical parse trees coincide e oe minimal parse trees e prioritizes p thus say parse tree higher priority parse tree u whenever pcanonical parse trees exactly highest acm transactions programming languages systems vol 16 3 may 1994 pages 10241050 priority term chosen later user allowed manipulate set e thereby showing priorities parser p proposition 41 set e parse tree pairs prioritizes parser p p complete proof let x ff derived production definition x ff generated least one parse tree u since e oe wellfounded e oe minimal hence pcanonical parse tree u 2 e oe e oe relates equivalent parse trees pcanonical parse tree x ff sometimes think definition prioritized parsers terms rewriting say parse tree pair u rewrites parse tree u 0 parse tree 0 substitution notice u 0 uniquely defined terms u 0 u might occur different positions u 0 let e set parse tree pairs prioritizing parser p definition prioritizing says given parse tree long possible rewrite parse tree pairs e eventually arrive p canonical equivalent moment might seem natural think prioritizing way however algebraic description terms orderings forms better base rest paper typically interested expansions e oe orderings expressible terms rewriting techniques presented section 8 appendices find prioritizing sets large classes grammars grammar 3 page 10 could return j j prioritizes parser p 3 found page 10 shown two different maximal rewriting sequences e 3 starting parse tree indices indicate subparse trees replaced j j acm transactions programming languages systems vol 16 3 may 1994 pages 10241050 controlled grammatic ambiguity delta 13 notice number rewritings needed transform parse tree canonical equivalent unique observe prioritizing set characterizes ambiguity completely sup pose example want show ambiguity grammar irrelevant respect semantics prioritizing set e given sufficient check parse tree pair e two parse trees semantically equivalent ie rewriting pair preserves semantics follows consider two equivalent parse trees u definition prioritizing rewritten common pcanonical equivalent v hence semantically equivalent v hence connection grammar 3 prioriting set e 3 ambiguity irrelevant respect semantics semantics associate associative operation production ee e characterization ambiguity grammar somewhat related work tomita 1986 rekers 1991 billot lang 1989 operate concepts shared forests local ambiguity subsumed concept substitution definition substitution shared forests corresponds case u trivial ie local ambiguity corresponds case u trivial tomita 1986 rekers 1991 billot lang 1989 concepts used compact cubic representation different parse trees given sentence whilst prioritizing sets characterizes ambiguity whole grammar hand techniques works restricted classes grammars finite prioritzing sets found set parse tree pairs prioritizes parser implies set canonical parse trees exactly set parse trees subparse trees amongst second coordinates prioritizing set thus fact set p 3 canonical parse trees exactly set parse trees containing j j subparse tree notice concise characterization rightassociative parsing appeared previously literature however somewhat related characterization proposed independently maddox personal communi cation 1993 characterization possible due change focus sentences derived productions prioritizing parsing grammar mean finding finite set e parse tree pairs parser p e prioritizes p thus prioritizing parsing grammar identify ambiguity characterize complete parser next section state precisely extent techniques presented section 8 appendices help us prioritizing parsing grammars section 7 shall see grammars like containing danglingelse finite prioritizing set claimed techniques deal successfully natural grammars lr acm transactions programming languages systems vol 16 3 may 1994 pages 10241050 techniques deal limited important classes unambiguous grammars ie grammars empty prioritizing sets parse tree pairs result paper techniques generalized deal safely correspondingly limited important classes ambiguous grammars finite prioritizing sets parse tree pairs relevance new classes indicated simply showing concrete natural ambiguous grammars like one 3 deal 5 main result following assume lr techniques modified work derived productions instead sentences focussing modified version canonical lr1 technique knuth 1965 henceforth referred clr1 technique change name canonical lr clr much brevity avoid confusion stemming overloading term canonical clr1 technique formally described appendix b given grammar traditional lr techniques modified deal derived productions try construct complete linear time lr parser unfortunately never successful grammar ambiguous techniques always succeed generating generally nondeterministic lr parser successful exactly parser deterministic thus failure shows conflicts generated action table ie entries containing one action generated nondeterministic parser always property appropriate parsing construct parse tree sentence emphasize property refer nondeterministic parsers generated lr techniques universal parsers notice universality implies completeness case universal parser deterministic consider example grammar grammar could relevant connection change representation ie wanted use equations like x theta however chosen richness ambiguity applying technique get following nondeterministic lr1 parser init state actions goto determinization universal lr parser u mean deterministic lr parser p obtained resolving conflicts action table ie entry e action table u select canonical action acm transactions programming languages systems vol 16 3 may 1994 pages 10241050 controlled grammatic ambiguity delta 15 denotes set actions entry e action table u example 4 let p 4 denote determinization u 4 derived selecting first action entry p 4 complete linear time parser universal parsers generated lr techniques including llk lalrk clrk technique satisfy nojunk property actions entry action table used parsing corresponding parse tree hence whenever resolve conflict action table exclude parse trees thus unambiguous grammar get conflicts action table hope finding complete determinization let u universal lr parser moreover let u parse tree pair 6 u consider unique parsings constructing u let c first configuration two parsings carry different actions b respectively let e entry action table corresponding c triple e b called projection u parse tree pair u parse tree pairs two identical parse trees projection undefined denoted take example following parse tree pair grammar f f f ff parse trees 4 constructed following parsings u stack buffer action stack buffer action thus projection 4 u 4 7 f shift reduce ef ordering universal lr parser u represented associating entry e action table strict partial ordering e u e thereby defines strict partial ordering parse trees fix two equivalent different parse trees u let e b projection u u u 2 b 2 e notice required e strict partial orderings definition guarantees fact strict partial ordering also notice e set parse tree pairs ordering u contains e unique least ordering namely entrywise transitive closure projection e u case say acm transactions programming languages systems vol 16 3 may 1994 pages 10241050 universal parser ordering spanned span universal parser ordering given universal lr parser u ordering determinization p say p minimal entry e p e minimal e thus p minimal pcanonical parse trees ominimal definition 3 let e set parse tree pairs u universal lr parser p determinization u spans ordering u p minimal definition extremely important following loosely speaking says given set e parse tree pairs prioritizing parser p e uprioritizes p finite universal parser u see rewritings never loop canonical parse tree rewritten continuing example grammar 4 set f f f ff ff f moreover denote 4 ordering u 4 obtained ordering actions entries action table u 4 order already listed notice pair 4 4 e oe techniques section 8 appendices ascertain e 4 prioritizes p 4 e 4 spans 4 moreover clear p 4 minimal 4 thus follows e 4 u 4 prioritizes p 4 also techniques verify p 4 works linear time p 4 complete linear time parser finding parser grammar 4 completely trivial suppose example apply wartons heuristic wharton 1976 conflict resolution u 4 prefers reductions shifts state choose reduce ef instead shifting hence resulting parser never terminate input production like f ff fact derived production main theorem 51 given grammar g finite set e parse tree pairs universal parser u obtained one various lr techniques decide exists determinization p u finite set e parse tree pairs e e uprioritizes p case find p e p linear time parser e minimal given p role e allow user impose priorities parser construction continuing example grammar 4 set e set first two parse tree pairs e 4 specify generated parser cyclefree leave open whether left right associative admittedly order keep size presentation prove main theorem 51 detail clr1 technique done constructively section 8 together appendices following talk unspecified technique understood talking generalization clr1 technique controlled grammatic ambiguity delta 17 6 disambiguating priorities section discuss detail priorities e main theorem 51 used like traditional rewriting rules discussion based example stemming aho sethi ullman 1986 pp 251 254 taken real world grammar equation typesetting language eqn kernighan cherry 1975 consider grammar aim construct complete linear time parser uses special case production ee sube supe connection substring c sub c sup c input cases specified setting z z z z z z z z z z z z z z z z z z xxxx x z z last three pairs priorities idea behind set technique choosing first coordinates hence effect priority exclude second coordinates canonical parse trees technique successfully find complete linear time parser prioritized superset e adequate first coordinates place lambdas looking priorities returned together parser see exactly technique resolved various associativity precedence questions yacc johnson 1975 based lalr1 technique sense easier construct parser grammar 5 satisfying specification yacc general heuristic prefers shifts reductionsthe heuristic lead incomplete parser grammar 1 introduction thus need get correct parser add disambiguating rule saying prefer reduce ee sube supe rather ee supe technically told yacc listing production ee sube supe first declaration grammaras already seems one needs quite familar yacc lr1 techniques order feel confortable conflict resolution serious complaint risk somebody else could worked gram mar adding disambiguating rules suppose example somebody acm transactions programming languages systems vol 16 3 may 1994 pages 10241050 worked grammar special case production ee sube supe introduced would made perfect sense herhim decide sub sup left associative beof precedence technically told yacc via declaration left sub sup declaration overrules heuristic prefering shifts reductions without going details applied full grammar 5 declaration implies conflict shifting reducing settled favor reducing contradict preference reducing ee sube supe rather ee supe implies never get state possible reduce ee sube supe consequently special case production never used 7 dangling else unfortunately grammars approach cannot successful prominent example dangling else construction commonly used despite semantically problematic order get correct semantics sentence dangling else one applies adhoc rule else belongs nearest preceding following grammar represents classic dangling else construction techniques cannot handle grammar shown finite prioritizing set however techniques offer start listing following infinite prioritizing set parse tree pairs tsss universal clr1 parser grammar 6 contains one conflict turns resolution conflict gives complete linear time parser choosing shifting reducing gives parser intended semantics unfortunately techniques cannot verify completeness due lack finite prioritizing set hence want safety techniques disambiguate grammar 6 using technique thorup 1994 done automatically result grammar even better solution would avoid problem completely changing language something readable done modula2 wirth 1985 course lack safety problem connection single small like 6 indicated last section problem arises start acm transactions programming languages systems vol 16 3 may 1994 pages 10241050 controlled grammatic ambiguity delta 19 using grammars like 6 larger context say several language designers collaborating grammar large grammar checking hidden ambiguity incompleteness generated parsers cumbersome hand appendix j shall return possibility generalizing techniques deal directly dangling else construction 8 algorithmic outline section give general outline computation described main theorem 51 also give introduction appendices relative clr1 technique contain details computation initially assume none priorities discussed section 6 thus given grammar g universal lr parser u g finite set e parse tree pairs goal find determinization p u finite set e parse tree pairs p e match sense matching pair exists want e minimal given p p linear time parser latter condition shown always satisfied p matched matching pair want able report key searching matching pairs construct first catalyst set r parse tree pairs defined follows second coordinates r minimal parse trees amongst nontrivial parse trees root symbol single symbol frontier let second coordinate r let x x derived production generated corresponding first coordinate ptx grammar 3 pare 10 set r empty grammar 4 page 14 r equal r f f straighforward see r always finite construct r special properties r described following theorem proof deferred appendices theorem 81 let p determinization universal lr parser u let e set parse tree pairs e uprioritizes p following conditions satisfied parse trees pcanonical spans ordering u p minimal theorem follows determinization p universal parser u finite set e parse tree pairs match following conditions satisfied parse trees pcanonical ii spans ordering u p minimal notice explicit test wellfoundedness e e oe required e e prioritizing spanning universal parser ordering follows directly e e r oe irreflexive strength theorem 81 irreflixivety implies desired wellfoundedness trivially ii satisfied p minimal ordering u spanned r oe restriction number relevant determinizations crucial running time generally number exponential user works modularly introducing little new ambiguity step set e largely determine parsing keeping number relevant determinizations small thus check e r oe spans ordering u report cannot matching pair choose ominimal determinization p going decide p matched set e construct minimal set returned together p try another ominimal determinization ominimal determinization p matched report matching pair denote set minimal noncanonical parse trees definition e e minimal parse trees coincide pcanonical parse trees case parse trees second coordinates either e e suppose infinite since e finite cannot finite set e matching p thus infinite try another ominimal determinization denote gamma set without parse trees occurring second coordinates e check parse tree gamma pcanonical equivalent p cannot complete try another ominimal determinization construct e gamma coincides second coordinates first coordinates pcanonical equivalents clearly thereby satisfy also clear ii satisfied e minimal set matching p since second coordinates forced claim ii satisfied p matched suppose set e 0 matches p prioritizes p parse tree pair canonical first coordinate contained e oe hence particular e oe thus fact e 0 satisfies condition e r oe spans ordering u p minimal may conclude also e satisfies condition hence ii satisfied claimed thus final step processing p check ii satisfied return p e successfully otherwise p cannot matched try another ominimal determinization outlines algorithm computation described main theorem 51 case input contained priorities need avoid determinizations second coordinate canonical first coordinates place lambdas use canonical equivalents unfor tunately priorities speed search adequate determinization much normal priorities essentially problem know advance first noncanonical action given second coordinate algorithmic outline assumes solve following problems given finite set e parse tree pairs check e oe spans acm transactions programming languages systems vol 16 3 may 1994 pages 10241050 controlled grammatic ambiguity delta 21 ordering u construct ordering problem construct projections u possibly infinite set parse tree pairs e oe given determinization p construct set minimal noncanonical parse trees constituted necessary second coordinates particular decide infinite implying p cannot matched given determinization p parse tree check pcanonical equivalent problem p might terminating input prove matched determinizations linear time parsers essential problem might nonterminating problems sorted appendices relative clr1 technique knuths canonical lr1 technique knuth 1965 modified deal derived productions solved exactly stated connection problems 2 3 give exact solution reason infer p cannot prioritized appendices divided follows appendix proves theorem 81 appendix b formally describe construction universal clr1 parsers appendix c introduce convenient notions concerning parsers framework set appendix solves problem 1 appendix e addresses problem 2 appendix f addresses problem 3 appendix g deals problem 4 addressed problems appendix h puts everything together exact algorithm computation described main theorem 51 clr1 technique algorithm followed examples appendix finally appendix j contains technical remarks efficiency possible generalizations 9 conclusion theoretical result paper various lr techniques generalized deal classes ambiguous grammars characterizing ambiguity generating complete linear time parsers practical result guaranteed completeness correctness generated parsers respect explicitly declared user intent input priorities unintentional ambiguity arising grammar evolution combination reused grammar fragments originally developed contexts slip unnoticed contrasts traditional approach based disambiguating rules general give warnings incompleteness incorrectness unfortunately interesting grammars like based dangling else techniques presented paper report failure connection would significant improvement techniques generalize deal parsers prioritized finite infinite sets parse tree pairs acknowledgments special thanks william maddox markjan nederhof eljas soisalonsoini nen put large effort helping presentation acm transactions programming languages systems vol 16 3 may 1994 pages 10241050 22 delta mikkel thorup work many others helpful suggestions comments encouragement years working theory algorithms presented among andrew appel dines bjrner andrezej blikle alan demers martin farach tony hoare neil jones bernard lang bill mccoll colin mcdiarmid hans rischel sren riis mary ryan barbara ryder vincent sgro anders thorup various anonymous referees r deterministic parsing ambiguous grammars compilers principles grammatical abstraction incremental syntax analysis languagebased editor structure shared forests ambiguous parsing denotational engineering conservative extensions syntax system development conservative extensions syntax process system development skeletal lr parsing ambiguity precedence syntax description principles obj2 incremental parsing incremental generation parsers system typesetting mathematics translation languages left right forward move algorithm lr error recovery generalized lr parsing general contextfree grammars technical report technical report cs r9153 parsing theory parsing theory looping lr parsers ambiguity incremental parsing evaluation topics computation disambiguating grammars exclusion subparse trees technical report diku9411 efficient parsing natural language fast algorithm practical systems resolution ambiguity parsing programming modula2 revised july tr programming modula2 3rd corrected ed compilers principles techniques tools looping lr parsers parsing theory vol 1 languages parsing grammatical abstraction incremental syntax analysis languagebased editor denotational engineering parsing theory volume 2 lrk llk parsing incremental generation parsers principles obj2 incremental parsing system typesetting mathematics deterministic parsing ambiguous grammars forward move algorithm lr error recovery efficient parsing natural language conservative extensions syntax process system development ctr wagner susan l graham efficient flexible incremental parsing acm transactions programming languages systems toplas v20 n5 p9801013 sept 1998
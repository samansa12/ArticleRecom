featherweight java several recent studies introduced lightweight versions java reduced languages complex features like threads reflection dropped enable rigorous arguments key properties type safety carry process step omitting almost features full language including interfaces even assignment obtain small calculus featherweight java rigorous proofs possible easy featherweight java bears similar relation java lambdacalculus languages ml haskell offers similar computational feel providing classes methods fields inheritance dynamic typecasts semantics closely following javas proof type safety featherweight java thus illustrates many interesting features safety proof full language remaining pleasingly compact minimal syntax typing rules operational semantics featherweight java make handy tool studying consequences extensions variations illustration utility regard extend featherweight java generic classes style gj bracha odersky stoutamire wadler give detailed proof type safety extended system formalizes first time key features gj b introduction inside every large language small language struggling get formal modeling offer significant boost design complex realworld artifacts programming languages formal model may used describe aspect design precisely state prove properties direct attention issues might otherwise overlooked formulating model however tension completeness compactness aspects model addresses time unwieldy becomes often sensible choose model less complete compact offering maximum insight minimum investment strategy may seen flurry recent papers formal properties java omit advanced features concurrency reflection concentrate fragments full language wellunderstood theory applied propose featherweight java fj new contender minimal core calculus modeling javas type system design fj favors compactness completeness almost obsessively five forms expression object creation method invocation field access casting variables syntax typing rules operational semantics fit comfortably single page indeed aim omit many features possible even assignment retaining core features java typing direct correspondence fj purely functional core java sense every fj program literally executable java program fj little larger churchs lambda calculus 3 abadi cardellis object calculus 1 significantly smaller previous formal models classbased languages like java including put forth drossopoulou eisenbach khurshid syme 20 nipkow oheimb 17 flatt krish namurthi felleisen 14 smaller fj lets us focus key issues example discovered capturing behavior javas cast construct traditional smallstep operational semantics trickier would expected point overlooked underemphasized models one use fj starting point modeling languages extend java fj compact focus attention essential aspects exten sion moreover proof soundness pure fj simple rigorous soundness proof even significant extension may remain manageable second part paper illustrates utility enriching fj generic classes methods la gj 7 al though model omits important aspects gj raw types type argument inference generic method calls already revealed portions design underspecified bugs gj compiler main goal designing fj make proof type soundness welltyped programs dont get stuck concise possible still capturing essence soundness argument full java language language feature made soundness proof longer without making significantly different candidate omission previous studies type soundness java dont treat advanced features concurrency inner classes reflection java features omitted fj include assignment terfaces overloading messages super null pointers base types int bool etc abstract method declara tions shadowing superclass fields subclass fields access control public private etc exceptions features java model include mutually recursive class definitions object creation field access method invocation method override method recursion subtyping casting one key simplification fj omission signment assume objects fields initialized constructor never changed afterwards restricts fj functional fragment java many common java idioms use enumerations cannot represented nonetheless fragment computationally complete easy encode lambda calculus large enough include many useful programs many programs felleisen friedmans java text 12 use purely functional style moreover tricky typing issues java gj independent assign ment important exception type inference algorithm generic method invocation gj twists imposed need maintain soundness presence assignment paper treats simplified version gj without type inference remainder paper organized follows section 2 introduces main ideas featherweight java presents syntax type rules reduction rules sketches type soundness proof section 3 extends featherweight java featherweight gj includes generic classes methods section 4 presents erasure map fgj fj modeling techniques used compile gj java section 5 discusses related work section 6 concludes fj program consists collection class definitions plus expression evaluated expression corresponds body main method java typical class definitions fj class pair extends object object fst object snd pairobject fst object snd pair setfstobject newfst return new pairnewfst thissnd class extends object class b extends object sake syntactic regularity always include supertype even object always write constructor even trivial classes b always write receiver field access thissnd method invocation constructors always take stylized form one parameter field name field super constructor invoked fields supertype remaining fields initialized corresponding parameters supertype always object fields invocations super arguments constructors place super appears fj program since fj provides sideeffecting operations method body always consists return followed expression body setfst context definitions expres sion new pairnew new bsetfstnew b evaluates expression new pairnew b new b five forms expression fj new new b new paire1e2 object constructors e3setfste4 method invocation body setfst expression thissnd field access occurrences newfst variables fj differs java ordinary variable rather special keyword remaining form expression cast expression pairnew pairnew pairnew new b new afstsnd evaluates expression new b paire7 e7 new pairfst cast cast required e7 field access fst declared contain object whereas next field access snd valid pair run time checked whether object stored fst field pair case check succeeds java one may prefix field parameter declaration keyword final indicate may assigned parameters accessed inner class must declared final since fj contains assignment inner classes matters little whether final appears omit brevity dropping side effects pleasant side effect evaluation easily formalized entirely within syntax fj additional mechanisms modeling heap moreover absence side effects order expressions evaluated affect final outcome define operational semantics fj straightforwardly using nondeterministic smallstep reduction relation following longstanding tradition lambda calculus course javas callbyvalue evaluation strategy subsumed general relation soundness properties prove reduction hold javas evaluation strategy special case three basic computation rules one field access one method invocation one casts recall lambda calculus betareduction rule applications assumes function first simplified lambda abstraction similarly fj reduction rules assume object operated upon first simplified new expression thus slogan lambda calculus everything function slogan everything object rule field access action new pairnew new bsnd gamma new b stylized form object constructors know constructor one parameter field order fields declared fields fst snd access snd field selects second parameter rule method invocation action denotes substitution new pairnew new bsetfstnew b gamma new bnewfst new pairnew anew bthis new pairnewfst thissnd ie new pairnew b new pairnew new bsnd receiver invocation object new pairnew new b look setfst method pair class find formal parameter newfst body new pairnewfst thissnd invocation reduces body formal parameter replaced actual special variable replaced receiver object similar beta rule lambda calculus xe0e1 gamma e1xe0 key differences fact class receiver determines look body supporting method override substitution receiver supporting recursion self readers familiar abadi cardellis object calculus see strong similarity reduction rule 1 fj lambda calculus pure abadicardelli calculus formal parameter appears body may lead duplication actual since side effects causes problems rule cast action pairnew pairnew new b gamma new pairnew new b subject cast reduced object easy check class constructor subclass target cast case reduction removes cast expression anew b rule applies computation stuck denoting runtime error three ways computation may get stuck attempt access field declared class attempt invoke method declared class message understood attempt cast something superclass class prove first two never happen welltyped programs third never happens welltyped programs contain downcasts stupid castsa technicality explained usual allow reductions apply subexpression expression computation second example expression next subexpression reduced underlined step pairnew pairnew pairnew new b new afstsnd gamma pairnew pairnew anew bsnd gamma new pairnew new bsnd gamma new b prove type soundness result fj expression e reduces expression e 0 e well typed e 0 also well typed type subtype type e informal introduction mind may proceed formal definition fj 21 syntax syntax typing rules computation rules fj given figure 1 auxiliary functions figure 2 metavariables b c e range class names f g range field names ranges method names x ranges parameter names e range expressions cl ranges class decla rations k ranges constructor declarations ranges method declarations write f shorthand f1 fn similarly c x e etc write shorthand m1 mn commas write empty sequence ffl denote concatenation sequences using comma length sequence x written x abbreviate operations pairs sequences obvious way writing c f shorthand c 1 f1 cn fn similarly c f shorthand c 1 f1 cn fn thisff shorthand thisf1f1 thisfnfn sequences field declarations parameter names method declarations assumed contain duplicate names class table ct mapping class names c class declarations cl program pair ct e class table expression lighten notation follows always assume fixed class table ct abstract syntax fj class declarations constructor declarations method declarations expressions given top left figure 1 java assume casts bind less tightly forms expression assume set variables includes special variable never used name argument method every class superclass declared extends raises question superclass syntax cl class c extends c c f k e x new ce subtyping class c extends computation new cef gamma e rfield new cemd gamma x 7 7 new cee0 dnew ce gamma new ce rcast expression typing tfield stupid warning method typing class c extends class typing class c extends c f k ok figure 1 fj main definitions field lookup class c extends c f k class c extends c f k class c extends c f k defined method body lookup class c extends c f k class c extends c f k defined valid method overriding figure 2 fj auxiliary definitions object class various ways deal issue simplest one found take object distinguished class name whose definition appear class table auxiliary functions look fields method declarations class table equipped special cases object return empty sequence fields empty set methods full java class object several methods ignore fj looking class table read subtype relation classes write c subtype ie subtyping reflexive transitive closure immediate subclass relation given extends clauses ct formally defined middle left column figure 1 given class table assumed satisfy sanity conditions 1 ct class c every domct 3 every class name c except object appearing anywhere ct c 2 domct 4 cycles subtype relation induced ct relation antisymmetric typing reduction rules need auxiliary definitions given figure 2 fields class c written fieldsc sequence c f pairing class field name fields declared class c superclasses type method class c written mtypem c pair written bb sequence argument types b result type b similarly body method class c written mbodym c pair written xe sequence parameters x expression e predicate overridec0c judges method argument types c result type c0 may defined subclass case overriding method name declared superclass must type 22 typing typing rules expressions method declarations class declarations right column figure 1 environment gamma finite mapping variables types written xc typing judgment expressions form environment gamma expression e type c typing rules syntax directed one rule form expression save three rules casts typing rules constructors method invocations check actual parameter type subtype corresponding formal abbreviate typing judgments sequences obvious way writing c1 gamma en 2 cn writing one technical innovation fj introduction stupid casts three rules type casts upcast subject subclass target downcast target subclass subject stupid cast target unrelated subject java compiler rejects ill typed expression containing stupid cast must allow stupid casts fj formulate type soundness subject reduction theorem smallstep semantics sensible expression may reduced one containing stupid cast example consider fol lowing uses classes b defined previous section aobjectnew b gamma anew b indicate special nature stupid casts including hypothesis stupid warning type rule stupid casts tscast fj typing corresponds legal java typing contain rule stupid casts omitted classic java 14 causing published proof type soundness incorrect error discovered independently classic java authors typing judgment method declarations form ok c read method declaration ok occurs class c uses expression typing judgment body method free variables parameters method declared types plus special variable type c typing judgment class declarations form cl ok read class declaration cl ok checks constructor applies super fields superclass initializes fields declared class method declaration class ok type expression may depend type methods invokes type method depends type expression body behooves us check illdefined circularity indeed none circle broken type method explicitly declared possible load use class table classes checked long class eventually checked 23 computation reduction relation form e gamma e 0 read expression e reduces expression e 0 one step write gamma reflexive transitive closure gamma reduction rules given bottom left column figure 1 three reduction rules one field access one method invocation one casting already explained introduction section write dx eye0 result replacing x1 d1 xn dn e expression e0 reduction rules may applied point expression also need obvious congruence rules e gamma e f like omit 24 properties formal definitions fun proof pudding well proof definitions sensible able prove type soundness result relates typing computation indeed prove result term well typed reduces second term second term well typed furthermore type subtype type first term 241 theorem subject reduction gamma e 2 c e gamma e proof sketch main property required proof following termsubstitution lemma proved induction derivation gamma x interesting case final rule used derivation tdcast suppose type e0 c0 induction since d0 c may may subtype rela tion derivation gamma cdxe 2 c may involve stupid warning hand ce0 derived using tucast cdxe also upcast theorem proved induction derivation e gamma e case analysis last rule used case rinvk easy using lemma base cases also straightforward induction steps interesting case congruence rule castingthat case ce gamma ce 0 derived using e gamma e using argument similar term substitution lemma see downcast expression may reduced stupid cast upcast expression always reduced upcast xi also show program well typed way get stuck reaches point cannot perform downcast 242 theorem progress suppose e welltyped expression 1 e includes new c0ef subexpression 2 e includes new c0emd subexpression mbodym state similar property casts say expression e safe gamma type derivations underlying ct gamma e 2 c contain downcasts stupid casts uses rules tdcast tscast words safe program includes upcasts see safe expression always reduces another safe expression moreover typecasts safe expression never fail shown following pair theorems 243 theorem reduction preserves safety e safe gamma egammae 0 e 0 safe gamma 244 theorem progress safe programs suppose e safe gamma e cnew c0e subexpression 3 featherweight gj gj adds generic types java featherweight gj fgj short adds generic types fj class definition pairs fj rewritten type parameters fgj class pairx extends object extends object extends object snd z extends object pairzy setfstz newfst return new pairzynewfst thissnd class extends object class b extends object classes methods may generic type pa rameters x parameters class z parameter setfst method type parameter bound x z bounded object context definitions expres sion new pairabnew new bsetfstbnew b evaluates expression new pairbbnew b new b extraordinarily pedantic would write b instead b allow latter abbreviation former order fj proper subset fgj gj type parameters generic method invocations inferred thus gj expression would written new pairabnew new bsetfstnew b b invocation setfst fj subset java fgj quite subset gj regard fgj intermediate language form would result type parameters inferred parameter inference important aspect gj chose fgj concentrate modeling aspects gj bound type variable may type variable may type expression involving type variables may recursive even several bounds mutually recursive example cx dy classes one parameter one may bounds x extends cx even x extends cy extends dx bounds including examples utility recursive bounds see gj paper 7 gj fgj intended support either two implementation styles may implemented di rectly augmenting runtime system carry information type parameters may implemented erasure removing information type parameters runtime section explores first style giving direct semantics fgj maintains type parameters proving type soundness theo rem section 4 explores second style giving erasure mapping fgj fj showing correspondence reductions fgj expressions reductions fj expressions second style corresponds current implementation gj compiles gj java virtual machine jvm course maintains information type parameters runtime first style would correspond using augmented jvm maintains information type parameters 31 follows sake conciseness abbreviate keyword extends symbol syntax typing rules computation rules fgj given figure 3 auxiliary functions figure 4 metavariables x z range type variables u v range types n range nonvariable types types type variables write x shorthand x1 xn similarly n etc assume sequences type variables contain duplicate names abstract syntax fgj given top left figure 3 allow c abbreviated c respectively assume fixed class table ct mapping class names c class declarations cl obeying sanity conditions given previously 32 typing environment delta finite mapping type variables nonvariable types written takes type variable bound bounds types write bound delta upper bound delta defined figure 4 unlike calculi f 9 promotion relation need defined recur sively bound type variable always nonva riable type subtyping subtyping relation defined left column figure 3 subtyping reflexive transitive closure relation type parameters invariant regard subtyping reasons explained gj paper imply wellformed types declaration class c begins class cx n type like ct well formed substituting respects bounds n write wellformed context delta rules wellformed types appear figure 3 note perform simultaneous substitution variable x may appear n permitting recursion mutual recursion variables bounds type environment delta well formed delta deltax ok x dom delta also say environment gamma well formed respect delta written delta gammax ok x dom gamma field method lookup typing reduction rules need auxiliary definitions given figure 4 fairly straightforward adaptations lookup rules given previously fields nonvariable type n written fieldsn sequence corresponding types field names f type method invocation nonvariable type n written mtypem n type form x nuu similarly body method invocation nonvariable type n type parameters v written mbodymv n pair written xe sequence parameters x expression e syntax cl class cx n n f k e x new ne subtyping class cx n n wellformed types class cx n n computation new nef gamma e new nemvd gamma dx new nethise0 onew ne gamma new ne expression typing stupid warning method typing class cx n n class typing class cx n n f k ok figure 3 fgj main definitions bound type bound bound field lookup class cx n n f k class cx n n f k class cx n n f k defined method body lookup class cx n n f k class cx n n f k defined valid method overriding implies figure 4 fgj auxiliary definitions typing rules typing rules expressions methods classes appear figure 3 typing judgment expressions form read type environment delta environment gamma e type subtleties field method lookup relations already seen typing rules straightforward rule gtdcast last premise ensures result cast run time matter whether use highlevel typepassing reduction rules defined later section erasure semantics considered section 4 example suppose defined result type method may subtype result type corresponding method su perclass although bounds type variables argument types must identical modulo renaming type variables class table ok class definitions ok 33 reduction operational semantics fgj programs little complicated fj rules appear figure 3 34 properties fgj programs enjoy subject reduction progress properties exactly like programs fj 241 242 basic structures proofs similar theorem 241 242 subject reduction ever since parametric polymorphism combined subtyping need lemmas main lemmas required term substitution lemma plus similar lemmas preservation subtyping typing type substitution read ers familiar proofs subject reduction typed lambdacalculi like f 9 notice many similarities begin three substitution lemmas proved straightforward induction derivation 341 lemma type substitution preserves sub none x appearing delta 1 342 lemma type substitution preserves typ none x appears delta 1 343 lemma term substitution preserves typ 344 theorem subject reduction delta gamma e 2 proof induction derivation e gamma e 0 case analysis reduction rule used show detail base case e method invocation premises rule grinvk e rule gtinvk gtnew also examining derivation mtypem bound delta n find supertype ct n none appear lemma 342 straightforward weakening lemma shown plus lemma 343 lemma 341 gives letting finishes case since delta strans xi theorem progress suppose e welltyped expression 1 e includes new n0ef subexpression 2 e includes new n0emvd subexpres sion mbodymv fgj backward compatible fj intuitively means implementation fgj used typecheck execute fj programs without changing meaning show welltyped fj program always welltyped fgj program fj fgj reduction correspond note isnt quite case welltypedness fj program fgj rules implies welltypedness fj fgj allows covariant overriding fj statement theorem use gamma fj gamma fgj show set reduction rules used 346 theorem backward compatibility fj program e ct well typed typing rules fj also welltyped rules fgj moreover fj programs e e whether well typed e gamma fj e proof first half shown straightforward induction derivation gamma e 2 c using fj typing rules followed analysis rules gtmethod gtclass second half directions shown induction derivation reduction lation case analysis last rule used xi compiling fgj fj explore second implementation style gj fgj current gj compiler works translation standard jvm maintains information type parameters runtime model compilation framework erasure translation fgj fj show translation maps welltyped fgj programs welltyped fj programs behavior program fgj matches suitable sense behavior erasure fj reduction rules program erased replacing types erasures inserting downcasts required type erased removing type parameters replacing type variables erasure bounds example class pairxy previous section erases class pair extends object object fst object snd pairobject fst object snd pair setfstobject newfst return new pairnewfst thissnd similarly field selection new pairabnew new bsnd erases bnew pairnew new bsnd added downcast b recovers type information original program call downcasts inserted erasure synthetic 41 erasure types erase type remove type parameters replace type variables erasure bounds write jtj delta erasure type respect type environment delta 42 field method lookup fgj gj subclass may extend instantiated superclass means unlike fj java types fields methods subclass may identical types superclass order specify typepreserving erasure fgj fj necessary define additional auxiliary functions look type field method highest superclass defined example previously defined generic class pairxy may declare specialized subclass pairofa subclass instantiation pairaa instantiates x given class class pairofa extends pairaa superfst snd pairofa return new pairofanewfst thisfst note setfst method argument type matches argument type setfst pairaa result type pairofa subtype result type pairaa permitted fgjs covariant subtyping discussed previous section erasing class pairofa yields following class pairofa extends pair pairofaobject fst object snd superfst snd pair setfstobject newfst return new pairofanewfst thisfst arguments constructor method given type object even though erasure result method given type pair even though erasure pairofa cases types chosen correspond types pair highest superclass fields method defined define variants auxiliary functions find types fields methods highest superclass defined maximum field types class c written fieldsmax c sequence pairs type field name defined follows class cx n du f maximum method type c written c defined follows class cx n du class cx n du undefined also need way look maximum type given field fieldsmax set 43 erasure expressions erasure expression depends typing expression since types used determine downcasts insert erasure rules optimized omit casts trivially safe happens maximum type equal erased type write jej deltagamma erasure welltyped expression e respect environment gamma type environment delta jnew nej strictly speaking one think erasure operation acting typing derivations rather expressions since welltyped expressions 11 correspondence typing derivations abuse notation creates confusion 44 erasure methods classes erasure method respect type environment delta class c written jmj deltac defined follows e gj actual erasure somewhat complex involving introduction bridge methods one ends two overloaded methods one maximum type one instantiated type dont model extra complexity depends overloading method names modeled fj erasure constructors classes jclass cx n n f k mj class c jnj 45 properties erasure defined erasure may investigate properties first welltyped fgj program erases welltyped fj program expected 451 theorem erasure preserves typing fgj class table ct ok delta gamma e 2 using fj rules proof induction derivation using following lemmas 1 delta n ok methodtype fgj mtypemax jnj wellformed type environment delta interestingly would intuitively expect erasure fgj fj also preserve reduction behavior fgj programs e reduce erase eerase reduce unfortunately quite true example consider fgj expression b expressions type b respec tively erasure anew pairjaj deltagamma jbj deltagamma fst fgj e reduces jaj deltagamma erasure jej deltagamma reduces ajaj deltagamma fj reduce jaj deltagamma new expression note artifact nondeterministic reduction strategy happens even adopt callbyvalue reduction strategy since method invocation may obtain expression like ae e new expres sion thus diagram commute even onestep reduction gamma bottom replaced manystep reduction gamma general synthetic casts persist fj expression although expect casts eventually turn upcasts reduces new expression example fj expression reduced jej deltagamma synthetic casts je ever always case may less casts je reduction step involves method invocation consider following class erasure class cx extends object extends object return new cxthisf class c extends object object f cobject f return new cthisf consider fgj expression new canew erasure new cnew fgj e gamma fgj new canew canew af fj hand jej deltagamma reduces new cnew cnew af fewer synthetic casts new canew cnew af erasure reduced expression fgj subtlety observe erased term duced synthetic casts may become coarser casts inserted reduced term erased may removed entirely example removal downcasts considered combination two operations replacement coarser cast object removal upcast object affect result computation formalize observations define auxiliary relation relates fj expressions differing addition replacement synthetic casts let us call welltyped expression expansion welltyped expression e written e obtained e combination 1 addition zero synthetic upcasts 2 replacement synthetic casts c c supertype 3 removal synthetic casts 452 theorem erasure preserves reduction modulo expansion delta gamma e 2 e gamma fgj e exists fj expression 0 0 jej deltagamma gamma fj 0 words following diagram commutes e reduce erase erase reduce easy corollaries theorem shown fgj expression e reduces fullyevaluated expression erasure e reduces exactly erasure fgj reduction gets stuck stupid cast fj reduction also gets stuck typecast use metavariable v fully evaluated expressions defined follows 453 corollary erasure preserves execution results delta gamma e 2 e gamma fgj v jvj deltagamma 454 corollary erasure preserves typecast er e ehas stuck subexpression csnew dte 0 0 stuck subexpression cnew dd expansions erasures e position modulo synthetic casts erasure e 5 related work core calculi java several known proofs literature type soundness subsets java earliest drossopoulou eisenbach 11 using technique later mechanically checked syme 20 prove soundness fairly large subset sequential java like us use smallstep operational semantics avoid subtleties stupid casts omitting casting entirely nipkow oheimb 17 give mechanically checked proof soundness somewhat larger core language language include casts formulated using big step operational semantics sidesteps stupid cast problem flatt krishnamurthi felleisen 14 use smallstep semantics formalize language assignment casting system somewhat larger syntax typing operational semantics rules take perhaps three times space soundness proof though correspondingly longer similar complexity published proof subject reduction slightly flawed case motivated introduction stupid casts handled properly problem repaired applying refinement used three studies flatt krishnamurthi felleisen closest important sense goal choose core calculus small possible capturing features java relevant particular task case task analyzing extension java common lisp style mixins extensions core type system goal two systems hand include large subset java possible since primary interest proving soundness java classbased object calculi literature foundations objectoriented languages contains many papers formalizing classbased objectoriented languages either taking classes primitive eg 21 8 6 5 translating classes lowerlevel mechanisms eg 13 4 1 19 systems eg 19 8 include generic classes methods fairly simple forms generic extensions java number extensions java generic classes methods proposed various groups including language agesen freund mitchell 2 polyj myers bank liskov 16 pizza odersky wadler 18 gj bracha oderksy stoutamire wadler 7 nextgen cartwright steele 10 languages believed typesafe study fgj first give rigorous proof soundness generic extension java used gj basis generic extension similar techniques apply forms genericity found rest languages 6 discussion presented featherweight java core language java modeled closely lambdacalculus embodying many key features javas type sys tem fjs definition proof soundness concise straightforward making suitable arena study ambitious extensions type sys tem generic types gj developed extension detail stated fundamental properties sketched proofs fj quite complete enough model interesting subtleties found gj particular full gj language allows parameters instantiated special bottom type using slightly delicate rule avoid unsoundness presence signment capturing relevant issues fgj requires extending assignment null values extensions seem straightforward cost us pleasing compactness fj stands somewhat subtle aspect gj accurately modeled fgj use bridge methods compilation gj jvm bytecodes treat compilation exactly gj would need extend fj overloading formalization gj also include raw types unique aspect gj design supports compatibility old unparameterized code new parameterized code currently experimenting extension fgj raw types formalizing generics proven useful application domain fj areas extreme simplicity may yield significant leverage example work way formalizing java 11s inner classes using fj 15 acknowledgments work supported university pennsylvania national science foundation grant ccr9701826 principled foundations programming objects igarashi research fellow japan society promotion science r theory ob jects adding type parameterization java language lambda calculus imperative firstorder calculus object extension core calculus classes mix ins core calculus classes objects making future safe past adding genericity java programming language safe type checking statically typed objectoriented programming language extension system f subtyping steele jr java type system sound little java relationship classes classes mixins inner classes parameterized types java java light typesafe definitely pizza java translating theory practice simple typetheoretic foundations objectoriented pro gramming proving java type soundness type inference objects instance variables inheritance tr extension system italicfitalic subtyping syntactic approach type soundness parameterized types java pizza java adding type parameterization java language javaisublightsubi typesafemyampersandmdashdefinitely classes mixins little java patterns making future safe past compatible genericity runtime types java programming language relationship classes objects data abstraction java type system sound modular typebased reverse engineering parameterized types java code parametric polymorphism java types programming languages theory objects partial evaluation classbased objectoriented languages imperative firstorder calculus object extension core calculus classes mixins inner classes true modules javalike languages ctr maurizio cimadamore mirko viroli reifying wildcards java using ego approach proceedings 2007 acm symposium applied computing march 1115 2007 seoul korea peter hui james riely typing minimal aspect language preliminary report proceedings 6th workshop foundations aspectoriented languages p1522 march 1313 2007 vancouver british columbia canada giovanni rimassa mirko viroli understanding access restriction variant parametric types java wildcards proceedings 2005 acm symposium applied computing march 1317 2005 santa fe new mexico atsushi igarashi hideshi nagira union types objectoriented programming proceedings 2006 acm symposium applied computing april 2327 2006 dijon france marco bellia eugenia occhiuto higher order programming java introspection subsumption extraction fundamenta informaticae v67 n13 p2944 january 2005 tomoyuki aotani hidehiko masuhara towards type system detecting nevermatching pointcut compositions proceedings 6th workshop foundations aspectoriented languages p2326 march 1313 2007 vancouver british columbia canada jeffrey fischer rupak majumdar todd millstein tasks language support eventdriven programming proceedings 2007 acm sigplan symposium partial evaluation semanticsbased program manipulation january 1516 2007 nice france jaakko jrvi jeremiah willcock andrew lumsdaine associated types constraint propagation mainstream objectoriented generics acm sigplan notices v40 n10 october 2005 gustavo bobeff jacques noy component specialization proceedings 2004 acm sigplan symposium partial evaluation semanticsbased program manipulation p3950 august 2425 2004 verona italy alex potanin james noble robert biddle generic ownership practical ownership control programming languages companion 19th annual acm sigplan conference objectoriented programming systems languages applications october 2428 2004 vancouver bc canada neal glew jens palsberg typesafe method inlining science computer programming v52 n13 p281306 august 2004 tian zhao jens palsber jan vite lightweight confinement featherweight java acm sigplan notices v38 n11 november vijay menon neal glew brian r murphy andrew mccreight tatiana shpeisman alireza adltabatabai leaf petersen verifiable ssa program representation aggressive compiler optimization acm sigplan notices v41 n1 p397408 january 2006 alex potanin james noble dave clarke robert biddle featherweight generic confinement journal functional programming v16 n6 p793811 november 2006 nathaniel nystrom stephen chong andrew c myers scalable extensibility via nested inheritance acm sigplan notices v39 n10 october 2004 g bierman formal semantics analysis object queries proceedings acm sigmod international conference management data june 0912 2003 san diego california gurevich benjamin rossman wolfram schulte semantic essence asml theoretical computer science v343 n3 p370412 17 october 2005 ernst klaus ostermann william r cook virtual class calculus acm sigplan notices v41 n1 p270282 january 2006 todd millstein colin bleckner craig chambers modular typechecking hierarchically extensible datatypes functions acm sigplan notices v37 n9 p110122 september 2002 suresh jagannathan jan vitek adam welc antony hosking transactional object calculus science computer programming v57 n2 p164186 august 2005 lorenzo bettini sara capecchi elena giachino featherweight wrap java proceedings 2007 acm symposium applied computing march 1115 2007 seoul korea adriaan moors frank piessens wouter joosen objectoriented approach datatypegeneric programming proceedings 2006 acm sigplan workshop generic programming september 1616 2006 portland oregon usa christian skalka trace effects object orientation proceedings 7th acm sigplan international conference principles practice declarative programming p139150 july 1113 2005 lisbon portugal alessandro warth milan stanojevi todd millstein statically scoped object adaptation expanders acm sigplan notices v41 n10 october 2006 dan grossman jeremy manson william pugh highlevel memory models mean transactions proceedings 2006 workshop memory system performance correctness october 2222 2006 san jose california matthew tschantz michael ernst javari adding reference immutability java acm sigplan notices v40 n10 october 2005 juan chen david tarditi simple typed intermediate language objectoriented languages acm sigplan notices v40 n1 p3849 january 2005 polyvios pratikakis jaime spacco michael hicks transparent proxies java futures acm sigplan notices v39 n10 october 2004 marko van dooren eric steegmans combining robustness checked exceptions flexibility unchecked exceptions using anchored exception declarations acm sigplan notices v40 n10 october 2005 franz achermann oscar nierstrasz calculus reasoning software composition theoretical computer science v331 n23 p367396 25 february 2005 alexander ahern nobuko yoshida formalising java rmi explicit code mobility acm sigplan notices v40 n10 october 2005 gerwin klein tobias nipkow machinechecked model javalike language virtual machine compiler acm transactions programming languages systems toplas v28 n4 p619695 july 2006 philip w l fong reasoning safety properties jvmlike environment science computer programming v67 n23 p278300 july 2007 chris andreae yvonne coady celina gibbs james noble jan vitek tian zhao scoped types aspects realtime java memory management realtime systems v37 n1 p144 october 2007 dependent types higherorder mobile processes acm sigplan notices v39 n1 p147160 january 2004 atsushi igarashi mirko viroli variant parametric types flexible subtyping scheme generics acm transactions programming languages systems toplas v28 n5 p795847 september 2006 alex potanin james noble dave clarke robert biddle generic ownership generic java acm sigplan notices v41 n10 october 2006 daniel j dougherty pierre lescanne luigi liquori addressed term rewriting systems application typed object calculus mathematical structures computer science v16 n4 p667709 august 2006 tian zhao jens palsberg jan vitek typebased confinement journal functional programming v16 n1 p83128 january 2006 todd millstein colin bleckner craig chambers modular typechecking hierarchically extensible datatypes functions acm transactions programming languages systems toplas v26 n5 p836889 september 2004 chris andreae james noble shane markstrum todd millstein framework implementing pluggable type systems acm sigplan notices v41 n10 october 2006 radha jagadeesan alan jeffrey james riely typed parametric polymorphism aspects science computer programming v63 n3 p267296 15 december 2006 martin abadi cormac flanagan stephen n freund types safe locking static race detection java acm transactions programming languages systems toplas v28 n2 p207255 march 2006 einar broch johnsen olaf owe ingrid chieh yu creol typesafe objectoriented model distributed concurrent systems theoretical computer science v365 n1 p2366 10 november 2006 anindya banerjee david naumann ownership confinement ensures representation independence objectoriented programs journal acm jacm v52 n6 p894960 november 2005
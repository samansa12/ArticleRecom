model checking modular verification describe framework compositional verification finitestate processes framework based two ideas subset logic ctl satisfaction preserved composition preorder structures captures relation component system containing component satisfaction formula logic corresponds particular structure tableau formula preorder show assumeguaranteestyle reasoning within framework additionally demonstrate efficient methods model checking logic checking preorder several special cases implemented system based methods use give compositional verification cpu controller b introduction temporal logic model checking procedures useful tools verification finite state systems 3 12 20 however procedures traditionally suffered state explosion problem problem arises systems composed many parallel processes general size state space grows exponentially number processes introducing symbolic representations sets states transition relations using symbolic model checking procedure systems large state spaces 10 100 states verified 1 8 time space requirements techniques may practice polynomial number components system research sponsored part avionics laboratory wright research development center aeronautical systems division afsc us air force wrightpatterson afb ohio 454336543 contract f3361590c1465 arpa order 7597 part national science foundation contract ccr9005992 part usisraeli binational science foundation views conclusions contained document authors interpreted representing official policies either expressed implied us government unfortunately symbolic procedures still limits many realistic problems tractable due size thus motivated search additional methods handling state explosion problem methods work well conjunction techniques obvious method trying avoid state explosion problem use natural decomposition system goal verify properties individual components infer hold complete system use deduce additional properties system verifying properties components may also necessary make assumptions environment approach exemplified pnuelis assumeguarantee paradigm 23 formula logic triple hi temporal formulas program formula true whenever part system satisfying system must also satisfy typical proof shows hi htrueim 0 hold concludes htrueim k 0 hi true order automate approach model checker must several properties must able check property true systems built using given component generally must able restrict given class environments check must also provide facilities performing temporal reasoning existing model checkers designed provide facilities instead typically assume given complete systems elegant way obtain system properties provide preorder finite state models captures notion behaviors use logic whose semantics relate preorder preorder preserve satisfaction formulas logic ie formula true model also true model smaller preorder addition composition preserve preorder system smaller preorder individual components finally satisfaction formula correspond smaller particular model tableau formula preorder framework reasoning sequence might expressed tableau k assumptions may given either formulas directly finite state models whichever concise convenient complex forms reasoning induction 18 also possible within framework choosing computational model logic preorder obtain system guided following considerations first must able realistically model physical systems circuits second efficient procedures model checking checking preorder finally possible implement procedures effectively using symbolic techniques paper propose preorder use subset logic ctl 11 subset strictly expressive ltl induced subset ctl expressive enough verification tasks efficient model checking algorithm also give tableau construction ctl subset construction provides means temporal reasoning makes possible use formulas assumptions preorder semantics logics include notion fairness essential modeling systems communication protocols show use results verify systems composed moore machines moore machines explicit notion input output particularly suitable modeling synchronous circuits finally suggest efficient methods checking preorder several interesting cases implemented system based results system supports efficient compositional verification temporal reasoning paper organized follows section 2 surveys related work section 3 present logic semantics kripke structures preorder properties given section 4 next section defines semantics logic moore machines given moore machine formula show efficiently check whether environments moore machine environment satisfies formula section 6 presents tableau construction demonstrates use temporal reasoning methods checking preorder discussed section 7 section 8 gives compositional verification simple cpu controller conclude summary directions future work related work much work reducing complexity automatic verification grouped two classes first class includes methods build reduced global state graph expand needed portion global state graph local model checking algorithms 6 26 29 based logics like calculus use tableaubased procedure deduce specific state initial state system satisfies given logical formula state space generated needed algorithm formulas small portion space may examined main drawback algorithms often entire space generated example checking property holds globally also clear whether algorithms take good advantage symbolic representations graf steffen 13 describe method generating reduced version global state space given description system structured specifications components interact clarke long mcmillan 4 describe similar attempt methods still produce large state graphs states system equivalent much verification must redone part system changes shtadler grumberg 24 show verify networks processes whose structure described grammars approach involves finding global behavior component networks arbitrary complexity verified checking one representative system many systems however number states may still prohibitive clear whether method use symbolic representations second class methods compositional properties individual components verified properties global system deduced representation global state space built josko 15 gives algorithm checking whether system satisfies ctl specification environments algorithm also allows assumptions environment specified restricted lineartime logic system able handle assumeguarantee reasoning method fairly ad hoc however complex forms reasoning induction cannot easily incorporated system within framework ccs 22 number suggestions compositional reasoning larsen 19 investigates expressive power formalisms specifying behavior process system suggests equivalence refinement satisfaction formula three interesting relations implementation specification however discuss applicability ideas verification suggest implemented walker 27 demonstrates use preorder plus knowledge system operate simplify verification bisimulation equiv alence cleaveland steffen 7 use similar idea winskel 28 proposes method decomposing specifications properties components system must satisfy specification hold approach appealing unfortunately dealing parallel composition difficult apparent whether methods work well symbolic representations kurshan 16 describes verification methodology based testing containment regular languages homomorphic reductions used map implementations specifica tions specifications may used implementations next level abstraction dill 10 proposes elegant form trace theory used similar manner framework handle liveness properties well approaches depend specifications deterministic efficiency neither approach makes provisions using logical formulas specifications assumptions shurek grumberg 25 describe criteria obtaining modular framework illustrate idea using ctl universal path quantifiers system closest work presented give provisions handling fairness efficiently using formulas assumptions supporting temporal reasoning models system also associated fixed decomposition components hence unclear perform inductive reasoning framework 3 temporal logic logics presented section branchingtime temporal logics order able efficiently decide whether formula true systems containing given component eliminate existential path quantifier logics thus formula may include universal quantifier paths unlike lineartime temporal logic nesting path quantifiers allowed ensure existential path quantifiers arise via negation assume formulas expressed negation normal form words negations applied atomic propositions logics interpreted form kripke structure fairness constraints path quantifiers range fair paths structures logic 8ctl set state formulas given following inductive definition 1 constants true false state formulas every atomic proposition p p state formulas 2 state formulas state formulas 3 path formula 8 state formula 4 state formula path formula 5 path formulas 6 path formulas x b u also use following abbreviations f g path formula denote true u false v respectively 8ctl restricted subset 8ctl 8 path quantifier may precede restricted set path formulas precisely 8ctl logic obtained eliminating rules 3 6 adding following rule 3 state formulas 8x 8 u 8 v state formulas practice found many formulas used specifying verifying systems expressible 8ctl almost expressible 8ctl example formula expressible 8ctl weak form absence deadlock states always possible reach state p holds give semantics logic using form kripke structure fairness constraints tuple following form 1 finite set states 2 0 set initial states 3 finite set atomic propositions 4 l function maps state set atomic propositions true state 5 r theta transition relation 6 f streett acceptance condition represented pairs sets states definition 3 path infinite sequence states infinitely many g fair path iff every notation n denote suffix begins n consider semantics logic 8ctl atomic propositions drawn set definition 5 satisfaction formula satisfaction state formula state path formula fair path j defined inductively follows 1 2 3 every fair path starting 4 state formula iff first state satisfies state formula 5 6 c indicates every 0 emerson halpern 11 compared expressive power three logics ltl ctl ctl showed ltl ctl incomparable expressive power ctl strictly expressive either others eliminating existential path quantifier ctl ctl affect relative expressive power logics 8ctl trivially encompasses ltl 8ctl formula 8f8gp formula 8ctl equivalent ltl formula hand equivalent ltl formula 8fg p thus ltl 8ctl incomparable strictly less expressive 8ctl 4 homomorphisms composition structures section define preorder use examine properties also show properties make assumeguarantee style reasoning possible definition 6 structure homomorphism let 0 two structures 0 let 0 states 0 respectively relation h theta 0 homomorphism following conditions hold 1 ht 0 2 0 hs 0 implies b every fair path exists fair path 1 0 every h satisfies property 2 say h homomorphism h homomorphism 0 iff every 0 2 0 0 0 hs indicate two paths correspond item 2b write h 0 homomorphism exists homomorphism 0 0 understood sometimes write 0 intuitively two states homomorphic labels agree atomic propositions second structure every fair path first state corresponding fair path second state two structures homomorphic every initial state first corresponding initial state second one may view second structure specification first implementation since specification may hide implementation details may smaller set atomic propositions definition 8 composition structures let 0 two structures composition 0 denoted k 0 structure 00 defined follows 1 2 00 3 4 l 00 5 r 00 choice definition composition motivated correspondence composition moore machines transition composition joint transition components states composition pairs component states agree common atomic propositions first note composition operator usual properties theorem 1 composition structures commutative associative isomorphism proof straightforward tedious 2 turn connections relation composition begin note path k 0 fair iff restriction component results fair path following conditions equivalent 1 fair path 00 2 1 fair paths 0 respectively state 00 2 n proof assume condition 1 definition composition path let definition fair path inf 00 hence fair path similarly 1 fair path 0 assume condition 2 definition composition path 00 suppose p theta 0 first case implies second case similar hence 00 fair path 00 2 theorem 2 1 preorder 2 0 3 4 k proof 1 relation homomorphism reflexive thus remains show transitive assume let h 0 homomorphism 0 let h 1 homomorphism 0 00 define h 2 relational product h 0 h 1 ie definition homomorphism exists 0 0 h 0 similarly exists 00 0 h 1 0 h 0 0 h 1 definition homomorphism fair path exists fair path 0 0 0 h 0 0 since h 1 homomorphism exists fair path 00 00 00 h 1 homomorphism 00 thus 00 2 define h initial state km 0 0 label 0 lsl 0 0 fair path k 0 previous lemma 0 1 fair path definition h h every hence h homomorphism k 0 3 let h 0 homomorphism 0 define h 1 ni show h 1 homomorphism let initial state k 00 definition composition 0 0such h 0 0 state 0 k 00 since initial state 0 k 00 definition composition definition h 1 h 1 first note fair path k 00 00 every previous lemma fair path starting 1 fair path 00 00 since path 1 0 every 2 n definition homomorphism ls arguing 0 state 0 k 00 h 1 definition h 1 applying previous lemma find 0 fair path starting corresponding path 4 first note every state state k define 0 2 0 definition composition initial state k trivially label using previous lemma definition composition find 0 1 fair path fair path k definition h hence h homomorphism k 2 theorem 3 let 0 states 0 let h homomorphism paths h 0 1 every 8ctl state formula atomic propositions 0 2 every 8ctl path formula atomic propositions 0 proof proof proceeds induction structure formula 1 false result trivial atomic proposition definition homomorphism lsa case 2 induction hypothesis implies case 3 every fair path fair path definition homomorphism exists fair path 0 0 h 0 0 0 0 induction hypothesis implies 4 path formula consisting state formula 0 initial state 0 0 satisfies induction hypothesis since initial state 5 cases conjunction disjunction path formulas similar case 2 6 since h 0 also induction hypothesis implies 1 b implies exists n 0n j applying induction hypothesis n c case similar previous two cases 2 corollary every 8ctl formula atomic propositions 0 proof immediate 2 using theorem 2 corollary see standard ctl ctl model checking algorithm 3 restricted 8ctl 8ctl viewed determining whether formula true systems containing given component key compositional verification theorem corollary also straightforward justify soundness assumeguarantee paradigm assumptions given structures connection structures formulas examined section 6 discharging assumption involves checking relation suppose wish check verified following relationships words discharges assumption 0 assumption discharges assumption 0 assumption 0 satisfies desired formula theorem 2 corollary 1 implies k 0 theorem corollary also show system containing k 0 satisfy note necessarily true either 0 may involve atomic propositions 0 5 moore machines seen structures defined earlier definition 2 used compositional reasoning synchronous systems however systems typically given using common finite state model moore machines 14 moore machines models computation explicit notion inputs outputs since inputs originate external uncontrolled environment machine always receive combination input values moore machines synchronous composition moore machines machine makes single step every point thus suitable modeling synchronous circuits section show natural correspondence moore machines empty set inputs structures defined earlier use correspondence define semantics 8ctl respect moore machines show use compositional reasoning verify system composed moore machines definition 9 moore machine moore machine tuple following form 1 finite set states 2 0 set initial states 3 finite set input propositions 4 finite set output propositions 5 l function maps state set output propositions true state theta transition relation require every 2 v exists 2 rs v also let denote composition moore machines let 0 moore machines composition 0 denoted km 0 moore machine 00 defined follows 1 2 00 3 4 5 l 00 r 0 turn question define satisfaction specification moore machine key consideration wish compositional method reasoning thus satisfying specification mean plus environment satisfies specification achieve considering behavior complete systems involving definition 11 moore machine called closed intuitively behavior closed machine cannot altered machine structure naturally corresponds define structure precisely definition actually slightly general assigns structure nonclosed machines well definition 12 structure moore machine structure 0 corresponding moore machine denoted km defined follows 1 2 0 3 4 l 0 v 5 r 0 definition 13 moore machine 0 called closing environment 0 0 0 closing environment 0 composed resulting moore machine closed define satisfaction formula moore machine definition 14 satisfaction moore machine moore machine 8ctl formula atomic propositions every closing environment must demonstrate efficiently check whether moore machines km k km 0 proof define oe mapping states km km 0 states kmkkm 0 follows oe suppose map state km k km 0 definition oe immediately 0 definition moore machine composition v u disjoint 0 hence implies hence oe injection argue oe surjective consider cardinalities two sets states first consider js number states cross product km theta km 0 compatible labelings fix pair states 0 2 ji j states km first component 2 ji 0 j km 0 0 first component thus potentially 2 jij states km corresponding 0 however must correspond atomic propositions 0 0 0 thus exactly states km k km 0 corresponding 0 thus hence oe bijection initial state km k 0 0 oe initial state km kkm 0 since 0 initial state km 0 implies initial state km 0 similarly oe initial state km k km 0 initial state km k 0 sets atomic propositions two structures clearly identical labeling v labeling oe v v v l 0 r km fairness sets structures empty 2 definition 15 moore machine maximal closing environment denoted em moore machine 0 defined follows 1 2 0 3 4 5 maximal environment represents environment anything step intuitively possible behavior arbitrary environment must also possible behavior maximal environment logics use specify properties hold every possible behavior system hence plus maximal environment satisfies formula environment satisfy formula lemma closing environment suppose proof define note every 0 2 0 00 2 00 hs state l 0 0 00 0 related h every state 00 initial state hs definition h l 0 0 fact every state 0 related state 00 plus fact r 00 identically true implies path 00 00 h every path 00 fair thus h homomorphism 2 lemma 4 let moore machine km isomorphic km k em mapping states 00 states 0 oe v oe obviously injection oe surjection since subset 2 state em must 0 hence similarly 00 0 trivially equal also v v finally r 00 f 00 f 0 empty 2 theorem 4 moore machine proof suppose km 4 find km k em j lemma 2 km k kem closing environment lemma 3 hence theorem 2 km k km 0 applying corollary 1 km k km 0 hence lemma 4 km thus determine system 1 k 2 k k n satisfies formula instead check lemma 2 equivalent checking formula illustrated previous section use assumeguarantee paradigm try verify latter relation thus actual verification working structures even though thing want verify property composition moore machines 6 tableau construction section give tableau construction 8ctl formulas similar construction ltl see burch et al 1 show tableau formula maximal model formula relation thus structure generated construction used assumption composing structure desired system applying model checking algorithm discharging assumption simply matter checking environment satisfies formula also indicate tableau used temporal reasoning remainder section fix 8ctl formula definition 16 set sub subformulas formula defined following equations 1 atomic proposition fg negated atomic proposition pg 2 3 b c definition 17 set el elementary formulas formula defined following equations 1 atomic proposition fpg 2 3 b c special elementary subformula 8x false denotes nonexistence fair path false indicates fair path begins definition formula tableau denoted structure fi defined follows 1 2 map el sub ftrue falseg defined following equations g b c ii 3 g 4 g 5 rs iff formula 8x el 8x 2 implies 2 phi lemma 5 subformulas 2 phi proof proof proceeds induction structure 1 every state satisfies true result trivial atomic proposition g negated atomic proposition g since 2 induction hypothesis case 3 rs definition r 2 phi 1 induction hypothesis implies chosen arbitrarily fair path satisfies 1 second state hence b state phi either case successors trivially case induction hypothesis implies case induction hypothesis implies definition r also know rt u u 2 phi consider fair path note state path satisfy first condition two cases consider j j first state path every hence path satisfies 1 u 2 ii every j j 6j 2 implies every j induction hypothesis know j phi 2 definition f contradicts fact fair case impossible thus c state phi either case successors trivially case also either 2 phi 1 every u rt u u 2 phi fair path note satisfy first condition induction hypothesis implies induction hypothesis implies j j path satisfies hence let lemma 6 define relation h 0 theta every subformula elementary formula 0 proof proof proceeds induction structure base cases induction elementary subformulas plus true false 1 result trivial definition h 0 2 negated atomic proposition 0 3 induction hypothesis 2 case 4 given three cases fair paths start 0 0 induction hypothesis implies b 0 induction hypothesis 2 phi 2 2 phi c otherwise 0 induction hypothesis 2 cases 2 phi8 1 u 2 5 fair paths start 0 case 0 false induction hypothesis implies 2 phi induction hypothesis 2 phi 2 also either 0 0 applying induction hypothesis either 2 cases 2 phi thus cases 2 lemma 7 relation h given homomorphism proof note every state 0 0 single state hs 0 let set atomic propositions assume hs 0 g definition h 2 fair path 0 let 8x 1 8x 2 8x n formulas form 8x el 0 satisfies state related 0 1 h previous definition h formulas form 8x must exactly 8x 1 8x 2 8x n definition r see rs 1 since hs 0 continue process defining get sequence states starting hs 0 complete proof must show sequence fair assume fair looking f see must elementary subformula 8x8 u b inf phi8x 8 u b consider one states definition h implies 0 addition previous lemma implies j fair path 0 starting 0 every state path satisfies b 0 hence fact fair path theorem 5 0 proof suppose 0 lemma 5 definition tableau every initial state satisfies ie definition every 0 definition h every 0 paired unique 0 lemma 6 implies 0 2 phi definition tableau 0 2 0 lemma 7 h homomorphism 0 2 tableau construction also used reason formulas typically interested whether every model formula also model formula relation proposition proof every model particular also model assume previous corollary since sometimes extend set elementary formulas formula adding additional atomic propositions example wished check whether true implied p would extend set atomic propositions true include p another way view imagine rewriting true true p p formula nontrivial model iff case j 8x false true every model iff true 7 checking homomorphism section discuss problem determining whether exists homomorphism two structures 0 goal efficiently determine 0 first note h 1 h 2 homomorphisms h 1 h 2 homomorphism also trivially homomorphism facts imply maximal homomorphism set inclusion actually give algorithm computing maximal homomorphism also note following facts 1 state fair paths start homomorphic exactly states 0 0 2 0 state 0 fair paths start 0 0 homomorphic exactly states start fair path lsa states start fair path detected polynomial time 12 eliminated preprocessing step hence without loss generality assume every state 0 start fair path describe polynomial time algorithms checking preorder several important special cases suppose 0 trivial acceptance condition ie f definition 19 define sequence relations h follows 1 2 h first h h exists since h j1 h j j h j finite theorem 6 every 2 0 proof first note h greatest fixed point equation suppose 0 states h 0 fair path starting equation exists state 0 1 r 0 continuing fashion find path 0 starting 0 h path fair hence h homomorphism 0 ie 0 show 0 implies h 0 show homomorphism h fixed point equation since h greatest fixed point h hence homomorphism h hs 0 enough show h subset set hs 0 earlier assumption exists fair path hence letting fair path 0 1 since hs 0 exists fair path 0 1 0 1 see 0 set 2 note h jsj delta js 0 j h j1 also computed polynomial time h computed polynomial time another important case 0 deterministic ie r 0 language contained language 0 language state set sequences labelings occur along fair paths starting relation checked polynomial time using techniques clarke draghicescu kurshan 2 finally 0 result tableau construction say shown previous section checking whether 0 reduces problem checking whether 8 example implemented bddbased model checker based theory developed previous sections model checker written combination yales dialect scheme c includes facilities model checking temporal reasoning via tableau construc tion checking homomorphism illustrate system use controller simple cpu example controller written state machine description language called csml 5 compiled moore machines give brief description cpu clarke long mcmillan 5 give details cpu simple stackbased machine ie part cpus memory contains stack instruction operands popped onto results pushed two parts cpu controller first part called access unit responsible cpus memory refer ences second part called execution unit interprets instructions controls arithmetic unit shifter etc two parts operate parallel access unit execution unit communicate via small number signals three signals push pop fetch inputs access unit indicate execution unit wants push pop something stack get next instruction signals corresponding ready output access unit execution unit must wait appropriate ready signal proceeding one additional signal branch asserted execution unit wants jump new program location order increase performance access unit attempts keep value top stack special register called ts register goal keep execution unit wait memory example ts register contains valid data pop operation proceed immediately addition value pushed stack moved register copied memory later point access unit also loads instructions queue possible fetches require waiting memory queue flushed whenever cpu branches clarke long mcmillan gave number correctness conditions controller demonstrate formulas verified compositional fashion form conditions divide three classes first class consists simple safety properties access unit example one formulas states access unit outputs topofstack pointer memory address either reading writing ts register model checker verified properties held access unit alone hence hold system containing access unit conditions second class slightly complex properties safety properties specify sequences operations allowed example one condition pushed 8x8tsstored popped v pushed tsload pushed abbreviation push pushrdy popped abbreviates pop poprdy formula asserts push operation completed another push cannot completed access unit cannot attempt load ts register memory either pop occurs ts register stored stack words register contains value needs pushed stack cpu cannot anything would destroy value value either used successfully stored memory since properties class essentially specify access unit may assert ready signals tempting check whether hold access unit alone well possible however properties also depend memory acknowledgment signal behaves verify properties made simple model memory see figure 1 conciseness figure shows moore machine actual model used obtained adding fairness constraint shown figure structure corresponding moore machine properties class except one turn true system composed access unit model memory exception analog previous formula deals occurs pop counterexample produced model checker formula showed formula false push pop could occur simultaneously examined access unit saw designed assuming operations would mutually exclusive formula turns true additional assumption 8gpush pop model checker verified building tableau assumption composing access unit memory model checking formula f defined memrd memwr memack figure 1 memory abstraction final class criteria consists single liveness property 8g8ffetch fetchrdy formula states cpu always fetches another instruction demonstrate two different ways verifying property one way observe formula true must obviously case memory responds requests eventually execution unit execute infinite sequences pushes pops branches memory model already fairness constraint ensuring first nothing guarantee second take care using simple model execution unit see figure 2 actual model structure derived moore machine plus indicated fairness constraint output idle figure abbreviation pushpopfetchbranch model checker verified access unit plus models execution unit memory satisfied formula also verified homomorphism structure actual execution unit model thus conclude formula holds final system provided homomorphism actual memory model also checked execution unit model satisfied assumption 8gpush pop used since homomorphism execution unit model know execution unit must satisfy assumption well final step allows us conclude composition access execution units satisfies entire specification provided memory homomorphic model used fetchrdy pushrdy poprdy fetchrdy pushrdy poprdy f defined branch fetch idle push pop figure 2 execution unit abstraction also verify final property using series 8ctl assumptions idea check property execution unit order formula true access unit must eventually respond push pop requests must fill instruction queue appropriate guarantee access unit meets conditions know execution unit try two operations remove request corresponding operation complete begin properties fetch 1 2 first specifies every pair operations execution unit perform mutually exclusive two formulas state execution unit makes push pop request deassert request operation completes model checker verified properties hold execution unit alone using tableau construction first property implies assumption 8gpush pop used using formulas 1 2 assumptions checked system composed access unit memory model satisfied formula specification states every push operation completed similarly using formulas 1 3 assumptions verified system composed access unit memory model also satisfies formula 8g8ffetchrdy branch point either access unit eventually fill instruction queue branch occur finally using formula formulas 4 5 assumptions model checker verified execution unit satisfies 8g8ffetch fetchrdy complete verification would demonstrate homomorphism actual memory model 9 conclusion identified subset 8ctl ctl appropriate compositional rea soning subset satisfaction preserved composition hence standard model checking algorithm used answer question formula true systems containing specified component also proposed preorder appropriate 8ctl preorder captures relation component system containing component provides basis using assumeguarantee style reasoning logic assumptions given structures discharged checking preorder given tableau construction 8ctl subset 8ctl satisfaction 8ctl formula corresponds tableau formula preorder construction makes possible use 8ctl formulas assumptions temporal reasoning 8ctl also efficient model checking algorithm implemented verification system based results used verify nontrivial systems compositional fashion several directions future work intuitively 8ctl subset ctl maximal sense formula satisfaction preserved composition equivalent formula 8ctl proved another idea look different logics flavor 8ctl extended automata operators calculus delta modalities would also interesting try extend tableau construction section 6 8ctl order accomplish however almost certainly necessary use complex type structure given definition 2 another question whether possible apply ideas branchingtime logics existential path quantifiers example reasonable algorithm determine whether ctl formula true systems containing given component fairly easy come algorithms sound completeness seems difficult achieve also wish examine problem efficiently checking preorder arbitrary structures finally essential try apply compositional reasoning methods considered complex systems order evaluate techniques r symbolic model checking 10 20 states beyond unified approach showing language containment equivalence various types automatic verification finitestate concurrent systems using temporal logic specifications compositional model checking language compositional specification verification finite state hardware controllers partial verifying temporal properties sequential machines without building state diagrams trace theory automatic hierarchical verification speedindependent circuits sometimes efficient model checking fragments propositional mucalculus compositional minimization finite state processes introduction automata theory verifying correctness aadlmodules using model checking analysis discrete event coordination structural induction theorem processes expressive power implicit specifications checking finite state concurrent programs satisfy linear specification calculus communicating systems transition global modular temporal reasoning programs network grammars modular framework computeraided verification moti vation local model checking modal mucalculus bisimulations divergence compositional checking validity finite state processes model checking modal tr myampersandldquosometimesmyampersandrdquo myampersandldquonot nevermyampersandrdquo revisited automatic verification finitestate concurrent systems using temporal logic specifications structural induction theorem processes trace theory automatic hierarchical verification speedindependent circuits compositional model checking concurrency workbench network grammars communication behaviors automatic verification verifying correctness aadl modules using model checking analysis discrete event coordination unified approach showing language containment equivalence various types myampersandohgrautomata transition global modular temporal reasoning programs tableaubased model checking propositional mucalculus expressive power implicit specifications note model checking model myampersandngrcalculus checking finite state concurrent programs satisfy linear specification calculus communicating systems introduction automata theory languages computation local model checking modal mucalculus modular framework computeraided verification verifying temporal properties sequential machines without building state diagrams compositional minimization finite state systems design synthesis synchronization skeletons using branchingtime temporal logic ctr pallab dasgupta arindam chakrabarti p p chakrabarti open computation tree logic formal verification modules proceedings 2002 conference asia south pacific design automationvlsi design p735 january 0711 2002 robert john walters checking models built using graphically based formal modelling language journal systems software v76 n1 p5564 april 2005 alma l juarez dominguez nancy day compositional reasoning portbased distributed systems proceedings 20th ieeeacm international conference automated software engineering november 0711 2005 long beach ca usa w b prasetya swierstra factorizing fault tolerance theoretical computer science v290 n2 p12011222 2 january david harel orna kupferman moshe vardi complexity verifying concurrent transition systems information computation v173 n2 p143161 march 15 2002 yunshan zhu james h kukula generatorbased verification proceedings ieeeacm international conference computeraided design p146 november 0913 k mani chandy michel charpentier experiment program composition proof formal methods system design v20 n1 p721 january 2002 arindam chakrabarti pallab dasgupta p p chakrabarti ansuman banerjee formal verification module interfaces real time specifications proceedings 39th conference design automation june 1014 2002 new orleans louisiana usa r lazi c newcomb w roscoe model checking dataindependent systems arrays without reset theory practice logic programming v4 n56 p659693 september 2004 doron bustan orna grumberg simulationbased minimization acm transactions computational logic tocl v4 n2 p181206 april jason baumgartner tamir heyman vigyan singhal adnan aziz abstraction algorithm verification levelsensitive latchbased netlists formal methods system design v23 n1 p3965 july juergen dingel computerassisted assumeguarantee reasoning verisoft proceedings 25th international conference software engineering may 0310 2003 portland oregon yonit kesten nir piterman amir pnueli bridging gap fair simulation trace inclusion information computation v200 n1 p3561 1 july 2005 alur radu grosu modular refinement hierarchic reactive machines proceedings 27th acm sigplansigact symposium principles programming languages p390402 january 1921 2000 boston usa thomas henzinger orna kupferman sriram k rajamani fair simulation information computation v173 n1 p6481 february 25 2002 ferucio laurentiu tiplea aurora tiplea petri net reactive modules theoretical computer science v359 n1 p77100 14 august 2006 clarke grumberg jha verifying parameterized networks acm transactions programming languages systems toplas v19 n5 p726750 sept 1997 adnan aziz thomas shiple vigyan singhal robert brayton alberto sangiovannivincentelli formuladependent equivalence compositional ctl model checking formal methods system design v21 n2 p193224 september 2002 peter henderson modelling architectures dynamic systems programming methodology springerverlag new york inc new york ny alur thomas henzinger reactive modules formal methods system design v15 n1 p748 july 1999 alur radu grosu modular refinement hierarchic reactive machines acm transactions programming languages systems toplas v26 n2 p339369 march 2004 orna kupferman moshe vardi automatatheoretic approach modular model checking acm transactions programming languages systems toplas v22 n1 p87128 jan 2000 yunja choi sanjai rayadurgam mats pe heimdahl automatic abstraction model checking software systems interrelated numeric constraints acm sigsoft software engineering notes v26 n5 sept 2001 doron bustan orna grumberg applicability fair simulation information computation v194 n1 p118 10 october 2004 xudong huiqun yu tianjun shi junhua ding yi deng formally analyzing software architectural specifications using sam journal systems software v71 n12 p1129 april 2004 edmund clarke armin biere richard raimi yunshan zhu bounded model checking using satisfiability solving formal methods system design v19 n1 p734 july 2001 arindam chakrabarti patrice godefroid software partitioning effective automated unit testing proceedings 6th acm ieee international conference embedded software october 2225 2006 seoul korea thomas henzinger orna kupferman rupak majumdar universal existential fragments calculus theoretical computer science v354 n2 p173186 28 march 2006 ansuman banerjee pallab dasgupta open family temporal logics annotating temporal operators input constraints acm transactions design automation electronic systems todaes v10 n3 p492522 july 2005 f zaraket j baumgartner aziz scalable compositional minimization via static analysis proceedings 2005 ieeeacm international conference computeraided design p10601067 november 0610 2005 san jose ca mats p heimdahl devaraj george effect testsuite reduction automatically generated modelbased tests automated software engineering v14 n1 p3757 march 2007 sharon barner orna grumberg combining symmetry reduction underapproximation symbolic model checking formal methods system design v27 n12 p2966 september 2005 dongfeng wang farokh b bastani ling yen automated aspectoriented decomposition processcontrol systems ultrahigh dependability assurance ieee transactions software engineering v31 n9 p713732 september 2005 chouali j julliand pa masson f bellegarde pltlpartitioned model checking reactive systems fairness assumptions acm transactions embedded computing systems tecs v4 n2 p267301 may 2005 mauro caporuscio paola inverardi patrizio pelliccione compositional verification middlewarebased software architecture descriptions proceedings 26th international conference software engineering p221230 may 2328 2004 andrew gordon alan jeffrey authenticity typing security protocols journal computer security v11 n4 p451519 01012004 david dharbe tutorial introduction symbolic model checking logic concurrency synchronisation kluwer academic publishers norwell frdric herbreteau franck cassez olivier roux application partialorder methods reactive programswith event memorization realtime systems v20 n3 p287316 may 2001 kathi fisler moshe vardi bisimulation minimization symbolic model checking formal methods system design v21 n1 p3978 july 2002 compositional analysis verification parameterized systems theoretical computer science v354 n2 p211229 28 march 2006 de la riva javier tuya automatic generation assumptions modular verification software specifications journal systems software v79 n9 p13241340 september 2006 r gentilini c piazza policriti bisimulation simulation coarsest partition problems journal automated reasoning v31 n1 p73103 hakan erdogmus architecturedriven verification concurrent systems nordic journal computing v4 n4 p380413 winter 1997 tevfik bultan richard gerber william pugh modelchecking concurrent systems unbounded integer variables symbolic representations approximations experimental results acm transactions programming languages systems toplas v21 n4 p747789 july 1999 sara gradara antonella santone maria luisa villani using heuristic search finding deadlocks concurrent systems information computation v202 n2 p191226 1 november 2005 stephan merz model checking tutorial overview modeling verification parallel processes springerverlag new york inc new york ny 2001 christoph kern mark r greenstreet formal verification hardware design survey acm transactions design automation electronic systems todaes v4 n2 p123193 april 1999 edmund clarke berndholger schlingloff model checking handbook automated reasoning elsevier science publishers b v amsterdam netherlands 2001
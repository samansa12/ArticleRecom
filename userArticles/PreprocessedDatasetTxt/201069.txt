conjoining specifications show specify components concurrent systems specification system conjunction components specifications properties system proved reasoning components consider decomposition given system parts composition given parts form system b introduction large systems built smaller parts present method deducing properties system reasoning components show represent individual component pi formula parallel composition usually denoted cobegin pi coend represented formula 1 sn composition conjunction reduce composition conjunction sake elegance best way know prove properties composite systems rigorous reasoning requires logic hence language logical formulas require conventional programming language describing systems find convenient regard programs circuit descriptions lowlevel specifications represent logic used higherlevel specifications logic use tla temporal logic actions lamport 1994 discuss important problem translating lowlevel tla specification implementation conventional language idea representing concurrent programs specifications formulas temporal logic first proposed pnueli 1981 later observed specifications allow stuttering steps leave state unchanged l asserts l implements h lamport 1983 hence proving lowerlevel specification implements higherlevel one reduced proving formula authors address systems research center digital equipment corporation 130 lytton avenue palo alto ca 94301 permission copy without fee part material granted provided copies made distributed direct commercial advantage acm copyright notice title publication date appear notice given copying permission association computing machinery copy otherwise republish requires fee andor specific permission c acm transactions programming languages systems vol 17 3 may 1995 pages 507533 508 delta martin abadi leslie lamport logic still later noticed formula 999 999x specifies system except variable x hidden abadi lamport 1991 lamport 1989 variable hiding became logical quantification idea composition conjunction also suggested abadi plotkin 1993 abramsky jagadeesan 1994 zave jackson 1993 method reducing composition conjunction new deduce useful properties component must specify environment component exhibit intended behavior presence sufficiently hostile environment example combinational circuit produce output intended range input line instead 0 1 improper voltage level 12 specification circuits environment must rule improper inputs reason composite system depends formed composite specifications arise two ways decomposing given system smaller parts composing given parts form larger system two situations call two methods writing component specifications differ treatment environment difference leads turn different proof rules decomposing specification environment component assumed components usually left implicit reason component must state assuming environment prove assumption satisfied components decomposition theorem section 4 provides needed proof rule reduces verification complex lowlevel system proving properties higherlevel specification properties one lowlevel component time decomposing proofs way allows us apply decision procedures verifications hitherto required completely handguided proofs kurshan lamport 1993 specifying reusable component without knowing precisely used must make explicit assumes environment therefore assert component satisfies guarantee long environment satisfies assumption e assumptionguarantee property jones 1983 gamma show composition reusable components satisfies specification must prove formula form gamma gamma may assumptionguarantee property prove formula composition theorem section 5 theorem allows us reason assumptionguarantee specifications using wellestablished effective methods reasoning specifications complete systems following section examine issues arise decomposition composition discussion informal wish show issues fundamental artifacts particular formalism treat topics formally sections 4 5 section 3 covers formal preliminaries comparison related work appears conclusion proofs relegated appendix 2 informal overview 21 decomposing complete systems complete system one selfcontained may observed interact observer program complete system provided model acm transactions programming languages systems vol 17 3 may 1995 conjoining specifications delta 509 inputs generated nondeterministically program tiny example complete system consider program computing gcd greatest common divisor devised informal programminglanguage notation statements within angle brackets executed loopendloop keywords enclose infinite loop cobegincoend keywords enclose parallel statements separated k semicolon usual meaning writing processes also mark variables output input process cannot change input variables access internal variables another process program gcd var initially 233344 b initially cobegin loop h b gamma b endloop loop h b b b gamma endloop coend program gcd satisfies correctness property eventually b become remain equal gcd 233344 233577899 make distinction programs properties writing tla formulas formula gcd represents program gcd formula p gcd represents correctness prop erty program implements property iff gcd implies p gcd thus correctness program gcd verified proving gcd p gcd hierarchical development one decomposes specification system specifications parts explained section 4 specification gcd program gcd written b asserts initially equals 233344 repeatedly decremented value b whenever b b analogous formulas b specifications two processes pi pi b write pi pi b process pi process pi b output var initially 233344 output var b initially input var b input var loop h b one decomposes specification order refine components separately refine gcd program remove simultaneous atomic accesses b refining process pi process pi l output var initially 233344 internal var ai input var b loop h ai b refining pi b analogous process pi l b composition processes pi l pi l correctly implements program gcd expressed tla assertion l implies b l l b formulas representing pi l pi l b would like decompose proof l proofs l l proofs would show pi l implements pi pi l b implements pi b initial statesentackedsentackedsent fig 1 twophase handshake protocol channel c unfortunately pi l implement pi absence assumptions input b change pi l behave ways process pi cannot process pi decrement current value b pi l decrement previous value b b changes assignment ai assignment similarly pi l b implement pi b process pi l correctly implement process pi context b change b expressed tla formula e l e asserts b change b similarly holds analogous e b decomposition theorem section 43 allows us deduce l b b approximately following hypotheses 1 third hypothesis holds composition processes pi pi b allow change b b change b observe e asserts property pi l b needed guarantee pi l implements pi complicated example e significantly simpler l b full specification pi l b verifying hypotheses therefore easier proving l l b b directly since proof requires reasoning specification l b complete lowlevel program one cannot really deduce l b hypotheses 1 example 1 trivially satisfied e e b b equal false cannot deduce l arbitrary l l b precise hypotheses decomposition theorem complicated must develop number formal concepts order state also develop results allow us discharge complicated hypotheses proving conditions essentially simple 1 22 composing open systems open system one interacts environment control examples consider systems communicate using standard twophase handshake protocol mead conway 1980 send values channels state channel c described three components value cval sent two bits csig cack used synchronization let csnd denote pair hcsig cvali figure 1 shows sequence states assumed sending sequence values 37 4 channel ready send cack value v sent setting cval v complementing csig receipt value acknowledged complementing cack consider nelement queue input channel output channel acm transactions programming languages systems vol 17 3 may 1995 conjoining specifications delta 511 oe isnd iack oe osnd oack queue fig 2 queue process queue output var iack osig initially 0 internal var q initially h input var isig ival oack cobegin loop theta theta iack 6 isig jqj n theta theta q q ffi hi vali iack loop theta thetatheta theta thetatheta oval head q coend fig 3 queue process depicted figure 2 describe queue use programminglanguage constructs introduced section 21 particular write large atomic actions within angle brackets also introduce following notation finite sequences jaej denotes length sequence ae equals 0 ae empty headae tailae usual denote head first element tail sequence ae ae nonempty ae ffi denotes concatenation sequences ae moreover angle brackets used form sequences h denotes empty sequence hei denotes sequence e element notation queue written figure 3 let qm tla formula represents queue process might seem natural take qm specification queue however specification would difficult impossible implement states queue behaves properly even environment obey communication protocol example lowerlevel implementation reading input oack setting outputs osig oval would separate actions environment changed oack actions implementation could violate requirement change oval oack osig problem artifact particular representation queue actual hardware implementations queue enter metastable states consequently producing bizarre unpredictable behav ior inputs changed supposed mead conway 1980 specification queue allow executions queue performs rule bad behavior queue caused environment performing incorrectly specification written assumptionguarantee style generalization traditional prepostcondition style sequential programs assumptionguarantee specification asserts system provides guarantee environment satisfies assumption e queue formula qm e asserts environment obeys acm transactions programming languages systems vol 17 3 may 1995 fig 4 simple example system system oe communication protocol obvious reason composition systems described assumptionguarantee specifications basic problem illustrated simple case two systems one guaranteeing c assuming guaranteeing assuming c since system guarantees satisfy others environment assumption would like conclude composition implements specification unconditionally environment assumption attempt answer question considering two simple examples based figure 4 first example c asserts c always equals 0 asserts always equals 0 implement specifications following two processes process pi c process pi output var c initially input var input var c loop h c endloop loop h c endloop process pi c guarantees 0 assuming 0 process pi guarantees 0 assuming c clearly composition leaves c unchanged implements 0 second example c asserts c eventually equals 1 asserts eventually equals 1 processes pi c pi implement specifications case process assuming 1 process pi guarantees 1 assuming 1 c however since composition leaves c unchanged implement conclusion first example depend particular choice processes pi c pi deduce directly assumptionguarantee specifications composition must implement 0 first process change output variable would violate guarantee assumption violated argument apply second example violating c 1 sins omission occur particular instant property made false violated instant called safety property alpern schneider 1985 examples suggest reasoning composition assumptionguarantee specifications easiest assumptions safety properties argument composition implement 0 first example rests requirement process maintains guarantee acm transactions programming languages systems vol 17 3 may 1995 conjoining specifications delta 513 environment violates assumption words interpret assump tionguarantee specification assertion guarantee become false assumption e becomes false write assertion formula gamma section 5 discusses form specification rules reasoning composition assumptionguarantee specifications embodied composition theorem section 52 composition theorem prove conjunction assumptionguar antee specifications 0 c gamma 0 0 gamma 0 implies 0 also prove substantial resultsfor example composition queues implements larger queue verifying hypotheses theorem requires reasoning complete systems theorem allows us handle assumptionguarantee specifications easily completesystem specifications 3 preliminaries 31 311 review syntax semantics state assignment values variables technically variables flexible variables temporal logic correspond variables programming languages distinct variables firstorder logic behavior infinite sequence states semantically tla formula f true false behavior say f valid write true every behavior syntactically tla formulas built state functions using boolean operators implication operators 0 2 999 999 described state function like expression programming language semantically assigns value statefor example assigns state three plus value variable x state predicate booleanvalued state function action booleanvalued expression containing primed unprimed variables semantically action true false pair states primed variables referring second statefor example x true hs ti iff value greater value pair states satisfying action called step say enabled state iff exists state hs ti stepfor example enabled states x 0 state predicate enabled true state iff enabled write v 0 expression obtained priming variables state function v v v v step either step step leaves v unchanged usual temporal logic f formula 2f formula means f always true 3f abbreviation 2f means f eventually true addition action v state function 2a v abbreviation 2a v using 2 enabled predicates define fairness operators wf sf weakfairness formula wf v asserts behavior either infinitely many steps change v infinitely many states steps enabled written 23hai v 23enabled hai v strongfairness formula sf v asserts either infinitely many steps change v finitely many states steps enabled written acm transactions programming languages systems vol 17 3 may 1995 formula 999 999x f means essentially way choosing sequence values x temporal formula f holds think f x hidden call x internal variable 999 999x f x x 0 bound 999 999x 999 999x f x tuple variables hx standard way specifying system tla formula canon ical init predicate l conjunction fairness conditions formula asserts exists sequence values x 1 init true initial state 2 every step behavior n step leaves state function v unchanged 3 l holds example specification gcd complete highlevel gcd program written canonical form taking 1 init delta b b 2 intuitively variable represents part universe behavior represents possible complete history universe system pi represented true precisely behaviors represent histories pi running make formal distinction systems specifica tions properties represented tla formulas usually call specifications 312 interleaving noninterleaving representations let two ob jects represented variables x respectively representing history universe behavior describe concurrent changes either single simultaneous change x separate changes x order changes directly linked usually convenient describe concurrent change single change x however changes independent free choose whether allow simultaneous changes x interleaving representation one simultaneous changes disallowed changes directly linked often think x output variables single component interleaving representation one simultaneous changes output variables different processes disallowed absence simultaneous changes expressed tla formula system n components v tuple output variables component interleaving expressed formula let list formulas bulleted denote conjunction disjunction formulas using indentation eliminate parentheses also let lower precedence boolean operators conjoining specifications delta 515 oe isnd iack oe osnd oack queue e e r r e c e e r fig 5 complete system queue plus environment found tla interleaving representations usually easier write reason moreover interleaving representation adequate reasoning system system modeled sufficiently fine grain atomicity however discussed tla also works noninterleaving representations tla mandate particular method representing systems indeed one write specifications intermediate interleaving noninterleaving representations 313 queue example give tla specification queue natural numbers length n described informally section 22 illustrated figure 2 section 22 write csnd pair hcsig cvali channel c also write c triple hcsig cack cvali channel initially ready sending initial condition wire c predicate cinitc defined cinitc delta operations sending value v acknowledging receipt value channel c represented following send v c ack c actions represent queue complete system add environment sends arbitrary natural numbers channel acknowledges receipt values channel resulting complete system shown figure 5 tla formula cq specifying queue defined figure 6 canonical form x internal variable q represents sequence values received input channel yet sent output channel init written conjunction init e init initial predicates environment component arbitrarily consider initial conditions channel part senders initial predicate n disjunction two actions qm describing steps taken component qe q describing steps taken environment leave q unchanged action qm disjunction actions enq deq enq step acknowledges receipt value appends value q enabled q fewer n elements deq step removes first element q sends action qe disjunction put acm transactions programming languages systems vol 17 3 may 1995 environment actions get delta init component actions specification fig 6 specification cq complete queue formulas cinit send ack defined text sends arbitrary number channel get acknowledges receipt number channel v tuple hi qi relevant variables 2 l weakfairness condition icl defined wf hi qi qm asserts component step cannot remain forever possible without occurring shown logically equivalent specification obtained condition replaced wf hi qi enq wf hi qi deq formula cq gives interleaving representation queue simultaneous steps queue environment allowed moreover simultaneous changes two inputs isnd oack disallowed simultaneous changes two outputs iack osnd section 4 describe noninterleaving representation queue 32 implementation specification l implies specification iff every behavior satisfies l also satisfies hence proving l shows system pi l represented l implements system property pi represented note l inconsistent equivalent false l holds vacuously inconsistent l represent system pi l formula l proved applying handful simple rules lamport 1994 form 999 key step proof finding refinement informally write hi qi concatenation tuples hqi conjoining specifications delta 517 oe isnd iack oe zsnd zack queue1 e e r oe osnd oack queue2 r e c e e r fig 7 complete system containing two queues series 26 4 fig 8 specification complete doublequeue system figure 7 mappinga tuple state functions x l implies c formula obtained substituting x x therefore x 0 x 0 c reasonable assumptions refinement mapping exists l 999 valid abadi lamport 1991 example show system composed two queues series shown figure 7 implements single larger queue first specify composite queue let f e 1 denote result simultaneously substituting expression e v formula f example get defined figure 6 get zi equals acko z z formula f let figure 8 specification cdq complete system consisting double queue environment defined terms formulas figure 6 think complete system containing three components environment two queues initial condition conjunction initial conditions component nextstate action consists three disjuncts representing actions three components leave components variables unchanged finally take liveness condition conjunction fairness conditions two queues show composite queue implements 2n 1element queue 1 arises internal channel z acts buffer element correctness condition cdq formula f proved showing icdq icq dbl refinement acm transactions programming languages systems vol 17 3 may 1995 mapping defined else formula icdq icq dbl proved standard tla reasoning kind described lamport 1994 33 conditional implementation instead proving specification l implements specification sometimes want prove weaker condition l implements assuming formula g words want prove g l equivalent l formula g may express one following law nature example realtime specification g might assert time increases monotonically current time represented variable assumption expressed formula 2 r 2now 0 2 1 r set real numbers interface refinement g expresses relation lowlevel tuple l variables highlevel representation tuple h variables ex ample l might lowlevel interface representing transmission sequences bits wire h could highlevel interface sending seven successive bits interpreted transmission single ascii character assumption reality translated formalism behaviors particular g may assert interleaving assumptionfor example assumption form disjointv conditional implementation explicit formula g needed open systems complete system properties expressed g easily made part system specification example system include component advances time contrast difficult include g specification open system 34 safety closure 341 definition closure finite sequence states called finite behavior formula f finite behavior ae say ae satisfies f iff ae extended infinite behavior satisfies f convenience say empty sequence h satisfies every formula even false safety property formula satisfied infinite behavior oe iff satisfied every prefix oe alpern schneider 1985 predicate init action n state function v formula init 2n v safety property shown tla formula f tla formula cf called closure f behavior oe satisfies cf iff every prefix oe satisfies f formula cf strongest safety property proposition 1 implies cinit 2n conjunction suitable fairness properties conjoining specifications delta 519 342 machine closure writing specification form init 2n expect l constrain infinite behaviors finite ones formally means closure init 2n init 2n v pair properties called machine closed iff cp l equals p abadi lamport 1991 often say informally p l machine closed proposition 1 already proved abadi lamport 1994 shows use fairness properties write machineclosed specifications proposition relies following definition action subaction safety property p iff every finite behavior enabled state r n exists state r n1 hr satisfies p hr step follows definition subaction implies n subaction init 2n v proposition 1 p safety property l conjunction countable number formulas form wfw andor sfw w 0 6 w subaction p p l machine closed 343 closure hiding several results hypotheses form obvious first step proving formula compute closures cm 1 use proposition 1 compute closure formula internal variables internal variables following proposition allows us reduce proof cm 1 proof formula closures computed proposition 1 proposition 2 let x x tuples variables variable x occurs j 6 j proofs appendix results also hypotheses form cm 1 expect e safety property verify e safety property apply proposition 2 e internal variables often use proposition 2 abadi lamport 1991 verify e safety property additional temporal operators define additional temporal operators although expressed terms primitive tla operations 0 2 999 999 define semantically 351 operator formula ev asserts temporal formula state function v stops changing precisely behavior oe satisfies ev iff either oe satisfies e n 1 e holds first n states oe 2 v never changes n 1st state e safety property canonical form easy write ev explicitly proposition 3 x tuple variables none occurs v variable occur init n w v x init delta init 2 b need reason verify hypotheses form decomposition composition theorems verify hypothesis first applying observation cev equals cev using proposition 3 calculate ev however approach necessary noninterleaving specifications proposition 4 provides way proving hypotheses interleaving specifications without calculate ev 352 gamma operator temporal formulas e formula e gamma asserts holds least long e abadi plotkin 1993 precisely gamma true behavior oe iff e true oe every finite prefix ae oe e true ae true ae follows definition gamma e gamma equals ce gamma cm operator gamma acts much like ordinary implication fact equivalent course general true 353 gamma operator observed introduction interpret specification guaranteed assumption e formula gamma means holds least one step longer e precisely gamma true behavior oe iff true oe every n 0 holds first n states oe holds first n1 states oe follows definition gamma gamma equals ce gamma cm gamma stronger e gamma asserts holds long e shown e safety property gamma equals gamma e gamma prove appendix e safety properties v tuple variables containing free variables gamma equals ev gamma 354 operator specification component made false step changes components output variables interleaving representation allow single step change output variables two different components hence e specifications separate components expect step make e false precisely expect orthogonal true behavior oe iff true first n states oe false first n1 states oe shown safety properties gamma step falsifies e remains true long e must remain true least one step longer e hence equivalence gamma fact prove appendix acm transactions programming languages systems vol 17 3 may 1995 conjoining specifications delta 521 gamma valid relation gamma derive proposition 4 e r safety properties v tuple variables containing variables occur free imply proposition enables us use orthogonality remove proof obliga tions apply proposition must prove orthogonality component specifications interleaving specifications following result proposition 5 e c9 4 decomposing complete specification 41 specifying component let us consider write specification one component larger system assume free variables specification partitioned tuples output variables e input variables component changes values variables general situation discussed specification component form 999 999x init 2n complete system component specification v tuple hx ei init describes initial values components output variables internal variables x n allow two kinds stepsones component performs ones environment performs steps performed component change output variables described action nm interleaving rep resentation components inputs outputs cannot change simultaneously nm implies e noninterleaving representation nm constrain value e 0 variables e appear primed nm either case specifying component environment let environment anything except change components output variables internal variables words environment allowed perform step hm xi 0 equals hm xi describe general specifications environment action change x therefore n equal l conjunction fairness conditions form wf hm xi sf hm xi interleaving representation definition allow steps change e subscripts hm xi xi yield equivalent fairness conditions 522 delta martin abadi leslie lamport leads us write form simple logic 3 equivalent specification process pi gcd example x empty tuple internal variable input variable e b output variable init n init 2n wf n specification l lowlevel process pi l tuple x pca internal variable tells whether control beginning loop assignment ai specification form l 2n l appropriate initial condition init l nextstate action n l specifications b l b similar queue example write specifications queue environment separate components form 4 queue component tuple output variables hi ack osndi tuple e input variables hi snd oacki specification specification environment separate component provided specifications queue environment interleaving representation noninterleaving representation queue obtained modifying specification follows change enq deq actions constrain values snd 0 oack 0 define action deqenq simultaneously enqueues input value dequeues output value change definition qm deqenq additional disjunct resulting specification qm ni given figure 9 noninterleaving specification allows step changes simultaneously nonin terleaving representation queues environment obtained similar fashion describing components nextstate action n required environment action change components internal variables one also write acm transactions programming languages systems vol 17 3 may 1995 conjoining specifications delta 523 init fig 9 noninterleaving representation queue component specification component records environment actions changing internal variables case n equal may imply resulting formula pure interleaving specification environment actions change components variables action change components environments output variables explored style specification assuming visible variables components specification partitioned tuples output variables e input variables see handle general case let action 0 6 let v equal mi observe nm hm xi equals nm step one attributed component since changes components output variables tuple v variables partitioned input output variables define action specifies steps attributed component write components nextstate action form results separate input output variables generalized writing nextstate action form however simplicity consider special case 42 conjoining components form complete system section 31 describe specify complete system section 41 describe specify individual component system complete system composition components composing two systems means constructing universe running formulas 1 2 represent two systems 1 2 represents composition since behavior represents possible history universe containing systems iff satisfies 1 thus principle composition conjunction show composition conjunction practice well composition conjunction conjunction specifications components equivalent specification complete system example conjunction specifications qm queue qe environment equivalent specification cq complete system acm transactions programming languages systems vol 17 3 may 1995 524 delta martin abadi leslie lamport shown figure 5 recall deduce equivalence qe qm cq following result substituting qe 1 qm 2 case x 1 empty tuple h proposition tuples variables let 1 variable x 3 proposition third hypothesis asserts component leaves variables components unchanged interleaving representation component hence implies disjointm implies expected interleaving representation complete system gcd example apply proposition formula 5 analogous formula b immediately get b equivalent formula gcd defined 2 except wf ha bi n instead wf ha bi n shown two fairness conditions hence b equivalent gcd another example decomposition consider system figure 7 consists two queues series together environment system decomposed three components following specifications 1st queue 999 999 2nd queue 999 999 obtain interleaving representation conjoined acm transactions programming languages systems vol 17 3 may 1995 conjoining specifications delta 525 first queues nextstate action q 1 mention similarly conjoined second queues nextstate action z z environments follows proposition 6 conjunction three specifications equals specification cdq complete system defined figure 8 third hypothesis proposition 6 satisfied interleaving represen tations arbitrary representations straightforward calculation shows assuming first hypothesis proposition righthand side expected form noninterleaving specification since allows n n j steps hence composition conjunction noninterleaving representations 43 decomposition theorem 431 basic theorem consider complete system decomposed components would like prove system implemented lowerlevel one consisting components pi l proving pi l specification pi l specification pi l must prove implies implication trivially true l however saw gcd example l need imply even l hold need reason lowerlevel components together instead prove includes properties components assumed component usually much simpler k proving reasoning component entire lowerlevel system propositional logic deduce implies l may prove however proving still requires reasoning k specification entire lowerlevel system following theorem shows need prove e implied specification higherlevel systema formula usually much simpler k proving deducing reasoning sound general reasoning would allow us deduce l equal break circularity need add cs one hypothesis violated least one additional step l implies hypothesis expressed formally hypothesis weakest v taken tuple relevant variables proof rule theorem 1 decomposition theorem 2 526 delta martin abadi leslie lamport b l theorem corollary composition theorem section 52 gcd example want use theorem prove l b component specifications described section 41 abstract environment specification e asserts b change b changed steps change b thus definition e b analogous let v ha bi general environment component specifications internal vari ables theorem also allows contain fairness conditions however first hypothesis asserts e implied safety properties practice means theorem applied e safety proper ties examples section 22 lead us expect restriction moreover e internal variables expect simple historydetermined variables abadi lamport 1994 proposition 2 abadi lamport 1991 used prove e safety properties 432 verifying hypotheses discuss one verifies hypotheses decomposition theorem illustrating method gcd example prove first hypothesis one first eliminates closure operators existential quantifiers using propositions 1 2 proposition 2 abadi lamport 1991 reduces hypothesis condition form interleaving representations use proposition 6 write canonical form noninterleaving representations apply 9 either case proof 10 implementation proof kind discussed section 32 gcd example first hypothesis asserts cm e e b differs third hypothesis 1 section 21 cs verify hypothesis apply proposition 1 show cm cm b obtained simply deleting fairness conditions b since n b implies easy see cm b implies e equally easy see cm implies e b complicated examples follow cm j single j prove part second hypothesis first eliminate non interleaving representations must done proposition 3 described section 351 interleaving representations apply propositions 4 5 described section 354 either case prove resulting formula first using proposition 2 eliminate quantifiers using proposition 1 compute closures performing standard implementation proof refinement mapping conjoining specifications delta 527 part b hypothesis also calls standard implementation proof use refinement mapping proof since e implies implies cm l infer part implies proving part b requires verifying liveness part gcd example verify two parts second hypothesis proving proofs corresponding conditions b similar first observe initial condition e true since l interleaving representation nextstate action n l implies step changes b cm l implies disjointa b hence applying propositions 4 5 reduce task proving ce applying proposition 2 remove quantifier cm l proposition 1 remove cs reduce proving ce proving 2n l using simple logic 11 reduce proving e l proving 2n l use proposition 6 rewrite lefthand sides 11 12 canonical form resulting conditions usual form tla implementation proof summary applying propositions standard sequence use decomposition theorem reduce decompositional reasoning ordinary tla reasoning reduction may seem complicated trivial example gcd program however insignificant compared complexity complete proof realistic example one kurshan lamport 1993 discussed 433 general theorem sometimes need prove correctness systems defined inductively induction stage n1 low highlevel specifications defined conjunctions k copies low highlevel specifications stage n respectively example 2 n1 bit multiplier sometimes implemented combining four 2 n bit multipliers want prove induction n stage n lowlevel specification implements stage n highlevel spec ification proof need general decomposition theorem whose conclusion stage n used proving hypotheses stage n1 appropriate theorem theorem 2 general decomposition theorem 1 2 b 3 v tuple variables including free variables 528 delta martin abadi leslie lamport cm l b l conclusion b theorem form hypothesis 2b l replaced conjunctions make corresponding hypothesis 2a follow conclusion suffices prove general decomposition theorem applied verification inductively defined multiplier circuit kurshan lamport 1993 shown versions decomposition theorem provide complete rules verifying one composition implies another however result significance decomposition simplify proof proof decomposed sense l implements corresponding simple environment assumption e theorems designed handle proofs decomposed 5 composing assumptionguarantee specifications 51 form assumptionguarantee specification assumptionguarantee specification asserts system guarantees assumption environment satisfies e saw section 22 specification expressed gamma means n environment satisfies e time n system must satisfy time n1 perhaps obvious form assumptionguarantee specification formula gamma since allows behaviors violated e however implementation could exploit extra freedom predicting advance environment violate e system control environment cannot predict environment specifications gamma therefore allow implementations take gamma form assumptionguarantee specifications form leads simpler rules composition discussed section 22 composition works best environment assumptions safety properties shown gamma equivalent ce gamma principle convert assumptionguarantee specification one whose assumption safety property similar observation appears earlier work abadi lamport 1993 theorem 1 however equivalence intellectual interest practice write environment assumption safety property systems fairness guarantee conjunction properties el environment fairness assumption apply proposition 1 show resulting specification machine closed p l machine closed l implies r also machine closed abadi lamport 1994 proposition 3 conjoining specifications delta 529 52 composition theorem suppose given n devices assumptionguarantee specification gamma j verify composition devices implements higherlevel assumptionguarantee specification gamma must prove gamma gamma use following theorem theorem 3 composition theorem 1 2 b gamma gamma theorem also allows us prove conditional implementation results form g gamma gamma let 1 equal g e 1 equal true since true gamma g equals g interleaving specifications general prove conditional implementation g includes disjointness conditions asserting outputs different components change simultaneously hypotheses composition theorem similar decomposition theorem proved much way major difference interleaving specifications orthogonality condition ce cm follow form component specifications requires explicit disjointness assumptions observe hypotheses form form specification complete system component specifications p thus hypothesis asserts complete system satisfies property r words theorem reduces reasoning assumptionguarantee specifications kind reasoning used completesystem specifications among corollaries composition theorem ones allow us prove lowerlevel specification implies higherlevel one simplest result conclusion gamma gamma condition expresses correctness refinement component fixed environment assumption corollary 1 e safety property b gamma gamma 53 queue example assumptionguarantee specification queue figure 2 qe gamma qm qm qe defined 7 8 section 41 compose two queues shown figure 7 specifications queues obtained qe gamma qm substitution qe 1 gamma qm 1 qe 2 gamma qm 2 want show composition implements 2n 1element queue specified qe dbl gamma qm dbl obvious thing try prove gamma qm 1 gamma gamma qm dbl could prove used noninterleaving representation queue however 13 valid interleaving representation following rea son specification first queue mention second queue mention conjunction two specifications allows enqueue action first queue dequeue action second queue happen simultaneously step changes iack osnd simultaneously interleaving representation 2n 1element queues guarantee allow step 13 must invalid another problem 13 conjunction component queues specifications allows step changes zsnd oack simultaneously step satisfies 2n 1element queues environment assumption qe dbl mention z 13 asserts next step must satisfy guarantee qm dbl however step changes zsnd oack violates second component queues environment assumption permitting component queue make arbitrary changes osnd next step similar problem caused simultaneous changes isnd zack already faced problem disallowing simultaneous changes different components outputs section 42 decomposed interleaving specification 2n 1element queue solution strengthen nextstate actions component queues environment solution cannot used want compose preexisting specifications without modifying case prove composition implements larger queue assumption outputs two different components change simultaneously thus prove gamma qm 1 gamma gamma qm dbl g formula proof outlined figure 10 6 conclusion developed method describing components concurrent systems tla formulas shown describe complete system conjunction component specifications describe open system formula gamma e specifications environment component system component respectively although idea reducing programming concepts logic old approach new style writing specifications direct believe practical conjoining specifications delta 531 1 cqe dbl proof use propositions 2 1 remove quantifiers closure operators lefthand side implication resulting formula asserts complete system consisting safety parts two queues internal state visible together environment implements qe 1 qe 2 proof formula straightforward 2 21 211 ciqm 1 proof follows easily proposition 1 definitions 212 cqm 1 proof 211 proposition 2 since predicate safety property 213 qed proof 212 definition g proposition 5 since disjointness safety property 22 proof use propositions 2 1 remove quantifiers closures formula resulting formula proved proving safety part step 3 23 qed proof 21 22 proposition 4 3 qe dbl g qm 1 qm 2 qm dbl proof direct calculation shows lefthand side implication implies cdq completesystem specification double queue already observed section 32 cdq implements cq dbl equals qe dbl qm dbl 4 qed proof 13 composition theorem substituting fig 10 proof sketch 14 also provided rules proving properties large systems reasoning components composition decomposition theorems rather simple yet allow fairness properties hiding preceded results long list publications described next like previous composition theorems strong sense could handle circularities safety properties approach differs earlier ones general treatment fairness hiding first strong composition theorem know misra chandy 1981 considered safety properties processes communicating means csp primitives wrote assumptionguarantee specifications hoare triples containing assertions history variables pandya joseph 1991 extended approach handle liveness properties pnueli 1984 first use temporal logic write sumptionguarantee specifications strong composition theorem safety properties hiding handle liveness wrote assumptionguarantee specifications implication instead gamma obtain strong composition theorem stark 1985 also wrote assumptionguarantee specifications implications temporal formulas required circularity avoided earlier work abadi lamport 1993 semantic complicated model agents lacked practical proof rules handling fairness hiding collette 1993 adapted work unity abadi plotkin 1993 used propositional logic agents considered safety properties previous papers concerned composition assumptionguar antee specifications lacked analog decomposition theorem exception work berthet cerny 1988 used decomposition proving safety properties finitestate automata far applied composition theorem toy examples formal reasoning systems still rare generally occurs casebycase basis specification component used verify specific system need general assumptionguarantee specification practical applications decomposition suffices decomposition suffice composition theorem makes reasoning open systems almost easy reasoning complete ones used decomposition theorem difficulty toy ex amples however believe biggest payoff systems complex verify easily hand theorem makes possible decision procedures work verifying system even procedures cannot applied whole system state space large unbounded approach currently pursued one substantial ex ample mechanical verification multiplier circuit using combination tla reasoning mechanical verification cospan kurshan lamport 1993 eliminates reasoning complete lowlevel system decomposition theorem key division labor acknowledgments karlis cerans stephan merz yuan yu anonymous referees provided helpful comments earlier version conjoining specifications delta 533 r composing specifications existence refinement mappings logical view composition games full completeness multiplicative linear logic defining liveness algebraic model asynchronous circuits verification ieee trans application composition principle unitylike specifications specification design parallel programs verification multiplier 64 bits beyond computeraided verification temporal logic actions simple approach specifying concurrent systems good temporal logic introduction vlsi systems proofs networks processes transition global modular temporal reasoning programs temporal semantics concurrent programs proof technique relyguarantee properties conjunction composition revised july tr algebraic model asynchronous circuits verification simple approach specifying concurrent systems transition global modular temporal reasoning programs existence refinement mappings composing specifications logical view composition conjunction composition temporal logic actions oldfashioned recipe real time games full completeness multiplicative linear logic introduction vlsi systems application composition principle unitylike specifications proof technique relyguarantee properties verification multiplier ctr jonathan ostroff composition refinement discrete realtime systems acm transactions software engineering methodology tosem v8 n1 p148 jan 1999 carlo furia matteo rossi dino mandrioli angelo morzenti automated compositional proofs realtime systems theoretical computer science v376 n3 p164184 may 2007 fei xie guowu yang xiaoyu song componentbased hardwaresoftware coverification building trustworthy embedded systems journal systems software v80 n5 p643654 may 2007 krishnendu chatterjee thomas henzinger marcin jurdziski games secure equilibria theoretical computer science v365 n1 p6782 10 november 2006 j niehren j schwinghammer g smolka concurrent lambda calculus futures theoretical computer science v364 n3 p338356 8 november 2006 marc shapiro practical proofs concurrent programs acm sigplan notices v41 n9 september 2006 de la riva javier tuya automatic generation assumptions modular verification software specifications journal systems software v79 n9 p13241340 september 2006 arnaud bailly mireille clerbout isabelle simplotryl component composition preserving behavioral contracts based communication traces theoretical computer science v363 n2 p108123 28 october 2006 feng zhong shao modular verification concurrent assembly code dynamic thread creation termination acm sigplan notices v40 n9 september 2005 ralph jeffords constance l heitmeyer strategy efficiently verifying requirements acm sigsoft software engineering notes v28 n5 september ansuman banerjee pallab dasgupta open family temporal logics annotating temporal operators input constraints acm transactions design automation electronic systems todaes v10 n3 p492522 july 2005 flanagan stephen n freund shaz qadeer sanjit seshia modular verification multithreaded programs theoretical computer science v338 viktor vafeiadis maurice herlihy tony hoare marc shapiro proving correctness highlyconcurrent linearisable objects proceedings eleventh acm sigplan symposium principles practice parallel programming march 2931 2006 new york new york usa alur radu grosu modular refinement hierarchic reactive machines acm transactions programming languages systems toplas v26 n2 p339369 march 2004 harry c li shriram krishnamurthi kathi fisler modular verification open features using threevalued model checking automated software engineering v12 n3 p349382 july 2005 stephan merz model checking tutorial overview modeling verification parallel processes springerverlag new york inc new york ny 2001 axel van lamsweerde formal specification roadmap proceedings conference future software engineering p147159 june 0411 2000 limerick ireland alur thomas henzinger orna kupferman alternatingtime temporal logic journal acm jacm v49 n5 p672713 september 2002 juergen dingel computerassisted assumeguarantee reasoning verisoft proceedings 25th international conference software engineering may 0310 2003 portland oregon natasha sharygina james browne fei xie robert kurshan vladimir levin lessons learned model checking nasa robot controller formal methods system design v25 n23 p241270 septembernovember 2004 leila barakatain sofine tahar jean lamarche jeanmarc gendreau practical approaches verification telecom megacell using formalcheck proceedings 11th great lakes symposium vlsi p16 march 2001 west lafayette indiana united states hakan erdogmus architecturedriven verification concurrent systems nordic journal computing v4 n4 p380413 winter 1997 dachuan yu zhong shao verification safety properties concurrent assembly code acm sigplan notices v39 n9 september 2004 sagar chaki sriram k rajamani jakob rehof types models model checking messagepassing programs acm sigplan notices v37 n1 p4557 jan 2002 thomas henzinger shaz qadeer sriram k rajamani serdar tasiran assumeguarantee rule checking simulation acm transactions programming languages systems toplas v24 n1 p5164 january 2002 alur thomas henzinger reactive modules formal methods system design v15 n1 p748 july 1999 variables prove simulation specifications acm transactions computational logic tocl v6 n1 p175201 january 2005 l e moser ramakrishna g kutty p melliarsmith l k dillon graphical environment design concurrent realtime systems acm transactions software engineering methodology tosem v6 n1 p3179 jan 1997 alur radu grosu modular refinement hierarchic reactive machines proceedings 27th acm sigplansigact symposium principles programming languages p390402 january 1921 2000 boston usa michel charpentier composing invariants science computer programming v60 n3 p221243 may 2006 thomas henzinger shaz qadeer sriram k rajamani decomposing refinement proofs using assumeguarantee reasoning proceedings 2000 ieeeacm international conference computeraided design november 0509 2000 san jose california leslie lamport tla pictures ieee transactions software engineering v21 n9 p768775 september 1995 thomas henzinger xiaojun liu shaz qadeer sriram k rajamani formal specification verification dataflow processor array proceedings 1999 ieeeacm international conference computeraided design p494499 november 0711 1999 san jose california united states alberto coenporisini carlo ghezzi richard kemmerer specification realtime systems using astral ieee transactions software engineering v23 n9 p572598 september 1997 carl gunter elsa l gunter michael jackson pamela zave reference model requirements specifications ieee software v17 n3 p3743 may 2000
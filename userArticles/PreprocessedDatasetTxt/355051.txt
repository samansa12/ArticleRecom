automated systematic testing constraintbased interactive services constraintbased languages express concise way complex logic new generation interactive services applications banking stock trading must support multiple types interfaces accessing data include automatic speechrecognition interfaces inputs may provided order users service study paper systematically test eventdriven applications developed using languages show applications tested automatically without need manuallywritten test cases efficiently taking advantage capability taking unordered sets events inputs b introduction today becoming commonplace modern interactive services personal banking stock trading one interface accessing data example many banks allow customers access personal banking services automated teller machine bankby phone interface webbased interface furthermore telephonebased services starting support automatic speech recognition natural language understanding adding flexibility interaction user multiple interfaces provided service duplication serious problem may different service logic ie code defines essence service every different user interface service moreover support natural language interfaces services must allow users considerable flexibility way input service requests thus desirable programming idioms methods services provide following capabilities allow requests phrased various ways eg needed information provided order prompting missing information correction erroneous information lookahead allow user speak several commands backtracking earlier points service logic constraintbased languages foundational overview see 16 19 provide suitable paradigm support required flexibility user inputs examples languages dialogue management include methods based frames 1 forms 9 15 approaches based andor trees 22 sisl several interfaces single logic 4 powerful expressiveness constraintbased languages allows construction succinct programs complex reactive behavior motivates need reliable yet costeffective testing techniques tools suitable check correctness businesscritical applications developed using languages study paper automatically efficiently check temporal properties programs written constraintbased languages interactive services first present nondeterministic algorithm systematically testing logic program constraintbased language possible use arbitrary host language code potential elaborate access external data database lookups full program makes use classical constraint satisfaction model checking techniques problematic consequently algorithm assumes usually done testing user specifies fixed set possible data values user input algorithm dynamically detects runtime set input events application currently ready accept uses information drive execution application sending inputs selected nondeter ministically used conjunction systematic statespace exploration tool verisoft 11 supports special system call called vs toss simulating nondeterminism nondeterministic test driver systematically generate possible behaviors program behaviors monitored checked userspecified safety properties algorithm thus eliminates need manuallywritten test cases automatically applicable program testing technique made possible structured interface eventdriven constraintbased program provides environment unfortunately expressiveness constraintbased languages makes algorithm quite inefficient instance service awaits 10 inputs user particular order 10 different paths collect inputs however flip side ability accept unordered sets inputs provided order inability constraint languages observation ally distinguish permutations unordered sets inputs thus generating sequences always necessary check temporal properties considering second algorithm makes systematic testing significantly efficient exploiting observation taking advantage form symmetry induced constraints ability specify sets input events rather single events basic problems ideas discuss work common deterministic constraintbased language domain interest concrete presentation context sisl language mentioned earlier sisl includes deterministic constraintbased domainspecific language developing eventdriven reactive services implemented library java sisl supports development services shared multiple user interfaces including automatic speech recognition based textbased natural language understanding telephone voice access web graphics based interfaces sisl currently used prototype new generation call processing services lucent technologies switching product paper organized follows next section describe sisl language formalize semantics present algorithms automatically efficiently checking safety properties sisl programs algorithms implemented implementation issues discussed section 4 simple example sisl application presented section 5 results experiments example discussed finally present concluding remarks compare results related work 2 sisl several interfaces single 21 overview sisl sisl applications consist single service logic together multiple user interfaces service logic interfaces communicate via events user interfaces collect information user send service logic form events service logic reacts events reports user interfaces set enabled events ie set events ready accept current state user interfaces utilize information appropriately prompt user user interface performs functions used conjunction sisl service logic example context interactive natural language service browses displays organizational data corporate database sisl may inform naturallanguage interface accept organization eg user said show size organization interface may prompt user eg saying organization want see user responds something naturallanguage interface recognizes organization interface generate sisl event indicating organization detected event processed sisl service logic sisl service logic application specified reactive constraint graph directed graph enriched structure nodes traversal reactive constraint graphs driven reception events environment events associated label event name may carry associated data response graph traverses nodes executes actions reaction graph ends needs wait next event sent environment predicates events play important role reactive constraint graphs par ticular nodes may contain ordered set predicates indicate conjunction information received user upon receipt appropriate events predicates current node evaluated order satisfaction predicates node triggers node change graph may violation predicate reactive constraint graphs implemented java library important aspect reactive constraint graphs nodes may associated actions consisting arbitrary java code executed upon entry intoexit node actions hence side effects local global variables java program external databases note individual predicates actions associated 22 sisl process algebra section describe process algebra succinctly describe sisl programs events begin description events used process algebra set input labels set values v carried labels label associated value called event write e range v signature subset use signature jj size predicate signature boolean valued function v jj bool maps every set fa vja ftrue falseg signature predicate sometimes written syntax terms process algebra following abstract viol denote processes sequential composition viol constraint refer p viol target node predicate informal dynamic semantics process combinators following intuitive meaning sequential composition standard means p1 executed first p2 executed terminates choice functions like prefixing process alge bras process waits event label data v term corresponds choice node reactive constraint graph represents disjunction events received user every event set sisl service logic automatically sends corresponding prompt user choice node waits user send event specified set event arrives corresponding transition taken control transfers child node ensure determinism sisl program events must distinct next viol n constraint combinator interesting dynamic behavior term corresponds constraint node reactive constraint graph associated ordered set predicates events intuitively constraint node awaiting events thus node represents conjunction information received user events sent constraint node order control reaches constraint node sisl service logic automatically sends prompt event every event still needed order evaluate predicate addition automatically sends optional prompt events mentioned predicates correspond information corrected user every round interaction constraint node waits user send event mentioned associated predicates predicate associated constraint node evaluated order soon events arrived event resent user interfaces ie information corrected predicates event signature reevaluated order two ways exit constraint node predicates evaluated satisfied case control transfers p next predicate nonnull p viol evaluates false predicates j j evaluate true predicate first predicate order false viol nonnull case control transfers p viol mentioned earlier node changes may cause sideeffecting actions executed however evaluation satisfaction violation individual predicates cause side effects occur node changes described 23 sisl state machine semantics describe associated space state machines associated sisl describe semantics sisl processes state machines state machine sisl semantics tuple set input labels set states s0 unique start state f set final states transition relation v deterministic ie given state event e one 0 e 0 transition relation case write e final states outgoing transitions constructions describe denotations sisl combinators constructions state machines section use p perhaps supersubscripts range members given class state machines state machine corresponding null single state start state final state transitions sequential composition described standard fashion assumption final states arcs final states p1 redirected unique start state p2 p1 p2 formally sequential composition state machines state machine choice described building state machine adding new start state transitions labeled start state state machine p formally given state machines p resulting state machine p new state constraint viol set intermediate states sisl program goes collecting events k determined partial maps f intuitively domain partial function f written domf indicates labels data received intuition clear information still required satisfy requirements constraint node given transitions enabled state labels undefinedg furthermore start state given partial map empty domain since information received identical labels f consistent f predicates domf includes f inconsistent otherwise ie predicate domf includes f complete domf k incomplete otherwise four combinations two parameters possible formally set states partial maps f either inconsistent incomplete let transition relation states defined follows v consistent complete map transition labeled v state label f p next p next target transitions make information contained state complete consistent fashion v inconsistent map first falsified g p viol null arc labeled v state label f start state p viol causing predicate violation nonnull target node causes control move node transition labeled v state label f state label g consistent incomplete g inconsistent p viol null first predicate order falsified g predicates violated predicate null target node violated control remains constraint node transition labeled v adds changes information label state changes information called overwrite event v overwrite event causes transition state f 2 domf start state given partial map empty domain final states given union final states p next nonnull p viol formally given state machines p next nonnull p resulting state machine partial map empty domain following write target refer target node predicate 3 automatic testing sisl program section show sisl programs automatically systematically tested violations safety properties using nondeterministic testing algorithms used conjunction systematic statespace exploration tool verisoft 11 supports special system call vs toss simulating nondeterminism nondeterministic testing algorithms systematically drive execution sisl application tested order exhibit possible behaviors safety properties represented prefixclosed finite automata finite words 3 assume representation ap define safety property lp set finite words accepted finite automaton ap let alphabet ap construction contained set input events state machine representing sisl program tested call input events observable events let w jo denote projection word w 2 set definition 31 let state machine defining semantics sisl program defined previous section therefore omitted let w denote execution goes state state 0 receiving finite sequence w events include overwrite events let denote set observable events define set observable behaviors language lo finite words lo jo g words set observable behaviors sisl program respect set observable events defined set finite sequences observable events sisl program take inputs excluding overwrite events technical convenience efficiency reasons deliberately ignore overwrite events definition since occurrence artifact userinterface system affect transitions nodes nodes hence logic sisl program problem address work thus check automatically efficiently lo lp naive solution problem consists driving execution sisl program test driver nondeterministically sends enabled input event associated valid data value whenever ready take new input execution nondeterministic test driver control verisoft checking lo lp done monitoring possible executions conjunction test driver checking observable behaviors accepted ap however naive approach would generate state space typically large would render analysis intractable instance input event takes 32bit integer argument would immediately generate branching point 2 branches clearly data values cause unacceptable state explosion case constraint nodes instance one could think analysis predicates associated nodes using constraint satisfaction techniques might used generate automatically data values however approach problematic context since predicates sisl programs implemented arbitrary java code quite elaborate may involve accesses external data instance evaluation predicate may involve database lookups fetch test provisioning data subscriber service also evaluation predicate set input data values may change time evaluation predicate may depend data previously modified current execution close automatically open reactive java program general environment interesting hard problem 5 beyond scope present work therefore simply assume usually done testing user specifies fixed set valuesa possible data values input event whenever event provided input sisl program testing data value v valuesa chosen nondeterministically test driver passed argument event sisl service given set v sets valuesa data values define restriction v follows definition 32 let state machine defining semantics sisl program defined previous section let v complete valuation function associates input event finite nonempty set valuesa data values 8a call restriction v state machine ag restriction v thus set states sisl program represented reach data values associated input events taken v exclusively note since sisl programs deterministic successor state 0 reached receiving input event av state always unique remainder section discuss restricted version original problem namely check automatically efficiently lo mv lp instead lo lp simple algorithm checking whether lo mv lp presented figure 1 reached state algorithm nondeterministically selects enabled input event step 2b data value v valuesa step 2c sends av sisl program tested step 2d nondeterminism simulated special operation vs toss supported verisoft operation takes argument positive integer n returns integer 0 n operation nondeterministic execution transition starting vs tossn may yield n different successor states corresponding different values returned vs toss execution nondeterministic nonterminating test driver algorithm controled verisoft verisoft provides value returned call vs toss order systematically explore possibilities also forces termination every execution certain depth reached maximum depth specified user via one several parameters user set control statespace search performed verisoft measured number calls vs toss executed far current run algorithm checking lo mv lp done follows whenever event av sent sisl service ssv tested automaton ap representing property p evaluated av 2 automaton may move reach new state con struction ap reaches nonaccepting state means property p violated error reported search stops last scenario executed saved memory replayed later user verisoft simulator algorithm figure 1 generates possible sequences input events associated data values taken input sisl program rest section show generating sequences actually necessary check type safety properties consider precisely show initialize sisl service ssv 2 loop forever let e set nonoverwrite events enabled current state b let vs tossjej 1 let th element e c let j vs tossjvaluesaj 1 let v j th element valuesa send av ssv figure 1 simple algorithm algorithm figure 1 optimized generate possible sequences input events enabled constraint nodes provided events observable example 33 let p sisl program let 1 predicates signatures given let set observable events empty interleavings unobservable input events drive system successor node constraint node void effect property checked need generate conse quently testing constraint node requires generation one sequence input events rather sequences generated naive algorithm hand testing constraint node requires generation sequences generated naive algorithm observation exploited algorithm figure 2 algorithm behaves previous one except case constraint nodes case step 2c algorithm starts step 2cii nondeterministically choosing data value va associated input event enabled constraint node step 2ciii evaluates successively predicates constraint node predicates violated selected set data values va 2 e added set marked violated predicates unless exists another predicate j previously added marked whose signature j contained signature whose signature contains set observable events step 2ciiia selected set data values satisfy predicates node step 2civ one violated predicate set marked target 6 null nondeterministically chosen input events signature selected set events provided sisl program step 2cive otherwise predicates satisfied set set enabled input events enabled node step 2cv unobservable input events set sent sisl program step 2cvi finally remaining hence observable input events sent sisl program one one random order picked nondeterministically among set possible interleavings events step 2cvii correctness algorithm figure 2 proved showing weak bisimulation nodes reached execution algorithm nodes mv restriction v turn guarantees observable behaviors mv observed nondeterministic executions algorithm figure 2 let nodes current node sisl program state write n w denote exists sequence nonoverwrite input events w 0 w 0 jo node n n 0 traversed transition 0 theorem 34 let restriction state machine defining semantics sisl program valuation function v let state machine defined set 0 representing set state transitions performed sisl program tested algorithm figure 2 reachable state mv n w n w mv proof sketch proof immediate n constraint node consider case n constraint node let reachable state mv simplify presentation assume first state reached entering node n visit n cases treated similar way let us show every node transition n w mv matched node transition n w converse immediate exists sequence nonoverwrite input events w 0 w 0 jo node n n 0 traversed transition 0 simplicity assume 0 denote first state reached entering node n 0 executing w 0 cases treated similar way n 0 node pnext reached predicates n sat isfied set fva ja 2 w 0 g data values associated input events provided execution w 0 state 0 satisfy predicates n thus exists execution algorithm figure 2 select set data values step 2cii case none predicates node n marked algorithm select input events w sent sisl program step 2cv exists one execution algorithm send observable events w 0 order w step 2cvii otherwise n 0 nonnull target node target reached predicate n violated means set fva ja 2 data values associated input events provided execution w 0 state 0 violates predicate since reachable also means predicate violated wise target j would reached instead target executing w 0 exists execution algorithm figure 2 select step 2cii set data values fva ja 2 initialize sisl service ssv 2 loop forever let e set nonoverwrite events enabled current state b current node ssv constraint node let th element e ii let j vs tossjvaluesaj 1 let v j th element valuesa iii send av ssv c current node ssv constraint node sequence predicates associated constraint node ii loop events e order let j vs tossjvaluesaj 1 let va j th element valuesa iii loop 1 violated data values fva ja 2 eg marked implies add set marked iv jmarkedj 0 remove marked target b c let vs tossjmarkedj 1 let th element marked v else let vi 2 n send ava ssv vii loop let vs tossjs oj 1 let th element b send ava ssv c remove event set figure 2 optimized algorithm g set data values violates predicate added set marked step 2ciii algorithm unless exists another violated predicate j j previously added marked target case violating predicate also leads node n 0 via sequence w 00 input events w 00 jo case predicate whose violation leads n 0 via sequence w 000 events w 000 jo w added marked predicate selected step 2civ algo rithm events signature includes events w sent sisl program exists one execution algorithm send observable events w 000 order w step 2cvii immediate corollary theorem observable behaviors mv generated algorithm figure 1 thus used check whether lo mv lp also prove optimization constraint nodes performed step 2c algorithm figure 2 optimal following sense theorem 35 let defined theorem 34 let reachable state mv constraint node given set fva ja 2 eg data values associated input events enabled node entered n w exists exactly one transition n w proof sketch contradiction assume exists two transitions n w implies exist two predicates j n violated set fva ja 2 eg data values whose signatures included target transitions labeled w wg therefore condition step 2ciiia algorithm figure 2 j cannot added set marked hence algorithm cannot visit node n 0 twice executing two different sequences events w 0 w 00 w 0 jo jo 4 implementation issues automatically systematically test sisl programs violation safety properties using algorithms presented previous section integrated verisoft sisl verisoft tool systematically exploring state spaces systems composed several concurrent processes executing arbitrary code written language state space system directed graph represents combined behavior components system paths graph correspond sequences operations scenarios observed executions system verisoft systematically explores state space system controlling observing execution components reinitializing executions verisoft drives execution whole system intercepting suspending resuming execution specific operations system calls executed implementation tested examples operations intercepted verisoft operations communication objects eg sending receiving message vs tossn operation mentioned earlier simulates nondeterminism introduces branching point n 1 branches state space whenever executed verisoft always guarantee complete coverage state space depth words possible executions system depth guaranteed covered since verisoft typically generate execute evaluate thousands tests per minute quickly reveal behaviors virtually impossible detect using conventional testing techniques details statespace exploration techniques used verisoft given 11 verisoft applied successfully analyzing several software products developed lucent technologies telephoneswitching applications implementations network protocols eg see 12 order use verisoft controlling execution nondeterministic algorithms section 3 built verisoft interface sisl interface provides necessary information requested algorithms previous section current set enabled input events etc algorithms implemented straightforward manner java calls external operation vs toss performed using java native interface verisoft control execution resulting single process formed combination sisl application tested nondeterministic test driver intercepting calls vs toss providing value returned calls creating destroying java virtual machine reinitialize program testing safety properties used specificationbased testing package triveni 6 framework eventdriven concurrent programming java implementation uses standard algorithm 20 translate given safety formula propositional lineartime temporal logic formulas finitestate automaton whose language set finite event sequences violate formula 5 example experiments consider table 1 describes interactive banking service called teller motivate sisl implementation service describe transfer funds detail transfer capability establishes number constraints among three input events source account target account transfer amount required make specified source target accounts must valid accounts previously given loginpin dollar amount must greater zero less equal balance source account must possible transfer money source target accounts constraints capture minimum requirements input transfer transaction proceed perhaps important constraints specify example specify ordering three inputs user repeatedly entered incorrect information figure 3 depicts sisl service logic teller specified reactive constraint graph uses constraint nodes describe requirements transfer capability deposit capability withdrawal capability particular constraint node transaction type order enter service user must first provide startservice event eg dialing service going web page depicted figure 3 user must successfully log valid login pin combi nation since login pin may provided either order constraint node expresses requirement expository simplic ity assume login pin must identical login successful user successfully logged service provides choice among different transaction types starttransfer event provided example control flows transfer constraint node user prompted source ac count target account amount order user provides source account amount greater balance source account example constraint amt bal ancesrc violated since explicit failure target nodes specified control flow remain current node user provides consistent information accounts amount transfer performed control reverts back choice node transaction types selfloop annotated quit choice node indicates subgraph node repeatedly executed precondition becomes false ie user quit service temporal properties interest teller include service accept source account current transaction type either withdrawal transfer service accept target account current transaction type either deposit transfer service begin deposit transaction user given login pin past quit service property described english equivalent formula propositional lineartime temporal logic terminol ogy set observable events analyzing property set events occur corresponding formula ex ample set observable events analying first property fsrcstartwithdrawal startdeposit starttransferg particular reference last transaction type necessitates startde posit event occur corresponding formula implementation two valid accounts checking savings transfers permitted accounts different ie checking savings viceversa money market accounts considered valid accounts example initially balance accounts zero hasquit variable set false implementation portion teller consists approximately 200 lines text markup language automatically translated sisl toolset approximately 500 lines java code currently applet html automatic speech recognition voicexml 21 interfaces 300 lines sharing service logic 51 results experiments evaluate approach compare efficiency algorithms presented section 3 performed systematic statespace explorations teller service teller interactive banking service service login protected customer must authenticate entering identifier login pin password access functions customers may many money accounts functions require customer select accounts involved authenticated customer may make deposit make withdrawal service makes sure customer enough money account withdraws specified amount transfer funds accounts service prompts customer select source target account transfer amount performs transfer 1 customer enough money source account 2 transfers permitted two accounts quit service table 1 highlevel description teller loginpin isvalidsrc amt balancesrc withdrawal notify deposit notify isvalidsrc amt balancesrc transfer notify startwithdrawal startdeposit starttransfer choice node hasquitfalse userquit figure 3 reactive constraint graph teller first selected following data associated event name pin events assigned two names set fjohn maryg src tgt amt events assigned three types set fchecking savings moneymarketg amt event assigned values set f0 100g analysis first tested following temporal prop erty service accept target account current transaction type deposit set observable events property ftgt startdeposit startwithdrawal starttransferg expected algorithms reported violation trace current transaction type transfer target account accepted ran set experiments set observable events empty order measure efficiency algo rithms actually tests uncaught runtime exceptions sisl java program along paths certain depth measured number events sent service logic ran tests succession time increasing maximum depth paths explored results summarized figure 4 plot left depicts number paths explored algorithms maximum depth paths explored plot right depicts running time algorithms seconds maximum depth paths explored interesting observations made experimental data first expected running times algorithms proportional number paths explored second consider rate number paths running times increase respect maximum path depth rate significantly less optimized algorithm important observation experimental data maximum depths 5 6 optimized algorithm explores number paths hence running time phenomenon occurs optimized algorithm performs bulk work upon entry constraint node especially true case empty set observable events case work done optimized algorithm upon entry constraint node example teller paths depth 4 consist startservice event followed consistent name pin event either order followed transaction type depth 5 control enters one transaction constraint nodes optimized algorithm performs work choosing event data computing marked predicates choosing marked predicate upon entry node merely sends corresponding events fixed order hence set paths explored identical depths 5 6 running time except extremely minor activity sending additional event similar phenomenon occurs depths 8 9 10 results show even small examples teller optimized algorithm provide significant improvement efficiency example depth 11 simple algorithm takes one half hours complete optimized algorithm takes eleven minutes hence latter used efficiently systematically test much complicated services simple simple optimized figure 4 experimental results number paths explored left running time seconds right vs path depth 6 concluding remarks 61 sisl applications currently using sisl several projects involving multimodal interactive services example sisl used prototype new generation call processing services lucent technologies switching product part researchdevelopment collaboration developing call processing features may form basis new product offerings service logics features expected quite complex need tested thoroughly planning use techniques tools presented paper test applications also planning test two sisl applications developed lucent technologies interactive service based system visual exploration analysis data collaborative applications users may interact system rich collection devices 62 related work conclude comparison approach related work combining open reactive system general environment related idea hiding set visible actions process process calculus 13 17 closing automatically open reactive eventdriven programs systematic testing modelchecking purposes studied 5 8 sequential datadriven programs numerous algorithms also proposed automatically generate set input data sufficient exercise test possible paths controlflow graph program instance previous work makes extensive use static analysis techniques eg 7 18 2 automatically extract information dynamic behavior sequential program examining text contrast algorithms presented dynamically detects runtime set input events application test currently ready accept uses information drive execution without using static analysis techniques makes algorithms directly applicable host language java perl scripts etc environment including external databases etc observation exploited second algorithm namely interleavings input events constrained node sometimes effect overall behavior system somewhat similar intuition behind partialorder reduction algorithms used modelchecking prune state spaces concurrent systems eg see 10 major difference algorithms exploit notion independence commutativity actions executed interacting concurrent processes contrast constraintbased programs purely sequential reduction obtain derived directly structure program takes advantage form symmetry induced constraint nodes ability specify sets input events rather single events another example programming language construct inducing symmetry exploited verification sys tematic testing scalarset 14 7 r development principles dialogbased interfaces compilers principles recognizing safety liveness sisl several interfaces abstract interpretation unified lattice model static analysis programs construction approximation fixpoints model checking programming languages using verisoft model checking without model analysis heartbeat monitor telephone switch using verisoft communicating sequential processes better verification symmetry speech interface forms www constraint logic programming communication concurrency program flow analysis theory applications concurrent constraint programming automatatheoretic approach automatic program verification event driven model dialogue systems tr communicating sequential processes compilers principles techniques tools constraint logic programming communication concurrency concurrent constraint programming model checking programming languages using verisoft model checking without model automatically closing open reactive programs filterbased model checking partial systems abstract interpretation partialorder methods verification concurrent systems program flow analysis better verification symmetry design implementation triveni ctr jean berstel stefano crespi reghizzi gilles roussel pierluigi san pietro scalable formal method design automatic checking user interfaces proceedings 23rd international conference software engineering p453462 may 1219 2001 toronto ontario canada jean berstel stefano crespi reghizzi gilles roussel pierluigi san pietro scalable formal method design automatic checking user interfaces acm transactions software engineering methodology tosem v14 n2 p124167 april 2005 patrice godefroid software model checking verisoft approach formal methods system design v26 n2 p77101 march 2005
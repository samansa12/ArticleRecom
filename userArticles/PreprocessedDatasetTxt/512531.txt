flowsensitive type qualifiers present system extending standard type systems flowsensitive type qualifiers users annotate programs type qualifiers inference checks annotations correct system type qualifiers modeled flowsensitivelythe underlying standard types unchanged allows us obtain efficient constraintbased inference algorithm integrates flowinsensitive alias analysis effect inference ideas linear type systems support strong updates demonstrate usefulness flowsensitive type qualifiers finding number new locking bugs linux kernel b introduction standard type systems flowinsensitive meaning values type everywhere however many important program properties flowsensitive checking properties requires associating dierent facts value dierent program points paper shows extend standard type systems userspecified flowsensitive type qualifiers atomic properties refine standard types system users annotate programs type qualifiers inference checks annotations correct critical feature approach flowsensitivity restricted type qualifiers decorate typesthe underlying standard types unchangedwhich allows us obtain ecient type inference algorithm type qualifiers capture natural class flowsensitive properties ecient inference type qualifiers allows us apply implementation large code bases user annotations example type qualifiers consider type file used io operations files systems file operations used certain ways file must opened reading read must opened writing written closed file cannot accessed express rules flowsensitive type qualifiers introduce qualifiers open read write readwrite closed type open file describes file opened unknown mode type read file respectively write file file open reading respectively writing type readwrite file file open reading writing type closed file closed file qualifiers capture inherently flowsensitive properties example close function takes open file argument changes files state closed file five qualifiers natural subtyping relation readwrite read open readwrite write open qualifier closed incomparable qualifiers file may closed open qualifiers introduce subtyping common framework supports subtyping directly addition set qualifiers users define partial order qualifiers results build recent advances flowsensitive type systems 5 7 25 well previous work flowinsensitive type qualifiers 16 24 main contribution work practical flowsensitive type inference al gorithm contrast type checking systems 5 7 flowsensitive type inference algorithm made practical solving constraints lazily flowsensitive analysis explicitly forming model store every program point prohibitively expensive large code bases generating constraint system linear size typeannotated program solving portion constraints needed check qualifier annotations algorithm able scale large examples finally system designed sound aim prove absence bugs heuristically good finding bugs example believe system could integrated java sound manner shown soundness restrict section 4 key new construct system see technical report 15 since remainder system viewed simplification 25 believe straightforward prove soundness full type system using techniques section 5 report experience two applica tions analyzing locking behavior linux kernel analyzing c stream library usage application code system found number new locking bugs including extend across multiple functions even one case across multiple files 11 system architecture flowsensitive qualifier inference algorithm several interlocking components first give overview major pieces fit together expect programmers interact type sys tem adding qualifier annotations reviewing results inference thus seek system supports ecient inference straightforward programmer understand use type inference system integrates alias analysis eect inference ideas linear type systems use flowinsensitive alias analysis construct model store alias analysis infers abstract location result program expression expressions evaluate abstract location may aliased use eect inference 20 calculate set abstract locations expression e might use es evaluation eects used analyzing function calls restrict see eect inference done simultaneously alias analysis model state program point abstract store mapping abstract locations types use abstract locations flowinsensitive alias analysis allow type qualifiers underlying standard types change execution represent abstract stores using constraint formalism store constructors model allocations updates function calls store constraints c1 c2 model branch program point represented store c1 program point represented store c2 compute linearity 25 abstract location program point informally abstract location linear type system prove corresponds single concrete location every execution otherwise nonlinear perform strong updates 4 locations linear weak updates locations nonlinear strong update change qualifier locations type arbitrarily weak updates cannot change qualifiers computing linearities important interesting flowsensitive properties require strong updates system described far serious practical weakness type inference may fail location strong update needed may inferred nonlinear address new annotation restrict expression restrictx e e introduces new name x bound value e name x given fresh abstract location among aliases e x values derived x may used within e thus location x may linear hence may strongly updated even location e nonlinear use eects enforce correctness restrict expressionssoundness requires location e appear eect e use eects increase precision analysis expression e reference location determine examining eect e access value stored analysis simply flow store preceding e one immediately e without passing e e application function called many dierent contexts idea makes e fully polymorphic locations e reference 2 related work discuss three threads related work type systems dataflow analysis tools finding bugs software type systems type system inspired region alias type checking systems designed lowlevel programs 5 25 29 two recent language proposals vault 7 cyclone 17 adapt similar ideas checking highlevel pro grams languages based type checking require programmers annotate programs types contrast propose simpler less expressive monomorphic type system designed ecient type system incorporates eect inference 20 32 gain measure polymorphism recent work vault 12 includes construct focus similar restrict type state system nil 27 one earliest incorporate flowsensitive type checking xu et al 33 use flowsensitive analysis check type safety machine code type systems developed java byte code 22 26 also incorporate flowsensitivity check initialization use allow reuse local variable dierent types igarashi kobayashi 18 propose general framework resource usage analysis associates trace object specifying valid accesses object checks program satisfies trace specifications provide inference algorithm although unclear ecient practice since invokes substep unspecified algorithm check trace set valid flanagan freund 13 use type checking system verify java locking behavior java locks acquired released according lexical discipline model locking linux kernel section 5 must allow non lexically scoped lock acquires releases subset system consisting alias analysis eect inference seen monomorphic variant region inference 28 improvements region inference reported 2 much expensive precise method computing linearities dataflow analysis although typebased approach related dataflow analysis 1 diers classical dataflow analysis several ways first generate constraints stores types model program thus distinction forward backward analysis information may flow directions constraint resolution depending specified qualifier partial order second explicitly handle pointers heapallocated data aliasing strongweak updates third distinction interprocedural intraprocedural analysis system strongweak update distinction first described chase et al 4 several techniques allow strong updates proposed dataflowbased analysis programs pointers among 3 8 31 jagannathan et al 19 present system mustalias analysis higherorder languages linearity computation system corresponds singleness computation use similar technique gain polymorphism flowing bindings around function calls another recent system checking typestate properties esp 6 like proposal esp incorporates conservative alias analysis also significant dierences esp directly based dataflow analysis incorporates pathsensitive symbolic execution component esp used check correctness c stream library usage gcc bugfinding tools ast toolkit provides framework posing userspecified queries abstract syntax trees annotated type information ast toolkit successfully used uncover many bugs 30 metalevel compilation 9 system finding bugs programs programmer specifies flowsensitive property finite state automaton program analyzed traversing control paths triggering state transitions automata particular actions program statements system warns potential errors automaton enters error state 9 intraprocedural analysis lock usage linux kernel uncovered many local locking bugs typebased system found interprocedural locking bugs extended across multiple functions even one case across multiple files section 5 1 newer work metalevel compilation 10 includes interprocedural dataflow unclear interprocedural dataflow analysis handles aliasing lclint 11 dataflowbased tool checking properties programs use lclint programmer adds extra annotations program lclint performs flowsensitive intraprocedural analysis using programmers 1 bugs found newer version linux kernel examined 9 direct comparison possible though bugs cannot found purely intraprocedural analysis annotations function calls escjava 14 tool finding errors java programs escjava uses sophisticated theoremproving technology verify program properties includes rich language program annotations 3 type system describe type system using callbyvalue lambda calculus extended pointers type qualifier annota tions source language e x n xe e1 e2 ref e e e1 e2 asserte q checke q x variable n integer xe function argument x body e expression e1 e2 application function e1 argument e2 expression ref e allocates memory initializes e expression e dereferences pointer e expression e1 e2 assigns value e2 location e1 points introduce qualifiers source language adding two new forms 16 expression asserte q asserts es toplevel qualifier q expression checke q type checks es toplevel qualifier q type inference algorithm divided two steps first perform initial flowinsensitive alias analysis eect inference second generate solve store qualifier constraints compute linearities 31 alias analysis effect inference present flowinsensitive alias analysis eect inference translation system rewriting source expressions expressions decorated locations types eects target language asserte q checke q target language extends source language syntax two ways every allocation site ref e annotated abstract location allocated function annotated type parameter eect l calling function eects unions intersections eect variables represent unknown set eects eect inference solves eect constants stands either read write allocation location simplicity paper distinguish three possible eects stands although implementation foreshadowing flowsensitive analysis pointer types written ref maintain separate global abstract store ci mapping locations types ci location contains data type type inference requires also require ci contain eect l calling function figure 1 gives rules performing alias analysis effect inference translating source programs target language translation system proves judgments meaning type environment expression e translates expression e type evaluation e may eect l ref deref app figure 1 type alias eect inference set locations appearing type locst locsref locsci locst1 l t2 assume locs empty equated constructed type define locs locst briefly discuss rules figure 1 var int standard lambda calculus variable rvalue lvalue accessing variable eect ref allocates fresh abstract location add eect allocation eect record ci type location points deref evaluates e yields value type standard type inference compute location e points create fresh location equate type type ref look type location ci add eect set assign writes location note type e2 type e1 points equated types contain locations forces potentially aliased locations modeled one abstract location lam defines function annotate function eect function body type parameter function types always eect write xs cell f z checky qc source program f z checky qc b target program c x figure 2 example alias eect analysis variable arrow makes eect inference easier notice creating function eect potential allocation closure count eect closure cannot updated app applies function argument eect applying e1 e2 includes eect calling function e1 represents notice e1 argument type constrained equal type e2 forces possiblyaliased locations abstract location assert check translated unchanged target language qualifiers flowsensitive model first flowinsensitive step algorithm hides eects purely local state evaluating e produces eect location neither cannot accessed subsequent com putation thus conservatively approximate set eects may visible locs locst intersecting eects l set eects may visible increase precision eect inference turn increases precision flowsensitive type qualifier inference although syntactic rule needs applied per function body 15 figure 2 shows example program translation use syntactic sugar constructs encoded language eg assuming primitive combinator appropriate type example constant qualifiers qa q b qc discrete partial order qualifiers incomparable f turns wish check qualifier qc check succeeds model update strong update figure 2 assign x z distinct locations x z respectively f called argument z system polymorphic locations alias analysis requires types z w match thus w given type ref z finally notice since x purely local body f using rule analysis hides eects x eect f z f writes parameter w type ref z precisely f eect z let n size input program applying rules figure 1 generates constraint system size using suitable representation locs locst see 15 resolving type equality constraints usual way unification takes onn time inverse ackermans function remaining constraints eect constraints form l solve constraints ondemandin next step algorithm ask queries form l answer queries single location time 15 32 stores qualified types next perform flowsensitive analysis check qualifier related annotations second step algorithm take input program decorated types locations eects inference algorithm figure 1 throughout step treat abstract locations eects l first step constants analyze input program using extended types shown int ref c l c mergec c l filterc l qualified types standard types qualifiers inserted every level qualifiers q either qualifier variables stand currently unknown qualifiers constant qualifiers b specified user assume supplied partial order among constant qualifiers flowsensitive analysis associates store c program point contrast flowinsensitive step uses one global store c give types loca tions function types extended c l c c describes store function invoked describes store function returns location store associated linearity three linearities 0 unallocated locations 1 linear locations admit strong updates nonlinear locations admit weak updates three linearities form lattice 0 1 addition linearities expected 0 store vector assigns type linearity every abstract location computed alias analysis call vector ground store g ground store write g type g write g lin linearity g rather explicitly associating ground store every program point represent stores using constraint formalism base case model unknown store using store variable relate stores consecutive program points either store constructors see build new stores old stores store constraints generated branches program point represented store c1 program point represented store c2 solution system store constraints mapping store variables ground stores assign stores see types solution satisfies system store constraints constraint c1 c2 ref figure 3 store compatibility rules according rules figure 3 solution satisfies rules figure 4 figure 3 constraints stores yield constraints linearities types turn yield constraints qualifiers stores constraint resolution algorithm exploit fact interested qualifier relationships solve little expensive store constraints possible see section 34 ref require locations left righthand sides alias analysis enforces property corresponds standard requirement subtyping becomes equality pointer constructor emphasize step treat abstract locations constants never attempt need unify two distinct locations satisfy ref fun require eects constrained function types match exactly would also sound allow eect lefthand function subset eect righthand function figure 4 formalizes four kinds store constructors showing solution behaves constructed stores store allocc store c except location allocated allocating location aect types store increases linearity location one store mergec c l combines stores c c according eect l l mergec c l assigns type c otherwise mergec c l assigns type c linearity definition similar store filterc l assigns types linearities c locations l types locations undefined linearities locations 0 finally store assignc store c except location updated type allow subtyping step nonlinear c figure 4c require type assignc least type c corresponds weak update implementation require equality putting together intuitively linear type assignc otherwise type sc leastupper bound 33 flowsensitive constraint generation figure 5 gives type inference rules system system judgments form c meaning type environment initial store types lin otherwise lin l lin l b linearities lin sc sassignc stores assignc c weak updates figure 4 extending solution constructed stores evaluating e yields result type new store c write c type associated store c discuss computation c section 34 use function spt decorate standard type fresh qualifier store variables briefly discuss rules figure 5 var int standard int pick fresh qualifier variable annotate ns type ref adds location store c yielding store allocc type e constrained compatible type c 2 deref looks type es location current store c rule qualifier may appear es type qualifiers checked check see assign produces new store representing assignment type location lam type checks function body e fresh initial store parameter x bound type fresh qualifier variables alternative formulation track type e part constructed store alloc constrain compatible c allocation nonlinear c c c c ref ref c deref c e1 c e1 app c c asserte c c checke figure 5 constraint generation rules app constrains 2 ensure e2 type compatible e1 argument type constraint ensures current state locations e1 uses captured eect set l compatible state function e1 expects final store merge c l joins store c function call result store function intuitively rule gives us lowcost polymorphism functions act join points locations use assert adds qualifier annotation program check checks inferred toplevel qualifier e compatible expected qualifier q figure 6 shows stores store constraints generated example program slightly simplified graph clarity f initial store f final store use undirected edges store constructors directed edge c1 c2 constraint c1 c2 step constraint generation model allocation x store allocx location x initialized 0 given type 0 int fresh qualifier variable 0 ref generates constraint 0 int x require type 0 compatible x model allocation initialization z sim ilarly construct three assign stores represent assignment statements give 3 4 types 3 int 4 int respectively 3 4 fresh qualifier variables recursive call f construct filter add constraint merge store represents state recursive call f returns join two branches merge filter assign assign qc int assign z 4 int alloc x 3 int alloc z alloc x qa int allocx figure store constraints example conditional making edges notice cycle due recursion state flow merge turn flow finally qualifier check requires qualifier qc 34 flowsensitive constraint resolution rules figure 5 generate three kinds constraints qualifier constraints q q subtyping constraints store constraints c righthand side store constraint always store variable set type qualifier constraints solved om time using wellknown techniques 16 23 section focus computing solution set store constraints analysis precise locations possible nonlinear recall linearities naturally form partial order 0 1 thus given set constructed stores store constraints perform least fixpoint computation determine sc lin initially assume every store location linearity 0 exhaustively apply rules figure 4b rule lin reach fix point last rule derived figure 3 implementation compute sc lin single pass store constraints using tarjans stronglyconnected components algorithm find cycles store constraint graph cycle containing one allocation location set linearity stores cycle given algorithm compute sc lin principle solve implied typing constraints using following simple procedure store variable initialize map 1 spci 1 n spci n store assignc initialize spci thereby assigning fresh qualifiers type every location every program point replace uses c figure 5 sc using logic figure 4a apply following two closure rules constraints generated lin sc sassignc stores assignc given program size n worst case naive algorithm requires least n 2 space time build generate necessary type constraints cost high small examples reduce cost practice taking advantage several observations many locations flowinsensitive location never appears lefthand side assignment type cannot change thus give one global type instead one type per program point imperative languages c c java function parameters major source flowinsensitive locations languages parameters lvalues associated memory location initialized often never subsequently changed adding extra store variables trades space time compute sc constructed store c must deconstruct recursively reach variable store assignment see figure 4a represent eect constraints compactly linear space deconstructing filter l merge l may require potentially linear time computation check whether l recover ecient lookups replacing c fresh store variable adding constraint c rather computing sc compute requires map lookup course must use space store however shown often avoid cost completely apply transformation store constructed constraint inference every store needs every location rather assuming contains locations add needed locations lazily add location first time analysis requests whenever constraint c c sc stores constructed filter merge tend stop propagation locations saving space eg filterc l l propagate c extend idea qualifier variable inference maintains set possible qualifier constants valid solutions set contains every constant qualifier uninteresting ie constrained qualifier variables otherwise interesting type interesting qualifier interesting otherwise uninteresting modify closure rules follows sc st sc interesting lin sc sassignc assignc st sc sassignc interesting way location bound uninteresting type need propagate constraint graph figure 7 gives algorithm lazy location propagation associate mark assignc initially mark set indicating location bound uninteresting type qualifier variable appears associate pair similarly assign stores constraint resolution set possible solutions changes call propagatec propagate turn store constraint graph propagate c called already marked c nothing otherwise backprop forwardprop make appropriate constraints sc sc every store c reachable c step may add c c store variable type constraints backprop forwardprop generate may trigger subsequent calls propagate consider running example figure 8 shows locations qualifiers propagate store constraint graph dotted edges graph indicate inferred constraints discussed clarity omitted alloc edges summarized dashed line base types four type constraints figure 6 shown directed edges figure 8 example constraint 0 int x reduces constraint 0 x directed edge 0 x adding constraint cause propagation constraint among variables notice assignment type 3 int x also cause propagation constraint qa int allocx reduces qa int reduces qa constraint trigger propagation propagatey first pushes backward filter store since l propagation stops next push forward graph stop reach store assign qc int forward propagation assumes strong update contains interesting type propagated store forward graph one path propagation stops filter paths yield constraint qc notice constraint remains satisfiable constraint q b z triggers propagation step however time z l backward propagation reach filter must continue eventually reach assign z 4 int add constraint 4 z turn triggers propagation propagation step reaches adds z generates constraint 4 z finally determine assign stores x linear z nonlinear linearity computation uses alloc stores shown thus update z weak update yields constraint z 4 example illustrates three kinds propagation location x never interesting propagated graph location propagated propagation stops strong update also filter rule figure 1 able prove purely local f location z hand purely local f thus instances z conflated z admits weak updates case c already marked mark forwardpropc c c backpropc marked assignc mark assignc forwardpropc case c already allocc backpropc backpropc else backpropc backpropc else backpropc c already c c constructed c case c allocc l forwardpropc l forwardpropc filterc forwardpropc assignc forwardpropc figure 7 lazy location constraint propagation 4 restrict mentioned introduction type inference may fail location strong update needed may nonlinear practice major source nonlinear locations data structures example given linked list l alias analysis often cannot distinguish llock lnextlock hence likely nonlinear solution problem add new form restrict x e1 e2 language intuitively declares aliases e1 x copies derived x used within qc merge z z filter assign assign qc assign z 4 x 3 x x z z qa figure 8 constraint propagation e2 example consider restrict x valid invalid first assignment x valid assignment forbidden restrict check restrict using following type rule integrated first inference pass figure 1 restrict x e1 e2 restrict x e 1 e restrict bind x type fresh abstract location distinguish dereferences x dereferences aliases e1 constraint l2 forbids location dereferenced e2 notice dereferences within e2 allowed require escape scope e2 locs locsci locst2 also add eect set translate restrict target language annotating location x bound full discussion restrict including soundness proof found technical report 15 use restrict locally recover strong updates key observation location e1 location x dierent thus even linearity linearity 1 therefore within body e2 may able perform strong updates scope restrict ends may need weak update example suppose wish type check state change lock deep within data structure location lock nonlinear following atypical linux kernel code nonlinear loc assuming type system determines contains accesses aliases lock alias lock nonlinear location modify code type check follows restrict lock abcdlock flowsensitive step use following inference rule restrict c restrict x e1 e2 2 restrict rule infer type e1 pointer location create new store c location x allocated initialized c added type environment evaluate e2 finally result store store c potentially update assigning contents 5 experiments test ideas practice built tool cqual implements inference algorithm use cqual programmers annotate c programs type quali fiers added c syntax way const 16 tool cqual analyze single file whole program standard typebased analysis analyzing single file programmer supplies type signatures external functions variables used cqual check two program properties locking 249 linux kernel device drivers uses c stream library implementation sound unsafe features c type casts variableargument functions illdefined pointer arithmetic currently make attempt track eect features aliasing except special case type casting result malloclike functions combination system enforcing memory safety ccured 21 implementation would sound implementation allow strong updates locations containing functions improves eciency never need recompute sc lin weak updates add constraints stores additionally observe allocations aect linearities types reads writes aect types linearities thus implementation also improve precision analysis distinguishing read write allocation eects omit details due space constraints analysis results presented user emacsbased user interface source code colored according inferred qualifiers type errors hyperlinked source line error first occurred user click qualifiers view path constraint graph shows type error de tected found ability visualize constraint solutions terms original source syntax use ful essential understanding results inference detail ideas user interface found 24 51 linux kernel locking linux kernel includes two primitive locking functions used extensively device drivers void spinlockspinlockt lock void spinunlockspinlockt lock use three qualifiers locked unlocked unknown check locking behavior subtyping relation locked unlocked assign spin lock type c ref assignc locked spinlock unlocked spinlock omit function qualifier since irrelevant type spin lock requires lock passed argument unlocked see clause changes locked upon returning signature spin unlock locked unlocked exchanged practice give spin lock type signature supplying cqual following definition void spinlockunlocked spinlockt lock locked spinlockt change typex like assignment something type except rather give explicit righthand side give type righthand side case programmer needs supply body spin lock inline assembly code since implementation currently lacks parametric poly morphism inline calls spin lock spin unlock using type signatures check three kinds errors deadlocks acquiring lock already held thread attempts release lock already released thread attempting acquire release lock unknown state analyzed 513 whole device driver modules whole module includes files make single driver module must meet wellspecified kernel interface model main function nondeterministically calls possible driver functions registered kernel also separately analyzed 892 driver files making whole modules experiments removed qualifier locked unlocked incomparable made optimistic assumptions environment file invoked examined results 64 513 whole device driver modules 892 separately analyzed driver files found 14 apparently new locking bugs including one spans multiple files five apparent bugs function tries acquire lock already held function call chain leading deadlock example emu10k1 module contains deadlock omit void return emu10k1muteirqhandlerstruct emu10k1card card struct patchmanager spinlockirqsavemgrlock flags emu10k1setossvolcard emu10k1setossvolstruct emu10k1card card emu10k1setvolumegprcard emu10k1setvolumegprstruct emu10k1card card struct patchmanager spinlockirqsavemgrlock flags note detecting error requires interprocedural analysis one goals understand often system fails type check real programs categorized every type error separate file analysis driver files experiment 52 files fail type check 11 files locking bugs sometimes one remaining 41 files type errors half type errors due incorrect assumptions interface functions type errors eliminated moving whole module analysis remaining type errors fall two main categories many cases problem alias analysis strong enough type check program another common class type errors arises locks conditionally acquired released case lock acquired predicate p true lock released p tested check whether lock held system path sensitive tool signals type error point path lock acquired joins path lock acquired since use single file experimentsin whole module analysis error detected later attempt acquire release lock state examples could rewritten little eort pass type system opinion would usually make code clearer saferthe duplication test p invites new bugs program modified even improvements expect dynamically correct programs type check future work propose following solution qualifier represents unknown state use information constraints automatically insert coercions needed execution coercions perform runtime tests verify locks correct state thus approach introduce dynamic type checking situations cannot prove safety statically 513 whole modules 196 contain type errors many duplicates shared code examined 64 type errorcontaining modules discovered major source type errors multiple aliases location one alias actually used code interest surprisingly larger programs whole modules problems spurious aliasing optimistic singlefile analysis added restrict annotations hand 64 modules looked including emu10k1 module yielded largest number false positives using restrict eliminated false positives modules occurred nonlinear locations could strongly updated supports belief restrict right tool dealing necessarily conservative alias analysis currently adding restrict hand burdensome requiring relatively large number annotations leave problem automatically inferring restrict annotations future work 52 c stream library mentioned introduction c stream library 0k 100k 200k 300k 400k 500k 600k 700k 800k size preprocessed lines code time sec flow sensitive flow insensitive parsing1003005007009000k 100k 200k 300k 400k 500k 600k 700k 800k size preprocessed lines code space mbytes figure 9 resource usage whole module analysis interface contains certain sequencing constraints ex ample file must opened reading read special property c stream library result fopen must tested null used fopen may may succeed class c stream library usage errors tool detect includes files used without opened checked null files opened accessed incompatible mode files accessed closed omit details due space constraints tried tool two application programs man15h1 sendmail8116 primarily interested performance tool complex application see expect find latent stream library usage bugs mature programs however find one minor bug sendmail opened log file never closed circumstances 53 precision efficiency algorithm described section 34 carefully designed limit resource usage figure 9 shows time space usage whole module analysis versus preprocessed lines code 513 linux kernel modules experiments done dual processor 550 mhz pentium iii 2gb memory running redhat 62 divide resource usage c parsing type checking flowinsensitive analysis flowsensitive analy sis flowinsensitive analysis consists alias eect inference figure 1 together flowinsensitive qualifier inference 16 flowsensitive analysis consists constraint generation resolution described sections 33 34 including linearity computation graphs reported time space phase includes time space previous phases graphs show space overhead flowsensitive analysis relatively small appears scale well large modules modules space usage flowsensitive analysis within 31 space usage flowinsensitive analysis running time analysis variable absolute running times within factor 13 flowinsensitive running times analysis sendmail8116 175193 preprocessed source lines took 288 seconds 264mb man15h1 16411 preprocessed source lines took 185 seconds 32mb results suggest algorithm also behaves eciently checking c stream library usage 6 conclusion presented system extending standard type systems flowsensitive type qualifiers given lazy constraint resolution algorithm infer type qualifier annotations shown analysis eective practice finding number new locking bugs 7 r better static memory management improving regionbased analysis higherorder languages extended form must alias analysis dynamic allocation analysis pointers structures typed memory management calculus capabilities enforcing highlevel protocols lowlevel software checking system rules using systemspecific bugs deviant behavior general approach inferring errors systems code static detection dynamic memory errors adoption focus practical linear types imperative programming extended static checking java checking programmerspecified nonaliasing theory type qualifiers cyclone users manual resource usage analysis simple tractable constraints finite semilattices detecting format string vulnerabilities type qualifiers alias types type system java bytecode subroutines programming language concept enhancing software reliability implementation typed callbyvalue calculus using stack regions alias types recursive data structures personal communication typing references e typestate checking machine code tr compilers principles techniques tools typestate programming language concept enhancing software reliability polymorphic effect systems analysis pointers structures typing references effect inference implementation typed callbyvalue myampersand955calculus using stack regions contextsensitive interprocedural pointsto analysis presence function pointers extended form must alias analysis dynamic allocation efficient contextsensitive pointer analysis c programs better static memory management static detection dynamic memory errors type system java bytecode subroutines single loving simple comprehensive type system java bytecode subroutines typed memory management calculus capabilities theory type qualifiers typebased race detection java enforcing highlevel protocols lowlevel software bugs deviant behavior ccured resource usage analysis adoption focus extended static checking java alias types typestate checking machine code tractable constraints finite semilattices alias types recursive data structures cyclone users manual version 013 checking programmerspecified nonaliasing ctr david greenfieldboyce jeffrey foster visualizing type qualifier inference eclipse proceedings 2004 oopsla workshop eclipse technology exchange p5761 october 2424 2004 vancouver british columbia canada futoshi iwama naoki kobayashi new type system jvm lock primitives proceedings asian symposium partial evaluation semanticsbased program manipulation p7182 september 1214 2002 aizu japan gary wassermann zhendong su sound precise analysis web applications injection vulnerabilities acm sigplan notices v42 n6 june 2007 brian chess gary mcgraw static analysis security ieee security privacy v2 n6 p7679 november 2004 vincent simonet extension hmx bounded existential universal datatypes acm sigplan notices v38 n9 p3950 september timothy fraser nick l petroni jr william arbaugh applying flowsensitive cqual verify minix authorization check placement 3 proceedings 2006 workshop programming languages analysis security june 1010 2006 ottawa ontario canada futoshi iwama atsushi igarashi naoki kobayashi resource usage analysis functional language exceptions proceedings 2006 acm sigplan symposium partial evaluation semanticsbased program manipulation january 0910 2006 charleston south carolina ranjit jhala rupak majumdar bit level types high level reasoning proceedings 14th acm sigsoft international symposium foundations software engineering november 0511 2006 portland oregon usa david koes mihai budiu girish venkataramani programmer specified pointer independence proceedings 2004 workshop memory system performance june 0808 2004 washington dc benjamin chelf dawson engler seth hallem write systemspecific static checkers metal acm sigsoft software engineering notes v28 n1 p5160 january thomas henzinger ranjit jhala rupak majumdar permissive interfaces acm sigsoft software engineering notes v30 n5 september 2005 yanhong liu tom rothamel fuxiang yu scott stoller nanjun hu parametric regular path queries acm sigplan notices v39 n6 may 2004 yoann padioleau julia l lawall gilles muller understanding collateral evolution linux device drivers acm sigops operating systems review v40 n4 october 2006 eran yahav g ramalingam verifying safety properties using separation heterogeneous abstractions acm sigplan notices v39 n6 may 2004 samuel z guyer calvin lin error checking clientdriven pointer analysis science computer programming v58 n12 p83114 october 2005 junfeng yang ted kremenek yichen xie dawson engler meca extensible expressive system language statically checking security properties proceedings 10th acm conference computer communications security october 2730 2003 washington dc usa yichen xie alex aiken scalable error detection using boolean satisfiability acm sigplan notices v40 n1 p351363 january 2005 atsushi igarashi naoki kobayashi resource usage analysis acm transactions programming languages systems toplas v27 n2 p264313 march 2005 naoki kobayashi time regions effects resource usage analysis acm sigplan notices v38 n3 march atsushi igarashi naoki kobayashi generic type system picalculus theoretical computer science v311 n13 p121163 23 january 2004 j field goyal g ramalingam e yahav typestate verification abstraction techniques complexity results science computer programming v58 n12 p5782 october 2005 system resource protocol verification correctness proof proceedings 2004 acm sigplan symposium partial evaluation semanticsbased program manipulation p135146 august 2425 2004 verona italy yitzhak mandelbaum david walker robert harper effective theory type refinements acm sigplan notices v38 n9 p213225 september kevin w hamlen greg morrisett fred b schneider certified inlined reference monitoring net proceedings 2006 workshop programming languages analysis security june 1010 2006 ottawa ontario canada seth hallem benjamin chelf yichen xie dawson engler system language building systemspecific static analyses acm sigplan notices v37 n5 may 2002 ranjit jhala rupak majumdar path slicing acm sigplan notices v40 n6 june 2005 thomas henzinger ranjit jhala rupak majumdar kenneth l mcmillan abstractions proofs acm sigplan notices v39 n1 p232244 january 2004 yichen xie alex aiken saturn scalable framework error detection using boolean satisfiability acm transactions programming languages systems toplas v29 n3 p16es may 2007 alex aiken jeffrey foster john kodumal tachio terauchi checking inferring local nonaliasing acm sigplan notices v38 n5 may adrian birka michael ernst practical type system language reference immutability acm sigplan notices v39 n10 october 2004 christian skalka trace effects object orientation proceedings 7th acm sigplan international conference principles practice declarative programming p139150 july 1113 2005 lisbon portugal nurit dor stephen adams manuvir das zhe yang software validation via scalable pathsensitive value flow analysis acm sigsoft software engineering notes v29 n4 july 2004 ted kremenek ken ashcraft junfeng yang dawson engler correlation exploitation error ranking acm sigsoft software engineering notes v29 n6 november 2004 junfeng yang paul twohey dawson engler madanlal musuvathi using model checking find serious file system errors proceedings 6th conference symposium opearting systems design implementation p1919 december 0608 2004 san francisco ca murali krishna ramanathan ananth grama suresh jagannathan static specification inference using predicate mining acm sigplan notices v42 n6 june 2007 weingan chin siaucheng khoo shengchao qin corneliu popeea huu hai nguyen verifying safety policies size properties alias controls proceedings 27th international conference software engineering may 1521 2005 st louis mo usa polyvios pratikakis jaime spacco michael hicks transparent proxies java futures acm sigplan notices v39 n10 october 2004 jeffrey fischer ranjit jhala rupak majumdar joining dataflow predicates acm sigsoft software engineering notes v30 n5 september 2005 karl chen david wagner largescale analysis format string vulnerabilities debian linux proceedings 2007 workshop programming languages analysis security june 1414 2007 san diego california usa matthew tschantz michael ernst javari adding reference immutability java acm sigplan notices v40 n10 october 2005 junfeng yang paul twohey dawson engler madanlal musuvathi using model checking find serious file system errors acm transactions computer systems tocs v24 n4 p393423 november 2006 madanlal musuvathi dawson r engler model checking large network protocol implementations proceedings 1st conference symposium networked systems design implementation p1212 march 2931 2004 san francisco california manuvir das sorin lerner mark seigle esp pathsensitive program verification polynomial time acm sigplan notices v37 n5 may 2002 nic volanschi condate protolanguage confluence checking compiling proceedings 8th acm sigplan symposium principles practice declarative programming july 1012 2006 venice italy gregor snelting torsten robschink jens krinke efficient path conditions dependence graphs software safety analysis acm transactions software engineering methodology tosem v15 n4 p410457 october 2006 tian zhao jens palsberg jan vitek typebased confinement journal functional programming v16 n1 p83128 january 2006 brian chin shane markstrum todd millstein semantic type qualifiers acm sigplan notices v40 n6 june 2005 polyvios pratikakis jeffrey foster michael hicks locksmith contextsensitive correlation analysis race detection acm sigplan notices v41 n6 june 2006 xiaolan zhang larry koved marco pistoia sam weber trent jaeger guillaume marceau liangzhao zeng case analysis preserving language transformation proceedings 2006 international symposium software testing analysis july 1720 2006 portland maine usa todd millstein practical predicate dispatch acm sigplan notices v39 n10 october 2004 cristian cadar vijay ganesh peter pawlowski david l dill dawson r engler exe automatically generating inputs death proceedings 13th acm conference computer communications security october 30november 03 2006 alexandria virginia usa john tang boyland william retert connecting effects uniqueness adoption acm sigplan notices v40 n1 p283295 january 2005 david hovemeyer william pugh finding bugs easy acm sigplan notices v39 n12 december 2004 philip w l fong pluggable verification modules extensible protection mechanism jvm acm sigplan notices v39 n10 october 2004 yaowen huang fang yu christian hang chunghung tsai dertsai lee syyen kuo securing web application code static analysis runtime protection proceedings 13th international conference world wide web may 1720 2004 new york ny usa chris andreae james noble shane markstrum todd millstein framework implementing pluggable type systems acm sigplan notices v41 n10 october 2006 jeffrey foster robert johnson john kodumal alex aiken flowinsensitive type qualifiers acm transactions programming languages systems toplas v28 n6 p10351087 november 2006 pistoia chandra j fink e yahav survey static analysis methods identifying security vulnerabilities software systems ibm systems journal v46 n2 p265288 april 2007 pistoia chandra j fink e yahav survey static analysis methods identifying security vulnerabilities software systems ibm systems journal v46 n2 p265288 april 2007
asynchronous parallel algorithms test set partitioned fault simulation propose two new asynchronous parallel algorithms test set partitioned fault simulation algorithms based new twostage approach parallelizing fault simulation sequential vlsi circuits test set partitioned among available processors algorithms provide result previous synchronous two stage approach however due dynamic characteristics algorithms due fact minimal redundant work run faster previous synchronous approach theoretical analysis comparing various algorithms also given provide insight algorithms implementations done mpi therefore portable many parallel platforms results shown shared memory multiprocessor b introduction fault simulation important step electronic design process used identify faults cause erroneous responses outputs circuit given test set objective fault simulation algorithm find fraction total faults sequential circuit detected given set input vectors also referred fault coverage simplest form fault injected logic circuit setting line gate faulty value 1 0 effects fault simulated using zerodelay logic simula tion fault simulation algorithms typically 2 time complexity n number lines circuit studies shown little hope finding lineartime fault simulation algorithm 1 typical fault simulator good circuit faultfree cir cuit faulty circuits simulated test vec tor output responses faulty circuit differ good circuit corresponding fault detected fault dropped fault list speeding simulation subsequent test vectors fault simulator research supported part semiconductor research corporation contract src 95dp109 advanced research projects agency contract daah0494g0273 dabt6395c0069 administered army research office run standalone mode grade existing test set interfaced test generator reduce number faults must explicitly targeted test generator random pattern environment fault simulator helps evaluating fault coverage set random patterns either two environments fault simulation consume significant amount time especially random pattern test ing millions vectors may simulated thus parallel processing used reduce fault simulation time significantly propose paper two scalable asynchronous parallel fault simulation algorithms test vector set partitioned across processors paper organized follows section 2 describe various existing approaches parallel fault simulation motivate need test set partitioned approach parallel fault simulation section 3 discuss approach test sequence partitioning section 4 present various algorithms implemented including two proposed asynchronous algorithms theoretical analysis sequential parallel algorithms proposed given section 5 provide deeper insight algorithms results presented section 6 algorithms compared section 7 conclusion parallel fault simulation due long execution times large circuits several algorithms proposed parallelizing sequential circuit fault simulation 2 circuit partitioning approach parallel sequential circuit fault simulation described 3 algorithm implemented sharedmemory multi processor circuit partitioned among processors since circuit evaluated levelbylevel barrier synchronization level gates level evenly distributed among processors balance work loads average speedup 216 obtained 8 proces sors speedup iscas89 circuit s5378 329 approach suitable sharedmemory architecture circuits many levels logic algorithmic partitioning proposed concurrent fault simulation 45 pipelined algorithm developed specific functions assigned processor estimated speedup 4 5 reported 14 processors based software emulation messagepassing multicomputer 5 limitation approach cannot take advantage larger number processors fault partitioning straightforward approach parallelizing fault simulation approach 67 fault list statically partitioned among processors processor must simulate good circuit faulty circuits partition good circuit simulation one processor obviously redundant computation alterna tively sharedmemory multiprocessor used good circuit may simulated one processor remaining processors lie idle processing performed least first time frame fault partitioning may also performed dynamically fault simulation even workloads processors expense extra interprocessor communication 6 speedups range 2438 obtained static fault partitioning 8 processors larger iscas89 circuits reasonably high fault coverages eg s5378 improvements obtained circuits dynamic fault partitioning due overheads load redistribution 6 however static dynamic fault partitioning approaches shortest execution time bounded time perform good circuit logic simulation single processor one observation made fault partitioning experiments larger speedups obtained circuits lower fault coverages 67 results highlight fact potential speedup drops number faults simulated drops since good circuit evaluation takes larger fraction computation time good circuit evaluation parallelized fault partitioning ap proach therefore speedups limited example good circuit logic simulation takes 20 percent total fault simulation time single processor dahls law one cannot expect speedup 5 number processors parallelization good circuit logic simulation simply logic simulation therefore important known difficult problem implementations shown appreciable speedup parallelizing logic simulation based partitioning circuit suggested successful due high level communication required parallel processors recently new algorithm proposed test vector set partitioned among processors 8 call algorithm spitfire1 fault simulation proceeds two stages first stage fault list partitioned among processors processor performs fault simulation using fault list test vectors partition second stage undetected fault lists first stage combined processor simulates faults list using test vectors partition obviously test set partitioning strategy provides scalable implementa tion since good circuit logic simulation also distributed processors test set partitioning also used parallel fault simulator zamlog 9 zamlog assumes independent test sequences provided form par tition one test sequence given zamlog partition example 4 independent sequences given cannot use 4 processors work make assumption independence test sequences hence scalable number processors shown 8 10 synchronous twostage al gorithm spitfire1 performs better fault partitioned parallel approaches synchronous algorithms spit fire2 spitfire3 extensions spit fire1 algorithm presented 10 spitfire3 particular synchronous pipelined approach helps overcoming pessimism may exist single two stage approach propose paper two new asynchronous algorithms based test set partitioning strategy parallel fault simulation demonstrate asynchronous algorithms perform better synchronous counterparts shall provide reasons first algorithm spitfire4 two stage algorithm modification spitfire1 algorithm described leaves first stage unchanged second stage implemented asynchronous communication processors second algorithm spitfire5 obviates need two stages entire parallel fault simulation strategy accomplished one stage asynchronous communication processors 3 test sequence partitioning parallel fault simulation test sequence partitioning illustrated figure 1 use terms test set test sequence interchangeably assumed ordered set test vectors test set partitioned example test sequence 5n vectors 5 processors test sequence processors 3n figure 1 test sequence partitioning among available processors processor performs good faulty circuit simulations vectors partition starting allunknown x state course state would really unknown segments first partition vectors since unknown state superset known state simulation correct may x values outputs serial simulation considered pessimistic simulation sense parallel implementation produces x outputs fact known 0 1 pure logic simulation perspective pessimism may may acceptable however context fault simulation effect unknown values faults detected serial simulation detected parallel simulation rather accept small degree pes simism test set partioning algorithm tries correct much possible compute starting state test segment vectors prepended segment preceding seg ment process creates overlap vectors successive segments shown figure 1 hypothesis vectors act initializing vectors bring machine state close correct state exactly state even computed state close actual state still far fewer unknown values exist starting allunknown state results 8 showed approach indeed reduces pessimism number fault detections number initializing vectors required depends circuit easy initialize overlap larger necessary redundant computations performed adjacent processors efficiency lost however overlap small faults detected test set may identified thus fault coverage reported may overly pessimistic 4 parallel test partitioned algorithms describe four different algorithms test set partitioned parallel fault simulation first two algorithms parallel singlestage twostage synchronous approaches proposed earlier810 third fourth algorithms parallel twostage singlestage asynchronous approaches 41 spitfire0 single stage synchronous algorith approach test set partitioned across processors described previous section algorithm presented base reference various test set partitioning approaches described later entire fault list allocated processor thus processor targets entire list faults using subset test vectors processor proceeds independently drops faults detect results merged end 42 spitfire1 synchronous two stage algorithm simple algorithm described somewhat inefficient many faults testable detected test segments simulating faults processors waste time therefore one filter easytodetect faults initial stage set test set partitioned among processors results two stage algorithm first stage processor targets subset faults using subset test vectors illustrated figure 2 large fraction f f f f f 5224partitioning stage 1 u partitioning stage 2 u u u u figure 2 partitioning spitfire1 detected faults identified initial stage remaining faults simulated processors second stage algorithm proposed 8 overall algorithm outlined 1 partition test set among p processors g 2 partition fault list f among p processors g 3 processor p performs first stage fault simulation applying f let list detected faults undetected faults processor p fault simulation c u respectively 4 processor p sends detected fault list c processor 5 processor p 1 combines detected fault lists processors computing broadcasts total detected fault list c processors 7 processor p finds list faults needs target second stage g 8 reset circuit 9 processor p performs second stage fault simulation applying test segment fault list g 10 processor p sends detected fault list processor 11 processor p 1 combines detected fault lists processors computing result parallel fault simulation list detected faults c available processor p 1 note g equivalent expression g reason second stage necessary every test vector must eventually target every undetected fault already detected processor thus initial fault partitioning phase used reduce redundant work may arise detecting easyto detect faults observed though one perform two stages good circuit simulation test segment processor however first stage eliminates lot redundant work might otherwise per formed hence twostage approach preferred test set partitioning approach parallel fault simulation subject inaccuracies fault coverages reported circuit cannot initialized quickly unknown state beginning test segment problem avoided test set partitioned segment starts initialization sequence definitive redundant computation approach overlap test segments good circuit simu lation however overlap small compared size test segment assigned processor redundant computation negligible another source redundant computation second stage processor target entire list faults remains excluding faults left undetected processor situ ation one processors detects fault may drop fault fault list processors may continue targeting fault detect fault complete simulation ie second stage fault simulation ends redundantcomputationoverheadcould reduced broadcasting fault identifier corresponding fault processors soon fault detected however savings computation might offset overhead communication costs 43 spitfire4 two stage asynchronous algorith describe asynchronousversion algorithm spitfire1 consider second stage fault simulation algorithm spitfire1 processors work almost list undetected faults available end first stage except faults could detect stage 1 would therefore advantageous processor periodically communicate processors list faults detects thus processor asynchronously sends list new detected faults processors provided detected least minfaultlimit new faults processor periodically probes messages processors drops faults may received messages helps reducing load processor detected faults yet thus allowing processor asynchronously communicate detected faults processors dynamically reduce load processor observed first stage algorithm spitfire1 processors working different sets faults hence need communicate detected faults stage 1 since effect workload processor would make sense therefore communicate detected faults end stage 1 asynchronous algorithm used fault simulation stage 2 processor p outlined vector k test set faultsimulate vector k numberofnewfaultsdetected minfaultlimit send list newly detected faults processors using buffered asynchronous send checkforanymessages receive new message using blocking receive drop newly received faults dropped earlier end routine checkforanymessages nonblocking probe returns 1 message pending received 44 spitfire5 single stage asynchronous algorith possible employ asynchronous communication strategy used algorithm spitfire4 algorithm spitfire0 latter algorithm processors start list undetected faults entire list faults f faults processor may detect get dropped processor continues work large set undetected faults would make sense processor communicate detected faults periodically processors provided detected least minfaultlimit new faults value minfaultlimit circuit dependent also depends parallel platform may used parallel fault simulation small circuit mostly easy detect faults may make sense set minfaultlimit small may result many messages commu nicated hand circuit reasonably large faults hard detect granularity computation two successive communication steps large therefore may make sense small value min faultlimit similarly may expensive communicate often distributed parallel platform network workstations however factor may matter much shared memory machine results obtained shared memory multiprocessor value minfault limit empirically chosen 5 show means whenever processor detects least 5 faults communicate new faults detected processors possibly reduce load processors may still working faults therefore important ensure computation communication ratio kept high hence depending parallel platform used one needs arrive compromise frequency faults communicated processors one may also use number vectors test set simulated say minvectorlimit control parameter regulate frequency synchro nization may useful towards end fault simulation faults detected slowly one also use parameters minfaultlimit minvectorlimit sim ulaneously communicate faults either control parameter exceeded long granularity computation large enough compared communication costs involved one expect good performance asynchronous ap proach assume communication costs zero one would ideally communicate faults soon detected processors frequency communication reduced one may perform redundant computation tradeoff algorithms spitfire4 spitfire5 see spitfire4 completely communication independent phase stage 1 followed asynchronous communication intensive phase however spitfire5 one stage fault simula tion means good circuit simulation test set processor p needs performed thus although may continuous communication algorithm spitfire5 may obtain substantial savings performing one stage fault simulation see next section indeed case approach asynchronous communication discussed previous section used algo rithm however asynchronous communication applied first stage fault simulation used algorithm 5 analysis algorithms theoretical analysis various algorithms pre sented first provide analysis serial fault simulation extend analysis various test set partitioning approaches fault partitioning approach 51 analysis sequential fault simulation first provide analysis uniprocessor proceed analysis multiprocessor situation let us assume n test vectors test set f g usually fault simulation many faults detected early remaining faults detected slowly let us assume fraction faults detected vector k test set given ffe gammakgamma1 ie fraction faults detected step falls exponentially tradition ally one assumes fraction faults left undetected kth vector simulated given ff 1 e gammak 3 11 hence fraction faults detected vector k given form ffe gammakgamma1 fraction faults detected stage n1 vectors simulated given 1gammae gamma hence number undetected faults remaining un nth vector simulated given total number faults circuit let us assume fl unit cost execution seconds per gate evalu ation assume fraction ffi total number gates g circuit simulated fault cost simulating faulty circuits left nth vector fl ffigun assume fraction fi gates g simulated good circuit logic simulation vector usually ffi fi fault simulation events triggered fanout cone starting node fault inserted need processed fault simulation cost simulation nth vector given flfig ffigun thus total fault simulation cost uniprocessor 1 n f g simulating n vectors given since n large may approximate 1gammae gamman 1 find 1 n f neglecting r relation n obtain 52 analysis algorithm spitfire0 single stage test set partitioned parallel algorithm processor simulates n vectors vector overlap processors processor also starts number faults f single stage synchronous algo rithm communication occurs end processors exchange detected faults neglected comparison total execution time therefore total execution cost psync1stage n f g approximated g formula shows approach scalable one pay redundant computation performed vector overlap factor 53 analysis fault partitioning algorithm fault partitioning algorithm processor simulates n vectors targets f faults hence execution cost case form f formula demonstrates fault partitioned approach scalable since first term corresponds good circuit logic simulation performed scale across processors eventually factor bound speedup number processors increased table 1 uniprocessor execution times pri pri random test set actual test mary mary size 10000 atpg tool inp flip time faults test set time faults circuit faults gates uts puts flops secs detected size secs detected table 2 execution time 8 processors sunsparccenter1000e shared memory multiprocessor random test test faults execution time secs faults execution time secs circuit faults detected spf0 spf1 spf4 spf5 detected spf0 spf1 spf4 spf5 s526 555 52 167 104 133 82 445 85 51 30 23 div16 2141 1640 192 260 248 134 1801 537 283 211 132 pcont2 11300 6829 1138 1377 1407 1044 6837 1163 1103 755 526 piir8 19920 15004 2858 2713 2650 2309 15069 511 484 443 336 54 analysis algorithm spitfire5 single stage asynchronous algorithm may assume due communication processors aware detected faults test vector input assume purposes analysis minf aultlimit 1 means processor broadcasts new faults dropped every time detects least 1 fault faults detected processors stage different number faults detected n1 vectors simulated given case g c pasync1stage n f communication cost involved reality faults multiply detected one processor factor pff formula smaller also since delay processor obtaining information faults dropped processors factor may even smaller also minf aultlimit large delay may even longer factor pff would scaled smaller value pff indicates longer execution time let us assume communication cost form 1 2 l 1 startup cost seconds 2 cost seconds per computer word l length message since f ffr1 gamma detected nth vector simulated p processors total cost communication given c pasync1stage n f note minf aultlimit large number messages smaller term 1 np would scaled however term would remain unchanged since total amount data communicated clearly tradeoff involved increasing value minf aultlimit 55 analysis spitfire1 spitfire4 easy show using similar analysis total execution cost two stage algorithms spitfire1 spitfire4 obtained replacing f f 1 e gamma n counting good circuit simulation cost twice formulas execution cost algorithms spitfire0 spitfire5 respectively apparent two stage algorithms effectively reduced faulty circuit simulation term could pay small price perform two stages good circuit logic simulation addition gammapff term helps reducing execution time asynchronous two stage algorithm see discussion asynchronous algorithms would possibly lowest execution time table 3 execution time speedups sunsparccenter1000e algorithm spitfire5 random test random test set execution timesseconds speedups uniprocessor 2 processors 4 processors 8 processors circuit time time speedup time speedup time speedup s526 5739 2850 201 1476 388 825 695 mult16 1433 6436 223 3321 431 2037 703 div16 1106 4895 225 2476 446 1338 826 table 4 execution time speedups sunsparccenter1000e algorithm spitfire5 atpg test atpg test set execution timesseconds speedups uniprocessor 2 processors 4 processors 8 processors circuit time time speedup time speedup time speedup s526 1092 570 191 403 270 226 483 pcont2 3244 16827 193 9615 337 5256 617 piir8 1274 7410 172 451 282 336 379 synchronous counterparts two factors contributing first n term corresponds partitioning test set across processors second gammapff term corresponding fact processor information faults processors dropped due asynchronous communication two asynchronous algorithms single stage asynchronous algorithm may win two stage algorithm simply one stage good circuit logic simulation performed case communication cost factor depend platform used may different impact different parallel platforms however long overall communication cost small compared overall execution cost single stage asynchronous algorithm run faster approaches 6 experimental results four algorithms described paper implemented using mpi 12 library implementation portable parallel platform provides support mpi communication library results obtained sunsparccenter 1000e shared memory multiprocessor 8 processors 512 mb memory results provided 8 circuits viz s5378 s526 s1423 am2910 pcont2 piir8o mult16 div16 circuits chosen test sets available reasonably large mult16 circuit 16bit twos complement multiplier div16 16bit divider am2910 12bit microprogram sequencer pcont2 8bit parallel controller used dsp applica tions piir8 8point infinite impulse response filter s5378 s526 s1423 circuits taken iscas89 benchmark suite parallel fault simulation done random test set size 10000 ie sequence 10000 randomly generated input test vectors actual test sets obtained automatic test pattern generation atpg tool 13 shows performance parallel fault simulator random test pattern environment grading environment table 1 shows characteristics circuits used timings single processor types input test sets number faults detected also shown table 2 shows execution times seconds 8 proces sors sunsparccenter 1000e obtained using four algorithms discussed previous section spf0 spf1 spf4 spf5 refer algorithms spitfire0 spit fire1 spitfire4 spitfire5 respectively number faults detected algorithms ever may pessimism number fault detected eliminated using pipelined approach algorithm spitfire3 10 value 5 used minfaultlimit spf4 spf5 minfaultlimit execution timessecs s526 243 226 233 div16 1288 1320 1332 table 5 execution times spitfire5 8 processors varying minfaultlimit explained next paragraph seen table execution times get progressively smaller general proceed spf0 spf1 spf4 spf5 sometimes spf0 better spf1 sometimes spf1 better spf4 lowest execution time shown bold seen spf5 always lowest execution time algorithms shows algorithm spitfire5 provides best performance thus see performing single stage fault simulation simultaneously allowing asynchronous communication processors provides substantial savings terms execution time tables 3 4 show execution times speedups obtained random test sets atpg test sets respectively 1 2 4 8 processors algorithm spit fire5 seen algorithm highly scalable provides excellent speedups combined effect test set partitioning coupled asynchronous communication detected faults resulted superlinear speedups cases results experiment determine value minfaultlimit shown table 5 experiment performed 3 values minfaultlimit viz 2 5 10 using actual test sets obtained test generator observed best performance obtained value 5 circuits 8 processors 7 conclusion parallel fault simulation difficult problem due limited scalability parallelism previous algorithms could extract parallelization fault simulation limited serial logic simulation faultfree chine partitioning test sets across processors achieved scalable parallel implementation thus avoided serial logic simulation bottleneck performing asynchronous communication dynamically reduced load processors redundant computation may otherwise occurred thus presented two asynchronous algorithms parallel test set partitioned fault simulation asynchronous algorithms provide better performance synchronous counterparts shared memory multiprocessor single stage asynchronous test set partitioned parallel algorithm shown provide better performance two stage test set partitioned asynchronous parallel algorithm although two stage synchronous algorithm better single stage synchronous algorithm r hope linear time fault simulation parallel algorithms vlsi computeraided de sign parallel test generation sequential circuits generalpurpose multiprocessors fault simulation pipelined multiprocessor system concurrent fault simulation logic gates memory blocks message passing multicomput ers parallel algorithm fault simulation based proofs zambezi parallel pattern parallel fault sequential circuit fault simulator overcoming serial logic simulation bottleneck parallel fault simulation zamlog parallel algorithm fault simulation based zambezi spitfire scalable parallel algorithms test partitioned fault simulation distributed fault simulation vector set partitioning portable parallel programming message passing interface automatic test generation using geneticallyengineered distinguishing se quences tr parallel test generation sequential circuits generalpurpose multiprocessors concurrent fault simulation logic gates memory blocks message passing multicomputers parallel algorithms vlsi computeraided design using mpi italiczamlogitalic parallel algorithm fault simulation based proofs overcoming serial logic simulation bottleneck parallel fault simulation automatic test generation using geneticallyengineered distinguishing sequences zambezi ctr victor kim prithviraj banerjee parallel algorithms power estimation proceedings 35th annual conference design automation p672677 june 1519 1998 san francisco california united states
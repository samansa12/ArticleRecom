optimization queries userdefined predicates relational databases provide ability store userdefined functions predicates invoked sql queries evaluation userdefined predicate relatively expensive traditional method evaluating predicates early possible longer sound heuristic two previous approaches optimizing queries however neither able guarantee optimal plan desired execution space present efficient techniques able guarantee choice optimal plan desired execution space optimization algorithm complete rankordering improves upon naive optimization algorithm exploiting nature cost formulas join methods polynomial number userdefined predicates given number relations also propose pruning rules significantly reduce cost searching execution space naive algorithm well optimization algorithm complete rankordering without compromising optimality also propose conservative local heuristic simpler low optimization overhead although always guaranteed find optimal plans produces close optimal plans cases discuss depending application requirements determine algorithm choice emphasized optimization algorithms handle userdefined selections well userdefined join predicates uniformly present complexity analysis experimental comparison algorithms b introduction order efficiently execute complex database appli cations many major relational database vendors provide ability define store userdefined func tions functions invoked sql queries make easier developers implement applications however extensions make task execution engine optimizer challeng ing particular userdefined functions used clause sql predicates cannot treated sql builtin predicates evaluation predicate involves substantial cpu io cost traditional heuristic evaluating predicate early possible may result significantly suboptimal plan refer predicates userdefined expensive predicates consider problem identifying potential customers mailorder distribution mailorder company wants ensure customer high credit rating agegroup 30 40 resides san francisco bay area purchased least 1000 worth goods last year query involves join person sales relation two userdefined functions zone high credit rating select name streetaddress zip person sales highcreditratingssno age 3040 bay area personname salesbuyername group name streetaddress zip sumsalesamount 1000 let us assume predicate high credit rating expensive case may evaluate predicate join fewer tuples invoke expensive predicate however predicate selective may still better execute high credit rating cost join duced queries involving userdefined predicates occur many applications eg gis multimedia paper shows commercial optimizers many based system r style dynamic programming algorithm sac 79 extended easily able optimize queries userdefined predicates propose easy extension traditional optimizer efficient guarantees optimal associate per tuple cost evaluation selectivity every userdefined predicate hs93 task optimizing queries userdefined predicates important interesting directions research userdefined predicates eg use semantic knowledge eg phh92 cs93 pointed earlier traditional heuristic evaluating predicates early possible inappropriate context queries userdefined predi cates two known approaches optimizing queries treat userdefined predicates special way first technique used ldl cgk89 exponential number expensive predicates fails consider class traditional plans userdefined predicates evaluated early possi ble second technique known predicate migration hs93 polynomial number expensive predicates takes consideration traditional execution space well however algorithm cannot guarantee finding optimal plan moreover worst case may need exhaustively enumerate space joins number joins n query algorithm finds optimal plan without ever requiring exhaustive enumeration space join orderings complexity algorithm polynomial number userdefined functions 1 approach require special assumptions execution engine cost model designing optimization algorithm discovered powerful pruning technique pushdown rule broader implication optimization problems well cs96 although optimization algorithm guarantees optimal satisfactory performance large class queries complexity grows increasing query size therefore wanted investigate simpler heuristics used alterna tive conservative local heuristic present guarantees optimality several cases experimental results show chooses execution plan 1 complexity exponential number joins unexpected since traditional join optimization problem nphard close optimal computationally expensive thus heuristic serves excellent alternative query size complexity optimization algorithm concern implemented optimization algorithm well heuristic extending systemr style op timizer present experimental results illustrate characteristics optimization algorithms proposed paper rest paper organized follows next section review system r optimization algorithm basis many commercial optimizers next describe desired execution space review past work optimizing queries userdefined predicates sections 4 5 describe optimization algorithm conservative local heuristic respectively performance results implementation details given section 6 2 system r dynamic programming algorith many commercial database management systems adopted framework system r optimizer uses dynamic programming algorithm execution query represented syntactically annotated join tree internal node join operation leaf node base relation annotations provide details selection predicates choice access paths join algorithms projection attributes result relation set annotated join trees query considered optimizer called execution space query cost function used determine cost plan execution space task optimizer choose plan minimal cost execution space optimizers commercial database systems restrict search subset space join ordering optimizers commercial database systems restrict search subset space join ordering many opti mizers execution space restricted linear join trees whose internal nodes least one two child nodes leaf base relation words join n relations considered linear sequence 2way joins intermediate relation cardinality result size statistical parameters estimated figure 1 adopted ghk92 illustrates system r dynamic programming algorithm finds optimal plan space linear leftdeep join trees 79 input algorithm select projectjoin spj query relations r 1 r n procedure dp algorithm n f fr 1 rng st bestplan dummy plan infinite cost r j costp costbestplan bestplan p figure 1 system r algorithm linear join trees function joinplanpr extends plan p another plan result p joined base relation r best possible way function costp returns cost plan p optimal plans subsets stored optplan array reused rather recomputed algorithm expose two important details system r optimization algorithm first algorithm uses heuristics restrict search space particular selection conditions secondary join predicates evaluated early pos sible therefore selections relations evaluated join evaluated next algorithm also considers interesting orders consider plan p uses sortmerge join costs another plan p 0 uses hashjoin nonetheless p may still optimal plan sortorder used p reused subsequent join thus system r algorithm saves single plan multiple optimal plans every subset figure one distinct order termed interesting order sac thus generous upper bound number plans must optimized query joins among n tables o2 n number subsets n tables times number interesting orders 3 execution space previous ap proaches mentioned earlier traditional spj queries many optimizers find optimal space linear join orderings userdefined predicates present natural extension execution space consists considering linear sequence joins allowing expensive predicate placed following number including zero joins thus expensive selection condition placed either immediately following scan relation ap plies number joins following scan likewise expensive secondary join predicate placed either immediately becomes evaluable following necessary joins number subsequent joins words execution space restricts join ordering linear allows expensive predicates freely interleaved wherever evaluable refer execution space unconstrained linear join trees execution space studied hs93 hel94 section discuss two approaches studied past optimizing queries userdefined predicates 31 approach approach expensive predicate treated relation point view optimiza tion approach first used ldl project mcc cgk89 subsequently papyrus project hp laboratories cs93 viewing expensive predicates relations advantage systemr style dynamic programming algorithm used enumerating joins well expensive pred icates thus e expensive predicate r 1 r 2 two relations extended join enumeration algorithm treat optimization problem ordering r 1 r 2 e using dynamic programming algorithm shortcoming approach suffers two drawbacks stem problem overgeneralizing viewing expensive predicate relation first optimization algorithm exponential number relations also number expensive predicates let us consider case linear join trees considered execution thus order optimize query consists join n relations k expensive predicates dynamic programming algorithm need construct o2 nk optimal subplans words cost optimizing relation n relations k expensive predicates high optimizing nk relations another important drawback approach restrict search linear join trees algorithm cannot used consider plans space unconstrained linear trees particu lar algorithm fails consider plans evaluate expensive predicates operands join prior taking join hel94 example assume r 1 r 2 two relations expensive relations e 1 e 2 defined since ldl algorithm treats expensive predicates relations alike consider linear join sequences joins selec tions however plan applies e 1 r 1 e 2 r 2 takes join relations r 1 r 2 linear sequence selections joins thus algorithm may produce plans significantly worse plans produced even traditional optimization algorithm 32 predicate migration predicate migration algorithm improves ldl approach two important ways first considers space unconstrained linear trees finding plan ie considers pushing selections operands join next algorithm polynomial number user defined predicates however algorithm takes step backwards ldl approach respects discussed later section discuss two aspects approach first discuss predicate migration algorithm given join tree chooses way interleaving join selection predicates next describe predicate migration may integrated system r style optimizer hs93 hel94 predicate migration algorithm takes input join tree annotated given join method join node access method every scan node set expensive predicates algorithm places expensive predicates optimal see discussion shortcomings position relative join nodes algorithm assumes join costs linear sizes operands allows assign rank join predicate addition assigning ranks expensive predicates notion rank studied previously ms79 kbz86 assigned ranks algorithm iterates stream stream path leaf root execution tree every iteration potentially rearranges placement expensive selections iteration continues streams modified operator tree changes shown hs93 convergence occurs polynomial number steps number joins expensive predicates next part optimization technique concerns integration system r style optimizer steps dynamic programming algorithm followed optimal plan subexpression generated following change join step option evaluating predicates ap plicable considered let p optimal plan oe e r 1 p 0 optimal plan oe e r 1 algorithm prunes plan p 0 without compromising optimal however plan p 0 cheaper dynamic programming cannot used extend plan p 0 rather plan p 0 marked unprunable subsequently constructing larger subplans algorithm ignores unprunable plans dynamic programming algorithm terminates unprunable plans needs extended exhaustive enumeration ie possible ways extending unprunable plan considered shortcomings approach optimization three serious drawbacks limit applicability first algorithm requires cost formulas join linear sizes inputs next algorithm cannot guarantee optimal plan even linear cost model used use predicate migration algorithm may force estimations inaccurate nutshell predicate migration requires join predicate assigned rank depends cost join latter function input sizes relations unfortunately input sizes join depends whether expensive predicates evaluated cyclic dependency forces predicate migration make adhoc choice calculating rank step algorithm potentially underestimates join cost assuming expensive predicates pushed adhoc assumption sacrifices guarantee optimality see section 52 hel94 detailed dis cussion finally global nature predicate migration hinders integration system r style dynamic programming algorithm algorithm may degenerate exhaustive enumeration let us consider query n relations single designated expensive predicate e relation r 1 let us assume given database traditional plan predicate e evaluated prior join optimal plan case plans oe e r 6 1 marked unprunable plans n gamma 2 distinct join orderings join orderings number join methods thus worst case optimization process requires exhaustive enumeration join space 4 dynamic programming based optimization algorithms discussion previous section shows none known approaches guaranteed find optimal plan space unconstrained linear join trees section present optimization algorithm guaranteed produce optimal plan execution space best knowledge first algorithm provides guarantee optimality techniques presented section readily adaptable join execution spaces well eg bushy join trees cs96 algorithm following important properties well 1 remarkably robust free special restrictions cost model requirements caching 2 algorithm integrates well dynamic programming based algorithm used commercial op timizers never requires exhaustive enumeration 3 algorithm polynomial number userdefined predicates provide succinct characterization makes optimization problem polynomial parameters determine complexity optimization thus algorithm successfully addresses shortcomings predicate migration algorithm without sacrificing benefit considering execution space unconstrained linear join trees ensuring complexity optimization grows polynomially increasing number userdefined functions notational convenience indicate ordering operators plan nested algebraic expres sions example oe e r plan first apply selection e relation relation r 2 joining relation r 3 reduced application selection condition e 0 describing rest section make following two assumptions userdefined predicates selec tions assumption simplify presentation algorithms accommodate userdefined join predicates well preserves guarantee optimality well properties 13 cs96 b traditional interesting orders present assumption ease exposition begin presenting naive optimization algorithm guarantees optimality properties 1 3 next present two powerful pruning techniques significantly enhance efficiency optimization algorithm shown later experimental section 41 naive optimization algorithm enumeration technique algorithm relies clever use following two key observations equivalent plan pruning rule strength traditional join enumeration lies able compare costs different plans represent subexpression evaluated different orders since selection join operations may commuted extend technique compare prune plans queries expensive predicates joins ie p p 0 two plans represent selectprojectjoin queries physical properties p may pruned example compare costs plans p p 0 p plan oe e r plan r r 1 selection ordering let us consider conjunction set expensive selection predicates applied relation problem ordering evaluation predicates selection ordering problem complexity selection ordering different ordering joins among set relations wellknown traditional cost models latter problem nphard hand selection ordering problem solved polynomial time ordering selections depend size relation apply problem selection ordering addressed hs93 cf kbz86 ms79 wk90 utilizes notion rank rank predicate ratio c cost per tuple selectivity theorem 41 consider query oe e r optimal ordering predicates e order ascending ranks independent size r example consider two predicates e e 0 selectivities 2 6 costs 100 25 although predicate e selective rank 125 rank e 0 625 therefore evaluation e 0 precede e technique selection ordering extended broader classes boolean expressions kms92 ensuring complete enumeration efficiently equivalent plan pruning rule allows us compare two plans represent expression observation help us integrate well system r algorithm avoid exhaustive enumeration unlike predicate migration hand selection ordering tells us contrast ldl algorithm treat selections unlike relations make enumeration efficient indeed observation makes algorithm polynomial number userdefined predicates therefore challenge treat selections differently joins enumerating still able compare costs two plans represent expression order achieve goal exploit wellknown idea interesting orders novel way keep multiple plans represent join set relations differ sets predicates evaluated words every join plan additional tag placed records set predicates evaluated plan thus tag acts much like interesting order point view join enumeration useful way thinking enumerating space execution plans since selection ordering rule ensures need tags notice whenever two plans represent join set relations agree tags compared pruned figure 2 illustrates execution plans sub plans need considered three relations two expensive selection predicates e 1 e 2 r 1 p 1 p 2 p 3 possible plans r 1 differing tags plans p 5 p 13 r 1 distinguish since different tags keep single plan among p 5 p 7 formalize idea tags let us consider join step join two relations r 1 r 2 let us assume p predicates applicable r 1 order increasing rank selection ordering criterion conclude predicate p j applied r 1 prior join must predicates p 1 words possibilities pushing selections r 1 applying predicate b applying first j predicates j 1 likewise predicates applicable r 2 q s1 possibilities thus altogether plans join r 1 r 2 differ applications selections prior join denote plans p p rt designates plan results evaluating join selection ordering plays crucial role reducing number tags exponential polynomial number user defined predicates observe cannot linear ordering among selections consider cases subset selection predicates chosen evaluation prior join case join r 1 r 2 number plans many 2 m1 2 s1 generalize idea straightforward fashion subquery consisting join among relations fr 1 plans need kept j represents number expensive predicates apply r ij associate distinct tag plans sub query sketch tags may represented assign number expensive predicate according ordering rank userdefined selection condition present w relations say r query plan associate vector width w tag vector plan p designates expensive predicates rank lower equal j r uj evaluated p 1 j w defer full discussion scheme tagging extended version forthcoming report cs96 illustrate scheme following example example 42 consider query represents join among four relations r selections selections numbered relative increasing rank relation r 1 three predicates numbered 256 let r 2 three predicates 134 let r 3 predicates 789 relation r 4 predicates defined tag vector three positions ith position represents predicates relation r altogether 16 plans join distinct tag consider plan tag vector 5 4 0 plan joined relation r 3 depending selection predicates evaluated prior join altogether 8 plans different tag vectors extend plan particular plan generated tag vector 5 4 8 plan compared plan obtained extending plan tag vector 0 4 8 join r 1 evaluating predicates 2 5 r 1 prior join example illustrated prune plans tag vector set relations unlike approaches hs93 hel94 userdefined predicate pusheddown plan unprunable algorithm extensions needed algorithm figure 1 naive optimization algorithm straightforward longer single optimal plan j figure 1 may multiple plans one tag vector thus need iterate set possible tags optimal plan j tag consider generating r1 figure 2 search space naive optimization algorithm possible legal tags tag 0 joinplan needs invoked extend optimal plan need also ensure compare costs plans tag 42 complexity optimization algorithm presented exploited dynamic programming well selection dering latter makes possible us optimization algorithm polynomial k whereas former made possible us retain advantage avoiding exhaustive enumeration join ordering efficiency algorithm enhanced applications pruning rules described next section let us consider query consists join among relations k userdefined predicates let us assume g n relations one userdefined selection conditions furthermore let w maximum number expensive predicates may apply one relation cases number tags 1w g show total number subplans need stored generous upperbound note since n total number relations k total number userdefined predicates k therefore formula used derive upperbound 2k n hence given n upperbound polynomial k generous upper bound detailed analysis presented cs96 observe case traditional join enumer ation complexity exponential n analysis complexity shows complexity sensitive distribution predicates among relations well number predicates may apply single relation particular userdefined predicates apply relation complexity o2 n 1k2 linear function k complexity algorithm grows number relations userdefined predicates occur since increase number tags exponen tially full paper study effect varying distributions userdefined predicates efficiency optimization algorithms cs96 important recognize able avoid worst cases predicate migration algorithm en counters predicate migration algorithm worst running time userdefined predicates turn relatively inexpensive ie low rank since cases unprunable plans generated see section 3 hand optimization algorithm prepares possible sequences predicate pushdown use tags furthermore since many applications expect number expensive userdefined functions query less number joins important ensure cost join enumeration increase sharply due presence userdefined predicates ever pointed earlier even single userdefined predicate n joins worstcase complexity predicate migration approach overcomes shortcoming predicate migration effectively 43 efficient pruning strategies naive algorithm compare plans tags section augment naive optimization algorithm two pruning tech niques pruning techniques propose allow us compare prune plans different tags pruning techniques sound ie guaranteed compromise optimality chosen plan pushdown rule rule says cost evaluating selections prior join together cost join selections applied less cost join without applied selections push selections 2 example figure 2 cost p 5 less cost 8 prune p 8 naive optimization algorithm keep p 5 p 8 since different tags ie different numbers expensive predicates applied plan join r 1 let p plan applies userdefined predicate e relation r taking join ie may pruned refer lemma pushdown rule soundness lemma follows observation spj queries interesting order cost monotonic function sizes relations cs96 consequence rule p 0 plan set 0 expensive predicates applied pruned another plan p set relations set expensive predicates applied superset 0 therefore given two plans set relations easily check b examining tag vectors p p 0 cs96 indeed b holds say dominates 0 tags p 0 p rephrase lemma conclude following two plans set relations tags 0 dominates may pruned given plan p set plans eg p 0 corollary allows us prune denoted pushdown expensivep strictly speaking lemma used compare plans interesting order us consider previous exam ple plan represents join among altogether 64 tags ever cost plan tag 6 4 9 lower 5 4 8 use pushdown rule prune latter plan pullover rule rule says locally deferring evaluation predicate leads cheaper plan plan evaluates userdefined predicate join defer evaluation predicate without compromising optimal soundness rule uses dynamic programming nature system r algorithm established inductive argument example cost plan extending p 6 evaluation e 2 ie oe e2 oe e1 r 1 less cost p 5 figure 2 prune p 5 naive optimization algorithm keep since different tags ie different number predicates applied plans e userdefined predicate relation r let p p 0 represent optimal plans oe e r 1 oe e r 1 respectively costp may pruned refer pullover rule since plan p lemma corresponds case predicate pulled rule also used context predicate migration reduce number unprunable plans generated cf hs93 use pullover rule pruning plans follows let us consider plans p p 0 set relations different tags 0 tag dominates predicates evaluated 0 also evaluated let difft 0 represent set predicates evaluated 0 use pullover rule obtain following corollary intuitively corollary says compare costp costp cost evaluating predicates difft 0 join p 0 corollary 47 let p p 0 two plans tags 0 set relations dominates plan obtained applying predicates difft 0 p 0 costp 00 p may pruned given p construct set plans may used prune p refer set pullover cheaperp following example illustrates corollary example consider example 45 following change cost plan p tag 6 4 9 higher cost plan p 0 tag 0 5 4 8 notice tag 6 4 9 dominates tag 5 4 8 set difft 9g case lemma allows us prune plan p cost plan p 0 added cost evaluating set predicates f6 9g join exceeds cost p 44 optimization algorithm pruning section augment naive optimization algorithm pruning strategies extended algorithm presented figure 3 p lantable data structure stores plans need retained future steps optimizer every subset lations data structure stores potentially multiple plans different plans correspond different tags storing plans requires simple extension data structure used represent plans interesting orders traditional optimizers determining access methods choice join methods algorithm behaves exactly like traditional algorithm figure 1 however applicable userdefined predicates operand applicable predicates operand r j algorithm iteratively considers r possibilities corresponds applying first u predicates first v predicates j r j respectively predicates ordered ranks inner loop algorithm represented extjoinp lan noted j intermediate relation first u predicates j may include predicates multiple relations joined form j choices u v uniquely determine tag plan p figure 3 plan p compared plans set relations already stored plan p pruned iteration steps next u v combination one following two conditions holds 1 p expensive plan p lantable tag 2 set plans pullover cheaperp empty ie pullover rule cannot used prune p otherwise predicate addtotablep becomes true plan p added p lantable next new plan p used prune plans currently plantable algorithm designated set pruned plans prunesetp may 1 stored plan tag exists p lantable expensive 2 set plans pushdown expensivep ie plans may pruned p using pushdown rule procedure extended dpalgorithm n f fr 1 rng st bestplan dummy plan infinite cost r j number evaluable predicates j r number evaluable predicates r j u 0 v 0 r addtotablep f remove prunesetp add p plantable plan q fr 1 rng complete plan q estimate cost return mincostfinal figure 3 optimization algorithm pruning linear join trees end final join consider plans relations fr ng plans may need completed adding step evaluate remainder predicates finally cheapest among set completed plans chosen 5 conservative local heuristic although optimization algorithm novel pruning techniques guarantees optimal plan computationally efficient conservative local heuristic propose section remarkable qualities make attractive alternative implementa tion first incorporating heuristic existing systemr style optimizer easier since tags need maintained next incorporating heuristic increases number subplans need optimized query factor 2 compared traditional optimization independent number userdefined predicates query finally number important cases algorithm guarantees generation optimal execution plan simplest heuristics correspond pushing expensive predicates deferring evaluation expensive predicates last join heuristics take account costs selectivities predicates therefore generate plans low quality recently new heuristic pullrank proposed found heuristic fails generate plans acceptable quality hel94 begin describing pullrank characterizing shortcomings presenting conservative local heuristic pullrank maintains one plan set relations join step every choice set predicates pushed pull rank algorithm estimates sum costs call completion cost following three components cost evaluating expensive predicates pushed step ii cost join taking account selectivities expensive predicates applied iii cost evaluating remainder userdefined functions evaluable join deferred past join pullrank chooses plan minimum completion cost thus algorithm greedily pushes predicates cost deferring evaluation predicates past join expensive ie pullrank decides evaluating predicate u join j cheaper evaluating predicate u immediately following j evaluation u precede j final plan ie pullrank consider plans u evaluated j thus pullrank fails explore plans deferring evaluation predicates past one joins significantly better choosing greedily push predicates based local comparison completion costs order address drawback pullrank conservative local heuristic picks one additional plan addition plan picked pullrank join step based sum costs ii let us refer cost metric pushdown join cost assuming deferred predicates evaluated free ie cost component iii zero words plans chosen using metric favor deferring predicates unless evaluation predicates helps reduce cost current join thus since conservative local heuristic picks two plans one completion cost pushdownjoin cost possible plan predicate u deferred past j well plan u pushed prior j chosen pullrank considered towards final plan thus conservative local heuristic find optimal plans pullrank global heuristics fail find due greedy approach illustrated following example example 51 consider query us assume plan oe e r 1 r 3 optimal note none global heuristic either pushes pulls selections find optimal plan oe e r cheaper oe e r 1 greedily pushes p fails obtain optimal ever algorithm uses plan r 1 next join step obtain optimal example pullup followed pushdown optimal therefore algorithm able find join every subset relations two plans stored conservative local heuristic fore never need consider optimizing plans thus unlike algorithm figure 3 number subplans need optimized grow increasing number userdefined predicates general conservative local heuristic may miss optimal plan intuitively algorithm distinctions among tags made nevertheless experimental results indicate quality plan close optimal plan cs96 furthermore following lemma states conservative local heuristic produces optimal plan several important special cases lemma 52 conservative local heuristic produces optimal execution plan one following conditions true1 query single join 2 query single userdefined predicate 3 optimal plan corresponds case predicates pushed 4 optimal corresponds case predicates deferred joins completed 6 performance evaluation implemented optimization algorithms proposed paper extending system r style optimizer section present results performance evaluations implementations particular 1 pruning strategies proposed improve performance naive optimization algorithm significantly 2 plans generated traditional optimization algorithm suffers poor quality 3 plans generated pullrank algorithm better less expensive plans generated traditional optimizer still significantly worse optimal 4 conservative local heuristic algorithm reduces optimization overhead generates plans close optimal number enumerated plans number udps one relation traditional algorithm pullrank algorithm conservative local heuristic algorithm optimization algorithm pruning naive optimization algorithm relative cost number udps one relation traditional algorithm pullrank algorithm conservative local heuristic algorithm optimization algorithm pruning 6 join query figure 4 performance varying number userdefined predicates experimental testbed experiments ware performed ibm rs6000 workstation 128 mb main memory running aix 325 used experimental framework similar ik90 cs94 algorithms run queries consisting equality joins queries tested randomly generated relation catalog relation cardinalities ranged 1000 100000 tuples numbers unique values join columns varied 10 100 corresponding relation cardinality selectivity expensive predicates randomly chosen 00001 10 cost per tuple expensive predicates represented number io page accesses selected randomly 1 1000 query generated two projection attributes page relation assumed contain 32 tuples relation four attributes clustered one relation physically sorted clustered tribute b tree hashing primary index attribute three alternatives equally likely attributes probability secondary index 12 choice tree hashing secondary index uniformly random considered block nested loops mergescan simple hybrid hash joins interesting orders considered storing sub plans experiment cost number io page accesses accounted performed two sets experiments first set varied number userdefined predicates apply one relation second set varied distribution userdefined predicates multiple relations query due lack space present experiments number userdefined selections apply relation var ied results experiments discussed cs96 second set experiments shed light distribution userdefined predicates among relations query influences cost optimization results also shows conservative local heuristic sharply reduces overhead optimization varying distributions effect number user defined predicates due lack space show results 6join ie join among 7 relations queries similar results obtained queries eg 4join 10join queries well detailed performance study various queries presented cs96 experiment one relation query chosen randomly number expensive predicates applicable varied 1 6 results presented data point represents averages 100 queries generated randomly experimented optimization algorithms behave increase number expensive predicates randomly selected relation queries figure 4 shows number enumerated plans quality plans generated algorithm comparison performances naive optimization algorithm optimization algorithm pruning shows proposed pruning techniques extremely effective note algorithms guaranteed optimal queries naive optimization algorithm enumerated 3 times plans optimization algorithm pruning result quality plans shows relative cost plans generated algorithms cost plan generated optimization algorithm pruning scaled 10 since naive optimization algorithm optimization algorithm pruning always generate optimal plans 10 represents cost optimal plans figure illustrates quality plan generated traditional optimizer suffers significantly quality plan generated pullrank algorithm gets worse number expensive predicates increases conservative local heuristic chooses plans identical close optimal 3 illustrated fact graphs heuristic optimization algorithm practically indistin guishable although experiment conservative local heuristic doesnt reduce number enumerated plans significantly compared optimization algorithm pruning observation extend general particularly userdefined selections distributed among multiple relations latter cases conservative local heuristic proves algorithm choice since continues choose plans close optimal plan much less optimization overhead cs96 acknowledgement indebted joe hellerstein giving us detailed feedback draft short time anonymous referees provided us insightful comments helped improve draft thanks due umesh dayal nita goyal luis gravano ravi krishnamurthy help comments without support debjani chaudhuri yesook shim would impossible complete work r query optimization presence foreign functions including groupby query optimization optimization userdefined predicates query optimization parallel execution predicate migration place ment predicate migration optimization queries expensive predicates randomized algorithms optimizing large join queries optimization nonrecursive queries optimizing boolean expressions objectbases sequencing seriesparallel precedence constraints extensiblerule based query optimization starburst query optimization memoryresident domain relational calculus database system tr join processing database systems large main memories exodus optimizer generator query optimization memoryresident domain relational calculus database system introduction algorithms towards open architecture ldl randomized algorithms optimizing large join queries query optimization parallel execution migration practical predicate placement advanced query optimization techniques relational database systems optimization execution techniques queries expensive methods access path selection relational database management system optimization nonrecursive queries implementing interpreter functional rules query optimizer optimizing boolean expressions objectbases query optimization presence foreign functions including groupby query optimization optimization queries userdefined predicates volcano optimizer generator ctr utkarsh srivastava kamesh munagala jennifer widom operator placement innetwork stream query processing proceedings twentyfourth acm sigmodsigactsigart symposium principles database systems june 1315 2005 baltimore maryland ihab f ilyas jun rao guy lohman dengfeng gao eileen lin estimating compilation time query optimizer proceedings acm sigmod international conference management data june 0912 2003 san diego california david taniar hui yee khaw haorianto cokrowijoyo tjioe eric pardede use hints sqlnested query optimization information sciences international journal v177 n12 p24932521 june 2007 iosif lazaridis sharad mehrotra optimization multiversion expensive predicates proceedings 2007 acm sigmod international conference management data june 1114 2007 beijing china kamesh munagala utkarsh srivastava jennifer widom optimization continuous queries shared expensive filters proceedings twentysixth acm sigmodsigactsigart symposium principles database systems june 1113 2007 beijing china changwon park junki min chinwan chung structural function inlining technique structurally recursive xml queries proceedings 28th international conference large data bases p8394 august 2023 2002 hong kong china shivnath babu rajeev motwani kamesh munagala itaru nishizawa jennifer widom adaptive ordering pipelined stream filters proceedings 2004 acm sigmod international conference management data june 1318 2004 paris france surajit chaudhuri prasanna ganesan sunita sarawagi factorizing complex predicates queries exploit indexes proceedings acm sigmod international conference management data june 0912 2003 san diego california zhiyuan chen johannes gehrke flip korn query optimization compressed database systems acm sigmod record v30 n2 p271282 june 2001 utkarsh srivastava kamesh munagala jennifer widom rajeev motwani query optimization web services proceedings 32nd international conference large data bases september 1215 2006 seoul korea zhen liu srinivasan parthasarthy anand ranganathan hao yang scalable event matching overlapping subscriptions pubsub systems proceedings 2007 inaugural international conference distributed eventbased systems june 2022 2007 toronto ontario canada caetano traina jr agma j traina marcos r vieira adriano arantes christos faloutsos efficient processing complex similarity queries rdbms query rewriting proceedings 15th acm international conference information knowledge management november 0611 2006 arlington virginia usa fosca giannotti giuseppe manco franco turini specifying mining algorithms iterative userdefined aggregates ieee transactions knowledge data engineering v16 n10 p12321246 october 2004 jayaprakash pisharath alok choudhary mahmut kandemir energy management schemes memoryresident database systems proceedings thirteenth acm international conference information knowledge management november 0813 2004 washington dc usa surajit chaudhuri luis gravano amelie marian optimizing topk selection queries multimedia repositories ieee transactions knowledge data engineering v16 n8 p9921009 august 2004 zhen byung suk lee robert snapp selftuning cost modeling userdefined functions objectrelational dbms acm transactions database systems tods v30 n3 p812853 september 2005 brian babcock shivnath babu mayur datar rajeev motwani dilys thomas operator scheduling data stream systems vldb journal international journal large data bases v13 n4 p333353 december 2004 panagiotis g ipeirotis eugene agichtein pranay jain luis gravano search crawl towards query optimizer textcentric tasks proceedings 2006 acm sigmod international conference management data june 2729 2006 chicago il usa srinath shankar ameet kini david j dewitt jeffrey naughton integrating databases workflow systems acm sigmod record v34 n3 september 2005
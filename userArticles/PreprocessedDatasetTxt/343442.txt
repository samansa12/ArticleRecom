statementlevel communicationfree partitioning techniques parallelizing compilers paper addresses problem communicationfree partition iteration spaces data spaces along hyperplanes finding possible communicationfree hyperplane partitions treat statements within loop body separate schedulable units instead using information data dependence distance direction vectors technique explicitly formulates array references transformations statementiteration spaces data spaces based transformations necessary sufficient conditions communicationfree partition along hyperplanes feasible proposed approach applied programs imperfectly nested loop sequences imperfectly nested loops whose array references affine functions outer loop indices loop invariant variables proposed approach practical existing methods finding data computation distribution patterns cause processor execute fullyparallel multicomputers without interprocessor communication b introduction widely accepted local memory access much faster memory access involving interprocessor communication distributedmemory multicomputers data computation properly distributed across processors may cause heavy interprocessor communication although problem data distribution critical importance efficiency parallel program distributed memory multicomputers known difficult problem mace 14 proved finding optimal data storage patterns parallel processing npcomplete even limited one twodimensional arrays addition li chen 11 12 shown problem finding optimal data alignment also npcomplete thus previous work number researchers developed parallelizing compilers need programmers specify data storage patterns based programmerspecified data partitioning parallelizing compilers automatically generate parallel program appropriate message passing constructs multicomputers projects using approach include fortran compiler project 4 5 18 superb project 21 kali project 9 10 dino project 17 purpose crystal project 11 12 compiler 16 deal functional languages generate parallel program message passing construct parallel program generated systems spmd singleprogram multiple data 8 model recently automatic data partitioning attractive research topic field parallelizing compilers many researchers develop systems help programmers deal problem data distribution automatically determining data distribution compile time paradigm project 3 suif project 1 19 based purpose systems automatically determine appropriate data distribution patterns minimize communication overhead generate spmd code appropriate message passing constructs distributed memory multicomputers since excessive interprocessor communication offset benefit parallelization even program large amount parallelism consequently parallelizing compilers must pay attention distribution computation data across processors reduce communication overhead completely eliminate interprocessor communication possible communicationfree partitioning therefore becomes interesting worth studying issue distributedmemory multicomputers recent years much research focused area partitioning iteration spaces andor data space reduce interprocessor communication achieve highperformance computing ramanujam sadayappan 15 consider problem communicationfree partitioning data spaces along hyperplanes distributed memory multicomputers present matrixbased formulation problem determining existence communicationfree partitions data arrays approach proposes array decompositions take iteration space partitionings consideration addition concentrate fully parallel nested loops focus twodimensional data arrays huang sadayappan 7 generalize approach proposed 15 consider issue communicationfree hyperplane partitioning explicitly modeling iteration data spaces provide conditions feasibility communicationfree hyperplane partitioning however deal imperfectly nested loops moreover approach restricted looplevel partitioning ie statements within loop body must scheduled together indivisible unit chen sheu 2 partition iteration space first according data dependence vectors obtained analyzing reference patterns nested loop group data elements accessed iteration partition two communicationfree partitioning strategies nonduplicate data duplicate data strategies proposed paper nevertheless require loop contain uniformly generated references problem domain restricted single perfectly nested loop also treat statements within loop body indivisible unit lim lam 13 use affine processor mappings statements assign statementiterations processors maximize degree parallelism available program approach treat loop body indivisible unit assign different statementiterations different processors however consider statementiteration space partitioning address issue data space partitioning furthermore uniform affine processor mappings cause large number idle processors affine mappings nonunimodular transformations paper communicationfree partitioning statementiteration spaces data spaces along hyperplanes considered explicitly formulate array references transformations statementiteration spaces data spaces based transformations present necessary sufficient conditions feasibility communicationfree hyperplane partitions currently existing partitioning schemes take iteration instance basic schedulable unit allocated processor loop body contains multiple statements difficult make loop communicationfreely executed allocating iteration instances among processors chance communicationfree execution found using methods limited flexible possible finding communicationfree hyperplane partitions treat statements within loop body separate schedulable units method consider one iteration space data space 13 method extended handle general loop models applied programs imperfectly nested loops affine array references rest paper organized follows section 2 introduce notation terminology used throughout paper section 3 describes characteristics statementlevel communicationfree hyperplane partitioning technique statementlevel communicationfree hyperplane partitioning perfectly nested loop presented section 4 necessary sufficient conditions feasibility communicationfree hyperplane partitioning also given extension general case sequences imperfectly nested loops described section 5 finally conclusions given section 6 preliminaries section explains statementiteration space data space also defines statement iteration hyperplane data hyperplane 21 statementiteration space data space let q z z denote set rational numbers set integers set positive integer numbers respectively symbol z represents set dtuple integers traditionally iteration space composed discrete points point represents execution statements one iteration loop 20 instead viewing iteration indivisible iteration divided statements enclosed iteration ie statement schedulable unit iteration space use another term statementiteration space denote iteration space statement nested loop following example illustrates notion iteration spaces statementiteration spaces example 1 consider following nested loop l 1 fig 1 illustrates iteration space statementiteration spaces loop l 1 5 fig 1a circle means iteration includes two rectangles black gray colors black rectangle indicates statement 1 gray one indicates statement 2 fig 1b fig 1c statement individual unit collection statements forms two statementiteration spaces 2 representation statementiteration spaces data spaces relations among described follows let denote set statements targeted problem domain set array variables referenced consider statement 2 enclosed dnested loop statementiteration space denoted siss subspace z defined loop index variable lb ub lower upper bounds loop index variable respectively superscript transpose operator column vector called statementiteration statementiteration space siss lb ub hand geometric point view array variable also forms space array element point space exactly describing array variable use data space represent ndimensional array v denoted dsv v 2 array element corresponding data index data space dsv denote data index column vector relations statementiteration spaces data spaces built via array reference functions array reference function transformation statementiteration space data figure 1 loop l 1 iteration space corresponding statementiteration spaces assuming 5 isl 1 iteration space loop l 1 b siss 1 statementiteration space statement statementiteration space statement 2 space existing methods require array references affine functions outer loop indices loop invariant variables suppose statement enclosed dnested loop array reference pattern va 11 1 ij integer constants 1 n array reference function written f sv 6 4 11 delta delta delta 1d 10 term f sv array reference coefficient matrix f sv array reference constant vector data index v 2 dsv referenced statementiteration 2 siss ref sv take array reference pattern example array reference coefficient matrix constant vector ai f f gamma4 respectively define statementiteration hyperplanes data hyperplanes next subsection 22 statementiteration hyperplane data hyperplane statementiteration hyperplane statementiteration space siss denoted psis hyperspace 6 siss defined psi h coefficients statementiteration hyperplane c h 2 q constant term hyperplane formula abbreviated psi h statementiteration hyperplane coefficient vector similarly data hyperplane data space dsv denoted phiv hyperspace dsv defined coefficients data hyperplane c g 2 q constant term hyperplane way formula also abbreviated phi data hyperplane coefficient vector hyperplanes include least one integer point considered paper statementiteration hyperplanes data hyperplanes used characterizing communica tionfree partitioning discuss characteristics next section 3 characteristics communicationfree hyperplane partition ing program execution communicationfree operations processors access data elements allocated processor trivial partition strategy allocates statement iterations data elements single processor program execution trivial partitioning communicationfree however interested single processor program execution exploit potential parallelization conflicts goal parallel processing hence paper consider nontrivial partitioning specific hyperplane partitioning formal definition communicationfree hyperplane partition defined let partition group g set hyperplanes assigned one processor definition communica tionfree hyperplane partition given following 1 hyperplane partitions statementiteration spaces data spaces said communicationfree partition group statementiterations access array element allocated statementiteration hyperplane therefore important decide statementiterations access array element following lemma states necessary sufficient condition two statementiterations access array element lemma 1 statement 2 referenced array v 2 0 two statement iterations siss ref sv array reference function siss dsv defined kers denotes null space 6 proof suppose ref sv thus conversely suppose 0 basis kerf sv vectors belonged kerf sv represented linear combination vectors fff 1 g since 0 thus ref sv using following example example 2 consider array reference ai j array reference coefficient null space f sa kerf sa zg lemma 1 two statementiterations difference r1 gamma1 access array element z fig 2 shows statementiterations f1 3 2 2 3 1g access array element a4 4 2 explain significance lemma 1 show lemma help find com municationfree hyperplane partitions communicationfree hyperplane partitioning requires statementiterations access array element allocated statementiteration hyperplane according lemma 1 two statementiterations access array element difference two statementiterations belongs kernel f sv hence subspace statementiteration hyperplane since may exist many different array references partitioning statementiteration space must consider array references appeared statement thus space spanned kerf sv array references appearing statement subspace statementiteration hyperplane figure 2 statementiterations whose differences kerf sv access array element dimension statementiteration hyperplane one less dimension statement iteration space exists statement dimension spanning space equal dimension siss spanning space cannot subspace statementiteration hyperplane therefore exists nontrivial communicationfree hyperplane partitioning observation obtain following theorem theorem 1 9s 2 dimspan v2d kerf sv exists nontrivial communicationfree hyperplane partitioning 2 example 3 consider matrix multiplication program three array variables b c three distinct array references involved statement three array reference coefficient matrices f sa f sb f sc respectively thus kerf sa dimensionality statement iteration space theorem 1 matrix multiplication nontrivial communicationfree hyperplane partitioning 2 theorem 1 useful determining nested loops nontrivial communica tionfree hyperplane partitioning furthermore nontrivial communicationfree hyperplane partitioning exists theorem 1 also useful finding hyperplane coefficient vectors state result following corollary corollary 1 communicationfree statementiteration hyperplane psi h following two conditions must hold denotes orthogonal complement space proof lemma 1 two statementiterations access data element using array reference f sv difference two statementiterations belongs kernel f sv therefore kernel f sv contained statementiteration hyperplane fact true array references appeared statement hence first condition obtained normal vector psi h delta orthogonal condition 1 implies delta orthogonal subspace span v2d kerf sv thus belongs orthogonal complement span v2d kerf sv corollary 1 gives range communicationfree statementiteration hyperplane coefficient vectors used finding communicationfree statementiteration hyperplane coefficient vectors hand range communicationfree data hyperplane coefficient vectors also given follows mentioned relations statementiteration spaces data spaces established via array references moreover statementiteration hyperplane coefficient vectors data hyperplane coefficient vectors related following lemma expresses relation two hyperplane coefficient vectors similar result given 7 lemma 2 statement 2 referenced array v 2 ref sv array reference function siss dsv psi h communicationfree hyperplane partitions proof suppose psi h communicationfree hyperplane partitionings let 0 00 two distinct statementiterations belong statementiteration hyperplane psi h 0 v 00 two data indices ref sv 0 v ref sv 00 v assumptions 0 v 00 belong data hyperplane phi g v 0 00 belong statementiteration hyperplane psi h delta delta 0 delta delta 00 therefore 1 note delta row vector however delta delta orthogonal psi hs hand since 0 v 00 v belong data hyperplane phi g v means theta delta 0 theta delta 00 thus theta delta 0 since 0 00 two statementiterations statementiteration hyperplane psi h vector statementiteration hyperplane furthermore delta delta theta delta f sv hence conclude delta theta delta f sv linearly dependent implies hyperplane partitions siss dsv respectively phi g v communicationfree partitioning according definition 1 prove v let statementiteration statementiteration hyperplane psi h delta assumption fftheta let c v shown 8i 2 psi h ref sv phi g v follows psi h phi g v communicationfree partitioning 2 lemma 2 statementiteration hyperplane coefficient vector delta decided data hyperplane coefficient vector theta determined f sv invertible statementiteration hyperplane coefficient vectors decided first data hyperplane coefficient vectors derived range communicationfree data hyperplane coefficient vectors derived lemma corollary 1 shows range statementiteration hyperplane coefficient vectors next corollary provides ranges data hyperplane coefficient vectors corollary 2 communicationfree data hyperplane phi g following condition must hold denotes complement set proof paper considers nontrivial hyperplane partitioning requires delta nonzero vector lemma 2 therefore theta delta f sv equal 0 implies theta 62 kerf sv condition true 2 hence theta 62 s2s kerf sv follows theta belongs complement s2s kerf sv consider following loop nested loop communicationfree statementiteration hyperplane coefficient vectors 1 2 data hyperplane coefficient vectors v 1 v 2 respectively f0g show delta 1 delta 2 satisfy corollary 1 follows test corollary 2 theta 1 theta 2 theta section describes communicationfree hyperplane partitioning technique necessary sufficient conditions communicationfree hyperplane partitioning single perfectly nested loop presented 4 communicationfree hyperplane partitioning perfectly nested loop data array corresponding data space however nested loop multiple statements may multiple statementiteration spaces section consider additional conditions multiple statementiteration spaces communicationfree hyperplane partitioning conditions also used determining statementiteration hyperplanes data hyperplanes number occurrences array variable v j statement r ij r ij reference v j r ij set 0 previous representation array reference function modified slightly describe array reference statement variable kth occurrence ref v j related representations changed accordingly ref v j section partition group contains statementiteration hyperplane statementiteration space data hyperplane data space considered suppose data hyperplane data space dsv j phi g v j g theta j delta let result statementiterations access data lay data hyperplane phi g v j g located statementiteration hyperplane psi h g simplify presentation assume variables v j appear every statement satisfy statementiteration space contains unique statementiteration hyperplane following two conditions met j j condition infer following two equivalent equations condition ii deduces following two equations vice versa eq 6 used evaluate data hyperplane constant terms constant term fixed say c furthermore obtain following results j c g j 1 therefore inferred obtain following describing conditions satisfying communicationfree hyperplane partitioning constraints conclude following theorem theorem 2 let sets statements array variables respectively ref v j k array reference function statement accessing array variables v j kth occurrence g statementiteration hyperplane siss v j g data hyperplane dsv j v j communicationfree hyperplane partitions following conditions hold j k g j k g theorem 2 used determine whether nested loop communicationfree also used procedure finding communicationfree hyperplane partitioning systematically conditions c1 c4 theorem 2 used finding data hyperplane coefficient vectors condition c5 check whether data hyperplane coefficient vectors found preceding steps within legal range following determination data hyperplane coefficient vectors statementiteration hyperplane coefficient vectors obtained using condition c6 similarly condition c7 check whether statementiteration hyperplane coefficient vectors within legal range data hyperplane constant terms statementiteration hyperplane constant terms obtained using conditions c8 c9 respectively one conditions violated whole procedure stop verify nested loop communicationfree hyperplane partitioning hand combining equations 3 5 together sufficient condition commu nicationfree hyperplane partitioning derived follows r ij r ij satisfy constraint theta nonzero row vector following condition true r ij r ij note condition similar result 7 looplevel hyperplane partitioning conclude following corollary corollary 3 suppose sets statements array variables respectively f v j k array reference coefficient matrix constant vector respectively ng k 2 g communicationfree hyperplane partitioning exists eq must hold 2 theorem 1 corollary 3 used check absence communicationfree hyperplane partitioning nested loop conditions sufficient necessary theorem 1 statementiteration space dimension test corollary 3 data space dimension test determine existence communicationfree hyperplane partitioning need check conditions theorem 2 show following example explain finding communication free hyperplanes statementiteration spaces data spaces example 5 reconsider loop l1 set statements fs set array variables fv b occurrences array variables r 2 section 21 array reference coefficient matrices constant vectors statements 1 2 listed respectively gamma1 1 gamma1 gamma2 2 theorem 1 may exist communicationfree hyperplane partitioning loop l 1 corollary 3 loop tested possible existence nontrivial communicationfree hyperplane partitioning array variable v 1 following inequality satisfied 2 similarly respect array variable v 2 following inequality obtained 2 although eq 9 holds array variables still ensure loop nontrivial communicationfree hyperplane partitioning using theorem 2 check existence nontrivial communicationfree hyperplane partitioning mean time statementiteration data hyperplanes derived exist recall dimensions data spaces dsv 1 dsv 2 two theta 1 theta 2 assumed respectively conditions listed theorem 2 checked determine hyperplane coefficient vectors constants condition c1 theorem 2 following equations obtained condition c2 theorem 2 condition c3 theorem 2 condition c4 theorem 2 substituting respectively equations form homogeneous linear system solving homogeneous linear system obtain general solution f0g therefore theta next show theta 1 theta 2 satisfy condition c5 theta theta statementiteration hyperplane coefficient vectors determined using condition c6 theorem 2 note statementiteration hyperplane coefficient vectors may obtained using many different obtained using theta 1 1 conditions c1 c2 theorem 2 ensure equations lead result statementiteration hyperplane coefficient vectors condition c7 satisfied next determine data hyperplane constant terms due hyperplanes related hyperplane constant term determined constant terms determined accordingly assuming c g 1 known c g 2 c h 2 determined using conditions c8 c9 similarly statementiteration data hyperplane constant terms evaluated using many different equations however conditions c3 c4 theorem 2 ensure lead values clear exists least one set nonzero statementiteration data hyperplane coefficient vectors conditions listed theorem 2 satisfied theorem 2 fact implies nested loop nontrivial communicationfree hyperplane partitioning partition group defined set statementiteration data hyperplanes allocated processor partition group example follows given loop bounds 1 constant term c g 1 corresponding statementiteration hyperplane coefficient vector delta 1 delta 2 ranged gamma5 3 0 respectively intersection part two ranges means two statementiteration hyperplanes coupled together onto processor rest one statementiteration hyperplane either delta 1 delta 2 allocated processor constant terms c g 2 c h 2 evaluated following values corresponding parallelized program follows doall enddoall fig 3 illustrates communicationfree hyperplane partitionings particular partition 2 2 communicationfree hyperplane partitioning technique perfectly nested loop discussed section method treats statements within loop body separate schedulable units considers iteration data spaces time partitioning groups determined using affine array reference functions directly instead using data dependence vectors 5 communicationfree hyperplane partitioning sequences imperfectly nested loops conditions presented section 4 communicationfree hyperplane partitioning applicable general case sequences imperfectly nested loops perfectly nested loop figure 3 communicationfree statementiteration hyperplanes data hyperplanes partition group loop l 1 2 statementiteration hyperplane siss 1 b statementiteration hyperplane siss 2 c data hyperplane dsa data hyperplane dsb statements enclosed depth nested loop ie statementiteration space statement dimensionality statementiteration spaces two statements imperfectly nested loops may different dimension since statementiteration schedulable unit partitioning technique independent dimensionality statementiteration spaces theorem 2 directly applied sequences imperfectly nested loops following example demonstrate technique applying sequences imperfectly nested loops example consider following sequences nested loops l 2 set statements fs g set array variables respectively values r 11 r 12 r 13 r r 43 1 use theorem 1 corollary 3 verify whether l2 communicationfree hyperplane partitioning since dim smaller dimsiss theorem 1 helpless ensuring l2 exists communicationfree hyperplane partitioning corollary 3 useless values 1 examinations necessary theorem 1 corollary 3 prove l2 communicationfree hyperplane partitioning theorem 2 communicationfree hyperplane partitioning exists conditions listed theorem 2 satisfied otherwise l2 exists communicationfree hyperplane partitioning due dimensions data spaces dsv 1 tively without loss generality data hyperplane coefficient vectors respectively assumed theta follows requirements satisfy feasibility communicationfree hyperplane partitioning examined onebyone need examine conditions c1 c3 values r ij 1 condition c2 obtain condition c4 obtain solving linear system general solutions 11 12 21 22 31 2t gammat f0g therefore theta verification condition c5 follows theta theta theta data hyperplane coefficient vectors within legal range statementiteration hyperplane coefficient vectors determined condition c6 follows legality statementiteration hyperplane coefficient vectors checked condition c7 follows observation statementiteration data hyperplane coefficient vectors legal fact reveals nested loops communicationfree hyperplane partitionings next data statementiteration hyperplanes constant terms decided first let one data hyperplane constant term fixed say c rest data hyperplane constant terms determined condition c8 similarly statementiteration hyperplane constant terms determined condition c9 data hyperplane constant terms decided corresponding partition group follows v 3 v 3 fig 4 illustrates communicationfree hyperplane partitionings partition group c g 1 0 corresponding parallelized program follows doall endif enddoall 6 conclusions paper presents techniques finding statementlevel communicationfree hyperplane partitioning perfectly nested loop sequences imperfectly nested loops necessary sufficient conditions feasibility communicationfree partitioning along hyperplane proposed techniques applied loops affine array references use information data dependence distances direction vectors although goal determine communicationfree partitioning loops reality loops communicationfree program communicationfree technique figure 4 communicationfree statementiteration hyperplanes data hyperplanes partition group loop l 2 statementiteration hyperplane siss 1 b statementiteration hyperplane siss 2 c statementiteration hyperplane siss 3 statementiteration hyperplane siss 4 e data hyperplane dsa f data hyperplane dsb g data hyperplane dsc used identify subsets statementiteration data spaces communicationfree statementiterations necessary generate communication code two important tasks future work develop heuristics searching subset statementiterations communicationfree generate efficient code communication inevitable r global optimizations parallelism locality scalable parallel machines communicationfree data allocation techniques parallelizing compilers multicomputers demonstration automatic data partitioning techniques parallelizing compilers multicomputers compiling fortran mimd distributedmemory machines evaluating compiler optimizations fortran englewood cliffs communicationfree hyperplane partitioning nested loops programming parallelism compiling programs nonshared memory machines compiling global namespace parallel loops distributed ex ecution index domain alignment minimizing cost crossreferencing distributed arrays data alignment phase compiling programs distributedmemory machines communicationfree parallelization via affine transformations memory storage patterns parallel processing compiletime techniques data distribution distributed memory machines process decomposition locality reference dino parallel programming language optimizing fortran compiler mimd distributedmemory machines loop transformation theory algorithm maximize parallelism high performance compilers parallel computing superb vienna fortran tr ctr wenglong chang chihping chu jiahwa wu communicationfree alignment array references linear subscripts three loop index variables quadratic subscripts journal supercomputing v20 n1 p6783 august 2001 skewed data partition alignment techniques compiling programs distributed memory multicomputers journal supercomputing v21 n2 p191211 february 2002 wenglong chang jihwoei huang chihping chu using elementary linear algebra solve data alignment arrays linear quadratic references ieee transactions parallel distributed systems v15 n1 p2839 january 2004
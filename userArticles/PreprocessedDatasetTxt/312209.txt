buckets heaps lists monotone priority queues introduce heapontop hot priority queue data structure combines multilevel bucket data structure denardo fox heap data structure superior operation bounds either structure taken alone use new data structure obtain improved bound dijkstras shortest path algorithm also discuss practical implementation hot queues experimental results context dijkstras algorithm show implementation hot queues performs well robust implementations based heap multilevel bucket data structures b introduction priority queue data structure maintains set elements supports operations insert decreasekey extractmin priority queues fundamental data structures many applications typical applications include graph algorithms eg 14 event simulation eg 5 important subclass priority queues used applications event simulation dijkstras shortest path algorithm 13 class monotone pri work done author visiting nec research institute supported department defense partial support nsf award ccr9357849 matching funds ibm schlumberger foundation shell foundation xerox corporation queues intuitively priority queue monotone time keys elements queue least big key recent element extracted queue paper deal monotone priority queues unless mentioned otherwise refer priority queues whose operation time bounds depend number elements queue heaps fastest implementations heaps described 4 14 19 alternative implementations priority queues use buckets eg 2 7 11 12 operation times bucket based implementations depend maximum event duration c defined section 2 see 3 related data structure heaps particularly efficient number elements heap small bucketbased priority queues particularly efficient maximum event duration c small furthermore work done bucketbased implementations amortized elements buckets yielding better bounds number elements large sense heaps buckets complement introduce heapontop priority queues hot queues combine multilevel bucket data structure denardo fox 11 heap queues use heap instead buckets buckets would sparsely occupied resulting implementation takes advantage best performance features data structures also give alternative insightful description multilevel bucket data structure concurrently independently similar description given raman 17 hot queues related radix heaps rh 1 ahuja et al 2 rh similar multilevel buckets uses heap find nonempty buckets get best bounds heap operation time rh depend number distinct keys heap complicated part 2 modifying fibonacci heaps 14 meet requirement contrast hot queue bounds require anything special heap use fibonacci heaps modifications achieve bounds rh using heap thorup 19 obtain even better bounds sideeffect obtain om implementation dijk stras shortest path algorithm improving previous bounds since thorups bounds depend total number elements heap rh cannot take immediate advantage data structure believe data structures especially interesting work well theory practice preliminary version hot queue data structure 6 perform well practice based experimental feedback modified data structure practical also developed techniques make hot queues efficient practice compare implementation hot queues implementations multilevel buckets kary heaps context dijkstras shortest paths algorithm experimental results show hot queues perform best overall robust either two data structures especially significant multilevel bucket implementation dijkstras algorithm compared favorably implementations algorithm previous study 7 shown robust many problem classes hot queue implementation dijkstras algorithm best theory practice due page limit omit proofs details experimental data full version paper appears 8 preliminaries priority queue data structure maintains set elements supports operations insert decreasekey extractmin assume elements keys used compare elements denote key element u aeu unless mentioned otherwise assume keys integral value element mean key ele ment insert operation adds new element queue decreasekey operation assigns smaller value key element already queue bounds depend c extractmin operation removes minimum element queue returns element denote number insert operations sequence priority queue operations n gain intuition following definition think event simulation applications keys correspond processing times let u latest element extracted queue event insert decreasekey operation queue given event let v element inserted queue element whose key decreased event duration aeu denote maximum event duration c application monotone event durations nonnegative monotone priority queue priority queue monotone applications make definitions valid first insertion assume initialization special element inserted queue deleted immediately afterwards without loss generality assume value element zero subtract value element values paper heap mean priority queue whose operation time bounds functions number elements queue assume heaps also support findmin operation returns minimum element heap call sequence operations priority queue balanced sequence starts ends empty queue particular implementations dijkstras shortest path algorithm produce balanced operation sequences paper use ram model computation 1 nonobvious result model use appears 9 attributed b schieber result given two machine words find constant time index significant bit two words differ 3 multilevel buckets section describe klevel bucket data structure denardo fox 11 give simpler description data structure treating element keys basedelta numbers certain parameter delta consider bucket structure b contains k levels buckets k positive integer except top level level contains array delta buckets top level contains infinitely many buckets top level bucket corresponds interval choose delta delta consecutive buckets top level nonempty need maintain buckets 2 denote bucket j level bi j bucket contains set elements way allows constanttime additions deletions eg doubly linked list given k choose delta small possible subject two constraints first top level bucket must contain least c definition c keys elements b belong level buckets second delta must power two manipulate basedelta numbers efficiently using ram operations words bits constraints mind set delta smallest power two greater equal c maintain key latest element extracted queue consider basedelta representation keys element u b definitions c delta k least significant digits basedelta representation aeu uniquely determine aeu ae numbers represented k least significant digits aeu respectively otherwise denote ith least significant digit basedelta representation denote number obtained deleting least significant digits k similarly 1 denote ith least significant digits aeu u denote number obtained deleting least significant digits aeu u k levels b numbered k top 1 bottom buckets level numbered 0 delta gamma 1 let index significant digit aeu differ 1 given u aeu say position u respect u u inserted b inserted bi u element b store position element u bi j except significant digits aeu equal corresponding digits u following lemma follows fact keys elements queue least lemma 31 every level buckets bi empty level maintain number elements level also maintain total number elements b extractmin operation change value sideeffect positions elements b may change suppose minimum element deleted 2 simplest way implement top level wrap around modulo delta value changes let 0 value deletion let 00 value deletion definition keys elements queue deletion least 00 let position least significant digit 0 00 differ differ last digit element b deletion position deletion 1 elements bucket bi 00 respect 0 exactly whose position different respect 00 elements longer prefix common 00 0 therefore belong lower level respect 00 bucket expansion procedure moves elements new positions procedure removes elements bi 00 puts positions respect 00 two key properties bucket expansions follows ffl expansion bi 00 correct positions respect 00 every element b moved expansion moved lower level ready describe multilevel bucket implementation priority queue operations ffl insert insert element u compute position insert u bi j ffl decreasekey decrease key element u position follows remove u bi j set aeu new value insert u described ffl extractmin need find delete minimum element update move elements affected change find lowest nonempty level find first nonempty bucket level delete element bi j set aeu return u case old new values differ last digit element positions remain examine elements bi minimum element u bi j set expand bi j return u next deal efficiency issues lemma 32 given u compute position u respect constant time iterating levels find lowest nonempty level ok time using binary search find level olog time even better using power ram model lemma 33 k log c lowest nonempty level b found o1 time see best bounds achieved k log c simple way finding first nonempty bucket level go buckets takes odelta time lemma 34 find first nonempty bucket level odelta time remark one better 11 divide buckets every level groups size dlog ce group containing consecutive buckets group maintain dlog cebit number bit j equal 1 jth bucket group empty find first nonempty group log c time first nonempty bucket group o1 time construction gives log c factor improvement bound lemma 34 iterating construction p times get log p c bound although observation improves multilevel bucket operation time bounds small values k bounds optimal value k improve simplify presentation use lemma 34 rather improved version rest paper theorem 31 amortized bounds multilevel bucket implementation priority queue operations follows ok insert o1 decreasekey proof insert operation takes o1 worstcase time assign amortized cost k charge moves elements lower level insertions elements decreasekey operation takes o1 worst case time assign amortized cost o1 extractmin operation show worstcase cost ok plus cost bucket expansions cost bucket expansion proportional number elements bucket cost amortized insert operations except minimum element element examined bucket expansion moved lower level excluding bucket expansions time operation o1 plus odelta finding first nonempty bucket completes proof since note sequence operations number insert operations least number extractmin operations balanced sequence two numbers equal modify proof obtain following result theorem 32 balanced sequence amortized bounds multilevel bucket implementation priority queue operations follows o1 insert o1 decreasekey okc 1k extractmin extractmin bound oc 2 bound c best bound log c log log c obtained log log c e remark klevel bucket data structure uses 4 hot queues hot queue uses heap h multilevel bucket structure b intuitively hot queue data structure works like multilevel bucket data structure except expand bucket containing less ele ments parameter set optimize perform ance elements bucket copied h processed using heap operations number elements bucket exceeds bucket expanded analysis charge scans buckets lower levels elements bucket expansion levels obtain improved bound klevel hot queue uses klevel bucket structure additional special level k 1 needed account scanning buckets level k two buckets top level nonempty time 1 note queue nonempty least one two buckets nonempty thus bucket scans special level add constant amount work processing element found use wraparound level k k active bucket bucket whose elements h one bucket active time h empty active bucket denote active bucket ba b make bucket active making h heap containing bucket elements inactive reseting heap empty heap elements active bucket bucket h describe details hot queues need following definitions denote number elements bi j ci j given delta say element u range bi replacing least significant digits 0 1 using ram operations check element range bucket constant time maintain invariant range active bucket detailed description queue operations follows ffl insert h empty element u inserted range active bucket insert u b multilevel case otherwise u belongs active bucket ba b insert u h ba b make ba b inactive add u ba b expand bucket ffl decreasekey decrease key element u follows u h decrease key u h otherwise let j position u b remove u j set aeu new value insert u described ffl extractmin h empty extract return minimum element h otherwise proceed follows find lowest nonempty level find first nonempty bucket level examining buckets starting bi delete element bi j set aeu return u examine elements bi delete minimum element u bi j set expand bi j otherwise make bi active return u correctness hot queue operations follows correctness multilevel bucket operations lemma 31 observation u h v b h aeu aev lemma 41 cost finding first nonempty bucket level amortized insert operations okdeltat proof scan one nonempty bucket search first nonempty bucket scan empty bucket level period time prefix including except last digits remains furthermore scan buckets level nonempty happen higherlevel bucket expanded period prefix change charge bucket scans insertions elements queue elements expanded charged k times giving desired bound theorem 41 let dn time bounds heap insert decreasekey findmin extractmin opera tions amortized times hot queue operations follows ok decreasekey txt kc 1k extractmin proof two key facts crucial analysis first fact number elements h never exceeds since level accounts elements second fact lemma 41 given first fact theorem 31 bounds straightforward fibonacci heaps 14 amortized time bounds ologn gives ok o1 olog amortized bounds queue operations insert decreasekey extractmin respectively setting log c log c o1 log c amortized bounds radix heaps achieve bounds complicated thorups heaps 19 expected amortized time bounds gives ok o1 expected amortized time bounds queue operations insert decreasekey extractmin respectively ffl positive constant setting 3 c olog3 c o1 olog3 ffl c expected amortized time similarly theorem 32 get bounds balanced sequence operations theorem 42 let dn time bounds heap insert decreasekey findmin extractmin opera tions consider balanced sequence hot queue operations amortized bounds operations follows oit insert odt decreasekey ok extractmin using fibonacci heaps get o1 o1 amortized bounds queue operations consider extractmin operation nonconstant bound setting log c get ologc bound setting log c get ologc bound setting log c get log c bound remark bounds valid n use heap remark consider 1 2level implementations although time bounds twolevel implementation two advantages uses less space time bounds remain valid wider range values c using thorups heaps setting 3 c expected amortized time bounds time bounds allow us get improved bound dijkstras shortest path algorithm suppose given graph n vertices arcs integral arc lengths range 0 c running time dijkstras algorithm dominated balanced sequence priority queue operations includes insert extractmin operations om decreasekey operations see eg 18 maximum event duration sequence operations c bounds queue operations immediately imply following result theorem 43 network n vertices arcs integral lengths range 0 c shortest path problem solved om expected time improves deterministic bound om log c 2 hot queue implementation based fibonacci heaps matches deterministic bound 5 implementation details previous papers 7 15 describe implementations multilevel buckets implementation hot queues augments multilevel bucket implementation 15 see 15 details multilevel bucket implementation consider klevel hot queue multilevel bucket implementation set delta smallest power two greater equal c 1k based analysis section 4 experimental results set maximum size active bucket c 1k log c e number elements active bucket often small take advantage fact maintaining elements active bucket sorted list instead heap operations list become expensive point switch heap use kheap worked best tests see eg 10 implement priority queue operations using sorted list use doubly linked list sorted nondecreasing order implementation designed shortest path application application number decreasekey operations elements active bucket tends small 16 fact proven random graphs elements inserted list moved decreasekey operation tend close beginning list different implementation may better different application insert operation searches elements position list puts element position one start search different places implementation starts search beginning list starting end list point last insertion may work better applications extractmin operation removes first element list decreasekey operation removes element list finds new position puts element position implementation starts search beginning list starting previous position element end list place last insertion may work better applications bucket becomes active put elements list number elements bucket 1 heap otherwise code uses switch list heap using following rule suggested satish rao personal communica switch insert decreasekey operation examines ative may work better applications performed worse switch number elements list exceeds 1 6 experimental setup experiments conducted pentium pro 166 mhz processor running linux 1368 machine 64 meg memory problem instances fit main memory code written c compiled linux gcc compiler version 270 using o6 optimization option made effort make code efficient particular set bucket array sizes powers two allows us use word shift operations computing bucket array indices full paper reports experimental results five types graphs two graph types chosen exhibit properties algorithm two extremes one paths start vertex vertices tend order thetan one path lengths order theta1 third graph type random sparse graphs fourth type constructed lot decreasekey operations active bucket meant test robustness implementations violate assumption made section 5 decreasekey operations fifth type graphs meant easy hard specific implementation specific number bucket levels tested type graph seven implement ations kary heaps k4 klevel buckets k ranging 1 3 klevel hot queues k ranging 1 3 parameters tune results show best parameter values tested problem families use previous paper 15 next two sections describe problem families 61 graph typestwo types graphs explored grids produced using gridgen generator 7 graphs characterized length x width graph formed constructing x layers path length order layers well vertices within layer connect vertex corresponding vertex adjacent layers vertices first layer connected source first type graph used long grid constant width 16 vertices tests used graphs different lengths ranging 512 32 768 vertices arcs lengths chosen independently uniformly random range 1 c c varied 1 100 000 000 second type graph used wide grid type graphs length limited 16 layers width vary 512 32 768 vertices c long grids third type graphs includes random graphs uniform arc length distribution random graph n vertices 4n arcs fourth type graphs type new compared 15 based cycle n vertices numbered 1 n addition vertex connected gamma 1 distinct vertices length arc j equal 2k 15 k number arcs cycle path j fifth type graphs includes hard graphs parameterized number vertices desired number levels k maximum arc length c c compute p number buckets level assuming implementation k levels graphs consist two paths connected source vertices path distance p distance source path 1 0 vertices path occupy first bucket bottom level bins distance source path 2 making vertices occupy last bucket bottomlevel bin addition source connected last vertex first path arc length 1 last vertex second path arc length c summary graph types appears table 1 62 problem familiesfor graph type examined relative performance implementations changed increased various parameters type modification constitutes problem family families summarized table 2 general family constructed varying one parameter holding others constant different families vary parameter using different constant values 7 experimental results 2 3level bucket structures robust 7 15 cases 2 3level hot queues perform similarly although usually slightly better corresponding multilevel bucket structures one level hot queues significantly robust one level buckets robust 2 3level hot queues due shortage space present experimental results hard problems problems separate hot queues multilevel buckets tables k denotes implementation h heap bi buckets levels hi hot queue levels report running times counts operations give insight algorithm performance heap implementation count total number insert decreasekey operations bucket implementations count number empty buckets examined empty operations hot queue implementations count number empty operations number insert decreasekey operations active bucket plot data addition tabulating unable run 1level bucket hot queue implementations problems memory limitations leave corresponding table entries blank tables 3 4 give data hard2 hard 3 families designed hard 2 3level bucket implementations respectively two elements heap time heap implementation efficient hard problems hot queue implementations bucket expanded action confined two special top level buckets thus hot queues perform almost well heaps exception h1 largest value c could handle running time 15 times greater value c explanation discrepancy hard2 problems hard b1 b2 expected implementations poorly family similarly bucket implementation worse implementations hard3 family concluding remarks theory hot queue data structure better heap multilevel bucket data structures experiments show resulting implementation robust heap multilevel bucket data structures new heap raman 17 instead thorups heap improves time bound factor log ffl c replaced p log log c hot queues seem practical radix heaps latter data structure requires bookkeeping addition hot queue heap usually contains much fewer elements implementation takes advantage fact 2level hot queue data structure seems robust 3level hot queue usually somewhat faster data structure best applications 3level structure may robust large values c value much smaller reducing sensitivity parameters active buckets 1level hot queue may useful event simulation applications viewed robust version calendar queue data structure acknowledgments would like thank bob tarjan stimulating discussions insightful comments satish rao suggesting adaptive strategy switching lists heaps harold stone useful comments draft paper r design analysis computer algorithms calandar queues fast o1 priority queue implementation simulation event set problem shortest paths algorithms theory experimental evaluation deterministic coin tossing applications optimal parallel list ranking introduction algorithms algorithm 360 shortest path forest topological ordering note two problems connexion graphs fibonacci heaps uses improved network optimization algorithms implementations dijkstras algorithm based multilevel buckets expected performance dijkstras shortest path algorithm fast algorithms shortest paths sorting data structures network al gorithms ram priority queues tr ctr mikkel thorup integer priority queues decrease key constant time single source shortest paths problem proceedings thirtyfifth annual acm symposium theory computing june 0911 2003 san diego ca usa stephen alstrup thore husfeldt theis rauhe mikkel thorup black box constanttime insertion priority queues note acm transactions algorithms talg v1 n1 p102106 july 2005 piet van mieghem fernando kuipers concepts exact qos routing algorithms ieeeacm transactions networking ton v12 n5 p851864 october 2004 klaus brengel andreas crauser paolo ferragina ulrich meyer experimental study priority queues external memory journal experimental algorithmics jea 5 p17es 2000 ran mendelson mikkel thorup uri zwick meldable ram priority queues minimum directed spanning trees proceedings fifteenth annual acmsiam symposium discrete algorithms january 1114 2004 new orleans louisiana mikkel thorup integer priority queues decrease key constant time single source shortest paths problem journal computer system sciences v69 n3 p330353 november 2004 haim kaplan robert e tarjan kostas tsioutsiouliklis faster kinetic heaps use broadcast scheduling proceedings twelfth annual acmsiam symposium discrete algorithms p836844 january 0709 2001 washington dc united states
lprintable sets language lprintable logspace algorithm input 1n prints members language length n following work allender rubinstein siam j comput 17 1988 pp 11931202 pprintable sets present simple properties lprintable sets definition lprintable robust allows us give alternate characterizations lprintable sets terms tally sets kolmogorov complexity addition show regular contextfree language lprintable sparse investigate relationship lprintable sets lrankable sets ie sets logspace algorithm input x outputs number elements precede x standard lexicographic ordering strings sparse sets l prove reasonable complexitytheoretic assumptions three classes sets different also show class sets small generalized kolmogorov space complexity exactly class sets lisomorphic tally languages b introduction easy set typically complexity theorists view easy sets easy membership tests even stronger requirement might easy algorithm print elements given length printable sets easy enough efficiently retrieve information might need hartmanis yesha first defined pprintable sets 1984 hy84 set pprintable polynomialtime algorithm input 1 n outputs elements length n pprintable set must lie p sparse ie number strings length bounded fixed polynomial length allender rubinstein ar88 give indepth analysis complexity pprintable sets pprintability defined natural consider analogous notion logspaceprintability since known whether obvious question ask lprintable sets behave differently pprintable sets paper able answer question affirmative least plausible complexity theoretic assumptions jenner kirsig jk89 define lprintability logspace computable version pprintability lprintability implies pprintability every lprintable set must sparse lie l paper give first indepth analysis complexity lprintable sets jenner kirsig focused one chapter printability printability results concern nlprintable sets department computer science university chicago chicago il 60637 work author supported part nsf grant ccr9253582 z department computer science university kentucky lexington ky 405060046 work authors supported part nsf grant ccr9315354 x dimacs center rutgers university piscataway nj 08855 work author supported nsf cooperative agreement ccr9119999 grant new jersey commission science technology work author supported part university kentucky presidential fellowship l fortnow j goldsmith levy mahaney whenever new class sets analyzed natural wonder structure sets hence examine regular contextfree lprintable sets using characterizations sparse regular contextfree languages show x 4 every sparse regular contextfree language lprintable although regular sets special case contextfree sets include results regular languages characterization sparse regular languages simple intuitive might expect many properties pprintable sets logspace analogues fact case x 5 show lprintable sets like polynomialtime counterparts closely related tally sets l sets l low generalized spacebounded kolmogorov complexity set said small generalized kolmogorov complexity strings highly compressible easily restorable generalized timebounded kolmogorov complexity generalized spacebounded kolmogorov complexity introduced har83 sip83 several researchers rub86 bb86 hh88 show pprintable sets exactly sets p small generalized timebounded kolmogorov com plexity ar88 show set small generalized timebounded kolmogorov complexity pisomorphic tally set using similar techniques show x 5 lprintable sets exactly sets l small generalized spacebounded kolmogorov complexity also prove set small generalized spacebounded kolmogorov complexity lisomorphic tally set x 6 note sets ranked logspace ie given string x logspace algorithm determine number elements set x seem different lprintable sets sparse sets prankability equivalent p printability show somewhat surprising result x 6 namely sparse lrankable sets lprintable sets tally sets p gamma l sparse sets l either lprintable lrankable allender rubinstein ar88 show every sparse set p pprintable sparse sets fewp gamma p x 6 similarly show stronger collapse every sparse set l lprintable every sparse set l lrankable sparse sets fewp gamma l unlike lprintable sets lrankable sets may exponential density blum see gs91 shows every set p prankable every p function computable polynomial time x 6 also show every set l lrankable every p function computable logarithmic space 2 definitions assume basic familiarity turing machines turing machine complexity information complexity theory suggest either bdg88 pap94 also assume familiarity regular languages expressions contextfree languages found mar91 denote characteristic function use standard lexicographic ordering strings let jwj length string w recall w lex v iff jwj jvj position leftmost bit w v differ w alphabet strings elements sigma denote complement class p deterministic polynomial time l deterministic logarithmic space remember calculating space complexity machine assumed separate tapes input computation output space restriction applies work tape known l p known whether two classes lprin equal class e deterministic time 2 linearspace deterministic space definition 21 set class pp polynomial time nondeterministic turing machine input x accepts half computations function f p polynomial time nondeterministic turing machine x fx number accepting computations mx allenderall86 defined class fewp fewe defined analogously definition 22 all86 set class fewp polynomial time nondeterministic turing machine polynomial p inputs accepts x pjxj paths set class fewe exponential time nondeterministic turing machine constant c inputs x accepts x 2 cn paths note small compared double exponential number paths exponentialtime nondeterministic turing machine definition 23 set sparse polynomial pn n number strings length n bounded pn ie js n j pn set alphabet sigma tally set foeg character oe 2 sigma work describes certain enumeration properties sparse sets l two notions enumeration considered rankability printability definition 24 c complexity class set cprintable function computable c input length n outputs strings length n note pprintable sets necessarily p sparse since strings length n must printed time polynomial n since every logspace computable function also computable polynomial time lprintable sets also pprintable thus also sparse definition 25 c complexity class set crankable function r computable c r words r x gives lexicographic rank x function r called ranking function note prankable sets necessarily p necessarily sparse furthermore set prankable complement prankable finally note pprintable set prankable definition 26 c complexity class two sets b c isomorphic total functions f g computable c oneone onto f reduction b g reduction b order two sets pisomorphic density functions must close one set sparse oneone reduction sparse set dense set must superpolynomial growth rate argument one superpolynomial gap must similar gap lexicographic orderpreserving isomorphism b informally bijection maps ith element ith element b maps ith element ith element b note definition similar densities isomorphisms need computable particular complexity class merely provides necessary condition densities order two sets pisomorphic lisomorphic definition 27 two sets b similar densities lexicographic 4 l fortnow j goldsmith levy mahaney isomorphisms b b polynomial size bounded notion printability ranking sparse sets considered form compression another approach compression found study kolmogorov complexity string said low information content low kolmogorov complexity interested spacebounded kolmogorov complexity class defined hartmanis har83 definition 28 let v turing machine let f functions natural numbers define v uses sn spaceg following notation ar88 refer compressed string fn compression sn restoration space hartmanis har83 shows exists universal machine u v exists constant c ks v fn sn ks u subscript let 3 basic results begin formalizing observations previous section observation 31 lprintable polynomially bounded density ie sparse follows immediately fact logspace computable functions ptime computable ie lprintability implies pprintability observations pprintable sets proposition 32 jk89 lprintable 2 l proof decide x 2 simulate lprinting function input 1 jxj 2 printed compare bit bit x accept comparisons done using o1 space lprinting function takes olog jxj space logspace procedure proposition 33 lrankable 2 l proof note function x gamma 1 lexicographic predecessor x computed though written space logarithmic jxj since logspace computable functions closed composition r computed logspace r proposition 34 lprintable lrankable proof compute rank x print strings jxj count ones lexicographically smaller x since sparse observation 31 store counter logspace prove following first shown jk89 different proof proposition 35 jk89 lprintable lprintable lexicographically increasing order proof prove use variation selection sort suppose logspace machine lprints construct another machine n lprint lexicographically increasing order note possible store instantaneous description logspace machine ie position input head state contents worktape character output olog jxj space basic idea store computation enough information produce three strings recently printed string lexicographically ordered printing current candidate next string printed lprin current contender certainly store three ids logspace id describes state immediately prior printing desired string addition storing ids must simulate three computations parallel compare resulting strings bit bit contender string greater last string output already output less candidate becomes new candidate otherwise final id computation becomes new contender simulated computations produce output n next string found n print initial id available simulation repeated output using technique previous proof one easily show following proposition 36 lprintable log b b lprintable well 4 lprintable sets begin section simple example class lprintable sets proposition 41 jk89 tally sets l lprintable proof input length n decide whether 1 n 2 print one may ask lprintable sets trivial proposition 41 demonstrate following sections every regular language contextfree language sparse also lprintable see theorem 45 corollary 414 also give lprintable set neither regular contextfree see proposition 415 41 sparse regular languages show sparse regular languages lprintable order give preliminary results regular expressions definition 42 bego71 let r regular expression say r unambiguous every string one derivation r theorem 43 bego71 every regular language l exists unambiguous regular expression r proof sketch represent l union disjoint languages whose dfas unique final state using standard union construction nfa dfa get nfa property string unique accepting path using state elimination construct regular expression nfa unique path string becomes unique derivation regular expression note even though removal ambiguity regular expression general pspacecomplete sh85 concern us theorem 43 guarantees existence unambiguous regular expression corresponding every regular language sufficient needs define restricted form regular expression generate precisely sparse regular languages note similar although involved characterization given ssyz92 give characterizations variety densities whereas concerned sparse sets definition 44 define static regular expression sre alphabet sigma inductively follows 1 empty expression sre defines empty set 2 x 2 sigma string x sre 3 sres st concatenation sre 4 sres union sre 5 sre sre iff contain union two sres 6 l fortnow j goldsmith levy mahaney b contain use operator note restriction operator definition ie applied string difference sres standard regular expressions alternately define sre regular expression sum terms concatenation letters starred strings theorem 45 let r unambiguous regular expression lr sparse iff r static proof first prove two lemmas forbidden subexpressions lemma 46 let ff fi nonempty regular expressions unambiguous constant k 0 infinitely many k strings length n proof let u 2 lff v 2 lfi let unambiguous must least two strings length k ls namely u jvj v juj length n least 2 strings length n ls lemma 47 let ff fi nonempty regular expressions unam biguous either form ff fi form fffi constant k infinitely many n k strings length n proof let u 2 lff v 2 lfi suppose jvj unambiguous least two distinct strings length k ls namely u jvj v v juj1 length n least 2 k strings length n ls proof similar unambiguous clear unambiguity necessary lemmas example static la sparse note r empty expression theorem true since r static certainly sparse rest proof assume r nonempty show one direction theorem 45 suppose r static contains subexpression either form fl form fl 0 ff first case small modification proof lemma 46 lr sparse second case similar modification proof lemma 47 lr cannot sparse suppose r static contains string x either string characters single character lr one string length sres let p r n p n bound number strings lr ls respectively p r np n strings length n finally suppose sres let p r n p n bound number strings lr ls respectively number strings length n degree q bounded 1 complexity r lr sparse lprin note second half proof use unambiguity hence static regular expression generates sparse regular language theorem 48 let r sre lr lprintable proof basically divide r terms either starred expressions nonstarred expressions example would divide 01 three parts 01 internally lprint term independently check see strings generated correct length example print strings length 9 might generate 0110 11 0011 respectively check combined string fact 9 characters long case string long printed let k number stars appear r partition r 2k subexpressions k stars others containing stars machine lprint lr two types counters starred subex pression machine counts many times subexpression used string length n starred subexpression used n times counter starred subexpression needs count n nonstarred subexpression generates constant number strings thus k 1 additional counters constant bound needed note production may intermix two types counters instance x occurs machine uses two passes potential string first machine generates current string counting length string correct length regenerates string prints otherwise increments set counters continues way strings lengths n generated strings length n printed lastly need argue procedure done logspace machine 2k must count n n sufficiently large say larger jrj thus counting done log n space addition actual production string requires additional counter store loop variable rest computation handled o1 space using states machine thus lr lprintable note lprinting algorithm may generate strings lr get nonredundant lprinter simply modify program output strings lexicographic order proposition 35 use unambiguous sre lr theorem 48 characterize lprintable sets see proposition 49 exists set lprintable regular proof language lprintable n print n even regular 42 sparse contextfree languages using theory bounded contextfree languages also show every sparse contextfree language lprintable definition 410 set bounded exist strings w note similarity bounded languages languages generated sres note also every bounded language sparse ibarra ravikumar ir86 prove following 8 l fortnow j goldsmith levy mahaney theorem 411 ir86 contextfree language sparse bounded ginsburg gin66 p 158 gives following characterization bounded contextfree languages theorem 412 gin66 class bounded contextfree languages smallest class consisting finite sets fulfilling following properties 1 b bounded contextfree languages b also bounded contextfree language 2 b bounded contextfree languages also bounded contextfree language 3 bounded contextfree language x fixed strings following set also bounded contextfree language ay corollary 413 every bounded contextfree language lprintable proof every finite set lprintable lprintable sets closed three properties theorem 412 corollary 414 every sparse contextfree language lprintable completely characterizes lprintable contextfree languages however sparse contextfree languages characterize lprintable languages proposition 415 exists lprintable set contextfree proof language lprintable contextfree 5 lisomorphisms easy show two pprintable sets prankable sets similar densities pisomorphic since usual proof relies binary search immediately extend lrankable sets however able exploit sparseness lprintable sets show following theorem 51 b lprintable similar densities b lisomorphic ie log b proof x define x image x lexicographic isomorphism b since b lprintable sparse let pn strictly increasing polynomial bounds densities sets x close x sense pjxj strings lexicographic ordering recall definition 27 fact x jy x let r x rank x rank x furthermore unique element b holds note r x r b x written space olog jxj thus compute x need compute maintaining variable initialized r x counter c initialized 0 following loop iterated counter c reaches pjxj 1 lprint lexicographic order elements b length c string lexicographically smaller decrement 2 increment c note written work tape bit x gamma computed logspace needed output lprinting function compared bitbybit manner lprin x 2 since lprinting function outputs strings lexicographic order computing x easy compute r x lprint b internally actually outputting r x th string without loss generality assume simulated lprinter b prints b lexicographic order thus soon r 1st element b printed internally simulation switches output mode following overview logspace algorithm computing desired isomorphism 1 compute ax 2 compute r x write work tape 3 x 2 find r x th element b output 4 find unique string output x using theorem characterize lprintable sets terms isomorphisms tally sets terms sets low kolmogorov space complexity theorem 52 following equivalent 1 lprintable 2 lisomorphic tally set l 3 exists constant k ksk log n k log n 2 l although known whether every sparse lrankable set lisomor phic tally set see theorem 61 prove following lemma use proof theorem 52 lemma 53 let sparse lrankable exists tally set 2 l similar density proof let n denote strings length n let pn everywhere positive monotonic increasing polynomial ja n j pn n greater number strings length n let rx ranking function define following tally set show 2 l notice tally strings 1 largest n pn gamma n written binary space olog compute difference bounded pn thus written logspace finally compute compare 1 accept iff 1 2 finally show similar density let f lexicographic isomorphism note f maps strings length n strings length pn f polynomially bounded note p always positive implies f lengthincreasing must also polynomially bounded thus similar density following proof theorem 52 similar proof analogous theorem ar88 proof 1 lprintable sparse lrankable let tally set guaranteed lemma 53 proposition 41 lprintable thus lprintable similar density theorem 51 l fortnow j goldsmith levy mahaney 2 lisomorphic tally set let f lisomorphism let x 2 string length n let logspace computable exists constant c r n c ie jrj c log n order recover x r compute f computing 0 r given r requires log n space one counter exists constant l computing requires lc log n space since r n c total space needed compute x given r less equal log n lc log n k log n k hence log n 2 l 2 l since log 3 log n k 2 l input 0 n simulate u string length k log n given string x log n first simulate u x check whether completes space k log n recompute u x time checking whether output recompute u x print result entire computation needs olog n space lprintable shown ar88 set small generalized kolmogorov complexity pisomorphic tally set note improvement result bb86 showed set small generalized kolmogorov complexity semiisomorphic tally set using similar argument theorem 52 show analogous result sets small generalized kolmogorov space complexity first prove following result proposition 54 v k ks v k log n k log n lprintable proof lprint length n simulate v string length less equal k log n output results corollary 55 exists k ksk log n k log n lisomorphic tally set proof suppose lisomorphic tally set argument given proof 2 3 theorem 52 ksk log n k log n suppose ksk log n k log n proposition 54 theorem 52 ksk log n k log n lisomorphic tally set l via lisomorphism f clear lisomorphic fa since fa subset tally set fa must also tally set 6 printability rankability decision section examine relationship among lprintable sets lrankable sets ldecidable sets show collapse classes even sparse sets equivalent unlikely complexity class collapse theorem 61 following equivalent 1 every sparse lrankable set lprintable 2 tally sets proof 2 3 equivalence follows techniques similar suppose sparse lrankable set note 2 l let ith bit jth string 1g lprin note hi ji computed space linear jij jjj since sparse bounded polynomial length jth string hence hi ji computed using logarithmic space respect length jth string given hi ji determine j polynomial time find jth string using binary search ranking function hence 2 p assumption 2 l next give method printing logspace given length n compute store ranks 0 n 1 n let r start r end ranks 0 n string rank r start length less n first check see 0 n 2 print j r start output jth string computing printing 1 hiji bit procedure prints strings length n note since sparse store r start r end olog n space since store increment current value log n space 1 tally set since monotone circuit value problem pcomplete see ghr95 exists logspacecomputable function f nondecreasing polynomial p fn produces circuit cn following properties 1 cn monotone ie cn uses gates 2 cn pn gates 3 inputs cn 0 1 4 cn outputs 1 iff 1 n assume reduction orders gates cn value gate depends constants 0 1 values gates g j ghr95 let xn string length pn ith bit xn value gate g ng contains exactly one string length pn n strings lengths 611 set lrankable proof prove claim let w string logspace find greatest n pn jwj pn 6 jwj w 62 rank w n suppose xn string length pn rank w consider ith bit w potential value gate g cn let j smallest value w j value g j order find value gate first use fn original reduction determine inputs g time consider th bit w know w correct encoding gates g k k use bits w values gates thus determine value g compare ith bit w differ done continue next gate count pn logspace whole process needs olog pn space compute j found three cases consider 1 j doesnt exist 2 jth bit w 0 w xn 3 jth bit w 1 w xn follow since ith bit xn matches ith bit w thus lrankable assumption lprintable 12 l fortnow j goldsmith levy mahaney determine 1 n lprint length pn get xn bit xn encodes output gate cn 1 iff 1 every step algorithm computable logspace 2 l completes proof theorem 61 corollary 62 exist two nonlisomorphic lrankable sets density unless tally sets proof consider sets second part proof theorem 61 set density proposition 41 b lprintable b lisomorphic proposition 36 would also lprintable would l one may wonder whether every sparse set l lprintable least l rankable show either case would lead unlikely collapse fewp l recall fewp consists languages np accepted nondeterministic polynomialtime turing machines polynomial number accepting paths fix nondeterministic turing machine input x let p specify accepting path mx represented list configurations computation step along path note logarithmic space verify whether p accepting computation since one configuration follows another constant number bits configuration change assume without loss generality paths length accepting path consists zero ones define set pm accepting path xg discussion following proposition use proofs theorems 66 67 proposition 63 nondeterministic machine pm l allender rubinstein ar88 showed following pprintable sets theorem 64 ar88 every sparse set p pprintable sparse sets fewp gamma p allender all86 also relates question inverting functions definition 65 function f strongly linvertible set exists logspace computable function g every x 2 gx prints strings extend techniques allender all86 allender rubinstein ar88 show following theorem 66 following equivalent 1 sparse sets fewp gamma l 2 every sparse set l lprintable 3 every sparse set l lrankable 4 every lcomputable polynomialtoone lengthpreserving function strongly linvertible f1g 5 proof 1 sparse set l p 1 sparse sets fewp gamma p theorem 64 pprintable consider following set b ith bit jth element length n bg lprin since pprintable b p 1 b sparse p fewp b l lprintable reading bits b 2 3 follows immediately proposition 34 3 sparse set fewp accepted nondeterministic machine computation paths length qn inputs length n consider set pm defined note pm sparse since length accepts polynomial number strings polynomial number accepting paths also proposition 63 pm l 3 pm lrankable determine logarithmic space whether mx accepts thus x checking whether r pm x0 2 f lcomputable polynomialtoone lengthpreserving function consider g since l lprintable sparse set l define x x otherwise g strong linverse f 1 g1 n print strings length n 1 n print strings length n logspace printing strings output g1 n except print 1 n 1 n 1 5 rrw94 rao et al show sparse sets fewp gamma p straightforward modification proofs sufficient show sparse sets fewp gamma l unlike lprintability lrankability imply sparseness one may ask whether every set computable logarithmic space may rankable show equivalent extremely unlikely collapse pp l theorem 67 following equivalent 1 every p function computable logarithmic space 2 3 every set l lrankable proof uses ideas blum see gs91 shows every set p prankable every p function computable polynomial time note hemachandra rudich hr90 proved results similar blums proof 1 pp p function f x iff highorder bit fx one 2 implies thus compute every bit p function logarithmic space 1 l consider nondeterministic polynomialtime machine input x guesses lex x accepts number accepting paths mx p function equal r x 3 f p function let nondeterministic polynomialtime machine fx number accepting computations mx let qn polynomialsized bound length computation paths consider pm defined proposition 63 pm l 3 pm lrankable compute fx logarithmic space noticing 14 l fortnow j goldsmith levy mahaney 7 conclusions class lprintable sets many properties analogous polynomialtime counterpart example even without ability binary searching one show two lprintable sets density isomorphic however properties appear carry unlikely every sparse lrankable set lprintable despite strict computational limits lprintable class still bite every tally set l every sparse regular contextfree language every lcomputable set low spacebounded kolmogorov complexity strings lprintable acknowledgments authors want thank david mix barrington counterexample conjecture sparse regular sets alan selman suggesting tally set characterization lprintable sets corollary 55 chris lusena proofreading amy levy john rogers duke whang helpful discussions simple proof sketch theorem 43 provided anonymous referee last equivalence theorem 66 suggested another anonymous referee authors would like thank referees many helpful suggestions comments r complexity sparse sets p sets small generalized kolmogorov complexity structural complexity ambiguity graphs expressions tally languages complexity classes mathematical theory contextfree languages limits parallel computation pcompleteness theory compression ranking generalized kolmogorov complexity structure feasible com putations sparse oracles separating feasible complexity classes computation times np sets different densities ambiguity decision problems acceptors transducers alternierung und logarithmischer platz introduction languages theory computation computational complexity upward separation fewp related classes note sets small generalized kolmogorov complexity complexity theoretic approach randomness characterizing regular languages polynomial densities tr ctr allender nlprintable sets nondeterministic kolmogorov complexity theoretical computer science v355 n2 p127138 11 april 2006
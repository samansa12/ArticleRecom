systematic formal verification faulttolerant timetriggered algorithms abstractmany critical realtime applications implemented timetriggered systems present systematic way derive timetriggered implementations algorithms specified functional programs form correctness faulttolerance properties formally mechanically verified relative ease functional program first transformed untimed synchronous system timetriggered implementation first step specific algorithm concerned second generic prove correctness proof formalized mechanically checked pvs verification system approach provides methodology ease formal specification assurance critical faulttolerant systems b introduction synchronous systems distributed computer systems known upper bounds time takes nonfaulty processors perform certain op erations time takes message sent one nonfaulty processor received another existence bounds simplifies development faulttolerant systems nonfaulty processes executing common algorithm use passage time predict others progress property contrasts asynchronous systems upper bounds processing message delays therefore provably impossible achieve certain forms consistent knowledge coordinated action presence even simple faults 6 13 reasons faulttolerant systems critical control applications air craft trains automobiles industrial plants usually based synchronous approach though differ extent basic mechanisms system really guarantee satisfaction synchrony assumption example process scheduling algorithms miss deadlines buffer overflows contention buses ethernet lead violations synchrony assumption may considered good enough less truly critical appli cations applications truly critical however often build mechanisms merely synchronous synchronized timetriggered clocks different processors kept close together processors perform actions specific times tasks messages globally statically sched uled honeywell safebus tm 117 provides safetycritical backplane boeing 777 airplane information management system aims 3139 control system shinkansen japanese bullet train 16 timetriggered protocol ttp proposed safetycritical automobile functions 21 use latter approach number basic functions identified provide important building blocks construction faulttolerant synchronous systems 8 10 include consensus also known interactive consistency byzantine agree ment 33 reliable atomic broadcast 9 group membership 7 numerous algorithms developed perform functions criticality subtlety several subjected detailed formal 15 23 43 mechanically checked 2 2628 34 verifications combination larger functions diagnosis 25 synthesis faulttolerant architecture based active statemachine replication 11 35 formal especially mechanicallychecked verification algorithms still something tour de force however real impact practice need reduce difficulty formal verification domain routine largely automated process order achieve study sources difficulty existing treatments attempt reduce eliminate particular look opportunities systematic treatments may allow aspects common range algorithms treated uniform way may even allow aspects broken verified generic manner wide range apparent level difficulty detail verifications cited differences attributed ways problems formalized different resources formal specification languages theorem provers employed example rushby 34 bevier young 2 describe mechanically checked formal verifications oral messages algorithm 24 consensus problem performed using different verification systems young 42 argues differences difficulty treatments 34 generally considered simpler clearer 2 due different choices way things formalized may assume differences reduced eliminated experience gained better choices become widely known significant differences due things formalized differences due formalized level detail considered necessary exam ple verifications oral messages algorithm mentioned specify algorithm functional program proofs conventional inductions following approach special case tworound algorithm variant algorithm known om1 specified 28 couple lines verification almost completely automatic contrast treatment om1 23 long detailed quite complicated reason length complexity treatment explicitly considers distributed message passing character intended implementation calculates tight realtime bounds timeouts employed details abstracted away treatments using functional programsbut mean verifications inferior detailed analyses contrary would argue capture essence algorithms concerned ie explain algorithm fault tolerant messagepassing realtime bounds implementation details ought handled separately fact papers introduce algorithms concerned standard textbook 29 use similarly abstract timefree treatment hand undeniably important also verify specification reasonably close intended implementa tion establish correct timeouts used concrete fault modes match assumed abstract treatment natural resolution competing claims abstractness concreteness hierarchical approach essence algorithm verified abstract formulation realistic formulation shown refinement suitable sense abstract formulation things work well refinement argument routine calculation timeouts concrete details purpose paper present framework hierarchical treatment show important case timetriggered implementations roundbased algorithms details refinement concrete formulation worked systematic formal verification timetriggered algorithms 5 roundbased algorithms textbook 29 nancy lynch identifies algorithms synchronous system model execute series rounds rounds two phases first processor 1 sends message processors different messages may sent different processors messages depend current state sending processor second phase processor changes state manner depends current state collection messages received first phase notion realtime model messages transferred instantaneously senders recipients two phases processors operate lockstep perform two phases current round move first phase next round several algorithms interest explicitly formulated terms rounds first presented others easily recast form example oral messages algorithm consensus om1 requires two rounds follows algorithm om1 round 0 communication phase distinguished processor called transmitter sends value processors called receivers receivers send messages computation phase receiver stores value received transmitter state round 1 communication phase receiver sends value received transmitter receivers transmitter sends message computation phase receiver sets decision component state majority value among received receivers stored state received transmitter presence one fewer arbitrary faults om1 ensures nonfaulty receivers decide value transmitter nonfaulty value one sent transmitter two different ways implement roundbased algorithms timetriggered approach implementation close model processors closely synchronized eg within couple bittimes case refer participants processors stress assumed fail independently agents perform actions actually processes safebus run common deterministic schedule cause execute specific algorithms specific times according local clocks sequencing phases rounds similarly driven local clocks communication bandwidth also allocated dedicated fixed time slots first communication phase round must sufficiently long nonfaulty processors able exchange messages successfully consequently explicit timeouts needed message arrived time second computation phase round begins implicitly timed whereas allocation resources statically determined timetriggered approach eventtriggered approach resources scheduled dynamically processors respond events occur implementation style initiation protocol may triggered local clock subsequent phases rounds driven arrival messages lamport merz treatment om1 example receiver received message transmitter may forward immediately receivers without waiting clock indicate next round started words pacing phases rounds determined locally availability messages unlike timetriggered approach messages may explicitly timed eventtriggered approach example lamport merz treatment om1 receiver wait relayed messages receivers beyond past start algorithm ffi maximum communication delay ffl maximum time take receiver decide relay message algorithms first introduced using eventtriggered formulation example cristians atomic broadcast group membership algorithms 7 9 possible reconstruct explicitly roundbased equivalents transform timetriggered implementations kopetz timetriggered algorithms 19 problems extent eventtriggered systems generally easier construct timetriggered ones require big planning scheduling effort upfront achieve better cpu utilization light load hand kopetz 2021 argues persuasively timetriggered systems predictable hence easier verify easier test make better use broadcast communications bandwidth since addresses need communicatedthese implicit time message sent operate closer capacity generally preferred truly critical appli cations previously mentioned safebus boeing 777 shinkansen train control system ttp protocol automobiles timetriggered goal systematic method transforming roundbased protocols abstract functional programs whose properties comparatively easy formally mechanically verify timetriggered implementations appropriate timing constraints consideration realistic fault modes transformation accomplished two steps first functional program untimed synchronous system timetriggered implementation first step systematic must undertaken separately algorithm see systematic formal verification timetriggered algorithms 7 section 4 generic deals large class algorithms fault assumptions single verification generic treatment second step described following section roundbased algorithms implemented timetriggered systems issues transforming untimed roundbased algorithm timetriggered implementation basically ensure timing duration events communication phase messages nonfaulty processors always arrive communication phase round fault modes interpreted appropriately verify transformation introduce formal models untimed synchronous systems timetriggered systems establish simulation relation treatment formalized mechanically checked using pvs verification systemsee section 34 31 synchronous systems untimed case use nancy lynchs formal model synchronous systems 29 chapter 2 slight adjustments notation make easier match mechanically verified treatment untimed synchronous systems assume set mess messages includes distinguished value null set proc processors processors partially connected directed channels channel thought buffer hold single message associated processor p following sets functions ffl set processors outnbrs p p connected outgoing channels ffl set processors innbrs p p connected incoming channels function inputs p mess gives message contained channels ffl set states p states nonempty subset init p initial states convenient assume component state counts rounds counter zero initial states ffl function msg p states p theta outnbrs p mess determines message placed outgoing channel way depends current state ffl function trans p states p theta inputs p states p determines next state way depends current state messages received incoming channels system starts processor initial state processors p repeatedly perform following two actions lockstep communication phase apply message generation function msg p current state determine messages placed outgoing channel message value null used indicate message computation phase apply state transition function trans p current state message held incoming channel yield next state round counter incrementeda particular algorithm specified supplying interpretations various sets functions identified faults distributed algorithms usually required operate presence faults specific kinds numbers faults may arise constitute fault hypothesis usually processor faults distinguished communication faults former modeled perturbations transition functions trans p latter allowing messages received along channel changed sent following 29 page 20 execution system infinite sequence triples global state start round r r collection messages placed communication channels n r possibly different collection messages received goal show timetriggered implementation achieves behavior untimed synchronous system serves specification need way ensure faults match across two systems reason prefer model processor communications faults perturbations trans p msg p respectively rather allowing messages received differ sent particular assume current round number recorded part state processor p faulty round r current state values input channels represented array trans p may yield value intended similarly channel p q faulty value msg p sq may different intended may null exactly values may differ intended depends fault assumption example crash fault round r results trans p null q states whose round component r greater notice although trans p msg p may longer intended functions still functions fact need suppose trans p msg p changed fault arrived round systematic formal verification timetriggered algorithms 9 r since round counter part state assume functions behave differently intended applied states round counters equal greater r benefit treatment since trans p msg p uninterpreted represent algorithm fault behavior show timetriggered system supplied arbitrary trans p msg p functions behavior untimed synchronous system supplied functions demonstration encompasses behavior presence faults well faultfree case furthermore since longer need hypothesize faults cause differences messages sent received instead assume fault msg p different messages actually sent executions simplified sequences triples simple sequences states global state start round r consequently demonstrate timetriggered system implements behavior specified untimed synchronous system simply need establish systems execution sequences mathematical induction reduce showing global states two systems start round r 32 timetriggered systems timetriggered system elaborate model previous section follows processor supplied clock provides reasonably accurate approximation real time speaking clocks usual distinguish two notions time clocktime denoted c local notion time supplied processors clock realtime denoted r abstract global quantity also usual denote clocktime quantities upper case roman greek letters realtime quantities lower case letters formally processor ps clock function c p c intended interpretation c p value ps clock realtime 2 clocks nonfaulty processors assumed wellbehaved sense satisfying following assumptions assumption 1 monotonicity nonfaulty clocks monotonic increasing functions satisfying assumption requires care implementation clock synchronization algorithms make adjustments clocks cause 2 terminology 22 actually inverse clocks jump backwards lamport melliarsmith describe solutions 22 particularly clever economical technique one particular algorithm introduced torrespomales 40 formally verified miner johnson 30 schmuck cristian 38 examine general case show monotonicity achieved loss precision assumption 2 clock drift rate nonfaulty clocks drift realtime rate bounded small positive quantity ae typically assumption 3 clock synchronization clocks nonfaulty processors synchronized within small clocktime bound sigma tj sigma systems feature characterizes timetriggered system activity driven global schedule processor performs action time local clock matches action scheduled formal model schedule function sched clocktime round r begin duration rth round given addition fixed global clocktime constants p give offsets round messages sent computation phase begins respectively obviously need following constraint constraint notice duration communication phase fixed p duration computation phase differ one round another 3 states messages channels timetriggered system corresponding untimed synchronous system transition message functions addition processors oneplace buffer incoming message channel timetriggered system operates follows initially processor initial state round counter zero clock synchronized others initialized c p current realtime processors p repeatedly perform following two actions 3 fact difficulty generalizing treatment allow time messages sent duration communication phase vary round round fixed clocktime constants p systematically replaced functions dr p r respectively generalization developed mechanized verification see section 34 systematic formal verification timetriggered algorithms 11 communication phase begins local clock reads sched r r current value round counter apply message generation function msg p current state determine messages sent outgoing channel messages placed channels local clock time schedrd incoming messages arrive communication phase ie later schedr moved corresponding input buffer remain stable computation phase buffers initialized null beginning communication phase value unspecified one message arrives associated communications channel given communication phase computation phase begins local clock time apply state transition function trans p current state messages held input buffers yield next state computation complete local clock time earlier schedr 1 increment round counter wait start next roundmessage transmission communication phase explained follows use sentp q indicate processor p sent message processor q member outnbrsp real time must satisfy c p round r use recvq indicate processor q received message processor p member innbrsq real time must satisfy constraint schedr c q round r two events related follows assumption 4 maximum delay p q nonfaulty processors sent p q oe recvq 0 ffi addition require spontaneous generation messages ie recvq corresponding sent p q 0 provided exactly one recvq event p communication phase round r processor q p nonfaulty message moved input buffer associated p processor q start computation phase round remains throughout phase clocks perfectly synchronized possible message sent processor fast clock arrive recipient still previous round reason send messages clocktime units start round general need ensure message processor round r cannot arrive destination processor started round r finished communication phase round r must establish constraints parameters ensure conditions satisfied processor p sends message processor q say realtime c p maximum delay assumption message arrive need sure clock synchronization jc q tj sigma substituting c p schedr obtain monotonic clocks assumption gives first inequality 1 ensured constraint 2 sigma clock synchronization calculation 2 also gives clock drift rate assumption gives follows thus second inequality 1 ensured constraint faults prove timetriggered system satisfying various assumptions constraints identified achieves behavior untimed synchronous system supplied trans p msg p functions explained earlier faults assumed modeled trans p msg p using functions untimed timetriggered systems ensure latter inherits fault behavior faulttolerance properties former thus algorithm shown untimed formulation achieve faulttolerance properties eg algorithm resists single byzantine fault two crash faults may conclude implementation properties systematic formal verification timetriggered algorithms 13 simple view somewhat compromised however timetriggered system contains mechanismtime triggeringthat present untimed system mechanism admits faults notably loss clock synchronization arise untimed system implementation must ensure faults either masked transformed way manifestations accurately modeled perturbations trans p msg p functions general desirable transform lowlevel faults ie outside model considered simplest easily tolerated fault class algorithm concerned lowlevel mechanism dealing loss clock synchronization present synchronization faults may manifest arbitrary byzantine faults abstract algorithm example one pro cessors clock drifts extent wrong round execute transition message functions appropriate round supply systematically incorrect messages processors could easily appear byzantine behavior level untimed synchronous algorithm reason desirable include round number messages wrong round rejected thereby reducing fault manifestation failsilence ttp goes includes critical state information operating mode time group membership messages part crc calculation 21 less drastic clock skews may leave processor right round sending messages wrong time arrive computation phases correct processors partly counter fault mode timetriggered model used explicitly moves messages input channels input buffer communication phase shields receiving processor changes channel contents computation phase physical implementation time triggered system multiplexes communications channels onto shared buses necessary control bab bling idiot fault mode faulty processor disrupts communications processors speaking turn practice controlled bus interface unit biu grants access bus appropriate times example safebus processors paired member pair controlling others biu ttp biu independent knowledge schedule cases babbling occur undetected double failures 33 verification need show timetriggered system achieves behavior corresponding untimed synchronous system traditional way establishing simulation relationship states execution timetriggered system corresponding untimed execution usually necessary invent abstraction function relate states implementation specification however states two systems difficult point select moments time states timetriggered system correspond untimed system untimed system makes progress discrete global steps component processors perform communication computation phases lockstep possible speak complete system round r processors timetriggered system however progress separately rate governed internal clocks imperfectly synchronized one processor may still round r another moved round r 1 need establish consistent cut timetriggered system provides global state processors point round treatments distributed systems necessary global cut correspond snapshot system particular realtime instant cut may abstract construction direct realization case however natural assume timetriggered system used control application outputs individual processors ie functions states used provide redundant control signals real timefor example typical application one outputs processors subjected majority voting separately drive actuator force summing configuration 4 consequently want identify cut system global state specific real time instant particular need realtime instant gsr corresponds global start rth round want instant one nonfaulty processors started rth round yet started computation phase change states achieve defining global start time gsr round r realtime processor slowest clock begins round r gsr satisfies following constraints sched r 4 intuitively p processor slowest clock since processors perfectly synchronized need sure cannot drift far apart processor q already reached computation phaseor even next roundat gsr thus need 3 c q plus clock synchronization assumption gives x sigma processor q still 4 example outputs different processors may energize separate coils single solenoid multiple hydraulic pistons may linked single shaft see eg 12 figure 322 systematic formal verification timetriggered algorithms 15 round r communication phase provided ensured inequality derived taken together constraint 3 wish establish global state timetriggered system time gsr corresponding untimed synchronous system start rth round denote global state untimed system start rth round gur global untimed global states simply arrays states individual processors state processor p point gurp similarly global state timetriggered system time gsr denoted gtr global timed state processor p gtrp state prove desired result theorem 1 given initial states global states untimed timetriggered systems beginning round proof proof induction base case case systems initial states hypothesis inductive step assume result r prove r 1 untimed case message inputs q p processor p received q rth round msg p gurpq 5 inductive hypothesis global state processor p timetriggered system time gsr gurp also furthermore processor p communication phase ensured 5 changed state since starting round thus local clocktime schedr sends msg p gurpq q 1 received q communication phase round r transferred input buffer inputs q p thus corresponding processors untimed timetriggered systems state input components begin computation phase round r state transition functions trans p applied corresponding processors two systems yield values corresponding elements gur completing inductive proof5 benefit used reading curried higherorder function applications decoded follows gurp ps state round applied state gives msg p gurp array messages sent outgoing channels qs component array msg p gurpq 34 mechanized verification treatment synchronous timetriggered systems sections 31 32 formally specified language pvs verification system 32 verification section 33 mechanically checked using pvss theorem prover pvs language higherorder logic subtyping formalization semiformal treatment sections 31 32 quite straightforward pvs theorem prover includes decision procedures integer real linear arithmetic mechanized checking calculations section 33 proof theorem also quite straightforward complete formalization mechanical verification took less day errors discovered formal specification verification described appendix specification files available url httpwwwcslsricomdcca97html reassuring know semiformal development withstands mechanical scrutiny argued previously example 3236 mechanized formal verification provides several benefits addition certification proofs particular mechanization supports reliable inexpensive exploration alternative designs assumptions constraints case wondered whether requirement messages sent fixed offset clocktime units round computation phase begin fixed offset p might unduly restrictive work minutes generalize formal specification allow offsets become functions round adjust mechanized proofs contend corresponding revisions semiformal development sections 32 33 would take longer would difficult summon fortitude scrutinize revised proofs care originals roundbased algorithms functional programs theorem section 33 ensures synchronous algorithms correctly implemented timetriggered implementations satisfy various assump tions constraints constructions introduced previous section next though logically preceding step ask one might verify properties particular algorithm expressed untimed synchronous system although simpler timetriggered implementation specification algorithm synchronous system especially convenient formal particularly mechanized verification requires reasoning attributes imperative programs explicit state control generally easier verify rather imperative programs represent state control applicative manner expressed directly conventional logic fairly systematic transformation synchronous systems functional programs ease verification task allowing performed functional program illustrate idea comes bevier systematic formal verification timetriggered algorithms 17 young 2 using om1 algorithm section 2 algorithm already introduced synchronous system illustrate transformation functional program technique becomes familiar easy perform transformation direction begin introducing function sendr v p q represent sending message value v processor p processor q round r value function message received q p q nonfaulty value v otherwise depends fault modes considered byzantine case left entirely unconstrained represents transmitter v value q arbitrary receiver communication phase first round om1 represented computation phase round simply moves messages received states processors concerned ignored functional treatment though see footnote 6 communication phase second round processor q sends value received first round ie send0 v q receivers p one receiver described functional composition computation phase second round processor p gathers messages received communication phase subjects majority voting 6 6 represents value p receives q need gather together way values messages p receives receivers q use combination argument majority vote function gathering together represented depend resources specification language logic concerned treatment using boyermoore logic example represented list values 2 higherorder logic pvs 32 however represented function specified abstraction ie function applied q returns value p received q majority voting represented function maj takes two arguments participants vote function participants returns 6 formulation algorithm synchronous system p votes messages receivers message received directly transmitter saved state functional treatment q includes among recipients message sends communication phase second round vote simply messages received round value associated function maj returns majority value one exists otherwise functionally determined value behavior either specified axiomatically defined constructively using algorithm boyer moores linear time mjrty 4 thus ps decision computation phase second round represented rcvrs set receiver processors use formula definition higherorder function om1t v whose value function gives decision reached receiver p possibly faulty transmitter sends value properties required algorithm following provided number receivers three one processor faulty definition 7 requirements agreement validity stated acceptable specifications pvs almost given pvs requires little explicit types quantification involved using constructive definition maj pvs prove agreement validity specific number processors eg completely automatically general case n 4 processors pvs able prove agreement single usersupplied proof directive validity requires half dozen one requiring insight casesplit whether transmitter faulty synchronous systems easily transformed recursive func tion properties always formally verified easily nonetheless believe approach promise many algorithms practical interest similar method advocated florin gomez lavallee 14 5 conclusion many roundbased faulttolerant algorithms formulated synchronous systems shown synchronous systems implemented timetriggered systems proved provided care taken fault modes correctness faulttolerance properties algorithm expressed synchronous system inherited timetriggered implementation proof identifies necessary timing constraints independent particular algorithm concerned provides general abstract treatment analysis systematic formal verification timetriggered algorithms 19 performed particular system di vito butler 5 relative simplicity proof supports argument timetriggered systems allow straightforward analysis preferred critical applications reason 20 also shown example roundbased algorithm formulated synchronous system transformed functional program specification logic properties verified easily mechanically systematic transformations faulttolerant algorithms functional programs synchronous systems timetriggered implementations provides methodology significantly ease specification assurance critical faulttolerant systems current work applying methodology algorithms ttp 21 acknowledgments discussions n shankar advice joseph sifakis instrumental development work comments anonymous referees improved presentation r arinc specification 659 backplane data bus design proof correctness faulttolerant circuit impossibility group membership reaching agreement processorgroup membership synchronous distributed systems understanding faulttolerant distributed systems atomic broadcast simple message diffusion byzantine agreement di vito general dynamics case study f16 flybywire flight control system impossibility distributed consensus one faulty process systematic building distributed recursive algorithm group membership protocol specification verification concepts technologies dependable realtime computer systems shinkansen train control safebus tm fault tolerant computing symposium 25 highlights 25 years responsive systems eventtriggered timetriggered ieice transactions information systems synchronizing clocks presence faults specifying verifying faulttolerant systems byzantine generals problem formally verified algorithms diagnosis manifest formal verification algorithm interactive consistency hybrid fault model formally verified algorithm interactive consistency hybrid fault model formal verification interactive consistency algorithm draper ftp architecture hybrid fault model distributed algorithms verification optimized faulttolerant clock synchronization circuit case study exploring boundary formal reasoning systems integrated modular avionics nextgeneration commercial airplanes formal verification faulttolerant architectures prolegomena design pvs reaching agreement presence faults formal verification oral messages algorithm interactive consistency faultmasking transientrecovery model digital flightcontrol systems formally verified algorithm clock synchronization hybrid fault model less elementary tutorial pvs specification verification system continuous clock amortization need affect precision clock synchronization algorithm boeings seventh wonder optimized implementation faulttolerant clock synchronization circuit formal techniques realtime faulttolerant systems comparing verification systems interactive consistency acl2 formal specification compositional verification atomic broadcast protocol tr ctr clara benac earle larske fredlund john derrick verifying faulttolerant erlang programs proceedings 2005 acm sigplan workshop erlang september 2628 2005 tallinn estonia christoph kreitz building reliable highperformance networks nuprl proof development system journal functional programming v14 n1 p2168 january 2004 faith fich eric ruppert hundreds impossibility results distributed computing distributed computing v16 n23 p121163 september
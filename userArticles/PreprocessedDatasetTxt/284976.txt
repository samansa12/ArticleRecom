guaranteeing fair service persistent dependent tasks introduce new scheduling problem motivated applications area access flow control highspeed wireless networks instance problem consists set persistent tasks scheduled repeatedly task demand scheduled often possible explicit limit number tasks scheduled concurrently however limits imposed implicitly tasks may conflict cannot scheduled simultaneously conflicts presented form conflict graph define parameters quantify fairness regularity given schedule proceed show lower bounds parameters present fair efficient scheduling algorithms case conflict graph interval graph results presented extend case perfect graphs circulararc graphs well b introduction paper consider new form scheduling problem characterized two features persistence tasks task simply go away scheduled instead task must scheduled innitely many times goal schedule every task frequently possible dependence among tasks tasks con ict hence cannot scheduled concur rently con icts given con ict graph graph imposes constraints sets tasks may scheduled concurrently note constraints based simply cardinality sets rather identity tasks within sets extended summary ibm research division j watson research center yorktown heights ny 10598 email famotzsbarmadhugwatsonibmcom z dept computer science columbia university new york ny 10027 email mayercscolumbiaedu part work done author ibm j watson research center partially supported ibm graduate fellowship nsf grant ccr9316209 cise institutional infrastructure grant cda9024735 consider problems allocation ie often task scheduled regularity ie evenly spaced lengths intervals successive scheduling specic task present formal description problem next discuss primary motivation immediately afterwards denitions presented general con ict graphs applications bounds algorithms special subclasses namely perfect graphs interval graphs circular arcgraphs 1 problem statement instance scheduling problem consists con ict graph g n vertices vertices g tasks scheduled edges g dene pairs tasks cannot scheduled concurrently output scheduling algorithm innite sequence subsets vertices 1 lists tasks scheduled time notice must independent set g form hard analyze running time scheduling algorithm consider instead nite version problem use analyze running time input con ict graph g time output independent set denoting set tasks scheduled time unit objective scheduling algorithm achieve fair allocation regular schedule next give motivation describe context work see none existing measures appropriately capture goodness schedule framework hence proceed introduce measures allow easier presentation results 1 graph perfect induced subgraphs size maximum clique equal chromatic number cf 11 graph interval graph circulararc graph vertices correspond intervals line circle two vertices adjacent corresponding intervals intersect cf 20 barnoy mayer b schieber sudan 11 motivation session scheduling highspeed localarea net works metaring 7 recent highspeed localarea ringnetwork allows spatial reuse ie concurrent access transmission user sessions using minimal intermediate buering packets basic operations metaring approximated following node send data node session established source destination sessions typically last active exclusive use links routes hence sessions whose routes share least one link con ict con icts need regulated breaking data sent session units quotas transmitted according schedule schedule ecient fair ecient means total number quotas transmitted throughput maximized whereas fair means throughput session maximized time successive activation session minimized large buers source nodes avoided recognized 5 access control network depend locality con ict graph however rm theoretical basis algorithmic framework proposed express problem scheduling problem create circulararc graph whose vertices sessions vertices adjacent corresponding paths associated sessions intersect link time sharing wireless networks indoor designs wireless networks based cellular architecture small cell size see eg 13 cellular architecture comprises two levels stationary level mobile level stationary level consists xed base stations interconnected backbone network mobile level consists mobile units communicate base stations via wireless links geographic area within mobile units communicate particular base station referred cell neighboring cells overlap thus ensuring continuity communications mobile units communicate among well xed information networks base stations backbone network continuity communications crucial issue networks mobile user crosses boundaries cells able continue communication via new basestation ensure basestations periodically need transmit identity using wireless communication implementations wireless links use infrared waves therefore two basestation whose cells overlap con ict cannot transmit identity simulta neously con icts regulated timesharing scheme time sharing ecient fair ecient means scheme accommodate maximal number base stations whereas fair means time two consecutive transmissions basestation less time takes user cross corresponding cell problem posed graphscheduling problem vertices graph basestations edge indicates base stations overlapping cells 12 relationship past work scheduling problems consider either persistence tasks dependence among tasks dealt task scheduling persistent tasks studied work baruah et al 2 consider problem scheduling set n tasks given arbitrary frequencies machines hence yields instance problem con ict graph clique measure regularity schedule problem introduce notion p fairness schedule problem p fair proportionatefair time task absolute value dierence number times scheduled f strictly less 1 f frequency task provide algorithm computing p fair solution problem problem fails capture situation due two reasons first would like constrain sets tasks scheduled concurrently according topology con ict graph according cardinality moreover problem every feasible frequency requirement scheduled p fair manner scheduling problem show p fair schedule cannot always achieved deal feasible frequencies cannot scheduled p fair manner dene weaker versions regularity dependency property captures work done based wellknown dining philoso phers paradigm see example 9 18 6 1 8 4 setting lynch 18 rst explicitly consider response time task goal successive works make response time node depend local neighborhood con ict graph see eg 4 response time terms nodes degree adequate oneshot tasks capture requirement task guaranteeing fair service persistent dependent tasks 3 scheduled regular fair fashion period time 13 notations denitions schedule innite sequence independent sets 1 use notation si represent schedule si lim inf t1 ff g refer f frequency ith task schedule definition 11 vector frequencies feasible exists schedule frequency ith task schedule least f definition 12 schedule realizes vector f frequency ith task schedule least f schedule capproximates vector frequencies f frequency ith task schedule least f c measure fairness fairness determined via partial order dene set frequency vectors definition 13 given two frequency vectors f less fair exists index j threshold f f j f g j g f definition 14 vector frequencies f maxmin fair feasible vector g less formally maxmin fair frequency vector one cannot increase frequency task expense frequently scheduled tasks means goal let task resource long take resource away tasks better ie resource task measures regularity provide two measures one evaluate schedule reg ularity call measures response time drift given schedule response time task denoted r largest interval time ith task waits successive schedulings precisely time number expected occurrences task expressed f note r larger 1f possible period time schedule allows task drift away expected number occurrences order capture introduce second measure regularity schedule denote drift task indicates much schedule allows task drift away expected number scheduled units based frequency note schedule achieves drift 1 pfair dened 2 finally schedule achieves strongest form regularity task scheduled every 1f timeunits except rst appearance hence say schedule rigid task exists starting point task scheduled exactly time units 14 results section 2 motivate denition maxmin fairness show several properties first provide equivalent alternate denition feasibility shows deciding feasibility frequency vector computable prove every graph unique maxmin fair frequency vector show task even weaklyapproximating maxmin fair frequencies general graphs nphard mentioned many practical applications problem arise simpler networks buses rings ie interval con ict graphs circulararc con ict graphs case perfect graphs hence interval graphs describe ecient algorithm computing maxmin fair frequencies prove period schedule realizing frequencies satises exist interval graphs n rest results deal problem nding regular schedule mentioned measures realizes feasible frequency vector section 3 shows existence interval graphs p fair schedule realizes maxmin fair frequencies section 4 introduce algorithm computing schedule realizes given feasible frequencies interval graphs schedule computed algorithm achieves responsetime d4f e drift log slight modication algorithm yields schedule 2approximates given frequencies advantage schedule 4 barnoy mayer b schieber sudan achieves bound 1 drift hence bound d2f e response time section 5 present algorithm computing schedule 12approximates given feasible frequencies interval graphs advantage rigid algorithms run polynomial time section 6 show transform algorithm computing schedule capproximates given feasible frequencies interval graphs algorithm computing schedule 2capproximates given feasible frequencies circulararc graphs responsetime drift resulting schedule doubled well finally section 7 list number open problems sketch additional properties required obtain solutions actual net works due space constraints proofs either omitted sketched extended summary allocation denition maxmin fair allocation based denition used jae 14 bertsekas gallager 3 diers one key ingredient namely notion feasibility study elementary properties denition section particular show denition guarantees unique maxmin fair frequency vector every con ict graph also show hardness computing frequency vector general graphs however special case perfect graphs notion turns 3 denition 14 3 considered traditional way measure throughput fairness also based partial order used denition primary dierence denition denition feasibility bertsekas gallager 3 use denition call clique feasible dened follows vector frequencies f feasible con ict graph g cliques c graph g notion maxmin fairness bertsekas gallager 3 exactly notion feasibility replaced clique feasibility denition 3 useful capturing notion fractional allocation resource bandwidth communication networks however application need capture notion integral allocation resources hence denition suce purposes easy see every frequency vector feasible sense clique feasible however converse true consider case con ict graph vecycle graph vector 12 12 12 12 12 clique feasible schedule achieve frequency 21 alternate denition feasibility given con ict graph g let denote family independent sets g 2 let denote characteristic vector proposition 21 vector frequencies f feasible exist weights f g i2i i2i f main impact assertion shows space feasible frequencies well behaved ie closed connected compact space immediately shows determining whether frequency vector feasible computable task fact may easy see earlier denition use denition see following connection proposition 22 given con ict graph g notions feasibility clique feasibility equivalent g perfect proof sketch proof follows directly wellknown polyhedral properties perfect graphs see 12 16 notation knuth 16 space feasible vectors polytope stabg space cliquefeasible vectors polytope qstabg result follows theorem page 38 16 says graph g perfect 22 uniqueness computability maxmin fair frequencies full paper prove following theorem theorem 23 exists unique maxmin fair frequency vector turn issue computability maxmin fair frequencies know exact complexity computing maxmin fair frequencies 2 seem hard task gen eral particular consider problem computing smallest frequency assigned vertex maxmin allocation show following theorem 24 exists 0 given con ict graph n vertices approximating particular know deciding whether frequency vector feasible np conp guaranteeing fair service persistent dependent tasks 5 smallest frequency assigned vertex maxmin fair allocation within factor n nphard proof sketch relate computation maxmin fair frequencies general graph computation fractional chromatic number graph fractional chromatic number problem cf 17 dened follows independent set graph assign weight w minimize quantity w subject constraint every vertex v graph quantity i3v w least 1 quantity w called fractional chromatic number graph observe w forced integral fractional chromatic number chromatic number graph following claim shows relationship fractional chromatic number assignment feasible frequencies 25 let f feasible assignment frequencies vertices graph g upper bound fractional chromatic number graph conversely k fractional chromatic number graph schedule sets frequency every vertex 1k feasible claim combined hardness computing fractional chromatic number 17 suf ces show nphardness deciding whether given assignment frequencies feasible given graph show claim also implies hardness approximating smallest frequency maxmin fair frequency vector inspect lund yannakakis construction bit closely construction yields graph every vertex participates clique size k deciding fractional chromatic number k kn nphard former case maxmin fair frequency assignment 1k every vertex latter case least vertex frequency smaller 1kn thus implies approximating smallest frequency maxmin fair frequencies within factor n nphard 2 23 maxmin fair frequencies perfect graphs turn perfect graphs show compute polynomial time maxmin fair frequencies class graphs give bounds period schedule realizing frequencies main focus subsequent sections interval graphs give algorithms bounds rst terms figure 1 interval graph n subclass show generalize results perfect graphs start describing algorithm computing maxmin fair frequencies interval graphs know cliquefeasibility equals feasibility proposition 22 use adaptation 3 algorithm 1 let c collection maximal cliques interval graph notice c n elements computed polynomial time clique c 2 c algorithm maintains residual capacity initially 1 vertex algorithm associates label assignedunassigned vertices initially unassigned dividing residual capacity clique number unassigned vertices clique yields relative residual capacity iteratively consider clique smallest current relative residual capacity assign cliques unassigned vertices capacity frequency vertex clique mark assigned subtract frequency residual capacity every clique contains repeat process till every vertex assigned frequency hard see algorithm 1 correctly computes maxmin fair frequencies polynomial time use behavior prove tight bound period schedule interval graph following theorem establishes bound see also figure 1 theorem 26 let f frequencies maxmin fair schedule interval graph g relatively prime period schedule furthermore exist interval graphs n 6 barnoy mayer b schieber sudan clear algorithm 1 works graphs clique feasibility determines feasibility ie perfect graphs however algorithm remain computationally ecient still theorem 26 directly extended class perfect graphs use fact describe polynomialtime algorithm assigning maxmin fair frequencies perfect graphs algorithm 2 algorithm maintains labelling procedure assignedunassigned algorithm 1 phase algorithm starts set assigned frequencies tries nd largest f unassigned vertices assigned frequency f compute f polynomial time algorithm uses fact deciding given set frequencies feasible reducible task computing size largest weighted clique graph weights vertices latter task well known computable polynomialtime perfect graphs using decision procedure algorithm performs binary search nd largest achievable f binary search rened due theorem 26 found largest f algorithm nds set vertices saturated f follows let small number instance sucient raises one time frequency unassigned vertex f maintaining unassigned frequencies f obtained set frequencies feasible marks vertex assigned frequency assigned f algorithm repeats phase vertices assigned frequency 3 nonexistence pfair allocations show p fair scheduling realizing maxmin fair frequencies need exist every interval graph theorem 31 exist interval graphs g pfair schedule realizes maxmin frequency assignment order prove theorem construct graph g follows choose parameter k every permutation elements dene interval graph g show necessary condition must satisfy g pfair schedule lastly show exists permutation 12 elements satisfy condition given permutation k elements g consists 3k intervals figure 2 graph g maxmin frequency assignment g following tasks bi frequency 1k tasks ai frequency tasks ci frequency ik see figure 2 observe properties pfair schedule tasks g time period k ii schedule entirely specied schedule tasks bi iii schedule permutation k elements time unit bi scheduled see kind permutations constitute pfair schedules g dene notion permutation fair another permutation definition 31 permutation 1 fair permutation 2 conditions cond ij dened follows 32 permutation pfair schedule g fair identity permutation permutation permutation 12 elements full paper show permutation fair identity realizing frequencies exactly section rst show construct schedule realizes feasible set frequencies hence particular maxmin frequencies exactly interval graph prove correctness demonstrate bound d4f e response time interval proceed introduce potential function used yield bound 1 drift every interval also prove feasible frequencies form drift schedule bounded 1 thus waiting time bounded use property give algorithm guaranteeing fair service persistent dependent tasks 7 computing schedule 2approximates feasible set frequencies high regularity input algorithm unit time con ict graph g interval graph equivalently set intervals unit interval 0 1 xcoordinate every interval frequency f following constraint simplicity assume constraints frequencies met equality g output algorithm independent set set tasks scheduled time scheduled given fi g realizes frequencies f algorithm recursive let denote number times task appear time units ie algorithm log levels recursion recall log maxmin fair frequencies rst level decide occurrences tasks half period task decide many occurrences appear rst half period many second half yields problem recursive nature two halves order nd schedule time suces solve problem recursively half contains note case odd one halves longer clearly task even number occurrences would appear number times half order minimize drift problem tasks odd number occurrences clearly half least bs c occurrences additional occurrence assigned half way resulting subproblems would still feasible main diculty assignment solved procedure sweep procedure sweep procedure compute assignment additional occurrence tasks odd number occurrences input procedure set intervals odd restriction clique resulting interval graph even size later show overcome restriction output partition intervals two sets clique equally divided among sets done sweep along xcoordinate intervals sweep every interval assigned variable end set 0 1 ie rst half period second half period suppose sweep point x say interval active sweep point x x 2 assignment rules follows interval starts x current number active intervals even new variable assigned unpaired current number active intervals odd paired currently unpaired interval j assigned negation j variable thus matter value later assigned variable j end opposite halves interval ends x current number active intervals even nothing done current number active intervals odd paired j paired currently unpaired interval k also j variable matched negation k variable ensure j k put opposite halves equivalently k put halves unpaired assign arbitrarily 0 1 variable operations ensure whenever number active intervals even exactly half intervals assigned 0 half assigned proven later recall assumed size clique even let us show overcome restriction need following simple lemma c x set input intervals odd even contain x c x referred clique lemma 41 period even oddgj even every clique c lemma implies even size clique input procedure sweep indeed even odd dummy interval n1 extends intervals exactly one occurrence added set calling sweep lemma 41 sure modied set size cliques even would increase period one additional time unit allotted dummy interval thus ignored note produce schedule time follow recursive calls include period since log calls time takes produce schedule polynomial n maxmin fair frequencies 8 barnoy mayer b schieber sudan lemma 42 algorithm produces correct schedule every feasible set frequencies lemma 43 set frequencies form drift bounded 1 hence response time bounded d2f e proof since algorithm always divides even equal halves following invariant maintained recursive level whenever 1 even also note thus express f 2 k following algorithm easily shown least one occurrence task time interval size hence c p fairness lemma 44 response time every interval bounded d4f e proof proof based lemma 43 lemma clearly implies case frequencies powers two moreover case frequencies powers two virtually partition task two tasks frequencies p r respectively f power two r p schedule task frequency p drift 1 implies response time d2p e d4f e 2 remark shown bound lemma tight algorithm summarize results section following theorem theorem 45 given arbitrary interval graph con ict graph algorithm exactly realizes feasible frequencyvector guarantees r 41 bounding drift since algorithm olog levels recursion level may increase drift one clearly maximum drift bounded olog section prove decrease maximum drift log xed n number tasks theorem 26 implies worst case drift maxmin fair frequencies bounded 1 method get better drift based following observation recursive step algorithm two sets tasks produced set placed dierent half timeinterval currently considered however free choose set goes half using degree freedom decrease drift make presentation clearer assume power two time units consider subinterval size t2 j starting time ending 1 rst j recursion levels already xed number occurrences task given number drift time xed similarly drift r time r also xed next recursion level split occurrences assigned interval thus xing drift dm time optimally would like drifts next recursion level time unit weighted average drifts r words let would like drift time r particular would like drift drift achieved occurrences interval split equally however case odd number occurrences split drift depending decision half interval put extra occurrence note weighted average drifts points changes accordingly new dm weighted average 2 r 1 2x weighted average 2 r r 1 2 2x 12 consider two sets tasks 1 2 assign two subintervals size level k recursion possible two assignments compute potential based resulting drifts time given possibility let dtm k denote resulting drift ith task k recursion levels dene potential k levels xed even constant choose possibility lowest potential theorem 46 using policy described maximum drift bounded log n xed realizing frequencies rigidly section show construct schedule 12approximates feasible frequencyvector rigid fashion interval graph reduce rigid schedule problem dynamic storage allocation problem dynamic storage allocation guaranteeing fair service persistent dependent tasks 9 problem dened follows given objects stored computer memory object two parameters size terms number cells needed store ii time interval stored object must stored adjacent cells problem nd minimal size memory accommodate given time objects needed stored time dynamic storage allocation problem special case multicoloring problem intervals graphs dene multicoloring weighted graph g weight function v 2 v size f v wv v u 2 e f v f multicoloring problem nd multicoloring minimal number colors problem known nphard problem 10 two interesting special cases multicoloring problem colors vertex either must adjacent must spread well among colors call rst case amc problem second case cmc problem formally solution amc f 1 k whereas solution cmc uses colors f divides ii x hard verify interval graphs amc problem equivalent dynamic storage allocation problem described simply associate object vertex graph give weight equal number cells requires put edge two vertices time intervals inter sect colors assigned vertex interpreted cells object stored hand cmc problem corresponds rigid schedule problem follows first replace frequency fv weight wv let assume output cmc problem uses colors let colors v fx 1 x k g interpret follows v scheduled times x dicult verify indeed solution rigid scheduling problem although dynamic storage allocation problem special case multicoloring problem still known nphard problem 10 similar reasons rigid scheduling problem also nphard therefore looking approximation algorithm follows present approximation algorithm produces rigid scheduling 12approximates given frequencies consider instances amc cmc problems input weights powers two definition 51 solution instance amc aligned contiguous 15 kierstead presents algorithm amc approximation factor 3 careful inspection algorithm shows produces solutions aligned contiguous instances weights power two show translate solution instance amc problem aligned contiguous solution instance cmc problem input weights kbit number whose binary representation inverse binary representation x lemma 51 1g consider instance cmc problem input weights powers two apply solution kierstead 15 solve amc instance input solution aligned contiguous uses 3t 0 colors 0 number colors needed optimal coloring let smallest power 2 greater 0 follows 6t 0 applying transformation lemma 51 output solution amc yields solution cmc colors turn yields approximation factor 12 rigid scheduling problem since wvt fv2 theorem 52 algorithm computes rigid schedule 12approximates feasible frequencyvector interval graph 6 circulararc graphs section show transform algorithm computing schedule capproximates given feasible frequencyvector interval graphs algorithm 0 computing schedule 2capproximates given feasible frequencies circulararc graphs barnoy mayer b schieber sudan f feasible frequencyvector circulararc graph g 1 find maximum clique c g interval graph 2 frequencyvectors resulting restricting f vertices g 0 c respectively note feasible g 0 c respectively step 2 using nd schedules 1 2 c g 2 g 0 c respectively step 3 interleave 1 2 clearly resulting schedule 2capproximates f circulararc graph g 7 future research many open problems remain exact complexity computing maxmin fair frequency assignment general graphs known characterization assignment easy compute scheduling algorithms paper use inherent linearity interval circulararc graphs would interesting nd scheduling algorithms wider class perfect graphs algorithm interval graphs realizes frequencies exactly exhibits considerable gap drift clear direction gap closed algorithms assume central scheduler makes decisions theoretical practical point view important design scheduling algorithms working realistic environments highspeed localarea networks wireless networks mentioned section 11 distinguishing requirements environment include distributed implementation via local signaling scheme con ict graph may change time restrictions space per node size signal performance measures general setting however remain rst step towards algorithms recently carried mayer ofek yung 19 acknowledgment would like thank coppersmith moti yung many useful discussions r dining philosophers algorithm polynomial response time notion fairness resource allocation data networks distributed resource allocation algorithms local fairness algorithm gigabit lansmans spatial reuse drinking philosophers problem hierarchical ordering sequential processes computers intractability algorithmic graph theory perfect graphs cellular packet communica tions bottleneck flow control polynomial time approximation algorithm dynamic storage allocation sandwich theorem hardness approximating minimization problems fast allocation nearby resources distributed system distributed scheduling algorithm fairness minimum delay matrix characterizations circulararc graphs tr ctr sanjoy k baruah shunshii lin pfair scheduling generalized pinwheel task systems ieee transactions computers v47 n7 p812816 july 1998 francesco lo presti joint congestion control routing media access control optimization via dual decomposition ad hoc wireless networks proceedings 8th acm international symposium modeling analysis simulation wireless mobile systems october 1013 2005 montral quebec canada sandy irani vitus leung scheduling conflicts bipartite interval graphs journal scheduling v6 n3 p287307 mayjune ami litman shiri moranschein distributed smooth scheduling proceedings seventeenth annual acm symposium parallelism algorithms architectures july 1820 2005 las vegas nevada usa tracy kimbrel baruch schieber maxim sviridenko minimizing migrations fair multiprocessor scheduling persistent tasks proceedings fifteenth annual acmsiam symposium discrete algorithms january 1114 2004 new orleans louisiana tracy kimbrel baruch schieber maxim sviridenko minimizing migrations fair multiprocessor scheduling persistent tasks journal scheduling v9 n4 p365379 august 2006 violeta gambiroza edward w knightly congestion control csmabased networks inconsistent channel state proceedings 2nd annual international workshop wireless internet p8es august 0205 2006 boston massachusetts
production systems negation failure study action rulebased systems two forms negation namely classical negation negation failure find course actions show several examples adding negation failure systems increases expressiveness sense real life problems represented natural simple way address problem providing formal declarative semantics extended systems adopting argumentationbased approach shown simple unifying framework understanding declarative semantics various nonmonotonic formalisms way naturally define grounded wellfounded stable preferred semantics production systems negation failure next characterize class stratified production systems enjoy properties mentioned semantics coincide negation failure find course actions computed simple bottomup operator stratified production systems implemented top conventional production systems two ways first way corresponds understanding stratification form priority assignment rules show implementation though sound complete general case hence propose second implementation means algorithm transforms finite stratified production system classical one sound complete implementation though computationally hard shown paper b sound complete implementation though computationally hard shown paper keywords rulebased systems knowledgebased systems rulebased process ing expert systems knowledge representation note paper revised extended version 9 1 introduction motivations section rst give examples motivate extension production systems paradigm 17 introduction negation failure nd course actions discuss role specication mechanism reactive systems 11 need negation failure production systems example 11 imagine situation person household work clothes washed person two options either hand washing machine washing machine powder house machine washing take place represented production rule machine powder house acquired either buying shop provided shops open borrowing neighbor rules acquiring powder represented following two classical production rules neighborin borrow course hand washing undesirable taken way acquire machine powder naive representation rule using classical negation clearly correct since meaning rule machine powder house current state clothes hand washed intuitive meaning way acquire machine pow der course actions starting current state leading acquiring machine powder hence state machine powder house neighbor naive representation would allow hand washing though way acquire machine powder borrowing neighbor hence fails capture intuitive understanding problem need use dierent kind negation called negation failure nd course actions denoted operator previous naive representation replaced powder handwash clearly ways representing situation use negation failure see next section argue however representation using negation failure provides better specication problem hand 2 dicult nd real life situations governed rules negation failure example 12 consider rules reviewing work faculties end academic year university rst rule species conditions oering tenure assistant professors states assistant professors good publications working experience least years oered tenure rule could formalized assistantprofx goodpubx workatleast5x oertenurex second rule states assistant professor prospect getting tenure though intuitive meaning rule clear possible represent classical production rule since premises classical production rule represent conditions must satised current state world premises second rule represent projection future says possibility assistant professor get tenure future sack words rule says assistant fail possible course actions future get tenure represent rule use negation failure nd course actions second rule represented follows assistantprofx gettingtenurex rex 2 real life often nd situations deal risky undesirable actions example doctor may take decision cutting foot patient due severe frostbite risky undesirable decision commonsense rule specifying conditions taking action doctor allowed cut way save foot patient represented using negation failure follows save cut finally expect real life intelligent systems could employed satisfy multiple goals goals dierent priorities negation failure nd course actions used represent priorities following example example 13 consider robot ghter sent save lives properties priority certainly saving lives rst imagine robot standing valuable artifact take get answer yes robot certain nothing save life rule represented follows artifactx indangerx humanfound savex note humanfound means human could found current possible states world reachable ring sequence actions robot enabled perform 2 12 negation failure specication mechanism reactive systems let us consider example 11 checking whether conditions rule powder handwash satised current state involves checking whether way acquire machine powder current state process could time consuming expensive concrete application example two ways get powder buying shop borrowing neighbor negation failure compiled classical negation produce ecient rule neighborin handwash however environment production system rule applied change example may get new neighbor may interest good relations peoples able borrow anything hence rule borrowing must dropped consequently production rule must revised clear rule r 4 negation failure still correct serves specication checking correctness new rule point want make many cases though negation failure employed directly could used specication mechanism classical production system situation encountered quite often many real life situations imagine work physician emergency case dealing patient severely injured road accident cases time crucial doctor would follow certain treatments taught apply situations less simply react depending physical conditions patient treatment may even suggest fateful decision operate patient cut organs clear treatment changes according progress medical science one treatment correct yesterday may wrong today decides correctness treatments think treatments simplied way set production rules telling doctors concrete state patient correctness rules determined commonsense principles like operate cut organ way save patient principle expressed using negation failure already pointed negation failure seen mechanism specify priorities dierent goals example robot reghter example 13 negation failure used give goal saving humans higher priority goal saving artifacts explicit priorities rules often used production systems active database systems 2 16 11 uence way rules executed systems whenever dierent rules triggered state rules higher priority triggered rst clearly notion priority negation failure induces dierent one used classical production active database systems former goals whether latter rules employed implement goals moreover often dicult understand declaratively rule higher priority another rule believe many cases negation failure used highlevel tool specify implicit priority goals could implemented dening explicit priorities rules 13 aim work seen examples using negation failure production systems allows one naturally correctly represent many real life problems main aim paper extended revised version 9 provide declarative semantics production systems two kinds negation used classical negation negation failure nd course actions respect show argumentation based approach 8 successfully adopted understand logic programming negation failure well many nonmonotonic formalisms also adopted provide natural simple declarative semantics production systems two kind negations basic idea negation failure literals powder example 11 represent assumptions underlying potential computations production system intuitive meaning assumption computation goes assuming course actions ie computation current state world leading state defeats assumption referring back example 11 assuming powder corresponds assuming current state course actions leading state machine powder house computation supported sequence assumptions plausible acceptable underlying assumptions cannot defeated actually nd course actions defeats informal intuitive notions formalized viewing production system argumentation system along lines 8 provides us many natural semantics grounded wellfounded preferred stable semantics 8 semantics arguably popular widely accepted semantics nonmonotonic commonsense reasoning literature 15 4 19 27 moreover address problem actually computing negation failure respect introduce class stratied production systems negation failure computed using simple bottomup operator case general stratied argumentation systems stratied production systems enjoy property previously mentioned semantics grounded preferred stable coincide show classical production systems explicit priorities rules used obtain straightforward sound implementation stratied production systems negation failure also show complete implementation requires sophisticated method compiling away negation failure even class stratied production systems method yields classical production systems complexity worst case polynomial number atoms occurring production system rest paper structured follows section 2 introduce basic notations terminologies use classical production rule systems section 3 extend production systems general production systems negation failure used condition part rules provide argumentation based semantics argumentation systems brie reviewed section 31 section 4 address problem computing negation failure introduce class stratied production systems semantics characterized simple bottomup operator section 5 discuss two ways implementing stratied production systems along lines mentioned finally section 6 address open issues future work preliminaries classical production rule systems introduce notations basic terminologies going use following production systems language use similar classical ones see eg 12 assume rst order language l representing ontology used describe domain interest state world interpreted snapshot world hence represented herbrand interpretation l ie set ground atoms l set states denoted stat assume set primitive actions given semantics eect actions described function eect production rule rule form ground literals l action conditions resp action rule r referred cond r resp actionr production system p set production rules production rule l said applicable state conditions l true ie denition 21 computations computation c production system p sequence 0 states r production rules p applicable 1 referred initialc n nal c 2 note computation empty computation denition 22 complete computations computation c called complete computation production rule p applicable n 2 behavior production system p dened set pairs states initial resp nal state complete computation p formalized next denition denition 23 inputoutput semantics production system p inputoutput semantics p dened nal c j c complete computation pg 2 even though considered ground production rules approach easily adopted production systems rules may contain variables given collection rules consider possible ground instances obtained replacing variables occurring ground term approach usually adopted study semantics logic programming 15 27 7 worth noting semantics ects inherent nondeterministic nature production systems indeed natural expect initial state may exist many dierent computations leading possibly dierent nal states means given might many different pairs io semantics nondeterminism arises naturally representation real life problems production rules referring back example 11 shops open neighbor two possible ways acquiring machine powder plausible ie buying shop borrowing neighbor clearly corresponding computations production system plausible intuitive reason prefer one need nondeterministic rule based languages pointed many authors see eg 1 indeed nondeterministic rule based languages mainly studied respect expressive power computational complexity opposed purely deterministic languages paper argue nondeterminism needed naturally represent real life problems work literature see eg 13 24 also devoted dene operational semantics classical production systems way nondeterminism avoided adopting ad hoc computational mechanism either implicitly explicitly assigns sort priority production rules red state lack intuitive motivation makes full understanding technical results dicult 3 production rules naf introduce new form negation language l denoted general literal either classical literal l nafliteral l l classical literal classical literal l intuition l possible nd course actions achieve l denition 31 general production rules general production rule form l ground general literal 2 given general production rule set classical literals r referred clcond r set nafliterals referred hypr general production system gps p set general production rules general production rule possibly applicable state denition 32 possible computations given gps p possible computation p sequence states r general production rules p 1 r possibly applicable 1 denote cp set possible computations gps p 2 given possible computation sequence hhypr 1 referred sequence hypotheses underlying computation basic idea understanding meaning nafconditions ls general production rules view hypotheses assumed possible course actions achieve l intuitively say rule applicable state possibly applicable hypotheses could assumed computation acceptable computation rules applicable whole problem understand formally mean possible course actions starting state achieve result l let us consider example 11 1 notice rule satisfying condition j clcondr state necessarily applicable since clear whether nafconditions satised example 33 let us rst recall production rules machinepowder handwash neighborin borrowpowder eects actions specied eecthandwash eectbuypowder eectborrowpowder assume initial state powder shops closed neighbor state represented interpretation state three possible nonempty computations starting namely r 4 fneighborin machinepowder clothescleang r 4 first notice c 2 c 3 based assumption commonsense dictate c 2 c 3 represent acceptable course actions initial state lead commonsense result clothes machine washed hence must accepted possible courses ac tions hand c 1 based assumption machinepowder meaning c 1 assumes possible way acquire machine powder however c 3 represents one possible way hence c 3 represents attack assumption machinepowder c 3 also viewed attack acceptability c 1 legitimate compu tation hand c 2 c 3 based assumption hence way attacked 2 example points semantics gpss form argumentation reasoning arguments represented possible computations following rst recall general notion argumentation systems 8 show natural semantics gps dened using theory argumentation 31 argumentation systems argumentation recognized lately important natural approach nonmonotonic reasoning 5 14 18 21 22 23 26 28 shown 8 many major nonmonotonic logics 20 19 25 represent fact dierent forms simple system argumentation reasoning based results 8 simple logicbased argumentation system developed 4 captures well known nonmonotonic logics like autoepistemic logics reiters default logics logic programming special cases 14 argumentation employed give proof procedure conditional logics argumentation also applied give elegant semantics reasoning specicity 10 review basic notions denitions argumentation systems reader refer 8 details discussion role argumentation systems many elds articial intelligence argumentation system pair har attacksi ar set possible arguments attacks arar representing attack relationship arguments pair b 2 attacks say attacks b b attacked moreover attacks set arguments h attacks argument b 2 h set h arguments con ictfree argument h attacks h argument defended set arguments h h attacks attack also say h defends defended h basic notion underlies semantics argumentation systems going review rest section following intuitive notion acceptability set arguments set h arguments acceptable con ictfree defend argument let h set arguments let def h set arguments defended h dicult see h acceptable h h con ictfree easy see monotonic hence equation least solution also acceptable following fact def acceptable h acceptable also h various semantics argumentation systems basically solutions equation particular grounded wellfounded semantics argumentation system least solution equation another semantics argumentation systems called preferred semantics dened maximal acceptable sets arguments dicult see sets maximal con ictfree solutions equation general preferred sets contain grounded semantics coincide next section give example finally popular semantics nonmonotonic reasoning argumentation systems stable semantics dened follows con ictfree set arguments h said stable attacks argument belonging dicult see stable set arguments acceptable furthermore also easy see stable set preferred hence maximal con ictfree solution equation vice versa 8 shown logic programming negation failure seen form argumentation systems view various semantics argumentation systems presented capture unifying framework various wellknown semantics logic programming negation failure instance grounded semantics corresponds wellfounded semantics logic programming 27 stable semantics corresponds stable semantics logic programming 15 following show general production systems two kinds negation also form argumentation systems philosophical explanation result seen fact computations production systems represent also form commonsense reasoning 32 computations arguments semantics gps p dened viewing argumentation framework set possible computations p relation attacks dened follows denition 34 attacks let c possible computation attack c possible computation c 0 initialc 0 exists underlying assumption l hypr i1 l holds nalc 0 2 remark 35 empty computations cannot attacked hence empty computations contained semantics 2 notice denition initial state attack c 0 defeats assumption l underlying c actual state assumption made words whether assumption l defeated depends state assumption made whether state lead computation state l holds referring back example 33 easy see c 3 attacks c 1 defeating assumption machinepowder c 1 based assumption made state 0 c 3 shows alternative course actions leading 0 state machinepowder actually holds consider initial state 0 among others fact machine powder house shops closed neighbor clear one possible computation apart empty one leading 0 0 nal state fclothescleang state represents fact clothes hand washed computation also based assumption machinepowder made state 0 0 hence cannot defeated powder cannot bought since shops closed neither borrowed since neighbor view gps argumentation system allows us provide three dierent semantics grounded wellfounded preferred stable se mantics recall given set h arguments ie possible computations h set arguments defended h see section 31 denition 36 let p gps k set possible computations k grounded k least solution equation k preferred k maximal con ictfree solution equation k stable k con ictfree attacks every possible computation klet us elaborate detail example 33 compute grounded semantics example 37 compute grounded semantics using use following abbreviations mp machinepowder ni neighborin cc clothesclean shopopen hw action handwash mw action machinewash bp action buypowder bop action borrowpowder hence rules example 33 become mp hw mentioned previous section grounded semantics least solution equation empty set arguments computations contains computations never attacked h 0 cannot defend computation clearly empty computations nonempty computations based assumptions let state following computations belong h 1 since hypr 3 hypr 2 empty similarly let ni state ni following computations r 4 belong h 1 let us move h us consider possible computations underlying assumptions computations must use rule r 1 rule containing nafliteral premises let 1 state 1 consider computation c form based assumption mp 1 computation form attacks computation since leads nal state mp holds belongs h 1 since h 1 con ict defend computation c similarly 1 cannot defend c conclude computations h 2 n h 1 computations form e 1 easy see h 2 indeed solution hence least solution equation case moreover dicult see example grounded preferred stable semantics coincide hence h 2 also stable preferred also consequence fact production system stratied sense section 4 show stratied production systems dierent semantics coincide 2 easy see following propositions hold proposition 38 computation c attacks computation c 0 c 0 prex c 00 c also attacks c 00 2 proposition 39 let h set computations either grounded preferred stable set c 2 h prex c also belongs h 2 give examples general production systems grounded preferred stable semantics coincide example 310 let p 0 following gps eect assertp state adding p let easy see nonempty possible computations starting 0 fbg underlying assumptions hfnot agi underlying assumptions hfnot ag fnot bgi fag underlying assumptions hfnot bgi underlying assumptions hfnot bg fnot agi empty computation starting fbg attacks c 0 1 empty computation starting fag attacks c 0 2 hand empty computation cannot attacked hence c 0 2 contained acceptable set computations furthermore also clear c 2 attacks c 1 since c 1 based assumption meaning way achieve starting 0 similar reasons c 1 also attacks c 2 hence computation starting 0 contained grounded semantics empty computation two stable sets computations one containing c 2 containing c 1 c 1 resp c 2 defend attacks example preferred stable semantics coincide notice rules similar r 1 r 2 may needed represent real world situations imagine situation team leader needs hire person important position two applications say mary ann leader asks advisors express opinion rst advisor likes ann hence says way hire ann hire mary expressed rule mary hired ann hired hiremary notice using negation failure capture intuition possible course actions hire ann imagine second advisor exactly opposite view ie opinion expressed mary hired hireann team leader reasoning represented two computations corresponds computations c 1 c 2 2 next example shows preferred sets may stable example 311 let p 1 following general production system intuition rule true current state way achieve add state clearly paradox since way achieve rule allows achieve nonempty possible computation starting fag clear c attacks hence example grounded preferred semantics coincide contain empty computations clearly stable set computations 2 dene set complete acceptable computations respect selected semantics denition 312 complete computations let p gps sem selected semantics p ie sem either grounded preferred stable set possible computations computation c 2 sem called semcomplete computation exists computation c 0 2 sem c prex c 0 2 semantics gps coincide simply talk complete computations instead semcomplete computations referring back example 33 complete computation starting 0 c 2 inputoutput semantics classical production systems extended general production systems respect selected grounded preferred stable semantics denition 313 inputoutput semantics gps let p gps grounded inputoutput semantics p dened nal c j c grounded complete computationg let sem set arguments preferred stable io sem p nal c j c semcomplete computation p g4 stratied production systems section consider special kinds gps actions two types assertp retractp p atom eect assertp resp retractp state adding resp removing p resp moreover rules following structure l classical literals rules rst kind called assert rules rules second kind called retract rules important distinguish assert retract rules simply write rule dene stratied gpss way negation failure computed bottomup following given classical literal l refer atom l l positive atom p l p denition 41 stratied production systems gps p stratied exists partition rules following conditions satised let rule p j l rule containing atom l head must belong pm ii l h rule containing atom l head must belong pm worth noting intuition underlying denition stratied gpss similar one underlying denition stratication logic programming 3 stratied gpss grounded preferred stable semantics coincide see theorem 43 moreover semantics computed bottomup way simple operator going dene next let c possible computation h k 0 h k n sequence called subcomputation c denote rulesc sequence denition 42 let stratied gps let operator dened follows subcomputation c 0 c c subcomputation c form l 2 hypr j computation lgroughly speaking operator formalizes intuition acceptability possible computation using rules p depends computations p thus semantics stratied gps p computed bottomup iterating operator strata p theorem 43 let p stratied gps unique preferred set computations unique stable set computationsproof see appendix implementing stratied ps section address issue implementing stratied ps translating stratied ps classical ps restrict production systems collection ground instances rules nite let us rst introduce notion implementation production system let two production systems say p 0 sound implementation p following two conditions hold computation c 0 p 0 exists computation c p nal c ii complete computation c 0 p 0 exists complete computation c p initialc 0 p 0 sound implementation p say also complete reverse conditions ii hold namely computation c p exists computation c 0 p 0 complete computation c p exists complete computation c 0 p 0 next section introduce class prioritized production systems pps rules dierent priorities dene accordingly suitable notion computation show viewing stratication priority assignment rules lower stratum higher priority yields sound implementation stratied gps pps however see means simple example implementations complete general case means priorities induced stratication powerful enough completely capture implicit priorities induced negation failure mechanism order obtain sound complete implementation need sophisticated method compiles away negation failure stratied gps yields classical production system priorities show classical ps obtained transformation indeed sound complete implementation original stratied ps however transformation worst case polynomial number atoms production system 51 implementing negation failure priorities let us introduce class pps namely classical production systems rules assigned dierent priorities type systems extensively studied literature 11 denition 51 prioritized production system pps pair hp p classical ps partial order relation rules 2 2 2 partial order irre exive transitive asymmetric relation sequel r r 0 say r higher priority r 0 notice classical ps pps empty relation priority relation rules aects applicability rules denition 52 let hp pps production rule l applicable state rule r 0 r r 0 applicable 2 notion computations pps one given denition 21 provided applicability rules understood previous denition example 53 let us formulate washing machine example 33 pps let us rst recall production rules neighborin borrowpowder notice negation failure rst rule replaced classical negation correctly represent fact hand washing lower priority machine washing add following priority relation rules way rule r 1 cannot applied states machine powder either shops open neighbor thus achieving desired behavior 2 p stratied gps idea view stratication implicit assignment priorities rules making assignment explicit allows us get rid negation failure translate directly classical negation need rst introduce useful notations let l naf literal denote l classical literal l l moreover given general production rule r denote r rule obtained replacing nafliteral l l denition 54 let stratied gps prioritized pps obtained replacing rule r p r dening follows following theorem shows given stratied gps p hp sound implementation theorem 55 let p stratied gps hp prioritized form sound implementation p ie computation c hp exists computation c 0 p ii complete computation c hp exists complete computation p nal c following example shows implementation given complete general case example 56 consider following stratication g consider following complete computation prioritized form p given following pps hp r r r r dened r 1 4 dicult see complete computation hp starting empty state ending state fa c dg due fact r 3 r 4 rule highest priority red r 1 since eect r 4 adding fdg state prevent r 1 applicable point naf literal b r 1 induces priority rules dierent naive one obtained given stratication indeed b intuitively means way achieve b given state classical conditions r 1 satised ensured enforcing c true ie making r 2 rule asserting b applicable obtained two ways either enforcing priority r 1 transforming r 1 following classical rule thus need deeper understanding stratication generalizing intuition sketched example allowed us compile away negation failure rule r 0 1 next section propose transformation given stratied gps p yields classical ps p 0 sound complete implementation p however order get complete implementation pay high price terms complexity transformation shown section 53 52 compiling away negation failure let us rst introduce notion incomplete state computations respect incomplete states denition 57 incomplete state consistent set ground literals l production rule l said applicable incomplete state conditions l true ie often necessary complete information state world carry computations indeed computation relies classical production rules following notion computation refer partial computation sucient denition 58 partial computation let incomplete states r production rules classical production system p sequence 0 partial computation c p 1 r applicable 1 retractpnotice computation also partial computation moreover partial computation c starting incomplete state viewed collection computations c 0 starting state j denition 59 let p classical ps incomplete state l ground literal say l achievable p partial computation c starting l 2 finalc 2 let us rst consider problem compiling away negation failure stratied ps two strata let r rule p 1 following form l 0 n collection incomplete states satised clcond r consistent l 0 achievable p 0 clcond r two cases j empty means exists classical computation p 0 starting clcond r leading state l 0 holds hence rule r never applied computation sp simply dropped j empty let r l 0 r empty set one j empty otherwise r l 0 r following r minimalg notice nonempty j viewed conjunction literals also minimality mean exists proper subset r implies j set r 2 r l 0 r set conditions satised state make l 0 achievable state set r l 0 r covers conditions formalized following lemma lemma 510 let state clcond r exists computation c cp 0 finalc proof denition r l 0 r clear l 0 achievable consistent clcondr clcond r clear condition satised computation c cp 0 suppose computation c cp 0 finalc assume exists incomplete state l 0 achievable consistent clcond r 6j n clcond r assumption j clcondr follows hence exists computation c cp 0 r 2 r l 0 r dene new production rule r r follows clcond r r hypr r actionr r dene example 511 machine wash example 37 translated following stratied ps g set incomplete states mp achievable hence hence pmp r 1 consists following rule production system clearly still stratied equivalent shown following results lemma 512 exists r r proof let us consider following assertion computation c 2 sp 0 holds consistent set literals l 0 achievable p 0 lemma 510 exists r 2 r l 0 r denition operator computation c 2 sp 0 8l computation c 2 sp 0 exists r 2 r l 0 r computation r r theorem 513 r h 0 r proof obvious taking r 0 procedure compiling away negation failure two strata production system following step 1 select r 2 p 1 l 2 hypr r exists stop step 2 else step 3 goto step 1 generalization procedure general case stratied production systems two strata obvious rst compile away naf p 1 obtain stratied production system continuing process eventually obtain classical production system coming back example 511 result applying transformation classical ps consisting rules original p 0 together new rule obvious new production system equivalent original one procedure assume p lr given dene method compute denition 514 set fi incomplete states called base l respect p 0 following conditions hold l achievable p incomplete state l achievable p 0 r 2 p 1 l 2 hypr easy see following lemma holds lemma 515 n base l respect p 0 j suppose j empty r constructing p lr consists computing base l respect p 0 computing r lr set r lr computed base applying standard methods propositional logic computing disjunctive normal forms following give algorithm computing base l constructing tree satisfying following properties node n tree labeled incomplete state labeln root tree labeled set flg link labeled rule r node node n child link labeled rule ancestor label labeln consistent actionr 0 labelm fpg clear construction node n ancestor label n leaf node hence since p 0 nite tree also nite clear construction tree exactly one tree satisfying conditions let us refer tree p 0 l example consider production system example 511 following tree fmpg f mp sog f mp nig theorem 516 node p 0 l g base l respect p 0 2 proof see appendix 53 complexity transformation section show compiling away naf general polynomial number atoms production system method given compile away naf literal l occurring rule r basically consists computing base l computing set r lr set r lr computed base applying standard methods propositional logic computing disjunctive normal forms show next computing set r lr polynomial taking account restricted class stratied production systems first consider sequel classical production systems rule following structure b positive atoms sequel rule form referred rule b given two atoms b say successor b denoted b occurs body rule b production system acyclic relation well founded ie decreasing sequence nite give acyclic production system dene rank atom denoted kak follows ag let stratied production system contains exactly one rule r p l assertp p 0 classical production system satisfying following conditions c2 rule p 0 following structure c3 atom either appears head exactly two rules appears head rule positive atom either occurs body exactly one rule occur body rule atom either atom exists decreasing sequence l atom occurring naf literal rule r notice condition c5 implies atoms b c b c also atom either successors exactly four successors due conditions c2 c3 want show number rules obtained compiling away naf literal rule r polynomial number atoms p 0 amounts proving cardinality set r lr polynomial number atoms p 0 recall set r lr computed base l applying standard methods propositional logic computing disjunctive normal forms let atom partial state satisfying following conditions achievable state satisfying ii minimal ie proper subset satises let also r set partial states satisfying conditions ii obviously r lr l sequel show cardinality r l polynomial number atoms p 0 first let us generalize denition r l conjunction atoms given conjunction set partial states satisfying following conditions achievable state satisfying iv minimal ie proper subset satises iii consider conjunction distinct atoms ka 1 let partial state r a1 n syntactic restrictions clear 2 r moreover clear r r j 6 j disjoint sets cardinality r previous observations clear cardinality r consider atom b kbk 0 p 0 contains exactly two rules b consider partial state 2 r b syntactic restrictions p 0 minimality clear split two disjoint sets 0 00 0 2 r 1 2 00 2 r 3 4 recall b c b p 4 set rules p 0 rules rules atom c c structure p 0 fact clear p p j 6 j equal renaming atoms hence also clear sets r r j equal renaming atoms let cardinality r 4 previous arguments obvious cardinality r 1 2 r 3 4 2 hence cardinality r let seen cardinality r b given inductively furthermore obvious since atom occur head rule hence fag set r easy show induction relation fk dened unique solution let us go back rule p 1 r p l assertp k dicult see due syntactic restrictions number n atoms occurring p 0 exactly 1from easily calculate ie ie hence dene cardinality r l function gn follows let 2 4 easy see constants c suciently big x 4 x x 2c hence constant c suciently conclude gn polynomial n number atoms p 0 hence worst case complexity translating away naf polynomial number atoms 6 discussion conclusions production systems negation failure nd course actions natural extension classical production systems increases expressiveness sense allow natural simple representation specication many real life problems extension given simple semantics based argumentation theoretic framework negation failure nd course actions tightly related negation failure prove logic programming indeed normal logic program p viewed gps g p transforming rule production rule k asserta dicult show semantics p g p coincide sense grounded preferred stable set computations g p corresponds grounded preferred stable model p side 8 shown argumentation represented logic programming negation failure therefore say mechanisms negation failure nd course actions production systems negation failure prove logic programming dierent sides coin still several issues deserve deeper study understanding first seen semantics ects inherent nondeterminism production systems fact semantics dierent complete computations starting initial state yield dierent nal states even stratied gpss contrasts many eorts literature aiming nding method select one complete computations expected semantics 13 24 even though believe many cases eorts contrast inherent nondeterministic nature problems represented production rules situations selecting one possibly many complete computations may harm cases worth studying computational strategies basically provide us deterministic operational semantics production systems still declarative semantics serves basis reasoning correctness methods secondly intend study computational mechanisms proof procedures general production systems negation failure seen stratied production systems way compute negation failure bottomup fashion seen dynamic runtime method compute negation failure worth addressing point whether class stratied ps extended general classes similar bottomup methods exist hand cases negation failure compiled classical negation seen section 12 seen compiletime static method compute negation failure finding general techniques achieve another interesting issue already mentioned case negation failure still serves specication classical ie without naf production systems finally investigating application approach active databases area active databases 6 important research topic database community due fact nd many applications real world problems many commercial databases systems extended allow user express active rules still active databases faced many open issues lack well understood declarative semantics see eg 11 29 semantics would provide common basis understanding operational semantics dened implementation active rules database systems well comparing dierent implementations typical active rule active databases eventconditionaction rule form event condition action currently extending argumentation based approach active rules addressing also case use negation failure condition part rules r static analysis techniques predicting behavior active database rules towards theory declarative knowledge abstract preferred answer sets extended logic programs active database systems triggers rules advanced database processing negation hypotheses abductive foundation logic programming acceptability arguments fundamental role logic programming production systems need negation failure reasoning speci active database systems ops5 users manual logic action rulebased systems stable model semantics logic pro gramming overview production rules database systems rule based systems computing argumentation logic programming semantical considerations nonmonotonic logics defeasible reasoning system defeasible argumentation logical systems defeasible argumen tation semantics class strati logic default reasoning mathematical treatment defeasible reasoning implementation unfounded sets wellfounded semantics general logic programs feasibility defeat defeasible reasoning active database rules transactionconscious stablemodel semantics tr
making graphs reducible controlled node splitting several compiler optimizations data flow analysis exploitation instructionlevel parallelism ilp loop transformations memory disambiguation require programs reducible control flow graphs however programs satisfy property new method transforming irreducible control flow graphs reducible control flow graphs called controlled node splitting cns presented cns duplicates nodes control flow graph obtain reducible control flow graphs cns results minimum number splits minimum number duplicates since computation time find optimal split sequence large heuristic developed results heuristic close optimum straightforward application node splitting resulted average code size increase 235 per procedure benchmark programs cns heuristic limits increase 3 impact total code size complete programs 136 straightforward application node splitting however cns used heuristic average growth code size complete program dramatically reduces 02 b introduction current computer architectures improvements obtained exploitation instruction level parallelism ilp ilp made possible due higher transistor densities allows duplication function units data paths exploitation ilp consists mapping ilp application onto ilp target architecture efficient possible mapping used long instruction word vliw superscalar architectures latter used workstations architectures may execute multiple operations per cycle efficient usage requires compiler fills instructions operations efficient possible process called scheduling problem statement order find sufficient ilp justify cost multiple function units data paths scheduler larger scope single basic block time basic block sequence consecutive statements flow control enters beginning leaves always end several scheduling scopes found go beyond basic block level 1 general scope currently used called region 2 set basic blocks corresponds body natural loop since loops nested regions also nested like natural loops regions single entry point loop header may multiple exits 2 1 speedup 40 reported extending scheduling scope region problem region scheduling requires loops control flow graph single entry point flow graphs called reducible flow graphs fortunately control flow graphs reducible nevertheless problem irreducible flow graphs cannot ignored exploit benefits region scheduling irreducible control flow graphs converted reducible control flow graphs exploiting ilp also requires efficient memory disambiguation accomplish nesting loops must determined since irreducible flow graph nesting loops clear memory disambiguation techniques cannot directly applied loops exploit benefits memory disambiguation irreducible control flow graphs converted reducible control flow graphs well another pleasant property reducible control flow graphs fact data flow analysis essential part compiler done efficiently 3 related work problem converting irreducible flow graphs reducible flow graphs tackled frontend backend compiler 4 5 methods normalizing control flow graph program frontend given methods rewrite intermediate program normalized form normalization irreducible flow graphs converted reducible ones make graph reducible code duplicated results larger code size since frontend unaware precise number machine instructions needed translate piece code difficult minimize growth code size another approach convert irreducible flow graphs backend advantage selecting machinecode duplicate one take resulting code size account solutions solving problem backend given 6 7 8 9 solution given cocke miller 6 9 time complex try minimize resulting code size method described hecht et al 7 8 even inefficient sense minimizing code size requires less analysis paper new method converting irreducible flow graphs backend given efficient terms resulting code size paper overview section 2 reducible irreducible flow graphs defined method detection irreducible flow graphs discussed principle node splitting conversion method described hecht et al straightforward application node splitting given section 3 approach controlled node splitting cns described section 4 known conversion methods convert irreducible flow graphs without minimizing number copies controlled node splitting possible minimize number copies unfortunately method requires much cpu time therefore developed heuristic reduces cpu time still performs close optimum heuristic algorithms controlled node splitting presented results applying cns several benchmarks given section 5 finally conclusions given section 6 irreducible flow graphs control flow program described control flow graph control flow graph consists nodes edges nodes represent sequence operations basic block edges represent flow control definition 21 control flow graph program triple n e finite directed graph n collection nodes e collection edges initial node 2 n path every node graph figure 1 shows example control flow graph nodes initial node c e f c e f b figure 1 reducible control flow graph b graph stated introduction finding sufficient ilp requires input reducible flow graph many definitions reducible flow graphs proposed one adopt given 8 based partitioning edges control flow graph g two disjoint sets 1 set back edges consist edges whose heads dominate tails 2 set forward edges fe consists edges back edges thus node u flow graph dominates node v every path initial node flow graph v goes u dominance relations figure 1 node dominates nodes node dominates nodes except node node c dominates nodes c e f node dominates nodes e f therefore fg definition reducible flow graph definition 22 flow graph g reducible flow graph acyclic every node n 2 n reached initial node control flow graph figure 1 reducible since acyclic flow graph figure 2 however irreducible set back edges empty neither node node b dominates fe equal fs acyclic definition 22 derive control flow graph g irreducible graph contains least one loop loops called irreducible loops remove irreducible loops must b figure 2 basic irreducible control flow graph detected first several methods one use interval analysis 10 11 method used hechtullman t1t2 analysis 12 3 method based two transformations t2 transformations illustrated figure 3 defined definition 23 let control flow graph let u 2 n removes edge u u 2 e selfloop edge exists derived graph becomes g short g 1u t1u u figure 3 definition 24 let control flow graph let node v 6 single predecessor u transformation consumption node v node u successor edges node v become successor edges node u original successor edges node u preserved except edge node v set successor nodes v derived graph g short g 2v definition 25 graph results repeatedly applying transformations possible order flow graph flow graph results application t1 t2 possible called limit flow graph transformation denoted 7 proven limit flow graph unique independent order transformations applied theorem 26 flow graph reducible repeatedly applying transformations particular order flow graph reduced single node proof theorem found 12 example application transformations given figure 4 flow graph figure 1 reduced single node conclude flow graph reducible f c c t2c t2a t1a c e f e c f t2d t2e c f e f c t1c figure 4 example application applying transformations resulting flow graph consists multiple nodes graph irre ducible transformations t1 t2 detect irreducibility also detect nodes causes irreducibility examples irreducible graphs given figure 5 theorem 26 follows alternatively define irreducibility corollary 27 flow graph irreducible limit flow graph single node 1 another definition intuitive flow graph irreducible least one loop multiple loop entries 12 b c b c b c b c figure 5 examples extensions basic irreducible control flow graph figure 2 3 flow graph transformation control flow graph occurs irreducible graph transformation technique used obtain reducible control flow graph past methods given solve problem 6 7 8 methods converting irreducible control flow graph based technique called node splitting section 31 technique reduce irreducible flow graph described section 32 shows node splitting applied straightforwardly reduce irreducible graph 31 node splitting node splitting technique converts graph g 1 equivalent graph g 2 assign label node graph label node x denoted label duplication node creates new node label equivalence relation two flow graphs derived hecht 7 given definition 31 path flow graph define labelsp sequence labels corresponding path labelsp two flow graphs g 1 g 2 equivalent path p g 1 path q g 2 labelsp conversely according definition two flow graphs figure 6 equivalent note nodes labela node splitting defined 32 node splitting transformation graph g graph g node n 2 n multiple predecessors p split incoming edge p n duplicate n n made one incoming edge p outgoing edges n n 0 defined n successor node n transformation denoted g 1 splitting node n 2 n principle node splitting illustrated figure 6 node graph g 1 split note node n split limit graph corresponding node n original graph must split remove irreducibility theorem 33 equivalence relation two graphs preserved transformation g 1 b b sa figure simple example applying node splitting node proof show node splitting transforms graph g 1 equivalent split graph g 2 assume graph g 1 node v n1 predecessors u 0 successors w k shown figure 7a set labelsp paths p graph g denoted labels g label notation paths graph g 1 figure 7a described k0 flabel label v label w k g b figure 7 two equivalent graphs node splitting b node splitting node v split n copies named v split graph g 2 results set paths graph g 2 k0 flabel label v graph given figure 7b since label v label v every path g 2 exists also g 1 conversely leads conclusion graphs g 1 g 2 equivalent since figure 7 split node arbitrary number incoming outgoing edges may general conclude splitting node graph results equivalent graph using reasoning clear equivalence relation transitive splitting finite number nodes either original graph equivalent graphs results graph equivalent original graph 2 name node splitting deceptive suggests node split different parts fact node duplicated 32 uncontrolled node splitting node splitting transformation technique used convert irreducible control flow graph reducible control flow graph hecht 7 adopt theorem 34 theorem 34 let denote splitting node let denote graph reduction transformation eg control flow graph transformed single node transformation represented regular expression st proof theorem given 7 hecht et al describe straightforward application node splitting reduce irreducible control flow graphs method selects node splitting limit graph node multiple predecessors selected node split several identical copies one entering edge approach advantage rather simple disadvantage select nodes split make graph reducible figure 8a see nodes b c candidate nodes splitting figure 8b node split number nodes reduces application two t2 transformations graph still irreducible splitting node neither makes graph reducible see figure 8c splitting node b c converts graph reducible control flow graph see figure 8d although method inefficient node splitting transform irreducible control flow graph eventually reducible one consequence inefficient node splitting number duplications becomes unnecessarily large 4 presentation controlled node splitting problem existing methods resulting code size converting irreducible graph grow uncontrolled controlled node splitting cns controls amount copies results smaller growth code size cns restricts set candidate nodes splitting first introduce necessary terminology definition 41 loop flow graph path n immediate successor n k set nodes contained loop called loopset figure 8a fa bg fb cg fa b cg loopsets definition 42 immediate dominator node u idu last dominator path initial node graph u excluding node u b c original irreducible graph b splitting node c splitting node splitting node b figure 8 examples node splitting figure 1 node dominates nodes b c e f immediate dominates nodes b c definition 43 shared external dominator set sedset subset loopset l properties elements share immediate dominator immediate dominator part loopset l sedset loopset l defined definition 44 maximal shared external dominator set msedset k defined sedset k maximal 6 9 sedset k ae definition says msedset cannot proper subset another sedset figure 5a multiple sedsets identified like fa bg fb cg fa b cg one msedset fa b cg definition 45 nodes sedset flow graph classified three sets ffl common nodes cn nodes dominate sedsets reachable sedsets dominate ffl reachable common nodes rc nodes dominate sedsets reachable sed dominate ffl normal nodes nn nodes sedset classified one classes nodes dominate sedsets initial graph figure 9a identify msedsets fa bg c dg nodes c elements set nn node b element set rc edge c b present node b would element set cn note loop b c sedset theorem 46 sedsetl one node corresponding loop l single header reducible proof theorem derived 7 example sedset one node graph figure 4 transformation section 41 description cns given treats method minimizing number nodes split section 42 gives method minimizing amount copies number copies equal number splits split creates every entering edge copy node n entering edges one split creates copies speed process minimizing amount copies heuristic given algorithms implementing heuristic given section 43 41 controlled node splitting nodes irreducible limit graph except initial node graph possible candidates node splitting since least two predecessors however splitting nodes efficient see section 32 cns minimizes number splits accomplish two restrictions made set candidate nodes restrictions 1 nodes elements sedset candidates splitting 2 nodes elements rc candidates splitting first restriction prevents splitting nodes sedset splitting node inefficient unnecessary example split shown figure figure 8b sedset figure 8b fb cg second restriction complicated impact restriction illustrated figure 9 figure shows two different sequences node splitting initial graph figure graph applied figure 9a three splits needed figure 9b two figure 9a node b split node however element set rc second restriction prevents splitting sequence one figure 9a node splitting restrictions alternated eventually result single node seen easily every time node element sedset split reduced transformation number nodes involved sedsets decreases one since considering flow graphs finite number nodes single node eventually remains b c c node splitting sequence three nodes b node splitting sequence two nodes c b c b figure 9 graph two different split graphs theorem 47 minimum number splits needed reduce msedset k nodes given proof every time node split applied number nodes msedset decreases one every predecessor node split duplicate made means every duplicate one predecessor duplicates reduced t2 transformation results msedset one node less original msedset reduce complete msedset nodes one msedset must split one node left results k1 splits 2 theorem 48 minimum number splits needed convert irreducible graph n msedsets reducible graph given splits total number splits k number nodes msedset proof proof consists multiple parts first related lemmas proven lemma 49 msedsets disjoint two msedsets share node proof node shared two msedsets node must two different immediate domina tors conflicts however definition immediate dominator given 42 2 since msedsets disjoint number splits individual msedsets added however splitting nodes results merging msedsets result hold anymore therefore prove cns merge msedsets merging msedsets lead less splits lemma 410 splitting node part msedset rc result merging msedsets proof first shall prove splitting node element rc merges msedsets afterwards prove splitting nodes elements cn nn merge msedsets splitting rc node merges two msedsets consider graph figure 10 suppose subgraphs g 1 g 2 msedsets nodes subgraphs form joined loop possible x figure 10 merging two msedsets go g 1 g 2 viceversa reason subgraphs form single msedset fact different immediate dominators splitting node rc case node x applying complete graph immediate dominator subgraph g 1 becomes also immediate dominator subgraph g 2 since subgraphs add single loop share immediate dominator msedsets merged holds also general case x dominates reachable n msedsets splitting nodes rc merge msedsets two types nodes left candidates splitting nodes sets nn cn splitting nodes element set nn merge msedsets nodes edges go msedsets therefore splitting nodes affect edges one msedset another therefore splitting never result merging msedsets splitting nodes element set cn merge msedsets nodes form loop msedset dominates splitting node nodes msedsets get immediate dominator loop msedsets therefore merged lemma 411 reducing two merged msedsets results splits reduce graph reducing msedsets separately proof suppose sedset 1 consists x nodes sedset 2 nodes merging costs one split since rc node must split reducing resulting sedset x splits total number splits x gamma 1y reducing two sedsets separately results splits one split less splits needed merging sedsets 2 combination lemmas 410 411 justifies restriction prevent splitting nodes elements rc lemma 412 exists always node irreducible graph part msedset element rc proof nodes msedsets elements rc nodes must dominate least two nodes node cannot dominate dominators nodes also elements msedset rc graph therefore must infinite number nodes since considering graphs finite number nodes must node part msedset element since msedsets disjoint algorithm always find node split without merging msed sets result equation 1 holds 2 example 413 figure 9 msedsets fa bg fc dg identified two nodes results minimal number splits needed reduce graph 42 minimizing amount copies previous section saw algorithm minimizes number splits result minimum number copied instructions basic blocks following quantity minimize denoted q q n means quantity node n qg quantity graph g defined purpose cns minimize qg g transformation g single node using sequence splits formally q g two conditions must satisfied achieve minimum 1 freedom selecting nodes split must big possible notice number splits also minimized prevent splitting nodes dominate another msedset prevent splitting nodes elements rc cn disadvantage lose freedom selecting nodes loss freedom illustrated figure 11 suppose nodes contain number b c figure 11 graph common node set rc instructions want minimize total resulting code size means would like copy less instructions possible number copied instructions prevent splitting nodes elements rc cn q prevent splitting nodes element rc number copied instructions min q number instructions node b less node number copied instructions less latter case thus keeping set candidate nodes big possible pays one would like minimize amount copies 2 sequence splitting nodes must chosen optimal exists multiple split sequences solve irreducible graph tree build discover figure 12 shows flow graph tree possible split sequences nodes tree indicate many copies introduced split b c 2b c c ba cb ab c bc figure 12 irreducible graph copy tree edges give split sequence number copies found following path root leaf adding quantities nodes suppose nodes contain number instructions want minimize total resulting code size means would like copy less instructions possible choose 6 different split sequences 5 different numbers copies minimum number copied instructions minq problem pick split sequence minimizes number copied instructions theorem 414 minimizing resulting qg irreducible graph converted reducible graph requires minimum number splits g single node totally reduced graph short splits produce g minimal proof suppose nodes limit flow graph except initial node candidates splitting nodes msedset nodes elements rc also candidates splitting node one categories results number splits greater minimal number splits prove splitting nodes always result qg greater one obtain exclude nodes proven minimum number splits required order minimize qg ffl splitting node msedset cannot result minimum qg seen previous section splitting nodes msedset make graph reducible since splitting nodes decrease number nodes msedset means msedset still needs number splits ffl splitting nodes element rc cannot result minimum qg g sag ag g sa ga saga sa ga splitting nodes set rc b splitting node set rc figure 13 influence number copies splitting rc node consider graph figure 13 figure subgraph g least one msedset otherwise graph would irreducible figure 13a shows reduction graph case splitting rc node allowed 13b splitting node allowed node g reduced subgraph g notation sa node means node consumed copy node resulting quantity node sum quantities nodes see resulting total quantity split sequence figure 13a qsqaqg resulting total quantity reduced graph figure 13b qs2qaqg without loss generality conclude splitting node rc never lead minimum total quantity 2 one easily see nodes msedsets larger tree number possible split sequences increases takes much computation time compute possibilities therefore heuristic constructed picks node n split smallest h n defined results heuristic compared best possible split sequence given section 5 43 algorithms method described previous sections detects irreducible control flow graph converts reducible control flow graph section algorithm method given algorithm consists three parts 1 t1 t2 transformations 2 selection candidate node 3 splitting node algorithm 41 controlled node splitting input control flow graph procedure reducible control flow graph procedure 1 copy flow graph basic blocks flow graph g nodes 2 apply repeatedly t1t2 transformations g 3 g one node selection 5 split candidate node apply repeatedly t1t2 transformations g algorithm 41 expects input control flow graph basic blocks structure flow graph copied flow graph nodes 1 two different flow graphs flow graph basic blocks flow graph nodes means initially every node represents basic block every duplicate introduced splitting flow graph nodes also performed flow graph basic blocks graph copied t2 transformations applied till graph nodes change 2 graph nodes reduced single node graph reducible splitting needed however remain multiple nodes node splitting must applied first node splitting selected 4 done algorithm 42 discussed later selected node split 5 defined definition 32 graph basic blocks corresponding basic blocks copied also splitting t1 t2 transformations applied graph nodes 6 still one node left process start algorithm terminates graph nodes reduced single node thus graph basic blocks converted reducible flow graph algorithms transformations node splitting quite straightforward given algorithm 42 selects node splitting initially every node candidate node rejected candidate fulfill restrictions 3 discussed subsection 41 nodes fulfill restrictions heuristic calculated 4 equation 1 node smallest heuristic selected splitting goal experiments measure quality controlled node splitting sense minimizing amount copies experiments four methods node splitting used optimal node splitting ons method computes best possible node split sequence respect quantity minimize number basic blocks number instructions algorithm however algorithm 42 node selection input control flow graph nodes node splitting 2 nodes n 3 n sedset n rc calculate value hn return candidate node requires lot computation time several days hp735 workstation uncontrolled node splitting ucns straightforward application node splitting restrictions made set nodes candidate splitting controlled node splitting cns node splitting restrictions discussed section 41 controlled node splitting heuristic cnsh method cns heuristic used select node set candidate nodes algorithms applied selective group benchmarks benchmarks procedures irreducible control flow graph obtained real world programs a68 bison expand gawk gs gzip sed tr programs compiled gcc compiler ported risc architecture 2 amount copies two different quantities considered table 1 number copies basic blocks listed table 2 number copied instructions reported results methods ucns cns cnsh averages possible split sequences first column tables 1 2 lists procedure name program name parentheses second column gives number basic blocks instructions procedure algorithm applied columns give number copies result algorithms absolute number copies given percentage indicates growth quantity respect original quantity given results ons method conclude node splitting lead excessive number copies furthermore conclude cns outperforms ucns ucns lead enormous amount copies average percentage growth basic blocks 2417 code size 2355 cns performs better growth 262 basic blocks 301 number instruction still big gap optimal case using heuristic controlled node splitting performs close optimum average growth basic blocks methods cnsh ons respectively 31 30 growth used risc like move architecture move project 13 1 researches generation application specific processors asps means transport triggered architectures tta table 1 number copied basic blocks atof output programbison 14 2 14 97 69 97 69 20 14 copy definitionbison 119 2 2 4170 350 277 23 20 2 copy guardbison 190 4 2 22735 1197 1334 70 40 2 copy actionbison next fileexpand 17 1 6 50 29 50 29 10 6 compile patterngawk 787 1 0 12027 153 475 6 10 0 gs copy blockgzip 17 2 12 25 15 25 15 20 12 compile programsed 145 1 1 801 55 600 41 10 1 search 2sed 486 20 4 13287 273 500 10 210 4 squeeze filtertr 33 8 2 163 49 155 47 80 24 total 2692 82 30 65053 2417 7041 262 83 31 code size methods 29 comparing results ons cnsh lead conclusion cnsh performs close optimum experiments one procedure small difference results tables 1 2 show substantial improvement using cnsh question impact code expansion using simple method like ucns code size complete program impact small bother except theoretical aspects tables 3 4 effects complete code expansion shown procedures benchmarks irreducible control flow graph converted procedures reducible control flow graph table 3 show impact basic blocks table 4 impact code size listed first column tables lists program name second column list total number basic blocks instructions remaining columns list increase basic blocks instructions method seen tables impact node splitting substantial terms number basic blocks instructions see ucns average increase basic blocks 154 instructions 136 using ucns even result code size increase 80 program bison using controlled node splitting increases smaller quite acceptable cnsh results expected smallest increases quantities results show importance clever transformation irreducible control flow graphs 6 conclusions method given transforms irreducible control flow graph reducible control flow graph gives us opportunity exploit ilp larger scope single basic block program method based node splitting achieve minimum number splits set possible candidate nodes limited nodes specific properties since splitting nodes result minimum resulting code size algorithm used prevent uncontrolled growth code size computation time determine optimum split sequence large heuristic developed table 2 number copied instructions instructions ons ucns cns cnsh atof output programbison 59 9 15 415 70 415 70 90 15 copy copy guardbison 880 copy actionbison 858 9 1 29614 345 1225 14 90 1 next fileexpand compile patterngawk 2746 1 0 41069 150 2185 8 10 0 gs lzwd read bufgs 228 62 27 950 42 950 42 620 27 copy blockgzip 88 4 5 75 9 75 9 40 5 compile programsed 693 2 0 3914 56 2675 39 20 0 search 2sed 1857 91 5 48037 259 2275 12 930 5 squeeze filtertr 119 22 18 570 48 555 47 220 18 total 11588 335 29 272917 2355 34841 301 337 29 method heuristic called controlled node splitting heuristic method applied set procedures contain irreducible control flow graphs results compared results methods methods uncontrolled node splitting controlled node splitting experiments follows uncontrolled node splitting lead enormous number copies average growth code size per procedure 2355 controlled node splitting performs better 301 still big gap optimal case observed average number copies using controlled node splitting heuristic close optimum average growth code size per procedure methods 29 also looked impact total code size benchmarks containing procedures irreducible control flow graphs methods used analysis per procedure used cnsh impact total code size small 02 average impact ucns however surprisingly large average code size growth 136 maximum bison 80 table 3 increase basic blocks per program program basic blocks ons ucns cns cnsh bison 4441 14 0 35017 79 2228 5 140 0 expand 1226 1 0 50 0 50 0 10 0 gs 16514 sed 3823 21 1 14088 37 1100 3 220 1 tr 1554 8 1 163 1 155 1 80 1 total 43116 108 03 66312 154 7541 17 1090 03 table 4 increase instructions per program instructions ons ucns cns cnsh bison 19689 63 0 158584 80 9838 5 630 0 expand gs 85824 210 0 21697 3 18041 2 2100 0 sed 17489 93 1 51951 30 4950 3 950 1 tr total 205073 452 02 278840 136 36954 18 4540 02 r global instruction scheduling superscalar machines elimination algorithms data flow analysis taming control flow structured approach eliminating goto statements controlflow normalization algorithm complexity analysis techniques optimizing computer programs flow analysis computer programs certain graphtheoretic properties programs basis program optimization program data flow analysis procedure flow graph reducibility tr compilers principles techniques tools elimination algorithms data flow analysis global instruction scheduling superscalar machines controlflow normalization algorithm complexity elimination algorithm bidirectional data flow problems using edge placement new framework exhaustive incremental data flow analysis using dj graphs loops using dj graphs fast usually linear algorithm global flow analysis fast algorithms solving path problems program data flow analysis procedure microprocessor architectures flow analysis computer programs transporttriggering versus operationtriggering ctr hansaem yun jihong kim soomook moon time optimal software pipelining loops control flows international journal parallel programming v31 n5 p339391 october sebastian unger frank mueller handling irreducible loops optimized node splitting versus djgraphs acm transactions programming languages systems toplas v24 n4 p299333 july 2002 fubo zhang erik h dhollander using hammock graphs structure programs ieee transactions software engineering v30 n4 p231245 april 2004 reinhard von hanxleden ken kennedy balanced code placement framework acm transactions programming languages systems toplas v22 n5 p816860 sept 2000
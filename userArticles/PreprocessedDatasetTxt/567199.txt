sparse evaluation representations sparse evaluation graph emerged past several years intermediate representation captures dataflow information program compactly helps perform dataflow analysis efficiently contributions paper threefold present linear time algorithm constructing variant sparse evaluation graph dataflow analysis problem algorithm two advantages previous algorithms constructing sparse evaluation graphs first simpler understand implement second algorithm generates compact representation one generated previous algorithms algorithm also efficient efficient known algorithm problem present formal definition equivalent flow graph attempts capture goals sparse evaluation present quadratic algorithm constructing equivalent flow graph consisting minimum number vertices possible show problem constructing equivalent flow graph consisting minimum number vertices edges nphard generalize notion equivalent flow graph partially equivalent flow graph even compact representation utilizing fact dataflow solution required every node controlflow graph also present efficient linear time algorithm constructing partially equivalent flow graph copyright 2002 elsevier science bv b introduction technique sparse evaluation emerged past several years efficient way performing program analysis sparse evaluation based simple observation given analysis problem number statements given program may irrelevant respect analysis problem simple example consider version pointer analysis problem eg see 13 1 goal identify relations may exist pointervalued variables assignment integervalued variable 10 typically irrelevant problem may ignored goal sparse evaluation simply construct smaller program whose analysis sufficient produce results original program enables analysis run faster also reduces space required perform analysis complex analyses like pointer analysis space often bottleneck sparse evaluation make difference able complete analysis idea sparse evaluation born context work done static single assignment 5 6 showed ssa form could help solve various analysis problems constant propagation redundancy elimination efficiently choi et al 2 generalized idea showed could used arbitrary dataflow analysis problem expressed kildalls framework 12 idea fact applicable analysis problems expressed various different frameworks generally problem computing extremal fixed points collection equations certain form however sake concreteness also deal analysis problems expressed kildalls framework context kildalls framework interested solving dataflow analysis problem controlflow graph g idea behind sparse evaluation construct smaller graph h refer equivalent flow graph whose dataflow solution solution original graph g trivially recovered detailed discussions equivalent flow graphs use found 2 11 16 choi et al 2 define particular equivalent flow graph called sparse evaluation graph seg present algorithm constructing johnson et al 11 10 define different equivalent flow graph called preliminary version paper appeared proceedings fourth international static analysis symposium volume 1302 lecture notes incomputer science pages 115 quick propagation graph qpg present linear time algorithm constructing general quick propagation graph compact sparse evaluation graph cytron ferrante 4 sreedhar gao 16 pingali bilardi 14 15 improve upon efficiency original choi et al algorithm constructing sparse evaluation graph duesterwald et al 8 show congruence partitioning technique used construct equivalent flow graph believe standard sparse evaluation graph pingalibilardi algorithm sreedhargao algorithm linear best worstcase complexity among various algorithms constructing sparse evaluation graph contributions paper follows ffl define new equivalent flow graph compact evaluation graph ceg present linear time algorithm constructing compact evaluation graph monotonic dataflow analysis problem algorithm two advantages previous algorithms simplicity algorithm particularly simple understand implement conceptually simple based two graph transformations whose correctness transparently ob vious implementation terms simplicity derives fact require computation dominator tree utilizes wellknown strongly connected components algorithm topological sort algorithm compactness general compact evaluation graph smaller sparse evaluation graph quick propagation graph particular show seg qpg also principle generated utilizing two graph transformations mentioned however compact evaluation graph normal form respect trans formations seg qpg necessarily since transformations make graph smaller since transformations churchrosser follows compact evaluation graph least small seg qpg ffl reasonable definition equivalent flow graph present quadratic algorithm constructing equivalent flow graph consisting minimum number vertices also show problem constructing equivalent flow graph consisting minimum number vertices edges nphard ffl show utilize fact dataflow solution required every node controlflow graph construct even compact representation call partially equivalent flow graph present efficient algorithm also based simple graph transformations produce partially equivalent flow graph rest paper organized follows section 2 presents notation terminology use section 3 describes compact evaluation graph algorithm constructing section 4 discusses graph transformations used construct compact evaluation graph section 5 compares compact evaluation graph previously proposed equivalent flow graphs section 6 presents results concerning equivalent flow graphs minimum size section 7 introduces concept partially equivalent flow graph presents algorithm constructing one section 8 briefly discusses concepts apply case interprocedural analysis section 9 presents comparison work previous work presents conclusions notation terminology dataflow analysis problems come various different flavors many differences cosmetic paper focus forward dataflow analysis problems results applicable backward dataflow analysis problems well also assume transfer functions associated vertices controlflow graph rather edges interested identifying dataflow solution holds exit nodes particular talk dataflow solution node u mean solution holds exit u controlflow graph g directed graph distinguished entry vertex denote vertex set g v g v edge set g eg e entry vertex entryg convenience assume entry vertex predecessors every vertex graph reachable entry vertex formally dataflow analysis problem instance tuple g c semilattice ffl g controlflow graph map gs vertices dataflow functions dataflow fact associated entry vertex refer u transfer function associated vertex u function extended map every path graph function l l p path v 1 defined v k convenient generalize definition sequence vertices even sequence path graph meetoverallpaths solution mopf problem instance g c defined follows denotes set paths p entryg u maximal fixed point solution problem denoted mfpf maximal fixed point following collection equations set variables fx u j results paper apply regardless whether one interested maximal fixed point solution meetoverallpaths solution whenever simply refer dataflow solution statement applies solutions assume interested solving dataflow analysis problem controlflow graph g idea behind sparse evaluation technique construct usually smaller graph h along function f set vertices g set vertices h dataflow solution node u graph g dataflow solution node fu graph h implies sufficient perform dataflow analysis graph h furthermore graph h mapping f constructed knowing set nodes g identity transfer function respect given dataflow analysis problem words reduction valid dataflow problem instance graph g associates identity transfer function vertices though description somewhat incomplete suffice later present formal definition equivalent flow graph compact evaluation graphs overview goal section explain compact evaluation graph algorithm constructing graph simple terms without distracting formalisms formal details presented latter sections let set nodes g includes entry node g well node nonidentity transfer function respect given dataflow analysis problem refer nodes whose execution may modify abstract program state mnodes nodes whose execution preserve abstract program state pnodes given graph g set idea construct smaller graph equivalent g explained earlier approach generate equivalent flow graph applying sequence elementary transformations much like t1t2 style elimination dataflow analysis algorithms 18 9 use two elementary transformations t2 t4 named relate t1 t2 t3 transformations 18 9 basic transformations transformation t2 transformation t2 applicable node u iff u pnode ii u one predecessor let v denote unique predecessor node u t2 applicable graph obtained g merging u v remove node u edge v u graph g replace every outgoing edge u say u corresponding edge transformation essentially one outlined ullman18 apply pnodes note dataflow solution graph g obtained trivially dataflow solution graph particular dataflow solution node u g given dataflow solution node 2u vg dataflow solution every node graphs transformation t4 t4 transformation applicable strongly connected set pnodes set x vertices said strongly connected exists path two vertices x path contains vertices x x strongly connected set pnodes graph g graph 4xg obtained g collapsing x single pnode words replace set x vertices new pnode say w replace edge form u edge replace edge form u edge w v delete edges form u note dataflow solution graph g obtained trivially dataflow solution graph 4xg particular solution node u g given solution new node w solution node u 4xg u 62 x algorithm constructs equivalent flow graph taking initial graph repeatedly applying t2 t4 transformations transformations applicable show latter final graph produced independent order transformations applied let denote final graph produced every vertex u final graph t2t set su vertices original graph g either u contains mnodes case transfer function associated u graph identity function u contains exactly one mnode v zero pnodes case us transfer function graph transfer function v g dataflow solution vertex u g given dataflow solution vertex u refer compact evaluation graph g computing normal form present algorithm constructing normal form graph respect t2 t4 transformations step 1 let g denote initial control flow graph let g p denote restriction g set pnodes g g p graph obtained g removing mnodes edges incident maximal strongly connected components g p using standard algorithms let x 1 denote strongly connected components g 1 topological sort order topological sort order implies edge vertex x vertex x j j step 2 apply t4 transformation x g collapse x single vertex w let us denote resulting graph g 1 note graph g p used identify sets x 1 transformations applied starting graph g step 3 visit vertices w 1 w k g 1 order vertex w visited check transformation applicable apply transformation let us denote final graph produced w k visited g show later g t2 g obvious complexity basic algorithm linear size graph case algorithms actual complexity depends implementation details especially details sets implemented straightforward implement algorithm runs linear time also note simple algorithm identifying strongly connected components described 3 due kosaraju sharir directly generates components topological sort order example example figure 1 illustrates algorithm assume interested identifying reaching definitions variable x graph g shown figure 1i problem vertex controlflow graph mnode iff entry node contains definition variable x let us assume nodes r c g shown bold circles mnodes g remaining nodes shown regular circles pnodes 1 first step algorithm identify maximal strongly connected components subgraph g consisting pnodes example g p one nontrivial maximal strongly connected component namely fa eg remaining pnodes forms strongly connected component consisting single vertex step 2 next step apply t4 transformation strongly connected components identified previous step t4 transformation applied strongly connected component consisting single vertex without self loop identity transformation hence need apply t4 transformation fa eg reducing set vertices new vertex w gives us graph figure 1ii later figures vertex generated merging set x vertices original graph shown polygon enclosing subgraph induced set x subgraph shown using dashed edges italic fonts part transformed graph shown aid reader step 3 next step visit possibly transformed strongly connected components set vertices h j topological sort order try apply t2 transformation first visit node w node w two predecessors namely r c t2 transformation applicable w visit b one predecessor namely w hence apply t2 transformation b obtain graph shown figure 1iii similarly apply t2 transformation nodes f one another merging w node h merging g transformation applicable last node visited j graph figure 1vi normal form g respect t2 t4 transformations 4 t2 t4 transformations section show apply t2 t4 transformations graph order whatsoever applicable transformations exist resulting graph unique also establish algorithm produces unique normal form follows transformation denotes either t2 t4 transformation theorem 1 let 1 2 two transformations applicable graph g exists transformation 1 applicable 2 g transformation 0 2 applicable 1 g 0 proof follows denote vertex obtained collapsing set x vertices v x disjoint transformations follows straightforward way choose 0 1 1 0 2 2 let us consider two overlapping t2 transformations 1 2u v 2 2v w choose 0 1 2u v 1 0 2 2u w 2 renamed handle merging v u let us consider two overlapping t4 transformations 1 4x 2 4y choose 0 1 2 let us consider overlapping 1 identity transformation 0 2 vg 1 2v v 0 2 4y follows theorem t2 t4 transformations form finite church rosser system hence every graph unique normal form respect transformations show graph g produced algorithm normal form r e f c r f c r f c r c r c r c ii iii iv v vi e e e f e f e f figure 1 example illustrating algorithm constructing compact evaluation graph theorem 2 t4 transformations applicable g proof first observe nontrivial strongly connected set pnodes exists graph g 1 hence t4 transformation applicable graph g 1 clearly application one t2 transformations g 1 cannot create nontrivial strongly connected set pnodes hence t4 transformation applicable final graph g either consider construction g g 1 assume find t2 transformation applicable pnode w visit node w words w least two predecessors visit clearly predecessor w must either mnode node w j transformations eliminate node form w j j hence none w predecessors eliminated subsequently hence t2 transformation applicable w g either 2 5 comparison previous equivalent flow graphs section compare ceg equivalent flowgraph produced algorithm two previously proposed equivalent flow graphs namely sparse evaluation graph seg 2 quick propagation graph qpg 11 10 show sparse evaluation graph compact evaluation graph generated original graph applying appropriate sequence t2 t4 trans formations goal present algorithms generate seg qpg rather show seg qpg two many equivalent flowgraphs generated via t2t4 transformations follows ceg least small seg qpg begin defining sparse evaluation graph say vertex x dominates vertex every path entry vertex passes x say x strictly dominates x dominates dominance frontier vertex x denoted df x set x dominates predecessor strictly dominate dominance frontier set vertices defined union dominance frontiers elements let x set vertices define idf df x 1 limit sequence called iterated dominance frontier x denoted idf x given graph g set vertices sparse evaluation graph consists 2 set vertices v idf set edges e idf defined follows exists path x g none whose internal vertices v idf g vertex define set partitionu follows exists path u v g none whose internal vertices v idf g denote set fug partitionu dominates every vertex partitionu proof let path g none v v idf show u dominates v induction consider dominate v 1 v 1 df u definition hence v 1 must v idf contradicting assumption df idf x idf x 2 choi et al also discuss couple simple optimizations applied seg ignore discuss later section 7 consider 1 know inductive hypothesis u dominates v igamma1 u dominate v v df u definition hence v must v idf contradicting assumption result follows 2 two different vertices v idf partitionu partitionv disjoint proof since domination antisymmetric relation either u dominate v v dominate u assume without loss generality u dominate v implies exists path ff entry vertex v contain u consider w partitionv definition exists path fi v w none whose internal vertices v idf particular fi contain u concatenation ff fi path entry vertex w contain u hence u dominate w follows lemma1 w element partitionu result follows 2 lemma 3 v partitionu predecessor w v must partition proof recall assume every vertex controlflow graph reachable entry vertex consider path ff entry vertex w let z last vertex ff belongs v idf implies w belongs partition z also implies v partition z definition partitionz hence z must u lemma 2 2 theorem 3 sparse evaluation graph produced original controlflow graph applying appropriate sequence t2 t4 transformations proof first show vertex u v idf whole partitionu merged u sequence t2 t4 transformations consider subgraph induced partitionu let c 1 denote strongly connected components subgraph topological sort order reduce every c vertex w using t4 transformation let hu denote resulting graph apply t2 transformation vertices w 1 w k order t2 transformation applicable w following reason note lemma 3b implies predecessor w graph hu must either u w j apply t2 transformation vertices w 1 w u unique predecessor hence apply t2 transformation w well merge u clear end process every vertex partitionu merged u repeat process every vertex u v idf clearly resulting graph sparse evaluation graph 2 corollary 1 compact evaluation graph generated sparse evaluation graph applying appropriate sequence t2 t4 transformations note application either t2 t4 make graph smaller transformations reduce number nodes number edges graph hence corollary implies representation produced algorithm least sparse one produced choi et als algorithm figure 2 shows difference compact evaluation graph sparse evaluation graph example graph g presented figure 1 seen compact evaluation graph generated sparse evaluation graph applying transformation 4fx yg r b e f g h c b c r e f x g h figure 2 compact evaluation graph produced algorithm ii sparse evaluation graph produced previous algorithms also establish results analogous quick propagation graph defined 10 quick propagation graph based concept singleentry singleexit regions every singleentry singleexit r unique entry edge edge vertex outside r vertex inside r let us refer vertex u entry vertex r show proof theorem 3 singleentry singleexit region r consisting pnodes merged entry vertex using t2 t4 transformations since quick propagation graph constructed precisely merging singleentry singleexit regions consisting pnodes entry vertices theorem 4 quick propagation graph produced original controlflow graph applying appropriate sequence t2 t4 transformations 6 minimum size equivalent flow graphs seen three different graphs namely seg qpg ceg serve equivalent flow graphs ie help speed dataflow analysis sparse evaluation techniques raises question exactly equivalent flow graph particular possible construct equivalent flow graph minimum size efficiently section attempt address questions presenting one possible definition equivalent flow graphs let set vertices graph g given path define sprojection ff denoted project ff subsequence x 1 ff consisting vertices let oe arbitrary sequence elements say oe spath vertices x iff exists path ff vertices x whose sprojection oe use notation xs denote fact spath x usually omitting superscript obvious context f function set vertices g set vertices another graph h let fs denote set ffx j x 2 sg say hf hi preserves spaths ii f onetoone respect 8x 2 sx iii vertex graph g spath entryg g iff fspath entryh fy h say dataflow analysis problem instance graph g srestricted transfer function associated vertex identity function definition one show hf hi preserves spaths srestricted dataflow analysis problem instance graph g mop mfp solution g recovered mop mfp solution h theorem 5 let g controlflow graph set vertices g includes entry vertex g let hf hi preserve spaths let g c srestricted dataflow analysis problem instance g define f 0 l hm 0 c 0 u defined x identity function otherwise every vertex u g proof note path ff g project ff since transfer functions associated vertices identity function let r denote entry vertex g let spathsr u denote set spaths r u obviously since hf hi preserve spaths follows trivially mopf let us consider dataflow equations induced f let u vertex since transfer function associated u identity function equation associated u reduces let us eliminate right hand side equations variable x u associated vertex elimination slightly complicated cycles involving vertices cycle consisting vertices equations vertices cycle together imply x two vertices u v cycle hence mutually recursive equations induced vertices converted selfrecursive equations selfrecursion eliminated elimination process finally transforms equation associated vertex w note meet set vertices reach w path consisting vertices endpoints since assume every vertex graph reachable entry vertex clear ssww iff entrygffsww path ff clear dataflow equations f f 0 isomorphic reduced simple form hence maximal fixed point solution f f 0 samethe theorem shows conditions definition 1 sufficient ensure dataflow solution g recovered dataflow solution h also argued conditions necessary fact theorem like hold obviously need condition definition 1 two vertices trivial construct srestricted dataflow analysis problem instance g solution two vertices different hence clearly condition ii also necessary similarly vertex g set spaths entryg dont correspond set fspaths entryh fy trivial construct srestricted dataflow analysis problem instance g solution differs solution fy hence may define given graph g set vertices g say hf hi equivalent flow graph g respect iff hf hi preserves spaths 61 algorithm constructing vertex minimal equivalent flow graphs present simple algorithm constructing equivalent flow graph consisting minimum number vertices possible algorithm runs ojsjjv denotes number mnodes graph jv j jej denote number vertices edges graph begin notation helpful relating algorithms based collapsing multiple vertices single vertex earlier algorithm based t2 t4 transformations notion equivalent flow graphs introduced let equivalence relation vertices graph g denote set equivalence classes let u denote equivalence class vertex belongs let denote function v g maps every vertex equivalence class may occasionally omit subscript reduce notational clutter define quotient graph obtained collapsing every equivalence class single vertex following definition depends set mnodes obvious natural definition reason definition become apparent soon graph gs graph h whose vertex set edge set definition eh deserves explanation basic idea edge u v g become edge u v collapsed graph however definition ensures certain edges eliminated completely particular u v corresponding edge u v self loop retained v 2 similarly v edge directed v projected otherwise eliminated note t2 t4 transformations viewed simple quotient graph constructions particular corresponds equivalence relation places u v equivalence class every vertex equivalence class similarly 4x corresponds equivalence relation vertices x equivalent every vertex x equivalence class sequence transformations corresponds equivalence relation namely transitive closure union equivalence relations associated individual transformations sequence hence compact evaluation graph quotient graph respect appropriate equivalence relation define particular equivalence relation induced set define pred u set vertices 2 exists spath u note 2 pred fsg say pred pred v algorithm identifies equivalence classes equivalence relation collapses equivalence class single vertex formally algorithm produces equivalent flow graph h gs first establish minimality claim theorem 6 hf hi preserves spaths proof let hf hi preserve spaths assume pred x w spath w x definition pred x fw fspath fw fx since hf hi preserve spaths fw fspath fw fy since w spath w since hf hi preserve spaths pred definition pred hence pred pred x 2 follows theorem cannot construct equivalent flow graph fewer vertices h g need show h g equivalent flow graph following theorem establishes general result namely equivalence relation approximates quotient graph respect equivalent flow graph theorem 7 preserves spaths iff proof let f denote forward implication theorem follows directly theorem 6 consider reverse implication first two conditions definition 1 follow trivially need show third condition holds recall xs denotes fact spath x let r denote entry vertex g need show establish forward implication induction length path r base case trivial since frfrfr inductive step assume path p r consisting n edges whose sprojection first consider case consider prefix path p ending vertex k path r k consisting less n edges whose sprojection follows inductive hypothesis frfs 1 frfs 1 consider remaining case note presence path p implies hence x last edge path p r via path edges follows inductive hypothesis frfs 1 done otherwise h includes edge fx fy follows frfs 1 establish reverse implication induction length path fr fy h base case trivial since r r r inductive step assume path p fr fy length n edges whose fs projection fs 1 establish r two steps proof r first consider case last edge p must edge g since path less edges fr fx whose sprojection fs 1 follows inductive hypothesis r together edge x k implies r consider case path less edges fr fs k whose sprojection fs 1 follows inductive hypothesis proof k k consider suffix path p fs k fy suffix written form fu 1 immediately follows k k u particular implies path q k g whose sprojection k follows r easy verify equivalence relations corresponding t2 t4 transformations approximations hence theorem shows h gs compact evaluation graph sparse evaluation graph quick propagation graph valid equivalent flow graphs identifying equivalence classes present efficient algorithm identifying equivalence classes algorithm partitioning algorithm similar hopcrofts algorithm minimizing finite automata initially start partition nodes single equivalence class refine partition considering every node one one every node first perform traversal graph identify rm set nodes reachable without going another node nodes u pred u contains every equivalence class x refined two equivalence classes sets nonempty refinement ensures two vertices x left equivalence class 2 pred pred hence refinement done respect every vertex pred pred two vertices x left equivalence class refinement partition given node done linear time appropriate data structures used example maintaining equivalence class doubly linked list element removed equivalence class constant time consequently final partition constructed time ojsjjv practice might efficient first construct compact evaluation graph using linear time algorithm apply quadratic algorithm smaller compact evaluation graph algorithm similar spirit work duesterwald et al 8 present ojv j log jv algorithm ojv j 2 log v partitioning based algorithm constructing equivalence graphs complexity measure based assumption number edges incident vertex bounded constant duesterwald et als algorithm hopcrofts algorithm utilize edges graph refine partitions algorithm uses paths graph consisting pnodesto refinement step guarantees graph produced algorithm minimum number vertices possible case duesterwald et als algorithm 62 constructing edge minimal equivalent flow graphs nphard show problem constructing smallest equivalent flow graph becomes much difficult one counts number edges graph well define size hf hi sum number nodes number edges h theorem 8 problem finding equivalent flow graph minimum size nphard proof reduction setcovering problem setcovering problem 3 following given finite s2f find minimumsize subset c f setcovering problem known nphard show given instance x f setcovering problem construct polynomial time graph g minimumsize cover x f generated polynomial time minimumsize equivalent flow graph g assume input instance x 62 f otherwise fxg trivially minimumsize cover x f graph g consists mnode r entry vertex mnode x every x 2 x pnode ps every 2 f pnode exit graph consists edge r every x edge x p edge every p exit let hf hi minimum size equivalent flow graph g assume every predecessor fexit h vertex form fp sw case h trivially modified follows without increasing size ensure consider vertex fexit h let w predecessor fexit h claim must fp sw reachable w exists fp sw reachable w proof consider following cases case 1 w fr possible since hf hi preserves spaths case 2 w fm x x clearly x must set 2 f hence must exist edge x ps g since hf hi preserves spaths must exist path case 3 w fp result trivially follows case 4 w fexit possible since drop edge fexit get smaller equivalent flow graph case 5 w fu u fp reachable w could simply merge w fexit generate smaller equivalent flow graph hence must exist fp reachable w us replace every predecessor w fexit fp sw gives minimum size equivalent flow graph predecessors fexit form fp shown set fs 2 f j fp edge hg minimum size cover x f clearly conditions spath preservation imply set must cover x f minimum size cover let c f minimum size cover x f replace predecessors fexit set ffps js 2 cg give us smaller equivalent flow graph contradicting assumption hf hi minimum size equivalent flow graph 2 63 discussion let us look results seen far slightly different perspective seen cycles involving pnodes irrelevant may eliminated eg via t4 transformations cycles eliminated problem constructing equivalent flow graphs becomes similar wellknown problem minimizing computation required evaluate set expressions set variables one additional factor need consider operator allowed expressions meet operator commutative associative idempotent example problem may viewed minimizing boolean circuit consisting say booleanand operator algorithm constructing vertex minimal equivalent flow graph essentially eliminates common subexpressions point view performing dataflow analysis achieves best possible space reduction one might hope since iterative algorithms typically maintain one solution every vertex graph also reduces number meet operations iterative algorithm needs perform order compute final solution least number necessary eliminating unnecessary edges graph reduce number meet operations performed analysis algorithm though provide space savings helps place nphardness result perspective indicating achieved efficiently cannot yet another question concerning significance nphardness result feeling may simpler generate minimum size equivalent flow graph controlflow graphs generated structured programs graphs generated unstructured programs nphardness result might hold restrict attention structured controlflow graphs consider example figure 3i mnodes shown bold circles graph already normal form respect t2 t4 transformations hence compact evaluation graph graph however smaller equivalent flow graph exists input graph shown figure 3ii note however graph figure 3i cannot generated using structured programming constructs contrast consider graph shown figure 3iii graph generated using structured constructs case statements ifthenelse statements nodes e f g graph solution corresponding nodes figure 3i case however linear time t2t4 based algorithm able reduce graph normal form shown figure 3ii interesting question arises whether simpler generate minimum size equivalent flow graph controlflow graphs structured programs particular nphardness result hold restrict attention structured controlflow graphs 7 partially equivalent flow graphs note equivalent flow graphs considered far permit dataflow solution vertex original graph recovered sparse graph general may require dataflow r f e r r e f figure 3 example illustrating kind factoring algorithm attempt achieve solution every vertex example solving reaching definitions problem variable x solution usually necessary nodes contain use variable x one use fact construct graphs even compact equivalent flow graphs refer generalized graphs allow us recover dataflow solution specified set vertices original graph partially equivalent flow graphs let us refer node dataflow solution required rnode node dataflow solution required unode let us refer node pnode unode upnode define transformations used construction partially equivalent flow graph transformations transformation t5 t5 transformation applicable node u u upnode ii u unique successor t5 transformation structurally t2 transformation simply merges node u applicable us unique successor let v denote us successor graph 5u vg obtained removing node u edge v graph g replacing every incoming edge w u u corresponding edge w v note dataflow solution node u graph g cannot general obtained dataflow solution node 5u vg however okay since dataflow solution u required transformation t6 t6 transformation applicable set unodes successor set x nodes said successor exists edge node x node outside x x set unodes successor g graph 6xg obtained g deleting nodes x well edges incident t6 transformation rather simple says node deleted node nodes reachable node unodes similar pruning dead oenodes discussed 19 2 general outline transformation essentially captures optimization described choi et al 2 optimization however requires us relax earlier condition partially equivalent flow graph constructed knowing nothing transfer functions associated mnodes assume know whether transfer function associated mnode constantvalued function example problem identifying reaching definitions variable x every mnode constantvalued transfer function since generates single definition x contained node kills definitions x let us refer mnode cnode transfer function associated node constantvalued function transformation t7 t7 transformation applicable cnode one incoming edges transformation simply deletes incoming edges t7 transformation may preserve meetoverallpaths solution since creates vertices unreachable entry vertex however preserve maximal fixed point solution theorem 9 t2 t4 t5 t6 t7 transformations form finite churchrosser system proof tedious straightforward 2 algorithm luckily transformations significantly interact let us denote normal form graph g respect set t2 t4 t5 t6 t7 transformations 2t4t5t6t 7 g let t5 g denote normal form g respect set t5 transformations t6 g t7 g similarly defined show theorem proof sketch outline proof omit details assume graph normal form respect t4 transformations words nontrivial size 1 strongly connected set pnodes clearly application t5 transformation create nontrivial strongly connected set pnodes hence graph continue normal form respect t4 transformation even application t5 transformation similarly graph continue normal form respect t4 transformations even application t6 t7 t2 transformation assume graph normal form respect t2 transformations one show graph continue normal form respect t2 transformations even application t5 t6 t7 transformation similarly graph normal form respect t7 transformations continue even application t6 t5 transformation graph normal form respect t6 transformations continue application t5 transformation establishes t5 t6 t7 t2 t4 g normal form respect transforma tions 2 present algorithm constructing partially equivalent flow graph given graph g step 1 compute outlined earlier step 2 compute outlined earlier step 3 compute simply deleting incoming edges every cnode g 2 step 4 compute perform simple backward graph traversal every rnode identify set x nodes rnode reachable delete nodes edges incident upon step 5 compute set upnodes g 4 topological sort order since g 4 normal form respect t4 transformations cannot cycle pnodes hence topological sort ordering upnodes must exist visit vertices w k w 1 order applying t5 transformation w one successor graph g 5 shown normal form respect transformations described earlier example figure 4 illustrates construction partially equivalent flow graph using algorithm assume applicable t2 t4 transformations applied initial graph using algorithm outlined earlier resulting graph shown figure 4i assume interested dataflow solution nodes e shown square vertices figure remaining nodes shown circles unodes also assume mnodes constant transfer function next step computing partially equivalent flow graph applying possible t7 transformations produces graph shown figure 4ii apply feasible t6 transformations produces graph figure 4iii examine remaining upnodes reverse topological sort order applying t5 transformations possible turns t5 transformation applicable f applying transformations produces normal form figure 4v f r f r f e e e e e iv v e figure 4 example illustrating algorithm constructing partially equivalent flow graph 8 interprocedural extensions discussed sparse evaluation applies intraprocedural analysis analysis single procedure programs however ideas outlined paper easily extended case interprocedural analysis assume input program consists set procedures controlflow graph vertices graphs may correspond calls procedures assume part input noncall vertices controlflow graph annotated mnode pnode vertices representing procedure calls however annotated part input clearly procedure whose nodes pnodes eliminated call procedure may marked pnode iterative application idea conjunction algorithm intraprocedural case suffices construct sparse evaluation representation multiprocedure programs absence recursion recursion complicates issues slightly define procedure p pprocedure nodes procedure p nodes procedure may directly transitively called p pnodes define p mprocedure otherwise set mprocedures program identified simple linear time traversal call graph initially mark procedures containing mnode mprocedure traverse call graph reverse identifying procedures may call mprocedure marking mprocedures well done may mark call node mnode call mprocedure pnode otherwise construct sparse evaluation representation procedure independently using intraprocedural algorithm 9 related work precursor sparse evaluation forms static single assignment form 5 6 used solve various analysis problems constant propagation redundancy elimination efficiently choi et al 2 generalized idea defined sparse evaluation graph cytron ferrante 4 sreedhar gao 16 pingali bilardi 14 15 improve upon efficiency original choi et al algorithm constructing sparse evaluation graph discuss relative efficiencies various algorithms detail soon johnson et al 11 10 define different equivalent flow graph called quick propagation graph qpg present linear time algorithm constructing duesterwald et al 8 show congruence partitioning technique used construct equivalent flow graph briefly compare work different algorithms representations terms following three attributes simplicity work originally motivated desire simpler algorithm constructing sparse evaluation graphs one require dominator tree standard prerequisite previous algorithms constructing sparse evaluation graphs johnson et al algorithm 10 require dominator tree prerequisites namely identification singleentry singleexit regions construction program structure tree subsequent work became aware log n algorithm duesterwald et al 8 generating sparse evaluation forms algorithm based congruence partitioning require dominator tree either believe algorithm simpler understand implement previous algorithms constructing sparse representations course dominator tree program structure tree applications built way algorithm offer particular advantage terms implementation simplicity compactness shown compact evaluation graph general smaller sparse evaluation graph quick propagation graph consequently dataflow analysis techniques benefit even using smaller representation also presented quadratic algorithm constructing equivalent flow graph smallest number vertices possible may interest complicated expensive analyses pointer analysis may worth spending extra time reduce number vertices graph duesterwald et al present ojv j log jv j algorithm constructing equivalent flow graph believe exactly sparse evaluation graph also describe another ojv j log jv lead reductions size graph suggest iteratively applying algorithms graph reduced leading ojv j 2 log jv algorithm algorithm constructing equivalent flow graph minimal number vertices similar spirit constructs even smaller graph efficiently efficiency comparing efficiency various algorithms constructing ssa form different equivalent flow graphs somewhat tricky particular situations worstcase complexity measure tell us full story interested problem constructing single equivalent flow graph given graph comparing algorithms easy linear algorithms due pingali bilardi sreedhar gao johnson pingali well linear time algorithm asymptotically optimal one could argue algorithm smaller constant factor simplicity often however may interested constructing multiple equivalent flow graphs given controlflow graph respect different set mnodes previous observations remain less valid even case equivalent graph desired one spend building map vertices original graph vertices equivalent flow graph linear time algorithms perform comparably upto constant factors typical controlflow graphs jej ojv j assume interested constructing multiple partially equivalent flow graphs given controlflow graph problem constructing ssa form falls category true generalization ssa form appears partially equivalent flow graph equivalent flow graph particular every subproblem instance specifies set mnodes well set r nodes dataflow solution required subproblem need construct partially equivalent flow graph mapping every vertex r vertex equivalent flow graph algorithm well sreedhar gaos algorithm construction partially equivalent flow graph original ssa algorithm 5 6 contrast constructs partially equivalent flow graphs parallel sharing linear time graph traversal overhead control flow graphs arise practice algorithm usually constructs partially equivalent flow graph sub linear time even though worst case algorithm take quadratic time construct partially equivalent flow graph hence many believe practice algorithm faster algorithms always take linear time every partially equivalent flow graph see 17 empirical evidence supporting fortunately work pingali bilardi 14 15 shows original ssa algorithm adapted best worlds namely linear worstcase complexity well sub linear behavior graphs arise practice finer distinction different linear time algorithms likely significant one could argue difference unlikely significant complex analysis problems cost analysis likely dominate cost constructing equivalent flow graph problems reaching definitions problem however simple linear time solutions case cost constructing equivalent flow graph may significant fraction analysis time distinction could significant hand 7 argue constructing equivalent flow graphs fastest way solve simple analysis problems anyway previous work shown equivalent flow graphs useful representation improving performance dataflow analysis algorithms well representing dataflow information compactly paper presents linear time algorithm computing equivalent flow graph smaller previously proposed equivalent flow graphs presented quadratic algorithm constructing equivalent flow graph consisting minimum number vertices also shown problem constructing equivalent flow graph consisting minimum number vertices edges nphard shown concept equivalent flow graph generalized partially equivalent flow graph extended algorithm generate compact representation simple partitioned problems reaching definitions problem partially equivalent flow graph directly yields desired solution factored form results presented give rise several interesting questions appear worth pursuing significant nphardness result practice minimum size equivalent flow graphs constructed efficiently special classes graphs generated structured programming constructs graph transformations worth incorporating framework r efficient flowsensitive interprocedural computation pointerinduced aliases side effects automatic construction sparse data flow evaluation graphs introduction algorithms efficiently computing oenodes onthefly efficient method computing static single assignment form efficiently computing static single assignment form control dependence graph analyze large programs efficiently informatively reducing cost data flow analysis congruence partitioning fast usually linear algorithm global dataflow analysis algorithm program tree structure computing control regions linear time unified approach global program optimization safe approximate algorithm interprocedural pointer aliasing apt data structure optimal control dependence compu tation optimal control dependence computation roman char iots problem linear time algorithm placing oenodes efficient program analysis using dj graphs fast algorithms elimination common subexpressions detecting program components equivalent haviors tr efficient method computing static single assignment form introduction algorithms automatic construction sparse data flow evaluation graphs efficiently computing static single assignment form control dependence graph analyze large programs efficiently informatively safe approximate algorithm interprocedural aliasing dependencebased program analysis efficient flowsensitive interprocedural computation pointerinduced aliases side effects program structure tree linear time algorithm placing myampersandphgrnodes optimizing sparse representations dataflow analysis sparse functional stores imperative programs apt efficient program analysis using dj graphs optimal control dependence computation roman chariots problem toward complete transformational toolkit compilers fast usually linear algorithm global flow analysis unified approach global program optimization efficiently computing phinodes onthefly extended abstract reducing cost data flow analysis congruence partitioning ctr stephen fink eran yahav nurit dor g ramalingam emmanuel geay effective typestate verification presence aliasing proceedings 2006 international symposium software testing analysis july 1720 2006 portland maine usa
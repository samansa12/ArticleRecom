secrecy typing security protocols develop principles rules achieving secrecy properties security protocols approach based traditional classification techniques extends techniques handle concurrent processes use sharedkey cryptography rules form typing rules basic concurrent language cryptographic primitives spi calculus guarantee protocol typechecks leak secret inputs b introduction security elusive cocktail many rare ingredients given security protocol one may want properties integrity confidentiality availability various forms anonymity nonrepudiation seldom protocol achieve properties designers intended moreover even protocol sound often delicate define important properties difficult prove tasks protocol design analysis simplified principles make easier achieve particular security objectives isolation rules help recognize objectives achieved ex ample wish obtain availability properties concerned denial service attacks may design protocols way obvious small bound amount work principal response message one could relax bound messages trusted authenticated principals trust authentication always correct letting availability depend done lightly paper develop informal principles formal rules achieving secrecy properties security protocols principles rules based traditional concepts classification information flow den82gas88 extended deal concurrent processes use sharedkey cryptography particular analyzing protocol label piece data communication channel either secret public secret data sent public channels secret channels made available indiscriminately approach encryption keys pieces data labelled secret data made publicdeclassifiedby encryption secret key however declassification cannot done without additional precautions example given secret bit b secret key k cannot simply publish b k may also publish 0 1 k attacker could deduce value b comparing ciphertexts rules paper capture sufficient set simple precautions permit declassification rules form typing rules basic concurrent language calculus ag97a calculus extension pi calculus mpw92 sharedkey cryptographic primitives purpose rules rather different standard typing rules related languages pierce sangiorgi ps96 rules guarantee protocol type checks leak secret inputs secrecy obtained independently feature flaw protocol example rules may guarantee protocol leak contents certain messages without concern whether message replay possible notion leaking formalized terms testing equivalence dh84bn95 roughly process p x leak input x second process q cannot distinguish running parallel p running parallel p 0 every 0 typing rules helpful following may lead designs clearer robust likely sound furthermore enable us give simple proofs properties would hard establish first principles however secrecy theorems obtain taken grain salt dependent choice particular model spi calculus model fairly accurate expressive take account issues key length example next section explains informally approach achieving secrecy section 3 review spi calculus spi calculus presented generalization defined originally ag97a includes polyadic constructs mil91 section 4 provides typing rules spi calculus section 5 shows rules applied prevent undesirable flows information section 6 illustrates use rules examples finally section 7 discusses conclusions throughout paper often opt simplicity generality considering work first exploration promising approach particular take binary manichaean view secrecy according view world divided system attacker secret something attacker sophisticated view secrecy would distinguish various principals within system enable us discuss principals given piece data binary view however vary boundary system attacker benefits principles secrecy security literature wellknown methods controlling flows information typically methods rely putting objects subjects security classes guaranteeing data flows higher classes lower classes methods security classes formalized types control flows information relies typing rules eg vsi96 adapt work security protocols section describes approach informally along main difficulties addresses probable basic observations section already made seem documented open literature 21 rules distributed systems centralized system administrator controls hardware system may hope control information flows communication mediated system hardware control information flows plausible least principle particular administrator may check user programs running statically may apply dynamic checks distributed system hand single administration may control hardware part system may able check software part constructed according given set rules best principal analyze programs receives principals well messages therefore whatever rules propose attacker satisfies vacuously cannot expect restrict code attacker runs rules constrain principals want protect secrets attacker 22 preliminaries keys channels mentioned introduction paper concerns sharedkey protocols write fmgk result encrypting k using sharedkey cryptosystem des des77 sharedkey cryptography secrecy achieved communication public channels secret keys addition public channels anyone may communicate consider channels builtin protection restrict attention channels principals send receive single machine channel protection provided operating system mediates communication user processes distributed system protection implemented cryptographically ability communicate channel often determined possession capability password key pi calculus spi calculus name channel capability channel public channel one capability public similarly secret channel one capability secret 23 classifying data consider three classes data public data communicated anyone secret data leaked data arbitrary data use symbols r range classes secret public refer secret public classes levels types difference one emphasis possible generalize rules richer classification structures three classes generalization essential immediate purposes encryption keys data classification scheme applies several different levels associated key level piece data levels data used encrypt levels resulting ciphertexts however combinations possible example public key used turn secret data public ciphertexts simplest retain one level key similarly associate single classification channel adopt following principles result encrypting data public key classification data result encrypting data secret key may made public public data sent public channels kinds data may sent secret channels relation r holds equals r r piece data level r piece data level r well piece data level could level secret leaked hand piece data level could level public cannot used secret example cannot used secret key encrypting secret data thus know piece data level protect level secret exploit level public piece data therefore useful constructing channel capabilities encryption keys find cleaner forbid uses altogether furthermore focus case classification secret given data created fresh within system trying protect however data class must protected though class secret 24 classifying inputs whereas principal may know classification data creates principal may always know classification data acquires communication principals data arrives clear public channels presumed public hand data arrives protection may either secret public participants protocols typically know handle fields encrypted messages receive following example inspired needhamschroeder protocol ns78 message message 3 protocol principals b share keys ksa ksb server respectively server provides confidential information b b response request receives message server decrypts retrieves forwards fi b gksb b crucial able recognize action appropriate example principal x plays role b two concurrent runs protocol able recognize whether message instance message 2 instance message 3 x mistakes instance fi x gksx message 3 instance message 2 x would forward part x clear example common principals deduce sensitivity inputs expected kind message implicit information implicit information often incorrect often hard analyze an96 clearer label explicitly component message classifi cation avoiding dependence implicit context labelling important messages secret channels secret keys messages contain public information alternatively may adopt standard format messages secret channels secret keys format guarantee standard way attach classifications parts message avoiding dependence implicit context rules adopt scheme message secret channel three components first level secret second third public message secret key three components plus confounder component discussed next schemes implementations following principle upon receipt message easy decide parts contents sensitive information decision least errorprone depend implicit context 25 confounders noted introduction given secret bit b secret key k cannot simply publish b k may also publish 0 1 k attacker could deduce value b comparing ciphertexts hand create fresh value n publish concatenation b n k value n sometimes called confounder purpose n guarantee resulting ciphertext differs previous ones resulting ciphertext differ future ones ciphertext includes fresh confounder always position general unless one concerned encrypting known plaintext confounders need kept secret confounders needed encryption historydependent different transformation applied message particular confounders needed encryption done stream cipher block cipher appropriate chaining mode remarks section intended apply protocols built algorithms independently choice cipher confounders needed protocols ciphertexts generated guaranteed different unfortunately always clear whether guarantee offered example consider simple protocol principal sends message principal b shared key kab sends message b provides challenge nb fresh message challenge serves proof freshness protects replays may reason ciphertexts different since includes fresh challenge however reasoning incorrect attacker c could provide challenge instead b would reply without noticing challenge come b attacker may pick challenge nc twice row case ciphertexts responds fmnc gkab identical cleartexts 0 identical thus c find whether sending two identical cleartexts even without knowing key kab thus protocol leaking information order prevent small leak create confounder na encryption modified protocol protocol analyzed ag97c proved protocol guarantees secrecy prudent adopt following principle encrypted message protocol includes freshly generated confounder standard position protocol generate ciphertext confounders used unless obvious needed 26 implicit flows system may reveal something one parameters even parameter never appears explicitly message example system may send different cleartext messages depending value parameter attacker could deduce something parameter patterns communication leak information sometimes called implicit flow course important restrict implicit flows purpose may forbid comparison involves pieces sensitive data could followed actions would reveal result comparison also important push restriction uncomfortable extremes many protocols exhibit implicit flows form usually without severe undesirable effects example consider protocol message message 3 attacker send arbitrary message instead message 2 receipt message performs test involves secret ksa branches result test reaction depends visibly whether message ciphertext ksa one could regard implicit flow perhaps one little importance chance independently created message ksa negligible allow implicit flow harmless model tentative policy implicit flows summarized following principle implicit flows information prevented except perhaps likelihood implicit flow greater likelihood attacker guess information 27 principles discussion section comprehensive practice several additional warnings techniques important often hard leak size secret use padding encrypted messages help respect prudent minimize benefit attacker may derive discovering one secret particular key used protect great volume sensitive traffic even bruteforce attack key may profitable weak secrets passwords protected bruteforce attacks see example sch96 undoubtedly however discussion section suffices background rules theorems 3 untyped polyadic spi calculus section defines version spi calculus serves setting formal work main novelty respect earlier versions spi calculus introduction polyadic forms input output encryption decryption operation applies arbitrary number pieces data rather single piece novelty important typing rules next section however novelty substantial particular affect expressiveness spi calculus therefore presentation mostly review material derived earlier presentations spi calculus ag97b includes ideas common picalculus literature 31 assume infinite set names infinite set variables let range names let w x z range variables outcome replacing free occurrence x p identify expressions renaming bound variables names set terms defined grammar name sucm successor x variable set processes defined grammar composition np restriction replication n p match let p pair splitting case case case l fx name n variables x x 1 x k bound processes constructs familiar earlier process algebras see ag97a review see operational semantics informal semantics constructs follows term fm represents ciphertext obtained encrypting key n process case l fx attempts decrypt l l form fm process behaves otherwise process stuck process let x p behaves p nxly pair n l stuck pair process case 0 qnx sucn n otherwise stuck process n p behaves p n equal otherwise stuck process mhn behaves p output happens name another process ready receive k inputs use mhn abbreviation process may output stop process mx ready receive k inputs n behave p n 1 process p behaves infinitely many copies p running parallel process np makes new name n behaves p polyadic notations input output encryption decryption k 6 1 necessary expressiveness definable corresponding unary notations example set case l fx case l fygn let variable fresh however mentioned polyadic constructs useful typing also introduce typing difficulty arities match case fm p typing difficulty could overcome appropriate system sorts addition polyadic notations use following standard abbreviations k 2 let let variable fresh write fnm fnp sets names free term process respectively write fv fv p sets variables free p respectively term process closed free variables 32 commitment operational semantics rely commitment relation definition commitment depends new syntactic forms abstractions concretions abstraction expression form x k bound variables p process concretion expression terms p process names 1 l bound 1 k p agent abstraction process concretion use metavariables b stand arbitrary agents extend restriction composition operators abstractions assuming x fvr concretions mnh assuming 62 fng fng define dual composition j r symmetrically definition mnh miq slightly different original one ag97b change crucial lemma 9 f abstraction c concretion n define processes fc cf follows reduction relation least relation closed processes satisfies following axioms red repl red match red let let red zero case 0 red suc case sucm red decrypt case barb name representing input coname representing put action barb distinguished silent action commitment relation written p ff gamma p closed process ff action closed agent defined rules comm comm gamma comm inter 1 gamma c gamma fc comm inter 2 gamma gamma f gamma cf comm par 1 gamma gamma j q comm par 2 gamma gamma comm res gamma mp ff gamma comm red gamma gamma 33 testing equivalence test pair r fi consisting closed process r barb fi say p passes test r fi gamma qn fi gamma n 0 processes q 1 qn agent obtain testing preorder v testing equivalence closed processes test r fi p passes r fi q passes r fi strict barbed simulation binary relation closed processes 1 every barb fi p fi gamma q fi gamma b b gamma p 0 exists q 0 q requirements somewhat stronger barbed simulations ag97b strict barbed bisimulation relation gamma1 strict barbed simulations following lemma provides method proving testing equivalence lemma 1 every closed process r exists strict barbed bisimulation p j r q j r p q proof lemma consequence earlier results ag97b give simple direct proof since one argue p passes test r fi q assuming exists strict barbed bisimulation symmetrically q passes test r fi p p passes r fi gamma rn fi gamma agent processes r 1 rn n 0 definition strict barbed simulation exist r 0 n 0 r gamma 0 therefore q passes r fi 2 4 typing system section describes rules controlling information flow spi cal culus based ideas section 2 several ways formalizing ideas embody typing system spi calculus typing system simple enough could enforced statically main results typing system section 5 typing system gives rules three kinds assertions judgments means environment e wellformed means term class e means process p typechecks e 41 environments environment list distinct names variables associated levels addition name n associated term form fm k 0 intuitively association means name n may used confounder term fm x level level term shorthand arbitrarily n needed confounder set names variables declared environment e domain write dome rules environments environment empty wellformed environment variable wellformed environment name wellformed collectively rules enable us form environments lists variables names associated levels addition terms attached names empty list written rule environment empty rule environment name hypotheses included variable occurs 1 k declared e restriction important without proper care variable could instantiated two different ways confounder could used two different messages double use would defeat purpose confounders 42 terms rules terms level subsumption level variable level name level zero wellformed level successor level pair level encryption public level encryption secret rule level subsumption says term level public secret level well rules level variable level name enable us extract levels names variables environment rules level zero says 0 level public rule level successor says adding one preserves level piece data therefore terms 0 suc0 sucsuc0 level public however term form sucx may level secret rule level pair says level pair level components components must level pair term level public one level secret need regard level thus rule level pair loses little bit typing information would interesting explore richer structural typing system would avoid loss rule level encryption public says k pieces data level encrypted key level public resulting ciphertext level rule level encryption secret imposes restrictions encryption keys level secret resulting ciphertext declassified level public restrictions enforce particular format levels contents use confounder explained section 2 one could relax rule somewhat considering also case resulting ciphertext given level public present rule strikes reasonable balance simplicity flexibility finally note rule encryption case n term level n term level known whether level public secret n cannot used key 43 processes rules processes level output public level output secret level input public level input secret level nil wellformed level parallel level replication level restriction level match level pair splitting 2 fpublic secretg level integer case 2 fpublic secretg case level decryption public 2 fpublic secretg case l fx level decryption secret 2 fpublic secretg case l fx two rules output two rules input rule level output public says terms level public may sent channel level public rule level output secret says terms levels may sent channel level secretprovided done according format described section 2 two rules input level input public level input match rules output level input public inputs assumed level public level input secret levels inputs deduced position allowed format messages channels level secret term level known whether level public secret cannot used channel rules nil parallel composition replication restriction routine rule level restriction name n bound associated arbitrary term l used confounder rule level match enables us compare two terms levels public secret terms level excluded order prevent implicit flows discussed section 2 may little surprising terms level secret allowed rule may seem permit implicit flow however generality rule level match present obstacle results rule level pair splitting enables us try break term level public secret two components assumed level original term case original term known level disallowed allowed rule would permit leaking whether term fact pair similarly rule level integer case enables examine whether term 0 successor term branch result successor case variable x represents predecessor term examined assumed level term level pair splitting term level may level secret names numbers repeated applications rule level integer case would enable us publish secret key unary formally leak cannot happen names numbers practical meaning small formal miracle debatable may suggest model concrete spi calculus would worth investigating finally two rules decryption rule level decryption public handles case decryption key level public rule level decryption secret handles case decryption key level secret rules analogous corresponding rules input rule case key level 5 typing guarantees goal section prove process typechecks leak values parameters level precisely main theorem says variables level names level public domain environment e oe oe 0 two substitutions values variables e p typechecks proved p oe p oe 0 testing equivalent conclusion means observer cannot distinguish p oe p oe 0 cannot detect difference values variables order prove result develop number propositions lemmas analyze typing system characterize possible behaviors processes typecheck 51 typing concretions abstractions first step proofs extend typing rules concretions abstractions level concretion public level concretion secret level abstraction public level abstraction secret rules reminiscent corresponding rules output input 52 auxiliary propositions next obtain several auxiliary results first proposition 2 formal counterpart discussion section 21 proposition shows given suitable environment closed process p may construe attacker always typechecks proposition 2 assume e wellformed dome contain variables names dome level public closed term fnm dome p closed process fnp proof prove general property allowing variables occur e p consider environment e e wellformed levels names variables public prove term fnm fvm dome p process former facts obtained direct induction structure using level encryption public terms form fm latter facts obtained direct induction structure using level output public level input public level decryption proposition 3 fairly standard says anything proved given environment also proved adding assumptions environment proposition 3 assume proof property proved induction derivations proposition 4 enables reorder environment moving declaration name past declarations variables proposition 4 let e 1 proof proof induction derivations note converse proposition cannot true hypotheses converse l could contain free occurrences x 1 x k next proposition says levels secret public mutually exclusive proposition 5 case proof assume hold derive contradiction induction size two derivations public interesting case form term fm could levels secret public n well application two rules encryption induction hypothesis yields expected contradiction 2 remaining auxiliary results concern substitutions first standard substitution lemma proposition 6 assume e wellformed proof proof joint induction derivations judgments case rule level encryption secret important note confounder n appears e x cannot occur term formed 2 general substitution partial function set variables set terms write domoe domain substitution oe proposition 7 given environment e suppose variables level e domoe either e loe variable l variable loe name l name loe form n l form loe 0 l 0 loe form sucm l form loe form fm l form proof follows fact l cannot variable domoe since domain consists variables level 2 proposition 8 given environment e suppose variables level e domoe suppose proof proof induction derivation rule level subsumption applied trivially last rule derivation since 2 fpublic secretg one case remaining rules typechecking terms last rule derivation variable one domoe since domoe consists variables level therefore oe n oe implies proposition 7 last rule derivation level name level name 0 therefore oe n oe implies proposition 7 cases level successor level pair easy applications proposition 7 induction hypothesis two remaining cases form fm depending whether derivation finishes application level encryption public application level encryption secret cases proposition 7 implies n form fn depending whether derivation finishes application level encryption public application level encryption secret induction hypothesis obtain proposition 5 derivations finish applications rule ffl rule level encryption public applications rule since oe n oe 1 oe induction hypothesis obtain ffl rule level encryption secret 4 name e level 0 n 4 name n name may declared environment conclude 53 lemmas commitment simulation main lemma section relates typing system commitment relation write e oe every x 2 dome oex closed term fnoex dome lemma 9 assume 3 variables dome level process q process q gamma 0 either concretion okcsecret depending whether gamma 0 either abstraction okasecret depending whether proof argument lemma quite long surprising given auxiliary propositions consists one case axioms reduction relation one case rules commitment relation therefore omit details argument 2 lemma 10 given environment e suppose variables dome level suppose e oe e oe 0 relation strict barbed bisimulation proof first consider commitment p oe ff gamma 0 ff barb lemma 9 agent p oe 0 ff gamma aoe 0 next consider commitment p oe gamma q 0 lemma 9 process q gamma qoe 0 thus step p oe may matched p oe 0 therefore relation fp oe p oe 0 strict barbed simula tion symmetry strict barbed bisimulation 2 54 main theorem finally obtain theorem described start section 5 theorem 11 given environment e suppose variables level names level public dome suppose e oe proof according lemma 1 suffices show every closed process q exists strict barbed bisimulation relates p oe j q p oe 0 j q since construct extension e names appear free q dome name n us call resulting environment propositions 2 3 obtain e also proposition 3 obtain e combining two results rule level parallel yields e p finally lemma 10 yields desired result 2 note theorem would hold p could free occurrences names level secret occurrences ruled hypotheses names level public e 6 examples order illustrate use typing rules consider examples two protocols key exchange secure communication cases typecheck protocols corollaries obtain secrecy certain messages protected corollaries surprising however would much harder prove spi calculus without rules developed paper first principles analogues corollaries might provable formal systems sur prisingly seem formal proofs sort literature methods one may able show messages question among terms attacker obtains protocol runs however result approximation corollaries rule attacker could least deduce whether messages even numbers odd numbers example corollaries exclude possibility analogues corollaries perhaps established informal rigorous models see example br95 models rather accurate particular take account issues probability complexity unfor tunately proofs models remain much difficult typechecking 61 first example first protocol similar structure wide mouthed frog protocol ban89 informally protocol c message message 3 message message message 7 gkab c b protocol b two clients server channels c c db public keys kas ksb secret keys communication server kab new key communication b message intended secret ns nb nonces used prove timeliness arbitrary message appropriate level necessarily occurrences ca c 0 cs confounders messages 1 2 requests receives nonce challenge messages 4 requests receives nonce challenge b message 3 provides key kab passes b message 6 message 7 uses kab sending receipt message recipient b outputs names b public channel db message 8 important specify receives last message include order illustrate b allowed react express protocol spi calculus much earlier work spi calculus ag97a attention requirements typing definition given set messages 1 mm source addresses addresses natural numbers range 1n indicate plays role plays role b run protocol addition address address channels c write term representing simply write term representing definition send ij variable z corresponds message write send ij send ij mz nonce nonce gk i21n x ns c hns case x cipher fx let z xb x nonce j21n z x b j x nonce ns nonce nonce case cipher fx let nonce i21n x x x b j nonce nb case z cipher fz z z x key sys delta next proposition says protocol typechecks proposition 12 let e environment fixed numbers 1n k 2 1m let k z k proof order indicate process sys typechecks annotate bound names variables levels introduced also annotate confounders terms used nonce gk i21n x case x cipher fx key nonce j21n z x b j x nonce ns nonce case cipher fx let i21n x x x b j nonce nb case z cipher fz finally given environment e set sys delta writing consequence typechecking obtain protocol reveal message conclusion stated following corollary simplicity restrict attention case numeral numeral one terms 0 suc0 sucsuc0 corollary 13 let k j k fixed numbers 1n k 2 1m let sys1 sys2 two versions sys terms k arbitrary numerals proof immediate consequence proposition 12 theorem 11 2 62 second example second example principal transmits secret message generated server example interesting brings issue trust trusts provide key appropriate transmission message message gksb c b message 5 b two clients server c c c b db public channels keys ksa ksb secret keys communication server b kab new key communication b na nb nonces cs c 0 ca confounders write example spi calculus much style first example definition given set messages 1 mm source case x cipher fx let x b j x nonce na nonce i21n x nonce nonce i21n x case cipher fx let nonce x b j nonce nb case z cipher fz z z sys delta next proposition corollary analogues proposition 12 corollary 13 respectively omit proofs proposition 14 let e environment fixed numbers 1n k 2 1m let k z k corollary 15 let k j k fixed numbers 1n k 2 1m let sys1 sys2 two versions sys terms k arbitrary numerals conclusions perhaps part advances programming languages idea static checking security properties seems reviving java bytecode verifier recent static checker security objectives ly96 last couple years sophisticated security checks based selfcertification informationflow techniques see example nec97vsi96 work seen part revival develops method static checking secrecy properties programs written minimal expressive programming language spi calculus programs concurrent use cryptography method embodied set typing rules principles rules developed paper neither necessary sufficient security necessary like practical static typechecking disciplines incomplete sufficient ignore security issues secrecy account implement spi calculus preserving secrecy properties however principles rules provide useful guidelines furthermore rules tractable precise able study detail prove secrecy properties establishing correctness informal principles within formal model acknowledgments butler lampson suggested studying authentication protocols classification techniques several years ago suggestion starting point work work took place context collaboration andrew gordon spi calculus themes techniques paper owe much andrew gordon also commented draft paper conversations mike burrows steve kent ted wobber helpful writing paper r calculus cryptographic protocols spi calculus calculus cryptographic protocols spi calculus reasoning cryptographic protocols spi calculus prudent engineering practice cryptographic protocols logic authentication testing equivalence mobile processes provably secure session key distribution three party case cryptography data security data encryption standard testing equivalences processes building secure computer system java virtual machine specification polyadic calculus mobile processes using encryption authentication large networks computers typing subtyping mobile processes applied cryptography protocols sound type system secure flow analysis tr building secure computer system calculus mobile processes calculus mobile processes ii lesson authentication protocol design testing equivalence mobile processes applied cryptography 2nd ed provably secure session key distribution prudent engineering practice cryptographic protocols linearity picalculus proofcarrying code calculus cryptographic protocols decentralized model information flow control system f typed assembly language secure information flow multithreaded imperative language slam calculus typed language distributed mobile processes extended abstract compositional security checker probabilistic polytime framework protocol analysis calculus cryptographic protocols sound type system secure flow analysis inductive approach verifying cryptographic protocols using encryption authentication large networks computers cryptography data security handbook applied cryptography java virtual machine specification bisimulation method cryptographic protocols protection programminglanguage translations reasoning cryptographic protocols spi calculus control flow analysis picalculus polyadic picalculus abstract robustness principles public key protocols mobile ambients secure implementation channel abstractions strategies replay attacks proving trust systems 2ndorder processes limitations design principles public key protocols ctr martn abadi bruno blanchet analyzing security protocols secrecy types logic programs acm sigplan notices v37 n1 p3344 jan 2002 riccardo focardi sabina rossi information flow security dynamic contexts journal computer security v14 n1 p65110 january 2006 shahabuddin muhammad zeeshan furqan ratan k guha understanding intruder attacks cryptographic protocols proceedings 44th annual southeast regional conference march 1012 2006 melbourne florida antonio brogi carlos canal ernesto pimentel component adaptation flexible subservicing science computer programming v63 n1 p3956 november 2006 roberto zunino pierpaolo degano weakening perfect encryption assumption dolevyao adversaries theoretical computer science v340 n1 p154178 13 june 2005 michael backes peeter laud computationally sound secrecy proofs mechanized flow analysis proceedings 13th acm conference computer communications security october 30november 03 2006 alexandria virginia usa pankaj kakkar carl gunter martn abadi reasoning secrecy active networks journal computer security v11 n2 p245287 may luca cardelli giorgio ghelli andrew gordon types ambient calculus information computation v177 n2 p160194 15 september 2002 c bodei p degano f nielson h riis nielson flow logic dolevyao secrecy cryptographic processes future generation computer systems v18 n6 p747756 may 2002 grard boudol ilaria castellani noninterference concurrent programs thread systems theoretical computer science v281 n12 p109130 june 3 2002 fabio martinelli analysis security protocols open systems theoretical computer science v290 n1 p10571106 1 january eijiro sumii benjamin c pierce logical relation encryption journal computer security v11 n4 p521554 01012004 luca cardelli giorgio ghelli andrew gordon secrecy group creation information computation v196 n2 p127155 january 29 2005 dependent types higherorder mobile processes acm sigplan notices v39 n1 p147160 january 2004 benjamin c pierce type systems programming methodology springerverlag new york inc new york ny andrew gordon alan jeffrey authenticity typing security protocols journal computer security v11 n4 p451519 01012004 phan minh dung phan minh thang stepwise development security protocols speech actoriented approach proceedings 2004 acm workshop formal methods security engineering october 2929 2004 washington dc usa chiara bodei pierpaolo degano riccardo focardi corrado priami primitives authentication process algebras theoretical computer science v283 n2 p271304 june 14 2002 martn abadi bruno blanchet analyzing security protocols secrecy types logic programs journal acm jacm v52 n1 p102146 january 2005 peeter laud secrecy types simulatable cryptographic library proceedings 12th acm conference computer communications security november 0711 2005 alexandria va usa martn abadi bruno blanchet secrecy types asymmetric communication theoretical computer science v298 n3 p387415 11 april annalisa bossi damiano macedonio carla piazza sabina rossi information flow secure contexts journal computer security v13 n3 p391422 may 2005 chiara bodei mikael buchholtz pierpaolo degano flemming nielson hanne riis nielson static validation security protocols journal computer security v13 n3 p347390 may 2005 christian haack alan jeffrey patternmatching spicalculus information computation v204 n8 p11951263 august 2006 david monniaux abstracting cryptographic protocols tree automata science computer programming v47 n23 p177202 may avik chaudhuri martn abadi formal security analysis basic networkattached storage proceedings 2005 acm workshop formal methods security engineering november 1111 2005 fairfax va usa c bodei p degano r focardi c priami authentication primitives secure protocol specifications future generation computer systems v21 n5 p645653 may 2005 giampaolo bella stefano bistarelli soft constraint programming analysing security protocols theory practice logic programming v4 n56 p545572 september 2004 martn abadi cdric fournet mobile values new names secure communication acm sigplan notices v36 n3 p104115 march 2001 gilles barthe tamara rezk amitabh basu security types preserving compilation computer languages systems structures v33 n2 p3559 july 2007
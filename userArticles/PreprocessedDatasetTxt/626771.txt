reconfigurability reliability systolicwavefront arrays authors study faulttolerant redundant structures maintaining reliable arrays particular assume desired array application graph embedded certain class regular boundeddegree graphs called dynamic graphs degree reconfigurability dr dr distance drsup redundant graph defined dr drsup independent size application graph graph finitely reconfigurable fr locally reconfigurable lr respectively shown dr provides natural lower bound time complexity distributed reconfiguration algorithm difference fr lr dynamic graphs also shown local reconfigurability fixed level reliability maintained dynamic graph must dimension least one greater application graph thus example onedimensional systolic array cannot embedded onedimensional dynamic graph without sacrificing either reliability locality reconfiguration b introduction highly parallel pipelined structures systolic wavefront arrays attractive architectures achieving high throughput 9 examples important potential applications include digital signal processing 11 2 largescale scientific computation arrays solving partial differential equations 12 simulating latticegas automata 14 array processors become larger reliability processing elements pes becomes critical issue becomes necessary use faulttolerant techniques time fabrication 15 runtime defective pes must located architecture reconfigured substitute good pes bad certain runtime applications like avionics space flight fault tolerant techniques must able restore proper operation failures fast possible purpose distributed reconfiguration algorithms executed parallel pes studied 13 17 5 faulttolerant multiprocessor developed space applications also employs distributed reconfiguration approach topology chordal skiplink ring paper study complexity algorithms reconfiguring arrays failures focus especially runtime fault tolerance literature fault tolerance faults confined processing elements assumed switches connections 1 10 3 18 perfect valid number switches connections becomes large paper use graph model takes account failures switches interconnection wires well pes pes switches represented nodes graph obvious way connection two elements computational structure represented node inserted edge appropriate two nodes graph model node graph associated probability failure achieve fault tolerance add redundancy system failure original working architecture reconfigured replacing nodes used redundant nodes good fault tolerant structure one number nodes need changed failure small possible paper define measure adaptability degree reconfigurability dr analyze measure class regular graphs called dynamic graphs 16 6 7 8 also analyze stricter measure called degree reconfigurability distance dr takes account total distance original nodes replacing nodes goal investigate relation structure dynamic graphs reliability faulttolerant capability measured degree reconfigurability case dr independent size system especially important represents situation amount change necessary repair system depends number failed nodes size system case say graph finitely reconfigurable similarly dr total distance cost changes independent size system say locally reconfigurable actually section 3 show redundant system dynamic graph locally reconfigurable finitely reconfigurable given desired working structure discuss kinds redundant structures possible impossible maintain fixed level reliability time locally reconfigurable particular main result wish maintain local reconfigurability fixed level reliability dynamic graph must dimension least one greater application graph shown section 4 section 5 definitions mathematical framework labelsecdef1 vlsiwsi array architecture represented graph e node graph g regarded processor edge g connection two processors assume nodes failed independently probability ffl mentioned node graph model represent pe switch interprocessor connection real working architectures considered family graphs g called application denotes ith application graph g example g family linear arrays indexed number nodes g n nnode linear array always assume g connected value n exists unique since need add redundant nodes edges increase reliability embedding structures g r called redundant graph also represented family r denotes ith redundant graph g r pair nodes v r associated value distance defined function r theta v set natural numbers 0 distance regarded physical distance two nodes cost communication cost given two graphs g define embedding function image v 1 given embedding function let mapping set set pairs represents difference two embedding functions 0 given g g r following function determine graph g r redundant graph ith application graph definition 21 embedding strategy g g r function es g g r ie r g j r redundant graph g esg r k nodes g j r failed failed nodes edges incident removed g j r becomes new subgraph r procedure finding new embedding function r called reconfiguration definition 22 given g g r es maximum faulttolerance g mft g maximum number nodes allowed fail arbitrarily esg esg still find subgraph isomorphic g addition ft g given fixed number mft g definition 23 given g g r es fault tolerance ft g quadruple g called embedding architecture ea array linear array figure 1 example g g r example figure 1 g family linear arrays g r family triple modularredundancy tmr arrays obtained triplicating node linear array three nodes called module let g n nmodule array let corresponding ft g n 2 n simplicity context clear always assume ith application graph maps ith redundant graph ie esg r let g r initial embedding function ith application graph g definition 24 given embedding architecture define initial embedding ie set 0 g family example figure 1 initial embedding set 0 node g maps bottom node module g r given embedding architecture g k nodes failed obviously may many different embedding functions k difference small possible purpose realtime faulttolerance suppose number nodes g n given ea ie k ft g nodes failed let cost reconfiguration g 4k n minimum k j possible embedding functions k 4k n 1 also want measure total distance original nodes replacing nodes reconfiguration total distance cost reconfiguration g 4 k n similarly defined following 1 given ea ie let drk n degree reconfigurability g maximum 4k n possible k failures failures k nodes degree reconfigurability distance dr k n defined similarly change 4 4 equation return example figure 1 let distance two nodes module one distance two nodes one module module j 1 case drk n dr k n g n k since k ft g n need change k nodes modules k faulty nodes distance two nodes module one definition 25 embedding architecture ea finitely reconfigurable resp locally reconfigurable exists initial embedding ie g 2 g drk nresp dr k n bounded function k n example embedding architecture linear arrays example lr fr since g drk n dr k n k show following lemma hayes hft n hfaulttolerant graph nnode loop application graph finitely reconfigurable figure 2 hayes 4ft single loop nth application graph g n nnode single loop embedding strategy map g socalled hayes hft n hnode single loop thus g n r defined following procedure assume example h even singleloop graph c nh nodes join every node x c nh nodes index distance j x j satisfying resulting graph g n r hft n hayes 4 shows mft g n let distance node x x j computations proof based indices mod nh indices g r graph figure 2 example lemma 21 embedding architecture h mapping nnode single loop hayes hft n hnode singleloop graph neither fr lr h 1 proof assume adversary always tries best select failures show drk n bounded function k matter initial n working nodes must distributed among nodes g n r define segment sequence consecutively numbered working nodes g n r x igamma1 x j1 nonworking redundant nodes denote length segment suppose h nonworking nodes ordered indices form sequence x j segment j may null starting x j 1 thus must exist segment ls without loss generality assume node x 1 node x ls adversary choose middle node x segment faulty e pick reconfiguration optimal sense fewest possible number nodes g nh r changed let number nodes changed reconfiguration let c sequence nodes ordered indices know x must replaced one node say x x 0 working node must replaced another node thus sequence c working nodes sequence replacements starting x ending working node replaced first node x r outside first divide many small subsegments length w h 1 represent sequence subsegment without loss generality assume index x r larger largest index node c ie r claim must exist least one node c subsegment k 1 suppose let x r replace x c let b two nodes connected x initial working subgraph since connections must length distance x last node also first node know b must b c say replaced x r must connected reconfiguration know r ls assumption impossible x r connected thus know b c say replaced 0 denote sequence original working nodes starting x toward one direction original working subgraph sequence reconfiguration fx r 0 0 g 0 2 0 replaces 0 must c since index 0 impossible 0 connected x r thus 0 summary know x x r 62 c 0 repeating argument using instead x 0 instead x r get result 1 c 0 1 continuing way follows nodes 1 c nodes 0 0 impossible since finite number nodes c thus claim correct claim next pair subsegments l exists least one node c proved true first pair subsegments assume true pairs subsegments kgammaj g since x 2 c 0 way x r chosen know must exist one node c 0 replaced node outside c 0 kgammaj1 j exist node c 0 argument results contradiction thus pair subsegments least one node replaced number nodes c must therefore least number nodes unbounded function n need changed thus drk n bounded function k initial embedding function n therefore hayes embedding architecture finitely reconfigurable obvious total distance original nodes replacing nodes also increasing function n lr either 2 next example embedding architecture finitely reconfigurable locally reconfigurable choose g figure 1 family linear arrays g r figure 3 family complete graphs row let es map g n g nh r let h g n g distance node node j defined one node failed say node 2 take spare node replace say node shown figure 3 reconfiguration initial embedding nh nh figure 3 example fr lr lemma 22 h embedding architecture fr lr proof obvious ea finitely reconfigurable since spare node replace node k faulty nodes need changed k nodes fail considering g n g nh r initial embedding must exist sequence working nodes g nh r consecutive indexes length nh 1 argument lemma 21 choosing middle node path faulty distance spare node faulty node must distance increasing function n thus ea locally reconfigurable 2 3 degree reconfigurability dynamic graphs applications interested graphs regular bounded degree interesting useful class graphs called dynamic graphs 16 6 7 8 model regular systolic wavefront arrays natural way undirected kdimensional dynamic graph g defined finite digraph g called static graph kdimensional labeling edges vertex set v x copy v 0 integer lattice point x v k union let x copy node 2 v 0 vertex set v x let b copy node b 2 v 0 vertex set v nodes x b connected b difference two lattice point x equal labeling k b therefore dynamic graph locallyfinite infinite graph consisting repetitions basic cell interconnected edges determined labeling k figure 4 show example twodimensional static graph g 0 corresponding dynamic graph g 2 g graph vertex set v x edges end points v x called xth cell g k c given dynamic graph contract nodes cell one node delete edges totally within cell contracted graph called celldynamic graph x6y give example figure 5 celldynamic graph corresponding g 2 figure 4 given static graph g 0 define f j finite subgraph g k dimension f j j cells ie f x xy define family f kdimensional dynamic graphs set f j j 1 different ways define distance dynamic graphs example one reasonable definition distance function define distance two nodes one vertex set v x v euclidian distance kdimensional space point x point x different cells one cell say distance function satisfies property 5 triangle inequality distance nodes b less equal total distance path b course euclidian distance satisfies 5 following lemma show set redundant graphs g r family static graph g c c c c c b c c c c b 0 c 0 1 0 figure 4 example g 0 corresponding dynamic graph g 2 figure 5 celldynamic graph g c g 2 dynamic graphs distance function satisfies 5 embedding architecture lr fr rest paper assume satisfies property 5 lemma 31 g r family dynamic graphs distance function satisfies 5 embedding architecture locally reconfigurable finitely reconfigurable proof given ea ea lr know definition total distance cost k failures expressed function fk f function k know distance two nodes least one number nodes changed must fk thus ea also fr suppose fr know g n 2 g k nodes failed function k say fk nodes must changed original working subgraph let 1 node g n distance g n r n maximum nodes v n fk nodes changed n k exists path application graph g n fk edges 1 unchanged node 2 ie c maximum distance two nodes connected edge constant independent k n definition distance node n c delta fk property 5 triangle ineqality similarly distance node n c delta fk since 2c delta fk therefore total distance fk changed nodes 2c delta fk 2 pairs changed ea therefore locally reconfigurable definitionfinite reconfigurability desirable practice especially realtime fault tolerance shows k nodes failed function k nodes need changed independent size application graph lemma 32 show degree reconfigurability dr provides lower bound time complexity distributed reconfiguration algorithm shows one reason measure dr important assume follows takes one time step send message edge lemma 32 g nnode application graph g r family ddimensional dynamic graphs time complexity distributed reconfiguration algorithm number nodes failed proof k nodes failed must change least dr nodes reconfigure assume distributed reconfiguration algorithm initiated neighbor node called source node faulty node neighbor node detected failure need inform least dr nodes g r assigned different nodes g thus time broadcast fault information lower bound time complexity distributed reconfiguration algorithm let corresponding static graph g labelling maximum edge distance c one dimension g let equal jv 0 j theta 2c always contract nodes g groups nodes obtain ddimensional reduced graph g 0 c 1 g node v 0 c called class represents nodes dynamic graph note constant definition time steps one source node inform 2 delta classes ddimensional reduced graph 2 delta delta nodes reached since source nodes c 1 maximum degree g r total number nodes informed time steps 2 delta delta mk dr nodes need informed 4 impossibility lrreliable embedding dynamic graphs dimension section restrict attention dynamic graphs consider relationship reconfigurability reliability particular ask whether given embedding architecture finite locally reconfigurable time maintain given level reliability without constraint fr lr simply construct redundant graph many replications application graph achieving high reliability price using large amounts hardware difficult reconfigure main result theorem 45 mapping ddimensions ddimensions cannot maintain local reconfigurability reliability simultaneously lemma 31 shows difference local finite reconfigurability dynamic graphs thus consider local reconfigurability without loss generality define lrreliability framework follows given ea lr probability g r contains isomorphic image g ft r j following definition replaces definition 25 statistical case definition 41 embedding architecture lrreliable reliability fi p g fi g 2 g following lemma useful follows lemma 41 given g g r es let mft g maximum number failures allows corresponding ea lr mft upperbounded constant n 1 exists constant fi ea cannot lrreliable reliability fi proof let upper bound mft c definition mft hypothesis lemma exist c1 nodes redundant graph g r failed ie ea cannot lr therefore p g know n chosen large enough make c1 ffln term corresponding largest summation thus probability p g obvious n goes 1 p goes 0 thus always pick therefore embedding architecture cannot lrreliable reliability fi 2 want study properties dynamic graphs insist local reconfigurability nodes failed since local reconfigurability desirable practical implementations following lemma tells us onedimensional dynamic graphs cannot lrreliable application graphs linear arrays lemma 42 g family onedimensional linear arrays g r family onedimensional dynamic graphs exists constant fi embedding architecture lrreliable reliability fi proof proof lemma 32 always build reduced graph g 0 contracting sets size nodes g n r produce onedimensional linear figure example 2dimensional 16node web array node g 0 c represents class finite number nodes note constant number since g 0 finite graph definition initial embedding n nodes g n distributed least nm contiguous classes g 0 c adversary chooses nodes middle class nm classes faulty initial working subgraph separated two halves must shift least half g n therefore n nodes get new working subgraph thus embedding architecture locally reconfigurable ft must bounded constant lemma 41 know exists constant fi ea cannot lrreliable reliability fi 2 generalize lemma 42 define n node ddimensional web ddimensional graph g thus connect adjacent points ddimensional euclidian space example figure 6 shows 2dimensional 16node web family ddimensional webs indexed n theorem 43 g family ddimensional webs g r family ddimensional dynamic graphs exists constant fi embedding architecture lr reliable reliability fi proof always find ddimensional reduced graph g 0 c contracting dynamic graph g n r proof lemma 32 without loss generality consider general case possible edges present v 0 ae z g node 2nodes figure 7 n paths proof theorem 43 c represents class nodes g n r constant proof lemma 32 first prove cannot embedding strategy maps ddimensional web gamma 1dimensional dynamic graph suppose first n theta n twodimensional lattice projected onedimensional dynamic graph among n 2 nodes web vertices path vertex 0 0 0 must projected n consecutive classes similarly n paths horizontally 0 vertically diagonal vertices must projected n consecutive classes show n paths figure 7 thus nodes paths must 2n classes must exist one class least n4 nodes mapped impossible since class finite number nodes argument generalized easily ddimensional lattices thus restrict attention possibility mapping ddimensional web mapping ddimensional dynamic graph say class g 0 c empty working node application graph nodes adjacent must mapped one adjacent classes hard see initial embedding cannot empty class surrounded image line along dimension 2d web image line along x dimension 2d web line inner central node border n lines passing inner central class 2m classes figure 8 inner central class proof theorem 43 nonempty classes consider line n nodes n node ddimensional web proof lemma 42 initial embedding n nodes distributed least nm classes linearly connected g 0 c images lines may zigzag c must map least nm contiguous classes therefore welldefined inner central class omegagamma nm classes away border image web shown figure 8 note line inner central class border may image line along one dimension web line must contains n nodes web figure 8 shows adversary chooses nodes inner central class faulty original working subgraph central inner hole must nodes one direction get new isomorphic subgraph g n r therefore maintain local reconfigurability embedding architecture ft must upperbounded lemma 41 know exists constant fi ea cannot lrreliable reliability fi 2 next modify application graph node x connected nodes call ddimensional graph ddimensional orthogonal lattice develop intuition gen interior image nonempty class empty class figure 9 pseudo hole eral case ddimensional dynamic graphs following lemma extends theorem 43 twodimensional orthogonal lattices lemma 44 g family twodimensional orthogonal lattices g r family twodimensional dynamic graphs exists constant fi embedding architecture lrreliable reliability fi proof proof theorem 43 know twodimensional orthogonal lattice cannot embedded onedimensional dynamic graph made use diagonal edges proof without diagonal edges however rest proof bit complicated image application graph regarded polygon say embedding g 0 c hole size k exist k consecutive empty classes line along one dimension inside polygon surrounded nonempty classes thus example figure 9 excluded definition hole claim embedding twodimensional orthogonal lattice twodimensional dynamic graph impossible hole size 2 assume claim false denote empty classes hole size 2 b index nodes twodimensional orthogonal lattice g x ij notational convenience choose origin x 00 particular node mapped nonempty class immediately g 0 c refer vertical line g passing x ij vertical line lx vertical line lx 1 vertical line lx 0 b class figure 10 image vertical lines lx 0 lx 1 following observations images g 0 c vertical lines orthogonal lattice g first images vertical lines lx lx i1 cannot one class apart along one dimension image pair nodes x i1j class adjacent classes follows induction j second vertical line lx 0 lx 1 resp lx 0 lx gamma1 must pass side b figure 10 since edge passing b according two observations induction vertical lines lx must side b either left right b cannot interior image g contradiction proves impossible hole size two theorem 43 adversary choose two inner central classes one dimension faulty way reconfigure g r two faulty classes surrounded nonempty classes thus must n nodes one dimension get new working subgraph 2 finally extend result dimensions line containing classes b replaced gamma 1dimensional hyperplane ddimensional dynamic graph theorem 45 g g r families ddimensional dynamic graphs exists constant fi embedding architecture lrreliable reliability fi proof given application graph g dynamic graph reduced graph built since application graph connected class connected neighboring classes exists least one edge along dimension one class neighboring class therefore ddimensional reduced graph contains subgraph isomorphic ddimensional orthogonal lattice therefore need prove theorem case application graph family ddimensional orthogonal lattices proof theorem 43 shows ddimensional orthogonal lattices cannot embedded 1dimensional dynamic graphs claim impossible exist hole size 2 dgamma1 one hyperplane dimensions one coordinate fixed reduced graph assume claim false call 2 dgamma1 classes obstacle obstacle composed two empty classes along gamma 1 dimensions h call fixed dimension h vertical reasoning lemma 44 vertical lines pass obstacle images two adjacent vertical lines must lie side obstacle reduced graph therefore obstacle cannot interior reduced graph claim correct adversary chooses inner central h faulty way reconfigure redundant graph faulty classes surrounded nonempty classes thus must change n nodes one dimension get new isomorphic subgraph 2 5 possibility lrreliable embedding dynamic graphs dimension d1 finally want show really embed ddimensional dynamic graphs 1dimensional dynamic graphs maintaining desired high reliability local reconfigurability begin onedimensional case lemma 51 g family linear arrays exists embedding architecture g r family twodimensional dynamic graphs lrreliable given fi figure 11 lrreliable 2dimensional dynamic graph proof prove constructing redundant graph g n r nnode linear array g n shown figure 11 g n r n columns column nodes let ft g n initial embedding allocates node g n distinct column g n r ie let initial isomorphic subgraph sequence 0 0 1 0 n 0 one node failed choose 1 replacing node nodes 0 1 failed use replace nodes gamma using reconfiguration procedure change 2k gamma 1 nodes respect ea ie locally reconfigurable want show given fi find g n r desired properties let r square piece g n r n theta n dynamic graph let pn probability r contains g n form vertical pile sn blocks obtain theta n dynamic graphs figure 12 connect two adjacent squares resulting graph g n r since connections two squares increase reliability probability exist working linear array big graph figure 12 pile r proof lemma 51 c cn delta logn probability 1n c therefore reliability fi find sufficient large achieve reliability fi 2 prove main result section theorem 52 g family ddimensional dynamic graphs exists embedding architecture g r family d1dimensional dynamic graphs lrreliable given fi proof construct reduced graph given dynamic application graph g general form reduced graph web thus without loss generality need prove theorem case application graph family ddimensional webs use construction reconfiguration method previous lemma 2 reconfiguration method k ft g n nodes failed need change 2 delta k nodes following corollary shows reduce exactly k nodes corollary 53 g family linear arrays exists embedding architecture g r family twodimensional dynamic graphs edge degree 4m constant 2 k ft g n nodes failed need change k nodes figure 13 dynamic graph construction corollary 53 proof first construct dynamic graph shown figure 13 nodes column node j connects reconfiguration method lemma 51 let ft g n family allocate nodes g n different columns number nodes need changed k nodes one column failed e theta 2 gamma 1 worst case drk n maxd 2 2 similar constructions work dimensions 6 conclusions open problems main result difficult dynamic graphs maintain local reconfigurability fixed level reliability precisely dynamic graph must dimension least one greater application graph properties problem considering tradeoffs among size redundant graphs number edges reconfigurability reliability needs studied class simple layered graphs logarithmic number redundant edges proposed 19 maintain finite reconfigurability fixed level reliability wide class application graphs sacrificing finite reconfigurability also construct highly reliable structures asymptotically optimal number edges onedimensional treelike array architectures however redundant graphs resulting constructions dynamic graphs would interesting consider construction redundant graphs restricted dynamic graphs easily implemented less regular graphs r diogenes methodology designing faulttolerant vlsi processing arrays digital signal processing applications systolic algorithms configuration vlsi arrays presence defects graph model faulttolerant computing systems distributed reconfiguration recovery advanced architecture onboard processor testing cycles infinite graphs periodic struc ture planarity testing doubly periodic infinite graphs semiring convex polygons zerosum cycle problems systolic architectures fault tolerant vlsi systolic arrays twolevel pipelines wavefront array processor languages architecture applications faulttolerant array processors using single track switches scalable architecture latticegas simulation waferscale integration systolic arrays problems dynamicperiodic graphs efficient algorithms reconfiguration vlsiwsi arrays reconfiguration architecture vlsi processing ar rays explicit constructions reliable reconfigurable array architectures tr configuration vlsi arrays presence defects testing cycles infinite graphs periodic structure vlsi array processors faulttolerant array processors using singletrack switches scalable architecture latticegas simulations efficient algorithms reconfiguration vlsiwsi arrays semiring convex polygons zerosum cycle problems
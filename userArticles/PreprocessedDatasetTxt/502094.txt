efficient generation shared rsa keys describe efficient techniques number parties jointly generate rsa key end protocol rsa modulus publicly known none parties know factorization n addition public encryption exponent publicly known party holds share private exponent enables threshold decryption protocols efficient computation communication results presented honest curious scenario passive adversary b introduction present ecient protocols number parties jointly generate rsa modulus p q prime end computation parties convinced n indeed product two large primes however none parties know factorization n show parties proceed compute public exponent e shares corresponding private exponent techniques require number steps including new distributed primality test test enables two parties test random integer n product two large primes without revealing primes several cryptographic protocols require rsa modulus none participants know factorization good example original fiatshamir authentication protocol 19 parties use modulus n none know factorization examples see 18 23 28 30 31 usually modulus n unknown factorization obtained asking dealer generate dealer must trusted reveal factorization n results eliminate need trusted dealer since parties generate modulus n threshold cryptography concrete example shared generation rsa keys useful give brief motivating discussion refer 24 survey let pq rsa modulus e signing verication exponents respectively ie de threshold rsa signature scheme involves k parties enables subset generate rsa signature given message subset 1 parties generate signature unlike standard secret sharing 35 signature generated without reconstruct private decryption exponent simple approach obtaining koutofk threshold signature scheme follows 20 pick random satisfying give party abstractly sign message party computes sends combiner holds secrets combiner multiplies obtains signature way parties supported darpa contract f3060297c0326 able generate standard rsa signature without reconstruct private key single location clearly advantageous securing sensitive private rsa key one used certicate authority constructions providing toutofk rsa threshold signatures schemes found 16 13 21 34 important issue left discussion initial generation rsa modulus n shares traditionally modulus n shares private key assumed generated trusted dealer clearly dealer anyone compromises dealer forge signatures results eliminate need trusted dealer since k parties generate n private shares results previously known elgamal public key system 32 rsa paper organized follows give high level description protocol section 2 sections 35 explain various stages generating modulus unknown factorization section 6 describe protocols given public exponent e generate shares corresponding private key achieve fault tolerance one often shares using toutofk scheme subset users apply private key explain toutofk sharing obtained section 63 discuss various practical improvements protocol section 7 note generic secure circuit evaluation techniques eg 38 26 3 9 also used generate shared rsa keys primality test represented boolean circuit however general techniques inecient 11 communication privacy model communication privacy model assumed protocol follows full connectivity party communicate party private authenticated channels messages sent party party b private cannot tampered en route achieved b share secret use encryption integrity authentication honest parties assume parties honestly following protocol end protocol threshold parties enough information factor generated modulus often called honest curious scenario section 8 discuss results showing assumption relaxed recently frankel mackenzie yung 22 showed protocol made robust b k 1 malicious parties collusion protocol b k 1c private coalition size b k 1c learns information factorization pq however coalition b k 1c recover factorization reason bound reliance bgw 3 protocol one step algorithm bgw protocol provides information theoretic security hence limited achieving b k 1c privacy honest parties model note possible achieve k 1 privacy replacing bgw step heuristic protocol due cocks 10 unfortunately cocks protocol far slower bgw method furthermore security based heuristic argument prove security properties ie privacy satised protocol provide simulation argument components overview section give high level overview protocol k parties wish generate shared rsa key wish generate rsa modulus publicprivate pair exponents factors p q least n bits end computation n e public shared k parties way enables threshold decryption parties convinced n indeed product two primes coalition information factors n high level protocol works follows 1 pick candidates following two steps repeated twice secret choice party picks secret nbit integer p keeps secret b trial division using private distributed computation k parties determine k divisible prime less bound b 1 details given section 5 step fails repeat step denote secret values picked rst iteration second iteration 2 using private distributed computation k parties compute value n step reveals information secret values details given section 4 n public k parties perform trial divisions test n divisible small primes range b 3 primality test k parties engage private distributed computation test n indeed product two primes test fails protocol restarted step 1 note primality test protocol k 1 private applies whenever two parties involved details section 3 given public encryption exponent e parties engage private distributed computation generate shared secret decryption exponent details section 6 notation throughout paper adhere following notation rsa modulus denoted n product two n bit primes p q denote p share possession party similarly q p shared among parties denote p ij share p sent party j performance issues protocol generates two random numbers tests product two primes prime number theorem probability p q prime asymptotically 1n 2 therefore naively one perform n 2 probes average suitable n found somewhat worse expected 2n probes needed traditional generation rsa modulus one rst generates one prime using n probes second prime using another n probes n2 degradation performance usually unacceptable typically fortunately thanks trial division things arent bad trial division step 1b tests prime individually therefore analyze protocol must analyze eectiveness trial division suppose random nbit number p passes trial division test primes less tested take likely p prime using classic result due mertens debruijn 12 shows asymptotically prp prime j trial division hence bits probability p prime approximately 122 consequently traditional rsa modulus generation requires 44 probes protocol requires 484 probes eleven fold degradation performance unfortunate manageable discuss methods avoid slowdown section 7 generation shares step 1 protocol party uniformly picks random n bit integer p secret share prime p taken sum shares since sum uniform independent random variables uniformly distributed p picked distribution slightly less entropy uniform show problem sum n log k bit number one easily show p chosen distribution least n bits entropy since n least signicant bits p uniformly chosen n bit string log k bits lost entropy help adversary since easily guessed number parties k small certainly k n formally stated next lemma second issue fact shares p leak information factors n instance party knows p p argue information help adversary either two issues raised dealt following lemma let z 2 n set rsa output protocol k parties involved assume k log n lemma 21 suppose exists polynomial time algorithm given random n 2 z 2 chosen distribution shares hp least 1n exists expected polynomial time algorithm b factors 14k 3 n integers z 2 n assuming hardness factoring lemma shows even adversary given n private shares k 1 parties cannot factor modulus n generated protocol proof lemma somewhat tedious given appendix b distract reader main thrust paper 3 distributed primality test begin detailed discussion protocol distributed primality test step 3 party two secret nbit integers parties know n determine n product two primes without revealing information factors n refer test distributed primality test primality test probabilistic test 36 33 carried z n quadratic extension z n throughout section assuming hence resulting blum integer arranged ahead time party 1 pick shares parties pick shares describing test brie discuss structure quadratic extension z n using working twisted group n suppose prime factors n 3 mod 4 case x irreducible zn x zn quadratic extension zn linear polynomial gcd follows elements tn viewed linear polynomials linear polynomials f g 2 zn x represent element tn ag 2 z n note elements tn also viewed points projective line zn distributed primality test 1 parties agree random g 2 z n value g known k parties step 2 party 1 computes jacobi symbol g n g protocol restarted step 1 new random g chosen step 3 otherwise party 1 computes parties compute parties exchange v values verify test fails parties declare n product two primes step 4 parties perform fermat test twisted group n carry fermat test tn parties pick random h 2 tn party 1 computes parties exchange u values verify test fails n rejected otherwise declare success exponents computation v step guaranteed integers division 4 correctness privacy protocol proved next two lemmas lemma 31 let pq integer p q 3 mod 4 n product two distinct primes success declared invocations protocol otherwise parties declare n product two primes probability least 1 2 random choice g h proof observe step 3 protocol test v amounts testing g n p q14 1 mod n suppose p q distinct primes step 2 verify g 1 implies also since q 1and p 1are odd q 1 mod p mod q since follows g n4 1 mod n since prime follows test step 3 always succeeds similarly show p q distinct primes test step 4 succeeds since root f p f q therefore f p xx f q quadratic extensions f p f q respectively follows group p order p 1 similarly jt q 1 chinese remainder theorem 1 conclude h 2 tn satisfy 1 consequently test step 4 always succeeds prove converse suppose least one p q prime ds nontrivial factorization n exponent used step 3 note e odd since p q 3 mod 4 dene following two subgroups z prove lemma show jhj 1jgj since h subgroup g suces prove proper containment h g ie prove existence g 2 g n h four cases consider case 1 suppose 3 let r 2 r 3 distinct prime factors n must exist pigeonhole principle let r 1 prime factor n distinct r 2 r 3 let quadratic nonresidue modulo r 3 dene g 2 zn element satisfying mod r 3 3 observe g 2 g since e odd consequently g e 6 1 mod n ie g 62 h case 2 suppose gcdp q 1 exists odd prime r r divides p q r 2 divides n implying r divides n follows z exists element g order r since r odd g g since r divides p q know r divide n consequently implying g e 6 1 mod n hence g 62 h case 3 way fall cases 1 distinct primes least one 1 2 bigger 1 case 2 handles n prime power symmetry may assume 1 1 since z p cyclic group order r 1 1 contains element order r 1 1 1 follows z n also contains element g order r 1 1 1 g g q 1 divisible r 1 1 1 consequently g 4e 6 1 mod n ie g 62 h case 4 left case q 1 since know r 4 case may indeed happen g show case step 4 primality test fail probability least half choice h 2 tn dene group h 1g show jh 0 j 1jt n j since h 0 subgroup tn suces prove proper containment ie must exhibit element 1 group p order r 1 1 1 therefore contains element h order r 1 follows exists element w 2 tn order r 1 since assumption q 1 mod r 1 know r 1 divide q 1 hence r 1 divide npq1 therefore w completing proof lemma note step 4 protocol needed lter integers fall case 4 indeed integers pass steps 13 example consider integers prime integers dened body proof consequently integers always pass steps 13 even though product two distinct primes however fail step 4 section 31 give alternate approach ltering integers fall case 4 following lemma shows n product two distinct primes primality test protocol reveals information private shares participants lemma 32 suppose p q prime coalition k 1 parties simulate view primality testing protocol consequently protocol k 1 private proof since p q prime know v v dened step 3 protocol also u dened step 4 let u coalition k 1 parties say party member coalition coalitions view consists construct simulator coalitions view follows simulator given coalitions input protocol started simulate coalitions view simulator rst picks random g 2 z n g computes u using values given input next simulator must generate um generating um trivial since um i6m generating v bit harder proof lemma 31 follows sign v quadratic residue modulo n simulate v simulator computes ips unbiased coin sets v accordingly resulting distribution v computationally indistinguishable true distribution assuming hardness quadratic residuosity modulo blum integer conclude given n product two distinct primes set values hu produced simulator computationally indistinguishable real transcript consequently coalition learns information beginning protocol note step 2 protocol crucial without condition step 3 might fail reveal factorization even p q prime also note practice probability non rsa modulus passes even one iteration test actually far less half 31 alternative step 4 step 4 distributed primality protocol necessary lter integers fall case 4 proof lemma 31 describe alternative simpler approach lter integers requires less computation although communication parties observe n falls case 4 1 alternative step 4 directly test condition test condition information leakage parties following party picks random r 2 zn keeps secret using protocol next section compute mod n without leaking information private shares finally parties check gcdz n 1 n rejected using bgw method section 41 approach b k 1c private n fall case 4 rejected product two distinct primes pass test overwhelming probability note alternate test eliminates valid rsa moduli ie moduli prime 4 distributed computation n next describe computation n party secret wish make product revealing information private shares beyond revealed knowledge n 41 bgw method benor goldwasser wigderson 3 describe elegant protocol private evaluation general functions three parties full technique overkill simple function mind adapt protocol computation hand minimize amount computation communication parties let p n prime unless otherwise stated arithmetic operations done modulo p protocol works follows c picks two random degree l polynomials words constant term f set p q coecients chosen random z p similarly party picks random degree 2l polynomial h step 2 computes 3k values party privately sends triple hp ij q ij h ij party j j 6 note standard loutofk shamir secret sharings p holds step 3 point party hp party broadcasts n parties step 4 point parties values n polynomial observe denition f furthermore x polynomial degree 2l note l dened k 2l 1 consequently since parties least 2l 1 points x interpolate discover coecients finally party evaluates 0 obtains n mod p since n p parties learn correct value n description protocol clear parties learn value n note protocol requires least three parties involved case exactly three parties linear polynomials used protocol 1private following lemma shows coalition b k 1 parties learns information private shares statement holds information theoretic sense complexity assumptions needed completeness sketch proof lemma refer 3 complete details lemma 41 given n coalition b k 1c parties simulate transcript protocol consequently protocol b k 1c private proof sketch set 1c symmetry may assume coalition made follows consistently let index vary l index j vary index r vary k coalitions view consists simulate coalitions view simulator given input rst picks random j picks p ri q ri h ri random independent elements z p computes picks random degree 2l polynomial x 2 z p x satisfying completes simulation setting n r r values perfect simulation coalitions view protocol consists one phase full bgw method diers bgw protocol need truncation step also combine addition multiplication stages one phase resulting computation surprisingly ecient essentially one multiprecision multiplication performed party one step 3 note communication parties reduced factor two using variant protocol described 6 section 4 42 bgw modulo non primes description bgw protocol arithmetic operations carried modulo prime coming sections useful run bgw protocol working modulo non prime p k parties wish compute necessarily prime one easily show prime divisors smaller k protocol used indeed lagrange coecients used interpolation step 4 exist lemma 41 remains correct running protocol modulo containing small factors require slight modication write prime factors smaller k 2 prime factors smaller k mentioned protocol immediately works modulo 1 problem working modulo 2 shamir secret sharing basis bgw possible instance consider case 3 possible use shamir secret sharing f 3 among k 3 parties since f 3 contain enough points shamir secret sharing party must given unique point simple solution run entire protocol algebraic extension f 3 contains k points simulation argument immediately extends case general one factor 2 prime factors run protocol large enough extension factor using chinese remainder theorem one recover value n mod 43 sharing nal outcome cases section 62 wish parties evaluate function however result additively shared among parties rather become publicly available end computation party information revealed private shares nal result modication bgw order achieve goal immediate parties perform step 4 protocol perform broadcast described end step 3 consequently end point polynomial x degree 2l evaluates n using lagrange interpolation know appropriate lagrange coecient therefore rather broadcast n end step 3 party simply sets resulting additive sharing n required simple simulation argument showing minority parties obtains information protocol 5 trial division section consider trial division step step 1b section 2 let integer shared among k parties let p small prime test p divides q party picks random r 2 z p using bgw protocol described section 41 compute divide q furthermore since r unknown minority parties qr provides information q note approach bad candidate q always rejected unfortunately good candidate might also rejected indeed even p divide q still possible alleviate problem one repeat test twice small prime p probability good candidate rejected 1 one caveat approach bgw protocol described section 41 cannot applied test divisibility q small p namely p k reason small p eld f p contain enough points shamir secret sharing among k parties small p one must run bgw protocol extension eld f p contains least k 1 elements explained section 42 6 shared generation publicprivate keys parties successfully construct rsa modulus may wish compute shares given encryption exponent e two approaches computing shares rst works small e say e 1000 ecient requiring little communication parties second works e still ecient requires communication throughout section set recall public modulus k locally compute compute shares parties must invert e modulo exposing unfortunately traditional inversion algorithms eg extended gcd involve computations modulo know eciently perform modular arithmetic modulus shared among participants fortunately trick computing e 1 mod modulo reductions single user involved inversion done three steps 1 compute 1 observe 0 mod e 3 set indeed since e 1 mod need modulo reductions since e 1 mod immediately deduced 1 mod e methods rely observation 61 small public exponent begin describing ecient technique generating shares public exponent e small method leaks value n mod e hence applied e small plus side k 1 private 1 parties jointly determine value possible compute l without revealing information private shares use simple protocol due benaloh 4 k 1 private step 2 let party locally computes e result step 3 sharing enables shared decryption 20 using equality c c r n party 1 determine value r trying possible values 0 r k trial decryption approach leaks n mod e r total log e bits 62 arbitrary public exponent unlike previous technique second method generating shares works arbitrary public exponent e leaks less 2 log k bits information cannot help opponent since easily guessed rather exposing mod e inverting show invert mod e shared among parties result information revealed protocol k 1private step 1 party picks random r 2 z e step 2 using protocol section 42 e end computation known parties invertible modulo e protocol restarted step 1 step 3 party locally computes hence parties able share inverse mod e without revealing information step 4 next parties agree prime p 2ne view shares 0 e elements z p using modied bgw protocol section 43 compute additive sharing party minority parties learns information step 5 regard integers 0 p objective ensure integers know end step 4 therefore given candidate value 2 0 given correct 0 equality holds integers determine correct protocol proceeds step 6 possible value trial decryption step 6 succeeds step 6 assuming equality 1 holds integers know e divides see observe therefore party sets result determine value r trying possible values 0 r k trial decryption protocol leaks value r hence total 2 log k bits exposed value r found using one trial decryption gateway rst picks random message asks parties decrypt c party computes sends result gateway performing k multiplications gateway nds r 2 0 relates value r back parties x shares accordingly determine procedure repeated k candidate values recall k typically small eg less 10 note 61 observe step 5 protocol needed due fact bgw method carried modulo p however possible carry bgw protocol step 4 directly integers avoiding step 5 altogether done using variant shamir secret sharing integers see 21 22 let picks two polynomials follows constant terms set f coecients chosen random f0 g interacting parties party computes point polynomial integers points multiplied appropriate lagrange coecients become additive sharing integers unfortunately approach resulting shares private key order n 2 rather n protocol results factor two slowdown threshold signature generation positive side need leak value computation 1 mod e steps 13 based technique due beaver 2 63 toutofk sharing previous two subsections explain one obtain koutofk sharing however provide faulttolerance often desirable toutofk sharing enabling subset parties apply private key simplest solution due rabin 34 makes use generic technique converting koutofk sharing private rsa key toutofk sharing scheme rabins approach immediately applies koutofk sharing obtained optimizations describe several practical techniques improve performance distributed protocol optimizations incorporated implementation protocol 29 sieving step 1 protocol section 2 parties repeatedly pick random shared integer nd one divisible small primes engage interactive trial division protocol brie outline ecient approach let product odd primes less bound b 1 suppose k parties could generate additive sharing random integer z party could set share p random number appropriate length make p nbit integer resulting candidate prime random nbit integer relatively prime need run trial division protocol p primes less question remains parties generate additive sharing random integer 2 z party generates random element b 2 z random element z parties use bgw method section 43 convert multiplicative sharing additive sharing one caveat work bgw method must made work zm eld done explained section 42 load balancing step 3 primality test party 1 computes parties compute v notice n 1 roughly 2n bits bits consequently party 1 works twice hard parties even things makes sense test k candidate n parallel tests role party 1 played dierent party way g n1 mod n computed dierent party n results better load balancing improving performance factor two parallel trial division recall n computed parties perform trial division invoking distributed primality test step 2 section 2 k parties perform trial division parallel party charge verifying n divisible set small primes eciently done hardcoding primes range b list party charge testing n divisible primes p j j mod k factor k speedup enables us use large bound b 2 increasing eectiveness trial division fermat lter need run full primality test section 3 every candidate modulus n instead one fermat test rst proceed perform full test fermat test succeeds refer test fermat test equality hold n product two primes carry test zeroknowledge k parties compute v verify protocol easily shown k 1 private saves computation jacobi symbol g integers n avoiding quadratic slowdown section 2 noted protocols suer quadratic slowdown comparison single user generation rsa key main reason primes p q generated brie outline potential solution consider case three parties alice bob carol could generate n alice p r p nbit prime bob q b r b q b nbit prime carol r c number probes r found prime single user generation n hence able avoid quadratic slowdown furthermore single party knows complete factorization resulting n unfortunately approach doesnt scale well enable tprivacy n must product primes also note example parties must perform distributed primality test verify n product three primes techniques paper easily generalize enable test note one use recent results 7 test shared modulus product three primes without revealing factorization 8 robustness throughout paper use model parties honestly follow protocol ne parties honestly trying generate shared rsa key applications desirable make protocol robust active adversaries cheat protocol since rsa function veriable parties simply check correctly decrypt encrypted messages active adversaries limited amount damage cause however may still possible party cheat protocol consequently able factor resulting n similarly party cheat cause nonrsa modulus incorrectly accepted recently frankel mackenzie yung 22 showed protocol made withstand malicious parties protocol enables parties detect exclude malicious party practice one could run nonrobust protocol modulus n found believed product two primes robust frankelmackenzieyung protocol used determine majority parties cheated nonrobust phase results robust generation shared rsa keys see 5 describe simple method making nonrobust protocol robust number participants small eg less ten consider case four parties one malicious one run nonrobust protocol candidate modulus n found point protocol run four times triplet users rst run three parties writing 4 random integers range 0 n party 1 sends p 0 party values nonrobust protocol among three ignoring party 1 resulting n match n computed four parties involved n turns rsa modulus n rejected parties announce one misbehaving experiment repeated four triplets time exactly one party excluded computation assuming one party malicious resulting n must product two large primes furthermore malicious party cannot know factorization n since point protocol honest party reveal information share another single party note approach enables parties detect cheating help detecting malicious party general k parties engaged nonrobust protocol c malicious protocol made robust cost k c extra invocations resulting computation private clearly approach applied long k c small 9 summary open problems presented techniques allow three parties generate rsa modulus parties convinced n indeed product two primes however none factor n methods achieves b k 1c privacy also show show parties generate shares private decryption exponent allow threshold decryption test n product two primes presented distributed doubleprimality test note test recently extended tripleprimality test 7 enabling k parties test n product three primes without revealing information factors demonstrate eectiveness protocols implemented generating 1024 bits shared rsa key among three 300mhz pentium machines takes 90 seconds see 29 description implementation well detailed timing measurements important open problem generation shared keys special form example modulus product safe primes ie p 1and q 1are prime considered security purposes 27 well technical reasons related threshold cryptography 16 25 currently techniques enable shared generation moduli special form progress directions would helpful acknowledgments thank beaver helpful discussions results r universal classes hash functions number uncanceled elements sieve eratosthenes focs 1986 pp 162167 cocks multiplication method bgw protocol described section 41 achieves b k 1 2 c privacy information theoretically secure cocks 10 describes multiplication protocol heuristically appears provide k 1 privacy unfortunately cocks protocol far slower bgw method furthermore seem possible prove security using natural tr strong primes easy find play mental game prove practical solutions identification signature problems sharing homomorphisms keeping shares secret secret practical zeroknowledge protocol fitted security microprocessor minimizing transmission memory zeroknowledge proofs identity completeness theorems noncryptographic faulttolerant distributed computation multiparty unconditionally secure protocols knowledge complexity interactive proof systems noncryptographic faulttolerant computing constant number rounds interaction modification fiatshamir scheme practical protocol large group oriented networks fast signature generation fiat shamirmyampersandmdashlike scheme share function securely robust efficient distributed rsakey generation share secret two party rsa key generation secure computation abstract shared generation authenticators signatures extended abstract robust efficient sharing rsa functions simplified approach threshold proactive rsa generation shared rsa keys two parties efficient dynamicresharing verifiable secret sharing mobile adversary knowledge generation rsa parameters generating product three primes unknown factorization optimalresilience proactive publickey cryptosystems security fault tolerance communication complexity distributed systems ctr jaimee brown juan gonzalez nieto colin boyd efficient secure selfescrowed publickey infrastructures proceedings 2nd acm symposium information computer communications security march 2022 2007 singapore dan boneh xuhua ding gene tsudik finegrained control security capabilities acm transactions internet technology toit v4 n1 p6082 february 2004
improving adaptability multimode systems via program steering multimode software system contains several distinct modes operation controller deciding switch modes even developers rigorously test multimode system deployment cannot foresee test every possible usage scenario result unexpected situations program fails underperforms example choosing nonoptimal mode may arise research aims mitigate problems creating new mode selector examines current situation chooses mode successful past situations like current one technique called program steering creates new mode selector via machine learning good behavior testing successful operation strategy generalizes knowledge programmer built system may select appropriate mode even original controller cannot performed experiments robot control programs written monthlong programming competition augmenting programs via program steering technique substantial positive effect performance new environments b introduction software failures often result use software unexpected untested situations behave intended desired 18 software cannot tested every situation might used even exhaustive testing possi ble impossible foresee every situation test research takes step toward enabling software systems react appropriately unanticipated circumstances research focuses multimode software systems multimode system contains multiple distinct behaviors inputoutput relationships program operates different modes depend permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee july 1114 2004 boston massachusetts usa ing characteristics environment operation example web servers switch handling interrupts polling avoid thrashing load high network routers trade latency throughput maintain service depending queue sta tus load traffic patterns realtime graphical simulations video games select model object render detailed models object close point view coarser models distant objects softwarecontrolled radios cell phones optimize power dissipation signal quality depending factors signal strength interference number paths induced reflections compilers select optimizations perform based estimated runtime costs benefits transformation examples programmer first decided upon set possible behaviors modalities wrote code selects among modalities mechanism selecting modes fixed program coded hypothesize part programmers effectively accurately select modalities situations anticipate however selection mechanism may perform poorly unforeseen circumstances unexpected en vironment builtin rules selecting modality may inad equate appropriate test may coded even one existing behaviors appropriate best among available choices instance robot control program may examine environment determine whether robot building road open terrain select appropriate navigation al gorithm algorithm appropriate robot street construction damaged building designer may considered scenarios another example applicability software system relies sources information single sensor failure may destabilize system even correlated information available alternately correlations assumed domain expert may always hold aim provide flexible automatic ways select among modalities approach called program steering first train system correlating modes program inputs internal state use resulting models select modes run time select operating mode comparing systems current behavior systems observed behavior representative runs modes steering system similar mode effect extend programmers builtin knowledge analogous situations improve upon suboptimal overspecialized builtin decisions paper organized follows section 2 gives simple concrete example program steering process section 3 describes program steering detail including policies parts program steering tool section 4 presents experimental methodology results paper concludes related work current program state standard mode power saver mode sleep mode brightness battery 10 battery 02 battery 10 score 75 60 66 current program state standard mode power saver mode sleep mode brightness battery 10 battery 02 battery 10 score 75 80 66 figure 1 similarity scores three possible modes laptop display program given two different input program states properties boldface true current program state contribute similarity score section 5 future work section 6 summary contributions section 7 2 example section presents simple example program steering program steering starts multimode program illustrate four steps applying program steering training modeling creating mode selector integrating original program show augmented program performs example multimode system use hypothetical laptop display controller contains three modes standard mode power saver mode sleep mode suppose three data sources available controller program battery charge ranges 0 1 inclusive availability dc power true false brightness display ranges 0 10 inclusive original mode selection code need necessarily make use variables first step collects training data running program observing operation variety scenarios suppose training runs selected among successful runs test cases test harness ensures system performing desired good runs generalize second step generalizes training runs producing model operation mode suppose model operational abstraction see section 412 set mathematical statements program variables satisfied observed executions resulting models might standard mode power saver mode sleep mode brightness battery 02 battery 00 battery 00 battery 10 battery 02 battery 10 third step builds mode selector models characterize program operating desired run time mode selector examines current state program environment determines model closely matches current conditions one simple metric percentage properties model currently hold figure 1 illustrates use metric two situations brightness 8 battery charge 01 dc power available mode selector chooses standard mode similar situation dc power available mode selector chooses power saver mode fourth step integrate mode selector target system two examples new mode selector might replace old one possibly inspected human might invoked old one throws error selects default mode target system given controller capability invoke new mode selector system used hopefully new controller performs better old one particularly circumstances anticipated designer old one example battery dcpower variables inputs brightness internal output variable technique utilizes types variables examining inputs indicates original controller handled situation ternaloutput variables indicate whether mode operating expected example laptop become damaged brightness could never turned 4 reason prefer power saver mode standard mode 3 program steering program steering technique helping software controller select appropriate modality software system novel situation even software written situation mind approach develop models based representative runs original program use models create mode selector assigns program states modes augment original program new controller utilizes mode selector figure 2 diagrams fourstage program steering process 1 collect training runs original program program behaved desired 2 use dynamic program analysis machine learning build model captures properties mode training runs 3 build mode selector takes input program state chooses mode based similarity models 4 augment original program new controller utilizes new mode selector section describes turn policies steps program steering process concludes exploring several potential applications discussing limits applicability program steering figure 2 program steering process consists four steps executing original program produce training data generalizing executions model mode creating new mode selector based models augmenting programs controller utilize new mode selector 31 training modeling step generalizes training data mode selector bases decisions models therefore better training runs yield better overall performance training runs exercise bugs original program resulting models faithfully capture erroneous behavior therefore training runs exhibit correct behavior high quality performance test suite aids construction good models believe least important code coverage user might supply canonical inputs represent situations mode designed tested optimized alternately training runs collected executions test suite passing tests indicates proper behavior definition sometimes test suite specification available particularly nonfunctional requirements example modulelevel specifications may guarantee part system performs particular way overall system achieves goals case program run performance observed process performed manually domain expert automated objective function evaluating quality run danger evaluating endtoend system performance even though overall system may performed well particular run certain mode behaviors transitions may suboptimal reverse situation may also occur al ternately mode transitions may perfect bad luck overall performance failed meet acceptance threshold 311 counterexamples training runs also include counterexamples instances specific modes inappropriate information may help runtime indicate program made make poor mode selection additionally many machine learners require perform better supplied counterexam ples however depending target system useful counterexamples may difficult produce programmer tester thinks counterexample code likely updated correct oversight counterexamples definition come unforeseen circumstances noted good respectively bad overall system performance indicate every mode choice good respectively bad counterexamples used incorporated model additional models created bad executions mode latter case additional models describe pro grams environment behavior program operating one mode operating another one 32 modeling modeling step performed independently mode training data grouped according mode system moment data collected separate model built group training data result one model per mode use multiple models requirement technique could use single complicated model indicates properties mode creating smaller simpler models plays strengths machine learners model represents behavior target system particular mode abstracts away details specific runs indicate properties hold general specialized models could indicate properties mode mode switched specific mode program steering technique dictate models represented representation permitted long models permit evaluation runtime program states indicate whether state satisfies model preferably nearly state satisfies model modeling step may sound approximate sound generalization reports properties true observed execu tions soundness respect learners input data respect possible future executions approximate statistical generalization additionally reports properties usually true true observed executions nearly true example statistical generalization may able deal noisy observations occasional anomalies model may also indicate incidence characteristics deviations typical case techniques help handling base cases special cases exceptions errors 33 mode selection mode selector compares current program state environment inputs model selects mode whose model similar current state mode selector explicitly prepare unanticipated situations operate situation determine appropriate mode program steering works generalizes knowledge built program programmer possibly eliminating programmer assumptions noting unrecognized relationships machine learners evaluation function indicating far particular execution line model divides good bad runs another approach execute modeling step run time sufficiently fast compare runtime model directly preexisting permode models machine learners produce easily decomposable model stance abstraction particular mode list logical formulas evaluated similarity score model percentage true decomposable model permits assigning different weights different parts example properties could weighted depending often true training runs another example properties may important oth ers nonnull constraint may crucial avoid dereferencing stronger property may significant one subsumes x weakening property may important indicator change strengthening one weights could even assigned second machine learning step first step provides list candidate properties second uses genetic algorithms machine learning techniques adjust weights step could also find relationships properties perhaps two properties simultaneously present particularly important new mode selector likely differ original mode selector two key ways one way original mode selector richer way new mode selector richer first original mode selector written human expert humans may use domain knowledge abstractions available generalpurpose machine learner original mode selector may also express properties beyond grammar model machine learner express certain properties set called learners bias bias positive limits false positives irrelevant put increases understandability enables efficient processing bias negative inevitably omits certain properties concern whether model enables effective mode selection bias per se whether model would effective tasks second new mode selector may richer original mode selector example programmer typically tests limited number quantities order keep code short com prehensible contrast training runs collect information arbitrarily many measurable quantities target program automated modeling step sift find ones relevant result mode selector may test variables programmer overlooked impact mode selection decision even modeling step accesses quantities programmer tested may note correlations programmer strengthen tests programmer wrote general fashion 12 34 controller augmentation new mode selector must integrated program replacing modifying original controller controller decides invoke mode selector apply rec ommendations programs intersperse controller mode selector conceptually distinct one policy controller would continuously poll new mode selector immediately switching modes recom mended policy necessarily appropriate noted original mode selector new mode selector certain advantages whereas new mode selector may capture implicit properties old one new one unlikely capture every aspect old ones behavior furthermore expect anticipated situations old mode selector probably performs well another policy leave old controller intact substitute new mode selector old mode selector mode changes occur controller decided current mode completed suboptimal third policy retain old mode selector override specific situations example new mode selector invoked original program throws exception violates requirement assertion deadlocks times spends much time attempting perform task waiting event also old mode selector chooses passive default mode low confidence choice unable make decision alternately anomaly detection aims indicate unexpected event occurred typically provide recommended course action indicate use mode selector models provide kind anomaly detection finally software engineer use new mode selector verifying finetuning original system even new mode selector never deployed customers otherwise used prac tice example programmer examine situations two mode selectors disagree particularly new mode selector outperforms old one find ways augment original hand disagreements mode selectors may also indicate inadequate test suite causes overfitting modeling step applications section 1 noted several domains program steering might applied section describes three application areas routers wireless communications graphics detail experiments section evaluate another domain controllers autonomous robots combat simulation routers router ad hoc wireless network may modes deal failure neighboring node rebuilding routing table respond congestion dropping pack ets conserve power reducing signal strength respond denialofservice attack triggering packet filters neighboring routers difficult programmer determine situations adaptations appropriate 2 even know detect situations occur eg imminent denialofservice attack use load traffic patterns queue lengths similar properties may help refine systems mode selector communications softwarecontrolled radios cell phones optimize power dissipation signal quality changing signal strength selecting encoding algorithms based bit error rate amount interference number multihop paths induced reflections etc modern radio software 40 different modes 6 machine assistance selecting among modes crucial additionally radio must choose host audio compression algorithms instance vocoders work best noiseless environments voices low pitch others lock onto single voice poor conference calls music like software radio may able match observations current state reference observations made known operating conditions detect operating new environment eg room containing heavy electrical machinery subject malicious attack eg jam ming encountering program bug eg caused supposedly benign software upgrade graphics realtime graphical simulations video games must decide whether render detailed computationally intensive model coarser cheaper model whether omit certain steps texture mapping algorithms use rendering tasks recurse switch levels detail presently least highend video games decisions made statically model factors simple function objects distance viewer multiplied processor load although system contains many complex parameters typically users given single knob turn extremes fast coarse detail slow fine detail program steering might provide finergrained automatic control algorithm performance instance correlating speed relatively slow rendering algorithm metrics sophisticated number triangles texture 36 applicability approach noted program steering technique applicable multimode software systems programs selects among existing modes rather creating new ones note two additional limitations techniques applicability one regarding type modes regarding correctness new mode selector limitations help indicate program steering may appropriate first limitation steering effect discrete rather continuous adaptation techniques best differentiating among distinct behaviors selecting among based differences system whose output behavior varies continuously input case many analog sys tems approaches based techniques control theory likely perform better particularly since continuous systems tend much easier analyze model predict discrete ones second limitation change mode selector affect correctness may violate requirements system cause erroneous behavior note three ways satisfy constraint first system supplied specification invariants must maintained instance particular algorithm valid certain parameter posi tive controller check properties runtime reject inappropriate suggestions computation occurs modes problems may relatively rare second modes differ performance power time mem ory selecting whether cache recompute values selecting sorting algorithm use third exact answers always critical selecting model object render graphics system selecting audio compression algo rithm put another way steering treated like hint profiledirected optimization similar technique operates lower level abstraction 4 droid wars experiments order evaluate program steering applied robot control programs built part monthlong droid wars competition known mit 6370 competition run mits january independent activities period 27 teams 80 undergraduate graduate students competed 1400 prizes bragging rights next year 1 droid wars realtime strategy game teams virtual robots compete build base specified goal location game map team first builds base location wins failing winner team base closer goal location time runs team consists four varieties robot robots abilities differing degrees different robot types best suited communication scouting sentry duty transport robot abilities include sensing nearby terrain robots sending receiving radio messages carrying unloading raw materials robots attacking robots repairing damage constructing new robots traveling rebooting order load different control program robots 1 separate paper 13 describes another experiment used solutions research assignment mits embodied artificial intelligence graduate class assignment objective program simulated fish could selforganize school without communication avoiding rocks program steering applied best programs produced controllers well applied lowperforming programs programs highlevel modes results program steering also performed equally original programs modeling step unable make good generalizations program total lines ncnb lines modes properties figure 3 statistics droid wars subject programs total lines column gives number lines code original program ncnb lines column gives number non comment nonblank lines modes column gives number distinct modes robots team properties column gives average number properties considered mode selector mode simulated game driver permits teams robots compete one another virtual world robot hardware fixed players supply software controls robots programs written subset java lacks threads native methods certain features unlike realtime strategy games human intervention permitted play robots controlled entirely software written contestants furthermore single omniscient control program robots control program knows sense world learn robots team many participants wrote software different modes deal different robot types tasks terrain instance particular robot might different modes searching raw terials collecting raw materials scouting enemies attacking enemies relaying messages activities organizers encouraged participants use reboot feature also invoked beginning game whenever robot created switch one control program another another strategy write single large program different classes methods handled different situations programs clearly identifiable modes always used code behaved differently depending values local variables augmented programs teams 26 program steering figure 3 gives details programs teams place 7th 20th 14th 22nd 1st spectively among 27 teams roundrobin tournament using actual contest map conditions chose teams arbitrarily among could identify modes source code made training new mode selector applying possible 41 applying program steering described section 3 applying program steering robot control programs consisted four steps training modeling creating mode selector augmenting controller one time manual work required training controller augmentation steps primarily refactoring original programs isolate modes mode selector 411 training mode selection requires multimode program implementation program steering requires mode transition represented calling distinct method every method necessarily represents mode however read programs identify modes sometimes required simply noting names methods represented mode shifts cases modes embedded code refactored code without affecting functionality order make mode transitions method calls different implementation program steering would required refactoring step hypothesize mode identification refactoring necessary would relatively easy original authors code harder us still hours work lack documentation possibility subtle interactions robot ran virtual machine global variables frequently used forced us take special care affect behavior program collected training data running approximately matches variety opponents training performed original environment training take account environmental changes section 42 used evaluate new mode selectors attempt achieve complete code coverage measure code coverage ensure mode exercised retained runs matches team appeared perform properly according human observer purpose train good executions program wish capture poor behavior bugs though possible nonoptimal choices made bugs exposed runs human observer examine every action detail simply watched match progress takes well 5 minutes alternative would train matches team matches better expected another good alternative train test suite program presumably operates desired however none robot programs came test suite 412 modeling experiments modeling step carried completely automatically independently mode producing one model per mode current implementation uses daikon invariant detector httppagcsailmitedudaikon modeling chine learning step resulting models operational abstrac tions sets program properties expressed logical mulae associated method call represents mode transition section 2 gives simple examples operational abstraction syntactically identical formal specifi cation contain preconditions postconditions object invariants however operational abstraction automatically generated characterizes actual observed behavior system models included properties environmental inputs internal state variables described section 2 operational abstractions produced process called dynamic invariant detection 9 briefly generateandcheck approach postulates properties given grammar properties specified invariant detection tool variables quantities available program point parame ters global variables results method calls checks one program executions reports never falsified dynamic analysis quality results depends part well test suite characterizes execution environment results soundly characterize observed runs necessarily sound respect future executions program steering technique depend use operational abstractions dynamic invariant detection program steering utilize method extracting properties training input representation resulting properties long distance metric exists either models program state among models good suc int selectmode int double compute score mode 1 int mode1match 0 int brightness brightness 10 mode1match battery 02 mode1match battery 10 mode1match double double mode1match mode1total mode1score bestmodescore compute score modes return mode highest score return bestmode figure 4 automatically generated mode selector laptop display controller section 2 given section mode selector evaluates appropriateness displays standard mode cess dynamic invariant detection would worthwhile compare results using modeling strategies machine learners perform equally well certain characteristics dynamic invariant detection make particularly attractive program steering made one small program modification running modeling step quantities frequently accessed robot control programs available sequence several method calls placed outside socalled instrumentation scope tools would among quantities generalized daikon tool therefore placed quantities number allies nearby amount ore carried whether robot base variables make accessible tools 413 mode selection given operational abstractions produced modeling step tools automatically created mode selector indicates modespecific operational abstractions similar current situation tools implement simple policy selecting mode property modes operational abstraction evaluated mode largest percentage satisfied properties se lected strategy illustrated figure 1 figure 4 shows code mode selector implements policy choosing mode highest percentage matching properties 414 controller augmentation finally inserted automaticallygenerated mode selector original program determining appropriate places insert selector required manual effort akin refactoring noted section 411 replace old mode selector new one augmented new one new mode selector invoked program threw uncaught exception would ordinarily cause crash possibly reboot program got caught loop timeout occurred waiting event program executed actions repeatedly without effect additionally moments chosen random mode chosen execution interrupted better approach forcing mode exited reentered identifying locations inserting proper calls required human effort 42 environmental changes wished ascertain whether program steering improved adaptability robot control programs particular wished determine whether robot controllers augmented program steering mechanism outperformed original mode selec tors robots exposed different conditions originally designed tested pro gram steering affect behavior original environment augmented robots performed well unaugmented ones considered following six environmental changes listed order least disruptive causing difficulties 1 new maps original tournament run single map provided participants ahead time generated program part original droid wars implementation ran program create new maps obeyed contest rules ran matches maps change simulates battle different location armies trained augmented environmental changes listed one improve evaluation running single competition map would resulted neardeterministic outcomes many teams 2 increased resources amount raw material used repair damage build new robots tripled environmental change simulates battle moves known terrain new territory different characteristics 3 radio jamming robot radio range given transmission 50 chance correctly receiving message messages received delivered messages contained errors programs simply ignored corrupted messages environmental change simulates reduction radio connectivity due jamming intervening terrain solar flare activity causes 4 radio spoofing periodically enemy performs replay attack arbitrary moment robot receives duplicate message sent team either earlier battle different battle environmental change simulates enemy attack communications infrastructure spoofing reduces likelihood match progresses simulating discovery spoofing attack change encryption keys 5 deceptive gps occasionally robot trying calculate position navigate another location receives inaccurate data environmental change simulates unreliable gps data due harsh conditions enemy interference 6 hardware failures average every 1000 time units robot suffers cpu error reboot mechanism voked without loss internal state stored data structures assume held nonvolatile memory robots already support rebooting needed initialization often used switching among modes match lasts 5000 time units neither team achieved objective matches end less half time single time unit robot perform computation move additionally attack repair damage mine resources load unload reboot perform activities environmental change simulates adverse environment whether overheating cosmic rays unusually heavy wear tear enemy action circumstance might make hardware less reliable 43 evaluation evaluated new program running tournament original programs new environment running new tournament replaced original program augmented version tournament participants identical compared rank original program rank augmented program respective tournaments always compare ranks unmodified modified robots tournament run environment rank unmodified robot without program steering aug mentation new environment necessarily robot original environment different robots affected different ways environmental changes original mode selectors choices appropriate new environment original controller fails creation new mode selector may able improve situation modes appropriate new environment instance algorithms longer achieve goals amount improvement mode selector restore system good performance droid wars competition used doubleelimination tourna ment evaluation uses roundrobin tournament requires additional time run much larger number matches permits accurate ranking particular played team team approximately 10 times determined team games played multiple matches per pair teams match used randomlygenerated map described section 42 used summary results one per pair teams rank teams ranked teams according number teams team defeated figure 5 shows results set tournaments giving original rank team rank program steering upgrades positive results reported change column figure 5 might attributed two different sources might result highquality mode selector constructed technique might result highquality controller chooses use new mode selector exactly right situations latter explanation true getting robot program unstuck bad mode might major benefit mode se lectors choice would secondary importance investigate hypothesis evaluated another variant target programs identical upgraded versions except instead using mode selector used random mode selector indicated change rand columns figure 5 mode selector substantially outperformed random mode selector 44 discussion steering aided team26 least two reasons first team26 already performs well placed first actual tournament less opportunity im provement also uses simple control program leaves little room modification enhancement team26s robots rely centralized knowledge decisionmaking robots new maps program original upgraded change rand increased resources program original upgraded change rand radio jamming program original upgraded change rand radio spoofing program original upgraded change rand team26 26 26 0 deceptive gps program original upgraded change rand hardware failures program original upgraded change rand averages program original upgraded change rand 193 105 88 13 figure 5 difference performance original programs versions upgraded program steering original column gives tournament rank original team smaller better upgraded column gives rank separate tournament team upgraded program steering change column shows improvement ranking difference original upgraded columns rand column gives change ranking original column using new controllers random mode selector initially sweep across entire map forage raw materials replicate robots selforganize meeting designated location hardcoded time enough arrived mass attack communication required default location hardcoded robots program however robot discovers strategic meeting point location enemy base important enemy convoy notifies base relays message rest team use different architecture implement centralized intelligence base collects information decides strategy issues instructions robots nonbase robot control programs relatively simple designed primarily follow bases directives sometimes unable react appropriately unexpected situation arises robot contact base program steering essentially distilled simple autonomous programs automatically producing version consistent bases control program team17 uses time elapsed beginning battle determine switch modes assign initial modes modechange times carefully crafted overfit tournament rules specify 5000 clock ticks per match original developers created program performed well specific assumptions environment true program steering mode selector better equipped adapting changes extracting generalizing hardcoded knowledge training examples briefly discuss results new environments listed figure 5 new maps new maps environment differs marginally original one yet program steering substantially helps team20 investigating effect discovered programming error cause robots enter infinite loop robot discovers two caches raw materials close one another robot navigates one attempts pick one check whether attempt pick raw materials successful immediately returns base team maintains centralized stockpile base robot unloads cargo nothing case returns site raw materials since knows raw materials remain unsuccessfully attempts pick raw materials new controller eventually times infinite loop invokes new mode selector chooses different task robot preventing continuing fruitless repetition upgraded teams largely unaffected new maps new mode selectors usually agreed original mode selectors invoked increased resources original team04 team20 control programs assign modes robots based assumptions size army correlated resources available constructing units control programs suboptimal assumptions incorrect example many robots assigned search resources rather attack defend upgrade provides slight improvement hardcoded times original program worse given faster battle progression radio jamming team26s strategy depend radio messages radio jamming little effect teams per formance units use default rendezvous point launch effective attack teams centralized intelligence suffered significantly base could reliably issue commands less intelligent allies program steering robots autonomously chose mode consistent base instructed similar training examples remaining new environments hardcoded original strategy copes poorly adaptive mode selector continues perform well radio spoofing radio spoofing environment strong negative impact team26 program steering unable reverse spoofed messages replay attacks collected previous battles including ones different maps robots authenticate messages different robots received messages specifying different rendezvous points teams strategy hinged gathering large army disrupted spoofing new mode selector indicated something wrong attack mode usually involved many nearby al lies unfortunately hardcoded meeting time set late match time robots scattered enough time recover mistake program steering improve team26s overall performance environment deceptive gps program steering helped every team including team26 deceptive gps environment robots using original team26 control program arrive rendezvous point navigation systems inaccurate resulting weaker army misled robots upgraded controllers noticed lack nearby allies time travel relatively nearby intended destination teams centralized intelligence even serious problems deceptive gps en vironment completing task robots frequently returned back base await next instructions deceptive gps mislead robots traveling different location outside radio transmission range base would wait messages hopes ever receiving one upgraded controllers would trigger timeout mode selector would notice robot go home mode hardware failures many teams tournament including five upgraded expected program reboots base radio range nearby ally issued specific command hardware failures environment caused reboots occur situations sometimes causing hardware assume passive state default team20 drastically improved upgrades robots could frequently infer correct mode complete task hand team26 saw significant less substantial improvement attack phase strategy take effect late game requiring robots withstand several hardware failures team10 improve much many modes required certain preconditions met would fail course executing mode example reason enter go home mode without knowing location home preconditions discovered modeling step selector sometimes chose modes without preconditions satisfied mode selection weighted property equally team10 models contained many properties 200 per mode given refined mode selection techniques discussed section 33 preconditions carry weight observed another way program steering affected operation programs programs followed fixed sequence modes fixed order simple example picking ore robot might always return base even robot capacity pick ore along way even encountered vulnerable enemy robot new mode selector sometimes executed one modes without executing one even though always executed together training runs modeling step discovered additional connec tions gave robot program steering larger range behaviors original robot behaviors appear valuable ones even though original designers anticipated modes interacting way technique also create mode selector chooses mode transitions could never chosen example suppose original mode selector laptop display example section 2 follows battery 02 dcpower false return powersavermode else return standardmode selector never chooses sleep mode perhaps mode triggered manually user new mode selector figures 1 tests variable brightness original also choose mode existed system previously accessible instance display sleep turned brightness 0 might save even power power saver mode would 5 related work current approaches design adaptive software make difficult expensive build systems adapt flexibly wide variety range changes operating conditions also operate efficiently normal operating conditions approaches based control theory example require designers identify important system inputs outputs model precisely changes input behavior affect output behavior systems built using approaches generally operate efficiently normal neartonormal operating conditions fail adapt extreme unanticipated changes operating conditions approaches used intrusion detection require designers distinguish normal abnormal patterns use systems built using approaches deal poorly unanticipated patterns use approaches based fault tolerance require designers anticipate kinds numbers faults may occur although designers need model precise effects faults systems built using approaches may tolerate wider range changes operating conditions operate less efficiently normal conditions always prepared worst technique shares similarities profiledirected optimization 1 5 profiledirected feedbackguided optimization uses information previous runs instance set abstraction typically contains elements might represented list rather hash table two pointers rarely aliased may worthwhile check whether aliased load registers rather manipulate memory optimizations must checked run time unless affect correctness value profiling 3 4 examines values returned load instructions work higher level abstraction compare relationships variables data structures programming language rather level machine instructions example list usually sorted may worthwhile perform sortedness check invoking log n sorting routine respect work shares similarities work specificationbased program optimization 17 small amount automated theorem proving run time determines whether precondition satisfied using efficient specialized version particular procedure previous work program steering addressed interactive program steering provides humans capability control execution running programs modifying program state managing data output starting stalling program execu tion altering resource allocations like 11 8 goal typically performance human observation analysis intuition inherent approach contrast interested automatic program steering miller et al 15 discuss safely execute steering operations ensuring occur program transactions point program state consistent debenham 7 suggests checking properties similar anomaly detection order note mode inappro priate solution found human operator asked assistance reactive systems change behavior state response events environment changes typically programmed start likewise much research ai field automatically chooses among behaviors focuses lowlevel control activating motor rather selecting highlevel goal latter typically performed less adaptive highlevel control program explicit hardcoded hierarchy may indicate priority levels among modes hierarchy unlikely appropriate every circumstance liu et al 14 discuss problems incompatible mode specifications proposes constraint system solve improved performance simulated powercritical mars rover application ghieth 10 discusses policies intercepting object invocation rerouting invocations specific implementation richter et al 16 discuss selecting among modes operation system design enabling runtime switching automatically provide policies switching 6 future work preliminary experiments suggest least cir cumstances program steering generalize training runs create new mode selector significantly outperforms original system new environments however additional work required conclude technique applies realworld situations future research also indicate sorts programs environmental changes technique best worst handling believe preliminary results justify additional investigation outline directions future work first technique needs run programs programs types better indicate strengths weak nesses address major threat external validity current research suffers additionally survey application domains could indicate much realworld software domain easily refactored modes mode selector technique requires noted earlier believe applied enough real software worthy investigation design space program steering large section 3 partially explores evaluated one point space point appears provide good results points may even better eager try different modeling approaches particularly noiseresistant ones different mode selection techniques assigning different weights different parts model seems particularly promising different policies controller invokes new mode selector one challenge methodology achieving reasonable response time constructing model timeconsuming many machine learning techniques process happens offline cost evaluating model much lower may limiting factor resourceconstrained environments future work would like steer programs among existing modes also introduce new modes instance two situations yield different models perhaps system optimized two situations much profile directed optimization task require recognizing different states introducing optimizations based 7 conclusion proposed approach making software adaptable new situations designers developers may neither foreseen planned technique called program steering applicable multimode systems controller selects appropriate mode based inputs state program steering generalizes observations training runs software behaved well produces new mode selector given concrete program state selects mode whose past executions similar given state program steering reduces dependence developer assumptions controller take account instead new mode selector uses available information gathered modeling step technique requires domain specific knowledge human direction existing controller works well expected situations way determine test runs successful enough become training runs implemented program steering performed preliminary experiments evaluate efficacy applied program steering tool five multimode robot control programs realtime combat simulation evaluated new mode selectors six new environments use new mode selectors substantially improved robot performance measured ranking 27team tournament acknowledgments thank steve garland fruitful discussions aided conception clarification ideas program steering anonymous referees thoughtful comments pa per research supported part nsf grants ccr 0133580 ccr0234651 gift ibm r compiler transformations highperformance computing value profiling value profiling optimization using profile information assist classic code optimizations personal communication multiagent architecture process management accommodates unexpected performance objectbased infrastructure program monitoring steering dynamically discovering likely program invariants support program evolution annotated bibliography interactive program steering use self checks voting software error detection empirical study improving reliability adaptability via program steering constraintbased application model scheduling techniques poweraware systems representation function variants embedded system optimization synthesis using specialized procedures specificationbased analysis reduce runtime costs modularity automatic upgrades handson process tr use self checks voting software error detection using profile information assist classic code optimizations chaossupscrptarcsupscrpt kernel support multiweight objects invocations atomicity realtime multiprocessor applications annotated bibliography interactive program steering using specialized procedures specificationbased analysis reduce runtime costs modularity compiler transformations highperformance computing value profiling objectbased infrastructure program monitoring steering representation function variants embedded system optimization synthesis multiagent architecture process management accommodates unexpected performance constraintbased application model scheduling techniques poweraware systems dynamically discovering likely program invariants support program evolution multimodal network protocols onthefly calculation verification consistent steering transactions ctr jeff h perkins michael ernst efficient incremental algorithms dynamic detection likely invariants acm sigsoft software engineering notes v29 n6 november 2004 jinlin yang david evans deepali bhardwaj thirumalesh bhat manuvir das perracotta mining temporal api rules imperfect traces proceeding 28th international conference software engineering may 2028 2006 shanghai china
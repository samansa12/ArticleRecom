checking approximate computations polynomials functional equations majority results selftesting correcting deal programs purport compute correct results precisely relax notion correctness show check programs compute numerical approximation correct answer types programs deal computing polynomials functions defined certain types functional equations present results showing perform approximate checking selftesting selfcorrecting polynomials settling affirmative question raised p gemmell et al proceedings 23rd acm symposium theory computing 1991 pp 3242 r rubinfeld sudan proceedings third annual acmsiam symposium discrete algorithms orlando fl 1992 pp 2343 r rubinfeld sudan siam j comput 25 1996 pp 252271 obtain first building approximate selftesters linear multilinear functions show perform approximate checking selftesting selfcorrecting functions satisfy addition theorems settling question raised r rubinfeld siam j comput 28 1999 pp 19721997 cases show properties used test programs functions robust approximate sense stable finally explore use reductions functional equations context approximate selftesting results implications stability theory functional equations b introduction program checking introduced blum kannan bk89 order allow one use program safely without know apriori program correct inputs related notions selftesting selfcorrecting explored blr93 lip91 notions seen powerful practical point view cf bw94 theoretical angle cf as92 alm 92 well techniques used usually consist tests performed runtime compare output program either predetermined value function outputs program dierent inputs order apply powerful techniques programs computing real valued functions however several issues dealing precision need dealt standard model considers output wrong even small margin strong make practical sense due reasons following 1 many cases algorithm intended compute approximation eg newtons method 2 representational limitations roundotruncation errors inevitable realvalued computations 3 representation fundamental constants eg inherently imprecise framework presented glr accommodates inherently inevitable acceptably small losses information overlooking small precision errors detecting actual bugs manifest greater magnitude given function f program p purports compute f error bound jp x fxj denoted p x fx appropriate notion norm say p x approximately correct input x approximate result checkers test p approximately correct given input x approximate selftesters programs test p approximately correct inputs approximate selfcorrectors take programs approximately correct inputs turn programs approximately correct every input domains work nite subsets xed point arithmetic refer nite rational domains n l precision allow n vary generality domain let denote positive negative elements testing using properties many approaches building selftesters illustrate one paradigm particularly useful approach order test program p computes function f inputs test p satises certain properties f example consider function property fx f satises one might pick random inputs x verify p 2 clearly x p incorrect program however might quite incorrect still satisfy choices random inputs particular exists p instance p high probability p satises property random x hence pass test ii function satises property x p agrees function inputs thus see method used naively yield selftester works according specications nevertheless approach used good heuristic check correctness programs cod91 cs91 vai93 example property yield good tester consider linearity property functions mapping ns r form random sampling conclude program p satises property x shown p agrees linear function g inputs blr93 rub94 call linearity property property exhibits behavior robust property describe formally build selftester class f functions characterized robust property twostep approach introduced blr93 test p satises robust property property testing ii check p agrees specic member f equality testing success approach depends nding robust properties easy test lead ecient equality tests property pair hi e ns consisting equation f values function f various tuples locations hx k ns locations picked property hi e ns said char naturally extend mod function ns letting xmodk stand j modk x k 2 ns acterize function family f following way function f member f f nonzero measure e ns instance linearity property written f ns distribution hx 1 chosen randomly distribution 2 domain ns case hi e lin rg set linear functions ns adhere denition property throughout paper however simplicity notation appropriate talk distribution equality together instance intuitive express linearity property fx giving distributions x writing pair rst consider robust properties detail suppose want infer correctness program domain ns allow calls program larger domain ns xed function depends structure ideally would like n technical reasons allow ns proper much larger superset ns particular description size element ns polynomial description size element ns 3 use property selftester one must prove property roubust informally robustness property hi e ns implies program p p probability least 1 hx chosen distribution e ns function g 2 f agrees p 1 fraction inputs ns case linearity shown distribution e lin 11ns 11ns property 2 11ns ns robust 148 blr93 rub94 therefore tested p satises p probability inputs picked randomly e lin 11ns possible conclude p agrees linear function inputs 2 example choosing x 1 x 2 uniformly ns suces characterizing linearity prove robustness however rub94 uses complicated distribution describe 3 alternatively one could test program domain ns attempt infer correctness program inputs dn 0 0 dn 0 0 large subdomain ns ns somewhat involved denition robust given rub94 given function n ns large enough subset ns paper say property robust 0 1 n property robust consider equality testing recall determined p satises robust property equality testing determines p agrees inputs specic member f instance case linearity ensure p computes specic linear function inputs perform equality test ensures x neither property test equality test sucient testing program however since x function satises linearity property equality property combination property test equality test shown sucient constructing selftesters combined approach yields extremely ecient testers make o1 calls program xed programs computing homomorphisms eg multiplication integers matrices exponentiation logarithm idea generalized rub94 class functional equations called addition theorems shown useful selftesting addition theorem mathematical identity form 8x addition theorems characterize many useful interesting mathematical functions acz66 cr92 g algebraic used characterize families functions rational functions x e cx doubly periodic functions see table 1 examples functional equations families functions characterize reals polynomials degree characterized via several dierent robust functional equations eg bfl91 lun91 alm approximate robustness stability program works nite precision properties upon testers built rarely satised even program whose answers correct required hardwarewise maximal number digits since involve strict equalities thus testing one might willing pass programs properties approximately satised relaxation tests however leads diculties approximate setting 1 harder cot ax fxfy 2fxfy cos sin ax sin axa fxfy 2fxfy cosh sinh ax sinh axa ax fxfy2fxfy cosh sinh ax sinh axa ax x table 1 addition theorems form fx analyze function families solutions robust properties 2 equality testing dicult instance obvious family functions would satisfy approximate linearity property x 2 ns approximate equality property construct approximate selftesters approach rst investigate notion approximate robustness property used rst require notion distance two functions denition 1 chebyshev norm function f domain fjfxjg domain obvious context drop given functions f g distance kf gk next dene approximation function another denition 2 function p approximates f domain kp fk least 1 fraction approximate robustness natural extension robustness property say program satises property approximately property true program exact equalities replaced approximate equalities consider linearity property program p satises property approximately ie p fraction choices hx ns approximate robustness linearity implies exists function g choice 0 00 2approximates p ns general would like dene approximate robustness property following program p satises equation approximately choices inputs according distribution e ns exists function g approximately inputs chosen according e ns ii approximates p inputs ns function relating distributions used describing behaviors p g depends required uniformly turingcomputable give formal denition approximate robustness denition 3 approximate robustness let hi e ns characterize family functions f domain ns let f 0 family functions satisfying approximately inputs chosen according e ns property hi e ns function family f 0 approximately robust 8p pr x 1 x k 2e ns implies approximates p ns g know property approximately robust second step analyze stability property ie characterize set functions f 0 satisfy property approximately compare f set functions satisfy property exactly hyersulam stability linearity example problem following given satisfying gx domain homomorphism h 0 depending size domain answer armative say property stable following denition denition 4 stability property hi e ns function family f ns n 0 stable 8g satises g 0 tuples nonzero support according e ns function h satises support according e n 0 0 kh gkd n 0 0 property approximately robust stable 4 used determine whether p approximates function desired family furthermore method approximate equality testing construct approximate self tester previous work previously many known checkers extended approximate case often rather straightforward extend robustness results show approximate robustness however diculty extending checkers appears lie showing stability properties issue rst mentioned glr approximate checkers mod exponentiation logarithm constructed domain assumed closed results domain said closed operation range operation subset domain instance nite precision rational domain closed addition abc 93 approximate checkers sine cosine matrix multiplication matrix inversion linear system solving determinant given domain assumed closed results sine cosine bw95 approximate checker oatingpoint division given sud91 technique uses approximation theory presented test univariate polynomials degree 9 left open glr whether properties used test polynomial hyperbolic trigonometric functions used approximate setting instance showing stability functional equations obvious functional equation involves division large numerator small denominator small additive error denominator leads large additive error output signicant work stability specic functional equations stability linearity homomorphisms addressed hye41 for80 fs89 cho84 techniques used prove results however cease apply domain closed stronger property stability nonclosed space called local stability 4 associated distribution needs sampleable addressed skof sko83 proves cauchy functional equations locally stable nite interval r problem stability univariate polynomials continuous domains rst addressed ab83 problem local stability r solved gaj90 see for95 survey results extend obvious way nite subsets r thus cannot used show correctness selftesters extended error bounds obtained naive extensions optimal dierent approach allows us operate ns obtain tight bounds results paper answer questions glr armative giving rst approximate versions testers rst present approximate tester linear multilinear functions tight bounds results apply several functions including multiplication exponentiation logarithm nonclosed domains next present rst approximate testers multivariate poly nomials finally show approximately test functions satisfying addition theorems results apply many algebraic functions trigonometric hyperbolic functions eg sinh cosh results apply nonclosed discrete domains since functional equation r constraints functional equation ns may happen functional equation r characterizes family functions proper subset functions characterized functional equation ns limit ability construct selftesters programs functions due equality testing performed selftesters show results prove new local stability results discrete domains techniques showing stability multilinearity dier used previously 1 require domain discrete 2 require range complete metric space allows us apply results multivariate polynomial characterizations addition new combinatorial arguments employ tools approximation theory stability theory techniques appear generally applicable cleaner work previously used selfcorrectors built taking advantage random selfreducibility polynomials functional equations blr93 lip91 exact case glr 91 employ similar idea approximate case making several guesses answer returning median output show guess within correct answer high probability median yields good answer high probability build approximate checker functions combine approximate selftester approximate selfcorrector blr93 organization section 2 addresses stability properties used test linear multilinear functions using results section 3 considers approximate selftesting polynomials section 4 addresses stability robustness functional equations section 5 illustrates actual construction approximate selftesters selfcorrectors 2 linearity multilinearity section consider stability robust properties used test linearity multilinearity nite rational domain ns results section addition useful testing linear multilinear functions crucial results section 3 glr 91 approximate robustness easy show appropriately modifying proof robustness rub94 involves replacing exact equality approximate equality keeping track error accrued step proof show stability use two types bootstrapping arguments rst shows error bound small subset domain implies error bound larger subset domain second shows error bound whole domain implies tighter error bound domain results applied give rst approximate selftesters several functions ns including multiplication exponentiation logarithm section 22 21 approximate linearity following denes formally means function approximately linear denition 5 approximate linearity function g approximately linear ns hyers hye41 skof sko83 obtain linear approximation approximately linear function domain r see appendix approach methods extendible discrete domains suppose dene h 1 0approximately linear case exact linearity since induction elements ns show approach typically used prove suciency equality test however approximately linear case 6 0 using inductive argument yield linear function h h quite unattractive since error bound depends domain size thus problem obtaining linear function h whose discrepancy g independent size domain nontrivial glr 91 solution given domain nite group technique requires domain closed addition therefore work ns give brief overview scheme glr 91 point breaks nonclosed domains existence linear h close g done glr arguing suciently large error least maximum error point x would imply even bigger error 2x contradicting maximality assumption error x crucial assumption x 2 implies 2x 2 step fails domains closed addition instead employ dierent constructive technique obtain linear h ns given approximately linear g technique yields tight bound 2 error e h g instead 4 sko83 require domain closed addition important achieve best lowest constants possible error results used section 32 constants aect error exponential way following lemma shows construct linear function h within approximately linear function g ns lemma 6 let g approximately linear function ns let h linear ns proof prove contradiction 8x 2 argument made show ex recall n greatest positive element domain note e approximately linear function assume exists point ns error greater maximal element p lie n 2s n otherwise ns would error greater 2 contradicting maximality p let p eq also x 2 p n ns denition p ex note x written satisfy approximate linearity property ex 0 must error strictly less know points interval 0 q error strictly less 2 point q error strictly less putting two facts approximate linearity together since x 2 q 2q written q conclude point q 2q error 2 repeat argument taking 0 2q rather 0 q bound error interval 0 3q 2 continuing argument eventually interval contains point p means p error 2 contradicts initial assumption ep greater 2 addition since e0 generalize error bound ns ns lemma 7 function g approximately linear ns h e dened je n proof observe error upper bounded 0 n 2s e2x also jexj je xj ns bound error ns rst 3 observations ex 4 2s 2s assume 9x 2 ns minimal point p n 2s otherwise error 2p would exceed 3 point highest error ns maximal one tie consider possible locations bound et 1 n 2s ensure e2t et et 2s 2s therefore satisfy bound et 2s therefore satisfy bound et 2 regardless lies et hence error ns bounded however e n ns contradicts bound established therefore cannot point ns error greater argument used bound negative error reduce error bound 2 assume p minimal point ns error least 2 proof similar previous stage using tighter bound ex 2s stay case 2 therefore error cannot exceed contradiction following special case proves stability result linearity corollary 8 linearity property ns ns proof suppose function g approximately linear ns set h n 7 uniquely denes linear h intuition drives us set h n proof corollary 8 follows consider following function g n integer part number easy see gxy gxgy set h 1 obtain h n kg hk growing function n way bound error points following example shows error bound obtained corollary 8 using technique tight shown construct linear function h kh gk 2 show function g given method constructing h asymptotically approaches bound dene g follows 3xn easy see g approximately linear x construction sets 0 zero function however kg large enough n 22 approximate multilinearity section focus attention multilinear functions multivariate function multilinear linear one input inputs xed multilinear function k variables called klinear function example bilinear function multiplication bilinearity property stated concisely distributive property multiplication respect addition special case multilinearity natural extension class functions class approximately multilinear functions formally dened denition 9 approximate multilinearity kvariate function g approximately klinear k ns approximately linear ns variable instance approximately bilinear 8x 1 generalize lemma 7 approximately klinear functions let g approximately klinear function h multilinear function uniquely dened condition h n g e approximately klinear function since g takes k inputs ns consider input g coordinate set possible ktuples inputs g form 2n dimension k show point theorem 10 approximate klinearity property k words function g approximately klinear k ns exists klinear h ns kh gk 2k proof h dened e n first argue points one coordinate dierent n fix k 1 inputs n hardwire g vary one say x operation transforms g approximately klinear function x approximately linear function x lemma 7 function cannot error 2 ns therefore je n next consider points two coordinates dierent n consider without loss generality input b n result argued know e n 2 xing inputs 2 k b n varying rst input lemma 7 jea b n j 4 2 ns via symmetric arguments bound error 4 two inputs dierent n continuing way shown inputs error 2k following theorem shows error reduced 1 constant 0 imposing multilinearity condition larger domain 0 tting multilinear function h jd 0 d2ke note doubling domain size involves adding one bit representation domain element theorem 11 0 approximate multilinearity property k stable proof theorem 10 g 2kclose klinear h 2kns x x coordinates except x argue ith coordinate ms rst show jexj dms jexj m2s observe note x 2 m2s 2x 2 ms therefore function satisfy exex e2x implies jexj 2 thus general maximum error m2 error 2kns 2k error ns 1 choice parameters multilinear case make similar argument using points least one coordinate x within smaller half axis note since h multilinear also symmetric test programs purportedly computing polynomials tempting 1 interpolate polynomial randomly chosen points 2 verify program approximately equal interpolated polynomial large fraction inputs since degree kvariate polynomial leads exponential running times furthermore obvious error bounds independent domain size obtained test uses evenly spaced interpolation identity rs96 0 identity computed method successive dierences never explicitly interpolates polynomial computed program thus giving particularly simple ecient od 2 operations test show interpolation identity approximately robust modifying robustness theorem rs92 section 33 proof stability interpolation identity section 32 however uses characterization polynomials terms multilinear functions previously applied program checking turn allows us use results stability multilinearity section 22 ideas stability theory section 34 extends techniques multivariate polynomials 31 preliminaries section present basic denitions theorems use dene standard forward dierence operator let r z r 1 fx following simple facts concerning operator facts 12 following true dierence operator r 1 r linear rf 2 r commutative r 1 3 r 1 2 let x k denote z x kary symmetric f let f diagonal restriction use three dierent characterizations polynomials mo34 dji69 following equations valid inputs f must 5 fact 13 following equivalent 1 8x 2 k x k 2 3 exist symmetric klinear functions f k 0 k 8x 2 f following denitions motivated notions using evenly unevenly spaced points interpolation denition 14 strong approximate polynomial function g called strongly approximately degree polynomial 8x gxj denition 15 weak approximate polynomial function g called weakly approximately degree polynomial 8x n x gxj 32 stability polynomials first prove function strongly approximately polynomial polynomial 2 lg 0approximates next show function weakly approximately polynomial domain coarser subdomain function strongly approximately polynomial combining two show function weakly approximately polynomial domain subdomain 5 due denition r operator inputs may sometimes slip outside domain stipulated equation must hold function approximates polynomial using theorem 11 bring error arbitrarily close assuming hypothesis large enough domain order pass programs err 0 need set strongly approximate case one must careful dening polynomial h close g instance dening h based values g points work proceed modifying techniques ab83 gaj90 using following fact fact 16 function f symmetric klinear r 1 f following theorem shows stability strong approximate polynomial property theorem 17 strong approximate polynomial property nd2s ns stable words g strongly approximately degree polynomial nd2s degree polynomial h kg h k dns o2 lg proof hypothesis g strongly approximately degree polynomial nd2s fact xt 1 rest proof uses modied hypothesis works ns induct degree modied hypothesis 8x 2 constant done suppose lemma holds degree strictly less 1 modied hypothesis using fact 12 modied hypothesis jr 1 0 symmetry dierence operator eect approximate symmetric dlinear function ns say gt multilinearity guarantees symmetric dlinear h kg hk 2d let x x 2 ns 8x xj denition g 0 xj triangle inequality xj denition r xj denition g denition h modied hypothesis g apply induction hypothesis g 0 satises hypothesis larger error induction guaranteed existence degree 1 polynomial h 1 kg 0 h 1 k e 1 0 set h fact 13 characterization polynomials h degree polynomial e unwinding recurrence nal error kg h weakly approximate case rst need following useful fact dji69 helps us go equally spaced points unequally spaced points fact using fact obtain following theorem let dg theorem 19 g weakly 2 d1 approximately degree polynomial nd1sd1 g strongly approximately degree polynomial ns proof choice parameters 0 therefore jr d1 33 approximate robustness polynomials section shows interpolation equation degree polynomials sense approximately robust results subsection modications exact robustness polynomials given rs92 let d1 selftest p ns use following domains domains used technical reasons become apparent proofs theorems section use pr x2d denote probability event x chosen uniformly domain 1 d2ns 2 3 assume p satises following properties tested sampling 1 pr 2 0 j 3 0 f obtain following theorem shows approximate robustness polynomials let e ns distribution ips fair threesided die outcome 2 f1 2 3g chooses inputs according distribution given ith equation let ns union domains used properties theorem 20 interpolation equation inputs picked according distribution approximately robust rest section devoted proving theorem markovs inequality gs denition properties p easy show p 2approximates g theorem 21 program p satises three properties 2 set prove g weakly approximate polynomial let p otherwise two domains b subsets universe x let call domains close b 1 following fact simple fact 22 x 2 d2ns domains j fx x domains ij fx following lemma shows sense g welldened lemma 23 x 2 d2ns pr proof consider l xed 0 j using properties p jk fxjt 2 close fact 22 get prp summing 0 noting using lemma 45 show relaxation twice error probability lower bounds probability rst part lemma second part lemma follows rst via simple averaging argument following theorem completes proof g weakly approximate degree polynomial theorem 24 x 2 d2ns 8i pr jr d1 proof theorem 21 lemma 23 closeness ij fx imply summing latter expression putting together rst part lemma second part follows rst part fact j ft appropriate choice 1 2 g weakly 2 d3 approximately degree polynomial ns g 2approximating p ns 34 multivariate polynomials following approach illustrated bivariate polynomials easily generalize multivariate polynomials easy show approximate robustness holds interpolation equation rs96 used section 33 axis parallel line xed horizontal line set points l zg vertical line dened analogously consequence approximate robustness bivariate function gx strongly approximately degree polynomial along every horizontal vertical line use consequence prove stability characterization use fx bivariate polynomial assume degree x range space degree univariate polynomials x value g x strongly approximately degree polynomial using univariate case theorem 17 exact degree polynomial p x x gx 2 lg p x construct function g 0 x xed x ie vertical line using r 1 d1 gx 0 bivariate function along every horizontal line exact degree polynomial along every vertical line strongly 0 approximate degree polynomial interpreting g 0 x g 0 x using idea univariate case conclude rt symmetric approximate dlinear function used fact g 0 x rest argument theorem 17 goes proofs approximate linearity lemma multilinearity theorem 10 assume range metric space true pd x say chebyshev norm result follows characterization bivariate polynomials 4 functional equations extending technique lemma 7 addition theorems fx straightforward since g arbitrary function order prove approximate robustness section 43 several related properties g required proving g satises individual one tedious however notion modulus continuity approximation theory gives general approach problem show bounds modulus continuity imply bounds quantities g require stability g shown careful inductive technique based canonical generation elements ns section 42 scope techniques limited addition theorems also show jensens equation approximately robust stable section 424 41 preliminaries addition theorems assume g algebraic symmetric function latter true general technical assumptions rub94 need notion smoothness g following notions wellknown approximation theory lor66 tim63 denitions 25 moduli continuity modulus continuity function f dened domain following function 2 0 modulus continuity function f following function x 2 0 partial moduli continuity function f following functions 2 sup sup present facts easily proved facts 26 following true modulus continuity 1 2 3 f 4 f 0 derivative f exists bounded 5 7 f symmetric f 8 b x partial derivative f respect x f f need notion inverse g gx since g symmetric g 1 2 denote g 1 z example wherever necessary illustrate scheme using functional equation solution functional equation constant c following fact tit47 useful locating maxima analytic functions fact 27 maximum modulus principle f analytic compact region f attains extremum boundary bounded rectangle analytic hence fact 27 attains maximum boundary g 2 c 1 l u ie continuously dierentiable g 0 decreasing function x fact 27 kg 0 attains maximum therefore using 26 42 stability functional equations section prove assumptions function g satises functional equation approximately everywhere close function h satises functional equation exactly everywhere functional equations form example gx valid x function h hx valid x hx 0 gx valid x domains valid values x well relationship 0 discussed later ns following sections show construct function h close g satisfying particular functional equation given h let ex denote consider cases c 1 rst show obtain h obtain bounds ex conclude h satises functional equation everywhere also approximates g ie functional equation stable call x even resp odd x even resp odd 421 c 1 rst construct h setting h 1 determines h values fact h satises functional equation obtain relationship error x 2x using functional equation lemma 28 e2x cex proof using denition modulus continuity jh 1 explore relationship ex 1 ex simplicity let h j constant proof ex j show scheme bound ex x 1 scheme thought enumeration strategy step process certain constraint equations satised first show canonical listing elements ns construct binary tree k following manner nodes tree labeled elements ns root tree labeled 1 x label node 2x label left child 2x already tree x label right child x already tree using induction prove k contains elements ns induction k tree obvious suppose requirement build k follows every leaf label k 1 left child 2x added left child right child 2x added assumption k 1 k nodes n2s moreover left child generates even element 2 k 1 right child generates odd element 2 k corollary k x even except root x left child x odd x right child canonical way listing elements ns arises preorder traversal k ordering used inductive argument lemma 31 x ns x even ex 1c proof prove induction preorder enumeration tree given ordering let x next element enumerated preorder listing parent already enumerated hence error known even corollary 30 left child hence generated 2y operation hence ey 2 induction hypothesis together lemma 28 yields ex cey preserving induction hypothesis odd corollary 30 right child hence generated induction hypothesis together lemma 29 1 yields ex dey 1c preserving induction hypothesis yields assumptions made c following theorem theorem 32 addition theorem stable example h 1 h 0 thus 1 theorem 32 ex 4 x ns n power 2 argue following manner proof see use specic values x approximate functional equation first extend ns nearest power 2 get 0 dene values g new points even x 2y let odd x thought new assumptions g satised exactly ie without error use lemma 31 conclude linear h 0 2 close g hence h close g even ns argue ns pick pivot point ns 0 simplicity h therefore e x 1 error longer bounded case c 1 let cd see structure k maximum error occur 2 k 1 simple induction depth tree error given e e 1 obtain constant error bound geometric summation otherwise obtain 422 c 1 case require additional assumptions dene quantity note f c 0 1 addition theorem used x h 1 welldened let rst obtain relationship error x 2x using addition theorem lemma proof lemma 28 jh 1 denition assumption get ex simplicity let h 3 x let h 3 constant following lemma proved easily lemma 34 ex de 2 k construction adopt strategy similar one previous section construct binary tree k following manner nodes tree labeled elements ns root tree labeled 2 k x label node x even x2 label left child x2 already tree 2 k x label right child 2 k x already tree easy see k contains elements ns corollary except root x left child x x right child use preorder enumeration ns using k following inductive argument lemma 36 x 1 ex 2c 0 proof proof induction preorder enumeration tree given ordering uses lemma 34 corollary 35 similar avor proof lemma 31 yields assumptions c following theorem theorem 37 addition theorem case arises linearity h 1 2 using theorem get weaker bound ex 3 opposed 2 corollary 8 similar techniques previous section used argue ns case 1 handled schemes previous section 423 case means h words fact 26 kh 0 1 fact 27 maximum occurs boundary domain hence test looking subdomain maximum less 1 424 jensens equation jensens equation following 8x 2 ns f fxfy solution functional equation ane linearity ie constants b jensens equation proved approximately robust modifying proof robustness rub94 show modied version technique proving stability 8x 2 ns g xy gxgy prove stability equation construct ane linear h note two points necessary sucient fully determine h set h n lemma 38 e xy ex2 proof e following corollary immediate corollary proof since construct slightly dierent tree k case root k labeled n x label node x2 integral already present label left child n integral already present label right child easy see k contains elements ns theorem 40 jensen equation proof proof induction enumeration order k given say breadthrst traversal clearly root e n 2 ex 2 consider children left resp right child exists x2 resp 2 thus corollary 39 e x 43 approximate robustness functional equations glr 91 rs92 test program 2ps make conclusions ns relationship p n determined later domain g analytic therefore consider case f bounded 2ps ie g family functions f satisfy following conditions 1 pr x2d 2ps 2 pr x2d 2ps 3 pr xy2d2ps 4 pr note membership g easy determine sampling dene distribution ns p satises functional equation e ns probability least 1 p also satises following four properties 1 pr xy2dps 2 pr xy2d ps 3 pr xy2d ps 4 pr x2dns y2dps e ns dened ipping fair foursided die outcome 2 f1 2 3 4g choosing inputs according distribution given ith property recall fact 26 b show following theorem 41 addition theorem distribution e ns approximately robust dene x 2 ps inequality denition g properties p easy show following lemma 42 pr x2dns gx p x 1 2 proof consider set elements ns pr y2dps p x gp x 1 fraction elements 2 contradicts hypothesis p pr x2dns y2d ps p x gp rest least half ys p x gp dening g median ys ps elements simplicity notation let p x denote p x x 2 ps g xy denote gp x p x 2 ps since g xed drop g modulus continuity let fact 43 x 2 2ns pr y2d ps x lemma 44 x 2 2ns pr proof pr note x z z random error rst step due computation p x 0 equation holds probability 1 hypothesis 3 bounds g x zz also hold probability least 1 2 hypotheses 3 4 error 0 loss 2 probability x z ps fact 43 next line rewriting similar manner nal equation holds probability least 1 hypothesis 2 error bound 0 bounds random points hold probability least 1 8 hypotheses b p make error 0 hence total error fact 26 equality holds probability least 1 12 2 following lemma helps us bound error ks95 lemma random graph edges inserted probability graph probability randomly chosen node largest clique proof let p crucial observation clique number g 2 least big maximum degree g hence random node x probability x present largest clique g 2 probability x connected maximum degree vertex say g let degrees vertices g 1 p degree 1 probability x edge 1 p probability edge two random nodes 1 p lemma follows following shows sense g welldened lemma 46 x 2 2ns pr y2d ps gx 2 0 g x yy proof following x 2 2ns pr yz2d ps g x yy 0 g x zz use lemma 45 g denotes graph z edge g x yy 0 g x zz g 2 denotes graph z edge g x yy 2 0 g x zz using lemma 45 number elements 2 0 away largest clique 2 thus least 1 2 elements within 2 0 12 since gx median lemma follows following theorem completes proof g satises addition theorem approximately theorem 47 probability least 1 g proof pr uv2d ps 0 g uxy u lemma 46 rst equality holds probability 1 error 2 bounds g ux u hold probability least 1 4 make error 2 fact 26 second third equalities always true fourth equality holds probability least 1 hypothesis 1 p error accrued 0 0 bounds p probability least 1 10 make error 0 0 fth equality also holds probability least 1 2 hypothesis 1 p error accrued 0 bounds p probability least 1 4 nal equality holds probability least 1 12 2 lemma 46 error thus total error 9 g fact 26 hence using fact 26 0 b 156 p 11n 1 56 9 0 lemma true probability 1 case example function already calculated b hence 5 approximate selftesting selfcorrecting 51 denitions following modications denitions glr capture idea approximate checking selftesting selfcorrecting formal manner let p program f ns input p condence parameter denition 48 approximate result checker f probabilistic oracle program given p x 2 ns satises following 0approximates f ns prt p outputs pass 1 2 outputs fail 1 denition approximate selftester f probabilistic oracle program given p satises following 0approximates f ns prt p outputs pass 1 2 p 2 approximate f ns prt p outputs fail 1 observe property approximately robust ns n 0 stable possible equality testing function family satisfying property possible construct denition 50 0 ns ns approximate selfcorrector f probabilistic oracle program sc p f given p approximates f ns x 2 ns outputs sc p f x prsc p note selfcorrector yield 52 constructing approximate selfcorrectors illustrate build approximate selfcorrectors functional equations approach subsection follows blr93 glr selfcorrector sc p f input x constructed follows obtain condence 1 choose random points 2 let sc p f x median gp assumption calls p within f probability greater 34 case value gp g away fx see section 41 b g using cherno bounds see least half values gp 0 away fx thus median sc p f x also 0 away fx degree polynomials similar selfcorrector works order pass good programs almost best 0 possible using evenly spaced interpolation equation since coecients interpolation equation e using interpolation equations use evenly spaced points seem require 0 dependent size domain 53 constructing approximate selftesters following selftester function satisfying addition theorem fx computing function family f ns use notation section 41 obtain condence choose random points x omaxf1 48g ln 1 verify assumptions program p beginning section 43 p passes test using cherno bounds approximate robustness stability property guaranteed p approximates function f next perform equality test ensure p approximates given f 2 f assume f 1 modifying proofs section 42 one show constant sc p 1 error sc p f f bounded constant rest ns since sc p approximates p correctness selftester follows polynomials use random sampling verify conditions program p required approximate robustness given beginning section 33 p satises conditions using approximate robustness stability evenly spaced interpolation equation p guaranteed approximate degree polynomial h perform equality test determines p approximates correct polynomial f assume tester given correct value polynomial f evenly spaced points x using selfcorrector sc p f section 52 ksc p equality tester tests x call input x bad jfx hxj x bad jfx sc p x sample point x bad test would failed dene bad interval sequence consecutive bad points test passes bad interval domain length 2n longer interval would contain least one sample point two sample points immediately preceding following bad interval satisfy jfx hxj 00 implies must local maximum f h degree polynomial inside bad interval since extrema f h bad intervals total number bad points d2n 1 thus 1 fraction ns sc p f error arguments generalized kvariate case partitioning kdimensional space cubes 54 reductions functional equations section explores idea using reductions among functions bk89 abc obtain approximate selftesters new functions consider pair functions f interreducible via functional equations suppose approximate self tester f 1 let exist continuous functions f f 1 f 2 given program p 2 computing f 2 construct program p 1 computing selftest p 1 suppose p 1 close f 1 large portion domain every x p 1 x close f 1 x bound deviation bound righthand side constant least portion domain bound maximum deviation 0 p 2 f 2 idea used give simple alternative approximate selftesters functions like sin x cos x sinh x cosh x reduced e x suppose given want approximate selftester function f 2 given f 2 x euler given program p 2 supposedly computes build program p 1 e ix given p 2 cos x selftest p 1 let range f 1 equipped following words case jp 1 x e ix metric ensures p 1 erroneous x p 2 erroneous least one x x32 alternatively cancellation errors suppose p 1 say fraction bad domain p 1 errors occur places p 2 invoked hence fraction domain p 2 bad rest domain p 1 1 close metric implies p 2 also 1 close f 2 thus p 2 similarly suppose p 1 good least 2 fraction domain p 1 2 close f 1 thus points domain least one points p 2 called denitely 2 2close f 2 thus p 2 therefore approximate selftester f 2 approximate selftester f 1 given glr acknowledgements would like thank janos aczel u waterloo peter borwein simon fraser u gian luigi forti u milan sivakumar suny bualo madhu sudan ibm yorktown nick trefethen cornell u suggestions pointers r lectures functional equations applications functions bounded nth dierences checking approximate computations reals proof veri probabilistic checking proofs new characterization np designing programs check work software reliability via runtime resultchecking journal acm volume44volumeissue6issuepages826849pages ections pentium division bug functional equations modeling science engineering stability problem generalized cauchy type functional equation performance evaluation programs related real gamma function use taylor series test accuracy function programs representation theorem existence stability theorem class functional equations stability homomorphisms completeness local stability functional equation characterizing polynomial func tions stability linear functional equation new directions testing approximation functions power interaction grundlegende eigenschaften der polynomischen opera tionen robust functional equations applications program test ing testing polynomial functions e robust characterizations polynomials applications program testing sullapprossimazione delle applicazioni localmente personal communication theory approximation functions real variable theory functions algebraic methods hardwaresoftware testing tr
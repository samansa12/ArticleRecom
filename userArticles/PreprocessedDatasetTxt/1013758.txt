realizability models blllike languages give realizability model girardscedrovscotts bounded linear logic bll gives new proof numerical functions representable system polytime analysis naturally justifies design bll syntax suggests extensions b introduction bounded linear logic bll 3 early attempt provide intrinsic notion polynomial time computation within logical system aim merely express polynomial time computability terms provability certain restricted formulas rather provide typed logical system computation via cutelimination proof normalization inherently polytime since appearance paper several dierent typed functional systems analyzing ptime computability appeared literature 5 4 10 11 6 7 deeper foundational purposes mention girards light linear logic lll 4 major improvement syntax bll eliminates explicit polynomial io sizebounds expense introducing subtle typing distinctions moreover capturing extensional class polytime functions appears less flexible bll terms expressing concrete algorithms furthermore bll merits viewpoint computer science bll natural polymorphicallytyped functional language bounded storage represent bounded calls memory main theorem 3 numbertheoretic functions representable bll polytime proof result used sophisticated techniques proof theory linear logic notably detailed analysis normalization proof nets boxes normalization strategy special kind inspired girards geometry interaction program paper give direct semantic proof main result involve notion reduction term rewriting cutelimination rather assign polytime algorithms proofs compositional syntaxdirected manner use research partially supported epsrc grant grn28436 research supported operating grant natural sciences engineering research council canada realizability relate algorithms intended settheoretic meaning proofs presented form concrete categorical model bll interprets bllformulas sets additional structure proofs functions witnessed polytime algorithms operating additional structure time analysis gives natural interpretation bll syntax justifies fine points design might suggest extensions example analysis encompasses ane variant bll proof constructive sense formalized extensional version calculus inductive constructions 2 provides new compilation method turning bll proofs equivalent polytime algorithms course practice one would use formalization rather derive compilation algorithm hand directly proof interpretation bears intriguing relationship approaches based finite model theory 5 namely polytime functions obtain form goerdt gurevichs total global functions take one extra argument interpreted bound size actual inputs however unlike goerdts system finite model interpretation godels system hence successor function injective bll supports usual semantics including peanos axioms thus seen meaningpreserving annotation standard functional programming hope relationship used transfer goerdts characterizations logspace pspace similar setting bounded linear logic introduce theory bll bounded linear logic first proposed 3 21 resource polynomials resource polynomials 3 finite sums products binomial coecients ie p jq q ip x ij fixed j variables x ij distinct n ij nonnegative integer constants resource polynomials closed sum product composition given polynomials p q write p q denote q p resource polynomial p p 22 syntax bll given following general syntax atomic formulae form p 0 p n1 secondorder variable given finite positive arity n list resource polynomials length n assume infinitely many secondorder variables finite arity formula denotes second order universal quantification xp bounded storage p resource polynomial containing x x bound xp positive negative occurrences resource terms formulae defined induction usual xp p occurs negatively p subterms occur positively atomic formula p connectives monotone connective antitone first monotone second argument example p occurs positively let free resource variables x 0 x n1 occur positively b second order abstraction term say denotes result substituting ie replacing atoms p 0 p n1 given types write dier choice resource polynomials positive occurrence resource polynomial p homologous p p p ii negative occurrence resource polynomial p homologous p p p finite multisets formulae true componentwise proofs given gentzen sequents follows 23 bll sequents sequents form b finite possibly empty multiset formulae order avoid mentioning permutation rule formulae considered indexed ordered follows p q w possibly subscripts range resource polynomials axiom waste resources special case cut b b c r b provided free dereliction ax 0 b contraction storage formulae left indicated form remark 21 rules bll written way given proof sequent given simple change resource parameters yield proof without altering structure proof note waste w rules associated storage without loss generality assumed 0 general case recovered cutting appropriate axioms paper interested cut elimination therefore adopt simplification also introduce unit denoted ordinary rules follows b data type tally natural numbers size x moreover proofs representing zero successor resp see 3 data type dyadic lists size x proofs n 2 representing zero two successor functions resp see 3 following two rules contained definition bll 3 far see admissible bll rules express functoriality monoidalness xp note subsumed following generalization semantics validates rules result addition increase computational strength bll note presence storage rule replaced following axiom x 3 main result shall assume ambient set theory constructive shall set sets u containing natural numbers n closed product function space uindexed products 9 discuss point detail section 5 allows us interpret types sets following way given formula environment assigns sets typevariables obtain settheoretic interpretation follows p notice interpretation types ignores resource polynomials every proof sequent 1 n b environment assign settheoretic function 1 induction derivations obvious way observe cu pair functions defined follows definition symbols 0 usual successor zero n note main goal give new proof following theorem equivalent theorem 54 3 theorem 31 let proof n x n px p contain free resource variables except x let f n n function fn computable polynomial time n moreover fn pn algorithm f eectively obtained proof analogous result holds type dyadic lists theorem 53 3 4 realizability model bll introduce refined model b bll based realizability ideas 6 allow us obtain theorem direct corollary soundness interpretation see proof theorem 421 41 preliminaries x n write binary length x fix linear time computable pairing function n n satisfying x also remark inverses pairing function assumed linear time computable let x finite set variables write vx n x elements vx called valuations x vx c n x c denotes valuation maps x c acts like otherwise assume reasonable encoding valuations integers allowing passed arguments algorithms write px set resource polynomials x p px vx write p number obtained evaluating p x x x x let x finite sets variables substitution x function px may write substitution x form defined p px case domain x clear context may simply write substitution x induces functions obvious way ie assume known untyped lambda calculus defined eg 1 untyped lambda term ane linear variable free bound appears congruence eg xyyx xyy xxy ane linear term xxx notice term strongly normalisable less steps size term runtime computation leading normal form therefore ot 2 henceforth use expression ane lambda term untyped ane linear lambda term normal form ane lambda terms application st defined normal form lambda term st notice application st computed time os ane lambda terms write ane lambda term ffst ane lambda term possibly containing free variables x write x yt uuxyt notice x ytu generally family ane lambda terms write n tally natural numbers may encoded ane lambda terms xyxxyx xyy pnq dyadic lists may encoded xyzxxyx xyzy pwq xyzz pwq notice pnq resp pwq computed linear time n resp vice versa course functions f natural numbers dyadic lists represented ane terms sense write set closed ane lambda terms subsequent development modular sense replaced polynomialtime computable bck algebra sense 7 example take turing machines application defined ex ex result obtained time de x otherwise length function defined inductively x otherwise defect e additionally require finally monotone sublinear function satisfying x x example 42 realizability sets definition 41 let x finite set resource variables realizability set x set vx ternary relation valuations x ane lambda terms set write intuition behind abstract semantic value measures abstract size ane lambda term encodes abstract value example 42 following useful examples realizability sets cf section 5 3 realizability set n x x tally natural numbers size x defined nx ii realizability set n 2 x x dyadic lists length x defined n 2 x iii realizability set defined xx iv given substitution x realizability set new realizability set x defined sets n x n 2 x turn retracts denotations eponymous bll formulas model order model notion positive occurrence resource variable bll formulas introduce corresponding concept realizability sets definition 43 let realizability set x say positive resp negative vx agree x x implies notice x positive n x n 2 x definition 44 let b realizability sets set x morphism b function f b satisfying following condition exists function e vx e computable time q resource polynomial q vx et b fa 1 case say e witnesses f write f e notation algorithm e presumed exist example 45 following useful examples numericalvalued morphisms morphism f n x n x function f n n computable time polynomial input n n moreover satisfies fn n letting similarly morphism f n 2 x function f 0 1 0 1 polytime computable usual sense moreover satisfies lhfw lhw let px unary resource polynomial x let substitution x x p morphism f n x n x function f n n polytime computable input fn pn composed abovementioned retractions morphisms denotations closed proofs n x n px following lemma illustrates realizability sets model syntactical iteration lemma bll cf lemma 62 3 lemma 46 iteration lemma let realizability set x x positive let z x 0 morphism let morphism x function f n defined n x proof witnesses z give rise element e z function e n n definition substitution x0 whenever n n follows induction n fact x positive define e recursively follows provided n n furthermore easy see e polytime given en fixed p independent n therefore ex witnesses function following analogous version dyadic lists cf lemma 62 3 proved similarly lemma 47 iteration lemma dyadic lists let realizability set x x positive let z x 0 morphism let morphisms x function f 0 1 defined morphism n 2 x remark one also prove general versions preceding iteration lemmas allowing extra resource variables parameters proposition 48 let x finite set resource variables realizability sets x morphisms form category bx mapping extends functor bx category set sets means composition bx given ordinary settheoretic composition functions proof identity function id witnessed algorithm exx clearly polytime computable 0 f composition g witnessed xyzxyz e polytime using fact application polytime recall definition example 42 realizability set x realizability set substitution x proposition 49 let substitution x assignment extends functor proof show f e find e f unfolding definitions reveals e e job allows us consider morphisms realizability sets dierent sets resource variables namely x z weakening substitution weak xz z x given weak xz realizability set x b realizability set consider morphisms aweak xxy bweak yxy morphism b exists algorithm e vx e computable time q resource polynomial q et x denotes restriction x shall sloppily refer morphisms morphisms b sense morphism n x n x constant zero function following immediate lemma 410 suppose realizability set substitu tions suppose furthermore occurs positively occurs negatively otherwise identity function morphism 43 category realizability sets show categories bx appropriate categorical structure model bll connectives definition 411 define following monoidal structure bx arbitrary 1 2 realizability sets x define 1 2 2 proposition 412 let f b bx morphism c bx function b c defined f ca c fa c morphism c b c ii canonical settheoretic maps b c b c b induce isomorphisms associated objects iii appropriately typed substitution says particular bx symmetric monoidal category forgetful functor set monoidal functor clause iii states substitution monoidal func tor says collection categories bx forms fibred symmetric monoidal category sense 14 proof ad e witnesses f define e x yex obviously e witnesses f c since e function e polytime cases analogous proposition 413 two objects b bx linear function space object b fa structure makes bx symmetric monoidal closed category ie natural bijection monoidal closed functor proof evaluation map f fa witnessed x yyx c f e witnessed e xyex prop 412 e p establishes e polytime notice forgetful functor bx set also monoidal closed ie sends definition 414 given polynomial p px realizability set xx define realizability set xp x ie x bound xp xp xpa p whenever write xp sequel implicitly assume x occur p proposition 415 f b bx x morphism xp f def f says xp extends functor bx x bx mapped identity forgetful functor set proof f e witness notice z p times p e computable time opq 2 e computable oq note rather generous estimate show appropriate categorical structure interpret rules bll proposition 416 following morphisms da x fresh b proof map witnessed e n i1 x x 0 map e may witnessed eyxx map da may witnessed see assume xpqa p xi n ip moreover hence yj jp axpy therefore result follows next may witnessed verification similar one da finally ab may witnessed x omit waste morphism wa obvious 44 interpreting syntax b shall give details interpretation syntax bll terms realizability sets morphisms definition 417 let x set resource variables secondorder environment x partial function assigns secondorder variable arity n pair l c list n pairwise dierent resource variables occurring x c realizability set x 0 n1 positive secondorder environment write mapping c l c substitution secondorder environment define secondorder environment x c assume variables l contained otherwise substitution cannot defined recall settheoretic semantics defined section 3 write set settheoretic semantics distinguish realizability semantics b define let bll formula free resource variables x environment x defined free secondorder variables occurring assume without loss generality bound variables distinct induction define realizability set b defining clauses follows b f c l c def 417 following lemmas immediate structural induction lemma 418 let substitution x let bll formula free resource variables let environment defined lemma 419 let bll formula possibly containing secondorder variable bll formula containing free resource variables 0 n1 occur lemma 420 let bll formula resource variable x occurs positively resp negatively appropriate secondorder environment x positive resp negatively b theorem 421 soundness let proof sequent 1 n b involving resource variables x let secondorder environment binding secondorder variables occurring sequent settheoretic function 1 morphism realizability sets 1 recall 1 1 proof induction bll derivations using using lemma 410 axiom using propositions 412 413 415 416 term formers associated using three lemmas universal application abstraction also make use obvious translations syntactic constructs categorical combinators eg application evaluation composition storage combination functoriality proof theorem 31 applying iteration principle theorem 46 denotations 0 shows function n n x set morphism bx n x similarly function n px n morphism direction polymorphic application thus function theorem morphism result follows analysis example 45 proceed analogously case dyadic lists using corresponding iteration principle 5 additional remarks notice realizability set x unique function morphism realizability sets witnessed eyxx particular gives projections shows model ane variant bll following additional rule weak b particular see rule add computational strength recall assumed existence universe u ambient set theory closed uindexed products wellknown universe exists classical zf set theory consistent constructive set theories 9 13 found convenient assume existence u allows use informal settheoretic arguments provided constructive reader feels uneasy sleightofhand oer following ways making rigorous however complicate formalize entire discussion calculus inductive constructions 2 formalize entire discussion realizability topos 6 13 making previous point explicit stipulate carrier sets realizability sets must subquotient per set untyped lambda terms necessarily linear furthermore morphism realizability sets must uniformly tracked untyped lambda term obvious sense would allow one interpret polymorphic quantification intersection pers r lambda calculus springer lncs 389 bounded linear logic light linear logic characterizing complexity classes highertype primitive recursive defini tions linear types nonsizeincreasing polynomial time computation type systems polynomialtime computation programming languages capturing complexity classes small complete category stratified functional programs computational complexity lambda calculus characterisations polytime categories working mathematician linear logic tr bounded linear logic characterizing complexity classes higher type primitive recursive definitions stratified functional programs computational complexity lambda calculus characterizations polytime light linear logic polymorphism set theoretic constructively inductively defined types phase semantics light linear logic linear types nonsizeincreasing polynomial time computation
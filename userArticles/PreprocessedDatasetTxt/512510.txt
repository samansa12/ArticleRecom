ordered binary decision diagrams knowledgebases consider use ordered binary decision diagrams obdds means realizing knowledgebases show view point space requirement obddbased representation efficient suitable cases compared traditional cnfbased andor modelbased representations present polynomial time algorithms two problems testing whether given obdd represents unate boolean function testing whether represents horn function b introduction logical formulae one traditional means representing knowledge ai 11 however known deduction set propositional clauses conpcomplete abduction npcomplete 13 recently alternative way representing knowledge ie subset models called characteristic models proposed see eg 6 7 8 9 deduction knowledgebase modelbased approach performed linear time abduction also performed polynomial time 6 paper propose yet another method knowledge representation ie use ordered binary decision diagrams obdds 1 2 12 obdd directed acyclic graph representing boolean function considered variant decision trees restricting order variable appearances sharing isomorphic subgraphs obdds following useful properties 1 variable ordering given obdd reduced canonical form boolean function 2 many boolean functions appearing practice compactly represented 3 ecient algorithms many boolean operations obdds result properties obdds widely used various applications especially computeraided design verication digital systems see eg 4 14 manipulation knowledgebases obdds eg deduction abduction rst discussed madre coudert 10 rst compare three representations ie formulabased modelbased obddbased basis sizes particular show cases obdds require exponentially smaller space two representations also cases two requires exponentially smaller space words three representations mutually incomparable respect space requirement known obdds ecient knowledgebase operations deduction abduction 10 investigate two fundamental recognition problems obdds testing whether given obdd represents unate boolean function testing whether represents horn function often encounter recognition problems since knowledgebase representing real phenomenon sometimes required unate horn hypothesis posed phenomenon andor investigation mechanism causing phenomenon example knowledgebase represents data set test results various physical measurements eg body temperature blood pressure number pulses often case diagnosis certain disease monotonically depending test result allow changing polarities variables necessary also articial intelligence common consider horn knowledgebases processed eciently many respects example deduction set horn clauses done linear time 5 show recognition problems obdds solved polynomial time unate horn cases rest paper organized follows next section gives fundamental denitions concepts compare three representations section 3 consider problems recognizing unate horn obdds sections 4 5 respectively preliminaries 21 notations fundamental concepts consider boolean function f f0 1g n f0 1g assignment vector 2 f0 1g n whose ith coordinate denoted model f satisfying assignment f ie theory f representing f set models f given b 2 f0 1g n denote b usual bitwise ie componentwise ordering assignments b given subset e f1 2 ng e denotes characteristic vector e ith coordinate e n variables f x corresponds ith coordinate assignments evaluates either 0 1 negation variable x denoted x variables negations called literals clause disjunction literals conjunction clauses called conjunctive normal form cnf say f represented cnf holds 2 f0 1g n boolean function represented cnf may unique sometimes make distinction among function f theory f cnf represents f unless confusion arises dene restriction f replacing variable x constant 2 f0 1g denote f restriction may applied many variables also lemma 21 relation following properties holds f j x gj x holds holds f h g h hold assignment p 2 f0 1g n dene p b bit p b bit p holds bit denotes bitwise ie componentwise exclusiveor operation boolean function f unate polarity p fa fb holds assignments b p b theory unate represents unate function clause unate polarity p positive literals x negative literals x clause cnf unate polarity p contains unate clauses polarity p known theory unate represented unate cnf unate function positive resp negative polarity 00 theory horn closed operation bit bit b bitwise models b example 0011 0001 closure theory respect bit denoted dened smallest set contains closed bit also use operation bit set operation f bit g holds b 2 f c 2 gg often denotes f bit g convenience note two functions dierent boolean function f horn f horn equivalently f holds sets models clause horn number positive literals one cnf horn contains horn clauses known theory horn represented horn cnf denition negative function horn conversely horn theory model 2 called characteristic cannot produced bitwise models 62 fag set characteristic models horn theory call characteristic set denoted char note every horn theory unique characteristic set char satises set minimal models f respect p 2 f0 1g n dened exists b 2 f satisfying b p ag b p denotes b p b 6 hold following lemma gives upper bound size ie cardinality characteristic set lemma 22 9 let f horn function n variables characteristic set f size ng e ni characteristic vector set e ni f0 ng given ng 22 ordered binary decision diagrams ordered binary decision diagram obdd directed acyclic graph represents boolean function two sink nodes 0 1 called 0node 1node respectively together called constant nodes nodes called variable nodes variable node v labeled one variables x 1 denote label node v variable node exactly two outgoing edges called 0edge 1edge respectively one variable nodes becomes unique source node called root node let denote set n variables variable ordering total ordering associated obdd permutation f1 2 ng ng level 3 node v denoted levelv dened label node v label x levelv dened root node level n label x 1 nodes level n 1 label x 2 level constant nodes dened 0 every path root node constant node obdd variable appears decreasing order levels every node v obdd also represents boolean function f v dened subgraph consisting edges nodes reachable v node v constant node f v equals label node v variable node f v dened varv f 0succv var v f 1succv shannons expansion 0succv 1succv respectively denote nodes pointed 0edge 1edge node v function f represented obdd one represented root node figure 1 illustrates three obdds representing x 3 x 2 x 1 3 denition level may dierent common use 0edge 1edge constant node variable node b c figure 1 obdds representing x 3 x 2 x 1 variable ordering given assignment value fa determined following corresponding path root node constant node following manner variable node v one outgoing edges selected according assignment varv variable var v value function label nal constant node two nodes u v obdd represent function levels called equivalent node whose 0edge 1edge point node called redundant obdd called dense every variable node v satisfy paths root node constant nodes visit nodes dense obdd equivalent nodes quasireduced quasireduced obdd redundant nodes reduced obdds b c fig 1 dense quasi reduced reduced respectively following assume obdds reduced unless otherwise stated size obdd number nodes obdd given function f variable ordering reduced obdd unique minimum size among obdds variable ordering minimum sizes obdds representing given boolean function depend variable orderings 2 given obdd represents f obdds f j x 0 f j x 1 obtained denotes size obdd f size increase restriction given two obdds representing f g applying fundamental logic operators g performed ojf j jgj time property f g also checked ojf j partition f pair sets l r satisfying l r l called left partition r called right partition let l denote assignment variables l r denote assignment variables r l r denotes complete assignment obtained combining l r let x 0 subset x positive number satisfying 0 1 partition l r called balanced given partition l r set assignments l l r r h called fooling set satises 2 f0 1g next lemma tells size h fooling set gives lower bound size obdd represents f lemma 23 3 let f boolean function n variables x 0 subset variables positive number satisfying 0 1 f fooling set size least h every balanced partition l r x 0 size obdd representing f least h variable ordering 3 three approaches knowledgebase representation section compare three knowledgebase representations cnfbased modelbased obddbased known cnfbased modelbased representations play orthogonal roles respect space requirement namely sometimes allows exponentially smaller sizes depending functions show obddbased representation incomparable two sense start relations obdd cnf representations lemma 31 exists negative theory n variables obdd cnf require size characteristic set requires size z n2 proof consider function 2m size cnf obviously characteristic set given exactly one 2i 1 2i 0 whose size obdd representing f illustrated fig 2 variable ordering size obdd 2 0edge 1edge figure 2 obdd representing f lemma 32 exists negative theory n variables obdd requires size characteristic set requires size 2 cnf requires size z n2 proof consider function f smallest cnf representation f b given clauses characteristic set f f122mgs 2 f0 1g 2m whose size 2 6 obdd representing f b illustrated fig 3 variable ordering f b dual f obdd obtained negating input variables ie exchanging roles 0edges 1edges negating output ie exchanging roles 0node 1node obdd fig 2 size obdd 2 combining lemmas 31 32 show theory obdd exponentially smaller characteristic set cnf representations theorem 31 exists negative theory n variables obdd requires size characteristic set cnf require sizes z n4 0edge 1edge figure 3 obdd representing f proof consider function 2m shown lemma 31 characteristic set requires size z n4 represent rst half also lemma 32 cnf representation always requires size z n4 represent second half note rst second halves independent since variables rst half appear second half vice versa therefore lower bounds characteristic set cnf valid also f c obdd represents f c illustrated fig 4 variable ordering size obdd 2 turn opposite direction ie cnf characteristic set exponentially smaller size obdd lemma 33 size characteristic set following horn function n variables x ij 1 f x ijaa x ij set b n dened lemma 22 convenience e set e n0 fi jg 0edge 1edge x n2 x n22 figure 4 obdd representing f corresponding variable x ij f holds characteristic vector e n0 thus similarly jmin e nij f since f next since f implied enumerate minimal models e nim1 denition obtain e n0 ipping m1th coordinate e nim1 e n0 minimal model e nim1 since 1th coordinate xed 0 clause satised ipping least one jth coordinates among two jth coordinates ipped corresponding vector minimal thus jmin e nim1 f similarly jmin e nm1j f also enumerate minimal models enm1m1 since f enm1m1 obtain e n0 ipping m1m1th coordinate m1m1th coordinate xed 0 minimal models obtained ipping exactly one m1th coordinates among exactly one coordinates among thus jmin e nm1m1 f total p a2bn jmin f ie lemma 22 means size characteristic set f 2 lemma 34 15 let f boolean function n variables x ij 1 partition l r satisfying either following properties holds 1 least dierent satisfying fx 2 least dierent js satisfying fx lemma 35 size obdd representing following negative function f e n variables variable ordering x ijaa x ij proof prove lemma 23 section 22 let us consider set x 0 lemma 23 given set variables every balanced partition assuming case 1 lemma 34 without loss generality least pdierent satisfying fx select 2 g every k 2 select two variables x k l k 2 l x k r k 2 r construct set assignments assignment satises following restrictions 1 every assigned either 0 1 1 0 2 every assigned 1 3 variables assigned 0 size set 2 2 since choices restriction 1 let l h r h denote assignment satisfying prove set fooling set dened lemma 23 first show assigned 0 assigned 0 w mg thus f e l h r h next show f e l h r h 0 exists least one variable x assigned 1 l h r h 0 l h 0 restriction 1 x k r k assigned 0 l h r h 1 l h 0 therefore x k l k x k r k assigned 1 assignment l h r h 0 implying holds proves fooling set since size fooling set least 2 2 balanced partition lemma follows lemma 23theorem 32 exists horn theory n variables cnf requires size characteristic set requires size size smallest obdd representation proof consider function f lemma 33 stated lemma 33 size characteristic set also size cnf obviously function f e lemma 35 obtained restricting x 1m1 xmm1 xm11 xm1m xm1m1 f 0 since size obdd increase restriction size smallest obdd f results show none three representations always dominate two obdds nd place knowledgebases represent theories eciently others unfortunately combining theorems 31 32 following negative result obtained corollary 31 exists horn function n variables characteristic set cnf require sizes size smallest obdd representation proof consider function consists two parts rst one resp second one corresponds f c theorem 31 resp f theorem 32 n2 variables respectively share none variables similarly case theorem 31 lower bounds three representations easily obtained 2 checking unateness obdd section discuss problem checking whether given obdd represents unate function assume without loss generality variable ordering always following wellknown property show problem solved polynomial time property 41 let f boolean function n variables x 1 unate holds every noted subsection 22 obdd representing f obtained ojf j log jf time obdd representing f jf j denotes size size increase restriction f j x 0 f j x 1 since property g h checked ojgj jhj time unateness f checked onjf checking conditions following wellknown property useful reduce computation time property 42 let f boolean function n variables x 1 unate f j xn0 f j xn1 unate polarity unateness functions f j xn0 f j xn1 checked applying property 42 recursively additional condition f j xn0 f j xn1 polarity note property f j xn0 f j xn1 resp f j xn0 f j xn1 also checked recursively since holds f j xn0 xn 1 1 algorithm checkunate fig 5 checks conditions bottomup manner ie level root node use array p denote polarity f respect x level element stores 0 1 checked yet also use twodimensional array impu v denote whether f u f v holds element stores yes checked yet step 2 unateness polarity specied array p checked functions nodes level precisely unateness functions checked step 21 consistency polarities checked step 22 step 3 impu v computed functions f u f v levels unateness check f v step 21 easily done since f 0succv ie f v j x 0 f 1succv ie f v j x 1 already checked unate polarity p1 p2 p 1 f 0succv f 1succv compared step 3 previous iteration note constant functions 0 1 considered unate polarity f v respect x level temporarily stored pol step 21 step 22 polarity consistency respect x checked comparing polarity node v pol p p rst node checked level store algorithm input obdd representing f variable ordering output yes polarity f unate otherwise impu v otherwise 1 check unateness level compute p node v level ie labeled x apply steps 21 22 step 21 set pol 0 imp0succv output halt step 22 p halt step 3 compute imp level pair nodes u v u v v u considered dierent levelu levelv least one levelu levelv equal set impu v yes imp0succ 0 u 0succ 0 v imp1succ 0 u 1succ 0 v yes otherwise set impu v step 4 iterate level root node output yes polarity halt otherwise set return step 2 figure 5 algorithm checkunate check unateness obdd pol p otherwise pol checked p output consistent note checkunate outputs p nodes level ie f depend x step 3 comparison f u f v also performed easily since comparisons f u j x f v j x use convention 0succ 0 v resp 1succ 0 v denotes 0succv resp 1succv f v j x hold holds levelv note f holds u v node step 3 done know impu v pairs nodes u v levelu levelv store results although may needed next consider computation time algorithm step 2 computation v performed constant time data already computed previous step 3 thus total time step 2 ojf j step 3 comparison f u f v pair u v performed constant time number pairs compared step 3 entire computation theorem 41 given obdd representing boolean function f checking whether f unate done ojf size given obdd start algorithm checkunate initial condition check positivity resp negativity f f positive resp negative polarities nodes 0 resp 1 corollary 41 given obdd representing boolean function f checking whether f positive resp negative done ojf size given obdd checking horness obdd section discuss problem checking whether given obdd represents horn function examining condition horness next subsection algorithm given subsection 52 51 conditions horness assume without loss generality variable ordering always denoting f j xn0 f j xn1 f 0 f 1 simplicity f given boolean functions similarly case unateness check horness f bottomup manner lemma 51 let f boolean function n variables x 1 expanded f 0 f 1 horn f holds proof rst prove identity considering models ifpart lemma immediate 1 horness f 0 f 1 ie property f imply next consider imply equality 2 implies f 1 horn also f holds since bit holds model f 0 thus combining 3 4 f holds g f holds also f horness f 0 f 1 checked applying lemma 51 recursively following lemma says condition lemma 51 also checked bottomup lemma 52 let f g h boolean functions n variables expanded holds f proof identity proved manner similar 1 considering models since f bit g h holds f bit gj hold prove lemma lemma 212 2 note condition type f bit g f lemma 51 requires check condition type ie checking type f bit g h three functions f g h last condition checked recursively lemma 52 52 algorithm check horness applying lemmas 51 52 recursively horness boolean function f checked scanning nodes given obdd bottomup manner namely node v level check condition lemma 51 ie whether f v j x 0 f v j x 1 horn holds lemma 52 gives condition f v j x checked bottomup manner algorithm checkhorn fig 6 checks horness given obdd manner use array horn v denote whether node v represents horn function threedimensional array bitimpu v w denote whether f element arrays stores yes checked yet horn says f v horn bitimpu v holds note since obdd reduced condition f may checked functions dierent levels case functions considered l max variables adding dummy variables l max denotes maximum level nodes u v w step 2 algorithm checkhorn horn v v computed constant time fig 7 corresponds lemma 51 since f v j x levelv f 1succv hold horn0succv horn1succv bitimp0succv 1succv 0succv fig 7 already computed previous iterations similarly bitimpu v w step 3 triple u v w computed constant time fig 8 corresponds lemma 52 case algorithm checkunate levelv upon completing step 3 results bitimpu v w triples u v w levelu levelv levelw contain information required next iteration although may needed consider computation time algorithm checkhorn step 2 since horn v node v computed constant time ojf time required checking algorithm checkhorn input obdd representing f variable ordering output yes f horn otherwise horn v yes v constant node 0 1 otherwise otherwise 1 check horness level node v level ie labeled x check whether function f v horn according fig 7 set result yes horn v exists least one node level horn output halt step 3 compute bitimp level triple u v w nodes levelu levelv levelw least one levelu levelv levelw equal check whether f holds according fig 8 set result yes step 4 iterate halt otherwise set return step 2 figure algorithm checkhorn check horness obdd yes horn0succv horn1succv yes otherwise figure 7 checking horn v node v step 2 yes bitimp1succ 0 u 1succ 0 v 1succ 0 w bitimp1succ 0 u 0succ 0 v 0succ 0 w yes otherwise figure 8 checking bitimpu v w ie f triple nodes u v w step 3 nodes obdd step 3 bitimpu v w triple u v w also computed constant time number triples checked step 3 entire computation ojf j 3 time rest computation minor theorem 51 given obdd representing boolean function f checking whether f horn done ojf j 3 time jf j size given obdd 6 conclusion paper considered use obdds represent knowledgebases shown conventional cnfbased modelbased representations new obdd representation mutually incomparable respect space requirement thus obdds nd place knowledgebases represent theories eciently others considered problem recognizing whether given obdd represents unate boolean function whether represents horn function turned checking unateness done quadratic time size obdd checking horness done cubic time obdds dominatingly used eld computeraided design verication digital systems reason many boolean functions encounter practice compactly represented many operations obdds eciently performed believe obdds also useful manipulating knowledgebases developing ecient algorithms knowledgebase operations deduction abduction addressed work acknowledgement authors would like thank professor endre boros rutgers university valuable comments research partially supported scientic grantinaid ministry education science sports culture japan r theoretical studies memorybased parallel computation ordered binary decision diagrams tr theory learnable graphbased algorithms boolean function manipulation complexity vlsi implementations graph representations boolean functions application integer multiplication efficient implementation bdd package sequential circuit verification using symbolic model checking shared binary decision diagram attributed edges efficient boolean function manipulation structure identification relational data empirical evaluation knowledge compilation theory approximation complexity logicbased abduction horn approximations empirical data reasoning models logic synthesis large pass transistor circuits fast exact minimization bdds approximation decomposition binary decision diagrams twolevel logic minimization 100 times faster bds obdds monotone function prime implicants horn envelopes hypergraph transversals reasoning ordered binary decision diagrams translation among cnfs characteristic models ordered binary decision diagrams ctr takashi horiyama toshihide ibaraki translation among cnfs characteristic models ordered binary decision diagrams information processing letters v85 n4 p191198 28 february
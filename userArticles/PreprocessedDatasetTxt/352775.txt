selftesting without generator bottleneck suppose p program designed compute function f defined group g task selftesting p testing p computes f correctly inputs usually involves testing explicitly p computes f correctly every generator g case multivariate functions number generators hence number tests becomes prohibitively large refer problem generator bottleneck develop technique used overcome generator bottleneck functions certain nice structure specifically relationship values function set generators easily checkable using technique build first efficient selftesters many linear multilinear nonlinear functions includes fft various polynomial functions selftesters present make o1 calls program tested consequence techniques also obtain efficient program resultcheckers problems b introduction notions program resultchecking selftesting selfcorrecting introduced 4 17 5 powerful tools attacking problem program correctness methods offer realistic efficient tools software verification various useful mathematical functions shown selftesters selfcorrectors examples found 5 3 17 9 14 18 1 19 21 6 theoretical developments area heart recent breakthrough results probabilistically checkable proofs subsequent results show nonapproximability hard combinatorial problems suppose given program p designed compute function f informally selftester f distinguishes case p computes f correctly always case p errs frequently resultchecker function f takes input program p input q p outputs pass p correctly computes f always outputs fail p q 6 fq given program p computes f correctly inputs selfcorrector f program p sc uses p oracle computes f correctly every input high probability 11 definitions basics discuss results present basic definitions testers checkers etc state desirable properties programs let f function domain let p program purports compute f testers correctors checkers define probabilistic programs take p oracle addition take one following parameters input accuracy parameter ffl specifies conditions p expected paper unifies preliminary versions appeared 27th annual symposium theory computing 10 15th annual foundations software technology theoretical computer science 16 department computer science cornell university ithaca ny 148537501 erguncscornelledu work partially supported onr young investigator award n000149310590 alfred p sloan research award nsf grant dmi91157199 z department computer science cornell university ithaca ny 148537501 ravicscornelledu work partially supported onr young investigator award n000149310590 alfred p sloan research award nsf grant dmi91157199 x department computer science university houston houston work performed author sunybuffalo supported part k regans nsf grant ccr9409104 un r kumar sivakumar meet confidence parameter ae upper bound probability testercorrectorchecker fails job following definitions formalize notions selftester 5 selfcorrector 5 17 resultchecker 4 definition 11 selftester fflselftester f probabilistic oracle program given ae 0 satisfies following conditions ffl pr x2d p definition 12 selfcorrector fflselfcorrector f probabilistic oracle program p sc given input ae 0 satisfies following condition ffl pr x2d p definition 13 resultchecker checker resultchecker f probabilistic oracle program c given input ae 0 satisfies following conditions ffl pr x2d p outputs pass list three important properties required selftesters self correctors resultcheckers definiteness state case self testers first selftester computationally different efficient program computes f 4 restriction ensures implement obvious algorithm compute f hence could harbor set bugs computationally inefficient furthermore ensures running time asymptotically better running time best known algorithm f second important property required require knowledge many correct values f particular rules possibility merely keeps large table correct values f inputs third important property required selftester efficiency efficient selftester make o1ffl lg1ae calls p constant ffl ae efficient selftester makes o1 calls program rest paper often write o1 shorthand o1ffl lg1ae particularly discussing dependence parameters interest following wellknown lemma summarizes relationships notions selftesters selfcorrectors resultcheckers readers convenience sketch idea proof lemma suppressing details accuracy confidence parameters lemma 14 5 f selftester selfcorrector make o1 calls program f resultchecker makes o1 calls program b f resultchecker selftester proof sketch part suppose f selftester selfcorrector given input oracle access program p first selftest p ensure doesnt err often selftester finds p erroneous output fail otherwise compute fy using selfcorrector p sc program p output pass iff p clearly perfect program always passes suppose p 6 fy one following two cases must occur program erroneous case selftester hence checker outputs fail program erroneous case selfcorrector computes fy correctly high probability checker detects p 6 p sc outputs fail part b suppose f resultchecker using resultchecker test p randomly chosen inputs x fraction inputs x p x 6 fx estimated output pass iff fraction less ffl useful tool constructing selfcorrectors notion random selfreducibility fine details notion beyond scope paper refer reader papers 3 17 see also survey paper 11 informally function f randomly selfreducible evaluation f input reduced efficiently evaluation f one random inputs quick example note linear functions randomly selfreducible compute fx suffices pick random r compute fx r fr finally obtain functions consider paper efficiently randomly selfreducible therefore whenever required always assume efficient selfcorrection possible 12 building selftesters using properties process selftesting whether program p computes function f correctly inputs usually twostep strategy first perform tests verify p agrees inputs function g belongs certain class f functions contains f perform additional tests verify function g fact intended function f standard way test whether p agrees function class f functions based notion robust property informally property said robust characterization function family f following two conditions hold 1 every f 2 f satisfies 2 p function program satisfies inputs p must agree g 2 f inputs example blum luby rubinfeld 5 establish property linearity serves robust property class linear functions use build selftesters linear functions generic technique first formalized 19 robust property property predicate f property f x ffl ffirobust class functions f domain satisfies following conditions theta ffl function program p satisfies pr x2d k p function g 9g 2 f p agrees g ffi fraction inputs outline process building selftesters using robust properties cf 5 let finite group generators e class functions range r assume functions f possess property random selfreducibility hence selfcorrected efficiently suppose p program purports compute specific function f 2 f let f x robust property characterizes f mentioned earlier process building selftesters twostep process first step ensure program p agrees function 2 f inputs use fact f robust property characterizes f specifically selftester estimate fraction ktuples holds fraction least 1 gamma ffl robustness f follows g 2 f agrees p ffi fraction required estimation carried random sampling x testing property f un r kumar sivakumar next step verify function g function f p purports compute achieved testing ge generator group true easy induction would follow g j f important point mentioned selftester access p g function g guaranteed exist nevertheless required values g may obtained using selfcorrected version p sc p another point worth mentioning carry step selftester needs know values f every generator 13 generator bottleneck immediate application basic method outlined functions whose domains vector spaces large dimension suffers major efficiency drawback example inputs function f ndimensional vectors n theta n matrices number generators domain n resp n 2 straightforward approach exhaustively testing p sc agrees f generator making n resp furthermore selftester built approach requires knowledge correct value f n resp large makes overhead selftesting process high issue called generator bottleneck problem paper address generator bottleneck problem solve fairly large class functions satisfy nice structural properties self testers build useful also useful building efficient resultcheckers important practical applications 14 results present fairly general method overcoming generator bottleneck testing multivariate functions making o1 calls program tested first investigate problem multivariate linear functions ie functions f satisfying show general technique applied natural vector space setting main idea obtain easy uniform way generating generators single generator using idea give simple powerful condition linear function f efficiently selftestable large vector space apply scheme obtain efficient selftesters many functions includes polynomial differentiation arbitrary order polynomial integration polynomial mod function etc also obtain first efficient selftester fourier transforms extend method case multilinear functions ie functions f linear variable variables fixed build efficient tester polynomial multiplication consequence another application give large finite fields show multilinear functions finite field extensions dimension n efficiently selftested o1 calls independent dimension n also provide new efficient selftester matrix multiplication next extend result nonlinear functions give selftesters exponentiation functions avoid generator bottleneck example consider function computes square polynomial finite field linearity property crucial proof linear functions instead use fact lagrange interpolation identity cf fact 41 polynomials gives robust characterization exhibit selftester function makes od calls program tested extending technique f constant degree exponentiation case f constant degree polynomial eg polynomial finite field much harder first show reduction multiplication computation lowdegree polynomials using reduction notion resultchecker construct selftester degree polynomials finite field extensions dimension n make o2 calls program tested 15 related work one method used get around generator bottleneck exploit property downward selfreducibility 5 selftesters use property however makeomegagamma383 n calls program depending way problem decomposes smaller problems instance tester permanent function n theta n matrices makes calls program whereas tester polynomial multiplication uses similar principles makes olog n calls 5 bootstrap tester polynomial multiplication makes olog n calls program tested given already known matrix multiplication tested without calls program using result checker due freivalds 13 idea freivalds matrix multiplication checker also adapted build testers polynomial multiplication make calls program tested approach however requires underlying field large least 2 degree polynomials multiplied fl positive constant moreover scheme requires tester perform polynomial evaluations whereas fourier transforms different resultchecker uses preprocessing given independently 6 useful fact following fact variant wellknown chernoffhoeffding bounds often useful obtaining errorbounds sampling 01 random variables 15 fact 16 let independently identically distributed 01 random variables means let 2 n 14 e organization paper section 2 discusses scheme linear functions vector spaces x3 extends scheme multilinear functions x4 outlines approach nonlinear functions 2 linear functions vector spaces section address problem selftesting linear functions vector space without generator bot tleneck demonstrate general technique selftest without generator bottleneck provide several interesting applications technique definitions let v vector space finite dimension n field k let f function v ring r interested building selftester case fdelta linear function fcff c 2 k unit vector 1 ith position 0s positions vectors e 1 collection basis vectors span v viewed abelian group vector addition v generated e assume field k finite since clear choose random element infinite field property linearity f ff fi shown robust 5 using generic construction selftesters robust properties one obtains following selftester function f 6 f erg un r kumar sivakumar property test repeat 1 ae times pick ff fi 2r v verify reject test fails generator tests verify p sc p passes property test guaranteed existence linear function g close p however two problems generator tests one selftester inefficientif inputs vectors size n selftester makes calls program desirable secondly selftester needs know correct value f n different points also undesirable primary interest avoid generator bottleneck solve problems mentioned key idea find easy uniform way converts one generator next generator illustrate idea following example example let pn denote additive group degree n polynomials field k elements multiplying generator x k x gives next generator x k1 polynomial q 2 pn scalar c 2 k let denote function evaluates qc clearly e c linear satisfies simple relation e c suppose p program purports compute assume p passed property test given know robustness linearity linear function g agrees p inputs note g computed correctly high probability via self corrector easy construct linear functions 5 rather verify gx k pn may instead verify g satisfies property easy induction implies g agrees e c generators linearity g follows g agrees e c inputs faced task verifying expensive tried explicitly exhaustively instead prove suffices check o1 tests almost everywhere look pick many random q 2 pn ask program p sc compute values gq gxq crosscheck holds words prove property j g q j robust restricted sense assumption g linear general interpretation robustness guarantees existence h satisfies agrees g large fraction inputs actually show h j g hence restricted sense notice number points selftester needs know value f one contrast n original approach 5 generalization via basis rotation function note idea natural generalization vector spaces let denote basis rotation function ie linear operator vector space v rotates coordinate axes span viewed matrix defines onetoone correspondence set basis vectors every e computational payoff achieved simple relation fff fff vectors specifically show generator bottleneck avoided easily computable function h f ff 2 v instance polynomial evaluation e c obvious drop suffix f simply denote h f h function f linear linearity implies h linear second argument following sense h ff important h easy compute given ff fff using scheme show many natural functions f suitable candidate h generator tests 5 replaced basis test verify p sc inductive test repeat 1 ae times pick ff 2r v verify p sc reject test fails following theorem proves replacement valid theorem 21 suppose f linear function vector space v ring r suppose p program f let ffl 12 suppose p satisfies following condition function g defined linear function v g agrees p least 1 gamma 2ffl fraction inputs b furthermore suppose h ff satisfies following conditions 3 pr ff2v gff 6 h ff gff ffl ff ff defined remarks theorem merely lists set properties fact set yields selftester presented theorem 22 note hypotheses 1 2 3 conditions p g tests performed selftester proof proof function g linear p sc computes g high probability due 5 rest proof assume g linear satisfies conditions 2 3 first argue suffices prove conditions hold every agrees f first basis vector 1 basis vector e obtained e would follow g computes f correctly basis vectors finally since g linear computes f correctly v since vectors v linear combinations basis vectors show condition 3 implies 8ff 2 v arbitrary element ff 2 v show probability random un r kumar sivakumar positive since equality independent fi holds nonzero probability must true probability 1 pr theta first equality rewriting second equality follows linearity third equality follows fact g linear random variable fi distributed uniformly v random variables fi ff gamma fi distributed identically uniformly v therefore assumption g satisfies condition 3 fourth equality fails probability 2ffl fifth equality uses fact h linear last equality uses fact g linear foregoing theorem shows p g satisfy certain conditions g computed using p identically equal function f selftester comprises following tests linearity test basis test inductive test theorem 22 ae 1 ffl 12 three tests comprise 2fflselftester f program p computes f correctly inputs selftester outputs pass probability 1 p computes f incorrectly 2ffl fraction inputs selftester outputs fail probability least 1 gamma ae proof performing three tests selftester essentially estimating probabilities listed conditions 1 2 3 hypothesis theorem 21 note condition 2 involve probability rather selftester uses p sc compute ge 1 choosing o1ffl log1ae samples linearity test inductive test using selfcorrector confidence parameter ae3 basis test selftester ensures confidence checking condition least 1 gamma ae3 correctly tester always outputs pass con versely suppose tester outputs pass probability ae hypotheses theorem 21 true conclusion theorem 21 follows function g identical f exists g equals p least 1 gamma 2ffl fraction inputs 21 applications present applications theorem 22 remind reader linear function f vector space v efficiently selftestable without generator bottleneck linear function h easily computable satisfies applications f show suitable function exists satisfies condi tions recall example polynomial evaluation function e c identity e c holds applications establish similar relationships also sake simplicity give technical parameters required computed routine calculations following proofs theorems last section applications concern linear functions polynomials obtain selftesters polynomial evaluation fourier transforms polynomial differentiation polynomial integration mod function polynomials moreover vector space setting lets us state results terms matrices compute linear transforms vector spaces let pn k x denote group polynomials x degree n field k group pn forms vector space usual polynomial addition scalar multiplication elements k polynomials polynomial vector representation q basis rotation function case multiplication x thus multiplying q x results polynomial degree n 1 handle minor detail assume program works domain pn1 conclude correctness pn polynomial evaluation c 2 k let e c q denote described function returns value qc function linear moreover relation e c xq e c q simple linear e c selftest program p claims compute e c inductive test simply choose many random qs verify p sc holds operators discrete fourier transform distinct elements k one may wish evaluate polynomial q 2 pn simultaneously points ideas e c extend easily case u 2 k relations hold simultaneously let principal n 1st root unity k operation converting polynomial coefficient representation pointwise evaluation powers known discrete fourier transform dft dft many fundamental applications include fast multiplication integers polynomials nota tion dft polynomial q 2 pn simply f dft f linear f function h really n coordinate functions h n selftester simply choose qs randomly request program compute f q f xq verify holds suggests following generalization case arbitrary vector spaces simultaneous evaluation polynomial corresponds multiplying vector p ideas used test simultaneous evaluation polynomials dft extend give selftester linear transform represented vandermonde matrix matrix dft written vandermonde matrix f inverse dft converting polynomial pointwise representation coefficient form also vandermonde matrix whose entries given e gammaij follows inverse fourier transform selftested efficiently another point worth mentioning carrying inductive test selftester compute det f needs verify many randomly chosen qs identity e f qi holds operators elementary jordan canonical form linear operator said elementary jordan canonical form diagonal entries c elements left main diagonal first nonprincipal diagonal lower triangle 1s easy verify 0 matrix gamma1 top left corner 1 bottom right un r kumar sivakumar corner zeroes elsewhere therefore every vector space gives easy way implement inductive test selftester attempt extend matrices jordan canonical form even diagonal matrices seems work however diagonal shifted diagonal matrix special structure obtain selftesters avoid generator problem example matrix corresponding differentiation polynomials special structure contains entries n diagonal main diagonal differentiation integration polynomials differentiation polynomials linear function explicit form integration polynomials linear function pn pn1 explicit form h even though readily fit framework since form proof theorem 21 easily modified handle case using linearity completeness spell details robustness inductive test change required lemma 23 g pn pn1 linear function satisfies pr q2pn gxq 6 proof pr r2pn theta since event holds positive probability independent r holds probability one thus avoid generator bottleneck functions considered special case previous application higher order differentiation polynomials let k denote kth differential operator easy write recurrencelike identity k terms gives us selftester library setting described 5 20 one assumes programs compute differential operators wish selftest program computes k library lowerorder differentials assumption valid remedy use following lemma proved appendix lemma 24 q polynomial x degree k using identity selftester perform inductive test robustness inductive test established proof theorem 21 completeness outline key step let c denote coefficient term sum lemma 24 thus c gammax kgammai lemma 25 g linear function satisfies pr q2pn proof pr r2pn theta x first equality rewriting second equality holds probability 1gamma2ffl assumption pr q event holds positive probability independent r holds probability one thus testing g satisfies identity q suffices ensure g satisfies identity everywhere g satisfy identity know following conclude g j k induction need modify basis test test k base cases mod function let ff 2 k x monic irreducible polynomial let ff q denote mod function respect ff ff ff linear function addition interpreted mod ff addition since ff monic degree ff q always less deg ff c 2 k coefficient highest degree term ff q ae xm ff q deg xm ff q deg ff testing program p computes function ff step 3 selftester choose many qs random compute p sc q p sc xq verify one identities p sc holds depending degree q 3 multilinear functions section extend ideas x2 multilinear functions kvariate function f called klinear linear variables variables fixed ie fff main motivating example multilinear function polynomial multiplication bilinear note domain f generated n 2 generators form ie pairs generators suppose wish test p purports compute f naive approach would require generator tests n 2 generators requires 2 calls p rendering selftester highly inefficient blum luby rubinfeld 5 give efficient bootstrap selftester makes olog ok n calls p seen general klinear functions method extended yield tester makes olog ok n calls p context allowable think k constant since changing k results entirely different function f interested reducing number calls p respect un r kumar sivakumar problem size n specific function f complexity tester present independent n selftester required know correct value f one point previous section result applies many general multilinear functions large vector spaces define set properties depending f satisfied p would necessarily imply p must particular multilinear function f simplicity present following theorem f bilinear analog theorem 21 multilinear functions theorem 31 suppose f bilinear function v 2 ring r suppose p program f let ffl 14 suppose p satisfies following condition function g defined gff bilinear function v 2 g agrees p least 1 gamma 2ffl fraction inputs b furthermore suppose g satisfies following conditions proof simple extension proof 5 shows g bilinear better bounds ffl via different test obtained appealing 2 proof theorem 21 suffices show given three conditions stronger version condition 3 holds gff 1 h 2 addition last property shown g j f taking condition 2 ge 1 base case inducting obtaining e via application either generator 1 shown ge bases elements combined bilinearity property g implies correctness g every input proceed show required intermediate result given conditions 1 2 g satisfies stronger version condition 3 require pr theta h 2 first equality rewriting terms multilinearity g implies second third equalities probability prgff fourth equality fails probability less 4ffl rest equality follows multilinearity h 2 g ffl 14 probability nonzero since first last terms independent equal nonzero probability result follows similar approach works h 1 well multilinearity test repeat 1 ae times pick verify reject test fails basis test verify p sc inductive test repeat 1 ae times pick verify verify reject test fails note latter two tests use selfcorrected version p sc p notion selfcorrectors multilinear functions vector spaces implied random selfreducibility easy see theorem 31 extends arbitrary klinear function long ffl 12 k thus obtain following theorem whose proof mirrors theorem 22 theorem 32 f kvariate linear function ae 1 three tests comprise 2 k fflselftester f succeeds probability least 1 gamma ae 31 applications let q 1 q 2 denote polynomials x function mq multiplies two polynomials symmetric linear variable moreover since polynomial multiplication efficient selftester interesting application polynomial multiplication together mod function described x21 following wellknown degree n finite extension k finite field f isomorphic field fxff ff irreducible polynomial degree n f isomorphism element k viewed polynomial degree n f addition two elements sum polynomials multiplication q q 1 q 2 mod ff follows field arithmetic addition multiplication finite extensions finite field selftested without generator bottleneck number calls made program tested independent degree field extension 32 matrix multiplication let mn denote algebra n theta n matrices mn mn denote matrix multiplication matrix multiplication 14 f erg un r kumar sivakumar bilinear function however since matrix operation rather vector oper ation requires slightly different treatment general multilinear functions mn viewed additive group n 2 generators one possible set generators generator e ij matrix 1 position note generator e ij converted generator e k via sequence horizontal vertical rotations obtained multiplications special permutation matrix pi rotation operations correspond operator model multilinear func tions however two different kinds rotationshorizontal vertical due twodimensional nature input function h defining behavior function respect rotations always easily computable short actually performing matrix multiplication therefore exploit additional properties problem come set conditions sufficient p computing matrix multiplication f let 0 n denote subgroup mn contains matrices columns allzero theorem 33 let p program f ffl 18 suppose p satisfies following ffl function g defined gx bilinear function 2 n g agrees p least 1 gamma 2ffl fraction inputs b furthermore suppose g satisfies following conditions able prove theorem first need show conditions recounted stronger implications statements show strengthened versions conditions imply theorem 33 first show condition 2 implies stronger version lemma 34 condition 2 theorem 33 holds ge proof fact show something stronger show gx pr theta gx second equality holds probability condition 2 rest hold linearity g f result follows since ffl 14 lemma follows since n immediate adaptation proof lemma 34 used extend condition 3 hold inputs next show linearity g makes possible conclude hypothesis 4 g associative lemma 35 condition 4 theorem 33 holds g always associative proof pr theta first equality holds linearity g expanding xy z respectively second one true condition 8ffl last one recombination terms using linearity tools prove theorem 33 proof bilinearity g follows proof theorem 31 lemmas 34 35 condition 2 extended conditions 3 4 hold inputs show properties sufficient identify g matrix multiplication note multilinearity g write 1ijn 1kn 1ijkn implies g f using assumptions proceed show former holds first equality rewriting two generators terms generators second one follows strengthening condition 3 g computes f whenever one arguments equal power pi third one follows associativity g fourth one holds g f first input power pi rewriting e kj gamma2 fifth equality true g computes f correctly first argument e i1 consequence condition 2 see lemma 34 last one rewriting previous equality using associativity multiplication therefore g function f present test associativity un r kumar sivakumar associativity test repeat 1 ae times pick xy z 2r mn verify p sc x p sc reject test fails selftester built testing conditions 1 2 3 4 correspond property test basis test inductive test associativity test respectively note testing conditions 2 3 involve knowing value f random inputs inputs however come restricted subspace makes possible compute f easily efficiently following theorem immediate theorem 36 ae 1 ffl 18 fflselftester matrix multiplication succeeds probability least 1 gamma ae 4 nonlinear functions section consider nonlinear functions specifically deal exponentiation constant degree polynomials ring polynomials finite fields z p obvious exponentiation constant degree polynomials clearly defined ring 41 constant degree exponentiation first consider function q raising polynomial dth power suppose program p claims perform exponentiation degree n polynomials q 2 pn k x using lowdegree test rubinfeld sudan 19 see also 14 first test function computed p close degree polynomial g using selfcorrected version p sc p also verify ge 1 induction identity applies one test whether p satisfies property inputs remains show implies follow strategy similar case linear functions time using lagrange interpolation formula robust property identifies degree polynomial note idea similar use interpolation formula gemmell et al 14 extends 5 result linear functions lowdegree polynomials proceeding proof state following fact concerning lagrange interpolation identity fact 41 let g degree polynomial q 2 pn distinct elements pn also selftester comprises following tests degree test verify p close degree polynomial g lowdegree test reject test fails basis test verify p sc inductive test repeat 1 ae times pick ff 2r v verify p sc reject test fails let fi denote probability random choices domain produce distinct elements assume domain large enough fi close 1 assume p passes degree test p sc passes basis test agrees degreed polynomial g inputs note lowdegree test 19 makes o1ffl log1ae calls render decision confidence o1ffl log1ae calls compute g correctly probability ae3 sketch proof ffl p sc passes inductive test g satisfies time taken tester thetad ae constant pr first equality fact 41 applies since g verified degree polynomial since q uniformly identically distributed inductive test second equality fails probability 1ffl third equality rewriting fourth equality due fact 41 interpolation identity applied long q distinct event occurs probability fi since equality holds independent q ffl holds probability 1 theorem 42 function o1dselftester makes od queries 42 constant degree polynomials next consider extending result x41 arbitrary degree polynomials f pn p nd clearly lowdegree test basis test work interpolation identity valid missing ingredient availability identity like f shown robust property efficiently tested show get un r kumar sivakumar around difficulty idea based suggestion due r rubinfeld private communication nd degree polynomial eg suppose program p purports compute f strategy design selfcorrector r p estimate fraction inputs q p q 6 rq difficulty implementing idea directly using random selfreducibility f usefulness selfcorrector compute f correctly every input depends critically ability certify p correct inputs since checking whether p correct inputs precisely task selftesting seem going cycles circumvent problem design intermediate multiplication program q uses p oracle design program q prove following technical lemma helps us express dary multiplication terms fthat establish reduction multilinear function nonlinear function f reduction generalization degree elementary polarization identity slightly stronger works arbitrary polynomials degree degreed exponentiation lemma 43 x 2 f0 1g let x denote ith bit x polynomial degree x2f01g g using reduction given lemma 43 show construct fflself tester f following outline sketched 1 first build program q performs cary multiplication c simply multiply extra 1s program q selftested efficiently without generator bottleneck using 12 d1 selftester dvariate multilinear multiplication function x3 number queries made p process o1 constant depends degree f n dimensionality domain f thus q passes selftesting step computes multiplication correctly 12 d1 fraction inputs q fails selftesting process selftester rejects 2 next build reliable program q sc selfcorrects q using random selfreducibility multilinear multiplication function q sc used compute cary multiplication c correctly every input probability least 1 gamma ae constant ae 0 particular making o2 log calls hence o2 2d log calls p q sc used compute multiplication correctly every input probability least 1 gamma 110d 3 next use q sc build program r computes fq straightforward way using q sc compute required multiplications q sc computes multiplication correctly probability correctly input probability least 09 finally randomly picks o1ffl log1ae many samples q checks outputs pass iff p chosen values q easy see p computes f correctly inputs selftester output pass probability one converse suppose outputs pass upper bound probability event ae since q passes selftesting step step 1 computes multiplication correctly 12 d1 fraction inputs therefore use selfcorrector q sc described step 2 justified turn implies guarantee made r step 3 every input q probability least 09 step 4 probability p q 6 rq single random q least 09ffi probability p every random input q chosen step 4 therefore 1 gamma 09ffi thus probability outputs pass given pr q p q 6 fq ffl ae following theorem proven modulo proof lemma 43 theorem 44 function fq f polynomial q 2 pn degree o12 selftester makes o2 queries even though selftester makes o2 queries test degreed exponentiation number queries independent n dimensionality domain thus selftester attractive n large small particular conjunction testers finite field arithmetic described x31 selftesters described help us efficiently selftest constant degree polynomials finite field extensions large dimension remains prove lemma 43 lemma direct corollary following lemma illustrates method express dary multiplication terms f proof next lemma given appendix lemma 45 let distinct variables x 2 f0 1g let x denote ith bit x x2f01g appendix proof lemma 24 lemma 45 lemma 24 q polynomial x degree k proof induction k base case obviously true let k 0 since differentiation linear since first term 0 first sum vanishes since delta first sum evaluates 1q inductive hypothesis hence suffices show second sum evaluates 0 summation written tity sum split terms xdq second term seen un r kumar sivakumar gammaxkdq using induction hypothesis first third terms combined obtain kxdq using induction hypothesis thus entire lemma 45 let distinct variables x 2 f0 1g let x denote ith bit x x2f01g proof proof uses fourier transform boolean cube f0 1g us ing standard isomorphism f0 1g z denote space functions z c f finite vector space functions dimension 2 define inner product functions f x fxgx define function ff z x ff denote ith bits respectively x ff easy check whence every ff character z furthermore easy check h ff therefore characters ff form orthonormal basis f every function f z unique expansion basis ff f ff ff called fourier transform f coefficients b f ff called fourier coefficients f orthonormality basis b h ff fi easy property fourier transform ff 6 0 fact true nontrivial character group proof lemma note suffices prove lemma complex numbers p fix list complex numbers define function left hand side statement lemma 2 b thus x2z f ff x x 0n1 n c 0n1 n c x 0n1 n c x innermost sum zero ff every n impossible since way happen otherwise n 1 since easy see 2 b acknowledgments grateful ronitt rubinfeld valuable suggestions guidance thank manuel blum mandar mitra useful discussions thank dexter kozen comments grateful two anonymous referees valuable comments resulted many improvements exposition idea describing proof lemma 45 using fourier transforms also due one referees r checking approximate computations reals hiding instances multioracle queries designing programs check work theory testing meets test theory reflections pentium division bug functional equations modeling science engineer ing note selftestingcorrecting methods trigonometric functions locally random reductions interactive complexity theory approximating clique almost npcomplete fast probabilistic algorithms selftesting without generator bottleneck new directions testing testing polynomial functions efficiently rational mains robust characterizations polynomials applications program testing mathematical theory selfchecking robust functional equations applications selftesting correcting role algebra efficient verification proofs tr ctr kiwi algebraic testing weight distributions codes theoretical computer science v299 n13 p81106 marcos kiwi frdric magniez miklos santha exact approximate testingcorrecting algebraic functions survey theoretical aspects computer science advanced lectures springerverlag new york inc new york ny 2002
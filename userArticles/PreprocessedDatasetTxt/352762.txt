separating complexity classes using autoreducibility set autoreducible reduced turing machine ask input oracle use autoreducibility separate polynomialtime hierarchy exponential space showing turing complete sets certain levels exponentialtime hierarchy autoreducible exists turing complete set doubly exponential space notalthough already knew separate classes using diagonalization proofs separate classes solely showing different structural properties thus applying posts program complexity theory feel techniques may prove unknown separations future particular could settle question whether turing complete sets doubly exponential time autoreducible would separate either polynomial time polynomial space nondeterministic logarithmic space nondeterministic polynomial time else polynomialtime hierarchy exponential timewe also look autoreducibility complete sets nonadaptive bounded query probabilistic nonuniform reductions show settling autoreducibility questions also lead new complexity class separations b introduction complexity theorists made great strides understanding structure complexity classes yet found proper tools nontrivial separation complexity classes p np developed sophisticated diagonalization combinatorial algebraic techniques none ideas yet proven useful separation task back early days computability theory post 13 wanted show set noncomputable computably enumerable sets strictly contains turingcomplete computably enumerable sets call iposts programj see 11 15 post tried show classes dioeer nding property holds sets rst class set second would like resurrect posts program separating classes complexity theory particular show classes dioeer showing complete sets dioeerent structure separate classes already separable known diagonalization techniques feel renements techniques may yield new separation results paper concentrate property known iautoreducibilityj set autoreducible decide whether input x belongs polynomialtime making queries membership strings dioeerent x trakhtenbrot 16 rst looked autoreducibility unbounded spacebounded models ladner 10 showed exist turingcomplete computably enumerable sets autoreducible ambosspies 1 rst transferred notion autoreducibility polynomialtime setting recently yao 19 beigel feigenbaum 5 studied probabilistic variant autoreducibility known icoherencej paper ask complexity classes complete sets autoreducibil ity property particular show ffl turingcomplete sets delta exp autoreducible constant k delta exp sets exponentialtime turingreducible sigma p k ffl exists turingcomplete set doubly exponential space autoreducible since union sets delta exp k coincides exponentialtime hierarchy obtain separation exponentialtime hierarchy doubly exponential space thus polynomialtime hierarchy exponential space although results also follow space hierarchy theorems 9 known long time proof directly use diagonalization rather separates classes showing dioeerent structural properties issues relativization apply work oracle access see 8 polynomialtime autoreduction view much oracle exponential doubly exponential computation illustrate point show exists oracle relative complete set exponential time autoreducible note settle whether turingcomplete sets doubly exponential time autoreducible one way major separation result exists turingcomplete set doubly exponential time autoreducible get exponentialtime hierarchy strictly contained doubly exponential time thus polynomialtime hierarchy strictly contained exponential time turingcomplete sets doubly exponential time autoreducible get doubly exponential time strictly contained doubly exponential space thus polynomial time strictly polynomial space also show assumption implies separation nondeterministic logarithmic space nondeterministic polynomial time similar implications hold space bounded classes see section 5 autoreducibil ity questions doubly exponential time exponential space thus remain exciting line research also study nonadaptive variant problem main results scale one exponential follows ffl truthtablecomplete sets delta p truthtableautoreducible constant k delta p denotes sets polynomialtime turingreducible sigma p k ffl exists truthtablecomplete set exponential space truthtableautoreducible nding whether truthtablecomplete sets intermediate classes namely polynomial space exponential time truthtableautoreducible would major implications contrast results exhibit limitations approach restricted reducibility allowed ask two nonadaptive queries complete sets exp expspace eexp eexpspace etc autoreducible also argue uniformity crucial technique separating complexity classes nonautoreducibility results fail nonuniform setting razborov rudich 14 show strong pseudorandom generators exist inatural proofsj separate certain nonuniform complexity classes since paper relies uniformity essential way result apply regarding probabilistic variant autoreducibility mentioned strengthen results construct turingcomplete set doubly exponential space even probabilistically autoreducible leave analogue theorem nonadaptive setting open exist truthtable complete set exponential space probabilistically truthtable autoreducible show every truthtable complete set exponential time probabilistically truthtable autoreducible positive answer open question would establish exponential time strictly contained exponential space negative answer hand would imply separation nondeterministic logarithmic space nondeterministic polynomial time outline paper first introduce notation state preliminaries section 2 next section 3 establish negative autoreducibility results adaptive well nonadaptive case prove positive results section 4 also brieaey look randomized nonuniform settings section 5 discusses separations follow results would follow improvements finally conclude section 6 mention possible directions research 11 errata conference version previous version paper 6 erroneously claimed proofs showing turing complete sets expspace autoreducible truthtable complete sets pspace nonadaptively autoreducible combined additional results version would separation nl np see section 5 however proofs earlier version failed account growth running time recursively computing previous players moves use proof technique section 3 though unfortunately get weaker theorems original results claimed previous version remain important open questions resolving either way yield new separation results notation preliminaries complexity theoretic notation standard refer reader textbooks balczar daz gabarr 4 3 papadimitriou 12 use binary alphabet 1g denote dioeerence set set b ie subset elements belong b n b integer k 0 sigma k formula boolean expression form oe boolean formula q denotes 9 odd 8 otherwise n positive integers say 1 alternations pi k formula like 1 except starts 8quantier also k gamma 1 alternations qbf k formula sigma k formula 1 pi k formula integer k 0 sigma p k denotes kth sigmalevel polynomialtime hierarchy dene levels recursively sigma p k deltalevels polynomialtime exponentialtime hierarchy dened delta p respectively delta exp k polynomialtime hierarchy ph equals union sets delta p k exponentialtime hierarchy exph similarly union sets delta exp k reduction set set b polynomialtime oracle turing machine say reduces b write 6 p turing reduction nonadaptive oracle queries makes input independent oracle ie queries depend upon answers previous queries case write 6 p truthtable reductions functions sets dened similarly number queries input length n bounded qn write 6 p bounded constant write 6 p denote set queries input x oracle b q bx case nonadaptive reductions omit oracle b notation reduction asks one query answers answer query write reducibility 6 p r complexity class c set c 6 p r hard c 6 p r reduce every set 2 c c addition c 2 c call c 6 p r complete c integer k 0 set tqbf k true qbf k formulae 6 p complete sigma p k reduces fact set sat satisable boolean formulae 6 p complete np get key concept paper denition 21 set autoreducible reduction never queries input ie input x oracle b x 62 q bx call autoreduction also discuss randomized nonuniform variants set probabilistically autoreducible probabilistic autoreduction bounded twosided error yao 19 rst studied concept name icoherencej set nonuniformly autoreducible autoreduction uses polynomial advice notions consider adaptive nonadaptive case randomized autoreducibility nonadaptiveness means queries depend input random seed 3 nonautoreducibility results section show large complexity classes complete sets autoreducible theorem 31 6 p 2gammat complete set eexpspace autoreducible natural classes containing eexpspace eg eeexptime eeexpspace also property even construct complete set theorem 31 defeat every probabilistic autoreduc tion theorem 32 6 p 2gammat complete set eexpspace probabilistically autore ducible nonadaptive setting obtain theorem 33 6 p 3gammatt complete set expspace nonadaptively autore ducible unlike case theorem 31 construction seem yield truthtable complete set probabilistically nonadaptively autoreducible fact shall show section 43 result would separate exp expspace see also section 5 detail section 43 nonautoreducibility results hold nonuniform setting 31 adaptive autoreductions suppose want construct nonautoreducible turingcomplete set complexity class c ie set 1 autoreducible 2 turinghard c 3 belongs c c 6 p complete set k realizing goals 1 2 hard encode k time diagonalize autoreductions straightforward implementation would encode ky ah0 yi stagewise diagonalize 6 p reductions picking input x form h0 yi queried previous stages setting x however construction seem achieve third goal particular deciding membership diagonalization string x might require computing inputs length jxj c assuming runs time n c since potential autoreductions bound resources time space needed decide function tn 1 tn denotes amount resources deterministic turing machine accepting k uses suoece keep inside c remedy problem avoid need compute ky large inputs say length least jxj instead make sure encode membership strings set k time diagonalize input x argue considering two possible coding regions every stage opposed xed one left region l containing strings form h0 yi right region r similarly containing strings form h1 yi following states use one regions encode arbitrary sequence set region output input x xed indicates region used encoding either case setting l setting r x accepts setting r setting l x rejects allows us achieve goals 1 2 follows former case set encode k l stage otherwise set encode k r since value ax aoeect behavior input x diagonalize cases also case deciding k still easy given moreover crucially order compute ax longer decide ky large inputs length jxj instead check whether former case holds although quite complex task depends part constructed far value ky input length jxj verify whether encode sequence characteristic sequence k lengths least jxj time diagonalize input x provided complexity class c suoeciently powerful perform task c still catch though suppose found former case holds use left region l encode k stage know diagonalize input x setting bits right region r appropriately however deciding exactly set bits noncoding region requires addition determining region use coding knowledge ky jxj 6 jyj 6 jxj c order also circumvent need decide k large inputs use slightly stronger version obtained grouping quantiers blocks rearranging partition coding noncoding regions intervals make sure given interval length string interval previous intervals square length string interval blockwise alternately set bits coding region according k corresponding ones noncoding region maintain diagonalization input x way order compute bit ah1 zi noncoding region query k inputs jyj 6 jzj 2 opposed arbitrarily large c depending case happens next lemma prove general form need generalization later section 5 lemma 34 fix set k suppose decide simultaneously time tn space sn constructible monotone unbounded function suppose deterministic turing machine accepting tqbf takes time 0 n space 0 n qbf formulae size 2 n fin 2 log fin alternations set 1 autoreducible 2 k 6 p 3 decide simultaneously time o2 n 2 deltatn 2 2 n deltat 0 n space o2 n 2 proof lemma 34 fix function fi satisfying hypotheses lemma let standard enumeration autoreductions clocked runs time n fii inputs length n construction starts empty set adds strings subsequent stages dened following sequence note since runs time n fii query strings length n i1 input 0 n fix integer 1 let integer j 0 6 j 6 log fim let j denote set strings lengths interval 2 j 1 note log fim forms partition set strings lengths fim property 0 6 k 6 log fim length string k j square length string k ith stage construction encode restriction kj k use string 0 diagonalizing applying next strengthening 31 set least one following holds use q z y2y shorthand q z 1 variables quantied f0 1g without loss generality assume range pairing function hdelta deltai disjoint 0 proof claim 31 fix 2 hold negation holds ie switching quantiers log fim 4 yields weaker statement 3 formula 2 holds lexicographically rst value satisfying endfor lexicographically rst value satisfying endfor endif figure 1 stage construction set lemma 34 figure 1 describes ith stage construction set note lexicographically rst values algorithm always exist construction works ne argue resulting set satises properties lemma 34 1 construction guarantees end stage since input 0 query 0 autoreduction strings added subsequent stages even time write strings a0 holds nal set autoreduction since true autoreduction set autoreducible 2 stage encode kj left region ioe put 0 otherwise encode kj right region 2 therefore 3 first note contains strings form 0 strings form hb yi b 2 f0 1g 2 sigma assume executed construction including stage additional work decide membership string belonging ith stage follows case hold 2 qbf 2 log fim formula size case hb zi hb zi 2 ioe z 2 k decide time tjzj case hb zi say z 2 k 0 6 k 6 log fim order compute whether hb zi 2 run part stage corresponding values j figure 1 including k involves computing k k j deciding o2 jzj qbf 2 log fim formulae size o2 fim latter takes o2 jzj delta 0 time since every string k j size former time o2 jzj 2 similar analysis also shows perform stages including time together yields time bound claimed analysis space complexity analogous lemma using upper bound 2 n fin 0 n smallest standard complexity class lemma 34 applies seems eexpspace results theorem 31 proof theorem 31 lemma 34 set k 6 p complete set eexpspace section 42 see 6 p 2gammat statement theorem 31 optimal theorem 45 shows theorem 31 fails 6 p 2gammatt note proof theorem 31 carries 6 expspace reductions polynomially bounded query lengths implies strengthening given theorem 32 32 nonadaptive autoreductions diagonalizing nonadaptive autoreductions easier runs time n n coding strings interfere diagonalization opposed 2 n adaptive case allows us reduce complexity set constructed lemma 34 follows lemma 35 fix set k suppose decide simultaneously time tn space sn constructible monotone unbounded function suppose deterministic turing machine accepting tqbf takes time 0 n space 0 n qbf formulae size n fin 2 log fin alternations set 1 nonadaptively autoreducible 2 k 6 p 3 decide simultaneously time o2 n delta tn 2 0 n space o2 n sn 2 0 n proof lemma 35 construction set lemma 34 see figure 1 apart following dioeerences standard enumeration nonadaptive autoreductions clocked runs time n fii inputs length n note set qm x possible queries makes input x contains jxj fii elements ffl stage 1 construction denotes set strings lengths denotes set strings lengths note r aoeect validity predicate im 0 formula 2 corresponding formulae figure 1 2 ffl end stage figure 1 add following line ensures coding ky strings lengths n queried input 0 although essential choose encode left right region adjusting time space bounds appropriately proof satises 3 properties claimed carries additional case analysis third point namely one input form hb zi b 2 construction decide time tjzj crucial simplication adaptive case lies fact 2 similar formulae figure 1 become qbf 2 log fin formulae size fin opposed size o2 n fin lemma 34 lemma 35 consequence lower space complexity equivalent theorem 31 doubly exponential singly exponential yielding theorem 33 section 42 show reduce number queries 3 2 theorem 33 restrict number queries nonadaptive autoreduction allowed make xed polynomial proof technique theorem 33 also applies exp particular obtain theorem 36 6 p 3gammatt complete set exp 6 p btt autoreducible 4 autoreducibility results small complexity classes complete sets turn autoreducible beigel feigenbaum 5 established property levels polynomialtime hierarchy well pspace largest class known hold work section prove deltalevels exponentialtime hierarchy nonadaptive reductions question even open levels polynomialtime hierarchy show 6 p tt complete sets deltalevels polynomialtime hierarchy nonadaptively autoreducible complexity class containing exp prove 6 p 2gammatt complete sets 6 p 2gammatt autoreducible finally also consider nonuniform randomized autoreductions throughout section assume without loss generality encoding fl computation given oracle turing machine given input x following properties fl marked concatenation successive instantaneous descriptions starting initial instantaneous description input x ffl given pointer bit fl nd whether bit represents answer oracle query probing constant number bits fl ffl answer oracle query corresponding query substring prex fl point easily compute pointer beginning substring without probing fl ffl answer oracle query perform local consistency check bit depends constant number previous bit positions fl input x formally exist function g predicate e polynomialtime computable constant c following holds input x index bit position fl j 1 index larger indicates whether fl passes local consistency test ith bit fl provided prex fl including position correct local consistency test passed ioe fl correct call encoding valid computation input x ioe local consistency tests 5 bit positions correspond oracle answers passed bits equal oracles answer corresponding query string call computation 41 adaptive autoreductions rst show every 6 p complete set exp autoreducible generalize deltalevels exponentialtime hierarchy theorem 41 every 6 p complete set exp autoreducible proof idea standard deterministic complexity classes c decide bit computation given input x within c 6 p complete set c decided machine within connes class c 6 p reduce deciding ith bit computation input x consider two possibly invalid computations obtain applying every bit position reduction answering queries except x according assuming x 2 one computation x 62 note computation corresponding right assumption ax certainly correct computations yield answer eoeciently check using without querying x answer correct computation contains mistake check computations entirely see one right given pointer rst incorrect bit wrong computation eoeciently verify mistaken checking constant number bits computation pointer computable within c case c exp using 6 p reduction assuming x 2 x 62 determine pointer oracle without querying x polynomial time since pointers length polynomially bounded details proof theorem 41 fix 6 p complete set exp say accepted turing machine computation input size n length 2 pn xed polynomial p without loss generality last bit computation gives nal answer let g e c formalization local consistency test described 5 let hx ii denote ith bit computation input x compute exp oracle turing machine r 6 p reducing let oex rst r anfxg exists compute oe exp 6 p reduction r oe oe consider algorithm figure 2 deciding input x algorithm polynomialtime oracle turing machine oracle query input x argue correctly decides input x distinguish two cases case r anfxg since least one computations r anfxg hx deltai r afxg coincides actual computation input x last bit computation equals nal decision correctness follows r anfxg accept ioe r afxg else r afxg oe x accept ioe e x endif figure 2 autoreduction set theorem 41 input x case r anfxg contains mistake variable gets correct value index rst incorrect bit computation local consistency test r anfxg computation input x fails ith bit accept x x 62 r anfxg hx deltai valid computation local consistency test fails reject x theorem 41 local checkability property computations used proof theorem 41 relativize oracle computation steps depend entire query ie number bits limited resource bounds base machine case exponentially many next show theorem 41 also relativize theorem 42 relative oracle exp 6 p 2gammat complete set autoreducible proof note exp following property property 41 oracle turing machine n running exp oracle b set accepted n b 6 p complete exp b without loss generality assume n runs time 2 n let k b denote set accepted construct oracle b set 6 p 2gammat complete exp b construction lemma 34 see figure 1 reductions also access oracle b encode b information construction reduces complexity relative b high enough destroy 6 p 2gammat completeness exp b diagonalizations 6 p b autoreductions construct b stages along start b empty using notation lemma 34 beginning stage add b ioe property 2 hold end substage j union b 2 holds stage note aoeect value k b computations inputs size suoeciently large log follows analysis proof lemma 34 set 6 p 2gammat hard exp b 6 p b regarding complexity deciding relative b note encoding oracle b allows us eliminate need evaluating qbf log fin formulae size 2 n fin instead query b easily constructed inputs size o2 n 2 therefore drop terms corresponding qbf log fin formulae size 2 n fin complexity consequently 2 exp b theorem 42 theorem 42 applies complexity class containing exp property 41 eg expspace eexp eexpspace etc sometimes structure oracle allows get around lack local checkability oracle queries case oracles polynomialtime hierarchy leads following extension theorem 41 theorem 43 integer k 0 every 6 p complete set delta exp k1 autoreducible proof idea follows let 6 p complete set accepted deterministic oracle turing machine oracle tqbf k first note polynomialtime turing machine n query q belongs oracle tqbf k ioe size polynomial jqj consider two purported computations input x constructed proof theorem 41 one belongs party assuming x 2 one party assuming x 62 computation corresponding right assumption correct one might suppose computations dioeer given pointer rst bit position disagree turns answer oracle query q two parties play kround game underlying 6 party claiming q 2 tqbf k plays existentially quantied one universally quantied players strategies consist computing game history far determining optimal next move 6 p reducing computation nally producing result reduction respective assumption ax guarantee party correct assumption plays optimally since also one claiming correct answer oracle query q win game ie nq answer bit thing autoreduction determine value nq polynomial time using oracle without querying x along lines base case algorithm given figure 2 process local consistency test computation requires knowledge bits compute via reduction dening strategy corresponding player bits q need retrieve mcomputations since computations correct point nished generating q know nq easily decide correct assumption ax construction hinges hypothesis 6 p reduce determining players moves computing moves become quite complex though recursively reconstruct game history far number rounds k constant seems crucial keeping complexity control conference version paper 6 erroneously claimed proof works expspace thought alternating exponential time exponential number alternations establishing theorem 43 expspace would actually separate nl np see section 5 proof theorem 43 let 6 p complete set delta exp k accepted exponentialtime oracle turing machine oracle tqbf k let g e c formalization local consistency test described 5 without loss generality polynomial p polynomialtime turing machine n inputs size n makes exactly 2 pn oracle queries form q length 2 p 2 n moreover computations n 7 length 2 p 3 n last bit represents answer holds computations inputs length n let g n e n c n formalization local consistency test n rst dene bunch functions computable delta exp k1 say x oracle turing machine r 6 p reduces nal autoreduction use proofs compute functions delta exp straightforward let hx ii denote ith bit computation tqbf k input x oex rst r anfxg ii roles oe proof theorem 41 use r gure whether possible answers oracle query lead nal answer use r oe nd pointer rst incorrect bit simulated computation getting negative oracle answer x 62 turns point oracle query proceed proof theorem 41 otherwise make use following functions associated reductions dene functions j inductively level rst dene j induces reduction r j dene based r j functions take input x ith bit r anfxg hx deltai answer oracle query 7 oe x dene j x lexicographically least value exist set j note righthand side 8 1 ioe existentially quantied 7 r afxg r anfxg condition righthand side 9 means use hypothesis x 2 compute x r j case ffl either existentially quantied 7 player assuming x 2 claims 7 holds ffl else universally quantied player assuming x 2 claims 7 fails otherwise use hypothesis x 62 case points answer oracle query 7 functions j reductions r j incorporate moves successive rounds game underlying 7 reduction r j together players assumption membership x determines actual move th round namely r afxg th round played opponent assuming otherwise condition righthand side 9 guarantees existentially quantied variables determined opponent claiming query 7 true formula universally quantied ones opponent particular 9 ensures opponent correct claim 7 wining strategy provided exists function denes winning move th round game opponent playing round given way previous rounds actually played described yxs odd ie existentially quantied tries set remainder 7 holds otherwise tries set remainder 7 fails actual move may dioeer one given j case players assumption x 2 incorrect opponent correct assumption plays according j since opponent also makes correct claim 7 win game case nq hold ioe 7 holds finally dene functions similar job functions respectively oe computation nq instead computation tqbf k x precisely hx ri equals rth bit computation nq 1 dened 9 bit index oe x computation r anfxg answer oracle query 7 dene x rst r r anfxg r afxg ri provided bit index oe x computation r anfxg hx deltai answer oracle query functions corresponding reductions describe autoreduction input x works described figure 3 next argue algorithm correctly decides input x checking properties required autoreduction straightforward consider cases r anfxg points answer oracle query r anfxg deltai refer analysis proof theorem 41 remaining cases case r anfxg points rst incorrect bit r anfxg hx deltai turns answer oracle query say 7 yields correct oracle answer 7 r anfxg accept x x 62 r anfxg give correct answer oracle query points computation r anfxg deltai equal reject x r anfxg accept ioe r afxg else r afxg oe x ith bit r anfxg deltai answer oracle query accept ioe e x else r anfxg accept ioe r anfxg else r r afxg accept ioe e n q r anfxg q denotes query described r anfxg ith bit computation answer r afxg r anfxg endif endif endif figure 3 autoreduction set theorem 43 input x case r anfxg described figure 3 use local consistency test r anfxg computation nq 1 x apart bits purported computation r anfxg hx deltai test may also need bits q xs xs computed straightforwardly using denition 9 bits q might need retrieved r anfxg deltai encoding scheme computations property query q substring prex computation position indexed since either r anfxg hx deltai correct everywhere else rst position incorrect description q r anfxg hx deltai correct case moreover easily compute pointer beginning substring q r anfxg hx deltai hx deltai error computation gets assigned index rst incorrect bit computation local consistency check fails accept x x 62 r anfxg hx deltai valid computation nq 1 every local consistency test passed reject x theorem 43 42 nonadaptive autoreductions far constructed autoreductions 6 p complete sets input x looked two candidate computations obtained reducing answering oracle queries except x according answering query x positively one candidate negatively candidates disagreed tried nd right one always existed managed get idea work quite powerful sets eg expcomplete sets exploiting local checkability computations allowed us gure wrong computation without going entire computation help rst computed pointer rst mistake wrong computation veried locally use adaptive approach constructing nonadaptive autoreductions seems like guring wrong computation nonadaptive way requires autoreduction perform computation base machine base machine run polynomial time checking computation essentially boils verifying oracle answers using game characterization polynomialtime hierarchy along lines theorem 43 oracles polynomialtime hierarchy theorem 44 integer k 0 every 6 p tt complete set delta p k1 nonadaptively autore ducible parallel adaptive case earlier version paper 6 stated theorem 44 unbounded k ie pspace however get proof work constant k section 5 see proving theorem 44 pspace would separate nl np additional dioeculty proof nonadaptive setting know player perform even rounds one odd rounds kround game underlying query like 6 play scenarios afterwards gure relevant run proof theorem 44 let 6 p tt complete set delta p k accepted polynomialtime oracle turing machine oracle tqbf k without loss generality polynomial p polynomialtime turing machine n inputs size n makes exactly pn oracle queries q q length p 2 n let qx denote ith oracle query tqbf k input x note k g set q belongs delta p 6 p reduction rq q given input x r afxg q r anfxg q agree hx ji every 1 6 j 6 pjxj home simulate base machine using r afxg answer jth oracle query otherwise make use following functions computable delta p corresponding oracle turing machines r j 1 tt reductions functions proof theorem 43 dene j inductively k dened inputs x smallest 1 6 6 pjxj r anfxg ii value j x equals lexicographically least set j string exist righthand side 11 1 ioe existentially quantied 10 r afxg r anfxg condition righthand side 12 means use hypothesis x 2 compute x r j case ffl either existentially quantied 10 assumption x 2 leads claiming ffl else universally quantied assumption x 2 leads claiming 10 fails intuitive meaning functions j reductions r j similar proof theorem 43 capture moves th round game underlying 10 function j encapsulates optimal move round exists reduction r j players assumption regarding membership x produces actual move round condition righthand side 12 guarantees correct alternation rounds refer proof theorem 43 intuition consider algorithm figure 4 note queries algorithm figure 4 r anfxg accept ioe accepts x jth oracle query answered r afxg else rst j r anfxg accept ioe nq q denotes ith query input x answer jth oracle query given r afxg r afxg r anfxg endif figure 4 nonadaptive autoreduction set theorem 44 input x needs make queries rq dioeerent x inputs hx ji 1 6 j 6 pjxj queries r j dioeerent x input x 1 6 6 k since rq r j nonadaptive follows figure 4 describes 6 p tt reduction query input similar simplied argument proof theorem 43 shows accepts nonadaptively autoreducible theorem 44 next consider restricted reductions using dioeerent technique show theorem 45 complexity class c every 6 p 2gammatt complete set c 6 p 2gammatt autoreducible provided c closed exponentialtime reductions ask one query smaller length particular theorem 45 applies view theorems 31 33 implies theorems 31 33 45 optimal proof exploits ability exp simulate polynomialtime reductions construct auxiliary set within c 6 p 2gammatt reductions xed complete set property induces autoreduction proof theorem 45 standard enumeration 6 p 2gammatt reductions runs time n inputs size n let 6 p 2gammatt complete set c consider set contains strings form h0 decided algorithm figure 5 input except deciding ax algorithm runs case truthtable input h0 xi truthvalue query x set ax constant rejects form iy 62 aj accept ioe x 62 otherwise accept ioe x 2 endcase figure 5 algorithm set theorem 45 input h0 exponential time therefore given conditions c 6 p reduction j construction diagonalizes every 6 p reduction whose truthtable input h0 would become constant lled membership bit x therefore every input x one following cases holds truthtable j input h0 ffl reduced truthtable form iy 2 aj 6 x ffl reduced truthtable form iy 62 aj 6 x ffl truthtable depends membership 2 strings dioeerent x j query x input h0 j xi accepts ioe x 2 analysis shows algorithm figure 6 describes 6 p 2gammatt reduction accept ioe accepts else unique element qm j accept ioe 2 endif figure autoreduction constructed proof theorem 45 theorem 45 43 probabilistic nonuniform autoreductions previous results section trivially imply 6 p complete sets deltalevels exponentialtime hierarchy probabilistically autoreducible 6 p tt complete sets deltalevels polynomialtime hierarchy probabilistically nonadaptively autoreducible randomness allows us prove nonadaptive case first establish theorem 44 exp theorem 46 let f constructible function every 6 p fngammatt complete set exp probabilistically ofngammatt autoreducible particular every 6 p tt complete set exp probabilistically nonadaptively autoreducible proof theorem 46 let 6 p fngammatt complete set exp apply pcp theorem exp 2 lemma 47 2 constant k set 2 exp polynomialtime turing machine v polynomial p input x ffl x 2 exists proof oracle pr ffl x 62 proof oracle pr moreover v never makes k proof oracle queries proof oracle 2 exp independent x 13 holds case x 2 translating lemma 47 terminology obtain lemma 48 constant k set 2 exp probabilistic 6 p reduction n set b 2 exp input x ffl x 2 n b x always accepts ffl x 62 oracle c n c x accepts probability 1 3 let r 6 p fngammatt reduction b consider probabilistic reduction input runs n input x oracle r afxg probabilistic 6 p k deltaf ngammatt reduction never queries input following shows denes reduction accepts ffl x 62 accepts probability 1theorem 46 note theorem 46 makes plausible manage scale theorem 32 one exponent expspace nonadaptive setting able results section 3 going adaptive nonadaptive case would separate exp expspace suggest extension theorem 46 deltalevels exponentialtime hierarchy interesting problem research second theorem 44 also holds np theorem 49 6 p tt complete sets np probabilistically nonadaptively autoreducible proof theorem 49 fix 6 p tt complete set np let ra denote length nondecreasing 6 p reduction sat dene set boolean formula say variables 9 6 p reduction rw w use following probabilistic algorithm valiant vazirani 18 lemma 410 18 exists polynomialtime probabilistic turing machine n input boolean formula n variables outputs another quantier ffl satisable probability least 1 4n oe unique satisfying assignment ffl satisable oe never satisable consider following algorithm input x run n input ra x yielding boolean formula oe say variables accepts ioe oer afxg evaluates true note algorithm describes probabilistic 6 p tt reduction never queries input moreover ffl x 2 probability least 1 valiantvazirani algorithm n produces boolean formula oe unique satisfying assignment oe case assignment use r afxg accept x ffl x 62 boolean formula oe n produces satisfying assignment always reject x executing thetan independent runs algorithm accepting ioe accepts yields probabilistic nonadaptive autoreduction theorem 49 probabilistic autoreductions get similar results deterministic ones low end complexity classes turn property complete sets autoreducible whereas high end complexity classes see detail next section structural dioeerence yields separations allow nonuniformity situation changes dramatically since probabilistic autoreducibil ity implies nonuniform autoreducibility 5 positive results small complexity classes carry nonuniform setting see next negative results also complete sets large complexity classes become autoreducible adaptive nonadaptive case uniformity crucial separating complexity classes using autoreducibility razborovrudich result 14 apply feigenbaum fortnow 7 dene following concept probustness also consider nonadaptive variant denition 41 set probust p fp nonadaptively probust p fp tt nonadaptive probustness implies probustness usual deterministic nondeterministic complexity classes containing pspace 6 p complete sets probust deterministic classes containing pspace also true 6 p tt complete sets nonadaptively probust following connection nonuniform autoreducibility holds theorem 411 probust sets nonuniformly autoreducible nonadaptively probust sets nonuniformly nonadaptively autoreducible proof feigenbaum fortnow 7 show every probust language randomselfreducible beigel feigenbaum 5 prove every randomselfreducible set nonuniformly autoreducible iweakly coherentj call proofs carry nonadaptive setting follows 6 p tt complete sets usual deterministic complexity classes containing pspace nonuniformly nonadaptively autoreducible holds adaptive reductions case property also true nondeterministic complexity classes containing pspace particular get following corollary 412 6 p complete sets nexp expspace eexp neexp eexpspace nonuniformly autoreducible 6 p tt complete sets pspace exp expspace nonuniformly nonadaptively autoreducible 5 separation results section see use structural property complete sets autoreducible separate complexity classes based results sections 3 4 get separations already known exph 6 eexpspace theorems 43 31 theorems 46 32 ph 6 expspace theorems 44 33 also scaling exph 6 eexpspace however settling question certain classes would yield impressive new separations summarize implications figure 7 theorem 51 figure 7 positive answer question rst column implies separation second column negative answer separation third column question yes 6 p complete sets expspace autoreducible nl 6 np ph 6 pspace 6 p complete sets eexp autoreducible 6 p tt complete sets pspace 6 p 6 p tt complete sets exp 6 p 6 p tt complete sets expspace probabilistically 6 p figure 7 separation results using autoreducibility entries figure 7 follow directly results previous sections order nish table use next lemma lemma 52 nl decide validity qbfformulae size ff alternations deterministic turing machine 1 time oc ff nondeterministic turing machine 2 space oc ff log constant c proof lemma 52 cooks theorem transform polynomial time pi 1 formula free variables equivalent sigma 1 formula free variables vice versa since decide validity sigma 1 formulae polynomialtime say transformation algorithm satisability algorithm run time n c constant c let oe qbfformula size ff alternations consider following algorithm deciding oe repeatedly apply transformation largest suoex constitutes sigma 1 whole formula becomes sigma 1 run algorithm correctly decides truth oe since number alternations decreases one every iteration makes ff calls time raising length formula power c follows algorithm runs time oc ff moreover since padding argument shows dtime time constructible function therefore result holds lemma 52 allows us improve theorems 32 33 follows hypothesis theorem 53 6 p 2gammat complete set expspace probabilistically autoreducible holds eexp instead expspace proof combine lemma 52 probabilistic extension lemma 34 used proof theorem 32 theorem 54 6 p 3gammatt complete set pspace nonadaptively autoreducible holds exp instead pspace proof combine lemma 52 lemma 35 ingredients establishing figure 7 proof theorem 51 nl 6 np implications iyesjcolumn figure 7 immediately follow theorems 53 54 contraposition theorem 31 positive answer 2nd question figure 7 would yield eexp 6 eexpspace theorem 33 positive answer 4th question would imply exp 6 expspace padding translate p 6 pspace similarly theorem 43 negative answer 2nd question would imply exph 6 eexp pads ph 6 exp negative answer 4th question would yield ph 6 exp directly theorem 44 token negative answer 1st question results exph 6 expspace ph 6 pspace negative answer 3rd question pspace theorem 46 negative answer last question implies exp 6 expspace p 6 pspace note tighten separations figure 7 bit apply lemmata 34 35 smaller classes theorems 31 respectively 33 one improvement along lines might warrant attention replace inl 6 npj figure 7 condition suoeces theorems 53 54 since strengthen lemma 52 follows lemma 55 conp np nspacelog o1 n decide validity qbfformulae size ff alternations deterministic turing machine 1 time oc ff nondeterministic turing machine 2 space od ff log constants c 6 conclusion studied question whether complete sets autoreducible various complexity classes various reducibilities obtained positive answer lower complexity classes section 4 negative one higher complexity classes section 3 way separated lower complexity classes higher ones highlighting structural dioeerence resulting separations new argued section 5 settling question intermediate complexity classes would provide major new separations believe renements techniques may lead would like end words thoughts direction one look complete sets let c 1 c 2 suppose know complete sets c 2 autoreducible suoeces construct eg along lines lemma 34 hard set c 1 autoreducible order separate c 1 c 2 mentioned end section 5 improve theorem 31 bit applying lemma 34 smaller spacebounded classes eexpspace hope gain much though since coding proof lemma 34 seems dspace2 n fin complete log fin formulae size 2 n fin involved inputs size n holds theorem 33 lemma 35 generalizations autoreducibility may allow us push things example one could look knautoreducibility kn bits set remain unknown querying machine theorem 43 goes kn 2 olog n perhaps one exploit leeway coding lemma 34 narrow gap positive negative results discussed section 5 would yield interesting separations finally one may want look properties autoreducibility realize posts program complexity theory perhaps another concept computability theory articial property used separate complexity classes acknowledgments would like thank manindra agrawal ashish naik helpful discussions also grateful carsten lund muli safra answering questions regarding pcp theorem thank anonymous referees nice suggestions present results r proof verication hardness approximation problems incoherent without hard using autoreducibility separate complexity classes randomselfreducibility complete sets role relativization complexity theory computational complexity algorithms mitotic recursively enumerable sets classical recursion theory computational complexity recursively enumerable sets positive integers decision problems natural proofs recursively enumerable sets degrees autoreducibility autoreducibility np easy detecting unique solutions coherent functions program checkers tr ctr christian glaer mitsunori ogihara pavan alan l selman liyu zhang autoreducibility mitoticity immunity journal computer system sciences v73 n5 p735754 august 2007 luca trevisan salil vadhan pseudorandomness averagecase complexity via uniform reductions computational complexity v16 n4 p331364 december 2007
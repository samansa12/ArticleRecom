specificationbased browsing software component libraries specificationbased retrieval provides exact contentoriented access component libraries requires much deductive power specificationbased browsing evades bottleneck moving deduction offline indexing phase paper show match relations used build appropriate index formal concept analysis used build suitable navigation structure structure singlefocus property ie sensible subset library represented single node supports attributebased via explicit component properties objectbased via implicit component similarities navigation styles thus combines exact semantics formal methods interactive navigation possibilities informal methods experiments show current theorem provers solve enough emerging proof problems make browsing feasible navigation structure also indicates situations additional abstractions required build better index thus helps understand reengineer component libraries b introduction large software libraries represent valuable assets larger grow harder becomes capitalize reuse purposes main problems keep overview library extract appropriate components requires better library organizations retrieval algorithms linear search list components libraries thus often structured syntactic means eg inheritance hierarchies misleading need express semantic relation components information science oers semantic methods library organization component retrieval eg 17 24 methods informal rely meaning conveyed words exact alternative application formal specication methods software libraries investigated starting 10 23 25 general idea quite simple component indexed formal specication captures relevant behavior desired relation two components eg renement matching expressed logical formula composed work supported dfg within schwerpunkt deduktion grant sn1123 indices automated theorem prover used check validity formula prover succeeds relation considered established ambitious approaches specicationbased retrieval 21 22 18 26 6 allows arbitrary specications search keys retrieves components library whose indexes satisfy given match relation respect key however spite research eorts cf 19 detailed survey still far away practicable notwithstanding progress automated deduction required theorem proving capabilities remain main bottleneck investigate practical approach specication based browsing component libraries crucial success factor timeconsuming deduction moved oline indexing phase pre processing thus separated navigation user works preprocessed xed navigation structure ects semantic properties components respect index show dierent match relations must used build appropriate index formal concept analysis used build concept lattice serves navigation structure techniquesspecicationbased library organization 9 18 conceptbased browsing 7 12have proposed combination new unique research thus combines exact semantics formal methods interactive navigation informal methods experiments show approach feasible apart writing specications rst place indexing fully automated current theorem provers solve enough emerging problems even modest timeouts calculation concept lattice fast enough navigation works without delay specicationbased browsing useful reuse also analyz ing understanding reengineering component libraries although browsing dened via specications actually required navigation instead symbolic names used hide actual formulas intelligent choice abstractions thus speedup improve standing lattice even indicates situations additional abstractions required build better index browsing vs retrieval library browsing retrieval closely related following 19 clear distinction made retrieval consists extracting components satisfy predened matching criterion main operation thus satisfaction check matching criterion usually given arbitrary userdened search query matched candidates indices browsing consists inspecting candidates possible extraction without predened criterion main operation thus navigation determines order components visited whether visited browsing usually works stepwise denote set components visited next step focus contrast retrieval requires search key works preprocessed usually hierarchical navigation struc ture obvious although optimal way compute structure order components inclusion retrieval results using index query specicationbased case dierences prove crucial greater practicability browsing preprocessing navigation structure allows us resort oline proving thus evade deductive bottleneck less obvious equally important construction hierarchy via crossmatch component library benets proof problems since arbitrary user specications involved spec ications much uniform style allows obvious prover tuning however real gain comes absence data mismatches consider example graph library graphs represented map nodes node sets query using representation list node pairs prover must repeatedly candidate show data representations equivalent although signature matching mitigate data mismatch problem 6 still major source complexity deductionbased retrieval renement lattices reconsidered formal specications used order components hence organize libraries hierarchically hierarchies exploited optimize retrieval compute navigation structure obvious question order components obvious answer renement plugin compatibility 21 6 given two components g respective axiomatic specications pre g post g pre post said rene g specic g w g g subsume pre g pre holds 1 intuitively 1 expresses fact plugged place g used wider domain produces specic results g using relational view ie specications considered sets valid input outputpairs 18 show 1 denes partial order induces latticelike structure set specications structure generally known renement lattice although strictly spoken lattice turning renement lattice navigation structure library browsing exposes however unexpected problems first libraries oer enough structure ie renement hierarchies induce shal low good thing design point viewit simply says library contains little redundancyit bad thing browsing overcome introduction metanodes abstractions specications represent real existing components factor 1 sake brevity shall omit quantication respective argument return variables identication via type compatibility predicates arguments x result variables full form pre x post g x g g similarities example consider specication abstract element lter 2 lter l list r list pre l post exists l1 lter species singleton element removed list hence cannot empty one thus via 1 rened components tail lead list lead l list pre l pre l post exists post exists however nave introduction metanodes yields unexpected results introduce another metanode segment segment l list pre true post exists l1 l2 list capture property components return continuous sublists argument work neither tail lead rene segment reason rst glance counterintuitive behavior segment specied total function pre segment tail lead partial x particular aw setting segments precondition also becomes increasingly infeasible library also contains components work sorted lists integrate property precondition eect want abstraction captures segmentlike components adjoin occurring preconditions con junctively however two contradictory result becomes false segment subsumes entire library solution dilemma easy use renement index components abstractions additionally need second relation model situation since interested eect calculation ie postcondition post g drop pre g want post g hold appropriate domain hence pre post g 2 also known conditional compatibility 6 weak post match 21 deductionbased retrieval consider g derived attribute feature 22 holds whenever execution legal pre holds terminated post holds example segment feature tail lead expected easy verify features inherited along renement relation ie r renes g feature g feature r use vdmsl example specications means concatenation lists empty list singleton list item reads similar problem arises want consider preconditions use abstraction total list pre true post true subsume total functions much harder index partial functions properly metanode requires non empty l list pre l post true correctly subsumes functions work nonempty lists really appropriate also subsumes total functions thus discriminative hence need third relation since interested properties legal domains drop postconditions contrast renement want domain restricted hence pre pre g 3 g derived attribute sit requisite w r gand using 3 requires non empty works index requisites also compatible renement contrast features absence propagated r renes g requisite g cannot requisite r top run lead tail duplicate rst requires non empty segment front segment works empty total lter top run w w f w f w w lead tail w w r w f w duplicate rst w w r figure 1 example index figure 1 shows index examples paper components represented rows attributes columns symbols indicate relations used index components respective attributes also see library indeed shallow component indexes however 13 sensible relations could use instead indexing component requisites could also index requisites require ie valid border conditions terms preconditions formalized pre g pre 4 denoted w r g g requisite also works g hence course tail 6w r requires non empty topological sort function top list pre acyclicl post top top sort w r requires non empty expected however principle 4 necessary achieve eect using modied version works empty l list pre post true requires non empty renement top sort w works empty 3 however hides fact requires non empty works empty complementary use 13 4 compute appropriately modied version renement lattice even variant yet adequate browsing still lacks singlefocus property ie contain enough structure represent focus single node consider example lead tail apart renements two components feature segment subsumed lter time 5 yet metanode represent user keep focus distinguishing properties capture conceptual similarity components deeper reason even modied renement lattice latticelike properties set possible specications arbitrary subsets libraries true lattices hand singlefocus property denition show embed renement lattice true lattice using formal concept analysis 4 concept lattices 41 formal concept analysis formal concept analysis 30 8 3 applies latticetheoretic methods investigate abstract relations objects attributes concept lattice structure strong mathematical properties reveals hidden structural hierarchical properties original relation computed automatically given relation 3 notice relies fact post works empty trueotherwise postcondition part 1 would valid 4 still need renement represent information interest eg cannot split total requisite feature value true index library 5 lter remove element segment allowed split list hence two choices remove element either end list denition 1 formal context triple r sets objects attributes respectively r arbitrary relation contexts imagined cross tables rows objects columns attributes hence index shown figure 1 also considered formal context provided dierent relations ie w w r w f merged denition 2 let r context common attributes dened def rg common objects def rg objects context share set common attributes vice versa concepts pairs objects attributes synonymous thus characterize denition 3 let c context called concept c c def called cs extent intent respectively set concepts c denoted bc concepts imagined maximal rectangles modulo permutation rows columns context table eg flead tailg fsegment requires non empty lter someg partially ordered inclusion extents intents concepts extent includes extent subconcepts intent includes intent superconcepts denition 4 let c context c 1 c 2 ordered subconcept relation c 1 c 2 1 2 structure b denoted bc intentpart follows duality immediate consequence preceding denitions get strict order corresponds strict inclusion extents intents ie c 1 1 following basic theorem formal concept analysis states structure induced concepts formal context ordering always complete lattice cf figure 2 example lattice theorem 5 30 let c context bc complete lattice concept lattice c inmum supremum operation given i2i i2i i2i i2i i2i i2i attribute object uniquely determined dening concept lattice calculated attribute object respectively alone denition 6 let bo r concept lattice dening concept attribute 2 object greatest smallest concept c 2 c 2 c holds denoted theorem 7 3 concept lattice 42 renement lattices concept lattices 12 shown keywordindexed components considered formal context components objects informal keywords attributes lift idea formal specications denition 8 let formally specied library components l requisites r features f abstractions induced context dened consider components objects course keywords replaced names specications 6 context table slightly complicated prevent dierent components collapsing single concept index insucient component specications l double objects attributes relations however remain original works empty segment ii requires non empty total front segment iii lter top sort top sort run run iv lead lead tail tail duplicate rst duplicate rst figure 2 example lattice calculate concept lattice context figure 2 shows result example context bullet represents concept labels 6 wlog assume l r f pairwise disjoint bullet attributes dened concept eg concept iii denes attribute lter however since attributes representation inherited downwards intent set fsegment requires non empty lter someg none attributes equivalent sense index set components hence concept introduces one attribute labels bullet denote objects dened concept eg lead iv since none actual components subsumes concept introduces one object atomic introduces object concept lattice extension renement lattice two attributes 1 2 1 2 possible completely unrelated ie neither relations 13 holds however two reasons adequate representation index first subconcepts preserve renement original components second superconcept distinguished subconcept attribute valid least one component extent superconcept valid components extent subconcept formally theorem 9 let bcl concept lattice context cl induced library l c 1 either 1 9m 2 2 9 2 r 2 c 1 9 2 f 2 c 1 9 2 2 c 1 theorem follows denitions 3 4 makes concept lattice already suitable specicationbased navigation however impose even structure double r use w r addition dene induced context theorem 9 holds appropriately additionally get theorem 10 let bcl concept lattice context cl induced library l two complementary requisites 2 r consequently u hence dening concepts two complementary requisites complementary lattice moreover extents divide entire library two partitions case two arbitrary complementary nodes lattice 5 navigation concept lattices 12 also shown concept lattices used navigation structure interactive incremental retrieval ie browsing terminology focus represented extent concept narrowing focus downward movement lattice done two steps 1 user selects additional attribute consequence lattice structure system support selection calculating attributes actually narrow focus sweep entirely thus prevent navigation dead ends ie empty focus 2 system calculates new focus lattice meet exists due theorem 5 actual focus dening concept selected attribute obtained theorem 7 similarly focus also widened deselecting attribute system calculates new focus using join operation specicationbased case navigation works quite similar use derived properties ie r f navigation attributes since property sets pairwise disjoint even split set navigation attributes three dimensions dimensions independent selected independently interdependencies contained concepts lattice use modied context ie double r use 14 get fourth dimension still independent due theorem 10 independent selection r r benecial instead toggle addition selectiondeselection initially attributes deselected focus concept focus entire library example assume select segment reduces focus tailg renement possible attributes whose dening concepts strictly smaller nonbottom meet current focus concept thus navigation attribute possible select requires non empty new focus concept u choice requires non empty eliminates run focus moreover leaves front segment possible renement navigation style attributebased focus essentially function selected attributes due dual nature conceptlattices also allow objectbased navigation user selects deselects single component system calculates new focus similarly however selecting additional component widens focus thus realized join operation attributebased navigation depends explicit learned choice functional properties thus suited reuse purposes objectbased navigation exposes implicit conceptual similarities components intent focus concept contains properties common selected components extent also contains components share properties even selected explicitly hence appropriate library understanding reengineering 6 practical aspects made series experiments support claim browsing practical specicationbased case retrieval used variant list processing library also used retrieval experiments 6 comprises 5 requisites 31 features 86 components abstractions example specications paper taken library 61 calculation renement lattice even calculation renement lattice done advance thus timecriticle principle obvious feasible two questions main concern 1 high computational eort practice 2 dicult proof problems practice current theorem provers powerful enough answer questions depends number structure arising proof problems rst glance seems check requisite feature ab straction component calculate modied rene ment lattice however practice optimized due three obser vations first need compare components abstractions pairwise use recursive comparison 9 renement tran sitive need check requisites features components abstractions finally since former compatible renement sink renement lattice nodes ready worst case number problems thus ojr f j ja lj 2 nevertheless still many problems arise handled manually software engineering applications fully automated system required feeds controls prover however sheer numbers become problem proof problems ap proximately 85 experiments logically invalid thus provable theorem provers usually check unprovability thus stopped timeout hence dedicated disproving lters required nevertheless computation practically feasible using techniques 6 generated full set 14000 proof tasks ie readyto run versions problems also contain appropriate axioms prover control information ltered approximately 6600 unprovable took approximately 8 hours sun sparcstation 20 simplicity use optimizations explained would reduced original number tasks 11000 used automated theorem prover spass 29 network pcs check surviving tasks timeout 60 seconds spass able solve 1250 tasks remaining 6250 problems regenerated tasks using dierent subset axioms third iteration spass solved total 1460 almost 80 valid problems required total approximately 340 hours runtime equivalently weekend real time 62 calculation concept lattice concept lattices grow exponentially number attributes objects practice however worst case rarely occurs polynomial behavior usual 12 contains experimental evidence example library concept lattices full ie manually computed approximated ie computed using spass renement lattices contained 153 180 concepts respectively computation took approximately second thus negligible compared time required proving 63 navigation experiments became quickly obvious neither modied renement lattice concept lattice suitable presentation big complex 12 makes observation describes simple textbased interface works attribute object names currently adapting system navigation process however fast system responds without noticeable delay even much larger concept lattices currently investigating 64 knowledge acquisition formal specications library components initial abstractions 7 must supplied seed available specicationbased browsing already support knowledge acquisition consider example seed comprising lter segment tail lead list pre true post exists l1 list list computes longest ordered initial subsegment ie run list seed initial concept lattice calculated objectbased navigation conrms tail lead common superconcept attributes lter segment expected objects also reveals concept extent lead run selecting also causes tail appear disambiguate tail feature front segment l list pre true post exists l1 list must introduced factors common property lead run 7 related work work applying specicationbased techniques software libraries examines retrieval relevant browsing investigation dierent match relations 21 eect software reuse 5 6 22 introduced features indexes speed retrieval 7 initial requisites features derived automatically splitting supplied specications resulting indiscriminate attributes merged single concept construction lattice 9 builds twotiered hierarchy library lower level based modied denition subsumption works modulo arbitrary userdened congruences literals thus unsound general upper level uses similarity metric derived normal forms specications hierarchy visualized support browsing 18 use subsumption build hierarchical representation library exploit optimize retrieval programming language research 15 16 apply formal methods specication verication objectoriented class libraries behavioral subtyping corresponds subsumption concept lattices galois lattices developed means structure arbitrary observations already applied various problems software engineering eg inference conguration structures 11 identication modules 14 28 objects 27 legacy programs application software component libraries however seems obvious retrospect little related work 7 also uses concept lattices navigation presents entire lattice user oers subset possible attributes selection far navigation concerned 12 thus closely related work objectbased navigation instrumental knowledge acquisition supported conclusions specicationbased methods provide exact contentoriented access software components retrieval however still requires deductive power current theorem provers hardware oer browsing evade bottleneck moving timeconsuming deduction oline indexing phase paper shown dierent match relations must used index library properly index turned navigation structure using formal concept analysis experiments show feasible calculate approximation index accurate enough browsing purposes using current theorem provers hardware eg spass small network pcs computational eort however still high concept lattice reveals implicit structure library follows index even indicate situations ner index required due dual nature lattice allows two complementary navigation styles based either attributes objects due lattice nature navigation styles automatically singlefocus property refrain user dead ends approach theorem provers used derive formally dened properties components navigation formal denitions still available actually requiredsymbolic property names suce however since informally dened derived properties eg reliability usually also represented symbolic names eg trusthworty conceptbased browsing allows smooth integration formal informal attributes thus refutes conjecture 1 formal informal methods incompatible future work especially concerns scaleup expect fraction non theorems grow increasing library size dedicated disproving techniques thus one area interest since remaining tasks homogeneous style learning theorem provers 4 2 expected perform well acknowledgments christian lindigs work conceptbased retrieval also triggered research discussions greatly improved understanding formal concept analysis comments christian jens krinke gregor snelting improved presentation paper christoph weidenbach actual theorem proving mpii r semanticbased software retrieval support rapid prototyping discount distributed learning equational prover introduction lattices order learning domain knowledge improve theorem proving reuse contract deductionbased software component retrieval design browsing interface information retrieval formale begri using formal methods construct software component library paris system reusing partially interpreted schemas inference con guration structures source code conceptbased component retrieval assessing modular structure legacy code based mathematical concept analysis behavioral notion subtyping speci cation veri cation objectoriented programs using supertype abstraction information retrieval approach automatically constructing software libraries storing retrieving software components nementbased system survey software reuse li braries speci cation matching software components classi cation retrieval reusable components using semantic features inscape environment implementing faceted classi cation software reuse speci cations search keys software libraries norahammr making deduction based software component retrieval practical applying concept formation methods object caton procedural code identifying modules via concept analysis spass flotter version 042 restructuring lattice theory approach based hierarchies concepts tr ctr katsuro inoue reishi yokomori tetsuo yamamoto makoto matsushita shinji kusumoto ranking significance software components based use relations ieee transactions software engineering v31 n3 p213225 march 2005 benedikt kratz ralf reussner willemjan van den heuvel empirical research similarity metrics software component interfaces journal integrated design process science v8 n4 p117 december 2004 ge li lu zhang yan li bing xie weizhong shao shortening retrieval sequences browsingbased component retrieval using information entropy journal systems software v79 n2 p216230 february 2006 balaji padmanabhan alexander tuzhilin use optimization data mining theoretical interactions ecrm opportunities management science v49 n10 p13271343 october
computing display conflicts string visualization strings used represent variety objects dna sequences text numerical sequences model system visualization analysis strings proposed mehta sahni 1992 problem display conflicts arise model identified methods overcome suggested methods require computation display conflicts present efficient algorithms compute display conflicts b introduction string data type used represent number objects text strings dna protein sequences molecular biology numerical sequences etc research molecular biology text analysis interpretation numerical data involves identification recurring patterns data hypothesizing causes andor effects 2 3 detecting patterns visually long strings tedious prone error 1 model proposed alleviate problem model consists identifying recurring patterns string highlighting identical patterns color first discuss notion maximal patterns let abc pattern occurring times string let occurrences ab occur abc pattern ab maximal always followed c notion maximality motivated assumption applications longer patterns significant shorter ones maximal patterns occur least twice known displayable entities problem identifying displayable entities occurrences solved results 4 displayable entities occurrences obtained confronted problem color coding string abc def displayable entities would displayed highlighting abc one color def another shown figure 1 strings encounter problem conflicts consider string cdefcdegabchabcde displayable entities abc cde maximal occur thrice must highlighted different colors notice however abc cde occur substring abcde occurs suffix clearly displayable entities cannot highlighted different colors abcde required model figure 2 alternative display model consequence fact letter c occurs displayable entities situation known prefixsuffix conflict prefix one displayable entity suffix note also c displayable entity consequently occurrences c must highlighted color different used abc cde impossible c subword abc cde situation referred subword conflict problem subword conflicts may partially alleviated employing sophisticated display models figure 2 irrespective display model used usually possible display occurrences displayable entities therefore forced choose ones display three ways achieving interactive user selects occurrences interactively using hisher judgement typi cally would done examining occurrences involved conflict choosing one meaningful weight assigned occurrence higher weight greater desirability displaying corresponding occurrence criteria could used assigning weights occurrences include length position number occurrences pattern semantic value displayable entity information conflicts etc information fed routine selects set occurrences sum weights maximized algorithms discussed 1 practical environment appropriate method would hybrid interactive automatic approaches described user could select occurrences heshe wants included final display selection remaining occurrences performed routine maximizes display information methods described require knowledge conflicts either choose occurrences display interactive assign weights occurrences au tomatic automatic methods would require list conflicts interactive methods require information conflicts local particular segment string since prefix suffix subword conflicts handled differently different display models separate lists required paper identify family problems relating identification conflicts various levels detail problems relating statistical information conflicts also identified efficient algorithms problems presented algorithms make use symmetric compact directed acyclic word graph scdawg data structure 4 may thought operations traversals scdawg scdawg used represent strings sets strings evolved string data structures position trees suffix trees directed acyclic word graphs 5 6 7 8 section 2 contains preliminaries including definitions displayable entities conflicts scdawgs section 3 presents optimal algorithms determine whether string conflicts compute subword prefix suffix conflicts string sections 4 5 6 discuss related size restricted pattern restricted statistical problems show implement modifying algorithms section 3 finally section 7 presents experimental data run times algorithms preliminaries 21 definitions string length n whose characters chosen fixed alphabet sigma constant size pattern said maximal iff occurrences preceded letter followed letter consider string abczdefydefxabc abc def maximal patterns occurrences def preceded different letters z followed different letters x occurrences abc preceded letter first occurrence predecessor followed letter however de maximal occurrences followed f pattern said displayable entity displayable iff maximal occurs maximal patterns displayable entities exception occurs subword conflict two displayable entities 1 2 exists iff 1 substring 2 ii prefixsuffix conflict two displayable entities 1 2 exists iff exist substrings p sms occurs p string sm known intersection conflict conflict said occur 1 2 respect sm 22 symmetric compact directed acyclic word graphs scdawgs scdawg scds corresponding string directed acyclic graph defined set vertices v set rs labeled directed edges called right extension edges set ls labeled directed edges called left extension le edges vertex v represents substring specifically v consists source represents empty word sink represents vertex corresponding displayable entity let dev denote string represented vertex v v ffl v define implication imps ff string ff smallest superword ff fdev v ffl v sg superword exists otherwise imps ff exist edges vertex v 1 obtained follows letter x sigma imps dev 1 x exists equal dev 2 exists edge v 1 v 2 label xfl fi empty string edge known prefix extension edge le edges vertex v 1 obtained follows letter x sigma imps xdev 1 exists equal dev 2 exists le edge v 1 v 2 label flx fi empty string edge known suffix extension edge figure 3 shows v rs corresponding gabcde de e de c abc bc de gabcde fabcgabcde gabcde fabcgabcde cde sink abc c source figure 3 scdawg displayable entities two outgoing edges vertex representing abc edges correspond g imps consequently edges incident sink edges corresponding letters alphabet imps abcx exist x ffl fa b c e fg space required scds time needed construct 5 4 defined scdawg data structure single string extended represent set strings 23 computing occurrences displayable entities figure 4 presents algorithm computing end positions occurrences dev based outline provided 4 complexity occurrencess v proportional number occurrences dev algorithm procedure occurrencessstringuvertexiinteger begin deu suffix right edge e u begin let w vertex e incident figure 4 algorithm obtaining occurrences displayable entities 24 prefix suffix extension trees prefix extension tree pet v vertex v v subgraph scds consisting root v ii pet w defined recursively vertex w v exists prefix extension edge v w iii prefix extension edges leaving v suffix extension tree set v v defined analogously figure consists vertices representing c cde sink also includes prefix extension edges c cde cde sink similarly set v consists vertices representing c abc suffix extension edge c abc shown figure contains directed path v vertex w v iff dev prefix suffix dew proof directed path pet v v vertex w definition prefix extension edge transitivity prefix relation dev must prefix dew dev prefix dew exists series edges v w dev concatenated labels edges yields dew edges must prefix extension edge directed path v w exists proof set v analogous 2 computing conflicts 31 algorithm determine whether string conflict free describing algorithm determine string free conflicts establish properties conflict free strings used algorithm lemma 2 prefixsuffix conflict occurs string subword conflict must occur proof prefixsuffix conflict occurs two displayable entities w 1 w 2 exists w p wmw w p followed letter w 2 isnt always preceded letter ie wm isnt always followed letter wm isnt always preceded letter wm maximal w 1 occurs least twice since w 1 displayable entity wm occurs least twice since wm subword w 1 displayable entity wm subword w 1 subword conflict occurs wm w 1 2 corollary 1 string free subword conflicts free conflicts lemma 3 dew subword dev iff path comprising right extension suffix extension edges w v proof definition scds exists edge u v deu subword dev exists suffix extension edge u v deu suffix therefore subword dev exists path comprising right suffix extension edges w v transitivity dew subword dev algorithm noconflictss 1 construct scds 2 compute 3 scan right suffix extension edges element v source edge points vertex sink conflict exists otherwise conflict free figure 5 algorithm determine whether string conflict free dew suffix dev path lemma 1 suffix extension edges w v dew subword suffix dev definition scdawg path edges w vertex representing suffix dev 2 source denote vertices v suffix extension edge exists source vertex scds element v source lemma 4 string conflict free iff right extension suffix extension edges leaving vertices v source end sink vertex scds proof string conflict free iff exist right suffix extension edge two vertices neither source sink scds corollary 1 lemma 3 assume conflict free consider vertex v v source v right suffix extension edge v w v 6 sink w 6 sink dev subword dew string conflict free contradicts assumption next assume right suffix extension edges leaving vertices v source end sink vertex clearly cannot exist right suffix extension edges two vertices v w v 6 sink w 6 sink v source cannot exist vertex x v x 6 source x 6 sink x source vertex exist must exist path consisting right suffix extension edges vertex v source x clearly true conflict free 2 preceding development leads algorithm noconflicts figure 5 theorem 1 algorithm noconflicts correct optimal proof correctness immediate consequence lemma 4 step 1 takes time 4 step 2 takes o1 time since jv source j 2jsigmaj step 3 takes o1 time since number edges leaving v source less 4jsigma 2 j noconflicts takes time optimal actually steps 2 3 merged step 1 construction scds aborted soon edge violates lemma 4 created 2 32 subword conflicts consider problem finding subword conflicts string let k number subword conflicts algorithm solve problem requires time read input string ii ok time output subword conflicts lower bound time complexity problem string upper bound number conflicts maximum number substring occurrences 2 worst case occurrences conflict section compact method representing conflicts presented let k sc size representation k sc n 3 6 3 n compaction never increases size output may yield factor n reduction example compaction method described consider abcdbcgabcdbchbc displayable entities ending positions 1 6 13 2 3 6 10 13 16 list subword conflicts 1 2 written f63 66 1310 1313g first element ordered pair last position instance superstring 1 involved conflict second element ordered pair last position instance substring 2 involved conflict cardinality set number subword conflicts 1 2 given frequencyd 1 lambdanumber occurrences 2 1 since conflict represented ordered pair size output 2frequencyd 1 lambdanumber occurrences 2 1 observe occurrences 2 1 relative positions instances 1 therefore possible write list subword conflicts 1 2 61303 first list gives occurrences superstring 1 second gives relative positions occurrences substring 2 superstring 1 right end 1 size output frequencyd 1 number occurrences 2 1 economical earlier representation general substring conflicts many instances number displayable entities say z superword would write conflicts l 1 z l represent occurrences l 0 z represent relative positions occurrences z one list required displayable entity contains displayable entities subwords following equalities easily obtained size compact representation size original representation f frequency conflicts considered r ij frequency j one instance represents set displayable entities represents set displayable entities subwords defined subgraph scds consists set vertices sv v ae v represents displayable entities subwords dev set ses v suffix extension edges connect pair vertices sv v define sgr v sgs v directions edges ses v reversed lemma 5 sgs v consists vertices w path comprising right suffix extension edges joins w v scds proof follows lemma 3 2 2 vertex v scds 5 vertices u right suffix extension edge u v incident v 6 u 6 source 8 vertex v scds v 6 sink vsubword true 9 getsubwordsv procedure getsubwordsv 7 vertex x 6 source reverse topological order sgs v 9 dex suffix dev xsublist f0g else xsublist fg vertex w sgs v edge e x incident 12 element l wsublist xsublist 14 end figure optimal algorithm compute subword conflicts algorithm b figure 6 computes subword conflicts subword conflicts computed precisely displayable entities subword displayable entities lines 4 6 algorithm b determine whether dev subword displayable entities incoming right suffix extension edge v checked see whether originates source incoming edge originates vertex source vsubword set true lemma 3 incoming edges originate source vsubword set false procedure getsubwordsv computes subword conflicts dev invoked vsubword true procedure occurrencess v line 2 getsubwords computes occurrences dev places vlist procedure setup line 5 traverses sgr v initializes fields vertex sgr v reverse topological traversal sgs v may subsequently performed procedure setsuffixes line 6 marks vertices whose displayable entities suffixes dev accomplished following chain reverse suffix extension pointers starting v marking vertices encountered suffixes v list relative occurrences sublist associated vertex x sgs v xsublist represents relative positions dex occurrence dev relative occurence denoted position relative last position dev represented 0 dex suffix dev xsublist initialized element 0 remaining elements xsublist computed sublist fields vertices w v right extension edge goes x w consequently wsublist must computed xsublist achieved traversing sgs v reverse topological order 9 lemma 6 xsublist vertex x sgs v contains relative occurrences dex dev completion getsubwordsv proof correctness lemma follows correctness procedure occurrencess v section 23 observation lines 7 15 procedure getsubwords achieve effect occurrencess v 0 sgs v 2 theorem space therefore optimal proof computing vsubword vertex v v takes time constant time spent vertex edge scds consider complexity getsubwordsv lines 2 3 take ojvlistj time let number vertices sgs v number edges sgs v om line 5 traverses sgs v therefore consumes om time line 6 worst case could involve traversing sgs v takes om time computing relative occurrences dex dev lines 915 takes ojxsublistj time vertex x sgs v total complexity getsubwordsv ojvlistj however xfflsv svx6v jxsublistj since jxsublistj 1 x ffl sgs v xfflsv svx6v jxsublistj size output getsubwordsv complexity algorithm b 33 prefix suffix conflicts subword conflicts lower bound problem computing prefixsuffix conflicts k p k p number prefixsuffix conflicts also upper bound k p unlike subword conflicts possible compact output representation let w x respectively vertices set v pet v let vertex representing imps www v w x vertex exists otherwise pshadoww v define pimagew v w www v w x possibly empty string w otherwise pimagew v vertex w set v shadow prefix dag spdw v rooted vertex w comprised set vertices fpshadoww v xj x pet v pshadoww v x 6 nilg figure 7 illustrates concepts broken lines represent suffix extension edges dotted lines represent right extension edges solid lines represent prefix extension edges ff l c r z x figure 7 illustration prefix suffix trees shadow prefix dag set v pet v spdw v enclosed dashed solid dotted lines respectively pshadoww v lemma 7 prefixsuffix conflict occurs two displayable entities w respect third displayable entity set v x occurs pet v ii pshadoww v x 6 nil number conflicts dew dex respect dev equal number occurrences depshadoww v x proof definition prefixsuffix conflict occurs displayable entities w 1 respect wm iff exists w p wmw w wmw clearly wm suffix w 1 wm prefix w 2 iff w occurs set v x occurs pet v w p wmw occurs iff imps w p wmw nil number conflicts dew dex equal number occurrences imps w p wmw lemma 8 prefixsuffix conflict occur dew dex respect dev w occurs set v x occurs pet v prefixsuffix conflicts displayable entity represents descendant w set v displayable entity represents descendant x pet v respect dev proof since w set v x pet v represent dew w p dev dex devw conflicts occur w p devw occur descendants w set v represent displayable entities form w w w p dev descendants x pet v represent displayable entities form dexw substrings prefixsuffix e f r z x figure 8 illustration conditions lemma 9 conflict occur w dew dexw b respect dev w w p devw w b must exist however possible w p devw occur result follows 2 lemma 9 scds prefix extension edge e x z label aff iii right extension edge f u label afi pshadoww v proof let possibly empty string w w b w ww devw x afi string w b prove lemma must show u ie ww devw x aff subword deu ii deu smallest superword ww devw x aff represented vertex scds assume ww devw x aff subword ff prefix fi case 1 fi proper prefix ff since w b w ww devw x afi maximal occurrences followed letter true suffixes particular occurrences devw x afi cannot followed letter similarly occurrences devw x afi cannot preceded letter prefix devw x dez devw x afi displayable entity consequently prefix extension edge x corresponding letter must directed vertex representing devw x afi contradiction case 2 afi matches aff first k characters th character 1 k 1 clearly strings devw x aflff 1 w b w ww devw x aflfi 1 occur ie occurrences devw x afl cannot followed letter occurrences devw x afl cannot preceded letter prefix devw x displayable entity consequently prefix extension edge x corresponding letter must directed vertex representing devw x afl results contradiction thus ff prefix fi ii ff prefix fi assume w b w ww devw x afi smallest su perword ww devw x aff since x smallest superword ww devw x smallest superword ww devw x aff must form w ww devw x afl ff prefix fl proper prefix fi andor w b 1 proper suffix w b right edge f z points smallest superword w ww devw x definition scds w b w ww devw x afi w b 1 contradiction 2 scds path prefix extension edges x x 1 let concatenation labels aff iii prefix extension edge x 1 z label bfl iv right extension edge f u label affbfi proof similar proof lemma 9 2 path p aff z x f r figure 9 illustration conditions lemmas 10 11 algorithm c construct scds 2 vertex v scds procedure nextsuffixcurrentv 1 suffix extension edge current w 2 fthere one suffix extension edge current wg 6 exist nextsuffixwv figure 10 optimal algorithm compute prefixsuffix conflicts lemma 11 lemma 9 lemma 10 jlabelfj sum lengths labels edges prefix extension edge path p x z labelf concatenation labels p proof lemma 10 concatenation labels edges p prefix labelf jlabelfj sum lengths labels edges p ie labelf concatenation labels series edges p x pet v proof follows lemmas 7 8 2 algorithm c figure 10 computes prefixsuffix conflicts line 1 constructs scds lines 2 3 compute prefixsuffix conflicts separately computing displayable entity dev prefixsuffix conflicts intersection procedure nextsuffixcurrentv computes prefixsuffix conflicts displayable entities represented descendants current set v displayable entities represented descendants v pet v respect dev call nextsuffixvv line 3 algorithm c computes prefixsuffix conflicts respect dev identifying spdw v child w current set v call shad owsearchvwvw line 5 identifies spdw v computes prefixsuffix conflicts dew displayable entities represented descendants v pet v respect dev shadowsearchvwvw report prefixsuffix conflicts global variable exist unchanged shadowsearchvwvw ie exist false line 4 otherwise set true shadowsearch line 6 ensures nextsuffixwv called shadowsearchvwvw detected prefix suffix conflicts dew displayable entities represented descendants v pet v respect dev lemma 8 descendant q vertex x pet v procedure shadowsearchvwxy computes prefix suffix conflicts dew deq respect dev represents pshadoww v x show calls shadowsearch maintain invariant referred image invariant hereafter nil notice invariant holds shadowsearch called nextsuffix v statement line 1 examines prefix edge x lines 3 28 compute prefix suffix conflicts dew displayable entities represented vertices pet z z vertex prefix extension edge x incident truth condition statement line 1 line 4 truth condition inside statement line 5 establish conditions lemma 9 satisfied prior execution lines 8 9 truth comment line 8 correctness line 9 established lemma 9 procedure listconflicts line 9 lists prefix suffix conflicts dew dez respect dev similarly truth condition inside statement line 11 lines 13 14 truth condition inside statement line 15 establish conditions lemma satisfied prior execution lines 1820 correctness lines 1820 established lemma 10 done remains false exiting loop condition statement line 15 must evaluated true consequently conditions apply since loop line 11 terminated additional condition lemma 11 also satisfied hence lemma 11 procedure shadowsearchv w x 1 prefix extension edge 2 fthere one prefix extension edge x zg first character labele 5 right extension edge whose label starts fc 6 9 done jlabelfj jlabelej 14 th character labelf 15 prefix extension edge starting nc 22 else 26 shadowsearchvwzu 28 end 29 end figure 11 algorithm shadow search image invariant recursive call shadowsearchv w z u maintained line 27 sets global variable exist true since execution clause statement line 5 ensures least one prefixsuffix conflict reported shadowsearchv w v w lemmas 7 9 exist remains false clause statement line 5 never executed theorem 3 algorithm c computes prefixsuffix conflicts time optimal proof line 1 algorithm c takes time 4 cost lines 2 3 without including execution time nextsuffixv v next show nextsuffixv v takes ok v time k v number prefix suffix conflicts respect v ie k v represents size output nextsuffixv v assume nextsuffix invoked p times computation let set invocations nextsuffix call nextsuffix recursively let p j let f set invocations nextsuffix call nextsuffix recursively let p element f directly call jsigmaj elements p p f jsigmaj lines 46 nextsuffixcurrentv element f yields least one distinct conflict call shadowsearch thus p f k v cost execution nextsuffix without including costs recursive calls nextsuffix shadowsearch ojsigmaj o1 jsigmaj suffix edges leaving vertex total cost execution invocations nextsuffix spawned nextsuffixv v without including cost recursive calls shadowsearch next consider calls shadowsearch spawned nextsuffixv v let set invocations shadowsearch call shadowsearch recursively let q jt j let tb set invocations shadowsearch call shadowsearch recursively let q q jsigmaj1q bjsigmajp algorithm element tb yields distinct conflict q b cost execution single call shadowsearch without including cost executing recursive calls shadowsearch o1 ocomplexity listconflicts line complexity listconflicts line 20 th iteration loop w denotes number iterations loop complexity listconflicts proportional number conflicts reports since listconflicts always yields least one distinct conflict complexity shadowsearch o1 summing calls shadowsearch spawned nextsuffixv v obtain oq thus total complexity algorithm c 34 alternative algorithms section algorithm computing conflicts ie subword prefixsuffix conflicts presented solution relatively simple competitive run times however lacks flexibility required efficiently solve many problems listed sections 4 5 6 algorithm algorithm presented figure 12 step 1 computes list occurrences displayable entities list obtained first computing lists occurrences corresponding vertex v except source sink concatenating lists occurrence represented start end positions step 2 sorts list occurrences obtained step 1 increasing order start positions occurrences start positions sorted decreasing order end positions done using radix sort step 3 computes ith occurrence occ prefix suffix conflicts occurrences whose starting positions greater subword conflicts subwords occ checked conflict c smallest integer conflict occ occ ic start position occ ic greater ending position occ start position occ j j c also greater end position occ since list occurrences sorted increasing order start positions start positions occ i1 occ greater equal start positions occ less equal end position occurrences among whose start positions equal occ end positions smaller since occurrences start position sorted decreasing order end positions remaining conflicts occ ie subword conflicts superwords prefix suffix conflicts occurrences whose start positions less occ already computed earlier iterations statement algorithm example let input step 3 following list ordered pairs16 13 11 22 38 35 46 58 610 first element ordered pair denotes start position second element denotes end position occurrence consider occurrence 35 conflicts 16 13 38 computed iterations 1 2 5 loop conflicts 46 58 computed iteration 6 loop theorem 4 algorithm takes proof step 1 takes number occurrences displayable entities step 2 also takes elements sorted using radix sort n buckets step 3 takes oo time loop executes oo times iteration loop yields distinct conflict total complexity onok show number occurrences involved conflict number occurrences involved least one conflict single conflict occurs two occurrences 2k algorithm modified size output may achieved checking whether occurrence first representative pattern loop step 3 subword conflicts reported first occurence pattern however time complexity algorithm remains k sense suboptimal algorithm step 1 obtain list occurrences displayable entities string list obtained first computing lists occurrences corresponding vertex scdawg except source sink concatenating lists step 2 sort list occurrences using start positions occurrences primary key increasing order end position secondary key decreasing order done using step3 1 number occurrences begin begin occ superword occ j else prefixsuffix conflict figure 12 simple algorithm computing conflicts 4 size restricted queries experimental data show random strings contain large number displayable entities small length applications small displayable entities less interesting large ones hence useful list displayable entities whose lengths greater integer k similarly useful report exactly conflicts conflicting displayable entities length greater k gives rise following problems p1 list occurrences displayable entities whose lengths greater k p2 compute prefix suffix conflicts involving displayable entities length greater k p3 compute subword conflicts involving displayable entities length greater k overlap conflict defined string common conflicting displayable entities overlap subword conflict subword displayable entity overlap prefixsuffix conflict intersection size conflict length overlap alternative formulation size restricted problem also seeks achieve goal outlined based reporting conflicts whose size greater k formulation problem particularly relevant conflicts interest displayable entities also establishes conflicting displayable entities reported size greater k following problems p4 obtain prefixsuffix conflicts size greater integer k p5 obtain subword conflicts size greater integer k p1 solved optimally invoking occurrencess v 0 vertex v v combined solution p2 p3 uses approach section 34 modification algorithm figure 12 step 1 becomes obtain occurrences displayable entities whose lengths greater k resulting algorithm optimal respect expanded representation subword conflicts however general problem possible obtain separate optimal solutions p2 p3 using techniques section 34 optimal solution p4 obtained executing line 3 algorithm c figure 10 vertices v v jdevj k optimal solution p5 obtaind following modification algorithm b figure 6 right extension suffix extension edges marked disabled ii definition sgs v modified sgs v v ffl v defined subgraph scds consists set vertices sv v ae v represent displayable entities length greater k subwords dev set suffix extension edges connect pair vertices sv v algorithm b modified modified algorithm shown figure 13 note p2 p5 identical since overlap subword conflict subword displayable entity algorithm b 2 vertex v scds 4 vertex v scds jdevj k 5 vertices u non disabled right suffix extension edge u v exists 7 vertex v scds v 6 sink vsubword true 9 end figure 13 modified version algorithm b 5 pattern oriented queries queries useful applications fact two patterns conflict important number location conflicts following problems arise result list pairs displayable entities subword conflicts p7 list triplets displayable entities 1 2 dm prefix suffix conflict 1 2 respect dm p8 p6 size restricted p5 p9 p7 size restricted p4 p6 may solved optimally reporting vertex v v v represent sink csds subword displayable entities dev accomplished reporting dew vertex w w 6 source sgs v p7 may also solved optimally modifying procedure listconflicts figure 11 reports conflicting displayable entiities intersection p8 p9 may also solved making similar modifications algorithms previous section 6 statistical queries queries useful conclusions drawn data based statistical facts let fd denote frequency number occurrences string number occurrences displayable entity 1 displayable entity 2 following queries may defined p10 pair displayable entities 1 2 involved subword conflict 1 subword 2 obtain number occurrences 1 occur subwords p11 pair displayable entities 1 2 involved prefixsuffix conflict number occurrences 1 prefixsuffix conflicts greater statistically determined threshold following could said confidence presence 1 implies presence 2 number prefix suffix conflicts 1 2 respect dm psfd 1 2 number prefix suffix conflicts 1 2 approximate pd two quantities identical unless single occurrence 1 subword two distinct occurrences 2 similarly approximate qd two quantities identical unless single occurrence 1 prefix suffix conflicts two distinct occurrences 2 fd 1 computed displayable entities scds time single traversal scds reverse topological order computed optimally 1 2 modifying procedure getsubwordsv shown figure 14 computed optimally 1 2 dm 1 prefix suffix conflict 2 respect dm modifying listconflictsu z w figure 11 returns fdeu since number conflicts dew dez respect dev psfd calculated summing psfd 1 2 dm intersections dm prefix suffix conflicts 1 2 pd may computed simple modifications algorithms used compute rfd procedure getsubwordsv 5 vertex x 6 source reverse topological order sgs v 6 begin 7 dex suffix dev rfdex 8 vertex win sgs v edge e x incident 9 figure 14 modification getsubwordsv computing relative frequencies problems may solved size restrictions p4 p5 modifications similar made section 4 7 experimental results algorithms b section 32 c section 33 section 34 programmed gnu c run sun sparcstation 1 test data used 120 randomly generated strings alphabet size chosen one f5 15 25 35g string length 500 1000 2000 test set strings consisted 10 different strings possible combinations input size alphabet size combinations average run times 10 strings given figures 1518 figure 15 gives average times computing conflicts combining algorithms b c figure gives average times computing prefixsuffix conflicts using algorithm c figure 17 gives average times computing pattern restricted prefixsuffix conflicts problem p7 section 5 modifying algorithm c described section 5 figure 18 represents average times algorithm figures 15 17 represent theoretically superior solutions corresponding prob lems figure represents algorithm provides simpler suboptimal size size string alphabet 500 1000 2000 figure 15 time ms computing conflicts using optimal algorithm solution three problems cases time constructing scdawgs writing results file included steps common solutions results show suboptimal algorithm superior optimal solution computing conflicts prefixsuffix conflicts randomly generated string due simplicity algorithm fact number conflicts randomly generated string small however string 100 represents worst case scenario terms number conflicts reported following run times obtained conflicts optimal algorithm 14190 ms prefixsuffix conflicts optimal algorithm 10840 ms pattern restricted prefixsuffix conflicts optimal algorithm 5000 ms algorithm 26942 ms experimental results using random strings also show expected optimal algorithm fares better algorithm restricted problem computing pattern oriented prefixsuffix conflicts conclude algorithm used general problems computing conflicts optimal solutions used restricted versions hence algorithm used automatic environment optimal solutions used interactive semiautomatic environments size size string alphabet 500 1000 2000 figure time ms computing prefix suffix conflicts using optimal algorithm size size string alphabet 500 1000 2000 figure 17 time ms computing pattern restricted prefix suffix conflicts using optimal algorithm size size string alphabet 500 1000 2000 figure 18 time ms algorithm conclusions paper described efficient algorithms analysis visualization patterns strings currently extending discrete objects circular strings graphs extending techniques domain approximate string matching would useful appears difficult r string visualization sequence landscapes matching protein sequences using color intrasequence homology displays complete inverted files efficient text retrieval analysis smallest automaton recognizing subwords text efficient online construction correction position trees spaceeconomical suffix tree construction algorithm efficient elegant subword tree construction fundamentals data structures pascal tr transducers repetitions complete inverted files efficient text retrieval analysis matching protein sequences using color intrasequence homology displays models techniques visualization labeled discrete objects spaceeconomical suffix tree construction algorithm fundamentals data structures pascal data structure circular string analysis visualization ctr hsuan chang nengwen lo wei c lu chung j kuo visualization comparison dna sequences use threedimensional trajectories proceedings first asiapacific bioinformatics conference bioinformatics 2003 p8185 february 01 2003 adelaide australia
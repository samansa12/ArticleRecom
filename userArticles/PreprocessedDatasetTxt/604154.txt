interprocedural compatibility analysis static object preallocation present interprocedural compositional algorithm finding pairs compatible allocation sites property object allocated one site live time object allocated site allocation site compatible said unitary one object allocated site live given point execution program use results analysis statically preallocate memory space objects allocated unitary sites thus simplifying computation upper bound amount memory required execute program also use analysis enable objects allocated several compatible allocation sites share preallocated memory experimental results show set java benchmark programs 60 allocation sites unitary statically preallocated moreover allowing compatible unitary allocation sites share preallocated memory leads 95 reduction amount memory preallocated sites b introduction modern objectoriented languages java present clean simple memory model conceptually objects allocated garbagecollected heap abstraction simplies many aspects program devel opment complicate calculation accurate upper bound amount memory required execute program scenarios upper bound especially important include development programs embedded systems hard limits amount available memory estimation scoped memory sizes realtime threads allocate objects sized scoped memories 9 paper presents static program analysis designed nd pairs compatible allocation sites two sites compatible object allocated one site may live time object allocated site allocation site compatible call allocation sites unitary allocation sites time execution program one live object allocated site therefore possible statically preallocate xed amount space allocation site use space hold objects allocated site space usage analyses focus nonunitary allocation sites analysis uses techniques inspired register allocation 2 6 reduce amount memory required hold objects allocated unitary allocation sites basic approach build color incompatibility graph nodes graph unitary allocation sites undirected edge two nodes nodes compatible analysis applies coloring algorithm assigns minimal number colors graph nodes subject constraint incompatible nodes dierent colors information enables compiler statically preallocate xed amount memory color unitary allocation site generated code bypasses standard dynamic allocation mechanism instead simply returns pointer start statically preallocated memory allocation sites color object stored memory duration lifetime com putation algorithm therefore enables objects allocated compatible allocation sites share memory results implemented analysis show set java benchmark programs analysis able identify 60 allocation sites program unitary allocation sites furthermore incompatibility graph coloring algorithm delivers 95 reduction amount memory required store objects allocated unitary allocation sites attribute high percentage unitary allocation sites specic object usage patterns characteristic java programs many unitary allocation sites allocate exception string buer iterator objects identify two potential benets analysis first used simplify computation amount memory required execute given program implemented memory requirements analysis pos sible computes symbolic mathematical expression amount memory 16 results 16 show preceding memory requirements analysis analysis presented paper using results compute memory requirements unitary sites separately signicantly improve precision eciency subsequent memory requirements analysis second potential benet reduction memory management overhead enabling compiler convert heap allocation static allocation analysis reduce amount time required allocate reclaim memory paper makes following contributions object liveness analysis presents compositional interprocedural object liveness analysis conservatively estimates set objects live program point compatibility analysis presents compositional interprocedural analysis nds sets compatible allocation sites objects allocated sites set share statically preallocated memory analysis uses results object liveness analysis implementation implemented analyses mit flex 3 compiler used analyze set java benchmark programs results show analyses able classify majority allocation sites unitary allocation sites many sites share memory also implemented evaluated compiler optimization transforms unitary allocation site use preallocated memory space instead invoking standard memory allocator rest paper organized follows section 2 presents analysis algorithm section 3 describes implementation presents experimental results discuss related work section 4 conclude section 5 2 analysis presentation given program p goal analysis detect pairs compatible allocation sites p ie sites property object allocated one site live time object allocated site equivalently analysis identies pairs incompatible allocation sites ie pairs sites object allocated rst site object allocated second site may live time possible execution p object live elds methods used future easy prove following fact fact 1 two allocation sites incompatible object allocated one site live program point corresponds site identify objects live program point analysis needs track use objects throughout program two complications first abstraction problem analysis must use nite abstraction reason potentially unbounded number objects program may create second parts program may read heap references created parts program using fulledged owsensitive pointer analysis would substantially increase time space requirements analysis owinsensitive pointer analysis 18 5 would provide sucient precision since liveness essentially owsensitive property address complications follows use object allocation site model 13 objects allocated given statement modelled inside node 1 associated statements program label analysis tracks objects pointed local variables nodes whose address may stored heap said escape heap analysis conservatively assumes node unitary ensure sets node incompatible notice usual java program many objects typically manipulated local variables exceptions iterators string buers etc 2 assumptions node escape heap live given program point variable live program point refers node variable liveness wellstudied data ow analysis 2 6 present quick reminder variable v live program point path control ow graph starts program point contain denition v ends instruction uses v analysis process call instructions accu rately example needs know nodes returned call nodes escape heap execution invoked method reanalyzing method call instruction corresponds conceptually inlining method would inecient stead use parameter nodes obtain single contextsensitive analysis result method parameter nodes placeholders nodes passed actual argu ments analysis processes call instruction replaces parameter nodes nodes sent argu ments hence analysis compositional absence recursion analyzes method exactly extract single analysis result 3 call site instantiates result calling context particular call site use adjective inside make distinction pa rameter nodes introduce later paper 2 possible increase precision analyis tracking one levels heap references similar 8 3 analysis may analyze recursive methods multiple times reaches xed point figure 1 node abstraction figure presents summary node abstraction use following notation inode denotes set inside nodes pnode denotes set parameter nodes node denotes set nodes analyzing method analysis scope method methods transitively invokes inside nodes model objects allocated scope n lb denotes inside node associated allocation site label lb superscript stands inside free variable n lb represents objects allocated label lb currently analyzed scope parameter nodes model objects receives arguments parameter node n p models object currently analyzed method receives ith argument object type 4 analysis two steps one analysis rst analysis computes objects live allocation site call instruction 5 second analysis uses liveness information compute incompatibility pairs formulate analyses systems set inclusion constraints use bottomup iterative xedpoint algorithm compute least set inclusion solution constraints given program number nodes bounded number object allocation sites number parameters hence constraints mono tonic xed point computations guaranteed terminate rest section organized follows section 21 describes execution analysis small example section 22 presents program representation analysis operates section 23 describes object liveness analysis section 24 describe use object liveness information compute incompatibility pairs section 25 discusses apply techniques multithreaded programs 21 example consider java code figure 2 program creates linked list contains integers 0 9 removes list elements satisfy specic condition even numbers case prints string representation remaining list program contains six lines allocate objects two iterators lines 3a 3b allocated library code allocation site four lines allocate objects directly executing new instructions sake simplicity ignore objects allocated library exam ple inside nodes node n 1 represents linked list allocated line 1 node n 2 represents integers allocated line 2 etc iterators lines 3a 3b represented node n 3 allocated site figure 3 presents incompatibility graph example 4 ie primitive types int char etc 5 object liveness analysis able nd live nodes program point however eciency reasons produce analysis result relevant statements static void mainstring args static list createlistint size 1 list list new linkedlist 2 integer listaddv return list static void filterlistlist l static string listtostringlist l 4 stringbuffer buffer new stringbuffer bufferappendvappend 5 return new stringbuffer figure 2 example code analysis processes methods bottomup fash ion starting leaves call graph library method linkedlistadd shown figure 2 causes parameter node n p 1 parameter escape heap address stored list cell createlist calls add n 2 argument therefore analysis instantiates 2 n 2 detects n escapes filterlist parameter node n p list escapes heap listiterator stores reference underlying list iterator creates listtostring method n 4 live call listiterator allocates n pointed local variable buffer live call therefore n 4 incompatible n 3 n 4 live line 5 n 4 also incompatible n 5 n 3 live n figure 3 incompatibility graph code figure 2 circles represent inside nodes double circle indicates node escapes heap 3 n 5 compatible unitary nodes name format informal semantics local variable another new c create one object class c create heap reference return return v normal return method throw throw v exceptional return method nodes join points figure 4 instructions relevant analysis line 5 n 3 n 5 still compatible parameter node n p list live lines 4 3b 5 therefore n p 1 incompatible n 4 n 3 analysis main detects l points n createlist returns n parameter filterlist escapes heap analysis detects n escapes processing call listtostring analysis instantiates 1 n 1 discovers incompatibility pairs hn 4 analysis already determined n escapes heap unitary node generate last two incompatibility pairs purely expository purposes graph coloring algorithm colors n 3 n 5 color means two iterators string allocated program property two live time hence compiler statically allocate objects memory space 22 program representation work context static compiler compiles entire code application application deployed executes compiler provides full ec tive access classes emulates dynamic loading classes precompiled executable support dynamic loading classes unknown compiler compile time approach acceptable class target applications real time software embedded devices memory consumption analysis particularly important analyzed program consists set methods distinguished main method method represented control ow graph cfgm vertices cfgm labels instructions composing ms body edges represent ow control inside method local variables var set local variables method parameters figure 4 contains instructions relevant analysis assume analyzed program already converted single static information ssi form 4 extension static single assignment explain dierences later sec tion intermediate representation models creation propagation exceptions explicitly instruction might generate exception preceded test exceptional situation detected eg null pointer deref erencing intermediate representation follows java convention allocating initializing exception ob ject eg nullpointerexception propagating exception appropriate catch block throwing exception method block exists notice due semantics java programming lan guage instruction throw exception also potential object allocation site moreover exception objects rst class objects exception caught references stored heap passed arguments invoked methods practice apply optimization method contains single allocation site automatically inserted exception example nullpointerexception arrayindexoutofboundsexception method may generate catch method detects exception jumps allocation site allocates exception object executes exceptional return method allow interprocedural propagation exceptions call instruction label lb two successors normal termination method case exception thrown invoked method cases locally generated exceptions exceptions thrown invoked method control passed appropriate catch block block determined succession instanceof tests applicable block exists exception propagated caller current method throw instruction throw v unlike throw instruction java language throw instruction intermediate representation always terminates execution current method note check exceptions subclasses javalangerror 6 signicant restriction work context static compiler know entire code class hierarchy errors cannot raised program compiled successfully system eg virtualmachineerror nosuchfielderror etc program raises one rest errors eg outofmemoryerror aborts cases intended behavior particular none benchmarks catches kind exception next present informal semantics instructions figure 4 copy instruction copies 6 java language exceptions correspond severe errors virtual machine program expected handle value local variable v1 local variable v2 phi instruction ssa node appears join points control ow graph ensures use local variable exactly one reaching de nition control arrived phi instruction ith incoming edge v copied v new instruction new c allocates new object class c stores reference local variable v call instruction hvn calls method named mn object pointed v1 arguments execution invoked method terminates return instruction return v address returned object stored vn control ow goes succn lb lb label call instruction otherwise ie exception thrown invoked method address exception object stored control ow goes succe lb typeswitch instruction hv1 c corresponds java instanceof test checks whether class object pointed v subclass c v split two variables v1 vs restriction true branch v2 vs restriction false branch therefore object pointed v1 instance c object pointed v2 typeswitch instruction simple example ssi sigma node v ssi form introduces preserve ow sensitive information acquired test instruc tions ssi thus allows elegant construction predicated data ow analyses apart variable splitting ssi similar ssa form particular ssi conversion seems require linear time practice 4 finally store instruction v1 sets eld f object referenced v1 point object referenced v2 instructions irrelevant analysis particular track heap references analysis cannot gain additional information analyzing instructions read references memory however analyze store instructions need identify objects escape heap assume precomputed call label lb corresponds call instruction calleeslb set methods call instruction may invoke analysis works conservative approximation runtime call graph implementation uses simplied version cartesian product algorithm 1 23 object liveness analysis consider method labelprogram point lb inside let livelb denote set inside parameter nodes live lb conservatively consider node live lb pointed one variables live point v live lb p v p v set nodes v may point interpret results need compute set eg inside nodes escape heap execution 7 sake simplicity presentation analysis consider instance methods java terms nonstatic methods ie v1 argument implementation handles instance methods static methods program able process calls also compute set nodes normally returned rn set exceptions thrown set parameter nodes may escape heap execution em formally analysis computes following mathematical objects eg inode formulate analysis set inclusion constraint problem figure 5 presents constraints generated method beginning method p points parameter node n p copy instruction sets v1 point nodes v2 points accordingly analysis generates constraint p case phi instruction similar new instruction label lb v new c makes v point inside node n lb attached allocation site constraints generated return throw add nodes rn spectively store instruction v1 causes nodes pointed v2 escape heap accordingly nodes p v2 distributed eg inside nodes em parameter nodes typeswitch instruction hv1 v2 c works type lter v1 points nodes p v may represent objects type subtype c v2 points nodes p v may represent objects type subtype c figure 5 denotes set subtypes ie java sub classes c including c precisely determine type typen inside node n lb 0 examining new instruction label lb 0 therefore precisely distribute inside nodes p v1 p v2 know exact types objects represented parameter nodes conservatively put nodes sets 9 call instruction hvn vn point nodes may returned invoked methods possible callee 2 calleeslb include nodes rn p vn note rn parameterized result therefore instantiate rn use replacing parameter node n p nodes corresponding argument v points ie nodes p v case analogous execution invoked method may also cause nodes passed arguments escape heap accord ingly analysis generates constraint instantiates set em uses nodes resulting set emhp v1 update eg em formal general denition previously mentioned instantiation operation node set contains parameter nodes n p necessarily 8 use ssi form denition v1 therefore lose precision using instead 9 better solution would consider declared type cp corresponding parameter check cp c least one common subtype method entry p p parameters return return v rn p v throw throw v p v rn mhp v1 let em pnode eg inode typeswitch denotes set subclasses class c figure 5 constraints object liveness analysis method compute rn em p v variable v live relevant label also compute set eg inside nodes escape heap 24 computing incompatibility pairs computation object liveness information completes analysis computes global set pairs incompatible allocation sites incg inode inode 10 analysis uses set incompatible allocation sites detect unitary allocation sites construct compatibility classes figure 6 presents constraints used compute incg allocation site label lb incompatible allocation sites whose corresponding nodes live lb however nodes livelb may parameter nodes cannot generate incompatibility pairs directly instead method analysis collects incompatibility pairs involving one parameter node set parametric incompatibilities parincm instantiates set call similar way instantiates recall bijection inside nodes allocation sites set nodes ith argument sent might point notice may contain parameter node caller however point call graph incompatibility pair involve inside nodes passed incg simplify equations figure 6 method compute entire set incompatibility pairs allincm allincm computed pairs contain inside nodes put global set incompatibilities incg pair contains parameter node put parincm implementation algorithm performs separation soon incompatibility pair generated without need allincm case call instruction two kinds incompatibility pairs already mentioned rst kind pairs obtained instantiating parincm 8m 2 calleeslb addition node live call ie call incompatible nodes corresponding allocation sites invoked methods increase precision treat normal new c livelb fn lb g allincm livelb livesuccn lb allincm livelb livesucce lb ae allincm allincm inode inode incg allincm n inode inode parincm figure constraints computing set incompatibility pairs instruction label lb method condition generated constraints new c lb return n figure 7 constraints computing ae relevant instruction condition second column satised corresponding constraint third column generated exceptional exit invoked method separately let inode set inside nodes represent objects may allocated method execution returns normally similarly let ae inode set inside nodes represent objects may allocated invocation returns exception describe later compute sets moment suppose analysis computes starts generate incompatibility pairs let succn lb successor corresponding normal return call instruction label lb nodes livelb livesuccn lb incompatible nodes similar relation holds ae computation ae given label lb code method dene predicate lb return true path cfgm lb return instruction ie instruction label lb may executed invocation returns normally analogously dene throw true path lb throw instruction computing predicates easy graph reachability problem method contains inside node n lb corresponds new instruction label lb lb return addi tion call instruction label lb code add nodes possible callee analogously computation ae similar figure 7 formally presents constraints computing sets ae 25 multithreaded applications far presented analysis context singlethreaded application multithreaded appli cation analysis needs examine methods transitively called main method run methods threads may started addition nodes correspond started threads need marked escaped nodes rest analysis unchanged java thread represented thread object allocated heap object escape one thread accessed another must reachable either thread object static class variable global variables called static class variables java cases analysis determines corresponding allocation site unitary therefore objects allocated unitary allocation sites local thread created escape threads although know two objects allocated thread unitary site live given moment multiple live objects allocated site dierent threads hence group compatible unitary sites need allocate one memory slot per thread instead one per program compiler generates code time program starts new thread preallocates memory space unitary allocation sites may executed thread unitary allocation site compiler generates code retrieves current thread uses preallocated memory space unitary site current thread thread terminates execution deallocates preallocated memory space threadlocal objects used space deallocation create dangling references bound memory space occupied unitary allocation sites need bound number threads simultaneously execute program given time 26 optimization singlethread programs previous sections consider node escapes heap incompatible nodes including equivalent considering node live entire program gain additional precision considering node escapes live rest program enhancement allows us preallocate even objects escape heap allocation site executes section presents changes analysis apply idea longer use global set eg instead label lb elb node denotes set nodes instruction label lb may store reference heap set relevant labels correspond stores calls call represents nodes escape execution invoked method extend set objects live label lb method include objects escaped instructions labels lb reach lb cfgm livelb v live lb p v change constraints figure 5 follows store instruction v1 constraint elb generate constraints p vn p additional constraint rules store call longer generate constraints eg unused em instead dene em lb elb em pnode denotes set nodes parameter nodes also inside nodes escape heap execution rest analysis unchanged new denition livelb ensures node escapes heap program point incompatible nodes live future program point notice objects allocated unitary sites longer guaranteed thread local cannot apply preallocation optimization described end section 25 therefore use version analysis single thread programs 3 experimental results implemented analysis including optimization section 26 mit flex compiler system 3 also implemented compiler transformation memory preallocation compiler generates executables property unitary sites use preallocated memory space instead calling memory allocation primitive memory sites preallocated beginning program implementation currently support multithreaded programs described section 25 measure eectiveness analysis using nd unitary allocation sites set java programs obtained results pentium 4 28ghz system 2gb memory running redhat linux 73 ran compiler analysis using sun jdk 141 hotspot mixed mode compiler generates native executables ran machine table 1 presents description programs benchmark suite analyze programs specjvm98 benchmark suite 11 java version olden benchmark suite 12 11 addition analyze jlex javacup 205 raytrace table presents several statistics indicate size benchmark analysis time statistics refer user code plus library methods called user code data table 2 indicate general time required perform analysis order magnitude time required build intermediate representation program exceptions 202 jess 213 javac table 3 presents number total allocation sites unitary allocation sites program results show analysis usually able identify majority sites unitary sites 14065 allocation sites benchmarks analysis able classify 8396 60 unitary sites twelve twenty benchmarks analysis able recognize 80 allocation sites unitary table 3 also presents results allocation sites allocate exceptions ie subclass javalangthrowable nonexceptions rest ob jects javalangstringbuers special case non exceptions category present total number allocation sites kind proportion sites unitary majority unitary allocation sites benchmarks allocate exception string buer objects 9660 total exception allocation sites benchmarks analysis able recognize 6602 68 unitary sites thirteen twenty benchmarks analysis able recognize 90 exception allocation sites unitary sites 1293 string buer allocation sites analysis able recognize 1190 92 unitary sites eight benchmarks analysis able recognize 95 string buer allocation sites unitary sites table 4 presents size statically preallocated memory area used store objects created unitary allocation sites second column table presents results case unitary allocation site preallocated memory chunk described introduction paper decrease preallocated memory size signicantly use graph coloring algorithm allow compatible unitary allocation sites share preallocated memory area third column table presents results case compiler optimization always uses graph coloring algorithm provide second column comparison purposes 11 exception 227 mtrt multithreaded application description specjvm98 benchmark set 200 check simple program tests jvm features compress file compression tool jess expert system shell 209 db database application 213 javac jdk 102 java compiler 222 mpegaudio audio le decompression tool 228 jack java parser generator java olden benchmark set bh barneshut nbody solver bisort bitonic sort em3d models propagation electromagnetic waves three dimensional objects health simulates healthcare system mst computes minimum spanning tree graph using bentleys algorithm perimeter computes perimeter region binary image represented quadtree power maximizes economic eciency community power consumers tsp solves traveling salesman problem using randomized algorithm treeadd recursive depthrst traversal tree sum node values voronoi computes voronoi diagram random set points miscellaneous raytrace single thread raytracer ocial part specjvm98 jlex java lexer generator javacup java parser generator table 1 analyzed applications application analyzed methods bytecode instrs size instr ssi conversion time analysis time 200 check 208 7962 10353 11 41 compress 314 8343 11869 12 74 jess 1048 31061 44746 53 1012 222 mpegaudio 511 18041 30884 52 159 228 jack 618 23864 37253 116 556 bisort 123 5157 6615 12 29 em3d 142 5519 7497 09 31 health 141 5803 7561 09 32 mst 139 5228 6874 12 30 perimeter 144 5401 6904 12 27 power 135 6039 7928 10 32 treeadd 112 4814 6240 08 28 voronoi 274 8072 10969 18 43 raytrace 498 14116 20875 42 230 jlex 482 22306 31354 40 123 javacup 769 27977 41308 58 320 table 2 analyzed code size analysis time application allocation unitary sites exceptions nonexceptions stringbuers sites count total unitary total unitary total unitary 200 check 407 326 80 273 92 134 57 44 97 compress 489 155 32 390 28 99 44 38 97 jess 1823 919 50 1130 58 693 38 233 84 222 mpegaudio 825 390 47 625 55 200 24 43 97 228 jack 910 479 53 612 54 298 50 135 99 bisort 234 198 85 177 97 57 47 17 94 em3d 276 235 85 206 98 70 50 20 95 health 276 227 82 202 97 74 42 17 94 mst 257 216 85 194 97 63 44 perimeter power 262 213 81 192 97 70 39 15 93 treeadd 227 190 84 170 96 57 46 15 93 voronoi 448 387 86 349 98 99 44 28 96 raytrace 753 318 42 525 44 228 39 43 95 jlex 971 812 84 645 99 326 54 72 86 total 14065 8396 60 9660 68 4405 41 1293 92 table 3 unitary site analysis results preallocated memory size application size bytes reduction normal sharing 200 check 5516 196 96 compress 2676 144 95 jess 17000 840 96 222 mpegaudio 6452 104 98 228 jack 8344 224 97 bh 4604 224 95 bisort 3252 96 98 em3d 3860 200 95 health 3716 96 97 mst 3532 96 97 perimeter power 3540 196 94 treeadd 3120 92 98 raytrace 5656 644 89 jlex 13996 1676 88 javacup 20540 1180 94 total 143088 6984 95 table 4 preallocated memory size graph coloring algorithm nds approximation smallest number colors two incompatible allocation sites color color preallocate memory area whose size maximum size classes allocated allocation sites color implementation uses dsatur graph coloring heuristic 10 important notice dsatur heuristic minimizes numbers colors nal total size preallocated memory however appear signicant negative eect results numbers table 4 show able reduce preallocated memory size least 88 cases average reduction 95 theoretically preallocation optimization may allocate memory original program preallocating memory area set compatible allocation sites reserves area entire lifetime program even object allocated attached set compatible sites reachable extreme case represented memory areas preallocate allocation sites program never executes however data table 4 indicate practice amount preallocated memory analyzed application quite small compiled benchmark memory preallocation optimization enabled optimized executable n ished normally produced result unoptimized version executed specjvm98 olden applications default workload ran jlex javacup lexer parser les compiler frastructure instrumented allocation sites measure many objects allocated program many objects used preallocated memory application total preallocated objects objects count 200 check 725 238 33 compress 941 108 11 jess 7917932 3275 0 222 mpegaudio 1189 7 1 228 jack 6857090 409939 6 bh 15115028 7257600 48 bisort 131128 15 0 em3d 16061 23 0 health 1196846 681872 57 mst 2099256 1038 0 perimeter power 783439 12 0 treeadd 1048620 13 0 raytrace 6350085 4080258 64 jlex 1419852 12926 1 javacup 100026 16517 17 table 5 preallocated objects table 5 presents results measurements benchmarks least one third objects resided preallocated memory correlation static number unitary sites dynamic number objects allocated sites explained large dierence number times dierent allocation sites executed general applicationspecic details tend factor determining dynamic numbers example jlex 95 objects iterators allocated nonunitary allocation site 213 javac javacup use many stringbuers preallocate 205 raytrace bh use many temporary objects represent mathematical vectors etc 4 related work paper presents knowledge rst use pointer analysis enable static object preallocation researchers used pointer andor escape analyses improve memory management java programs 14 20 7 algorithms focus allocating objects call stack researchers also developed algorithms correlate lifetimes objects lifetimes invoked methods use information allocate objects dierent regions 19 goal eliminate garbage collection overhead atomically deallocating objects allocated given region corresponding function returns researchers 17 require programmer provide annotations via rich type systems specify region object allocated bogda hoelzle 8 use pointer analysis eliminate unnecessary synchronizations java programs spite dierent goals pointer analysis many technical similarities analysis analyses avoid maintaining precise information objects placed deep heap bogda hoelzles analysis precise stack allocate objects reachable single level heap references analysis attempt maintain precise pointsto information objects reachable heap hand analysis precise computes live ranges objects treats exceptions precision particular found predicated analysis type switches takes type referenced object account necessary give analysis enough precision statically preallocate exception objects analysis aggressive aims escape anal ysis escape analysis typically used infer lifetimes objects allocated specic allocation site contained within lifetime either method allocates one methods transitively invokes allocating method compiler transform allocation site allocate object method stack frame instead heap notice analysis provide bound number objects allocated allocation site presence recursion loops may arbitrary number live objects single allocation site arbitrary number objects allocated call stack contrast analysis identify allocation sites property one object live given time addition stack allocation transformation may require compiler lift corresponding object allocation site method originally contained one transitive callers original allocating method 20 object would passed reference call stack incurring runtime overhead 12 static preallocation optimization enabled analysis suer drawback compiler transforms original allocation site simply acquire pointer statically allocated memory need move allocation site callers original allocating method combined liveness incompatibility analysis use graph coloring minimize amount memory required store objects allocated unitary allocation sites similar spirit register allocation algorithms 6 chapter 11 however register allocation algorithms concerned liveness local variables computed simple intraprocedural analysis found obtaining useful liveness results dynamically allocated objects signicantly dicult particular found use predicated analysis track ow objects across procedure boundaries identify signicant amounts unitary sites 5 conclusions presented analysis designed simplify computation accurate upper bound amount memory required execute program analysis statically preallocates memory store objects allocated unitary allocation sites enables objects allocated compatible unitary allocation sites share preallocated memory experimental results show set java benchmark programs 60 allocation sites unitary statically preallocated allowing compatible unitary allocation sites share semantically equivalent alternative perform method inlining however inlining introduces set overheads preallocated memory leads 95 reduction amount memory required sites based set results believe analysis automatically eectively eliminate need consider many object allocation sites computing accurate upper bound amount memory required execute program also used analysis optimize memory managment 6 acknowledgements would like thank wes beebee scott c ananian useful advice implementing preallocation optimization mit flex compiler system 3 viktor kuncak proofreading early drafts paper also want thank anonymous referees valuable comments 7 r cartesian product algorithm mit flex compiler infrastructure java static single information form program analysis specialization c programming language modern compiler implementation java escape analysis object oriented languages removing unnecessary synchronization java realtime speci cation java daniel br data ow analysis software prefetching linked data structures java software caching computation migration olden analysis pointers structures statically determining memory consumption realtime java threads region inference algorithm compositional pointer escape analysis java programs tr compilers principles techniques tools analysis pointers structures efficiently computing static single assignment form control dependence graph software caching computation migration olden pointsto analysis almost linear time modern compiler implementation java region inference algorithm escape analysis java escape analysis objectoriented languages removing unnecessary synchronization java compositional pointer escape analysis java programs new methods color vertices graph regionbased memory management cyclone data flow analysis software prefetching linked data structures java cartesian product algorithm ctr oukseh lee kwangkeun yi experiments effectiveness automatic insertion memory reuses mllike programs proceedings 4th international symposium memory management october 2425 2004 vancouver bc canada oukseh lee hongseok yang kwangkeun yi static insertion safe effective memory reuse commands mllike programs science computer programming v58 n12 p141178 october 2005 samuel z guyer kathryn mckinley daniel frampton freeme static analysis automatic individual object reclamation acm sigplan notices v41 n6 june 2006 darko marinov robert ocallahan object equality profiling acm sigplan notices v38 n11 november chandrasekhar boyapati alexandru salcianu william beebee jr martin rinard ownership types safe regionbased memory management realtime java acm sigplan notices v38 n5 may
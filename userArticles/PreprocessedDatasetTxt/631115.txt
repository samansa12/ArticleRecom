using term rewriting verify software paper describes uniform approach automation verification tasks associated statements representation functions abstract data types generic program units abstract base classes program units annotated equations containing symbols defined algebraic axioms operations axioms developed using strategies guarantee crucial properties convergence sufficient completeness sets axioms developed stepwise extensions preserve properties verifications performed aid program incorporates term rewriting structural induction heuristics based ideas used boyermoore prover program provides valuable mechanical assistance managing inductive arguments providing hints necessary lemmas without formal proofs would impossible successes limitations approaches illustrated examples domain b introduction many different methods used annotate software prove properties fewer attempts made adapt single notation variety different annotation tasks explore interactions types tasks properties specifications demands verification techniques paper apply equational specification reasoning techniques verify properties statements abstract data types generic program units derived classes present new techniques computing weakest preconditions statements annotating abstract base classes classes derived designing algebraic specifications convergent sufficiently complete addition discuss experimental tool partially automating verification activities report experiences using techniques tool research supported part national science foundation grant ccr8908565 office naval research grants n0001487k0307 n001490j4091 rewriting 10 26 central approach use rewriting concepts designing small specifications desirable properties completeness consistency extending specifications incrementally preserving properties also use rewriting concepts proving programs correct respect specifications abstraction factorization reduce amount detail needs considered solving problems specifications play key role abstraction hiding details implementations factoring program components collecting program units common semantics rather common syntax weakest precondition 11 statement abstracts particular state transformation induced statement class state transformations satisfy particular postcondition 17 notion weakest precondition extends method proposed 20 include termination since termination verification programs unsolvable somewhat surprising one compute first order expression weakest precondition statement 8 32 expression however involves concepts godelization turing machines cannot reasoned automatically introduce notation called power functions describe statements state transformations power functions described algebraic equations operations appear statements postconditions thus may reason power functions automated way reason operations appearing program annotations power functions also allow us address incompleteness problems arising verification statements involving abstract data types 24 30 abstract data types permit program proofs factored two parts proofs programs depend abstract properties objects proofs implementations types guarantee abstract properties second type proof implementations manipulating concrete objects must satisfy pre postconditions containing abstract objects hoare 21 introduced representation mappings map concrete objects corresponding abstract objects make reasoning possible show representation mappings cast within equational framework allowing us reap benefits equational reasoning automated term rewriting parameterized subprograms factor similar operations different objects types thus reducing sizes programs generic clauses like ada extend benefits factoring program units manipulate objects different types generic formal type parameters represent classes types providing basic operations eg assignment equality additional generic formal subprogram parameters specified access additional operations generic unit instantiated syntactic discrepancies reported types formal actual generic subprogram parameters alphards designers 31 among first suggest functions defined generic type parameters semantic restrictions guarantee functions properly instantiated several research projects currently investigating restrictions stated checked 13 14 16 use equational reasoning show formal parameter specifications denoting properties required actual parameters checked generic program components instantiated objectoriented programming languages permit new classes defined via inheritance superclass defines interfaces perhaps implementations operations inherited subclasses order factor implementation common operation superclass subclass redefines operations used implementations common operations must ensure new operations behaviors consistent respective superclasss operations subclass must behave like subtype supertype groups researchers 31 28 29 currently defining subtype relations present method annotating abstract base classes classes derived using equational reason ing show derived classes subtypes abstract base class manner similar 19 section 2 discuss four classes verification problems although limit size examples dimensions suitable technical presentation representative increasingly larger programming problems common denominator verification tasks use equations annotate program components reason annotations section 3 address problems quality expressiveness specifications annotations based motivate need structuring specifications rewrite systems ensure crucial properties specifications overcome inherent difficulties equational reasoning present design strategies extending specification preserving properties rewrite system section 4 briefly describe automated tool formally proving obligations arising verification problems section 5 discuss use tool informally compare performance another automated prover section 6 contains conclusions annotation verification 21 statements power functions 2 device express weakest precondition statement form useful stating verifying program correctness briefly review technique show application two examples later section show automate steps process statement w postcondition r weakest precondition wpw r w respect r describes set states w activated state terminates state r satisfying r 11 w statement condition b body stmt r defined recursively follows statement defined state wpw rs false since h k rs hold k power function function f whose domain range identical embodies kfold composition f stmt function computed statement stmt state power function pf stmt defined undefined otherwise every function unique power function totality computability primitive recursiveness function imply similar properties power function 2 using notion power function obtain first order expression weakest precondition statement respect first order postcondition stmt total function pf power function expression p stands minimum nonnegative integer exists p holds precisely second conjunct right side short hand bpf k least value k applications stmt original state produce state b evaluates false yields following equation right side requires pf power function stmt immediately obtained via equation 1 often find convenient express power function terms functions capture higher level abstractions show one example loosely speaking say power function maximum accumulator maximum sequence case must ensure validity claim ie must prove function pf power function given function f call step validation pf respect f weakest precondition statement manageable equation 2 conjunct solved respect k ie value k explicitly determined call step minimization loop loop minimization obviously unsolvable problem since difficult demonstrate loop termination following examples show minimize loops operation considerably simplifies weakest precondition example 1 consider following program statement w postcondition r maxa1n largest value set ang function computed statement body stmt returns program state examining one component array power function pf returns program state examining slice array maxaij largest value set mg use induction validate pf ie show indeed power function stmt base minimization loop requires us demonstrate kik n substituting expression k calculate wpw r although annotations appear use familiar welldefined functions addition max actually overloaded function symbol max assuming scalar values natural numbers one version max defined two naturals another array naturals third array naturals natural algebraic axioms permit us define relations symbols appear specifications natarray theta nat theta nat nat natarray theta nat theta nat theta nat nat definitions wpw r expressed initializing statements 2 a1 transform equation verified n 0 verification tasks outlined expressed equations verified chanically tasks 1 power function validation base cases add0 inductive cases addk 2 loop minimization 3 loop initialization example 2 previous example shows one may need define new symbols analysis loop peculiarity method classic approaches correctness verification may fail due lack expressiveness data type specifications 24 30 example kamin shows program containing following statement cannot properly annotated lack expressiveness usual theory type stack similar result appears 30 equation 2 implies one needs properly annotate loop power function functional abstraction loop body rather using equation 1 chose formulate power function loop terms highlevel abstractions abstractions capture formally intuitive concepts allow programmer code program repeated execution loop body effect chopping topmost portion reversing placing top concept separating sequence initial portion remainder generalizes usual head tail operations sequences associate symbols drop take general operations axiomatize stack newstack stack newstack newstack operation drop denoted pop 24 required make type stack expressive drop power function pop operation take returns portion stack dropped drop formulate power function loop pf functional abstraction body stmt exactly informally stated earlier pf k concat reverse defined usual stack theta stack stack concatpushs stack newstack validate pf prove last equation instance second case equation 1 stems simple result 2 th 57 concerning equivalence two formulations power functions ie accumulation vs recursion minimize loop define operation size computes size stack axiomatize isnewstack verify kisnewstacktakek minimization loop obtained proving latter equivalent isnewstackdropsizes substituting permits us calculate wpw r rpf initializing newstack 0 results following wp program holds 0 22 data type implementations modern programming languages provide special constructs implement userdefined data types constructs specifically designed hide representation type users codelevel verification techniques discussed examples 1 2 insufficient address correctness implementation wide gap lowlevel operations performed code highlevel operations described operations interface example decrementing integer variable may takes pop stack however verifying variable decremented ensure code correctly implements pop operation need show code fulfills obligations abstract operations 21 example 3 implementation data type stack may represent instance type record follows subtype index integer range 1size type data array index item type stack record range 0size 0 items code fragment belongs package generic arguments size positive item private type correctness implementation type stack entails types representation mapping 21 function denoted maps concrete instance stack represented record abstract counterpart newstack implementation stack operation pop straightforward procedure popq stack begin raise underflow else qpntr qpntr gamma input stack q pop raises exception qpntr 0 qpntr 0 precondition normal termination procedure precondition satisfied pop simply decrements qpntr implementation correct clients stack package stack representation procedure code may hidden indeed perceive decrementing qpntr popping q proof method proposed hoare reduces correctness implementation individual obligations procedure package omitting readability qualification pntr items obligation procedure pop standard techniques 20 reduce correctness code truth false first disjunct describes impossible initial state would result normal termination procedure pop exception underflow raised representation mapping defined equationally proof obligation discharged automatically using tool discussed section 4 23 instantiations generic program units modularity essential feature design implementation large programs generic type subprogram parameters added statically typed programming languages avoid duplicating operations source code cases manipulates objects operations either implicitly defined generic formal type parameters appear generic formal subprogram parameters interconnection errors become likely subtle language features used compilers andor loaders verify syntactic properties module interconnections verification semantic correctness entails activities similar required verification loops data types discussed earlier ie axiomatizing symbols used asserting properties requirements modules proving theorems expressed means symbols modules example 4 many computations sets sequences elements instances general paradigm referred accumulation 4 example finding maximum element computing sum elements counting many elements certain property computations implemented loop whose body processes new element sequence iteration special variable whose initial value depends computation performed accumulates result computation portion sequence processed thus far example 1 presented earlier instance accumulation sequence elements represented array process performed finding maximum language supporting generic parameters interface simple accumulator types elements accumulated result appears follows type type vector arrayinteger range elem function stepa b elem return elem return elem begin v 0 first last loop stepa vi return generic subroutine instantiated eg actual parameters natural nat vect 0 max shown discrepancies may detected types generic subprogram parameters types actual objects bound procedure main function max array new accumulatorelem unfortunately syntactic discrepancies reported implementations accumulator may rely semantic properties hold bindings cannot detected compiler example certain accumulations performed parallel simplest form parallel implementation accumulator may simultaneously activate two tasks task accumulator operating half input array feeding results function step returns desired value improve implementations efficiency use treelike cascade tasks executing single invocation step parallel however parallel implementation accumulator assumes function bound generic parameter step associative element bound parameter init left identity ie elem step init monoid result established following manner let e 1 sequence values processed accumulator function defined techniques described section 21 prove function computed code accumulator k k j following equation holds implement accumulator parallel described easy show equation 3 holds elem monoid algebraic notation used specify properties generic subroutine parameters verified specifications actual parameters restrictions made explicit writing conditions including text specification accumulator stepstepx function accumulator instantiated actual arguments replacing formal parame ters identifiers axioms actuals replaced names formals specification actual arguments used prove conditions example easy verify conditions operation max 0 maximum two natural numbers specified example 1 likewise instantiation requirement holds addition multiplication exponentiation thus exponentiation cannot legally bound generic parameter step 24 inheritance objectoriented programming languages permit definition new classes via inheritance subclass inherits data representations operations superclass may add redefine components use algebraic equations specify behavior classes verify subclass relation also subtype relation example 5 following example shape abstract class serve superclass another class objects type shape may created class shape public virtual point center const return point left virtual void move const point void recenter const point p move pcenter virtual double top virtual double bottom virtual double left virtual double right abstract class used define interfaces operations manipulate objects created subclasses example recenter moves object new position circle declared subclass shape redefining latters center operation efficient version providing definitions operations pure virtual functions shape ie move top etc class circle public shape public circle const point c const double inline void radius const double r assert r0 radius r inline double radius const return radius inline void center const point c center c inline point center const return center inline void move const point p centermovep double top const return centery double bottom const return centery radius double left const return centerx radius double right const return centerx private point double radius passed reference circle object recenter invokes circles center move operations point p11010 p255 circle cp120 use algebraic specifications define meanings shapes operations first argument abstract operation f modeling corresponding concrete operation f class instance f belongs example referring program fragment recenterc p2 abstract counterpart crecenterp2 specify abstract class shape means sort rather describe relationships class defined operations completeness specification critical issue heuristically consider pair triple etc member functions shape capture mutual dependencies algebraic equations remove obviously redundant equations specifications define meanings operations manipulate objects type shape using specifications may prove correctness implementation member functions pure virtual assuming correctness future implementation member pure virtual discussed earlier verification condition conjunct ensures argument recenter remains constant proof implementation recenter relies pre postconditions shapes center move operations proofs hold recenter passed object whose type derived shape objects type must subtype merely subclasses type shape show must demonstrate relationships among operations shape hold operations instances circle specifications circle shown differ shape since latter classic abstract data type rather abstract class c sense first condition class invariant ensures every circle nonnegative radius circles operations annotated usual 21 although standard proof techniques imperative languages 11 20 may fall short prove objectoriented code concerned different problem want prove circle subtype shape task verify annotations shape hold every instance circle activity similar proving circle implements shape technique proposed 19 minor differencea circle shape thus representation function equality interpretation involved proofs proofs easily formulated problems theorem prover completed automatically designing specifications annotations problems discussed previous sections formulated resolved using first order formulas formulas involve symbols specification whose atomic components equations section discuss design equations specifications goal produce equations specifications easy process automatically processing limited proving formula expressing correctness piece software also includes analyzing specifications determine satisfy properties whose absence often sign flaws major obstacle automation declarative nature equations changing equations rewrite rules makes specification operational simplifies problem 31 rewriting unrestricted freedom provided equational reasoning replacing term equal term leads combinatorial explosion possibilities hard manage prover whether automated human equation oriented yielding rewrite rule rewrite rule still defines equality 1 2 allows replacement instance 1 corresponding instance 2 forbids replacement opposite direction orienting equations transforms algebraic specification term rewriting system 10 26 two crucial properties must achieved equations oriented two terms provably equal equational reasoning common reduct ie third term rewritten property referred confluence churchrosser addition possible rewrite term forever particular circular rewrites property referred termination noetherianity system properties canonical complete convergent knuthbendix completion procedure 27 attempts transform equational specification complete rewrite system termination procedure cannot guaranteed execution may require human intervention difficulty stems undecidability whether rewrite system canonical 9 22 reason attempt convert equational specification corresponding complete rewrite system rather ask specifiers structure specifications rewrite systems characteristics task eased considerably two strategies used designing specification technique also ensures properties sufficient completeness deem essential framework 32 sufficient completeness constructorbased systems apply technique consider constructorbased systems ie partition signature symbols constructors defined operations constructors type generate data instances values represented terms called normal forms cannot reduced terms containing defined operations represent computations example constructors natural numbers 0 successor denoted postfix 1 examples constructors type stack discussed example 2 newstack push since stack either empty obtainable pushing element stack concat reverse examples defined operations considering constructorbased systems raises problem sufficient completeness yet another undecidable property 25 specification type sufficiently complete must assign value term type 18 specification structured constructorbased rewrite system sufficient completeness equivalent property normal forms constructor terms left sides axioms defined operations outermost operators constructor terms arguments state necessary sufficient conditions sufficient completeness specification constructor enumeration 7 set c tuples constructor terms substituting constructor terms variables tuples c exhaustively unambiguously generates set tuples constructor terms set tuples arguments defined operation constructor enumeration example set tuples arguments drop discussed example 2 shown constructor enumeration hnat stacki since every pair hx yi x natural stack instance one one element c set tuples arguments operation max 0 discussed example 1 constructor enumeration since h0 0i instance h0 ii hi 0i second axiom although difference affect specification latter axiomatization removes triv ial ambiguity note right side second axiom defined specification would inconsistent since would consequence axioms operation overspecified two rules used rewrite combination arguments underspecified rule used rewrite combination arguments overspecification detected superposition algorithm 27 uses unification detect overlapping underspecification natural condition operations although creates nonnegligible problems systematically avoided example framework ordersorted specifications 15 underspecification detected algorithm informally described 23 operations underspecified called completely defined huet hullot devised algorithm detect incompletely defined operations algorithm assembles arguments axioms tuples terms th position tuple checked see include variable instance constructor constructor c tuples remaining arguments constructor c variable position formed recursively tested rigorous description appears 23 way example execute algorithm set c input constructor 0 position 1 tuple 1 considered set tuples remaining arguments fhsig trivially complete constructor successor position 1 tuples 2 3 considered set tuples remaining arguments fhnewstacki hpushs eig contains instance constructor stack position 1 completeness recursive problem fhig newstack fhs eig push obvious ensure confluence constructorbased specification sufficient avoid overspecifi cation ensure sufficient completeness necessary sufficient avoid underspecifica tion operations completely defined terminating specification sufficiently complete fact every term normal form obviously contains constructor symbols term containing defined operation reducible underspecification overspecification easily checked syntactic properties however termination rewrite system undecidable 9 next section discuss syntactic properties sufficient ensure termination show obtain design strategies 33 design strategies axioms confluence sufficient completeness undecidable although essential properties spec ification lack confluence implies computation ambiguously specified lack sufficient completeness implies computation unspecified regard conditions serious flaws specification describe two design strategies generating confluent sufficiently complete specifications binary choice strategy interactive iterative nondeterministic procedure sequence binary decisions generates left sides axioms defined operation used symbol called place placeholder decision let f operation type consider template th place sort get rules left side must replace place template either variable constructor term appropriate sort forming left sides neither want forget combination arguments include combinations twice want avoid underspecification overspecification equivalent forming constructor enumeration achieve goal selecting place template chosing one two options variable inductive choice variable replaces selected place fresh variable choice inductive place sort splits corresponding template several new templates one constructor c sort new template replaces selected place c many places arity c formal description strategy appears 3 apply strategy designing left sides rules operation drop discussed example 2 initial template chose inductive first place since sort place natural split template two new templates one associated 0 successor chose variable remaining place first template variable first place second template obtain chose inductive last remaining place since sort place stack split template two new templates one associated newstack push obtain remaining choice variable selected completing rules left sides describe second strategy ensures termination recursive reduction term term obtained stripping recursive constructors constructor sort called recursive argument sort example successor push recursive constructors stripping term ct derived operation recursive constructor removes outermost application constructor stripping process recursively applied throughout term formal description recursive reduction function appears 3 show application examples reasons become clear shortly interested computing recursive reduction left side rewrite rule use corresponding right side symbol right side rule denotes recursive reduction rules left side convention last axiom drop written since recursive reduction left side dropi obtain replacing 1 since recursive argument successor replacing pushs e since recursive argument push constructor several recursive arguments recursive reduction requires explicit indication selected argument may also specify partial rather complete stripping recursive constructors recursive reduction strategy consists defining right sides rules using functional composition symbols terminating term rewriting system recursive reduction corresponding left sides specification designed using binary choice recursive reduction strategies canonical sufficiently complete 3 34 design strategies specifications strategies lead naturally design approach called stepwise specification extensions 12 given specification step extends specification adding operations yielding new specification i1 i1 complete consistent extension 12 every data element i1 already distinct elements remain distinct i1 furthermore canonical sufficiently complete i1 3 clarify concepts showing steps yielding specification example 2 initial specification 0 consists sorts boolean natural stack constructors ie true false 0 successor newstack push since rewrite rules ie constructors free canonicity sufficient completeness 0 trivially established extend 0 operation concat obtaining 1 concatpushs recursive reduction left side concats since designed concat axioms using binary choice recursive reduction strategies 1 complete consistent extension 0 canonical sufficiently complete specification step may also extend take size isnewstack however cannot extend 0 reverse right side one axiom reverse contains concat must first establish properties specification containing concat hence separate step necessary extend 1 operation reverse obtaining 2 newstack strategies together stepwise approach ensure 2 complete consistent extension 1 canonical sufficiently complete specification specifications presented note designed manner binary choice strategy force us construct left sides plausible axioms want define right side complete definition axioms placing distinguished symbol right side specification languages follow equivalent approach control incompleteness example larch would declare exempt term appearing left side one axiom single strategies used also presence nonfree constructors properties specifications nonfree constructors confluence longer automatically guaranteed checked easily strategies used design specification 3 proving theorems annotations examples previous section contain many small theorems need proved automating proofs makes easier carry less prone error section report experience task 41 induction many equations eg cannot proved rewriting ie using equational reasoning equations proved via structural induction 6 data type induction 19 inductive variables type replaced terms determined constructors inductive hypotheses established f formula proved v inductive variable type v induction proofs carried following manner every constructor c skolem constant inductive hypothesis 42 automated theorem prover implemented prototype theorem prover incorporating many concepts boyermoore theorem prover 5 however except builtin knowledge term equality data type induction knowledge theorem prover supplied specifications theorem prover checks function completely defined executing huets inductive definition check identifies inductive arguments filled instances constructors discovery inductive arguments allows prover generate automatically theorems constitute cases proof induction theorem prover executes four basic actions reduce fertilize generalize induct reduce applies rewrite rule formula proved fertilize responsible using inductive hypothesis ie replacing subterm current formula equivalent term inductive hypothesis generalize tries replace nonvariable subterm common sides formula fresh variable induct selects inductive variable generates new equations induction variable chosen set inductive arguments heuristics include popularity 5 seniority theorem prover computes boolean recursive function called prove whose input equation whose output true equation proved axioms lemmas specification accessed global data proofs theorems generated side effects computations prove users may override automatic choices made prover inductive variables generalizations technique discussed later allows users use case analyses proofs function provee begin e form x x term x return true end e reduced return provereducee end e fertilized return provefertilizee end contains inductive variable return return false attempt prove theorem may exhaust available resources since induction may generate infinite sequence formulas proved however termination property rewrite system guarantees equation cannot reduced forever elimination previously used inductive hypotheses 5 guarantees equation cannot fertilized forever 5 experience proving theorems proofs discussed previous sections completely generated theorem prover except two proofs inheritance properties many proofs produced automatically prover others generated supplied additional lemmas independently proved using theorem prover validation proofs power functions statement examples done automatically term rewriting others rewriting induction minimization proofs slightly challenging array example required three simple lemmas eg proved added set axioms theorem prover could finish proofs lemmas suggested similarity terms opposite sides equations generated theorem prover generalization inhibited obtain minimization proofs stack example explained relationships different skolem constants inserted time may lost generalization replaces terms containing constants new constants attempting verify generate equation generalization replaces sizea1 new skolem constant b2 starts verify lemma relation a1 b2 lost generalization crucial validity theorem nested inductions equation rewritten proof attempt fails simply inhibiting generalization case solves problem theorem proved rewriting induction however generalization essential proofs illustrate example also shows discover lemmas make proofs possible simpler proof total correctness example 2 requires verifying induction formula proved becomes prover simultaneously generalizes reversetakesizea1 a1 pushnewstack a2 attempts prove proof easily completed nested inductions a6 a7 without generalization proof continues induction a1 inductive hypothesis strong enough complete proof prover keeps generating new inductions formulas increasing complexities available resources exhausted regard generalized formulas lemmas often able generalize lemmas suggested prover example equation 4 suggests newstack might right identity concat thus prove use lemma original proof immediately reduced original formula presence leading reverse side equation suggests equality may depend arguments thus attempt prove proof succeeds use result lemma original proof two lemmas original proof becomes trivial lemmas obtained removing context generalization hypothesizes truth equation depend certain internal specific portions side latter example hypothesizes truth equation depend certain external specific portions side ie proof conditions required semantic correctness generic instantiations accumulator attempted operations max 0 see example 1 addition multiplication exponentiation theorems relative first three instantiations proved automatically however attempt prove associativity exponentiation fails prover attempts verify nested induction equation reduced prover halts message failed case thus first three instantiations generic accumulator semantically correct interestingly fact equation 3 holds step associative init left identity proved automatically prover reversal stack discussed example 2 parallelized divideandconquer technique similar discussed accumulation program instance complex case accumulation type result accumulation differs type elements accumulated sequence may exploit parallelism assume stack dynamically allocated chunks chunk consists fixedsize arraylike group contiguous memory locations addressed index chunks allocated demand necessarily occupy contiguous locations memory rather threaded together pointers linked list reverse stack parallel stack consists several chunks case split stack two nonempty portions say x linked together whole chunks assume bottommost chunk x points topmost chunk reverse link recursively reverse x portion stack consists single chunk swap content chunks memory locations achieve reversal correctness parallel implementation stack reversal relies equation reverse concat defined example 2 operationally concat stands operation linking together two portions stack represented arguments reverse overloaded multichunk stacks partitions recurs whereas singlechunk stacks swaps proof equation entails mutual relationships symbols implementations thus representation chunks type stack issue proof obviously comprehensive proof correctness differences two computations associated reverse must accounted eg discussed section 22 prover proves equation without human help interestingly proof induction x prover automatically generates proves independent lemma case induction one lemma states newstack right identity concat concat associative section 24 presented annotations involving c predefined type double axiomatize type means algebraic inductive specification consequently could use prover theorems relying intrinsic properties type however proofs section except lefts rights bottoms tops easily proved provided simple unproved lemmas commutativity double 51 informal comparison need supply guidance automatic prover peculiarity implementation example larch theorem prover lp 13 designed proof checker well automated prover consider approach sensible guidance required prover form lemmas lemmas simplify proofs improve understanding removing context case also overcome lack certain proof tactics friendly interface implementation briefly compare lp prover prove two sample theorems proposed 13 proofs involve types linear container priority queue whose axioms shown total order type boolean standard operators member next nextinsertq else nextq c nextq else c symbol axioms next corresponds larch declaration exempt nextnew lp used prove theorems e e first theorem proved inductive variable c explicitly picked second theorem required intervention rewriting produced lp given series commands divide proof cases apply criticalpairs comple tions case isemptyq required criticalpairs completion case isemptyq required case analysis truth v nextq case subdivided based truth case v nextq criticalpairs completion requested prover also verified theorems first automatically second added lemmas axioms since provers knowledge derives axioms treat conditional expressions implications special manner represented means userdefined operations example implication defined following axioms true false thus often need lemmas manipulate functions since prover handles equations formulate second theorem prover automatically chooses a0 inductive variable base case new trivially proved rewriting inductive case true inductive hypothesis reduces left side large nested conditional expression use two standard lemmas simplify one distributes respect conditionals ie replace instances x b else z b x else x z transformation allows use properties ordering relation irreflexivity implied equation 13 fig 9 lemma splits implications whose antecedent disjunction ie replace instances x z z z transformation allows use antecedent independently applications lemmas left side equation proved becomes enable use antecedent conjunct formula means two specific lemmas approach directly inspired 5 one lemma replaces instances lemma replaces instances q holds specific instance latter membera2 a1 ie contrapositive form first theorem proved problem several inference steps left side reduced continue cases nexta2 a3 expression negation appear formula although prover lacks proofbycases tactic simulate lemma p formula proved x boolean subexpression p use lemma rewrite p x p replace subexpression x p known implied x likewise conjunct reasoning cases allows us crossfertilize p 5 using lemma triggers additional rewriting activity transform left side conjunct antecedent nexta2 a3 rewritten fertilized inductive hypothesis reduced true continue cases membera2 a1 truth theorem depends standard properties ordering relations first conjunct rewritten consequent holds transitivity successively reducing consequents true second conjunct eventually reduced true true thus proof terminates successfully complexities proofs comparable obtained lp inductive variables chosen automatically less case analysis required need invoke knuthbendix completion although technique occasionally useful find proofs generates difficult understand thus prefer tactic situations allow data type induction eg non constructorbased specifications provide lemmas prover lemmas either trivial instances trivial lemma schemas although suggesting requires understanding proof mixed blessing effort understand proof go helps discovering relevant properties specification may lead better specifications even code enhancements user interface prover primitive consequence iterated proof attempt several times completion create manually instances lemma schemas supplied prover 6 concluding remarks discussed formal verification techniques problems characterized differences sizes addressed properties loops critical components small programs problems solved domain correctness termination lack expressiveness axiomatizations used annotations inherent difficulty reasoning repeated modifications program state data type implementations representative medium size programs crucial problem solved mutual internal consistency group related subroutines bound choice representation abstract concepts means structures offered hardware architecture andor programming language proofs correctness domain entail code also representation mapping physical presence software module interconnection significant feature large programs syntactic semantic commitments one component may match expectations another problem exacerbated languages allow customization software unit means units proving correctness involve code directly annotations generated proofs correctness previous problems tasks addressed common formalism equational specifications proof techniques rewriting induction particular formalizations based specifications qualitative extent quantitative point view independent tasks sizes furthermore discussed conceptual practical tools designing using specifications crucial requirement specification adequacy assumption specification good often mistaken unless considerable care devoted design several properties unfortunately undecidable generally used address quality specification shown restricting expressive power specification language common fundamental properties guaranteed hard say whether restrictions severe encouraging discover typical verification problems proposed literature pose severe problems proposed specifications easy use humans automated tool rewriting fundamental idea behind approach design strategies presented designing rewrite rules ensure properties smaller units specifications defined operations strategies also allow us build specifications incrementally way preserves properties smaller units building large specifications smaller ones glossed problems modularizations parameterization specifications approach compatible various techniques proposed features respect properties able guarantee ease composition specifications hardest task nearly verification problem proving theorems informal proofs easier understand formal ones less reliable formal proofs except simplest problems complicated humans without automated tools proofs contain hundreds inferences majority simple rewriting steps prover becomes effective occasional hints lemmas supply macrosteps prover lack knowledge experience would carry completion certain contexts finding appropriate lemmas always easy however lemmas discussed comparison lp relatively standard others suggested prover generalization generalizations sometimes find elegant lemmas finally inspecting proof attempts able detect repeated patterns formulas increasing complexities generally lead proof failures conditions arise look lemmas overcome problems believe specification approach adequate large number cases however prover still fails solve nontrivial problems autonomously manages bookkeeping inductions provides hints necessary lemmas completely removes tedium rewriting clerical mistakes associated activity prints readable proofs although sometimes makes inferences necessary provers rewrite strategy nermost outermost rewriting strategy would produce shorter readable proofs shows remarkable skill finding inductive variables despite considerable limitations user interface proof tactics prover increases quality specifications enhances considerably human ability produce formal proofs software problems r parallel objectoriented language inheritance subtyping automatically provable specifications design strategies rewrite rules development iterative programs functional specifications computational logic proving properties programs structural induction complexity analysis termrewriting systems mathematical theory program correctness termination rewriting rewrite systems discipline programming fundamentals algebraic specifications 1 equations initial semantics debugging larch shared language specifications ieee computer operational semantics ordersorted algebras introducing obj3 notes type abstraction algebraic specification abstract data types abstract data types software validation axiomatic basis computer programming proof correctness data representations confluent reductions abstract properties applications termrewriting sys tems proofs induction equational theories constructors expressive theory stacks sufficientcompleteness related properties term rewriting systems rewriting systems simple word problems universal algebras modular specification verification objectoriented programs family values semantic notion subtyping new incompleteness result hoares system introduction construction verification alphard programs verification programs predicate transformation tr reusing interconnecting software components expressive theory stacks termination rewriting complexity analysis termrewriting systems parallel objectoriented language inheritance subtyping debugging larch shared language specifications rewrite systems rewriting systems new incompleteness result hoares system confluent reductions abstract properties applications term rewriting systems abstract data types software validation axiomatic basis computer programming mathematical theory program correctness discipline programming fundamentals algebraic specification modular specification verification objectoriented programs operational semantics ordersorted algebra design strategies rewrite rules ctr olivier ponsini carine fdle emmanuel kounalis rewriting imperative programs logical equations science computer programming v56 n3 p363401 mayjune 2005 antoy dick hamlet automatically checking implementation formal specification ieee transactions software engineering v26 n1 p5569 january 2000
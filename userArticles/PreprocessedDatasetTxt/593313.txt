ordering constraints feature trees feature trees formal basis algorithms manipulating record like structures constraint programming computational linguistics concrete applications like software configuration management feature trees model records constraints feature trees yield extensible modular record descriptions introduce constraint system feat ordering constraints interpreted feature trees view feature trees relation leq corresponds information ordering carries less information present two algorithms cubic time one satisfiability problem one entailment problem feat show feat independence property thus able handle negative conjuncts via entailment obtain cubic algorithm decides satisfiability conjunctions positive negated ordering constraints feature trees furthermore reduce satisfiability problem drres weak subsumption constraints satisfiability problem feat improve complexity bound solving weak subsumption constraints on5 on3 b introduction feature constraints used describing records constraint programming 2 24 23 record like structures computational linguistics 13 12 20 18 19 following 3 5 4 consider feature constraints predicate logic formulae interpreted structure feature trees feature tree possibly infinite tree unordered labeled edges possibly labeled nodes edge labels functional ie labels edges departing node must pairwise different view feature trees represent symbolic information feature tree 1 represents less information feature tree 2 1 fewer edges node labels 2 relation define corresponds information ordering precisely sense algebraically homomorphic embed wine red color wine red 1997 color year ding 1 2 ie mapping nodes 1 nodes 2 node labeling invariant example given picture introduce constraint system ft information ordering constraints feature trees system ft obtained adding ordering constraints constraint system ft 3 syntax ft constraints j defined x x 0 variables label semantics ft given interpretation feature trees symbol interpreted information ordering feature trees semantics xay ax defined ft stance trees depicted possible values x solutions constraint clear ft expressive ft since information ordering antisymmetric ie show paper ft strictly expressive ft instance constraint ft equivalent xx 0 also know formula ft even existential quantifiers equivalent 9xx 1 x x 2 x9xx 1 x x 3 x ft formula expresses x 1 unifiable x 2 x 3 imply unifiability x 2 x 3 show satisfiability problem conjunctions positive negative ft constraints jj 1 j n decidable 3 result includes decision procedure entailment problem form j 0 formula j 0 j unsatisfiable establish result prove ft fundamental independence property similar relatives rt 6 ft 3 cft 24 reduce satisfiability problem dorres weaksubsumption constraints 7 feature algebras linearly one ft thereby algorithm improves best known satisfiability test weak subsumption constraints uses finite automata techniques 5 complexity bound 7 plan paper section 2 surveys related work section 3 defines ft section 4 presents satisfiability test ft constraints section 8 contains completeness proof section 5 presents entailment test ft constraints proves independence property ft section 6 defines weak subsumption constraints reduces satisfiability problem one ft constraints section 7 shows ft strictly expressive ft related work ines constraints previous work 17 introduced constraint system ines inclusion constraints nonempty sets trees cubic satisfiability test satisfiability test ft inspired subsumes one ines however entailment problems ft ines constraints different entailment problem ines constraints conphard 16 intuitively entailment problem ft less expressive one ines ft constraint j cannot uniquely describe single feature tree absence arity constraints contrast ines constraints inclusions firstorder terms implicit arity restriction uniquely describe constructor tree singleton set instance ines constraint xa describes singleton fag consequence entailment proposition xaay xy holds ines similar entailment phenomenon exists ft feature constraints constraint system cft 24 extends ft arity constraints form xf f saying denotation x subtrees exactly features rational tree constraint system rt 6 provides finergrained constraints system ef 25 extends cft feature constraints xyz providing firstclass features complete axiomatizations ft cft given 5 4 respectively satisfiability ef constraints shown nphard 25 system ft sort extends ft allowing partial order labels 15 subsumption constraints subsumption ordering domain feature alge bras subsumption constraints considered context unificationbased grammars model coordination phenomena natural language 9 7 21 one wants express two feature structures representing different parts speech share common properties example analysis programming linguistics phrase feature constraints np programming np linguistics share might refine differently information common noun phrases since satisfiability subsumption constraints undecidable 9 dorre proposed subsumption decidable approximation subsumption show information ordering feature trees investigated paper coincides subsumption ordering interpreted algebra feature trees independent constraint systems constraint system fundamental independence property negated conjuncts independent constraints cannot express disjunctions give formal definition later apart mentioned tree constraint systems rt ft cft 6 1 24 3 constraint systems independence property include linear equations real numbers 14 infinite boolean algebras positive constraints 10 3 syntax semantics ft constraint system ft defined set constraints together interpretation feature trees assume infinite set variables ranged xyz infinite set l labels ranged ab feature trees path p finite sequence labels empty path denoted e freemonoid concatenation paths p p 0 pp 0 given paths p q p 0 called prefix p domain nonempty prefix closed set paths feature tree pair l consisting tree domain partial labeling function l l given feature tree write tree domain l labeling function set feature trees denoted f feature tree called finite tree domain finite infinite otherwise syntax ft constraint j defined following abstract syntax ft constraint conjunction basic constraints either inclusion constraints xy labeling constraints ax selection constraints xay compatibility constraints xy compatibility constraints needed algorithm expressed firstorder formulae inclusion constraints see proposition 1 identify associativity commutativity conjunction ie view j multiset inclusion labeling selection compatibility constraints write j j 0 conjuncts j contained j 0 size constraint j defined number label variable occurrences j semantics next define structure f feature trees interpret constraints signature f contains binary relation symbols every label unary relation symbol binary relation symbol f relation symbols interpreted partial function 1 let f denote firstorder formulae built ft constraints usual first order connectives call f satisfiable valid f satisfiable valid structure f say f entails f 0 written f valid f equivalent f 0 f 1 f 2 valid denote v f set variables occurring free f lf set labels occurring f proposition 1 formulae xy 9zxz yz equivalent f proof let variable assignment f also solution formula 9zxz yz since l sx l sy l sz l sz partial function l sx l sy also partial function hence solution xy conversely solution xy l sx l sy partial function thus pair feature tree variable assignment 0 defined 0 x 6 z solution xz yz 2 4 satisfiability test present set axioms valid ft interpret axioms algorithm solves satisfiability problem ft axioms algorithm inspired ones ines constraints presented 17 table contains five axiom schemes f1 f5 regard sets axioms union sets axioms denoted f ie instance axiom scheme xx represents infinite set axioms obtained instantiation meta variable x axiom either constraint j implication constraints implication proposition 2 structure f model axioms f f1 xx xy yz xz false 6 b table 1 satisfiability ft constraints proof routine check illustration prove statement second rule f3 namely xy yy following implications hold algorithm f set axioms f induces fixed point algorithm f given input constraint j iteratively adds logical consequences f fjg j observe actually constraints form xy xy derived precisely every step f inputs constraint j terminates false outputs constraint termination false takes place exists j 00 j j 00 false 2 f output jj 0 possible j 0 2 f exists j 00 j example 1 inconsistency due incompatible upper bounds consider false 6 b may add xz f31 zx via f33 yx f32 finally terminate false via f5 example 2 need f4 deriving unsatisfiability constraint algorithm f may add xy several steps shown example 1 may proceed xy 0 via f4 terminate false via f5 termination fixed point algorithm f terminates reflexivity inclusion xx restricted variables x 2 v j given subset f f constraint j called fclosed algorithm f restriction wrt axioms f cannot proceed j note false fclosed since constraint definition example 3 control takes care termination presence cycles like xax instance following constraint fclosed particular f2 f4 loop cycle xax infinitely often example also illustrates fixed point algorithm would terminating based axiom xax proposition 3 j constraint variables algorithm f input j terminates control 2 proof since f introduce new variables may add 2 nondisjointness constraints xy 2 inclusions xy 2 proposition 4 every fclosed constraint j satisfiable ft proof see section 8 2 theorem 5 satisfiability ft constraints decided time 3 offline onlinesee 11 n constraint size proof proposition 2 shows j unsatisfiable f started j terminates false proposition 4 proves j satisfiable f started j terminates constraint since f terminates input constraints control prop yields effective decision procedure main idea complexity proof one needs 2 steps prop 3 implemented time implementation organized incrementally exploiting algorithm f leaves order unspecified axioms applied hence obtain offline online complexity implementation details complexity proof omitted since similar presented 17 2 5 entailment independence negation section give cubic algorithm testing entailment j 0 prove independence property ft hence solve conjunctions positive negative ftconstraints jj basic constraint conjunction free constraint j ie given following abstract syntax entailment j 0 equivalent fact entailment j j holds basic constraints j next characterize entailment problems j 0 syntactically say constraint syntactically contains written j one following holds exist x 0 0 x 0 ay 0 j say firstorder formula f syntactically contains f j f 0 j lemma 6 given fclosed constraint j compute representation j linear time allows test syntactic containment j time o1 proof simple 2 easy see syntactic containment semantically correct ie j implies deciding entailment show notion syntactic containment semantically complete ie j 6 j 6j proposition 13 idea construct satisfiable extension j saturation syntactically simultaneously contradicts syntactically contained j lemma 12 saturation defined terms two operators g 1 g 2 constraints operator g 2 g 2 j contradicts form xy xy ax ie selection constraints syntactically contained j lemma 10 operator g 1 serves contradicting selection constraints instance consider j yy case g 1 j enforces existence feature denotation x adding j constraint xav xa fresh variable v xa g 2 g 1 j contradicts either yv xa v xa see example 4 sense g 1 preprocessor g 2 definition 7 let j constraint v 1 v 2 distinct fresh variables l 1 l 2 distinct labels furthermore every pair variables x 2 v j label every label 2 lj let l x l xy fresh labels v xa fresh variable define g 1 j g 2 j dependence example 4 consider constraint fclosed trivial constraints entail xay order contradict xay compute fclosure g 1 j 0 g 0 v xa xxv xa yv xa observe v xa definition g 2 g 2 g 0 contradicts v xa hence g 2 g 0 xay lemma 8 let j fclosed hence satisfiable constraint g 1 j satisfiable f closure g 0 satisfies following two properties basic constraints 1 j 6 v v j g 0 2 j 6 xay g 0 proof fclosure g 0 1 j g 1 j following form upto trivial constraints symmetry compatibility constraints exist exist exist instance note v xa x 0 x 0 v xa g 0 clauses 42 43 reflexivity constraints g 0 either belong g 1 j derived axioms f fclosedness g 0 1 j proved somewhat tedious case distinction holds two additional properties g 0 lemma 9 j fclosed g 2 j satisfiable proof difficult show constraint part g 2 j fclosed trivial constraints xx xx symmetric compatibility constraints critical bit check negated selection constraints added clause 1 g 2 j consistent let 9y 0 yl x 0 g 2 j must show g 2 j 6j 9y 0 yl x 0 assume converse g 2 j corollary 27 section 8 exist z z 0 g 0 definition g 2 j know z x however definition g 2 clause 1 apply thus 9y 0 yl x 0 cannot contained g 2 j contradiction assumption 2 lemma 10 let j ftconstraint let basic constraint form xy xy ax ie selection constraint g 2 j proof inspection definition g 2 j clause 1 contradicts entailment xy j forcing x feature l x must clause 2 contradicts xy forcing x common feature l xy subtrees x l xy incompatible clause 3 contradicts ax label forcing x unlabeled ie compatible least two trees distinct label 2 definition 11 saturation let j fclosed constraint g 0 1 j fclosure exists according lemma 8 saturation j formula satj given lemma 12 let j fclosed constraint v v j j 6 implies proof let g 0 1 j fclosure g 1 j selection constraint g 2 g 0 lemma 10 otherwise let lemma 82 lemma 10 either g 2 g 0 holds cases g 2 g 0 proposition 13 notions entailment syntactic containment coincide basic constraints j fclosed basic constraint j proof assume j converse correctness syntactic con tainment v 6 v j form xx xx j otherwise since satj contains j moreover satj satisfiable lemmas 8 9 satj 6j hence j lemma 12 2 theorem 14 entailment entailment problems form j 0 tested cubic time proof let n size j 0 j decide j 0 first test whether j 0 satisfiable theorem 5 done computing fclosure test fails entailment test trivial otherwise lemma 12 obtain hence j 0 size 2 hence lemma 6 decidable time overall complexity sums 3 theorem 15 independence constraint system ft independence prop erty ie every n 1 constraints jj proof assume unsatisfiable done also satisfiable j j let j jj satisfiable let j fclosed wlog prop 2 exists syntactically contained j j done otherwise exists j 6 lemma 12 yields satj satisfiable lemma 8 entails j contradicts assumption j corollary negation satisfiability conjunctions positive negative ft constraints jj 1 j k tested time 3 n size given conjunction proof j nonsatisfiable j n trivially nonsatisfiable proposition 5 satisfiability j decidable time 3 assume j satisfiable independence theorem 15 j n nonsatisfiable j lemma 12 equivalent existence overall 2 candidates tested syntactic containment possible tested time o1 total complexity sums time 3 6 weak subsumption constraints next introduce weak subsumption constraints used computational linguistics show satisfiability problem subsumed one ft syntax assume given set c constants c set features consider set labels subsumption constraint h ft constraint following form note compatibility constraints occur 7 add simplify comparison semantics interpret weak subsumption constraints whole class feature algebras induced weak subsumption ordering define feature algebra c consists set dom called domain unary relation c dom every constant c 2 c binary relation dom every feature 2 satisfy following properties aa 0 00 2 dom constants c c 1 ad 0 ad 00 2 c 1 c 2 c literature 22 7 slightly different notion feature algebras constants considered give formal comparison two notions end present section proposition 17 structure f l feature algebra c proof properties follow axioms f antisymmetry information ordering ft xy yx xy 2 given feature algebra define weak subsumption ordering follows simulation binary relation domain satisfies following properties elements 1 2 0 2 domain 1 1 2 1 da 2 1 0 2 0 subsumption ordering greatest simulation relation subsumption relation induces compatibility relation exists 1 2 feature algebra induces structure signature f interpreted weak subsumption ordering c c proposition 8 structure f coincides structure induced feature algebra defined f proof sufficient prove weak subsumption relation feature algebra defined f coincides information ordering f proof case feature algebras constants found 8 page 24 satz 6 satz 7 algebra feature trees called algebra path functions direct proof additional 5 lines omitted lack space 2 theorem 19 weak subsumption constraint h satisfiable f h satisfiable structure induced feature algebra proof h satisfiable satisfiable structure induced feature algebra defined f conversely every structure induced feature algebra model axioms f thus h satisfiable one structure equivalent fclosed constraint false hence satisfiable f 2 alternative notions feature algebras literature 22 7 restricted notion feature algebra considered call feature algebra constants sequel focus feature algebras constants leads restricted satisfiability problem shows presented results properly extend results 7 feature algebra constants feature algebra additional property ca ad 0 1 order handle new property consider following mapping weak subsumption constraints c weak subsumption constraints c flabelg label new constant contained c proposition 20 constraint h satisfiable feature algebra satisfiable feature algebra constants proof satisfiable feature algebra constants c features flabelg h satisfiable feature algebra f labels c given solution 0 solution h f defined follows exists domain 0 xp p 2 g exists domain 0 xplabel ca g conversely let h satisfiable feature algebra h satisfiable f theorem 19 consider following feature algebra constants f show satisfiable f constants features f c dflabelg respectively domain f contains feature trees without labeled internal nodes labeled internal node path p p 2 exists c exists pd 2 selection labeling relations f ft restricted trees without internal labels obviously f satisfies three axioms feature algebra constants let asolution h variable assignment 0 mapping x 0 x given f solution exists 7 expressiveness show ft strictly expressive ft ft cannot express constraint ft constraint h form xy ax xay hh 0 arity constraint form xfa g arity constraint xfa holds x denotes tree subtrees exactly 1 n proposition 21 ft constraint expresses variable x denotes empty feature tree ie 6 b constraint equivalent proof j ft constraint j well finite fclosure would entail xy variables contradicts proposition 13 j variable exists since v j finite 2 lemma 22 let h ft constraint h proof ft constraint h equivalent ft constraint j obtained h replacing equalities xy inequalities xy yx hence xy j iff yx j since algorithm f preserves invariant also holds fclosure j claim follows proposition 13 2 proposition 23 x 6 ft constraint h equivalent xy proof follows immediately lemma 22 proposition 13 2 8 completeness satisfiability test proposition 4 every fclosed constraint j satisfiable ft proof based notion path reachability covers rest sec tion proceed follows first define path reachability give two lemmas finally compose proof proposition 4 lemmas paths p constraint j define binary relation j reachable x path p j xay j meaning reached x path p j example j constraint xy ay xau xbz zax bz following reachability propositions hold j x j x j definition 24 path consistency call constraint j path consistent following two conditions hold x p b 1 x j 2 x j lemma 25 every f1f2closed path consistent constraint satisfiable proof let j f1f2closed path consistent define variable assignment trees follows ag path consistency j condition 1 implies l min j x partial function thus feature tree verify min j solution j let xy j x 0 j definition path reachability thus min j min j x j definition path reachability thus l min j l min j x ie min j ymin j x consider xay j prove p z b equivalences first equivalence equivalent min j second one l min g start proving first equivalence j ap z since xay j suppose x j ap z definition path reachability exists x 0 0 f1closedness j x j imply xx 0 j f2closedness ensures yy 0 j j holds prove second equivalence ap b exists z x j ap z bz first equivalence implies z thus j b converse simple let ax j reflexivity f11closedness implies xx j thus x j e e 2 l x let xy j show set l min j x l min j partial function j b path consistency lemma 26 every f3f4f5closed constraint path consistent proof let j f3f4f5closed condition 1 definition 24 follows condition 2 definition 24 f31closedness proof condition 2 induction paths p assume x b x j j x j e exist nm 0 x f3closedness implies x n ym j f32 yields xy 1 j therefore mx j f33closedness hence mx 1 closedness hence f5closedness implies b case exists exist x 0 0 x since xx 0 j x 0 0 j f3closedness thus f4closedness implies x j ab holds induction hypothesis 2 proof proposition 4 j fclosed j path consistent lemma 26 thus satisfiable lemma 25 2 corollary 27 let j fclosed constraint j variables x 0 0 j x 0 ay 0 j x 0 x proof assume holds minimal solution min j fclosed constraint 62 l min j hence j 6j 9yxay 2 acknowledgments would like thank jochen dorre gert smolka ralf treinen discussions topic paper would also like acknowledge many helpful remarks referees research reported paper supported esprit working group ccl ii ep 22457 sfb 378 universitt des saarlandes r complete axiomatization theory feature arity constraints complete recursive feature theory 2 nd future generation computer systems subsumption semiunification feature algebras constraint logic programming survey functional grammar applications canonical form generalized linear con straints ordering constraints feature trees ordered sorts entailment set constraints feasible inclusion constraints nonempty sets trees feature logics introduction unificationbased approaches grammar parsing type inference natural computer languages feature constraint logics unification grammars oz programming model records logic programming feature constraints firstclass features tr ctr franois pottier versatile constraintbased type inference system nordic journal computing v7 n4 p312347 winter 2000 jens palsberg tian zhao trevor jim automatic discovery covariant readonly fields acm transactions programming languages systems toplas v27 n1 p126162 january 2005 ernst althaus denys duchier alexander koller kurt mehlhorn joachim niehren sven thiel efficient graph algorithm dominance constraints journal algorithms v48 n1 p194219 august michael benedikt leonid libkin frank neven logical definability query languages ranked unranked trees acm transactions computational logic tocl v8 n2 p11es april 2007
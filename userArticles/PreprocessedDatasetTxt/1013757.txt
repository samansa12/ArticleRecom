minimization np multifunctions implicit characterizations polynomialtime computable functions fp given bellantonicook leivant suggest class complexitytheoretic analog primitive recursive functions hence natural add minimization operators characterizations investigate resulting class partial functions candidate analog partial recursive functions paper cobhams definition fp bounded recursion bellantonicooks safe recursion prove resulting classes capture exactly npmv nondeterministic polynomialtime computable partial multifunctions also consider relationship schemes notion nondeterministic recursion defined leivant show latter characterizes total functions npmv view results giving evidence npmv appropriate analog partial recursive view reinforced earlier results spreen stahl show many relationships partial recursive functions sets analogous relationships hold npmv np sets furthermore since npmv obtained fp way recursive functions obtained primitive recursive functions defined via function schemes also gives evidence fp properly seen playing role primitive recursion b introduction considering analogy arithmetic polynomialtime hierarchy standard view polynomial time plays role recursive though alwayssee eg selman 9 return polynomialtime sets used base p 0 polynomial hierarchy p dened sets polynomialtime oracle p set however view unproblematic analogy p indicates np conp identied recursive sets assumption p 6 np conp leaves polynomialtime sets viewed analogy smaller class natural choice smaller class primitive recursive sets functions backed cobhams 4 characterization fp functions computable polynomial time scheme recursion notation nothing explicitly bounded version primitive recursion formulated binary words work bellantoni cook 3 report date 24 oct 2000 leivant 6 provides primitive recursive schemes dening fp explicit bounds rather controlling primitive recursion semanticallyinspired syntactically implemented tiering notions approach characterizing complexity classes without explicit mention resources bounds typically referred implicit computational complexity however identify fp primitive recursive functions view np conp appropriate analogy recursive sets left following question correct analog partial recursive functions course expect class partial functions however machinebased view complexity classes bound lead unpleasantness seem straightforward clean way dene complexity partial functions especially becomes clear insist upon notion timebounded machines may halt inputs implicit computational complexity truly shines since characterizations make mention resources bounds natural extend existing implicit characterizations fp operators analogous classical case analyze resulting class partial functions candidate analog partial recursive functions since one passes primitive recursive functions partial recursive functions adding minimization operator composition primitive recursion obvious starting point add version minimization cobhams bellantoni cooks leivants characterizations understand version minimization use consider classical denition used partial recursive functions obtain version minimization appropriate polynomialtime functions want ensure verication fact minimum value requires search polynomial number values thus replace bounded quantier sharply bounded one denition immediately raises ag minimization longer denes partial function could several satisfying 8b 0x eg suppose 1 inputs length 3 0 inputs length 3 minimization would yield thus straightforward approach leads us consider partial multifunctions formally maps natural numbers n p n set nite subsets n retrospect unexpected partial function satises condition x x one element partial multifunction except x nitely many elements essentially unrestricted computational resources recursive functions collapsing many values one problem restrict complexity objects consideration reasonable assume cannot necessarily perform collapse eg x many elements functions must allowed many outputs another view sharply bounded quantier instead multiple output values instead choose one values leads directly idea nondeterministic choice computation fact function classes considered particular selman 9 denes class npmv consist partial multivalued functions computable nondeterministic turing machine polynomial time computed means possible output x tm accepting path input x contents output tape upon halting main results paper add minimization various primitive recursive denitions fp obtain exactly class npmv thus approach implicit computational complexity provide straightforward way generalize polynomialtime computable functions broader class ought correspond partial recursive functions fact gives resourcefree characterization previously dened class asserts play role thus justifying naturality turns single class considered plan paper follows section 2 provide basic denitions including notion bounded minimization resulting extension cobham class section 3 contains proof extension captures exactly npmv section 4 introduce resourcefree notion minimization within framework bellantoni cooks safe recursion 3 work know directly addresses issue adding minimization operator similar way bellantonis 2 adds operator singlevalued total compare approach section well section 5 consider scheme nondeterministic recursion dened leivant 6 show total functions denable scheme exactly total functions npmv hence total functions denable using safe recursion notion safe minimization finally closing section 6 mention straightforward results reinforce claim npmv correct analog partial recursive functions suggest directions study 2 definitions use lowercase roman letters b x numeric variables length number jxj dened dlog 2 1e abbreviate sequence x x k relevant binary successors binary predecessor given partial multifunction pmf alternatively viewed relation n k1 satisfying constraint x fy j hx yi 2 g nite use range pmfs total partial function identied natural way pmf assume identication whenever mention functions function classes write x 7 possible output x x z x 7 z z computation model register machine rm consists nite set states nite set registers nite set instructions following form state j holds x store 0 x 1 x j 0 change state k state j holds x store px j 0 change state k state contents j either 0 0 x change state k 0 otherwise change state k 1 let register machine states one instruction deterministic states others nondeterministic deterministic states deter ministic deterministic rm computes nary partial function storing n arguments entering state 1 executing instructions natural manner reaches state instruction halts x contents wise never halts x undened nondeterministic rms assume two distinguished states acc rej instructions enters one states said accept reject input accordingly nondeterministic rm computes pmf storing x executing instructions obvious nondeterministic fy j 0 contains accepts xg conguration list specifying state contents registers computation sequence sequence congurations n transition c c i1 assume coding register machines congurations satisfying condition e code z code computation sequence length n every register every conguration stores number length n z seqbnde n seqbnd polynomialtime computable also dene polynomialtime function result z code computation sequence resultz contents 0 last conguration z shall consistently con ate state etc corresponding codes consider following classes functions paper fp class total singlevalued functions computable deterministic rm time polynomial length input npmv class pmfs computable nondeterministic rm polynomial time pr primitive recursive functions rec partial recursive functions noted leivant 6 turing machines register machines polynomialtime reducible denitions fp npmv correspond usual ones make use following operators pmfs composition dened composition bounded recursion notation dened bounded recursion notation brn bounded weak minimization dened bounded weak minimization bwm written bounded witnessing dened bounded witnessing written definition 1 class c smallest class pmfs contains projections zero binary successors 0 1 smash function x 7 2 jxjjyj closed composition brn bwm 2 class smallest class pmfs contains projections zero binary successors 0 1 smash function x 7 2 jxjjyj closed composition brn bounded witnessing proposition 1 fp c fp proof without bwm bounded witnessing classes dened cobhams characterization fp freely make use polynomialtime computable predicates denitions func tions cases understand formally referring characteristic functions specically minimization form z xp x z mean z definition pmf polynomiallybounded polybounded polynomial p jyj pjxj proposition 2 every pmf c polybounded proof straightforward proof induction denition c proposition may assume bounding functions used bounded recursion notation bounded pseudominimization fact polynomials 3 machine characterization theorem 3 let pmf following equivalent 1 2 3 2 npmv proof 1 3 proved induction denition c initial functions c ptime computable hence npmv given inductively assume computed nondeterministic rm time p similarly pmfs suppose computed machine follows input x run x rejects also rejects otherwise accepts output z run input x z rejects rejects otherwise accepts output clearly computes runs time p n suppose x z dened bounded recursion notation 2 qjjjj q polynomial increasing arguments z x z 7 sequence zi th bit z furthermore sequence thus compute x z guess sequence 2 qjxjjzj verify condition holds element sequence running comparing output previous element sequence none verications fails accept output guessing sequence takes time verication takes jzjpjxj qjxj jzj time finally suppose compute x follows run input x rejects reject otherwise guess smaller output next verify reject verication successful run input x every jyj computations accepts output 0 reject otherwise accept output assumptions coding rms given section 2 polynomial q let x z modied kleene predicate asserts following e description nondeterministic rm n z sequence c c code conguration n c 0 initial conguration n input x c i1 conguration n reachable c one step transition relation n accepting state n note c k may repeated number times suppose nondeterministic rm code e computes pmf x computation paths length pjxj dene claim denition z codes computation sequence input x length pjxj contents 0 enters state acc hence x 7 conversely suppose x 7 denition accepting computation path code w input x length pjxj hence w seqbnde pjxj ends 0 since allow accepting state repeated number times may assume j seqbnde pjxjj w j seqbnde pjxjj w reason might x 7 could much shorter accepting computation path output dierent weak minimization operator would reject w pick shorter path instead w 0 jwj w 0 situation arise hence z seqbnde pjxjj seqbnde pjxjj z therefore x 7 proof 2 3 equivalent essentially preceding without compensate short computation sequences reverse direction corollary 4 normal form theorem every pmf x 2 c written form z application equivalence consider following intersection union operations pmfs see npmv closed operations follows computed rms respectively x computed nondeterministically choosing run one x x computed running accepting exactly accept output theorem c must also closed operations note latter fact obvious composition simple operation applied partial functions particular consider composition evaluate x intuitively must nd z 1 z 2 involves evaluating example 1 x undened entire composition undened hand intersection union operators welldened even x x dened 4 resourcefree characterization recall bellantoni cooks denition safe recursion 2 context pmfs arguments separated two types normal use x z safe b c one view distinction normal arguments used clock iterations whereas safe arguments used simply bit stores polynomial number bits examined computation 2 another view safe positions safe large input values ie one increase size arguments without signicant increase computation time 3 yet another philosophically justied view given leivant 6 views safe arguments terminology tier 0 arguments able take data somehow impredicatively dened say denition data somehow assumes totality domain function dened impredicative used tier 0 position particular function dened recurrence denition makes sense g dened matter third argument isin words denition assumes totality f hence domain denition argument must tier 0 use semicolon delimit normal safe arguments x takes single normal argument x single safe argument consider following operations pmfs x mod 2 value loworder bit x safe composition dened safe composition z 7 safe recursion notation dened safe recursion notation srn 7 9ux z 7 safe weak minimization dened safe weak minimization swm written mod 2 7 1 write x c mod 2 7 0 z x c 7 z z mod usual notion pmf composition zz mod 2 would natural say dened safe witnessing x 7 c x c mod 2 7 0 minimization bounding requirements would lead pmfs innite number outputs xed input eg constantly 0 consider scheme mentioned introduction bellantoni 2 denes minimization scheme bfx least b fx b mod b exists 0 otherwise 1 note f total bfx b mod bellantoni add scheme characterization fp base functions plus safe composition safe recursion notation dene new class total functions proves natural denition applications actually b bellantonis minimization outputs s1b minimization functions denable i1 applications minimization exactly computable polynomial time p oracle also shows characterization holds bounded version total minimization scheme notion safety furthermore note add unbounded total minimization operator primitive recursion easy show functions denable applications exactly recursive proof one simply remove bounds bellantonis proof bounded version thus total minimization operator bounded safe behaves manner exactly analogous corresponding operator recursive functions however exactly reason capture appropriate minimization analogous generating partial recursive functions aim paper show safe weak minimization appropriate operator goal following set functions 1 constant 0 nullary function 2 projections nm 3 binary successors 0 4 predecessor pred 5 conditional cond b c mod definition class c safe smallest class pmfs containing b 0 closed safe composition srn swm class c nml safe consists functions c safe normal arguments following denition lemma proposition taken essentially 2 proofs taken almost verbatim taken together formalize intuition pmf polynomial q jwj bits output x depend bits safe arguments first dene jxj rightmost bits bellantoni gives denition mod x x safe normal 2 definition let x pmf note separate arguments normal safe let q polynomial 1 polychecking x threshold q w v satisfying jvj qx jwj x mod v 7 mod w x 7 mod w 2 pmf x polymax bounded x q x x dened maxfjajg lemma 5 let x b pmf polychecking x threshold q x x b mod 2 7 0 jb proposition 6 x 2 c safe polychecking polymax bounded x proof induction denition c safe theorem 7 let pmf safe proof proof 2 npmv implies 2 c nml safe follows lines proof thm 3 2 npmv 2 c must dene version kleene predicate using safe recursion notation allows us extract accepting computation sequences nondeterministic rm main idea use srn dene functions fx examine bits return value words normal arguments used clocks examine safe values used bit stores mind dene characteristic functions following predicates machm e jmj loworder bits e code description nondeterministic rm given coding machm e actually examines pjmj bits e xed polynomial p detail specify point onward cfgn e c machjej e jnj loworder bits c code conguration rm described e transition c 1 c 2 according description e csn e z machjej e jtj loworder bits z code sequence congurations c rm transn rst conguration z initial conguration rm described e input x last conguration accepting state suppose 2 c thm 3 computed nondeterministic rm code e time bounded polynomial pn since pn tape cells accessed computation input length n every conguration coded string whose length also polynomial n say qn furthermore code computation sequence length n seqbnd e n take seqbnd e arguing thm 3 dene safe reverse direction one proves induction x 2 c safe 2 c using polymax bound given prop 6 cases real interest dened safe recursion notation safe weak minimization dened srn recursion notation denes c furthermore polymax bounded q x x x dened x 2 qjxj since bound polynomialtime computable recursion notation bounded function denable c suppose x b x polymax bounded q x induction hypothesis denable c x 0 denition valid suces note function zz mod 2 polynomialtime therefore denable c 5 nondeterministic recursion 6 x5 leivant discusses notion nondeterministic recursion safe ramied variant say fx z dened nite set multifunctions nondeterministic safe recursion 7 9g 2 gx 7 7 9g 2 9ufx z 7 words step computation fx z allowed choose dierent recursion function note consists total multifunctions f also total multifunction let e smallest class total multifunctions containing b 0 closed safe composition nondeterministic safe recursion e nml consists functions e normal arguments section prove e nml consists exactly total multifunctions npmv 2 lemma 8 fx 2 e f polymax bounded x 2 technical subtlety leivants proof sketch result carry proof proved induction denition f essentially proof functions dened safe recursion minimization polymax bounded theorem 9 let f total multifunction f proof forward direction prove induction fx 2 e fx 2 c therefore f 2 npmv thm 3 essentially proof forward direction thm 7 course case needs consideration f dened nondeterministic safe recursion say multifunctions 0 used compute fx 0 multifunctions 1 used compute fx z dene f c union operator dened cor 4 recall dened nondeterministic safe recursion nite sets 0 1 nite polymax bound f given lemma 8 gives ptime computable bound recursion recursion dened c reverse direction suppose f computed nondeterministic rm runs time qn uses states registers simplicity assume f unary assume nondeterministic state exactly two corresponding instructions dene new register machine n behave similarly dierence n rst guess nondeterministic choices behave deterministically referring original guesses whenever encounters nondeterministic state formally dene n follows 1 n uses registers new states a0 0 every nondeterministic state 2 initial state n nondeterministically constructs m1 length qj using states 3 otherwise n exactly except every nondeterministic state instructions 0 1 replace instructions following tm1 a0 a0 pm1m1 0 thus n enters state transitions state ai corresponds loworder bit contents m1 deletes bit executes either rst second instruction would execute state note nondeterministic instructions start one states n also computes fx executing exactly qjx steps change contents m1 acting deterministically simulate n using nondeterministic safe recursion 1 dene transition functions j 6 dene states accurately denition states irrelevant gives contents j th register transition state code one possibility 1 gives next state j dened use conditionals successors predecessors hence take safe arguments 2 dene functions j simultaneous safe recursion j contents 0 executing jy 1 j jy steps starting state register see 6 details leivant also shows simultaneous safe recursion reducible safe recursion without loss generality assume use latter 3 dene function guessz using nondeterministic safe recursion words guess dened set functions containing constant 0 1 functions 0 1 6 qn n k qn running time f represented e nml examining proof thm 9 actually proved f 2 e nml f dened c using schemes composition bounded recursion notation along operator let c 0 smallest class total multifunctions containing base functions c closed composition brn proved theorem f total multifunction f 2 c 6 analogy npmv partial recursive functions close returning theme introduction proper analog partial recursive functions class npmv recall pr rec primitive recursive partial recursive functions respectively made argument fp proper analog pr given two dened terms essentially function schemes one bounded safe previous sections seen npmv arises straightforward bounded safe minimization operator added schemes partial recursive functions arise unbounded minimization operator added pr section consider properties rec analogs npmv specically consider relationship rec recursively enumerable sets show mostly relationships hold npmv np sets conclude introducing new hierarchy obtain applying analogy view levels arithmetic hierarchy ranges partial functions also discuss generalization npmv higher type computability pmf dene yg graph say polybounded polynomial q hx yi lemma 11 let partial function 2 npmv 2 np polybounded particular characteristic function set 2 npmv 2 np proof 2 npmv computed register machine verify run x accept accepts outputs since runs polynomial time must polybounded reverse direction suppose x 7 polybounded q compute x follows first guess 2 qjxj guess accept output otherwise reject lemma 12 set characteristic function 2 np 2 np conp proof suppose 2 np say suppose 2 np conp r ptime predicates proposition 13 set 2 npmv 2 np conp compare 2 rec proof rst equivalence follows thm 3 second follows lemmas 11 12 proposition 14 set 2 np 2 npmv compare 2 rec dom proof suppose x 2 9y 2 pjxj rx dene 2 npmv follows input x guess 2 pjxj rx holds accept output reject clearly dom suppose 2 npmv since polybounded x 2 dom 9y x 7 np predicate lemma 11 interestingly seem able identify np ranges honest pmfs npmv following balcazar iaz gabarro 1 def 310 pmf honest polynomial q whenever x 7 z jz j qjyj z 7 proposition 15 set 2 np honest 2 npmv ran proof forward direction use pmf prop 14 reverse direction suppose 2 npmv honest matrix predicate np lemma 11 however honesty condition applies expressing np ranges fp functions rosser showed analogous result holds primitive recursive functions albeit without honesty condition proposition set 1 1 exercise 392 2 np honest f 2 fp ran f 2 7 primitive recursive f ran f finally close two suggestions study first one view arithmetic hierarchy following way refer syntax formal language recursive 2 g npmv right analogy partial recursive following ought interesting hierarchy study second notion oracle computation total singlevalued oracle g straightforward one corresponds adding g base function class c one considers oracle computation focuses functions natural oracles pmfs leading notions highertype computability two dierent denitions computing relative pmf oracle 5 8 neither obviously comparable adding oracles base pmfs c denitions totalize oracle order always return value obviously makes dierence oracle characteristic function whereas would unnatural approach adding base pmfs c properly developing notion highertype computability along lines may help clarify dicult issues highertype feasibility providing appropriate universe consider highertype complexity r predicative recursion polytime hierarchy new recursiontheoretic characterization polytime functions intrinsic computational di oracles compute values extensions theorems g taxonomy complexity classes functions much ado functions tr power singlevalued nondeterministic polynomial time computations new recursiontheoretic characterization polytime functions functions computable nondeterministic polynomial time much ado functions
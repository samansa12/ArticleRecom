computing givens rotations reliably efficiently consider efficient accurate computation givens rotations f g positive real numbers simply amounts computing values apparently trivial computation merits closer consideration following three reasons first definitions c r seem obvious case two nonnegative arguments f g enough freedom choice one f g negative zero complex lapack auxiliary routines slartg clartg slargv clargv compute rather different values c r mathematically identical values f g eliminate unnecessary ambiguity blas technical forum chose single consistent definition givens rotations justify second computing accurate values c r efficiently possible reliably despite overunderflow surprisingly complicated complex givens rotations efficient formulas require one real square root one real divide well several much cheaper additions multiplications reliable implementation using working precision number cases sun ultra10 new implementation slightly faster previous lapack implementation common case 27 46 times faster corresponding vendor reference atlas routines also reliable previous codes occasionally suffer large inaccuracies due overunderflow real givens rotations also improvements speed accuracy though striking third design process led reliable implementation quite systematic could applied design similarly reliable subroutines b introduction givens rotations widely used numerical linear algebra given f g givens rotation 2by2 unitary matrix rc c fact rc unitary implies c c computer science division university california berkeley ca 94720 dbindelcsberkeleyedu material based upon work supported national science foundation graduate research fellowship computer science division mathematics dept university california berkeley ca 94720 demmelcsberkeleyedu material based part upon work supported advanced research projects agency contract daah049510077 via subcontract ora446602 university tennessee department energy grant defg0394er25219 contract w31109eng38 via subcontract nos 20552402 941322401 argonne national laboratory national science foundation grants asc9313958 asc9813361 nsf infrastructure grant nos cda8722788 cda9401156 computer science division mathematics dept university california berkeley ca 94720 wkahancsberkeleyedu nersc lawrence berkeley national lab osninerscgov see real 2 f g real positive widely accepted convention let however negatives c r also satisfy conditions 1 2 satisfying 2 also satisfy 1 c r determined uniquely slight ambiguity led surprising diversity inconsistent definitions literature software example routines slartg clartg slargv clargv level 1 blas routines srotg crotg 6 well algorithm 515 5 get significantly dierent answers mathematically identical inputs avoid unnecessary diversity blas basic linear algebra subroutines technical forum design new blas standard 3 chose pick single definition givens rotations section 2 presents justifies design blas technical forum also providing reference implementations new standard case computing givens rotation kernel routines intermediate overunderflows straightforward implementations make output inaccurate stop execution even cause infinite loop attempting scale data desired range even though true mathematical answer might unexceptional compute c r eciently possible reliably despite overunderflow surprisingly complicated particularly complex f g square root division far expensive real floating point operations current machines easy see one real square root one real division perhaps single reciprocalsquare root operation necessary compute c r little algebraic manipulation also show single square root division also sucient along several much cheaper additions multiplications compute c r complex case contrast algorithm crotg routine fortran reference blas uses least 5 square roots 9 divisions perhaps 13 divisions depending implementation complex absolute value function cabs however formulas c r use one square root one division susceptible overunderflow must store intermediate results precision f g define systematically identify values f g formulas reliable ie guaranteed underflow way unnecessarily loses relative precision overflow generating set simultaneous linear inequalities log f log g define polygonal region safe log f log g space formulas may used common situation call case 1 algorithm case new algorithm runs 25 faster lapacks clartg routine nearly 4 times faster crotg routine vendor blas sun ultra10 atlas blas fortran reference blas log f log g lies outside two possibilities scaling f g constant fit inside using dierent formulas scaling may interpreted geometrically shifting parallel diagonal line log log g log f log g space region covered shifted images ss shadow region scaling possible part shadow case 4 algorithm scale f g lie inside use previous formula remaining region log f log g space including space outside ss shadow consists regions log f log g dier much f 2 rounds either f 2 case 2 algorithm case 3 replacing f 2 either f 2 g 2 simplifies algorithm dierent formulas used addition 4 cases 2 simpler ones f andor g zero three dierent ways deal multiple cases first way tests branches depending f g appropriate formula used portable method using working precision precision inputoutput arguments one explored detail paper second method use exception handling ie assume f g fall common case case 1 use corresponding formula floating point exception raised overflow underflow invalid alternative formula used 4 suciently fast exception handling available method may fastest third method assumes floating point format wider exponent range available store intermediate results case may use main new formula case 1 without fear overunderflow greatly simplifying algorithm cases f andor g zero remain example ieee double precision 11bit exponent used inputs f g ieee single precision numbers 8bit exponents sun ultra10 mixedprecision algorithm nearly exactly fast case 1 single precision algorithm described usually rather faster cases 2 4 intel machine double extended floating point 15bit exponents used single double precision inputs would algorithm choice however double precision inputs machine like sun ultra10 without doubleextended arithmetic double precision much slower single precision new algorithm 4 cases best know addition new algorithm significantly faster previous routines accurate earlier routines inputs exhibit large relative errors whereas always nearly fully accurate rest paper organized follows section 2 presents justifies proposed definition givens rotations section 3 details dierences proposed definition existing lapack level 1 blas code section 4 describes assumptions floating point arithmetic section 5 presents algorithm complex case simple cases presents algorithm common complex case assuming neither overflow underflow occur case 1 section 7 shows alternate formulas complex givens rotations f g dier greatly magnitude cases 2 3 section 8 describes scaling f g comparable magnitude large small case 4 section 9 compares accuracy new complex givens routine several alternatives accurate cases section 10 discusses performance complex givens routine sections 11 12 13 discuss algorithms accuracy timing real givens rotations rather easier section 14 draws conclusions actual software included appendix givens rotations use following function defined complex variable x follows signx clearly continuous function away x 0 x real definition simplies stated introduction need extra requirements besides 1 2 order determine c hence r uniquely least one f g nonzero deduce first component rc sf g 1 real fact c must real deduce f 0 stated chosen arbitrarily long satisfy 2 extra requirements initially chosen blas technical forum help resolve choice sign 3 4 follows definitions real complex data consistent real data passed complex algorithm result answers modulo roundo real algorithm current lapack subroutines use givens rotations continue work correctly new definition current lapack subroutines slartg clartg compute single real complex givens rotation resp satisfy requirement 1 furthermore lapack subroutines slargv clargv computing multiple givens rotations compute answers slartg clartg resp dierences described section 3 change practice needed consistent definitions indeed original motivation blas technical forum simply adopting lapack definitions unchanged however immediately resolve choice sign 1 proceed add requirement r3 mapping f g c r continuous whenever possible continuity c functions f g possible everywhere real f g approach 0 along real line sin c must discontinuous 0 0 consider c r functions f increases 0 2 ie f traverses unit circle complex plane consider common convention c increases remains equal 1 since c real continuity implies c stays fixed hence continuous desired thus requirement r3 implies c must nonnegative together 3 implies f 0 obviously define f g r continuously away simplify attractive r1 0 identity matrix using multiply arbitrary pair vectors requires work light requirement r3 since c continuous signf change arbitrarily small complex neighborhood 0 cannot hope define continuity argument includes complex f instead ask c r continuous functions real f 0 complex g 0 ie continuous f approaches zero right limit easily seen take definition finally consider case impossible define continuity since f g approach 0 direction instead add requirement r4 given choice c choose requiring least work rc typically used multiply pair vectors r1 requires work set summary algorithm complex real f g follows algorithm 1 computing givens rotations includes case must nonzero else f g nonzero endif f g real algorithm slightly simplified replacing g g 21 exceptional cases algorithm run ieee floating point arithmetic 2 possible inputs might nans notanumber symbols section discuss values c r cases insist routine must terminate return output values cases say complex number nan least one real imaginary parts nan say complex number infinite least one real imaginary parts infinite neither nan first suppose least one nan occurs input semantics nan binary unary arithmetic operation nan returns nan extension routine ought return nans well see definition necessarily since implementation might reasonably still return since require arithmetic operations compute rather specify exactly happen input nan insist least r nan perhaps c well implementors discretion permit discretion nans hopefully rare computations insisting testing case might slow code much common cases illustrate challenges correct portable coding nans consider computing maxa b need compute f g max implemented hardware software b else b max0 nan returns nan maxnan returns 0 hand equally reasonable implementation b b else instead returns 0 nan respectively thus implementation might mistakenly decide missing nan g model implementation work implementation max next suppose least one occurs input nans case reasonable return limiting values definition exist nans otherwise example one might return since cannot welldefined r g one could simply return nans even limit existed example returning avoid overspecifying rare cases thereby possibly slowing common cases leave implementors discretion approach take insist least r either infinite nan assiduous reader noted algorithm 1 leaves ambiguous sign zero treated includes 0 0 dierent implementations free return 0 0 whenever zero delivered seems little gained insisting example would actually computed r1 0 multiplied vector 3 dierences current lapack blas codes short summary dierences algorithm 1 algorithms lapack 30 1 earlier versions level 1 blas 6 lapack algorithms question slartg clartg slargv clargv level 1 blas routines srotg crotg lapack release 30 test code passed well new givens rotations old ones indeed one test failure old code disappeared new rotations new definition givens rotations satisfies requirement r2 returns comment slartg saving work mean lapack bidiagonal svd routine g nonzero slartg returns negatives values c r returned algorithm 1 algorithm 1 mathematically identical clartg numerically identical see section 9 returns returns returns returns g 0 clargv returns r g quantity z one reconstruct c otherwise besides dierence r assigned sign g long either f g nonzero rather sign f 1 compute quantity like z crotg sets g nonzero matches algorithm 1 mathematically numerically assumptions floating point arithmetic lapack routines slamch dlamch available return various machine constants need particular assume machine epsilon available power machine radix machines ieee floating point arithmetic 2 either 2 24 single 2 53 double also use safmin intended smallest normalized power radix whose reciprocal computed without overflow ieee machines underflow threshold 2 126 single 2 1022 double however machines complex division implemented compiler fastest risky algorithm exponent range eectively halved since c 2 even though true quotient near 1 machines safmin may set safmin indicate result scaling algorithms make assumptions proximity safmin actual underflow threshold indeed tiny value rather less lead correct code though closer safmin underflow threshold fewer scaling steps needed extreme cases algorithms also work correctly accurately whether underflow gradual important processors default fast mode replaces underflowed quantities zero means eective underflow threshold safmin since underflow x cause relative error safminx roundo scaling algorithms use quantity z safmin 14 rounded nearest power radix thus use z eective underflow threshold z overflow threshold note may safely add subtract many quantities bounded magnitude z 4 without incurring overflow repeat algorithms work correctly slowly conservative estimate safmin used ie one large powers z used software computed first call saved reused later calls values z powers ieee machines safmin equal underflow threshold follows single precision double precision z z inputs include nan assume semantics ieee arithmetic 2 used later discussion denote actual overflow threshold ov underflow threshold un smallest positive number 2un machine gradual underflow un otherwise 5 complex algorithm follows use convention capitalizing variable names c r data computed f g use notation ref imf mean real imaginary parts f w maxre w im w complex number w begin eliminating easy cases least one f g zero variables f g r complex rest real algorithm 2 computing givens rotations includes case else g must nonzero scale g powers z 4 z 2 g z 2 unscale r powers z 4 else f g nonzero use algorithm described endif note even though easy case need scale g avoid overunderflow computing reg2img2 51 exceptional cases discuss exception handling noticeably speeds code implement tests g0 f0 precomputing used later testing whether sg0 sf0 described section 21 either tests might succeed even though real imaginary part f g nan therefore logic algorithm must change slightly shown algorithm 2e computing givens rotations exception handling includes case case g nan make sure r else g must nonzero scale g powers z 4 z 2 g z 2 limit number scaling steps case g infinite nan unscale r powers z 4 case f nan make sure r else f g nonzero use algorithm described endif test scaleg0 succeed one part g 0 nan must return instead r f make sure input nan propagates output r note outputs c1 s0 even nans infinities input similarly branch taken g nan infinity means loop scale g scaleg range might terminate written without upper bound maximum number steps take maximum essentially maxlog z ovlog z timing depends strongly implementation details scaling use unrolling loop structure etc algorithm used could probably improved tuning particular compiler architecture c always zero nan g either infinite nan r infinite precisely g infinite 6 complex algorithm f g nonzero assume f g nonzero compute c r following code fragment employs one division one square root last column shows algebraically exact quantity computed line code assume realcomplex multiplications performed two real multiplications fortran implementation explicitly rather relying compiler variables f g r complex rest real algorithm 3 fast complex givens rotations f g well scaled 1 f2 ref2 2 g2 reg2 3 fg2 f2 4 5 c f2d1 f f 2 7 r 8 fd1 f f f 2 g 2 9 conjgs f f recall z safmin 14 z 4 eective overflow threshold z 4 eective underflow threshold region algorithm run reliably described following inequalities numbered correspond lines algorithm logarithms base 2 1 assume f z 2 prevent overflow computation f2 2 assume g z 2 prevent overflow computation g2 3 line safe given previous assumptions 4a assume z 2 f prevent underflow f2 consequent division zero computation d1 4b assume f z prevent overflow f 4 term f2fg2 computation d1 4c assume fg z 2 prevent overflow f 2 g 2 term f2fg2 computation d1 either 4d z 4e z 2 fg prevent underflow f2fg2 consequent division zero computation d1 5 line safe given previous assumptions c underflows deserved 6 gf z 4 prevent overflow fg2 since 1 gf large 7 line safe given previous assumptions returning r roughly z 1 z 2 smaller component r underflows deserved un log f log z log g log z un 4b 4a 4c 4d 4e figure 1 inequalities describing region unnecessary overunderflow un ov overunderflow thresholds smallest representable positive number 8 line safe given previous assumptions returning roughly z 2 1 smaller component may underflow error small compared component 9 line safe given previous assumptions underflows deserved note inequalities list describe half planes log f log g space example inequality 6 becomes log g log f 4 log z region described inequalities shown figure 1 inequality described thin line marked arrows indicating side inequality holds heavy line borders safe region satisfying inequalities algorithm safely used remains say decide whether point lies boundary complicated time test membership nontrivial accordingly use simplest tests likely succeed first use expensive tests particular easiest tests threshold comparisons f g test membership subset labeled 1 figure 2 following algorithm f z f z 1 g z f g region 1 endif called case 1 software region 1 contains data f g terribly far 1 magnitude z single z double expect arguments especially double complement region 1 shown bounded dashed lines figure 2 harder test boundaries require threshold tests product fg could overflow test membership region explicitly case something else instead 61 exceptional cases consider consequence nans infinities easy see either f g infinite test membership region 1 cannot succeed suces consider nans test like ab evaluates false either b nan case 1 occurs nan inputs f g nans occur described section 21 examining algorithm 3 see nan f g leads fg2 c r nans 7 complex algorithm f g dier greatly magnitude g 2 rounds f 2 formulas c r may greatly simplified accurately approximated f f 2 region closely approximated regions g 12 f marked 2 figure 2 called case 2 software instead f 2 rounds g 2 formulas c r may greatly simplified accurately approximated g f g g f g f g region closely approximated region f 12 g marked 3 figure 2 called case 3 software important dierence formulas 7 8 versus formula 5 7 8 independently homogeneous f g words scale f g independently instead scalar order evaluate safely thus shadow region formulas safe covers f g pairs contrast formula 5 f g must scaled value algorithms implementing 7 8 without scaling note 7 even require square root algorithm 4 computing complex givens rotations gf using formulas 7 without scaling gf endif algorithm 5 computing complex givens rotations fg using formulas 8 without scaling fg endif may apply analysis last section formulas deducing linear inequalities log f log g must satisfied order guarantee safe accurate execution simply summarize results cases get regions boundaries like sets line segments may vertical horizontal diagonal wish restrict tests f g alone rather product might overflow means identify smaller safe region like region 1 within figure 2 membership easily tested safe region algorithm 4 set satisfying z 2 f z 2 z 2 g z 2 safe region algorithm 5 smaller set satisfying z leads following algorithms incorporate scaling algorithm computing complex givens rotations gf using formulas 7 scaling gf scale f powers z 4 z 2 f z 2 scale g powers z 4 z 2 g z 2 unscale powers z 4 undo scaling f g algorithm 7 computing complex givens rotations fg using formulas 8 scaling fg scale f powers z 2 z 1 f z scale g powers z 2 z 1 g z unscale c r powers z 2 undo scaling f g endif note algorithm 7 value uneected independent scaling f g 71 exceptional cases first consider case 2 ie algorithm 6 possible either f g nans since f g may neither nan f infinite since test gf gf care must taken assure termination scaling f g even nans infinite case 2 c1 independently whether inputs infinite nans nan either f g nan infinite simply get rf r nan infinite precisely f nan infinite words r might nan g model implementation ensure r nan either f g nan instead computing computing next consider case 3 ie algorithm 7 analogous comments possible values inputs apply care must taken assure termination scaling case 3 either input nan three outputs nans g infinite f finite r nans 8 complex algorithm scaling regions 4a 4b point f g lie regions 1 2 3 figure 2 use following algorithm 1 scale f g point scale f scale g lie 2 apply algorithm 3 scale f scale g yielding c r 3 unscale get rscale scaling figure 2 corresponds shifting f g parallel diagonal line log scale lies geometrically apparent set points scalable regions 4a 4bof figure 2 lie set diagonal translates ie shadow scaled lie indeed points region 2 many points region 3 scaled lie regions 2 3 cheaper formulas discussed last section available first suppose f g lies region 4a let scale f g z 2 eventually f g lie union two arrowshaped regions a1 a2 figure 3 still exceeds z ie f g a1 multiply f g z putting a2 thus guarantee scaled f g a2 safe use algorithm 3 next suppose f g lies region 4b let scale f g z 2 eventually f g like union two parallelograms b1 b2 figure 4 still less z 1 ie f g b1 multiply f g z putting b2 thus guarantee scaled f g b2 safe use algorithm 3 considerations lead following algorithm algorithm 8 computing complex givens rotations f g region 4a 4b scaling code executed f g region 4a 4b scale f g powers z 2 maxfg z 2 maxfg z scale f g z else scale f g powers z 2 f z 2 f z 1 scale f g z endif compute givens rotation using algorithm 3 undo scaling r caused scaling f g call overall algorithm new clartg distinguish old clartg part release entire source code included appendix contains 248 noncomment lines opposed 20 reference crotg implementation 81 exceptional cases either input may nan may simultaneously infinite cases three outputs nans care must taken scaling 9 accuracy results complex givens rotations algorithm run values f g real imaginary part f g independently took 46 dierent values ranging 0 overflow threshold intermediate values chosen threshold values determining edges corners figures 1 4 thus barely satisfying satisfying possible branches algorithm correct answer inputs computed using straightforward implementation algorithm 1 using double precision arithmetic overflow underflow possible arguments tested maximum errors r c computed follows r computed single using new algorithm r computed straightforwardly double precision subscripted c variables analogous meanings absence gradual underflow error metric finitely representable r gradual underflow maximum taken nonzero test cases true r overflow subset mathematical definitions c r used clartg crotg agree note safmin 2 smallest denormalized number analogous metrics computed c routines first tested sun ultra10 using f77 fast o5 flags means gradual underflow used ie results less safmin replaced 0 therefore expect measure 11 un log g log z log f log z 1 2 3 4a 4b figure 2 cases code f 0 g 0 un log g log z log f log z figure 3 scaling f g region 4a un log g log z log f log z figure 4 scaling f g region 4b least 1 hopefully little bigger 1 meaning error r r either machine epsilon times true result small multiple underflow threshold inherent uncertainty arithmetic routines also tested without optimization flags means gradual underflow used expect stringent measure 12 close 1 results follows gradual underflow routine max error r max error max error c old clartg 70588 70588 70292 reference crotg nan nan nan modified reference crotg 359 341 322 atlas crotg nan nan nan limited atlas crotg 288 vendor crotg nan nan nan limited vendor crotg 359 gradual underflow routine max error r max error max error c old clartg 460 427 4913930 reference crotg nan nan nan modified reference crotg old clartg fails accurate first consider situation without gradual underflow g z 2 f algorithm decide scaling unnecessary result f 2 may nonnegligible relative error underflow creates nonnegligible relative error r c consider situation gradual underflow error occur dierent one occurs 1 g f f denormalized algorithm scale result f suers large loss relative accuracy rounded nearest denormalized number c f g large loss accuracy reference blas crotg fail even though tries scale avoid overunderflow scale factor f computed internally overflow even consider situation without gradual underflow sine computed f multiplication done first three quantities parentheses quite accurate entries ff less one causing multiplication underflow 0 true exceeds 4 repaired inserting parentheses f division done first excluding cases f inserting parentheses get errors line modified reference crotg consider situation gradual underflow rounding intermediate quantities nearest denormalized number cause large relative errors c equaling 1 instead 1 2 atlas vendor version crotg run full optimizations suggested authors means gradual underflow enabled also return nans large arguments even true answer representable modify routines instead ran limited subset examples f g less overflow still occasionally large errors underflow causing large relative errors even true value quite large summary systematic procedure produced provably reliable implementation whereas errors previous implementations yield inaccurate results without warning fail unnecessarily due overflow latter occurs true r close overflow hard complain much former problem deserves corrected timing results complex givens rotations complex givens rotations compared new algorithm described old clartg lapack crotg reference blas timings done sun ultra10 using f77 compiler optimization flags fast o5 routine called times arguments throughout f g plane see figure 2 average time taken argument f g range timings f g typically percent 29 cases tried exercising paths new clartg code input data shown table note timing results optimized code entirely predictable source code example small changes way scaling implemented make large dierences timings proper behavior presence infinity nan inputs issue finite termination propagating infinities nans ot output scaling parts code could simplified probably accelerated timing results figures 5 6 six algorithms compared 1 new clartg algorithm presented report using tests branches select correct case 2 old clartg algorithm lapack 30 3 ref crotg reference blas 4 atlas crotg atlas blas 5 vendor crotg suns vendor blas 6 simplied new clartg double precision see figure 5 shows absolute times microseconds figure 6 shows times relative new clartg vertical tick marks delimit cases code described table common case case 1 left plots see new clartg 25 faster old clartg nearly 4 times faster version crotg get absolute speed limit also ran version algorithm works case 1 ie omits tests scaling f g simply applies algorithm appropriate case 1 ultimate version ran 243 microseconds 68 time new clartg price reliability alternatively system fast exception handling one could run algorithm check underflow overflow divisionbyzero exception occurred recompute rare case 4 experiment performed doug priest 7 report results sun enterprise 450 server 296 mhz clock exception handling used 1 save clear floating point exceptions entry clartg 2 run case 1 without argument checking 3 check exception flags see divisionbyzero overflow underflow invalid operations occurred 4 use cases exceptions 5 restore exception flag exit way arguments falling common usual case 1 run 25 faster new clartg priest notes essential use inline assembler access exception flags rather library routines ieee flags take 150 cycles description algorithm called simplified new clartg double precision avoids need scale fastest overall architecture ieee single precision inputs testing cases use algorithm 3 ieee double precision three extra exponent bits eliminate overunderflow machine algorithm takes 365 microseconds nonzero inputs f g nearly exactly case 1 entirely single algorithm attractive single precision machine since fast much simpler course would work input data double since wider format available architecture input data timing complex givens rotations case case code f g 22 26 28 case microseconds time compute complex givens rotations old clartg atlas vendor reference double figure 5 time compute complex givens rotations computing real givens rotations f g nonzero following algorithm minimizes amount work algorithm 9 real givens rotations f g nonzero without scaling endif may apply kind analysis applied algorithm 3 summarize results 1535time compute complex givens rotations relative new clartg case time time new old clartg atlas vendor reference double figure relative time compute complex givens rotations algorithm 10 real givens rotations f g nonzero scaling scale z 2 scale f g scale powers z 2 scale z 2 elseif scale z 2 scale f g scale powers z 2 scale z 2 endif endif unscale r necessary algorithm one division one square root contrast srotg routine fortran reference blas 1 square root 4 divisions compute quantities contains 95 noncom ment lines code opposed 22 lines reference blas srotg 20 lines excluding 2 described contained appendix 12 accuracy results real givens rotations accuracy variety routines measured way entirely analogous way described section 9 results shown tables first consider results absence gradual underflow three versions srotg use scale factor f g overflow even r eliminating extreme values f g tests yields results lines labeled limited gradual underflow letting f g equal smallest positive denormalized number yields instead 1 2 large relative error best machine approximation true result 2m divided get c respectively slightly larger f g yield slightly smaller still quite large relative errors c gradual underflow routine max error r max error max error c old slartg 145 181 181 reference srotg nan nan nan limited reference srotg 151 195 195 atlas srotg nan nan nan limited atlas srotg 168 155 155 vendor srotg nan nan nan limited vendor srotg 168 155 155 gradual underflow routine max error r max error max error c old slartg 145 181 181 reference srotg nan nan nan limited reference srotg 151 timing results real givens rotations six routines compute real givens rotations tested way entirely analogous manner described section 10 test arguments timing results shown table figures three versions srotg reference atlas suns vendor version originally computed c r compute single scalar z one reconstruct c defined f g 1c f g c 0 three cases distinguished examining value z c reconstructed permits example qr factors matrix overwrite givens rotations used compute q case householder transformations capability used lapack neither version slartg computes z make timing comparisons fairer therefore removed two lines code computing z reference srotg timing tests however modify atlas sun performance library anyway routines work necessary input data timing real givens rotations case f g case microseconds time compute real givens rotations old slartg atlas vendor reference double figure 7 time compute real givens rotations see figures 7 8 common case case 1 scaling needed new slartg 18 faster old slartg 135 262 times faster version srotg get absolute speed limit also ran version algorithm works case 1 ie omits tests scaling f g simply applies algorithm appropriate data large small ultimate version ran 161 microseconds 72 time new slartg price reliability experiments doug priest using exception handling avoid branching showed 8 improvement common case scaling needed finally double precision version slartg simply tests cases runs algorithm 9 double precision without scaling nearly fast new slartg common case scaling needed faster scaling needed 14 conclusions justified specification givens rotations put forth recent blas technical forum stan dard shown implement new specification way faster previous implementations reliable used systematic design process kernels could used whenever accuracy reliability overunderflow eciency simultaneously desired side eect approach algorithms much longer must implemented precision arguments fast arithmetic wider range available avoid overunderflow algorithm becomes simple reliable least fast time compute real givens rotations relative new slartg case time time new old slartg atlas vendor reference double figure 8 relative time compute real givens rotations r faster numerical algorithms via exception handling matrix computations basic linear algebra subprograms fortran usage private communication tr algebraic eigenvalue problem implementing complex elementary functions using exception handling matrix computations 3rd ed applied numerical linear algebra implementing complex arcsine arccosine functions using exception handling basic linear algebra subprograms fortran usage faster numerical algorithms via exception handling performance improvements lapack cray scientificlibrary ctr luca gemignani unitary hessenberg qrbased algorithm via semiseparable matrices journal computational applied mathematics v184 n2 p505517 15 december 2005 milo ercegovac jeanmichel muller complex square root operand prescaling journal vlsi signal processing systems v49 n1 p1930 october 2007 frayss luc giraud serge gratton julien langou algorithm 842 set gmres routines real complex arithmetics high performance computers acm transactions mathematical software toms v31 n2 p228238 june 2005
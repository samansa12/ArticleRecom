implementing failsilent nodes distributed systems abstracta failsilent node selfchecking node either functions correctly stops functioning internal failure detected node constructed number conventional processors softwareimplemented failsilent node nonfaulty processors node need execute message order comparison protocols keep step check respectively paper design implementation efficient protocols two processor failsilent node described detail performance figures obtained indicate wide class applications requiring high degree faulttolerance softwareimplemented failsilent nodes constructed simply utilizing standard offtheshelf components attractive alternative hardwareimplemented counterparts require specialpurpose hardware components faulttolerant clocks comparator bus interface circuits b introduction replicated processing distinct processors whereby outputs faulty processors prevented appearing application level employing means comparing voting outputs produced processors provides practical means constructing systems capable tolerating byzantine also referred failuncontrolled processor failures approach used constructing failcontrolled node composed number conventional processors application level processes replicated particular case failcontrolled node p1 processor failsilent node either works correctly stops functioning becomes silent soon internal failure detected behaviour node guaranteed long p processors node fail two processor failsilent node p1 offers practical economical solution problem constructing failcontrolled nodes paper concentrate design implementation performance evaluation twoprocessor nodes particular describe practical designs software implemented twoprocessor failsilent nodes suitable use distributed systems meet abstraction failsilence following sense node produces either correct messages verified destination nodes ceases produce new correct messages case destination nodes detect messages may produce unwanted paper structured follows begin reviewing related work area reliable node design contrasting approach summarising main contributions paper describe basic principles underpin failsilent nodes present term reference implementation failsilent node implementation makes use standard synchronised clock based message order protocol describing performance protocol improved present two new much faster order protocols based logical clock leaderfollower masterslave approaches following describe design comparison protocol makes use masterslave approach message comparison present results obtained experimental work comparative performance evaluation various implementations failsilent nodes conclusions work presented final section paper 2 related work failcontrolled node uses replicated processing comparisonvoting must incorporate mechanisms keep replicas synchronised avoid states replicas diverging asynchronous events eg interrupts timeouts processing nonidentical messages reasons could lead replica state divergence synchronisation level processor microinstructions logically straightforward way achieve replica synchronism approach processors driven common clock source guarantees execute steps clock pulse course logic individual processors must deterministic outputs evaluated comparedvoted possibly replicated hardware component appropriate times eg bus access asynchronous events must distributed processors node special circuits ensure correct processors perceive event point instruction stream 12 23 since every correct processor node executes instruction stream programs run nonredundant version made run without changes node major advantage gained synchronising level micro instructions implementations two processor failsilent nodes use stratus 27 sequoia 2 two wellknown examples systems common reliable clock source used driving pair processors execute lockstep access bus controlled reliable comparator circuit enables access bus signals generated two processors another example failcontrolled node presented 6 design employs tight synchronisation redundant processors addition uses coding techniques detectingcorrecting memory bit corruptions however problems microinstruction level approach synchronisation first indicated individual processors must built way deterministic behaviour clock pulse produce identical outputs dont care transitions instance bit either one zero allowed design processors second introduction special circuits reliable comparatorvoter reliable clock asynchronous event handlers bus interfaces increases complexity design extreme lead reduction overall reliability node third every new microprocessor architecture requires considerable redesign effort fourth tight synchronism transient fault likely affect processors identical manner thus making node susceptible common mode failures approaches use processor replication rely instead various application specific forms checking mechanisms eg watchdog timers detecting erroneous behaviour processor therefore considered eg 17 error detection coverage one node estimated better 99 11 however approaches application specific rather general purpose completely eliminate second third problems referred alternative approach seeks reduce eliminate altogether hardware level complexity associated approaches discussed maintain replica synchronism higher level instance process task level making use appropriate software implementedprotocols softwareimplemented nodes offer several advantages hardwareimplemented counterparts technology upgrades appear easy since principles behind protocols change protocol software ported relatively easily type processor including ones expected available future ii note employing different types processors within node possibility measure tolerance design faults processors obtained without recourse specialised hardware assistance iii since replicated computations execute lockstep node likely robust transient failures 11 task synchronisation approach pioneered designers sift failure masking node 28 sift application processes structured set cooperative cyclic tasks task performs deterministic computation execution particular iteration task consists inputting data possibly generated previous iteration tasks processing data outputting results faulttolerance achieved voting input data thus task replicas must synchronised beginning iteration start frame achieve sift maintains global timebase uses static priority based scheduling schedules tasks predefined time frames global timebase implemented keeping clocks correct processors synchronised software implementation byzantine resilient clock synchronisation protocol normal operation system allows interruptions clocks handled correct processors beginning time frame application dependent design sift architecture applied restricted range applications also case votrics system 25 follows design principles sift provide faulttolerance different still specific class applications railway signalling systems work taken sift approach investigating design family failuremasking failsilent nodes called voltan 21 22 24 capable supporting quite general purpose message passing programs voltan nodes composed offtheshelf processors connected via communication links processors node execute message agreement ordering protocols guarantee correct replicas application processes receive process input messages identical order output messages produced process replicas evaluated either comparator failsilent node voter failuremasking node processor however concern performance softwareimplemented nodes due overheads imposed redundancy management protocols indeed terms performance hardwareimplemented nodes always perform software equivalents hardwareimplemented node capable working nearly speed constituent processors sift instance redundancy management protocols consume much 80 processor throughput 15 hybrid solutions proposed circumvent problem maft 10 ftpap 13 delta4 16 hybrid architectures share basic design architectures structured around microinstruction synchronised hard core top conventional processors replicated microinstruction synchronised hard core responsible executing redundancy management functions eg message voting certainly improves performance however hard core reintroduces problems associated hardwareimplemented nodes paper present design implementation softwareimplemented twoprocessor failsilent nodes efficient terms performance capable executing general purpose message passing software performed careful analysis performance original implementation voltan nodes reference implementation examined several ways improving performance led design two novel message order protocols considerably efficient original protocol property failsilent node exploited design obtaining efficiency required detect failure rather mask present protocols resulting performance nodes performance figures obtained lead us believe wide class applications requiring high degree fault tolerance software implemented failsilent nodes constructed simply utilising standard offtheshelf components employing one new order protocols particularly leaderfollower protocol represent attractive alternative hardware implemented counterparts 3 basic principles 31 system model assumptions assume failed processor therefore processes running processor exhibit byzantine behaviour make assumption nonfaulty processor node able sign message sends affixing message message dependent unforgeable signature nonfaulty processor also assumed able authenticate signed message receives digital signature based techniques 18 provide comprehensive way meeting functionality assume nonreplicated distributed computations composed number processes interact via messages example function typical server process cycle selecting input message one input ports process necessary output one messages output ports necessary assume computation performed process selected message deterministic well known state machine model state machine process precise requirements supporting replicated processing known 20 basically replicated version process multiple input ports nonreplicated process merged single port replica selects message head port queue processing nonfaulty replicas identical initial states identical output messages produced provided queues correct replicas guaranteed contain identical messages identical order thus replication process requires following two conditions met agreement nonfaulty replicas process receive identical input messages order nonfaulty replicas process messages identical order practical distributed programs often require additional functionality using timeouts waiting messages timeouts asynchronous events high priority messages etc potential sources nondeterminism input message selection making programs difficult replicate previous papers 22 26 described nodes enhanced provide necessary functionality dealing cases paper assume simple state machine model discussed assume processor failsilent node network interfaces internode communication possibly redundant networks addition processors node internally connected communication links intranode communication needed execution redundancy management protocols eg message ordering comparison assume maximum intranode communication delay link known bounded nonfaulty process sends message nonfaulty link nonfaulty process neighbour processor message received within time units simplicity assume lower bound actual transmission delay zero 0d also represents maximum variation message transmission delays link link failures categorised processor failures link failure prevents message sent processor received neighbour node considered failure sender processor fig 1 shows example distributed system three twoprocessor failsilent nodes p q connected dual redundant network c1 c2 architecture node level processes replicated distinct nodes increased availability node level process composed two processes one underlying processors behaves like failsilent process particular system architecture used building highly available services constructing kresilient node processes k1 replicated node level process k0 tolerate maximum k replica failures subsequent failure makes services providing becoming unavailable separate paper shown protocols group communication node level processes necessary supporting services implemented run two processor failsilent nodes 7 fig 1 distributed systems architecture employing failsilent nodes 32 basic software architecture describe basic software architecture twoprocessor failsilent node addition application level computational processes processor node executes five system processes described sender process process takes messages produced computational processes processor signs sends via link neighbour processor node comparison comparator process process compares authentic messages sent neighbour processor counterparts produced locally message comparison succeeds singly signed authentic message received neighbour counter signed considering first signature part message double signed message termed valid message handed local transmitter process network delivery destination nodes comparison detects disagreement indicates failure similarly absence message comparison node specific timeout interval also indicates failure failure detected comparator process stops sender process new valid messages produced node transmitter process process responsible sending double signed messages network destination nodes processor transmitter process node correct processors produce two copies every output message subsequent discussions timing analysis node node output refer valid copy produced first receiver process process authenticates messages received network link discards unauthentic duplicate messages authenticated messages network valid messages sent local order process authenticated singly signed messages link sent comparator order process process executes order protocol counterpart processor node order construct identical queues valid messages processing computational processes since protocol entails order process relay valid messages counterpart sufficient message received network one processors node ordered processors exception asymmetric order protocol without feedback discussed later requires message received nominated processor leader ordering architecture adapted general case p1 processor failsilent node node produce valid messages p1 processor signatures 33 node failure semantics assume application processes correctly functioning nodes assign monotonically increasing sequence numbers new messages produce property enables correctly functioning destination nodes discard replicas previously received messages let application process running correctly functioning unreplicated node take units time compute response input message corresponding correct output failsilent node take ttt delay units time delay delay 0 bounded worstcase delay introduced redundancy management protocols output failsilent node produced later node said suffered performance failure 4 failsilent node one three states see fig 2 normal silent failing fig 2 failsilent node states normal state state node produces correct outputs detection internal failure comparator process causes node irreversibly enter either failing state silent state ii failing state intermediate state node suffer one performance failure state node eventually enters terminal silent state iii silent state new valid messages produced node messages produced node invalid copies previously produced valid messages functioning destination node detect messages unwanted reason existence intermediate failing state follows faulty processor contain message correct processor sent comparison message sent correct processor stopped faulty processor output valid double signed message future time sender comparator processes processor must therefore incorporate intranode message synchronisation measures ensure processor node time one message sent neighbour comparison yet compared locally way number performance failures failing state limited one fact failsilent node suffer single performance failure intermediate state need cause concern applications consider system fail crash nodes without intermediate state client application timing constraints expecting response node would still expected contain timeliness checks detecting absent response checks adequate case failsilent nodes filtering late responses application programs timing constraints performance failure suffered failsilent node failing state cause inconsistencies thus system software implemented failsilent nodes regarded capable implementing abstraction failsilence following sense node produces either correct messages verified destination failsilent nodes ceases produce new correct messages case destination nodes detect messages may produce unwanted possible design specialised faulttolerant network interfaces could prevent messages output node one processors detects failure minimally need provide network interface single switch unilaterally irreversibly switched control signal sent either processors node software solution design node intermediate failing state require additional redundancy example one could delegate responsibility message comparison output separate node fail 2p1 failure masking node capable masking p processor failures within node could provide services message comparison output collection p1 processor nodes indeed failuremasking node provide services recording status failsilent nodes design much resembles system failstop nodes 19 switch functioning halted state provide failurestatus indication 34 rationale behind experimental work rest paper describing experimental work evaluating number designs twoprocessor failsilent nodes however brief discussion rationale behind experimental work worth mention note performance failsilent node depend quickly messages ordered compared ordering achieved several ways basic idea agreement protocol guarantees correct replicas receive set messages accomplish ordering assigning monotonically increasing sequence numbers messages also necessary devise method establish message becomes stable ie guaranteed valid messages sequence numbers less certain value seq ever received messages sequence numbers less seq processed consistent order among replicas general methods assigning sequence numbers messages associated stability tests different system assumptions discussed 20 used ideas applied special case twoprocessor failsilent nodes delay imposed comparison protocol mostly made time spent message exchanges plus delay introduced intranode message synchronisation measure necessary ensure processor node time contains one message neighbour comparison took following approach quest design minimised ordering comparison delays first performed reference implementation based design relatively easy understand reason reference implementation used simple order protocol messages simple comparison protocol incorporate synchronisation measure limiting number received messages neighbour one potentially node suffer one performance failure failing state investigated number ways reducing message ordering delays investigated message comparison protocols synchronisation measures work order protocols proved highly significant coming clean efficient solution selected design comparison protocol undertook comparative performance evaluation four node designs using comparison protocol different order protocols input messages starting one used reference implementation carefully designed software reference implementation modular fashion made relatively easy us replace modify modules incorporate necessary changes 24 4 reference implementation 41 software architecture overall software architecture failsilent node depicted fig 3 major software modules within processor node interactions summarised processor maintains several message queues lists received message queue rmq contains valid messages intended ordering received network b delivered message queue dmq contains ordered messages consumed application process service c processed message queue pmq contains unsigned output messages produced local application processes messages must validated comparator process transmission final destination sender process responsible transmitting messages pmq neighbour processor well local comparator process external candidate message list ecl contains singly signed messages received neighbour processor validation internal candidate message list icl contains unsigned messages waiting matching signed message arrive ecl f compared message queue cmq contains successfully compared double signed messages valid messages ready transmitted network order comparator receiver sender transmiter icl network link network link network link fig 3 software architecture processor node 42 comparison protocol reference implementation uses simple comparison protocol referring fig 3 sender process processor transmits messages pmq neighbour get buffered neighbours message pool ecl comparator process maintains application process service sequence number next message compare recall application processes assign monotonically increasing sequence numbers new messages produce using criterion comparator matches messages identical sequence numbers ecl icl comparison detects disagreement indicates failure similarly absence message comparison node specific timeout interval also indicates failure failure detected comparator process stops sender process simple protocol ecl processor permitted contain one correct message neighbour thus potentially faulty processor output one late valid message latter section describe additional synchronisation measure necessary prevent happening 43 order protocol synchronised clocks reference implementation order protocol described section makes use wellknown approach using synchronised clocks message ordering clocks processors node assumed synchronised magnitude measurable difference readings clocks instant bounded known constant say e nonfaulty processor stops soon failure detected clock synchronisation protocol need faulttolerant assumed execute faultfree environment shown lower bound e d2 5 faultfree environment e taken d2 provided inter synchronisation period kept small enough effects due differences running rates clocks ignored order process processor timestamps message ordered local clock reading copy timestamped message sent link order process processor node timestamp message received sent order process processor message becomes stable local clock time td dde message timestamp becomes stable valid messages timestamp tt received order process stable messages enqueued appropriate dmq increasing timestamp order action taken discard rather enqueue stable message replica already enqueued order process composed three cyclic processes relayer transfer deliver see fig 4 relayer process picks messages rmq timestamps sends processor node also inserts message ordered message list oml transfer process receives relayed messages link performs timeliness check rejects message received early messages timestamp less ce c current reading processors clock received late messages timestamp greater cd accepted messages inserted oml deliver process takes stable messages messages timestamp less cd oml removes duplicates enqueues messages appropriate dmq increasing order timestamps deliver relayer transfer link oml link order fig 4 order protocol synchronised clocks compare ordering speeds various protocols failurefree situations define actual stability delay order protocol terms reliable reference clock clock could correct processors physical clock processors node correct order protocol given message network defined reference clock time elapsed instant copy message first received one processors node instant message gets ordered enqueued appropriate dmq processors node throughout paper assume effects differences runnning rates reference clock correct processors clock negligible intervals e measured assumption order protocol presented l l 0 magnitude message reception skew according reference clock ie difference reference clock times processor node receives copy message network e 0e e magnitude actual clock synchronisation error time message first received network ahead factor 1 clock processor first received message network ahead processors clock zero either first processors clock ahead l 0 note one processor receives message network l message ordered processors also define min max respectively lower upper bound actual stability delay order protocol min max therefore protocol fixed overhead least units time implicit order protocol motivated us seek enhancements begin describing method improving protocol describe new protocols require clocks node kept synchronised 5 improved order protocols 51 improving synchronised clock algorithm arrival relayed message used reduce constant stability delay imposed order protocol shall assume messages sent link received sent order given fifo assumption timestamp received relayed message used define new lower bound actual stability delay fig 5 used illustrate idea case relayed message timestamp received local clock reading c greater messages received ordering neighbour bearing timestamp smaller equal new local message ordering get timestamp greater equal c messages sender ordering oml fig 4 timestamps smaller equal stable case b shows case message timestamp received ordering neighbour ct case messages ordering timestamp smaller c stable note case guaranteed neighbours clock ahead processors clock also message could taken d2 time transmission across link otherwise possible ct e d2 therefore updating local clock t1 cause magnitude clock difference increase beyond d2 ie beyond e update relayed message timestamp received processor define new stabilisation interval messages timestamp smaller equal stable case c words message relayed one processor becomes stable receiving processor soon received b c stable timestamps accordance synchronised clock protocol stable timestamps assuming fifo channels nonstable timestamps fig 5 stability intervals derive modified protocol let processor first receive message network receive reference clock time r processor receive relayed message time r 0d actual link transmission delay immediately order first processor able order message time r time r l receives relayed message processor mind l min 0 max 0 52 order protocol logical clocks take idea discussed step eliminate requirement physical clocks processors forming node kept synchronised instead use logical clocks generating timestamps 14 order protocol processor node maintains two logical clocks counters namely local logical clock llc remote logical clock rlc initialised 1 0 respectively llc used timestamp messages relayed neighbour ordering rlc used store estimation neighbours llc clocks updated following way whenever processor relays message neighbour timestamps message current value llc increments llc one whenever message timestamp received neighbour rlc set llc set maximum current value t1 updates ensure following properties messages relayed neighbour bearing increasing timestamps ii value rlc processor smaller llc well neighbours llc property ii guarantees messages ordering timestamps smaller equal rlc stable relayed message becomes stable receiver processor soon received actual stability delay l protocol presented one shortcoming messages processor become stable arrival relayed message neighbour rlc updated message relayed neighbour received however processor relay message receives network one processors receives message network l prevented stabilising message solve problem discuss scheme based timeouts allows processor update rlc even processor relay message 20 processor say neighbour say schedules update rlc value occur time t2d value read physical local clock 1 relayed time t2d rlc updated value less 2d timeout interval follows fact receiving 1 timestamp llc p 2 value least t1 therefore message timestamp smaller equal relayed p 2 p 1 say relayed p 2 received 1 worst case would done reception 1 1 2 taking units time thus p 1 must wait least 2d units time advancing rlc order process protocol also composed three cyclic processes work fashion similar discussed previous protocol see fig 4 relayer process picks message rmq timestamps value read llc places message oml copy timestamped message sent link neighbour processor finally processors llc incremented one update rlc scheduled executed 2d units time transfer process receives relayed message timestamp link performs timeliness check message considered timely timestamp greater current value rlc timely places processors oml llc rlc updated necessary discussed messages oml timestamps less equal rlc stable thus deduce min2d l min 0 max 2d 0 2d 53 asymmetric order protocol present protocol assign different roles two processors forming node term one processor leader neighbour follower responsibility leader determine order processing messages selected message processing leader sends copy message follower inspiration way building failsilent node comes leaderfollower replication protocol application level processes used delta4 system 1 16 due simplicity ordering mechanism need special order process within processor instead receiver processes different functionality leader follower comparator receiver sender transmiter icl network link network link network link comparator receiver sender transmiter icl network link network link network link timing leader follower link fig leaderfollower failsilent node node works follows see fig 6 leader maintains counter whose value used assigning unique identifiers input messages authentic double signed message received receiver leader tagged counters value counter incremented one message deposited appropriate dmq increasing order tag values copy message also sent follower across link output messages application process service follow path discussed tagged messages leader reach follower also get deposited appropriate dmq message buffers ecl icl cmq comparator process role asymmetry introduced assigning different roles two processors node requires us introduce extra mechanism follower detecting late non arrival message ordering leader timing process see fig 6 introduced follower followers receiver process deposits authentic double signed input message received network external received message list erml associated timeout copies messages received leader via link way dmq deposited internal received message list irml timing process picks message irml resets timeout associated counterpart erml timeout expires follower assumes leader failed send message ordering stops activities processes processor unlike previous protocols order calculate actual stability delay protocol relevant identify processor first receives copy particular input message define l lf difference time leader receives copy particular input message time follower receives copy message actual stability delay protocol given f l 0 l lf 0 l lf otherwise l f actual stability delay leader follower respectively protocol embellished deal case correctly functioning leader receive message network follower leads node becoming silent follower processor try prevent shut feeding leader missing input message feedback version leaderfollower protocol timeout expired follower sends copy missing input message leader order properly ordered simplicity path shown fig 6 second timeout t2d associated message timeout also expires follower may assume leader failed follower cease activities stability delays become f l 0 l lf 0 minl lf td otherwise also sensible strategy follower set t0 thus soon follower receives message network checks presence corresponding relayed message leader 2d thus max protocol becomes identical logical clock protocol 6 asymmetric comparison protocol comparator protocol discussed permitted node failing state commit one performance failure one way preventing happening use comparison protocol guarantees processor sends given message comparison neighbour previously sent messages successfully compared locally order prevent deadlocks also necessary processors first agree order exchange messages comparison architecture logical way achieving agreement would insert order process pmq sender process processor asymmetric ordering approach discussed previous section provides convenient way integrating ordering comparison accordingly present comparison protocol based around leaderfollower technique worth noting comparison protocol used within node uses order protocol input messages synchronised clock logical clock leaderfollower ordering input messages independent ordering output messages description given concentrates message synchronisation aspects protocol aspects remain unchanged purpose message comparison one processor assigned role leader follower leader messages pmq follow path see fig 3 however following synchronisation sender comparator introduced sender allowed send new message link comparison permitted comparator permission granted comparator finished comparing current message comparator sender icl link transmiter network fig 7 message comparison followers side messages produced application processes follow slightly different path shown fig 7 comparator compares message ecl sent leader locally produced one icl comparison succeeds valid message deposited cmq network delivery locally produced message deposited pmq delivery link leader message arrive ecl leader get compared successful comparator process leader permit local sender process send next message comparison 7 performance evaluation section present performance figures obtained set experiments run main objective assess degradation performance suffered node called upon execute redundancy management software present ordinary processor currently simple checksums used signatures minimal impact upon system performance need complex signature mechanisms yet assessed implemented failsilent nodes t800 inmos transputers evaluated performance four protocols ordering input messages reference implementation based clock synchronisation algorithm ii logical clocks iii leader iv leaderfollower feedback implementations made use asymmetric message comparison protocol discussed cases iii iv processor acting leader ordering also leader comparison two processors node directly connected transputer links thereby providing fast internal path intranode communication first experiment consists client application process executing node requesting simple service server application process executes different node client process issues request server process waits response server process receives request client services actual computation performed minimal sends response back client upon reception response message client issues new request measured following time intervals server process input delay id input delay measures time interval message entering node earliest reception times processors message last removed dmq one processors delay made actual stability delay message plus time taken authentication queue manipulation within node reflects overhead involved ordering messages node ii output delay od output delay measures time interval message becoming ready comparison processors ie largest two times message entered pmq message output node ie first output one processors reflects time taken message compared output iii node delay nd finally node delay simply sum input output delays idod reflects earliest response node given input message ie overhead associated replication modeldelaysms id od nd av l av synchronised clocks 2021 409 2430 347 144 logical clocks 764 318 1082 394 150 leaderfollower 434 206 640 232 123 leaderfollower table performance figures clientserver system collected data ten runs experiments run involves client node sending 100 request messages 64 bytes one time intervals discussed averaged values measured requests processed also measured average link transmission delay av average message reception skew l av average delays obtained summarised table figures expressed milliseconds unreplicated node also executed experiment using single processor nodes would anticipate case ordinary processors overheads small exist still necessary enqueue dequeue messages system measured node delay server amounted 1ms 07ms due input overheads whilst 03ms due output overheads ii nodes synchronised clock order protocol experiments worst case circumstances determined smallest safe value 12ms reference implementation node uses simplified version clock synchronisation algorithm presented 9 stated e set d2 hence fixed e6ms gives stability delay 18ms since dde measurements indicated actual stability delay almost values shown table id indicate overheads due message authentication queue manipulation take 221ms iii nodes logical clock order protocol using logical clocks actual stability delay would around av l av assuming overheads due message authentication queue manipulation results given table show expectation almost realised practice unlike previous protocol asymmetric protocols performance proportional actual values transmission delays message reception skews iv nodes leaderfollower order protocols asymmetric order protocols necessary examine separately performance leader follower processors since executing different protocols analysis presented previous section id corresponds followers stability delay f l plus overhead due message authentication queue manipulation experiment two nodes directly connected leadertoleader followertofollower transputer links therefore follower always outputs messages leader time also follower receive copy particular input message first thus time l lf 0 consequently l lf values shown table indicate message handling overheads asymmetric protocols 079ms leaderfollower 083ms leaderfollower close experienced unreplicated node functions order protocol incorporated receiver process overheads slightly bigger replicated node messages must authenticated performance figures presented two leaderfollower protocols see extra message traffic introduced feedback mechanism hardly impact performance node despite fact implementations make use comparison protocol figures table show node asymmetric order protocol input messages suffers less output delay node symmetric one reason asymmetry introduced input ordering comparison helps follower comparison time time message becomes available icl see fig 7 leaders message usually available ecl next experiment performed evaluate impact size input messages messages need ordered performance node size messages affect intranode message transmission times consequently affecting input output delays transputers use bytestream protocol linklevel communication system endtoend message transmission delay two transputers varied 18ms messages size 256 bytes 33ms messages size 2048 bytes using clientserver system measured node delay various order protocols message size increased 256 2048 bytes see fig 8 synchronised clocks logical clocks leaderfollower leaderfollower 683 731 764 802 872 978 1021 1100 794 86 923 968 1017 1002 1064 11105 synchronised clocks logical clocks leaderfollower leaderfollower feedback512102415362048 node delay milliseconds fig 8 impact message size impact message size order protocols uniform increased transmission delay little impact performance order protocol based synchronised clocks stability delay based worst case transmission delay thus node delay synchronised clock protocol suffers moderately small increase 124ms 2476ms 2600ms mainly due increased output delay hand would expect protocols would affected strongly values fig 8 show increase 357ms logical clock protocol increases 417ms 316ms leaderfollower leaderfollower feedback protocols respectively last experiment measured maximum throughput maximum rate node given order protocol order compare messages compared throughput node configuration throughput unreplicated node experiment used fixed message size 64 bytes modified version client process client process wait response arrive issuing next request rather sends continuous stream request messages experiment simulates environment server process always input messages processing measured rate messages per second messages deposited cmq comparator processor first output message see fig 3 output rate used obtain throughput ratio tr unreplicated unreplicated output rate measured unreplicated node figures obtained presented table ii model unreplicated node 329 10000 synchronised clocks 66 2006 logical clocks 68 2067 leaderfollower leaderfollower table ii throughput heavily loaded node heavy load ordering protocols performance closer worst case see performance node logical clock protocol almost synchronised clock based node asymmetric protocols still outperform protocols 8 concluding remarks described work building efficient failsilent nodes first performed reference implementation made use simple comparison order protocols investigated performance order protocol improved led much simpler protocol based purely logical clocks obviating need keeping intranode clocks explicitly synchronised also designed implemented asymmetric order protocols described asymmetric ordering approach also exploited construction efficient message comparison protocol extensive experiments performed evaluate performance nodes order protocols results obtained indicate adopting asymmetric leaderfollower mechanism within failsilent node message comparison well ordering represents best design choice must stated possible design symmetric comparison protocol require processors decide order exchanging messages comparison protocol sender comparator processes processor ensure given time one message sent comparison locally compared first combining protocol symmetric ordering protocols discussed earlier could result efficient node designs performance figures obtained quite careful engineering message passing software unlikely therefore significantly better performance obtained improved message passing mechanisms leaderfollower node described probably indicates limits achieved using standard theshelf processors asymmetric protocols particular implementation performance impact using failsilent nodes produce delay response 6ms per message lightly loaded system secondly worst case loading failsilent node achieve 39 throughput rate nonreplicated counterpart appreciated price performance becomes significant distributed applications processes interact frequently hand application processes involved computations requiring little interactions performance impact adding softwareimplemented failsilence quite small thus bearing mind discussion presented start paper advantages softwareimplemented failsilent nodes hardwareimplemented nodes anticipate range applications softwareimplemented nodes offer attractive alternative hardwareimplemented counterparts conclude highlighting recent work illustrates advantages softwareimplemented approach software approach makes possible apply failsilence measures selectively processes deemed critical given application voltan system software uses asymmetric leaderfollower mechanism sufficiently lean make practical use software library constructing selfchecking processpairs member processpair contains number threads together implement entire voltan message ordering selfchecking mechanisms implemented system software permits collection distributed processes replicated transparently giving equivalent collection selfchecking voltan processes 3 software approach also makes possible extend capabilities node relative ease proposed simple significant embellishment capabilty failsilent node resulting node termed failstable node 8 addition failsilence property p1 processor failstable node second property providing stable store node maintains log whose contents survive internal failure log accessible nodes system used constructing recent states processes running node node stopped state information provided halted node facilitates easy prompt restarting stopped processes nodes node therfore forms attractive building block constructing available distributed systems acknowledgements work supported part grants uk engineering physical sciences research council brazilian research council cnpq r delta4 extra performance architecture xpa sequoia faulttolerant tightly coupled multiprocessor transaction processing voltan application programming environment failsilent processes understanding faulttolerant distributed systems possibility impossibility achieving clock synchronization errorresistant interactively consistent architecture erica distributed systems architecture supporting high availability reliability building available distributed systems using failstable nodes fault tolerant clock synchronization maft architecture distributed fault tolerance tolerating transient faults mars byzantine resilient fault tolerant computer nuclear power plant applications hardware software fault tolerance unified architectural approach time clocks ordering events distributed system measurements sift operating system overhead design failsilent processing node predictable hard realtime system mars method obtaining digital signatures publickey cryptosystems byzantine generals action implementing failstop processors implementing fault tolerant services using state machine approach tutorial failcontrolled computer architectures distributed systems principal features voltan family reliable node architectures distributed systems fault tolerant processor concepts operation design implementation voltan faulttolerant nodes distributed systems votrics voting triple modular computing system preventing state divergence replicated distributed programs stratus architecture sift design analysis fault tolerant computer aircraft control tr ctr mark w burns alan george bradley wallace simulative performance analysis gossip failure detection scalable distributed systems cluster computing v2 n3 p207217 1999 mark l mckelvin jr gabriel eirea claudio pinello sri kanajan alberto l sangiovannivincentelli formal approach fault tree synthesis analysis distributed fault tolerant systems proceedings 5th acm international conference embedded software september 1822 2005 jersey city nj usa bruno gaujal nicolas navet maximizing robustness tdma networks applications ttpc realtime systems v31 n13 p531 december 2005 claudio pinello luca p carloni alberto l sangiovannivincentelli faulttolerant deployment embedded software costsensitive realtime feedbackcontrol applications proceedings conference design automation test europe p21164 february 1620 2004
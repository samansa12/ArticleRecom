universal wormhole routing abstractin paper examine wormhole routing problem terms congestion c dilation set packet paths show mild restrictions simple randomized algorithm routing set p packets oleft cdeta cleta rm logp right time high probability l number flits packet constant number flits stored queue time using result show fattree network area simulate wormhole routing network comparable area olog3a slowdown worms length variablelength worms also considered run simulations fattree show wormhole routing tend perform better heavily studied storeandforward routing context performance superior provable bound attainable practice b introduction efficient routing algorithm critical design largescale generalpurpose parallel computers one must move data different locations appropriate routing network quickly possible little queuing hardware possible storeandforward routing extensively studied model many asymptotically efficient algorithms proposed model eg 15 references therein recently increasing attention devoted wormhole routing model 3 since lead reduction routing time storage requirements intermediate nodes model packets worms composed flits flow control digits packets snake network one flit another works performed theoretical analysis work supported part national science foundation grants ccr9109550and ccr9321388and summer research award university maryland office graduate studies research r greenberg department mathematical computer sciences loyola university 6525 n sheridan rd chicago il 60626 rigmathlucedu hc oh department information engineering korea university chochiwon korea hyeongtigerkoreaackr wormhole routing similar schemes leighton 17 performs averagecase analysis greedy cutthrough routing meshes cutthrough routing 13 differs wormhole routing uses buffers store least one full packet rather flits makedon simvonis 20 give worst case bounds cutthrough routing permutations mesh torus aiello leighton maggs newman 1 give efficient algorithm wormhole routing permutations dilated butterfly algorithm nonoblivious may use information packets routing given packet recently felperin raghavan upfal 6 obtained simple oblivious algorithm wormhole routing permutations butterfly mesh works described iterative methods estimating performance certain networks certain probabilistic models message generation 4 11 2 analyses wormhole routing applicable specific networks andor specific message patterns paper takes general approach based summary measures message traffic 16 15 require two paths network intersect constant number contiguous sequences edges condition met many networks used practice recently intermediately broad class networks considered ranade et al particular application improved routing certain message distributions butterfly 26 deriving general bounds wormhole routing apply results construction areauniversal net works particular worms fixed length boundeddegree network butterfly fattree 9 area using wormhole routing simulate online network comparable area olog 3 though proven ologa slowdown suffices storeandforward routing model 15 approach requires universal network queue full packets intermediate node similarly limits type competing network considered also circuitswitching scheme 9 could actually used wormhole routing scheme poorer overhead show since earlier scheme locks routing path time required worm pass also extend universality analysis case worms varying lengths case processor continuously generates sends packets packet length l random variable mean maximum value lm mild restrictions show fattree network area thetaa simulate network comparable area l log 3 proceeding promised results give detail model terminologies used throughout paper consider routing set p pack ets consisting l flits follow usual graphbased processors switches nodes graph communication channels represented edges make usual assumption unit time suffices flit cross edge network though would also desirable extend analysis general edge delays done 10 storeandforward model flit atomic object time step either waits queue crosses edge enters edge queue end edge storeand forward routing packets atomic objects call unit time step flitstep corresponding unit time step storeandforward routing packetstep restrict attention boundeddegree networks time make routing decisions given node affect asymptotic time bounds may view packet routing problem comprised two tasks selecting path network packet setting schedule packets move wait next section paper focus second task course selection paths affects required routing time example maximum distance number edges traveled packet lower bound routing time distance often referred dilation literature may noted dilation typically large network diameter necessarily packets traverse shortest paths similarly routing time lower bounded cl congestion c maximum edges number packets must traverse edge entire course routing set packet paths determined define graph vertex edge network edge u v whenever packet path network edge v immediately follows network edge u refer graph dependency graph ensure deadlock cannot occur assuming dependency graph paths acyclic 3 many networks eg leveled networks 15 cycle set packets also techniques breaking cycles 3 addition adaptive routing techniques avoiding deadlock eg see 5 references therein analysis applied set packet paths generated technique ii simple wormhole routing algorithm section give simple delayedgreedy wormhole routing algorithm theoretical analysis worms length l throughout sec tion consider set paths channel dependency graph acyclic also assume two paths network intersect one contiguous sequence edges easily seen results also valid long two paths intersect constant number contiguous sequences edges node queue input edge store one flit sufficient analysis node scan input queues fixed order send flit whenever relevant outgoing edge occupied another worm say worm w 0 blocks w edge head w proceed taken w 0 worm worm w delay chain w blocking worm w worm chain move since exclude possibility deadlock blockage end time also worm w 0 delays worm w l steps necessarily consecutive w 0 delay w assumption packet paths intersect one contiguous sequence edges basic routing algorithm use delayedgreedy approach similar felperin raghavan upfal 6 analysis simplifies clarifies generalizes argument begin worstcase bound routing time holds high probability give tighter bound expected time throughout paper use term high probability standard fashion constant achieve probability appropriate measure problem size particular focus achieving time bounds routing p packets probability network simulation using networks area hold probability o1a starting point results following core routing procedure expressed terms parameters k determined later algorithm assign packet integral delay randomly uniformly interval 0 kcl gamma 1 packet assigned delay waits initial queue steps proceeds destination refer time gamma 1t ith phase follows assume large enough worms dispatched different phases interfere analyze large needs worms dispatched phase actually get delivered end phase begin key lemma bounding tail binomial distribution independent bernoulli trials probability p success probability number successes larger expectation p proof probability lemma follows use stirlings approximation prove general lemma number delaying worms encountered specified set edge traversals set worms consider set worm paths comprising total edge traversals worm heads need accomplished phase algorithm let p x probability delays x worms interfere set traversals p w x 2 proof use induction x prove result value x using induction base cases trivial induction step first consider l focus first l edge traversals particular worm notice blocked cl worms none worms launched current phase equal p x gamma l otherwise let set worms launched current phase note probability contains worms using kcl worst case worms could act delaying worms must also worry delays encountered worms traversal already considered need consider new edges worm worm traversed many edges already consideration digressed far enough paths originally consideration effect thus induction step cl cl cl l additive term preceding summation disappears replace p final result still holds analyze time worm dispatched algorithm required traverse links probability given worm w requires least 2dlz time reach destination algorithm p 0 z 2 proof w require 2d lz time reach desti nation must delayed z worms since one worm delay w l steps result follows lemma 2 ready main analytical result theorem 4 set p packets routed cdj probability proof consider first case l case simply run algorithm probability given worm delivered phase dispatched assumption worms dispatched previous phases deliv ered yields overall probability o1p exists worm get delivered failure probability changed constant power 1p changing constant k total time kcl phases algorithm ocdlcl 2 log p use modified version algorithm kcd phases lemmas 2 3 still go replacing appearances l proofs proceed total routing time ocdl log p high probability interesting note also obtain better expected routing time well high probability result theorem 5 set packets routed ocdl expected time proof proof theorem 4 actually use o32ecj phases algorithm also initially run algorithm run whole algorithm etc high probability result theorem 4 still holds double routing time process building towards high enough value addition expected time per phase lemma 3 od l total expected time ocjd also following corollary theorem 4 useful section corollary 6 log p set p packets routed flitsteps high probability iii wormhole routing fattrees fattrees constitute class routing networks hard wareefficient parallel computation 18 9 15 figure 1 shows layout one fattree variant using switches constant size fattree style usually referred butterfly fattree variation adopted cm5 supercomputer thinking machines corporation 19 figure 1 set n processors placed leaves represented circles squares switches connection drawn pair switches processor switch represents pair oppositely directed fig 1 butterfly fattree links capable transmitting one flit unit time call link parent child link link underlying structure figure 1 complete 4ary tree edge underlying tree consists group links called channel call channel parent child channel channel number links channel called ca pacity important measure difficulty routing set packets fattree load factor maximum ratio number packets traversing channel capacity channel load factor closely related congestion c always choose packet paths select shortest path packet dependency graph paths selected way free cycles shortest path proceeds channel channel fact view network partitioned two halves network channels network channels duplicating switch network comprised two halves two paths intersect two contiguous sequences edges hence result section ii applied bound number steps given worm delay another given worm increases l 2l areauniversality fattrees a1 worms fixed length algorithm analyzed section ii allows us extend wormhole routing problem universality theorems 18 9 15 7 state universal fattree given area volume simulate using circuit switching storeandforward packet routing routing network equal area volume polylogarithmic factor increase time required throughout section assume worms fixed length l construct fattree unitsize processors occupies area linear number processors 7 actually reasonable consider processors larger constantsize bypass complication since handled 7 8 simple onetoone mapping competing networks processors fattree guarantees set packets delivered one packetstep competing network comparable area induce great congestion fattree shown following lemma adapted 7 lemma 21 example area construct mesh htree oa processors butterfly lg nodes straightforward geometric mapping fattree processors appropriate channel capacities lemma 7 consider networks unitsized processors let r set networks area exists fattree f area thetaa set packets delivered one packetstep network r induces congestion log f immediately extend lemma case competing network uses wormhole routing set packets move window l flitsteps competing network induce congestion log state universality result wormhole routing theorem 8 fattree f area thetaa simulate network area factor log 3 delta loss runtime efficiency using online wormhole routing high probability proof consider set packets moves l flit steps competing network area extending lemma 7 suggested know congestion created set packets fattree area thetaa log next restate corollary 6 substituting p long number packets polynomial true fattree set packets delivered f flitsteps noted circumstances obtain asymptotic bound appears better splitting packet flits essentially treating flits independent packets course must attach complete addressing information flit flit big enough carry full address think flit transformed packet two flits could use storeandforward routing scheme leveled networks leighton et al 15 route packets cl log overhead fattree simulation course unfair compare result theorem 8 independentflit approach would induce additional overhead increased storage intermediate nodes overhead splitting reconstructing packets a2 worms variable lengths section consider situation processor continuously generates sends packets packet length l random variable mean l variance oe 2 l maximum value lm following lemma shows realistic restric tions total length set n packets unlikely greatly deviate expected value lemma 9 let x random variable mean variance oe 2 let sn sum n independent random variables distributed x 0 oe ffl ffl constant 0 least n proof proof follows tchebycheff inequality next note simple corollary corollary set packets routed flitsteps high probability assume standard deviation packet length satisfies l constant ffl 1 assumption satisfied packet length distributions generated typical concurrent computing applications presented literature eg 21 packets varying lengths simulation overhead becomes complicated analyze number packets crossing wire competing networks may vary wire wire interval time consider situation processor continuously generates sends packets time interval length l following theorem extend result theorem 8 general setting theorem 11 consider competing networks area processors continuously generate send packets time interval length least l let lm bounded polynomial fattree f area thetaa simulate network factor l log 3 delta loss runtime efficiency using online wormhole routing high probability proof break overall time period consideration consider separately worms delivered competing network consecutive time intervals length l determine overhead set message routed network interval length delivered fattree comparable area construct fattree unitsize processors section a1 next recursively bisect competing network straightforward geometric fashion 7 8 match parts obtained bisection pieces f accordance obvious recursive bisection f consider piece c area 0 competing net work construction f guarantees channel capacity f corresponding perimeter c consider set wires connecting c remaining part competing network let p 0 denote maximum wires number worms crossing wire since sum lengths p 0 packets cannot exceed know lemma 9 p probability least since perimeter c total number worms crossing wires thus congestion induced channel f worms crossing wires p 0 log corollary 10 worms routed competing network delivered f total number worms delivered polynomial theorem follows simulation section investigates practical performance wormhole routing algorithms butterfly fattrees simplicity focus case worms fixed length l overhead fattrees simulating networks much worse variable length worms terms provable bounds expect true practice b1 description butterfly fattree use butterfly fattree n processors style figure 1 node address expressed pair l integers l represents level node butterfly fattree represents address node level let level node distance leaves 0th level l 0 n processors addressed 0 n gamma 1 figure 1 arrange processors similar fashion shuffled rowmajor indexing 27 processors connected n4 switches 1st level processor 0 connected switch 1 ba4c lth level switches connections switch determined switchs address follows l connected l xi l xi b2 routing algorithms strategies algorithm store delayed greedy storeandfor ward routing algorithm packet chooses integral delay randomly uniformly interval 0 r gamma 1 packet assigned delay x waits initial queue x time steps proceeds destination step node scans input queues sends available packets greedily whenever corresponding output edge idling queue end edge full algorithm worm delayed greedy wormhole routing algorithm packet consists l flits packet chooses integral delay randomly uniformly interval packet assigned delay x waits initial queue xl log n time steps proceeds destination flit step node scans input queues flit head flit node sends according flits path output edge used packet queue end edge full flit head flit node sends flits head sent whenever queue end edge full algorithm univ universal storeandforward routing algorithm 15 leveled networks scheme packets choose random priority 1 r used order passage packets given switch algorithm split uses independentflit approach packet split flits treated independent packets routed store approach also called multipacket routing approach 14 note approach requires replication addressing information independent packets routed correct location butterfly fattree one shortest path pair leaves specifically switch packet take one two links destination one leaves subtree rooted switch redundancy links use redundancy selecting paths ffl fixedpath fp selection packet select shortest path randomly uniformly packet leaves source ffl randompath rp selection packet needs go selects link randomly link blocked packet waits selection oblivious ie time packet seeks go makes selection randomly ffl greedypath gp selection packet seeking go scans links chooses first one blocked one incoming packet routed outgoing link way selecting one may affect results following schemes tested ffl fixedorder fo scan time step switch scans incoming links fixed order chooses first pertinent packet outgoing link ffl random roundrobin rr scan scheme similar fo scan except switch selects first incoming link randomly scans around link ffl farthestfirst ff selection scheme switch scans input queues rr fashion except priority given packets heading farthest destinations links packets farthest sources links b3 simulation results since real parallel computations tend dominated communication time algorithms typically viewed consisting alternating phases computation communication focus static injection model processor fixed number packets send measure time deliver full set messages scenario corresponds situation analyzed theoretically section a1 compare empirical results constitutes important general model argued 28 example consider three communication patterns representative range likely patterns real parallel computations ffl random instance packet chooses destination randomly uniformly complement permutation processor 0 sends packet processor 0 permutation induces high congestion fattree permutation congestion created permutation n2 ffl manyto1 instance packets sent processors processor 0 packets processors 0 sent processor 0 0 pattern gives us high congestion number packets permutation random pattern probably common simulation studies arises many practical contexts example recently studied variation sample sort begins randomly redistributing keys sorted 12 focus pattern graphical results presented permutations also included stud ies however since comprise common communication primitive trivial whereas complement natural permutation presents high conges tion finally manyto1 pattern models common operations broadcast census involve hotspot contention give substantially different behavior uniform traffic patterns 25 five network sizes considered 256 1024 4096 run measure maximum communication latency time elapsed routing begun tail last packet arrives destination figures 2 5 point represents average runs error bars showing 99 confidence interval true average value maximum latency also included figure 2 omitted plots ease readability cases draw distinctions performance little overlap error bars describe plots principle conclusions additional plots including combinations routing strategies different parameters queue size worm size error bars found 22 queue size q worm chosen experimentally random instances little gained increasing queue size beyond 2 flits choice generally yielded better performance store queues size tested following use queues 2 flits worm queues 1 packet store store improves somewhat larger queues already using buffer space worm first compare store univ even though univ known achieve asymptotically optimal time fattrees delayed greedy routing algorithm store performed better univ communication patterns considered comparison random instances shown figure 2 marked difference somewhat surprising since algorithms use value r use random priorities univ seems intuitively somewhat similar imposing random initial delays tested effects initial delays latency store worm found initial random delays decrease latency find cases provided much advantage use henceforth50150250350450 max latency fig 2 performance store rp rr comparison univ algorithms used also found average latency tends depend linearly worm size l consistent observation total number packets may delay given packet function l l fore except otherwise noted experiments one worm size typical value literature 24 figure 3 compares path selection schemes storeandforward routing wormhole routing adaptive schemes significantly outperform fixedpath scheme cases considered similar results obtained packet selection schemes using best path selection scheme rp figure 4 compares packet selection schemes shows rr slightly outperforms fo 48 cases ff performed similarly fo henceforth show results rr rp routing schemes gpfo combination may also good choice though rprr outperforms 59 store 1215 worm dont worry difficulty implementing good randomization schemes programmers prefer deterministic systems figure 5 compares two approaches treating flits packet ordinary wormhole independentflit split approaches performance split pretty sensitive selection routing schemes example split gpff uniformly outperforms split max latency fig 3 comparison routing schemes selecting paths store worm rr scan10002000300016 64 256 1024 4096 max latency fig 4 comparison routing schemes scanning input queues store worm rp selection rpfo observed store found worm rprr outperforms split rp4008001200 max latency fig 5 comparison routing schemes treating flits worm rp rr split various strategies fo split gpff split rprr performs slightly better worm rprr comparison however made without considering addressing information added individual flit original packet figure 5 expect even slight increase number flits sent split due replication addressing information would cause worm outperform split table compares average latencies worm store various conditions cases considered worm outperforms store finally investigated experimental upper bound maximum latency worm rprr table ii summarizes random instances average values runs c latency divided c sought best leastsquares fit latency divided c form k log p 4 n constants k p best fit obtained p 022 would rash conclude latency fits closely thetacl log 022 n since neglected lower order terms network sizes used may small observe proper asymptotic bound nonetheless appears performance superior provable bound corollary 6 close obvious lower attainable random instances storerprr wormrprr random complement manyto1 random complement manyto1 table average latency flitsteps greedy storeandforward store greedy wormhole worm algorithms value represents average independent experiments 343 464 table ii average values c latency divided c worm rprr value represents independent experiments practice r fast algorithms bitserial routing hypercube performance analysis kary ncube interconnection networks comprehensive analytical model wormhole routing multicomputer systems necessary sufficient condition deadlockfree adaptive routing wormhole networks theory wormhole routing parallel computers fatpyramid robust network parallel computation fatpyramid universal parallel computation independent wire delay randomized routing fattrees packet routing networks long wires performance study wormhole routed networks analytical modeling experimentation parallel sorting algorithm experimental study virtual new computer communication switching technique randomized routing sorting fixedconnection networks packet routing jobshop scheduling ocongestion average case analysis greedy routing algorithms arrays fattrees universal networks hardwareefficient supercomputing network architecture connection machine cm5 framework adaptive routing multicomputer networks efficient communication schemes massively parallel computers critique adaptive routing hot spot contention combining multistage interconnection networks nearly tight bounds wormhole routing sorting meshconnected parallel computer bridging model parallel compu tation tr ctr cicerone gabriele di stefano michele flammini static dynamic lowcongested interval routing schemes theoretical computer science v276 n12 p315354 april 6 2002
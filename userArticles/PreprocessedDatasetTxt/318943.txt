efficient pointsto analysis wholeprogram analysis function programs written languages c make extensive use pointers automated software engineering tools require safe alias information existing aliasanalysis techniques sufficiently efficient analysis large software systems may provide alias information imprecise tools use imprecision alias information may 1 reduce precision information provided tools 2 increase cost tools paper presents flowinsensitive contextsensitive pointsto analysis algorithm computes alias information almost precise computed andersens algorithm precise flow contextinsensitive algorithm almost efficient steensgaards algorithm efficient flow contextinsensitive algorithm empirical studies show algorithm scales large programs better andersens algorithm show flowinsensitive alias analysis algorithms algorithm andersens algorithm compute alias information close precision computed expensive flow contextsensitive alias analysis algorithms b introduction many automated tools proposed use software engineering function programs written languages c make extensive use pointers tools require alias information determines sets memory locations accessed dereferences pointer variables atkinson griswold discuss issues must considered integrating alias information wholeprogram analysis tools argue effectively apply tools large programs aliasanalysis algorithms must fast thus propose approach uses steensgaards algorithm 16 flow contextinsensitive aliasanalysis algorithm 1 runs nearlinear time provide flowsensitive algorithm considers order statements program flowinsensitive algorithm contextsensitive algorithm considers legal callreturn sequences procedures program contextinsensitive algorithm alias information tools however experiments show many cases steensgaards algorithm computes imprecise alias information 13 18 imprecision adversely impact performance wholeprogram analysis wholeprogram analysis affected imprecise alias information two ways first imprecise alias information decrease precision information provided wholeprogram analysis preliminary experiments show sizes slices computed using alias information provided steensgaards algorithm almost ten percent larger sizes slices computed using precise alias information provided landi ryders algorithm 11 flowsensitive contextsensitive aliasanalysis algorithm sec ond imprecise alias information greatly increase cost wholeprogram analysis empirical studies show take slicer five times longer compute slice using alias information provided steensgaards algorithm compute slice using alias information provided landi ryders algorithm similar results reported 13 results indicate extra time required perform wholeprogram analysis less precise alias information might exceed time saved alias analysis steensgaards algorithm one way improve efficiency wholeprogram analysis tools use precise alias information precise alias information provided flowsensitive contextsensitive algorithms eg 5 11 17 potentially large number iterations required algorithms however makes costly time space thus expensive applicable large programs andersens algorithm 1 another flowinsensitive contextinsensitive aliasanalysis algorithm provides precise alias information steensgaards algorithm less cost flowsensitive contextsensitive al gorithms algorithm however may require iteration among pointerrelated assignments 2 3 program size requires entire program memory analysis thus algorithm may still expensive time space applicable large programs approach providing alias information sufficiently precise use wholeprogram analysis maintaining efficiency incorporate callingcontext flowinsensitive aliasanalysis algorithm compute procedure alias information holds statements proce dure algorithm three phases first phase algorithm uses approach similar steensgaards process pointerrelated assignments compute alias information procedure program second phase algorithm uses bottomup approach propagate alias information called procedures callees calling procedures callers finally third phase algorithm uses topdown approach propagate alias information callers callees 3 pointerrelated assignment statement change value pointer variable 3 future work includes extending algorithm handle function pointers using approach similar discussed reference 2 paper presents aliasanalysis algorithm main benefit algorithm efficiently computes alias solution high precision like steensgaards algorithm algorithm efficiently provides safe alias information processing pointerrelated assignment however algorithm computes separate pointsto graph procedure single procedure typically contains pointerrelated variables signments algorithm computes alias sets much smaller computed steensgaards algorithm provides alias information almost precise computed andersens algorithm another benefit algorithm modular procedures stronglyconnected component call graph memory thrice phase algorithm suitable andersens analyzing large programs paper also presents set empirical studies investigate efficiency precision three flowinsensitive algorithms algorithm steensgaards algorithm andersens algorithm landi ryders flowsensitive algorithm 11 b impact alias information provided four algorithms wholeprogram analysis studies show number interesting results programs studied algorithm andersens algorithm compute solution close precision computed flow contextsensitive algorithm programs andersens algorithm requires large amount time algorithm compute alias information time close steens gaards algorithm thus may scale large programs better dersens algorithm alias information provided algorithm andersens algorithm landi ryders algorithm greatly reduce cost constructing systemdependence graphs performing dataflow based slicing algorithm almost effective andersens algorithm landi ryders algorithm improving performance constructing system dependence graphs performing dataflow based slicing results indicate algorithm provide sufficiently precise alias information wholeprogram analysis efficient way thus may effective algorithm among four supporting wholeprogram analysis large programs flowinsensitive contextinsensitive aliasanalysis algorithms flowinsensitive contextinsensitive aliasanalysis algorithms compute alias information holds every program point algorithms process pointer related assignments program arbitrary order replace call statement set assignments represent bindings actual parameters formal parameters algorithms compute safe alias information points relations pointerrelated assignment set locations pointed int incrptrint ptr return ptr1 22 incrptr buf2 p input ptr buf1 q r incrptr buf2 p input ptr buf1 q r incrptr buf2 p input ptr buf1 q r 3 int input10 input input input h17 h18 incrptr ptr input buf2 buf1 q r incrptr ptr input buf2 buf1 q r incrptr ptr input buf2 buf1 q r b input input c fig 1 example program pointsto graph using steensgaards algorithm b pointsto graph using andersens algorithm c lefthand side superset set locations pointed righthand side view steensgaards algorithm andersens algorithm building pointsto graphs 14 4 vertices pointsto graph represent equivalence classes memory locations ie variables heapallocated objects edges represent pointsto relations among locations steensgaards algorithm forces locations pointed pointer equivalence class processes pointerrelated assignment forces lefthand righthand sides assignment point equivalence class using method new pointerrelated assignments processed pointsto graph remains safe previouslyprocessed pointer related assignment method lets steensgaards algorithm safely estimate alias information processing pointerrelated assignment figure 1b shows various stages construction pointsto graph example program figure 1a using steensgaards algorithm top graph labeled b1 shows pointsto graph initial stage pointers except input point empty equivalence classes steensgaards 4 points graph similar alias graph 3 algorithm processes statement 6 merges equivalence class pointed input equivalence class pointed p merged equivalence class illustrated dotted box steensgaards algorithm processes statement 7 similarly merged equivalence class illustrated dashed box algorithm processes statements 10 11 14 simulating bindings parameters return values assignments shown solid boxes figure 1 middle graph labeled b2 shows pointsto graph steensgaards algorithm processed main represent objects returned malloc steensgaards algorithm processes statements 17 18 uses h hstatement numberi bottom graph labeled b3 shows pointsto graph steensgaards algorithm processes entire program graph illustrates steensgaards algorithm introduce many spurious pointsto relations andersens algorithm uses vertex represent one memory location algorithm processes pointerrelated assignment adding edges force lefthand side point locations pointsto set righthand side example algorithm processes statement 6 adds edge force p point input adding edges way however may cause alias information previouslyprocessed pointerrelated assignment unsafe pointsto set ss lefthand side superset pointsto set ss righthand side provide safe solution andersens algorithm iterates previously processed pointerrelated assignments pointsto graph provides safe alias solution figure 1c shows various stages construction pointsto graph using andersens algorithm example program top graph labeled c1 shows pointsto graph constructed andersens algorithm processes main algorithm processes statements 10 11 14 simulates bindings parameters using assignments shown solid boxes middle graph labeled c2 shows pointsto graph andersens algorithm processes statement 17 algorithm forces h 17 point buf1 causes alias information unsafe statement 7 provide safe solution andersens algorithm processes statement 7 subsequently requires statements 11 14 reprocessed bottom graph labeled c3 shows complete solution graph illustrates andersens algorithm compute smaller pointsto sets steensgaards algorithm pointer variables however andersens algorithm requires steps steensgaards algorithm 3 flowinsensitive contextsensitive pointsto analysis algorithm flowinsensitive contextsensitive pointsto analysis algorithm fics computes separate alias information procedure program section first present definitions use discuss algorithm next give overview algorithm discuss details algorithm input buf2 r buf1 input buf2 r buf1 input buf2 r buf1 incrptr ptr incrptr buf1 buf2 global global buf1 buf2 ptr incrptr ptr incrptr phase 1 phase 2 phase 3 input input buf1 buf1 buf2 buf1 buf2 incrptr incrptr buf2 fig 2 pointsto graphs constructed fics algorithm 31 definitions refer memory location program object name 11 consists variable possibly empty sequence dereferences field accesses say object name n 1 extended another object name constructed applying possibly empty sequence dereferences field accesses n 2 case denote n 1 e hn 2 n formal parameter object name actual parameter bound n call site c define function c returns object name e hai n global c returns e hni example suppose p pointer points struct field c language e hpi lambdap e hlambdapi p e hpi lambdapa another example p formal parameter function f lambdaq actual parameter bound p call site c f c lambdapa returns qa extend pointsto graphs represent structure variables field access edge labeled field name connects vertex representing structure vertex representing field structure pointsto edge labeled represents pointsto relation pointsto graph labels unique among edges leaving vertex given object name n fics find access path phngi pointsto graph g first fics locates creates vertex n 0 g n variable corresponds fics locates creates sequence vertices path g labels edges p match sequence dereferences field accesses n refer n k end vertex phngi associated vertex n g denote n k vhn gi note set memory locations associated vhn gi set memory locations aliased n 32 overview fics computes separate alias information procedure using pointsto graphs fics first computes pointsto graph gp procedure p processing pointerrelated assignment p using approach similar steens gaards algorithm none pointer variables appears p global variable formal parameter none pointer variables used actual parameter gp safely estimates alias information p ever pointer variables appear p global variables formal parameters pointer variables used actual parameters pointerrelated assignments procedures also introduce aliases related variables gp must processed capture aliases three cases pointerrelated assignments procedures introduce aliases related pointer variable appear p first case pointerrelated assignment another procedure forces e hgi g global variable appears p aliased memory lo cation fics consider order statements must assume alias pair holds throughout program thus fics must consider alias pair p example figure 1a statement 17 forces lambdabuf 1 aliased h 17 alias pair must propagated main main uses buf1 fics captures type alias pair gp two steps 1 computes global pointsto graph g glob estimate memory locations aliased possible global object name program 2 updates gp using alias information represented g glob second case assignment procedure called p forces e1 hf 1 aliased e2 hf 2 f 1 formal parameter f 2 either formal parameter global variable return value function viewed formal parameter alias pair e 1 hf 1 ie 2 hf 2 propagated called procedure p force c e 1 hf 1 aliased c e 2 hf 2 call site c example figure 1a statement 21 function incr ptr forces lambdaincr ptr aliased lambdaptr alias pair propagated back main forces lambdar aliased lambdaq fics maps alias pairs related formal parameters alias pairs related actual parameters updates gp alias pairs actual parameters third case assignment procedure calls p forces location l aliased e hai actual parameter bound f call site c p alias pair propagated p forces e hfi aliased l example statement 6 forces lambdap input alias pair main figure propagated incr ptr statement 10 forces lambdaptr input alias pair fics propagates type alias pairs calling procedure p updates gp fics three phases phase 1 processes pointerrelated assignments procedure initially builds pointsto graph procedure phase 2 phase 3 handle three cases discussed phase 2 propagates alias information called procedures calling procedures also builds pointsto graph global variables using alias information available far procedure phase 2 processes procedures reverse topological bottomup order stronglyconnected components call graph within stronglyconnected component phase 2 iterates procedures pointsto graphs procedures stabilize phase 3 propagates alias information pointsto graph global variables proce dure phase 3 also propagates alias information calling procedures called procedures phase 3 processes procedures topological top order stronglyconnected components call graph phase 3 iterates procedures component pointsto graphs procedures stabilize fics propagates information called procedures calling procedures phase 2 propagates information calling procedures called procedures phase 3 never propagate information invalid callreturn sequences therefore fics contextsensitive bottom graphs figure 2 depict pointsto graphs computed fics example program figure 1 graphs show using fics variables divided equivalence classes differently pointsto graphs different procedures example incr ptr h 17 h 18 input one equivalence class however main input different equivalence class h 17 h 18 fics creates separate pointsto graphs main init incr ptr computes precise alias solution steensgaards algorithm example program graphs also show fics computes smaller pointsto set p q andersens algorithm considers callingcontext solution computed andersens algorithm p must point locations pointed incr ptr calling context solution computed fics p points locations pointed incr ptr incr ptr invoked statement 10 calling context incr ptr points input 33 algorithm description figure 3 shows fics inputs p program analyzed outputs l list pointsto graphs one procedure one global variables phase 1 create pointsto graphs individual procedures first phase lines 17 fics processes pointerrelated assignments procedure p p compute pointsto graph gp fics first finds creates gp pointerrelated assignment rhs algorithm uses merge variant join operation steensgaards algorithm merge v 1 v 2 one vertex merge also merges successors v 1 v 2 properly labels unique among edges leaving new vertex phase fics ignores call sites except call sites memoryallocation functions call sites algorithm uses h hstatement numberi represent objects returned functions finally fics adds p w 1 w 2 adds gp l algorithm fics input p program analyzed output l list pointsto graphs one procedure one global variables declare gp list procedures sorted reversetopologically stronglyconnected components call graph list procedures sorted topologically stronglyconnected components call graph begin fics 1 foreach procedure p p phase 1 2 foreach pointerrelated assignment lhs rhs 3 find create v1 lhs v2 rhs gp 4 mergegp 5 endfor l 7 endfor 8 w1 6 oe phase 2 9 remove procedure head w1 10 foreach call site c p j p 11 bindactualsc gp 12 endfor 13 bindglobalglobalsgp g glob gp 14 bindlocglobalsgp 15 gp updated foreach p caller pk 17 pk w1 add pk w1 endif 18 endfor 19 endif 20 endwhile 21 w2 6 oe phase 3 22 remove procedure head w2 24 foreach call site c p p j 26 endfor 27 gp j updated 28 foreach p j callee p l 29 p l w2 add p l w2 endif 30 endfor 31 endif 32 endwhile fig 3 fics flowinsensitive contextsensitive aliasanalysis algorithm pointsto graphs top figure 2 constructed fics first phase main left init middle incr ptrright example program note pointsto relations introduced init pointsto relation buf1 h 17 yet represented mains pointsto graph following two phases fics gathers alias information callees callers p build gp phase 2 compute aliases introduced callsites create global pointsto graph second phase lines 820 procedure p fics computes aliases introduced p call sites call site c procedure calls bind find alias pairs e 1 hf 1 ie 2 hf 2 f 1 p j formal pointer parameters using depthfirst search gp j search begins vertices associated p j formal parameters pointer type looking possible pairs phe1 hf 1 vertex implies e1 hf 1 aliased e2 hf 2 bind maps type alias pair back p captures alias pairs gp merging end vertices pha c e 1 hf 1 gp pha c e 2 hf 2 gp gp example fics calls bind process call site statement 14 figure 1 bind finds alias pair lambdaptr lambdaincr ptr g incr ptr substitutes ptr q incr ptr r creates alias pair lambdaq lambdar merges also searches phe1 hfi gp j phe2 hgi gp j f formal pointer parameter g global variable end vertex similarly bind merges end vertices pha c e 1 hfi gp phe2 hgi gp gp phase fics also calls bindglobal compute global pointsto graph g glob alias information p bindglobal finds alias pairs global variables using depthfirst search gp search begins associated vertices global variables gp looks pairs access paths phe1 hg 1 one vertex bindglobal merges end vertices phe1 hg 1 phe2 hg 2 example fics processes main phase calls bindglobal search g main finds p hlambdabuf p hlambdabuf 2 g main end vertex thus fics merges v hlambdabuf v hlambdabuf 2 g glob fics also computes memory locations aliased e hgi g global location l equivalence class represented vhe hgi gp alias pair fics calls bindloc look vhe hgi gp using depthfirst search location l associated vhe hgi gp merges vhl g glob vhe hgi g glob capture alias pair example fics processes init phase merges vhh 17 g glob v hlambdabuf associated phase g glob complete phase 3 compute aliases introduced calling environment third phase lines 2132 fics computes sets locations represented vertices gp j completes computation gp j fics first computes locations vertices gp j g glob let g global variable appears gp j fics calls bindloc look vhe hgi gp j using depthfirst search bindloc copies memory locations vhe hgi g glob vhe hgi gp j example fics processes main example figure 1 copies h 17 h fics also computes locations vertices gp j gp given p calls p j call site c suppose bound formal parameter f c fics calls bindloc copy locations vhe hai gp vhe hfi gp j capture fact aliased locations e hai also aliased e hfi example fics copies input v hlambdap g main v hlambdaptr g incr ptr p bound ptr statement 11 phase set memory locations represented vertex complete complexity fics algorithm 5 theoretically possible construct program p o2 n distinguishable locations 15 n size p makes aliasanalysis algorithm discussed paper exponential time space size p practice however total distinguishable locations p structure p typically limited number fields let p number procedures p worstcase actual size pointsto graph computed procedure space complexity fics op n absence recursion procedure p processed phase thus bind bindglobal bindloc invoked onumofcall times presence recursion single change gp might require one propagation p callers one propagation p callees gp changes os times thus bind bindglobal bindloc invoked onumofcallp times pointsto graph implemented fast findunion structure invocation bind bindglobal bindloc requires os find operations fast findunion structure size op let n numofcall absence recursion n numofcall presence recursion time complexity fics sp sffn ff inverse ackermann function practice expect numofcall thus expect run fics time almost linear size program practice 4 empirical studies investigate efficiency precision fics impact wholeprogram analysis alias information various precision levels performed several studies compared algorithm steensgaards algorithm st 16 andersens algorithm 1 landi ryders algorithm lr 11 used prolangs analysis framework paf 6 implement pointsto graphs fics steensgaards algorithm ander sens algorithm used implementation landi ryders algorithm provided paf none implementations handles function pointers setjumplongjump constructs lefthand side table 1 gives information subset subject programs used studies 6 allow algorithms capture aliases introduced calls library functions created set stubs simulate effects functions aliases however create stubs functions would introduce aliases calls functions preliminary studies observed using stubs forces steensgaards algorithm introduce many additional pointsto relations example dixie 5 details complexity analysis fics found 12twmc moria used studies 2 3 slicer requires 10 hours time limit set slicing collect data table 1 subject programs time seconds compute alias solutions lines number number number program code cfg nodes procedures pras st fics lr loader 1132 819 ansitape 1596 1087 37 59 006 016 019 054 dixie 2100 1357 52 149 01 022 03 092 learn 1600 1596 50 129 008 02 035 147 smail simulator 3558 2992 114 83 011 038 034 143 flex 6902 3762 93 231 014 042 053 41028 space 11474 5601 137 732 062 177 464 11339 bison 7893 6533 134 1170 033 078 127 larn 9966 11796 295 642 037 12 12 mpeg play 17263 11864 135 1782 092 318 492 espresso 12864 15351 306 2706 421 1069 95716 moria 25002 20316 482 785 234 368 52182 using stubs functions would introduce aliases calls fics com putes average thruderef mod 18 2945 whereas using stubs computes average thruderef mod 2210 see study 1 study 1 study 1 compare performance precision steensgaards algorithm fics andersens algorithm landi ryders algorithm subject program recorded time required compute alias information time average number locations modified dereference righthand side table 1 shows running time algorithms subject programs 7 collected data running system sun ultra 1 workstation 128mb physical memory 256 mb virtual memory table shows subject programs flowinsensitive algorithms run significantly faster landi ryders algorithm table also shows small programs fics andersens algorithm running time close steensgaards algorithm however large programs andersens algorithm takes large amount time fics still runs time close steensgaards algorithm result suggests large programs fics efficient time andersens algorithm figure 4 shows average number thruderef mod four algorithms graph shows many programs steensgaards algorithm computes imprecise alias information might limit applicability dataflow analyses graph also shows subject programs fics computes alias solutions thruderef mod close computed andersens algorithm smail espresso fics computes smaller thrud mod andersens algorithm two programs functions similar incr ptr figure 1 andersens algorithm loses precision consider calling context graph shows 7 data landi ryders algorithm available seven programs analysis required 10 hours limit set analysis 62 433 fig 4 thruderef mod subject programs table 2 average number summary edges per call average time seconds compute summary edges call system dependence graph raw data steensgaard program st fics lr fics lr loader 465 23 195 11 195 11 199 11 419 474 419 478 428 500 ansitape 880 26 533 17 431 12 400 12 606 667 490 485 455 458 dixie 821 25 314 15 227 11 206 10 383 584 277 425 252 400 learn 1578 76 209 13 173 11 159 10 133 171 110 141 101 129 unzip 1979 94 738 40 687 34 402 21 373 429 347 364 203 221 smail simulator 979 20 736 12 736 12 535 10 751 624 751 626 546 503 flex 1156 121 620 80 579 75 550 74 536 661 501 619 476 613 space 7562 194 5639 104 5525 102 3839 75 746 534 731 527 508 385 bison 679 26 653 16 520 11 962 624 766 434 larn 36726 1829 9582 382 8087 309 261 209 220 169 mpeg play 1306 322 946 239 940 218 724 742 720 677 solutions computed fics andersens algorithm close computed landi ryders algorithm result suggests many dataflow problems aliases obtained using fics andersens algorithm might provide sufficient precision note landi ryders algorithm uses klimiting technique collapses fields structure handle recursive data structures 11 pointsto set pointer p computed landi ryders algorithm may contain locations pointsto set p computed three flowinsensitive algorithms thus andersens algorithm provides smaller alias solution landi ryders algorithm loader space study 2 study 2 investigate impact alias information provided four algorithms size cost construction one program representation systemdependence graph 10 8 study average number summary edges per call cost compute summary edges system dependence graph summary edges computed slicing procedure respect memory location modified procedure using harrold cis slicer 7 thus time required compute summary edges might differ time required compute summary edges using methods eg 10 nevertheless approach provides fair way compare costs computing summary edges using alias information different precision levels table 2 shows results study obtained results sun ultra workstation 640mb physical memory 1gb virtual memory table shows using precise alias information provided fics andersens algorithm landi ryders algorithm effectively reduce average number summary edges per call time compute summary edges construction systemdependence graph 9 table shows subject programs using alias information provided fics almost effective using alias information provided andersens algorithm algorithm even effective andersens algorithm espresso algorithm computes smaller pointsto set pointer variables results suggest fics preferable andersens algorithm building systemdependence graphs large programs fics run significantly faster andersens algorithm large programs study 3 study 3 investigate impact alias information provided four aliasanalysis algorithms sizes slices cost computing slices obtained slices running harrold cis slicer slicing criterion interest without stored reuse information table 3 shows results study obtained results sun ultra workstation 640mb physical memory 1gb virtual memory table shows subject programs using precise alias information computed steensgaards algorithm significantly reduce time compute slice table also shows four programs using precise alias information significantly 10 reduce sizes slices four programs illustrate exceptions conclusion drawn shapiro horwitz 13 sizes slices hardly affected precision alias information note five programs slicer computes larger slices using alias information provided landi ryders algorithm using provided fics andersens algorithm pointsto set computed landi ryders algorithm pointer p contains memory locations pointsto set computed steensgaards fics andersens algorithms p table shows using alias information 8 systemdependence graph used slice program computing summary edges expensive part constructing graph 9 similar results time reported 13 steensgaards shapiros andersens algorithms compared table 3 average size slice average time seconds compute slice raw data steensgaard program st fics lr fics lr loadery 207 53 192 34 192 33 194 35 930 641 930 634 938 665 ansitapey 290 166 284 96 277 53 300 49 981 581 957 322 1035 297 dixiey 705 255 704 83 704 59 699 55 999 327 999 231 992 217 learny 442 254 442 176 442 114 440 168 1000 690 999 449 995 660 unzipy 808 375 807 131 807 108 805 93 999 350 998 289 996 249 smaily 738 1765 637 961 635 754 863 545 861 427 simulatory 1258 548 1087 225 1087 227 1151 242 864 411 864 413 915 442 flexz 2025 2202 2019 1673 2019 1538 2002 1598 997 760 997 699 989 726 spacez 2234 13739 1936 5735 1936 5698 2086 4673 867 417 867 415 934 340 bisonz 2394 949 2394 841 2338 410 1000 886 977 432 larnz 6626 34773 6602 10756 6592 9024 996 309 995 260 mpeg playz 5708 3255 3935 1346 3935 1395 689 413 689 429 espressoz 6297 83321 6291 37765 6264 53671 999 453 995 644 data collected slices program z data collected one slice provided fics almost effective using alias information provided andersens algorithm computing slices supports conclusion fics preferable andersens algorithm wholeprogram analysis 5 related work many dataflow analysis algorithms eg 9 10 including fics use twophase interprocedural analysis framework first phase information propagated called procedures calling procedures call statement encountered summaries called procedure used avoid propagating information called procedure second phase information propagated calling procedures called procedures recently chatterjee et al 4 use unknown initial values parameters global variables summaries procedure computed flowsensitive alias analysis 10 use twophase interprocedural analysis framework compute flow contextsensitive alias information although algorithm improve worst case complexity landi ryders algorithm 11 computing alias information precision still costly practice furthermore comparison two algorithms reported known much chatterjee et als algorithm outperforms landi ryders algorithm number attempts design algorithms compute alias information efficiency close steensgaards algorithm precision close andersens algorithm shapiro horwitz 14 propose method divides program variables k categories allows variables belonging category equivalence class thus similar fics method computes smaller equivalence classes provides smaller pointsto set pointer variable steensgaards algorithm fics differs method however uses independent set equivalence harrold rothermel used similar approach 8 classes procedure thus fics benefit fact procedure references small set program variables fics also differs method fics contextsensitive information propagated invalid callreturn sequences finally fics differs shapiro horwitzs algorithm fics handle fields structures whereas al gorithm assignments field structure treated assignments structure last difference difficult compare experimental results however experimental results reported reference 14 appears average fics computes alias information closer andersens precision algorithm 6 conclusions presented flowinsensitive contextsensitive pointsto analysis algorithm conducted several empirical studies 20 c programs compare algorithm aliasanalysis algorithms empirical results show although steensgaards algorithm fast alias information computed algorithm imprecise used wholeprogram analysis empirical results show using precise alias information provided algorithm andersens algorithm landi ryders algorithm effectively improve precision reduce cost wholeprogram anal ysis however empirical results also show andersens algorithm landi ryders algorithm could costly analyzing large programs contrast empirical results show algorithm compute alias information almost precise computed andersens algorithm running time within six times steensgaards algorithm thus algorithm may effective algorithms supporting wholeprogram analysis future work includes performing additional empirical studies especially large subject programs compare algorithm alias analysis algorithms also conduct studies see imprecision alias information computed algorithm affect various wholeprogram analyses acknowledgements work supported part grants microsoft inc nsf nyi award ccr9696157 ess award ccr9707792 ohio state university thank anonymous reviewers made many helpful suggestions improved presentation paper r program analysis specialization c programming lan guage effective wholeprogram analysis presence pointers relevant context inference programming languages research group separate computation alias information reuse efficient computation interprocedural definitionuse chains interprocedural slicing using dependence graphs safe approximate algorithm interprocedural pointer aliasing effects precision pointer analysis fast accurate flowinsensitive pointsto analysis efficient contextsensitive pointer analysis c programs program decomposition pointer analysis step toward practical analyses tr interprocedural slicing using dependence graphs safe approximate algorithm interprocedural aliasing efficient computation interprocedural definitionuse chains contextsensitive interprocedural pointsto analysis presence function pointers efficient contextsensitive pointer analysis c programs separate computation alias information reuse pointsto analysis almost linear time program decomposition pointer aliasing fast accurate flowinsensitive pointsto analysis effective wholeprogram analysis presence pointers relevant context inference reusedriven interprocedural slicing flowinsensitive interprocedural alias analysis presence pointers effects presision pointer analysis pointsto analysis type inference programs structures unions ctr donglin liang maikel pennings mary jean harrold evaluating precision static reference analysis using profiling acm sigsoft software engineering notes v27 n4 july 2002 atanas rountev satish chandra offline variable substitution scaling pointsto analysis acm sigplan notices v35 n5 p4756 may 2000 donglin liang mary jean harrold lightweight context recovery efficient accurate program analyses proceedings 22nd international conference software engineering p366375 june 0411 2000 limerick ireland manuel fhndrich jakob rehof manuvir das scalable contextsensitive flow analysis using instantiation constraints acm sigplan notices v35 n5 p253263 may 2000 manuvir das unificationbased pointer analysis directional assignments acm sigplan notices v35 n5 p3546 may 2000 donglin liang maikel pennings mary jean harrold extending evaluating flowinsenstitive contextinsensitive pointsto analyses java proceedings 2001 acm sigplansigsoft workshop program analysis software tools engineering p7379 june 2001 snowbird utah united states donglin liang mary jean harrold equivalence analysis general technique improve efficiency dataflow analyses presence pointers acm sigsoft software engineering notes v24 n5 p3946 sept 1999 markus mock manuvir das craig chambers susan j eggers dynamic pointsto sets comparison static analyses potential applications program understanding optimization proceedings 2001 acm sigplansigsoft workshop program analysis software tools engineering p6672 june 2001 snowbird utah united states ana milanova atanas rountev barbara g ryder precise call graphs c programs function pointers automated software engineering v11 n1 p726 january 2004 jamieson cobleigh lori clarke leon j osterweil right algorithm right time comparing data flow analysis algorithms finite state verification proceedings 23rd international conference software engineering p3746 may 1219 2001 toronto ontario canada markus mock darren c atkinson craig chambers susan j eggers program slicing dynamic pointsto sets ieee transactions software engineering v31 n8 p657678 august 2005 david j pearce paul h j kelly chris hankin efficient fieldsensitive pointer analysis c proceedings acmsigplansigsoft workshop program analysis software tools engineering june 0708 2004 washington dc usa markus mock darren c atkinson craig chambers susan j eggers improving program slicing dynamic pointsto data acm sigsoft software engineering notes v27 n6 november 2002 markus mock darren c atkinson craig chambers susan j eggers improving program slicing dynamic pointsto data proceedings 10th acm sigsoft symposium foundations software engineering november 1822 2002 charleston south carolina usa donglin liang mary jean harrold equivalence analysis application improving efficiency program slicing acm transactions software engineering methodology tosem v11 n3 p347383 july 2002 sigmund cherem radu rugina region analysis transformation java programs proceedings 4th international symposium memory management october 2425 2004 vancouver bc canada amie l souter lori l pollock omen strategy testing objectoriented software acm sigsoft software engineering notes v25 n5 p4959 sept 2000 michael hind anthony pioli pointer analysis use acm sigsoft software engineering notes v25 n5 p113123 sept 2000 chris lattner andrew lenharth vikram adve making contextsensitive pointsto analysis heap cloning practical real world acm sigplan notices v42 n6 june 2007 brian hackett radu rugina regionbased shape analysis tracked locations acm sigplan notices v40 n1 p310323 january 2005 g ryder safe approximate algorithm interprocedural pointer aliasing acm sigplan notices v39 n4 april 2004 alessandro orso saurabh sinha mary jean harrold classifying data dependences presence pointers program comprehension testing debugging acm transactions software engineering methodology tosem v13 n2 p199239 april 2004 sandrine blazy specifying automatically generating specialization tool fortran 90 automated software engineering v7 n4 p345376 december 2000 jongdeok choi manish gupta mauricio j serrano vugranam c sreedhar samuel p midkiff stack allocation synchronization optimizations java using escape analysis acm transactions programming languages systems toplas v25 n6 p876910 november chris lattner vikram adve automatic pool allocation improving performance controlling data structure layout heap acm sigplan notices v40 n6 june 2005 david binkley mark harman analysis visualization predicate dependence formal parameters global variables ieee transactions software engineering v30 n11 p715735 november 2004 martin hirzel daniel von dincklage amer diwan michael hind fast online pointer analysis acm transactions programming languages systems toplas v29 n2 p11es april 2007 michael hind pointer analysis havent solved problem yet proceedings 2001 acm sigplansigsoft workshop program analysis software tools engineering p5461 june 2001 snowbird utah united states david binkley nicolas gold mark harman empirical study static program slice size acm transactions software engineering methodology tosem v16 n2 p8es april 2007 david j pearce paul h j kelly chris hankin online cycle detection difference propagation applications pointer analysis software quality control v12 n4 p311337 december 2004 barbara g ryder william landi philip stocks sean zhang rita altucher schema interprocedural modification sideeffect analysis pointer aliasing acm transactions programming languages systems toplas v23 n2 p105186 march 2001 baowen xu ju qian xiaofang zhang zhongqiang wu lin chen brief survey program slicing acm sigsoft software engineering notes v30 n2 march 2005
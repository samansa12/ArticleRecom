modeling hardware synthesis methodology isabelle formal synthesis methodology developed university kent combining circuit design verification circuit constructed proof meets given formal specification reinterpreted methodology isabelles theory higherorder logic circuits incrementally built proofs using higherorder resolution interpretation simplifies extends formal synthesis conceptually implementation also supports integration development style proofbased synthesis methodologies leads techniques developing new classes circuits eg recursive descriptions parametric designs b introduction verification formal proof time intensive burden bringing formal methods software hardware design one approach reducing verification burden combine development verification using calculus development steps either guarantee correctness since proof steps parallel design steps allow early detection design errors present approach using resolution synthesize circuit designs proofs correctness approach based modeling particular methodology hierarchical design development within synthesis resolution framework starting point novel methodology hardware synthesis called formal synthesis proposed veritas group kent 7 formal synthesis one starts design goal specifies behavioral properties circuit constructed interactively refines design using small powerful set techniques allows developer hierarchically decompose specifications introduce subdesigns library components natural way internally technique consists pair functions subgoaling function validation function former decomposes specification spec sub specifications spec latter takes proofs circ achieve spec constructs implementation circ proof circ achieves spec refinement finished system composes validation functions applied constructs theorem synthesized circuit satisfies original design goal make clearer consider one simpler techniques called split subgoaling function reduces design goal spec 1 spec 2 two new design goals one conjunct validation function based rule explains combine implementations achieve subgoals implementation achieves original goal kind topdown problem decomposition spirit lcf style tactics designing good set techniques analogous designing appropriate set tactics problem domain however tactics decompose goal subgoals validation proves original goal whereas techniques validation proves different theorem altogether formal synthesis separates design goals techniques ordinary theoremproving goals tactics conceptual separation different sorts entities different semantics moreover treated differently implementation formal synthesis required extending veritas theorem prover show reinterpret formal synthesis deductive synthesis based higherorder resolution begin final theorem formal synthesis validations deliver circuit achieves stated specification however circuit given front instead named metavariable proof proceeds applying rules isabelle correspond veritas validation rules like 1 rule application uses resolution metavari able incrementally instantiated synthesized circuit let us illustrate split technique goal simplifying slightly prove theorem like circspec question mark means circ metavariable spec conjunction spec 1 spec 2 resolve circspec 1 spec 2 rule 1 result substitution circ imp 1 imp 2 subgoals imp 1 spec 1 imp 2 spec 2 refinement subgoals generate instances imp hence circ number advantages reinterpretation conceptually simple away subgoal validation functions let resolution construct circuits simple implement changes required isabelle system instead derive rules program tactics appropriate extension isabelles theory higherorder logic hol moreover reinterpretation makes easy implement new techniques compatible formal synthesis style development past worked rules tactics synthesis logic programs 1 programs similar circuits described conjunctive combinations primitive relations existential quantification used pass values moving formal synthesis similar theorem proving setting could adapt apply many tactics rules logic programming synthesis circuit synthesis example rules developing recursive programs yield new techniques developing parameterized classes circuits also exhibit cf section 6 kind rules used resolutionbased development lambda system compatible reinterpretation background assume familiarity isabelle 10 higherorder logic space limitations restrict us reviewing notation essentials isabelle interactive tacticbased theorem prover logics encoded isabelles metalogic declaring theory signature set axioms example propositional logic might type f orm formulae constructors like typical proof rule would b b implication universal quantification isabelles metalogic outermost metaquantifiers often omitted iterated implication written readable list notation eg b implicitly quantified variables treated metavariables instantiated applying rule using higherorder unification work use isabelles theory higherorder logic extended theories sets well founded recursion natural numbers like isabelle supports proof construction higherorder resolution given proof state subgoal proof rule unify oe succeeds unification yields substitution oe proof state updated applying oe replacing subgoals oeoe unification used apply rules proof state may contain metavariables use synthesize circuits proofs note proof rule read intuitionistic sequent oe hypotheses isabelles resolution tactics apply rules way maintains illusion working sequents often refer oe assumptions veritas 8 tactic based theorem prover similar isabelle hol higherorder logic augmented constructions type theory eg standard type constructors dependent function space product subtype used reason hardware one proves theorems relate circuits circ specifications spec eg external port names common hardware represented relationally primitive constructors eg transistors gates etc relations combined conjunction wired together using existential quantification 3 variables p1 typed primary difference veritas similar systems one use richer types specifications example defining circuits operating 8bit words would formalize requirement wordlength types 3 formal synthesis formal synthesis based techniques previously indicated technique combines subgoaling function validation validations executed derivation completed build proof circuit achieves im plementation giving techniques introduce notation used formal synthesis design specification spec implemented written 2spec 2 symbol relationship modal logics formula thm proved written thm term tm demonstrated well typed written 3tm proof veritas associated support name subgoaling rule validation rule impspec reveal 29dec spec 9dec imp9decspec inside 2circ b dec spec ports library 2library part args library part argslibrary part args subdesign 2spec let c b design 2subdesign args subdesign argssubdesign args proof thm pitm thm tm table 1 veritas design techniques signature contains theory used eg datatype definitions definitions predicates like veritas signature extended dynamically proof technique extends signature goal spec written extensionspec finally initial design goal must form circ name assigned circuit eight techniques adequate develop combinational circuit structured hierarchical way subgoaling validation functions based rules subgoaling rules read top implement goal line solve subgoals line validation rules operate opposite direction goal line established proofs goals line rules behave follows claim subgoaling function yields new design goal spec 0 subgoal suffices spec validation based transitivity split subgoaling function decomposes conjunctive specification problem implementing conjunct validation constructs design designs two subparts reveal shifts internally quantified ports signature allowing refinement inside since initial design goal given lambda abstraction technique needed remove binding implement circuit circ means implement specification spec validation theorem states implementation correct portvalues appear ports port declared declaration dec library subgoaling function imports components database predefined circuits validation corresponds use lemma subdesign subdesign submitted lambda abstraction may intro duced must implemented second subgoal may used proving original design goal first subgoal design like library technique enables user apply design already implemented case implementation subdesign introduced design process proof veritas used prove theorem 4 implementation extension describe reinterpretation formal synthesis isabelle divide presentation several parts roughly correspond isabelle theories implemented circuit abstractions concrete technology technique reinterpretation new techniques 41 circuit abstractions concrete technology represent circuits relations portvalues model kinds signals sets use isabelles set theory hol imitate dependent types veritas logic hence quantifiers used encoding bound quantifiers isabelles set theory name connectives serve constructors circuits following definitions say types p w shortly definition derive rules characterize operators use rules subsequent proofs rather expanding definitions example using properties conjunction implication derive hence guaranteed correctness isabelle following rules relate join sat associating definitions characterization theorems increases comprehensibility provides abstraction change definitions reuse theories provided characterization theorems still derivable definitions second function distinguish circuit constructors propositional connectives restricts resolution eg join unify makes easier write tactics automate design using abstractions express correctness synthesized circuit respect specification quite adequate though simulate formal synthesis style proofs small problem application techniques reveal inside subdesign extend veritas signature direct analog dynamic signature extension isabelle model reveal inside using bounded quantification achieve effect similar signature extension adding declaration information assumptions proof state according rules set theory subdesign veritas extends signature new definition slightly trickier model regard new definition condition necessary validity correctness theorem express condition using ordinary implication course stating initial goal yet know definitions made use metavariable leave unknown thus theorem prove takes initial form analogous formal synthesis design goals call theorem design theorem constant simply identity function defdefinitions serves kind definition context time definition made definitions instantiated conjunction definition fresh metavariable instantiated definitions made later design theorem wires bound types types defined theories concrete technologies eg representations voltage signals like simple instance port values range datatype bin voltage takes either value lo hi use isabelles hol set theory define set bin containing two elements afterwards derive standard rules bin eg caseanalysis binary values extend theory tactics automate common kinds reasoning binary values example tactics perform exhaustive analysis port values quantified bin tactics combine case analysis isabelles simplifier heuristic based proof procedure fast tac hol tactics automate almost standard kinds reasoning combinational circuits extend voltage theory theory gates declares types gates axiomatizes behavior example gate predicate type bin bin bin bool whose behaviour axiomatized axioms form part library circuit specifications used synthesize parts circuits 42 reinterpreting techniques implemented tactics simulate first seven techniques proof technique simply call prover table 2 lists tactics derived rules corresponding veritas techniques tactics based reveal reveal tac inside inside tac library library tac dels elims thm subdesign subdesign tac str design design tac dels elims table 2 isabelle techniques name tactic rule derived rules correspond validation rule associated veritas technique function mostly self explanatory claim split tactics apply rules direct translations corresponding veritas validation rules specification spec 0 supplied string str claim tac reveal inside identical veritas techniques except internal wiring quantification ports converted quantification metalevel type constraints expressed isabelles hol settheory become assumptions rules state implementation satisfies spec ification wire signal port inside hide internal wiring reveal reveal tac inside tac apply respective rule many times possible specified goal library library tac solves design goal r using previously implemented design supplied user rule form implication elimination first subgoal instantiated components design theorem second solved extending definition context overall design third establishes correctness design using specification library component involves type checking ports depends concrete technology designs hence supply tactic additional elimination deletion rules solve type checking goals subdesign given informal rule schema others formally derived represents infinitely many rules arbitrarily many quan tifiers indicated ellipses subdesign tac simulates effect applying rule user gives design goal subdesign implemented form initial goal three new subgoals generated tactic first corresponds subdesign definition tactic discharges adding definition context main design second subgoal commits us implement subdesign third allows us use subdesign proving original subgoal design solves design goal using previously introduced subdesign subdesign given design goal part assumptions goal solved tactic removes port quantifiers assumption repeatedly applying associated rule port new subgoal generated concerns type port solved library technique hence provide lists type checking rules tactic proof general proof goals arise application claim rule undecidable general must proven user 43 extensions calculus techniques defined formal synthesis effective developing combinational circuits however nontrivial circuits often best developed instances parametric designs example rather designing 16bit adder preferable develop one parameterized wordlength afterwards compute particular instances developed new techniques compatible reinterpretation formal synthesis construct parameterized circuits structural induction used build parameterized linear circuits generally ndimensional grids courseofvalues induction used build general recursively defined designs consider courseofvalues induction later apply build treestructured addition circuit idea extensions motivated previous work calculi isabelle synthesizing recursive logic programs 1 developed rules tactics based induction extend definition contexts templates function predicate name metavariable standing body recursive definitions leave user goal prove use induction hypothesis builds recursive program past work much common techniquebased calculus circuits syntactically logic programs circuits similar described conjunctive combinations primitive relations existential quantification passes val ues turns could minor adaptation directly use rules tactics developed synthesizing logic programs build recursive circuits find kind reuse concepts also actual rules tactics attractive advantage interpreting different synthesis methodologies common framework address point section 6 consider techniques developed lambda system also applied formal synthesis setting construct parameterized circuit proving parameterized design orem design theorem outermost quantifier quantifiers ranges inductively defined datatype like natural numbers eg specifies implementation whose size depends number n use induction instantiate circ recursively specified design isabelles hol comes theory natural numbers given inductive definition easy derive following courseofvalue induction rule use rule basis tactic cov induct tac functions following rule schema applied rule applied higherorder resolution spec unify specification design theorem circ metavariable standing circuit first subgoal sets parameterized circuit definition equality circ defined equal definition metavariable tactic discharges subgoal adding definitions main design leaves us second goal design goal however build circuit named definition instantiating subsequent proof steps instantiate definition circ moreover new assumption induction hypothesiswhich states circ achieves spec smaller values k reduce problem implementing smaller design resolve induction hypothesis build recursive design instantiating definition body circ instance circ works practice become clearer section 52 parameterized specifications require parameterized input types eg rather input ports parameterized input busses support develop theory busses encoded lists specified lengths possibilities allows us directly use isabelles list theory definitions follows bus b bus n list length n whose members set b functions upper lower return upper lower n bits exist bus b ln returns nth element bus proven many standard facts definitions eg decompose busses 5 examples present two examples first example comparator developed using formal synthesis 7 illustrates directly mimic formal synthesis create hierarchical designs second example uses induction construct parameterized treeshaped adder 51 comparator cell comparator takes input two words b representing numerals determines relative order ie three cases b holds circuit built ripplecarry fashion comparator cells cells lefthand figure figure 1 compare bit b also input three bits one case result previous comparisons grin eqin lsin output three bits grout eqout lsout behavioral specification compcellsa b grin eqin lsin grout eqout lsout function vl defined theory binary values submit following design theorem isabelle port abin bbin grinbin eqinbin lsinbin groutbin eqoutbin lsoutbin compcellsa b grin eqin lsin grout eqout lsout apply initialization tactic sets design goal implication introduction moves definition context assumption list applies inside tactic yields following proof state elide information typing ports compcellsa b grin eqin lsin grout eqout lsout 1 b grin eqin lsin grout eqout lsout grin eqin lsin grin eqin lsin b b bitcomp compcell lsout eqout grout grout eqout lsout fig 1 compcell claimed implementation original goal given firstthree lines contains two metavariables circ h standing implementation compcells definitions made respectively also present following lines contain subgoal must established prove original goal instantiated proving subgoal next introduce new subdesign bitcomp use component idea first compare two bits b representing current digit combine result comparison information coming comparisons less significant bits give result specification bitcomp subdesign following apply subdesign tac yields two subgoals top see original goal definition context h extended definition bitcomp new metavariable g definitions first subgoal design theorem subdesign second original design theorem additional assumption implementation subdesign satisfies specification bitcomps port abin bbin grbin eqbin lsbin compcellsa b grin eqin lsin grout eqout lsout 1 2 b grin eqin lsin grout eqout lsout bitless bitless bitcomp bitless ls eq gr z x fig 2 claimed implementations bitcomp bitless given subdesign use claim tac state following specification entails original goal figure 1 ex grbin eqbin lsbin xbin ybin andseq eqin eqout andseq lsin ls orsls lsout due space limitations sketch remaining proof first show claimed specification entails original one prove automatically using tactic performs caseanalysis simplification implement using reveal tac strip existential quantifications introduce internal wires use split tac break conjunctions join together subcircuits components implemented either introducing simpler subdesigns implementing see using library tac accesses appropriate library parts using design tac apply developed subdesigns let us sketch one remaining tasks implementing subdesign bitcomps proceed manner earlier introduce new subdesign bitless build bitcomp using bitless twice shown figure 2 finally bitlesss simple claim direct implementation consisting components library steps design theorem proved following port xbin ybin zbin bitlessx z andeq eqin eqout join andeq lsin ls join orls lsout sat compcellsa b grin eqin lsin grout eqout lsout metavariable h become instantiated conjunction definitions subdesigns used implementation main design goal ie bitcomp bitless main goal unknown circ become predicate represents structure desired circuit built subdesigns additional gates overall proof builds circuit uses identical sequence technique applications presented 7 difference much techniques applied rather underlying conceptualization implementation veritas system implementation constructed end proof validation functions whereas setting design takes shape incrementally proof find advantageous since directly see effects design decision taken 52 carry lookahead adder second example illustrates wellfounded induction technique synthesizes parameterized designs synthesize carry lookahead adder henceforth claadder parametric bitwidth n nbit numbers adder height proportional logn thus computes sum carry co two numbers b incoming carry c ologn time instead propagating carry digit digit done ripplecarry adder compute detailed information cf 9 generate bit g indicates carry generated adding digits b propagate bit indicates incoming carry handed information obtain carry bit co adder following way hi hi carry lookahead adder implemented roughly speaking recursively decomposing two adders half size original propagate generate bits overall adder obtained combining corresponding bits subparts incoming carry c case adding single digits b base case recursion propagate bit corresponds logical generate bit corresponds logical digits adder synthesize built two components figure 3 first cla computes sum propagate bit p generate bit g numbers b incoming carry c second auxiliary component aux used combine propagate bit generate bit incoming carry outgoing carry co component consists two gates derived steps focus development interesting component cla specify behavior using data abstraction arithmetic expression clasnabspgci case g hi note numbers represented busses ie bit vectors value bus natural number given val assume busses nonzero length hence following design theorem restrict induction set nnat1 natural numbers greater zero bus n bbin bus n sbin bus n pbin gbin cibin n cla carry lookahead adder aux b ci aux co x fig 3 implementation claadder two components begin shifting definition environment defh sumptions apply courseofvalues induction tactic yields following proof state bus n bbin bus n sbin bus n pbin gbin cibin clan b p g nnnat1 port abin bus n bbin bus n sbin bus n pbin gbin cibin clan b p g ci sat clasn b p g ci 1 n port abin bus clak b p g ci sat clask b p g ci abin bus n bbin bus n sbin bus n pbin gbin cibin d16n b p g ci sat clasn b p g ci previously described h extended definition template definitions collected q2 metavariable lefthand side definition serves name design defined metavariable righthand side instantiated implementation prove subgoal 1 induction hypothesis added assumptions subgoal may assume implementation k less n use build circuit size n proceed performing case analysis n type byiftac n1 1 resolves subgoal 1 rule p instantiated bus n bbin bus n sbin bus n pbin gbin cibin clan b p g clabase b cla c c aux aux carry carry c lower upper lower lower upper l l l b u u b u cla fig 4 base case left recursive decomposition middleright nnnat1 port abin bus n bbin bus n sbin bus n pbin gbin cibin clan b p g ci sat clasn b p g ci 1 n b p g ci port abin bus clak b p g ci sat clask b p g ci abin bus n bbin bus n sbin bus n pbin gbin cibin c23n b p g ci sat clasn b p g ci 2 n b p g ci port abin bus clak b p g c sat clask b p g ci abin bus n bbin bus n sbin bus n pbin gbin cibin n 1 c23n b p g ci sat clasn b p g ci overall design goal righthand side definition instantiated conditional whose alternatives c23 c 0 respective implementations base step case former implemented proving subgoal 1 assumption latter proving subgoal 2 assumption n 6 1 base case solved subdesign cla base figure simple steps step case build adder two smaller adders half size decompose busses b segment lowern div 2 containing inferior n div 2 bits bus segment uppern div 2nmod 2 containing remaining bits lower upper segments b added adder bitwidth n div 2 n div 2nmod 2 yielding lower upper segment sum propagate generate carry bit overall adder carry flowing lower upper part adder computed additional circuitry collected new subdesign accordingly reformulate specification component cla follows claimtac ex p0bin ex g0bin ex p1bin ex g1bin ex c1bin clasn div 2 lowern div 2 lowern div 2 b lowern div 2 p0 g0 c clasn proof new specification entails original accomplished automatically tactic implemented performs exhaustive case analysis values carry propagate generate bits performs simplification arithmetic expressions decompose new specification subparts implement recursive occurrences specification clas using induction hypothesis done applying design tac twice remaining specification carrys solved new subdesign implemented shown figure 4 note reuse formerly developed aux thus design goals solved 39 steps finished bus n bbin bus n sbin bus n pbin gbin cibin clan b p g wire p0bin g0bin p1bin g1bin c1bin clan div 2 lowern div 2a lowern div 2b lowern div 2s p0 g0 ci join port abin bbin sbin pbin gbin cibin wire wbin xora b w join xorw ci join ora b p join anda b port p0bin g0bin p1bin g1bin c1bin pbin gbin cibin port ubin vbin wbin xbin nnnat1 port abin bus n bbin bus n sbin bus n pbin gbin cibin clan b p g ci sat clasn b p g ci definition context h become instantiated four definitions one one correspondence implementations shown figures 3 4 predicates defining 6 comparison conclusion combined two development methodologies formal synthesis implemented veritas resolution based synthesis isabelle result simple realization formal synthesis compatible approaches resolution based synthesis moreover implementation supports structural behavioral dataabstraction well independence concrete circuit technology implementation based series extensions higherorder logic able directly utilize standard isabelle theories work well isabelles simplification tactics derived rules proven one step proofs isabelles classical prover idea using firstorder resolution build programs goes back green 1960s 6 recently within systems like isabelle interactive proof higherorder resolution used construct verified programs hardware designs 1 4 10 work closely related mike fourmans group based lambda system proof development system supports synthesis based secondorder resolution 5 motivated isabelle use rules order represent design state difference lies particular approach use proof construction 1 instead using general purpose techniques formal synthesis derive intro duction rules component definition rules applied proof state order simplify specification thereby refine implementation specialized form rules supports higher degree automation general purpose techniques conversely generality formal synthesis techniques provides abstract view design process better supports hierarchical development extended formal synthesis techniques induction possible adapt methodology within setting carried initial experiments indicate use formal synthesis techniques synthesize lambda style design rules rules combined techniques circuit development simple illustration suppose axiom adder circuit given apply techniques synthesize partial implementation schematic specification spec contains subexpression form anat bnat circab sat specab applying techniques inside claim reveal split solving proof obligation claim arrive following intermediate proof state anat bnat wire snat 1 b anat bnat snat discharging first subgoal assuming removing port quan tifiers arrive lambdastyle design rule anat bnat explaining technique says reduce specification involving addition b one instead involving validation tells us 1 end many 700 proof development systems many strategies constructing proofs circuit built specs hooked appropriately adder builds circuit original specification would difficult build tactics enable us integrate lambda techniques others developed taking advantage different strengths two approaches conclude brief mention deficiencies future work currently amount information present proof overwhelming shortterm solution instruct isabelle elide information however graphical interface like lambda would tremendous value displaying designs giving specifications another weakness automation automated many simple kinds reasoning combining isabelles simplifiers caseanalysis binary values resulting tactics effective execution slow decision procedures based bdds effectively solve many problems started integrating one synthesis environment namely decision procedure decidable monadic logic wellsuited modeling hardware 2 hope step towards synthesis framework different verification methodologies may integrated r logic frameworks logic programs hardware verification using monadic secondorder logic hardware verification using higherorder logic interactive program derivation formal system design interactive synthesis based computerassisted formal reasoning application theorem proving problem solving formal synthesis digital sys tems computer architecture isabelle generic theorem prover tr
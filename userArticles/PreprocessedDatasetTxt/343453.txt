low overhead logging scheme fast recovery distributed shared memory systems paper presents efficient writerbased logging scheme recoverable distributed shared memory systems logging data item performed writer process instead every process accesses item logging since writer process maintains log data items volatile storage used logging readers access information needs logged stable storage writer process tolerate multiple failures moreover reduce frequency stable logging data items accessed multiple processes logged access information items invalidated also semanticbased optimization logging considered compared earlier schemes stable logging performed whenever new data item accessed written process size log logging frequency significantly reduced proposed scheme b introduction distributed shared memorydsm systems15 transform existing network workstations powerful sharedmemory parallel computer could deliver superior priceperformance ratio however workstations engaged system longer execution time probability failures creases could render system useless dsm system practical use important system recoverable processes restart beginning failure 25 approach provide faulttolerance dsm systems use checkpointing rollbackrecovery checkpointing operation save intermediate system states stable storage affected system failures periodic checkpointing system recover one saved states called checkpoint failure occurs system activity resume computation one previous checkpoints called rollback dsm systems computational state process becomes dependent state another process reading data item produced process dependency relations process recovering failure force dependent processes roll back together cannot reproduce sequence data items rollback propagated dependent processes processes may roll back recursively reach consistent recovery line checkpoints processes taken carefully recursive rollback called domino effect17 worst case consistent recovery line consists set initial points ie total loss computation spite checkpointing efforts one solution cope domino effect coordinated checkpointing time process takes checkpoint coordinates related processes take consistent checkpoints together 3 4 5 8 10 13 since checkpointing coordination approach produces consistent recovery line processes cannot involved domino effect one possible drawback approach processes need blocked normal computation checkpointing coordination communicationinduced checkpointing another form coordinated checkpointing process takes checkpoint whenever notices new dependency relation created another process9 22 24 25 checkpointing coordination approach also ensures dominoeffect since checkpoint communication point however overhead caused frequent checkpointing may severely degrade system performance another solution domino effect problem use message logging addition independent checkpointing 19 every data item accessed process logged stable storage process regenerate computation rollback reprocessing logged data items result failure one process affect processes means rollback propagation also domino effect possible drawback approach nonnegligible logging overhead reduce logging overhead scheme proposed 23 avoids repeated logging data item accessed repeatedly correct recomputation data item logged first accessed count repeated access logged item data item invalidated result amount log reduced compared scheme 19 scheme proposed 11 suggests data item logged produced write operation hence data item accessed multiple processes need logged multiple sites amount log reduced however data item written accessed processes logging becomes useless moreover correct recomputation process accessing data item log location item logged access count item result cannot much reduction frequency logging compared scheme 23 reduce logging overhead scheme proposed 7 suggests volatile logging process produces new data item write operation value logged volatile storage writer process written value requested processes writer process logs operation number requesting process hence requesting process fails data value proper operation number retrieved writer process compared overhead logging stable storage volatile logging cause much less overhead however concurrent failures requesting process writer process system cannot fully recovered paper present new logging scheme recoverable dsm system tolerates multiple failures proposed scheme twolevel log structure used volatile stable storages utilized efficient logging speed logging recovery procedures data item readers access information logged volatile storage writer process tolerate multiple failures log access information data items saved stable storage volatile logging limited space one possible problem stable logging access frequency stable storage critical issue solve problems logging data item performed data becomes invalidated new write operation writer process takes whole responsibility logging instead every process accessing data concurrently logs also eliminate unnecessary logging data items semanticbased optimization considered logging result amount log frequency stable storage accesses substantially reduced rest paper organized follows section 2 presents dsm system model definition consistent recovery line presented section 3 section 4 section 5 proposed logging rollback recovery protocols presented respectively section 6 proves correctness proposed protocols evaluate performance proposed scheme implemented proposed logging scheme top cvmcoherent virtual machine12 experimental results discussed section 7 section 8 concludes paper 2 system model dsm system considered paper consists number nodes connected communication network node consists processor volatile main memory nonvolatile secondary storage processors system share physical memory global clock communicate message passing however system provides shared memory space unit shared data fixedsize page system logically viewed set processes running nodes communicating accessing shared data page processes considered sequence state transitions initial state final state event atomic action causes state transition within process sequence events called computation dsm system computation process characterized sequence readwrite operations access shared data pages computation performed process assumed piecewise deterministic computational states generated process fully determined sequence data pages provided sequence read operations dsm model assume readreplication model 21 system maintains single writable copy multiple readonly copies data page memory consistency model assume sequential consistency model version data page process reads reader page x copy request 2 2 2 writer ownership owner page x invalidate copyset x owner remote read operation b remote write operation 2 1 read readonly request 1 write figure 1 remote readwrite procedures latest version written data page 14 number different memory semantics dsm systems proposed including processor weak release consistency 16 well causal coherence 1 however paper focus sequential consistency model writeinvalidation protocol 15 assumed implement sequential consistency figure 1 depicts read write procedures writeinvalidation protocol data page one owner process writable copy local memory process reads data page local memory ask transfer readonly copy owner set processes readonly copies data page called copyset page process perform write operation data page owner page copyset page must empty hence writer process first sends write request owner process owner owner process sends invalidation message processes copyset make invalidate readonly copies page collecting invalidation acknowledgements processes copyset owner transfers data page ownership new writer process writer process owner copyset empty performs invalidation procedure overwriting page system component make following failure assumptions processors failstop 20 processor fails simply stops perform malicious actions failures considered transient independent node recovers failure reexecutes com putation failure likely occur also failure one node affect nodes make assumption number simultaneous node failures node fails register contents main memory contents lost however contents secondary storage preserved secondary storage used stable storage communication subsystem reliable message delivery handled errorfree virtually lossless manner underlying communication subsystem however assumption made message delivery order 3 consistent recovery line state process naturally dependent previous states dsm system dependency relation states different processes also created reading writing data item process p reads data item written another process p j p states read event become dependent p j states write event formally dependency relation defined follows let r ff denote ffth read event happened process p ff denote state interval triggered r ff ended right r ff1 denotes p initial state let w ff denote set write events happened ff read write event data item x returning written value u definition 1 interval ff said dependent another interval fi one following conditions satisfied dependency relation denoted fi c2 r ff j w c3 exists interval fl fi fl figure 2 shows example computational dependency among state intervals dsm system consisting three processes horizontal arrow figure 2a represents progress computation process arrow one process another represents data page transfer processes data page x containing data item x denoted xx figure 2b depicts dependency relation created figure 2a directed graph node represents state interval edge path node n ff another ji ji ki ki computation diagram b dependency graph figure 2 example dependency relations node n fi indicates direct transitive dependency relation state interval n ff another state interval n fi note figure 2a dependency relation 1 j 1 k according definition given however dsm system easy recognize part data page accessed process hence computation figure 2a may differentiated one p k read operation ry 0 case must dependency relation 1 k dotted arrow figure 2b denotes possible dependency relation logging scheme must carefully designed take care possible dependency consistent recovery dependency relations state intervals may cause possible inconsistency problems process rolls back performs recomputation figure 3 shows two typical examples inconsistent rollback recovery cases discussed messagepassing based distributed computing systems6 first suppose process p figure 3a roll back latest checkpoint c due failure cannot retrieve data item ry result w x may different one computed failure hence consistency p p j becomes violated since computation event rx depends invalidated computation case called orphan message case hands suppose process p j figure 3b roll back latest checkpoint c j due failure p j regenerate exactly computation retrieve data item x roll back resend data page xx case called lost message case however dsm system lost message case cause inconsistency problem failure failure orphan message case b lost message case figure 3 possible inconsistent recovery lines write operation since w x p p j retrieve contents page current owner time even though another write operation contents page changed p j still retrieve data page xx even different contents different recomputation p j affect processes unless p j dependent processes failure hence dsm system rollback recovery case causes inconsistency problem orphan message case definition 2 process said recover consistent recovery line involved orphan message case rollback recovery 4 logging protocol efficient logging three principles adopted one writerbased logging instead multiple readers logging data page one writer process takes responsibility logging page also invalidationtriggered logging used logging data page delayed page invalidated finally semanticbased logging optimization considered avoid unnecessary logging activities access pattern data related processes considered logging strategy 41 writerbased invalidationtriggered logging consistent regeneration computation process required log sequence data pages accessed contents data page accessed process log page log access duration instead logging page contents repeatedly access duration denoted first last computational points page accessed logging data page performed either process accessed reader process produced writer since data page produced writer usually accessed multiple readers efficient one writer log page rather multiple readers log page moreover writer utilize volatile storage logging data page since logged pages required readers failure writers failure even writer loses page log due failure regenerate contents page consistent recovery assumption uniquely identify version data pages access duration process p system maintains following data structures local memory assigned process p variable counts number read write operations performed process using opnum unique sequence number assigned read write operations performed p version data page x produced p unique version identifier assigned ffl version x unique identifier assigned version data page x version opnum opnum value time p produced current version x produces new version x write operation version x assigned page current version x invalidated p logs current version x version x p volatile log space also log access duration current readers page x report access duration page reader p j maintains following data structure associated page x local memory ffl duration jx record variable four fields denote access information page x p j first value opnum j time page x first accessed p j last value opnum j time page x invalidated p j new version page x transferred current owner p j creates duration jx fills entries pid version first entry last completed p j receives invalidation message x current owner p process p j piggybacks complete duration jx invalidation acknowledgement sent p owner p collecting duration kx every reader logs collected access information volatile log space owner p may also duration ix read page x writing another process implicitly accesses current version x next owner since next owner usually makes partial updates current version page current version retrieved case next owners failure hence process p k sends write request current owner p attach opnum k value receipt request creates duration kx first last notice volatile logging access information writer provides fast retrieval case readers failure however information totally lost case writers failure since unlike data page contents access information cannot reconstructed failure hence cope concurrent failures might occur writer readers stable logging access information required writer p makes volatile log access information also save information stable log space readers access information reconstructed writer fails figure 4 shows way writerbased invalidationtriggered logging protocol executed incorporated sequential consistency protocol system consisting three processes symbol r ff x w ff x figure denotes read write operation data page x opnum value ff inv x denotes invalidation page x figure assumed data page x initially owned process p j noticed figure proposed logging scheme requires small amount extra information piggybacked write request message invalidation acknowledgements volatile stable logging performed writer process invalidation time figure 4 also shows contents volatile stable log storages process p j note stable log p j includes access information volatile log includes contents page x addition access information delaying page logging invalidation time readers access information collected without extra communication moreover logging access duration multiple readers performed one stable storage access though amount access information small read request read request request write invalidate invalidate invalidate invalidate ownership 1 j1 1 1 readonly copy copy readonly figure 4 example writerbased invalidationtriggered logging frequent accesses stable storage may severely degrade system performance hence important reduce logging frequency invalidationtriggered logging however invalidationtriggered logging may cause data pages accessed readers yet invalidated log entries pages reader process cannot retrieve log entries reexecutes computation due failure data page however safely refetched current owner even readers failure since data page accessed multiple readers cannot invalidated unless every reader sends invalidation acknowledgement back data pages currently valid system necessary logged sequential consistency protocol incorporated writerbased invalidationtriggered logging formally presented figure 5 figure 6 bold faced codes ones added logging protocol 42 semanticbased optimization every invalidated data page access information however necessary logged considering semantics data page access data pages accessed reproduced recovery access duration implicitly estimated logged access information p reads data page x send readrequestx ownerx wait pagex notexistduration ix duration ix pidpid duration ix versionversion x duration ix firstopnum 1 duration ix last0 receives readrequestx send pagex figure 5 writerbased invalidationtriggered logging protocol semanticbased logging strategy unnecessary logging points detected based data page access pattern logging points avoided delayed logging strategy reduce frequency stable logging activity also reduce amount data pages logged volatile storage first data pages remote access need logged data page remote access means page read invalidated locally without creating dependency relation example figure 7 process p first fetches data page x p j creates new version x identifier i1 version page locally read r 2 x r 3 x invalidated w 4 x however version i1 x invalidated due operation w 4 x p need log contents page x access duration ii124 reason recovery p version i1 x regenerated operation w 1 x access duration ii124 estimated duration w 1 x w 4 x next version i4 page x however need logged invalidated due operation w 2 x p j since operation w 2 x p writes data page x send writerequestx opnum ownerx wait pagex else copysetx 6 oe f send invalidationx every p k 2 copysetx wait invalidationackx every p k 2 copysetx duration x k2copygammasetx duration save version x pagex duration x volatilelog flush version x duration x stablelog write pagex version x pid opnum receives writerequestx opnum j send invalidationx every p k 2 copysetx wait invalidationackx every p k 2 copysetx duration x k2copygammasetx duration duration jx pidpid duration jx versionversion x duration jx firstduration jx lastopnum j 1 duration x duration x duration jx save version x pagex duration x volatilelog flush version x duration x stablelog send pagex ownershipx duration ix lastopnum send invalidationackx duration ix ownerx figure invalidationtriggered logging protocol continued figure 7 example local data accesses implicitly requires remote access version i4 eliminating logging local data pages amount logged data pages volatile log space also access frequency stable log space significantly reduced however elimination may cause inconsistency problems shown figure 8 integrated invalidationtriggered logging suppose process p figure roll back failure consistent recovery p perform recomputation w 4 x otherwise orphan message case happens p p j however p performed last logging operation w 2 x log entry w 4 x p dependency p j matter whether p rolls back w 2 x w 4 x however due dependency p j process p perform recomputation least point dependency formed record opnum value process recover process p system maintains ninteger array called operation counter vectorocv n number processes system ocv n ith entry v denotes current opnum value denotes last opnum value p j p current computation dependent notation similar causal vector proposed 18 hence process p j transfers data page another process p sends current ocv j value page receiver updates ocv taking entrywise maximum value received vector vector follows example figure 8 p sends data page x version identifier i4 p j sends page p j updates ocv j 4 2 0 p j sends data page version identifier j3 p k ocv sent page ocv k failure logging figure 8 example operation counter vectors updated ocv 1 result v j ocv indicates last operation process p j process p current computation directly transitively dependent hence p j performs rollback recovery complete recomputation least point v j yield consistent states p p j another data access pattern considered logging optimization sequence write operations performed data page shown figure 9 processes l figure sequentially write data page x however written data read r 2 x p l access pattern means explicit dependency relation occurred system w l even though explicit dependency write operations shown figure write precedence order operations important since order indicates possible dependency relation explained section 3 also indicates process become current owner page recovery reduce frequency stable logging without violating write precedence order suggest delayed stable logging precedence orders delayed stable logging volatile logging data page access duration performed described however stable logging performed data page copyset invalidated instead information regarding precedence order current owner page next owner attached data page transferred next owner since new owner maintains unlogged precedence order information correct recomputation precedent performed long new owner survives suppose new owner precedent fail concurrently new owner fails without making new dependent write arbitrary recomputation may cause inconsistency problem new owner precedent pl figure 9 example write precedence order however fails making new dependents write correct recovery may possible hence process maintaining unlogged precedence order information perform stable logging creates dependent process example figure 9 p perform stable logging invalidates page x instead maintains precedence information i1 j1 performs stable logging transfers page x p k time precedence order p j p k j1 k1 also stably logged together hence page x transferred p j p k need carry precedence relation p j p k result computation shown figure 9 requires two stable logging activities instead four stable logging activities 5 recovery protocol consistent recovery two log structures used volatile log mainly used recovering process perform consistent recomputation stable log used reconstruct volatile log tolerate multiple failures addition data logging independent checkpointing periodically performed process reduce recomputation time 51 checkpointing garbage collection reduce amount recomputation case failure process system periodically takes checkpoint checkpoint process p includes intermediate state process current value opnum ocv data pages p currently maintains process takes new checkpoint safely discard previous checkpoint checkpointing activities among related processes need performed coordinated manner process however careful discarding stable log contents saved new checkpoint since log entries may still requested dependent processes hence checkpoint c ff process p p maintains logging vector say lv iff j th entry vector denoted lv iff j indicates largest opnum j value duration jx logged corresponding checkpoint process p j takes new checkpoint recomputation checkpoint longer required sends current opnum j value processes process periodically compares received opnum j value lv iff j value checkpoint c ff every p j system received opnum j becomes larger lv iff j process p safely discard log information saved checkpoint c ff 52 rollbackrecovery recovery single failure case first discussed process p recovered failure recovery process first created sets p status recovering process p 0 broadcasts log collection message processes system receipt log collection message process p j replies ith entry ocv j v j also data page x logged p j accessed p logged entry duration ix contents page attached reply message p 0 collects reply messages processes system creates recovery log arranging received duration ix order duration ix first also arranging received data pages corresponding order process p 0 selects maximum value among collected v j entries sets value p recovery point since processes system except p normal computational status p 0 collect reply messages selected recovery point p indicates last computational state p process system dependent also constructed recovery log p includes every remote data page p accessed failure recovery process restores computational state last checkpoint p restored state process begins recomputation restored state includes set active data pages residing main memory checkpoint taken value opnum also set one checkpointing time recomputation process p maintains variable condition action readx write pagex duration ix last read requestx ownerx last invalidatex read requestx ownerx recovery log table 1 retrieval data pages recomputation called value duration ix first first entry recovery log next indicates time fetch next data page recovery log read write operations p recomputation performed follows read first increments opnum value one compares opnum next matched first entry recovery log including contents corresponding page duration ix moved active data page space operation performed new page previous version page removed active data page space new version page used read write operations opnum reaches value duration ix last read write operations data pages created recomputation need used logging optimization hence new version data page x created write operation corresponding log entry found recovery log page must kept active data page space duration ix last set infinity version page x used next write operation x performed new version x retrieved recovery log sometimes p reads data page x may face situation valid version x found active data page space yet time fetch next log entry opnum next situation occurs data page accessed p failure invalidated note page logged since current version still valid case current version page x must refetched current owner hence p reads data page x request page x current owner version x active data page space duration ix last value page x active data page space less opnum cases opnum must less next previous version page x invalidated receiving new version retrieval invalidation activities data pages recomputation summarized table 1 active data page space abbreviated adps table recomputation process p also reconstruct volatile log contents maintained failure recovery dependent processes access information volatile log retrieved stable log contents p 0 waiting reply messages sending log collection requests however data pages saved volatile log must created recomputation hence write operation p logs contents page version identifier corresponding access information entry found volatile log case write operation may cause invalidation previous version page active data page space however issue invalidation messages processes recomputation opnum reaches selected recovery point p changes status recovering normal resumes normal computation extend protocol handle concurrent recoveries multiple failures process p p 0 performs recovery procedure another process p j system failed state also recovering status p j failed state cannot reply back log collection message p 0 wait p j wakes however p j recovering status make p wait reply since case p p j must end deadlocked situation hence message sent recovering status must carry recovery mark differentiated normal ones recovery message must taken care without blocking whether message recovery related recovery another process however normal message readwrite request invalidation message need delivered process recovering status since processing message recovery may violate correctness system recovering status receives log collection message another process p 0 reconstructs access information part p volatile log stable log contents done yet replies duration jx entries logged p p j even though access information restored stable log contents data pages contained volatile log may yet reproduced hence duration jx sent records value duration jx version corresponding data page sent p j later p creates page recomputation process p j begins recomputation access information collected every process system result every data page logged failure corresponding log entry duration ix retrieved recovery log however corresponding data page x may exist recovery log process p begins recomputation note case writer corresponding page may also recovery procedure hence p wait writer process sends page x recomputation may send request page x using duration ix version worst case two processes p p j concurrently execute recomputation data pages must retransferred two processes done failure however cannot occur deadlocked situation since data transfer exactly follows scenario described access information recovery log scenario must follow sequentially consistent memory model recovery process p begins normal computation reconstruct two informa tion one current operation counter vector data page directory operation counter vector reconstructed vector values received processes system v j value p use value v j retrieved process p j v value use current opnum value directory includes ownership copyset information data page owns checkpoint p contains ownership information data pages owned time checkpointing hence recomputation p reconstruct current ownership information follows p performs write operation data page records ownership page directory p reads new data page log invalidates ownership page since logging means invalidation however copyset data pages process owns obtained since copyset information future invalidation page process put processes copyset 6 correctness prove correctness proposed logging recovery protocols lemma 1 recovery point selected proposed recovery protocol consistent proof prove lemma contradiction suppose process p recovering failure selects inconsistent recovery point say r must produced data page x version x ik k r must another process p j alive system read page means v j p j must larger equal k since r selected maximum value among v k values collected r contradiction occurs 2 lemma 2 proposed logging protocol log exists every data access point prior selected recovery point proof data access point page used transferred another process either logged transferred remote write case logged page invalidated remote read case data page locally generated used data access point either log created page page invalidated remote invalidation case log contents calculated next write point local invalidation case case page invalidated failure retrieved current owner therefore data access point log data page either found recovery log calculated log contents 2 theorem 1 process recovers consistent recovery line proposed logging recovery protocols proof proposed recovery protocol recovering process selects consistent recovery point lemma 1 logging protocol ensures every data access point prior selected recovery point data log exists lemma 2 therefore process recovers consistent recovery line 2 7 performance study evaluate performance proposed scheme two sets experiments performed simple tracedriven simulator built examine logging behavior various parallel programs running dsm system logging protocols implemented top cvm system measure effects logging actual system environments figure 10 comparison logging amount synthetic traces 71 simulation results tracedriven simulator built following logging protocols simulated sharedaccess trackingsat23 process logs data pages transferred read write operations also logs access information pages process logs data pages produced also data pages accessed logs access information pages sat rwl schemes data pages related information first saved volatile storage logged stable storage process creates new dependency transferring data page writetriggered loggingwtl propose paper simulation run two different sets traces one traces synthetically generated using random numbers execution traces parallel programs first simulation model 10 processes used workload randomly generated using three random numbers process number readwrite ratio page number one simulation run consists 100000 workload records simulation repeated various figure 11 comparison logging frequency synthetic traces readwrite ratios locality values readwrite ratio indicates proportion read operations total operations readwrite ratio 09 means 90 operations reads 10 writes locality ratio memory accesses satisfied locally locality 09 means 90 data accesses local pages simulation results synthetic traces ones well show effects logging various application program types figure 10 figure 11 show effects readwrite ratio locality application program number logged data pages frequency stable logging respectively number parenthesis legend indicates locality sat scheme data page miss logging newly transferred page required hence write ratio increases large number data pages become invalidated large number page misses occur result number logged pages also logging frequency increased however locality increases higher portion page accesses satisfied locally hence number data pages logged logging frequency decreased rwl scheme number logged data pages directly proportional write ratio number affected locality since write operation requires logging however figure 12 comparison logging amount parallel program traces stable logging scheme performed process creates new dependent sat scheme hence logging frequency rwl scheme shows performance similar one sat scheme comparing sat scheme rwl scheme performance sat scheme better write ratio locality high since environments lot logging local writes rwl scheme wtl scheme pages updated logged logging performed owners data pages compared sat scheme every process copyset performs logging number logged data pages much smaller logging frequency much lower wtl scheme also wtl scheme logging data page remote access logging writewrite precedence order delayed hence wtl scheme shows much smaller number logged data pages much lower logging frequency compared rwl scheme logging performed every write operation furthermore logging data pages sat scheme rwl scheme require stable storage scheme volatile storage used logging validate claim also used real multiprocessor traces simulation traces contain references produced 64processor mp running following four programs fft figure 13 comparison logging frequency parallel program traces speech simple weather figure 12 figure 13 show simulation results using parallel program traces figure 12 programs fft simple weather sat scheme shows worst performance programs may contain large number read operations locality reads must low however program speech rwl scheme shows worst performance program contains lot local write operations cases wtl scheme consistently shows best performance amount log also considering logging frequency shown figure 13 programs wtl scheme shows lowest frequency simulation results conclude new schemewtl consistently reduces number data pages logged also frequency stable storage accesses compared schemessatrwl reduction 50 cases shown synthetic parallel program traces 72 experimental results examine performance proposed logging protocol actual system environments proposed logging protocol wtl protocol proposed 23 sat implemented top dsm system order implement sequentially consistent dsm system use application logging execution logging amount logged number program scheme time sec overhead information bytes stable logging table 2 experimental results cvmcoherent virtual machine package 12 supports sequential consistency memory model well lazy release consistency memory models cvm written using c well modularized pretty straightforward add logging scheme basic high level classes commmanager class msg class handle network operation memorymanager class handles memory management page class diffdesc class handling page management protocol classes lmw lsw seq inherit high level classes support operations according protocol modified subclasses seq implement logging protocols ran experiments using four sparcsystem5 workstations connected 10mbps ethernet experiments four application programs fft sor tsp water run table 2 summarizes experimental results amount logged information table 2 denotes amount data pages access information logged stable storage sat scheme data pages size 4k bytes access information logged whereas wtl scheme access information logged hence amount information logged wtl scheme 00105 one logged sat scheme number stable logging table indicates frequency disk access logging experimental results show logging frequency wtl scheme figure 14 comparison logging overhead 5766 one sat scheme addition amount logged information logging frequency also measured total execution times parallel programs logging scheme without logging compare logging overhead logging overhead table 2 indicates increases execution time protocol compared execution time logging environment comparison logging overhead also depicted figure 14 shown table sat scheme requires 20189 logging overhead whereas wtl scheme requires 585 logging overhead comparing two schemes wtl scheme achieves 5575 reduction logging overhead compared sat scheme one reason reduction low logging frequency imposed wtl scheme small amount log information written wtl scheme also another reason however considering fact increases amount data pages written per disk access cause much increases disk access time 75 reduction logging overhead may require another explanation one possible explanation cascading delay due disk access time stable logging delays progress process performs logging also one waiting data transfer process overall experimental results show wtl scheme reduces amount logged information logging frequency compared sat scheme also show actual system environment reductions total execution time achieved conclusions paper presented new message logging scheme dsm systems message logging usually performed data page transferred read operation process affect processes case failure recovery however logging stable storage always incurs overhead reduce overhead logging protocol proposed paper untilizes twolevel log structure data pages access information logged volatile storage writer process access information duplicated stable storage tolerate multiple failures usage twolevel log structure speed logging also recovery procedures higher reliability proposed logging protocol also utilizes two characteristics dsm system one data pages read written logged data page needs logged invalidated overwriting data page accessed multiple processes need logged every process site one responsible process logging data page related information amount logging overhead substantially reduced extensive experiments compared proposed scheme existing schemes concluded proposed scheme always enforces much low logging overhead reduction logging overhead profound processes reads writes since disk logging slows normal operation processes believe parallel applications would greatly benefit new logging scheme r implementing programming causal distributed shared memory causal memory performance consistent checkpointing distributed shared memory systems network multicomputing using recoverable distributed shared memory distributed snapshot determining global states distributed systems lightweight logging lazy release consistent distributed shared memory coordinated checkpointingrollback error recovery distributed shared memory multicomputers relaxing consistency recoverable distributed shared memory reducing interprocessor dependence recoverable shared memory implementation recoverable distributed shared memory logging writes cvm coherent virtual machine recoverable distributed shared memory integrating coherence recoverability make multiprocessor computer correctly executes multiprocess pro grams shared virtual memory loosely coupled multiprocessors distributed shared memory survey issues algorithms reliability issues computing system design causal ordering abstraction simple way implement algorithms implementing distributed shared memory fault tolerant distributed shared memory reduced overhead logging rollback recovery distributed shared memory fast recovery distributed shared virtual memory systems recoverable distributed shared memory tr ctr taesoon park inseon lee heon yeom efficient causal logging scheme recoverable distributed shared memory systems parallel computing v28 n11 p15491572 november 2002
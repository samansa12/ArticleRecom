compact recognizers episode sequences given two strings xa1an pb1bm alphabet problem testing whether p occurs subsequence x trivially solved linear time also known simple n log time preprocessing x makes easy decide subsequently p p log character comparisons whether p subsequence x problems become complicated one asks instead whether p occurs subsequence substring x bounded length paper presents automaton built textstring x capable identifying distinct minimal substrings x p subsequence substring minimal respect p meant p subsequence proper substring every minimal substring automaton recognizes occurrence p lexicographically smallest sequence symbol positions difficult realize automaton time space n2 text n characters one result paper consists bringing bounds linear n log n respectively depending whether alphabet bounded arbitrary size thereby matching corresponding complexities automata constructions offline exact string searching built automaton search lexicographically earliest occurrences p x carried time i1mroccii ni1mroccii log n depending whether alphabet fixed arbitrary rocci number distinct minimal substrings x b1bi subsequence note substring may occur many times x counted bound log factors appearing bounds reduced log log resorting known integerhandling data structures b introduction consider problem detecting occurrences pattern string subsequence substring bounded length larger text string variants problem arise numerous applications ranging information retrieval data mining see eg 10 molecular sequence analysis see eg 12 intrusion misuse detection computer system see eg 9 recall given pattern say p occurs subsequence x iff exist indices 1 case also say substring x realization p beginning position 1 ending position x reserve term occurrence sequence 1 trivial compute time linear jxj whether occurs subsequence x alternatively simple onjsigmaj time preprocessing x makes easy decide subsequently p jp j character comparisons whether p subsequence x needed pointer leading every position x every alphabet symbol closest position occupied symbol exemplified fig 1 slightly complicated arrangements developed 2 accommodate within preprocessing time log jsigmaj space linear x also case arbitrary alphabet size though introducing extra log jsigmaj cost factor search p refer also 3 additional discussion subsequence searching figure 1 recognizer subsequences abaababaabaababa shown without explicit labels forward skip links problems become complicated one asks instead whether x contains realization p bounded length since earliest occurrence p subsequence x guaranteed solution case one would need apply scheme suffixes x find way detect minimal realizations p x realization minimal substring realization p algorithms socalled episode matching problem consists finding earliest occurrences p minimal realizations p x given previously 7 occurrence 1 p realization earliest occurrence string lexicographically smallest respect possible occurrence p algorithms 7 perform within roughly onm time without resorting auxiliary structure index based structure text applications exact string searching text string preprocessed way subsequent query regarding pattern occurrence takes time proportional size pattern rather text notable among constructions resulting structures subword trees graphs refer eg 1 6 notice answer typical query whether pattern appears text one wanted locate occurrences well time would become ojwj denotes total number occurrences kinds searches may considered line respect pattern sense preprocessing pattern allowed offline terms ability preprocess text general setting efficient structures kind non exact matches seems quite hard sometimes small selection options faced represent various compromises among space time parameters 11 5 idea limiting search distinct substrings text applied perform approximate string matching suffix trees paper addresses construction automaton based textstring x suitable identifying given p set distinct minimal realizations p x specifically automaton recognizes realization earliest occurrence p preceding discussion suggests difficult realize automaton time space text n characters main result paper consists bringing bounds linear log n depending assumption alphabet size thus matching cost preprocessing offline exact string searching subword graphs construction used particular cases symbols p affected individual expiration deadlines expressed eg terms positions x might elapse next symbol alternatively entire occurrence pattern p must matched paper organized follows next section review basic structure directed acyclic word graphs outline extension constitutes first quadratic space realization automaton compact implementation automaton addressed following section implementation requires linear space case finite alphabet case general alphabets addressed last section results tradeoff seach time space 2 dawgs skipedge dawgs main concern section show text x preprocessed way subsequent search earliest occurrences x prefixes given p carried time bounded size output rather input solution rests adaptation partial minimal automaton recognizing subwords word also known dawg directed acyclic word graph 4 associated word let w set subwords text x p ith prefix p modified graph built time space quadratic linear length input depending whether size input alphabet arbitrary bounded constant respectively searched earliest occurrences rocc distinct realizations p time realization p minimal substring x quence note realization p substring may occur many times x counted bound begin discussion recalling structure dawg string first consider following partial deterministic finite automaton recognizing subwords x given two words x endset x set endpos x two strings w equivalent x endpos x w equivalence relation instituted way denoted jx partitions set strings sigma equivalence classes convenient assume henceforth text string x fixed equivalence class respect jx word w denoted simply set strings occurrences x terminating set positions w correspondingly finite automaton recognizing substrings x one state equivalence classes subwords x jx specifically 1 start state ffl ffl empty word 2 state w symbol 2 sigma transition edge leading state wa 3 state corresponding strings substrings w nonaccepting state states accepting states deleting nonaccepting state incoming arcs yields dawg associated x example dawg abbbaabaa reported figure 2 aa figure 2 example dawg refer eg 4 6 construction dawg recall basic properties structure clearly directed acyclic graph one sink one source every state lies path source sink moreover following two properties hold 4 6 property 1 word x sequence labels distinct path source sink dawg x represents one distinct suffix x property 2 word x dawg x number states q jxj number edges e jxj recalling basic structure subsequence detector one fig 1 immediate see dawg x may adapted recognize earliest occurrences given pattern p subsequence x essentially need endow every node ff number downward failure links skipedges link associated specific alphabet symbol role link leaving ff label enable transition descendant ff nontrivial ie least two original edges path labeled string symbol occurs suffix formally skip link labeled set node ff associated equivalence class w node fi associated class wv v 6 ffl appear v thus skipedge labeled issued ff one closest descendants children original incoming edge labeled already exists example figure 3 displays partially augmented version dawg figure 2 skipedges added source two adjacent nodes use words full skipedge dawg refer structure would result adding skipedges nodes dawg clearly role skipedges serve shortcuts search however edges also introduce nondeterminism automaton particular one path source may labebed prefix p following theorem used summarize discussion theorem 1 string x n symbols full skipedge dawg x built 2 jsigmaj time space searched rocc earliest realizations prefixes pattern symbols time proof built dawg time log jsigmaj one existing methods augmentation easily carried 2 jsigmaj time space eg adaptation depthfirst visit dawg follows first sink first reached gets assigned nil skipedges alphabet symbols next every time backtrack node ff node fi label arc ff fi skipedges defined fi used identify issue additional skipedges ff bound follows fact every node symbol skipedges might directed thetan nodes time bound searches subtended immediate consequence property 1 namely p occurs subsequence x beginning specific position x following two conditions hold 1 path labeled p source node ff full skipedge dawg x 2 possible replace skipedge chain original edges way resulting path source ff labeled consecutive symbols x beginning position therefore search p trivially performed eg depthfirst visit longest paths full skipedge dawg start source labeled prefix p incidentally depth search may suitably bounded taking account length p lengths shunted paths edge traversed precisely time backtrack node corresponds prefix p cannot continued along path explored whence claimed time bound searches 2 searchtime bound theorem 1 actually tight even tighter one represented total number distinct nodes traversed practice may expected proportional small power length p consideration symbol durations may also added construction phase thereby reducing number skipedges issued main problem however storing full skipedge dawg would take unrealistic thetan 2 worstcase space even alphabet size constant cf fig 3 remainder discussion devoted improving space requirement figure 3 adding skipedges source two adjacent nodes compact skipedge dawgs observe property 1 node dawg x mapped position x way path say fix ideas longest one node sink labeled precisely suffix i1 n x easy check mapping assignment carried construction dawg extra cost observe also always path labeled x dawg x path called backbone dawg let depth node dawg length longest word w path source definition dawg every path source labeled one consecutive suffixes w certain minimum length words equivalence class w occur x suffixes w also follows considering set immediate predecessors paths depths must mutually different smaller jw j finally depths backbone nodes must given consecutive integers 0 source n sink order describe skip links issued dawg resort slightly extended version spanning tree dawg see fig 4 extension consists simply replicating nodes dawg adjacent leaves spanning tree bring final structure also edges connecting nodes edges would classified either cross edge descendant edge depthfirst visit dawg resulting tree stipulate duplicates node created way leave connected immediate predecessor property depth dawg equals depth minus 1 note node must exist except source note also spanning tree must contain directed path corresponds precisely backbone dawg let resulting structure clearly number edges dawg moreover node dawg represented every incoming edge therefore size linear jxj use convenient structure describe set skipedges auxiliary links actuality edges set dawg since introduction skipedge every node symbol would costly endow edges fraction nodes specifically policy result linear number skipedges issued overall node endowed skipedge desired symbol corresponding transition performed first gaining access suitable node skipedge available following edge order gain access node appropriate surrogate skipedge need resort two additional families auxiliary edges respectively called deferring edges back edges space overhead brought auxiliary edges delta jsigmaj hence linear sigma finite new edges labeled like skipedges unlike skipedges traversal given input symbol consume symbol full structure management explained due course describe augmentation dawg reference generic node fl distinguish following cases outdegree 1 assume edge leaving fl labeled consider original path fl branching node leaf whichever comes first every first occurrence edge j fi labeled 6 direct skipedge labeled fl figure 4 extended spanning tree sample skipedges fi every symbol alphabet encountered set deferring edge fl branching node leaf found end ffl case 2 node fl branching node auxiliary edges possibly issued fl determined follows see also fig 5 let j descendant child fl incoming edge labeled let longest ascending original path j edge labeled fl highest ie closest root branching node perform following two actions first direct skipedge labeled fl j next consider subtree rooted fl path tree lead eventually arc labeled like arc leading node j must end leaf every leaf direct fl deferring edge labeled second action always performed special case fl root ffl case 3 node fl leaf fl sink nothing done otherwise let original dawg node fl replica back symbol alphabet follow every distinct path encountering first occurrence sink every path intervening branching nodes direct skipedge leaf fl node end path every path traversing proceding past branching node direct deferring edge fl deepest one among branching nodes end eliminate possible duplicates among deferring edges introduced figures 4 5 exemplify skip links backbone root one children tree example figure 5 onesymbol transition node ff descendant j implemented via three auxiliaryedge traversals first deferring link nearest branch node fi next fi fl backedge finally skipedge fl j avoid unnecessarily cluttering figure edges shown note presence another alabeled skipedge fl ffi introduces ambiguity direction take search reached fl point result construction policy may branching nodes get assigned skip deferring edge may cause search stall middle downward path lack appropriate direction order prevent problem back edges added every branching node follows see fig 5 every branching node fi every alphabet symbol alabeled skipedge fi defined edge labeled directed fi closest ancestor fl fi skip deferring edge labeled defined refer fl abackup fi denote back fi note construction case 2 backup node exists always clearly intent effect traversing skipedge described previous section achieved traversing small sequence auxiliary edges example fig 5 transition node ff j implemented traversing succession one deferring edge one back edge one skipedge complication compensated following advantage lemma 1 total number auxiliary edges whence also augmented dawg x ojxj delta jsigmaj proof one auxiliary edge per alphabet symbol leaving nodes outdegree 1 concentrate branching nodes leaves skipedges directed branching nodes observe symbol node fi one skipedge labeled may reach fi node due conventions made case 2 indeed skipedge labeled set branching node ff another node fi construction branching node path ff fi issued alabeled skipedge also construction either ff root else must edge labeled path closest branching ancestor ff ff hence skipedge labeled could possibly set branching ancestor ff node subtree rooted ff similar argument holds deferring edges directed towards every leaf indeed mechanics case 2 deferring edge labeled set branching node ff leaf fi original edge labeled path ff fi either ff root else must original edge labeled path closest branching ancestor ff ff deferring edge labeled may issued branching ancestor ff node subtree rooted ff considering leaves observe first one skipedge per symbol may directed leaf node get global bound deferring edges set leaves consider compact trie suffixes x trie leaves arcs every branching node mapped distinct branching node trie indeed obtained figuratively pruning noncompact version trie map one deferring edges set leaf fl arc trie way arc trie charged one deferring edge per alphabet symbol see mapping let w word root fl let w extension w completes one paths ending first occurrence crossing branching nodes dawg deferring edge relative w 0 charged edge trie w 0 ends observe extension w appearing x occurrence v 0 v v 0 must diverge words w 00 must path trie diverges w 0 thus charge arc trie different one charged w 0 moreover since prefix w ends leaf ancestor fl produce charges conclusion leaf symbol sigma distinct arc trie charged whence total number auxiliary edges kind per symbol bounded length x 2 realization x beginning ending j sequence oe arcs following properties concatenation consecutive labels original skipedges oe spells p ii original skipedge oe followed sequence containing two deferring edges one back edge iii path labeled dawg source node reached last arc oe proof proof induction length pattern let assume p realization x stated definition must original arc corresponding node reached arc satisfies trivially points gamma iii 1 assume claim holds patterns lengths matched prefix p node ff maintaining gamma iii hence index f j path root ff labeled f realization pmgamma1 given p realization must path dawg labeled f1 j originating node represented ff path image perhaps fragmented sequence segments considering image claim easily checked last symbol b p consumed either original arc defined skipedge leaving ff shunting path labeled f1 j assuming neither type edge defined ff construction must deferring edge labeled leading path labeled prefix f1 k f1 either branching node call fi leaf second case either defined skipedge leading final node would conclude argument one deferring edge take branching node considering branching node must image node dawg path ff labeled k1 j hence moment reset reasoning assume case branching node fi except fact would start handicap already consumed two deferring edges assume branching node fi possibly already traversed one two deferring edges suffix k1 j f still matched clearly fi defined alabeled skip original edges concludes argument thus remaining cases interest occur alabeled skip original edge defined fi event link back fi traversed instead depicted fig 5 let j descendants fi j connected fi nontrivial original path symbol appears precisely suffix alabeled original edge fi j claim skipedge labeled fl j fact selection edge labeled path fi parent node j assuming one edge existed path fl fi fi branching ancestor fi would alabeled skipedges defined thereby contradicting back choose j node end path originating fi labeled suffix k1 j remains point consumed skipedge labeled must exist fl j traversal edge achieves propagation points gamma iii p within transitions two deferring edge one back edge one skipedge proof converse straightforward thus omitted 2 based lemma 2 search realizations pattern augmented dawg x may carried along lines boundeddepth visit directed graph elementary downward step search consists following original edge skipedge depending one found details obvious whenever edge actually exists problem need examine detail symbol may one skip deferring edge labeled leaving node like node fl fig 5 edges leading descendants fl simultaneously descendants ff fig 5 instance situation represented node ffi assume auxiliary ie skip deferring edges leaving node fl label arranged list dedicated sorted say according lefttoright order descendants fl thus particular descendants node ff example reachable alabeled auxiliary edge fl found consecutive entries auxiliary edge list fl associated symbol list part traversed left right search follows naturally structure depthfirst visit graph convention also made backedge fi fl points directly auxiliary edge associated leftmost descendant fi search beginning sublist fl relative descendants fi immediately accessed fi way skip deferring edges sublist scanned sequentially subtree rooted fi explored following theorem summarizes discussion theorem 2 compact skipedge dawg associated x supports search earliest occurrences pattern x time rocc number distinct realizations x prefix p p already noted realization substring may occur many times x counted bound difficult modify dawg augmentation highlighted previous section build compact variant described core paradigm bottomup computation except time lists skip deferring edges may assigned branching nodes temporary basis whenever climbing back towards root node fi ancestor branching node ff encountered intervening edges labeled alabeled skip deferring edge lists fi surrendered ff fi simultaneously appended list back branching nodes awaiting back edges soon intervening original edge labeled reached root alabeled lists permanently assigned node ff appropriate backedges also directed every node list back back disposed similar process governs introduction skip deferring edges leaves recall leaf fact replica confluence node dawg shows possible compute class auxiliary edges bottomup also suggests group leaves replicating node dawg suffices issue edges node image dawg node let replicas simply point note long insist reasoning terms deferring edges leaves must suitably marked lest confused issued branching nodes play havoc search described lemma 2 overall process takes time space linear structure outset linear jxj fixed alphabets symbol durations may taken account construction well searches possibly resulting additional savings details tedious straightforward left reader 4 generalizing unbounded alphabets alphabet size jsigmaj constant independent length n x face choice implementing original adjacency list node dawg either linear list balanced tree first option leaves space unaffected introduces slowdown linear multiplicative factor worstcase searches second introduces linear number extra nodes overhead search multiplicative factor olog jsigmaj assume second choice made rather straightforward adaptations structure discussed previous section would lead statement similar theorem 2 except olog jsigmaj factor time bound however interested fact alphabet size longer constant lemma 1 collapses number auxiliary edges needed dawg may become quadratic section show transducer supporting search time fact built within log n time linear space idea course forfeit many skipedges auxiliary edges pay sparsification log jsigmaj overhead elementary transitions explain first work original array x stored resort global table close defined follows 2 contains smallest position larger j occurrence p pth symbol alphabet thus close regarded subdivided blocks size jsigmaj entries cyclically assigned different symbols alphabet trivial compute close x linear time let closesti p closest instance p right position occurrence set closesti 1 following property holds lemma 3 given table close sorted list occurrences p closesti p computed p olog jsigmaj time refer 2 proof lemma 3 main idea two accesses form must either identify desired occurrence else define interval jsigmaj entries occurrence list p within desired occurrence found binary search hence olog jsigmaj time note symbols x partitioned individual symboloccurrence lists log jsigmaj overall time lists occupy linear space collectively construction enables us immediately get rid skipedges issued inside chain unary nodes present key element making latter fact possible cir cumstance already remarked map every path sink dawg hence also every maximal chain substring suffix hence interval positions x fact interval identified application closest tell far along chain one go along lines need show downward transition performed following identification made closest node want reach may either scan chain sequentially search logarithmically first option results adding overall time complexity term linear n second requires additional adhoc auxiliary links rate 2 log n per node log n point upward many point downwards overhead introduced second option olog n per transition absorbs olog possibly charged closest scheme adapted get rid skipedges directed leaves still face potential thetajsigmaj deferring edges per chain node many backup edges per branching node edges easy accommodate deferring edges node point branching node thus coalesce single downward failure link backup edges recall definition path fi back fi edge labeled edge must exist path closest branching ancestor fl fl let trivially node given label starting position earliest suffix whose path passes node use table closest array x find distance arc j climb using log n auxiliary upward links finally reach fl downward failure link considering deferring edges lead leaves edges entirely suppressed cost visiting subtrees involved search time introduces work linear overall since eg breadthfirst search suffices visit subtree finally consider collection deferring edges originate arbitrary leaf recall deferring edge labeled set leaf fl branching node fi done intent making accessible searches final target node j found along unary chain connecting fi closest branching descendant leaf specifically j node end first edge labeled chain connecting fi analogy discussed earlier j reached logarithmic time application closest problem thus prepared reach nodes searches without dedicating one separate deferring edge every node terms discussion lemma 1 idea could coalesce deferring edge deferring edges fl would charged arc suffix trie x let closest discern search time among individual symbols present arc specific case considering trie arc would one maps dawg path connecting fi however time enough since every symbol sigma guaranteed appear every dawg chain trie arc must go one step coalesce jsigmaj edges reaching along given path trie deepest one among edges intent search table closest used climb back appropriate depth symbol need show done consistently ie connected path supporting climb guaranteed exist let w word associated fl w shortest extensions w v contains least one instance every symbol sigma w 0 ends branching node suffix trie let w respectively longest words equivalence classes w w 0 recall fl replica node corresponding w clearly must path dawg connecting node w w 0 labeled v moreover dawg node corresponding w 0 must branching node corresponding node trie construction branching node must exist also tree must connected root path labeled suffix connected path labeled v exists claimed conclude pointing log factors appearing claims reduced log log expense additional bookkeeping deploying data structures especially suited storing integers known range 8 also likely log n factors could made disappear entirely resort amortized finger searches eg 2 5 conclusion described data structure suitable reporting occurrence pattern string constrained subsequence another string since fullfledged data structure would bulky practical allocations compact sparse version built space saving traded exchange overhead search time parameters perhaps susceptible improvement particular clear bounds attained fixed alphabet sizes cannot extended without penalty case unrestricted alphabet nontrivial estimates bounds terms rocc appear complexities may shed light expected worst case performance search finally little known indices would return time linear pattern size whether given pattern occurs episode subsequence textstring 6 acknowledgements indebted referees thorough scrutiny original version paper many valuable comments r pattern matching algorithms longest common subsequence problem revisited smallest automaton recognizing subwords text fast approximate matchings using suffix trees algorithms priority queue initialization queue operations take olog log n time patternmatching model instrusion detection discovering frequent episodes sequences approximate string matching suffix trees introduction computational biology tr searching subsequences text algorithms pattern matching algorithms discovery frequent episodes event sequences approximate stringmatching suffix trees episode matching ctr zdenk tronek episode directed acyclic subsequence graph nordic journal computing v11 n1 p3540 spring 2004 abhijit chattaraj laxmi parida inexactsuffixtreebased algorithm detecting extensible patterns theoretical computer science v335 n1 p314 20 may 2005 robert gwadera mikhail j atallah wojciech szpankowski reliable detection episodes event sequences knowledge information systems v7 n4 p415437 may 2005 philippe flajolet wojciech szpankowski brigitte valle hidden word statistics journal acm jacm v53 n1 p147183 january 2006
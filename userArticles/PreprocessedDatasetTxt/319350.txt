specificational functions mathematics supplies us various operators creating functions relations sets known functions function inversion simple example operations useful specifying programs however many strong constraints arguments ensure result indeed function example functions bijective may inverted serious impediment use specifications best limits specifiers expressive power worst imposes strong proof obligations programmer propose loosen definition functions constraints operations inversion greatly relaxed specificational functions emerge generalize traditional functions application arguments may yield good outcome arguments application may yield several outcomes unpredictably functions general algorithmic serve specifications traditional functions embodied programming languages idea specificational functions new accommodating generality without falling foul myriad anomalies proved elusive investigate technical problems hindered use propose solutions particular develop formal axiomatization reasoning specificational functions prove consistency constructing model b introduction square function integers defined sqr z traditionally regarded welldefined inverse neither injective surjective suppose however broaden definition functions inverse sqr call sqrt indeed function might define sqrt thus permission make digitalhard copy part material without fee granted provided copies made distributed profit commercial advantage acm copyrightserver notice title publication date appear notice given copying permission association computing machinery inc acm copy otherwise republish post servers redistribute lists requires prior specific permission andor fee morris bunkenburg used instance call prescriptive expression general form 2xt j p intuitive meaning x type satisfying predicate p x regard 2xt jp equivalent special expression pronounced bottom many x information outcome actually produced example sqrt 4 may yield 2 gamma2 dont know care indeed cannot even determine behavior experiment sqrt 4 yields 2 morning may well yield gamma2 afternoon sqrt 7 sqrtgamma4 yield another example suppose type phonebook comprised relations type name type phonenumber following function looks persons phone number phone book lookup lookup necessarily function traditional sense people listed phone books several entries would like treat elaborate example consider function takes arguments function f set selects element f minimized example instantiating z yields either 1 gamma1 define leastwrt type thus illustrate use make function used two lovers travels city city computer consultant function yield city travel want together soon possible assume type city whose elements cities function timecity theta cityn yields least traveling time minutes say two cities function herscity ffl leastwrt ccity ffl timehis c max timehers c city need socalled flat type integers structured type function type example specifies familiar factorial function elaborate example usefulness choice function types let us specify program playing oneplayer game rubiks cube assume context provides set cube legitimate states game set legalmoves subset cube cube describing set legal moves value goal 2 cube describes goal game player modeled function f cubecube position player moves position b players specificational functions delta 3 eliminate players get stuck goodplayers player cost total number moves taken play possible games cost program want gameplayer cost goodplayers sqrt lookup leastwrt gamep layer examples functions liberally defined call specificational functions although specificational functions general computational play important role specifying computational functions example sqrt might presented programmer specification program implement meant produce computational function sqrt whose behavior consistent sqrt consistent mean sqrt applied perfect square x yields square root x either negative non negative otherwise behaves way programmer fancies example programmer might well design sqrt graph say sqrt refinement sqrt write sqrt v sqrt roughly holds expressions e f contexts possible outcomes e superset possible outcomes f slight twist refined terms mathematical way saying customer asks impossible better willing accept whatever given readers familiar refinement calculi may feel good cause w would appropriate symbol refinement v traditionally used may help think v suggesting increasing information content example context applying sqrt 4 outcome 2 among outcomes applying sqrt 4 2 gamma2 context applying sqrt gamma2 outcome 49 acceptable sqrt applied gamma2 yields refinement calculus essence language transitive refinement relation v terms language computational remainder available describing desired behavior process making program consists producing sequence language terms t0 v t1 v v tn t0 customers specification tn computational term sequence except first constructed incrementally predecessor say term sequence refinement predecessors programming stepwise refinement wirth 1973 example process albeit somewhat informal one terms language written partly informal pseudocode motivation studying specificational functions desire use part refinement calculus supports development functions whether functional imperative programming unlike stepwise refinement mind fully formal mathematical system refinement formally provable deduction given axioms morris bunkenburg ff xt ffl e j yt ffl exny fresh e j xt ffl f extensionality skolem fig 1 axiomatic properties functions requires axiomatization logic axiomatization base types functions operate axiomatization functions traditional functions typically axiomatized postulating properties figure replaced f subject usual caveat renaming avoid variable capture similarly predicates j extensionality e f functional type tu listed properties independent one another one axiomatization would use employ axioms specificational functions fall foul myriad anomalies shall see shortly effect inhibit deployment seriously example common restrict choice flat types rules example specification gameplayer investigate technical problems propose solutions particular develop formal axiomatization reasoning show sees anomalies 11 outline rest paper next section introduce concepts notations equivalence finement choice proper values third section explains detail anomalies occur functions choice meet suggests ways avoiding fourth section axiomatizes language constructs pairs fifth section core paper presents axiomatization specificational functions avoids discussed anomalies sixth section discusses logic argues prefered logic seventh section gives denotational model calculus finally draw conclusions review related literature 12 contributions detailed exposition six anomalies occur functions choice combined suggestions anomalies avoided axiomatization specificational functions denotational model 2 mathematical preliminaries 21 equivalence choice refinement presume availability strong equality operator j terms reserving weak computational equality operator found programming languages weak equality explained use equivalence specificational functions delta 5 synonym strong equality equivalence reflexive symmetric transitive congruence replace f term without changing meaning choice inherent 2xt j p may unbounded 2xz j true may yield integer hand may x satisfying p 2xt jfalse introduce special term abbreviation 2xt jfalse may seem intuitively reasonable v f hold term f refinement calculi commonly depart intuition postulating v f terms f adopt latter approach known excluding miracles calculus gives rise arguably easier apply practice although underlying theory slightly complex choice central concerns paper nothing substance follows depends note 2xt j true differs refined even nonterminating expression application recursive function f f x bottom type indicated subscripting nearly always omit type either significant context easily inferred refinement calculi partial operations 30 commonly equated similarly nonterminating expressions also customary use dont care term customer indicates interest outcomes although may useful contexts distinguish various roles program derivation similar represent error situations outcome unpredictable unconstrained precisely one x type satisfying predicate p call k equivalent k one consequence specificational functions include traditional total functions finite choice expressed terms binary choice e u f specifies choice among terms e f use words term expression interchangeably example 2 u 3 specifies 2 3 without preference written equivalently 2xz j x j evident u commutative associative idempotent standard postulate refinement calculi refinement equivalence related e follows v reflexive transitive antisymmetric respect j also follows zero u readers coming background formal logic might tempted view rough equivalent hilberts ffl operator leisenring 1969 would mistake little connection two roughly speaking ffl represents choices already made everyone time whereas 2 represents choices yet made may made differently different occasions hilbert choice 2 3 always 2 always 3 dont know one hand 2 u 3 sometimes 2 sometimes 3 formal terms ffl operator satisfies axiom words p true x type true fflxt j p assertion hold ffl replaced 2 example letting j abbreviate fflxz j x truth j k standing 2xz j x false ffl operator useful program refinement requires looseness specification resolved programmers way times places example customer asked 6 delta j morris bunkenburg error message displayed file unavailable without stating preference wording message would require every programmer deliver exactly message amusingly choice hilberts choice diners restaurant would choose meal menu postulate operators base types like integers strict ie zero distribute choice design decision properly reflects fact brand choice allows different resolutions different occasions example although 2 u would equivalent 0 according hilberts brand choice admit possibility first occurrence 2u3 outcome 2 second outcome 3 vice versa hence behaves strictly distributively 22 propers instantiation rule universal quantification asserts truth term e instantiation rules easily lead inconsistencies presence bottom choice example theorem arithmetic might tempted infer contradiction earlier conclusion similar anomaly arises instantiate infer two ways dilemma either modify standard laws arithmetic take account bottom choice modify rules instantiation easiest fix modify instantiation rules forbidding instantiations terms involving unresolvable choice call terms improper terms proper example 2u3 improper whereas proper final example assumed distributes u intention every expression either proper bottom choice among propers requirement 8xt ffl p similarly instantiated proper terms condition underlying logic terminology sndergaard sestoft 1992 opted strict singular semantics list alternate approaches technically expression e type proper iff 9xt ffl e j x course ensure useful definition shall axiomatize type infer truth otherwise 9xt ffl e j x postulate common base types z char float flat ie 8x yt ffl deduce flat types e u f proper iff e proper equivalent f also postulate constants case integers 0 1 gamma1 2 gamma2 etc proper formally deduce say proper 2 proper differs 3 write proper e abbreviation 9xt ffl nonflat types function types considerably complex flat types determining expressions proper need obvious shall see us came know functions studying functions integers reals easy seduced accepting properties functions may hold functions flat types true general even case specificational functions advise reader think nonflat types whenever looking specificational functions delta 7 intuitive understanding sometimes misguided thinking terms flat types purpose examples denote two type least two propers u v u v ie u v whether type exists course consequence design decisions however usually functional types nonflat example might reasonably considered proper remainder paper use lower case letters proper ex pressions upper case letters arbitrary possibly improper expressions 3 anomalies section expose problems encountered straightforward axiomatization functions drawn figure 1 used presence bottom choice 31 betaequivalence extensionality specificational functions combination axioms fi extensionality leads inconsistency consider xz ffl xgammax xz ffl 0 extensionality conclude equivalent since 8xz ffl xgammax j 0 apply function turn deduce j 0 similarly deduce applying two functions 2 u 3 turn fruitful attack anomaly restricting extensionality axiom two functions question simple expect equivalent extensionality however restricted remedy shall adopt restrict fi axiom proper arguments anomalies disappear since neither 2 u 3 proper course left question assigning meaning applications improper arguments choose make function application strict distribute choice symbols e g example functions yield applied 0 applied 2 u 3 forget function types also accommodate bottom choice reasons symmetry decide function application strict distributive function well argument ie g decisions arent controversial since reasonable alternative lead quandary shall see first several examples inconsistencies arise naively applying traditional laws functions ridding requires com promise choose compromises make life pleasant possible put tools intended use purposes change might compromises example insisting strictness would appropriate target program language lazy functional language like eg haskell peterson hammond 1997 calculus explored bunkenburg 1997 hehner 1993 1998 decision whether function application distributes choice left open general must decided individually every abstraction developer writes morris bunkenburg 32 distribution j following inconsistency discussed solved satisfactorily meertens 1986 using j prove equivalence transforming one elsewhere omit type information reduce syntactic clutter g f show 3 u 4 u 5 u 6 j 3 u 6 applying higherorder function f g turn assuming f proper 1 whereas g get 3 u definitely want 3 u 4 u 5 u 6 j 3 u 6 calculation assumed x ffl x u 3 proper shall see later reasonable jaxiom also leads us conclude tu xt ffl u equivalent ap strict specificational functions delta 9 runs counter practice imperative functional programming languages imperative languages example body function f supplied argument procedure proc inspected point invoking proc point invoking f within body proc resolve dilemmas restricting jaxiom proper functions tu functions x ffl x u x ffl improper much say properness functions later 33 extensionality distribution postulating distribution application consequence extensional equivalence functions breaks presence higherorder functions consider f proof equivalence must lead contradiction h ffl previously proved equivalent j distribution prove equivalent extensionality extensionality uap choose resolve inconsistency function equivalence require extensionality general turn case proper functions extensionality sufficient reflection restriction surprising unrestricted extensionality identifies functions tu wishes 34 monotonicity distribution difficult deduce function application distributes u function application monotone respect v follows introduce inconsistency construct nonmonotone function function f twou f u recall two two propers u v u v assuming conditional expression whose first argument proposition available construct f thus xtwo ffl x j u 1 else 2 shall avoid anomaly admitting abstractions xt ffl e restriction hindrance practice turns operators used programming languages used specifications indeed monotone function f nonmonotone j nonmonotone operator trivially functions flat domains monotone even bodies employ nonmonotone constructs possible set reasonable morris bunkenburg syntactic rules forming abstractions guarantee monotonicity although acceptable abstractions might ruled little disappointing refine monotone body abstraction retain obligation show monotonicity necessarily preserved refinement example x j uthen 1u2 else 1 monotone refined x j u 2 else 1 monotone fortunately examples rare know rely use strong j v operators however theoretical surprises shall see later 35 monotonicity skolem skolem axiom 8xt ffl9yu fflp 9f u ffl8xt fflp ynf x promises existence certain functions seems intuitively reasonable presence monotonicity requirement functions may promising impossible recall type two propers u v u v let p holds function f promised skolem axiom would map u 1 v 2 monotone essence problem restriction monotone functions skolem axiom promises existence monotone mapping every possibly nonmonotone mapping promise cannot kept shall postulate skolem axiom able derive reasonable p example x p x drawn flat type skolem holds return point later 4 axiomatization process axiomatize prescriptive conditional expressions also explain method axiomatizing types operations using pairtypes example serve model complex function types come 41 axiomatizing language constructs let e abbreviate e 6j following postulate captures intuitive idea refinement described earlier conjunct e f required distinguish 2xt ffl true antisymmetry v deduce follows determine whether given expression e refined another expression f whether e equivalent f need know whether e f bottom propers refine language construct foo need able determine foo foo v x fresh x general strategy define axioms simple example see axiomatization u figure 2 defining axioms prescriptive expressions given figure 3 axiomatization prescriptive expressions makes assumptions underlying logic specificational functions delta 11 ue fig 2 axioms u fig 3 axioms prescriptive expressions different assumptions might made would give rise similar axiomatization possible axiomatize language constructs foo defining foo v e arbitrary expression e determine foo instantiating e determine foo v x instantiating e x see example axiomatizations conditional assertion expressions figure 4 assertion expression form p gamma e equivalent e p true otherwise assertion expressions called assumptions ward 1994 discussed eg moller 1989 increasingly becoming part specification program languages eg eiffel meyer 1992 serve annotate expressions little knowledge used refinement example finding zero function integers might specified f zz ffl 2xzjf wish inform implementor function ever invoked monotonically increasing functions specify 42 axiomatizing types new type introduced must provide axioms describing propers case pair types properness seems perfectly straightforward proper pairs form x proper constituents x every proper x x proper pair captured first two axioms figure 5 figure 5 also gives axiomatization operations pairs observe shape two axioms describe type constructor pair forma tion two axioms describe type destructor two projection functions describe left projection fst right projection snd simi lar third axiom states pair formation strict arguments fourth states refinement carried componentwise formulation axiom slightly cluttered need state refinement guaranteed either component intimate relationship refinement choice import axiom pairformation distributes choice arguments axioms fst obvious final axiom fact implies fst distributes choice fig 4 axioms conditional assertion expressions morris bunkenburg fig 5 axioms pair types 5 axiomatizing functions axiomatize function types following strategy pairs keeping mind desired properties functions collected earlier 51 core axioms partial axiomatization functions given figure 6 recall use lower case letters propers uppercase letters arbitrary expressions conse quently lower case variables figure 6 universally quantified done minimize syntactic clutter upper case ones also omitted types avoid clutter example first axiom full first axiom familiar jequivalence proper functions shows every proper function written abstraction taking pair types model expect companion axiom determines abstractions proper turns lot said without committing axiom postpone consideration moment second group axioms defines abstraction axiom ensures desire distinguish xt ffl met axiom v implies desired property extensional equivalence proper functions remaining axioms define single function destructor viz application effect asserting function application strict distributive application reduced substitution essential interplay abstraction application captured axiom fij nothing corresponding axiom fij pair types axiom ap states three ways function application yields either function argument application normal yields observe ap apv function application determined considering applications e f e f proper refinements e f respectively even though yet fixed abstractions proper axioms figure 6 imply large body desired theorems including listed figure 7 particular function application strict distributive monotone either side proper functions refinement equivalence extensional abstraction refined refining body assuming monotonicity preserved bound variable abstraction renamed assuming logic gives renaming universally quantified variables finally moving choice abstraction refinement equivalence might expected see observe xz ffl even x 2 else 3 refines xz ffl 2 u 3 whereas specificational functions delta 13 e e v f8x fij x ffl e j exny fig 6 core axiomatization functions apmon apmon g v h mon e v x ffl f ff x ffl e j ffl exny x free variables e e u x ffl f fig 7 theorems follow axioms figure 6 refinements xz ffl 2 xz ffl 3 illustrate axioms prove mon axioms deduce u e v x ffl f e e axioms v transitive deduce e u x ffl f u greatest lower bound respect v e x ffl e mon e property choice axioms figure 6 resolve anomalies section 3 example recall functions f used putative equivalence functions section 3 construct difficulties j extensionality although remain extensionally equal longer equivalent 14 delta j morris bunkenburg 2 f g arbitrary f g u v final line general hold seen instantiating f x ffl even x x else 3 52 proper functions must address question functions proper first definitely expect traditional functions proper ie abstractions xt ffl e e proper proper x second already ruled tu proper third consider abstractions xt ffl e e values x proper remaining values x ie traditional partial functions assume moment deem improper consider extreme example xt ffl improper must equivalent choice proper refinements impossible assumption proper functions proper outcomes conclude must include partial functions among propers finally left question whether functions x ffl 2 u 3 whose bodies contain unresolvable choice considered proper seem two reasonable views liberal view accept abstractions proper conservative one regard x ffl 2 u 3 improper case equivalent choice infinite collection proper functions refine ie functions whose application argument equivalent either 2 3 2 u 3 including x ffl 2 x ffl 3 x ffl even x 2 else 3 many others according view abstraction proper iff body proper bottom liberal view adopted postulating axiom prop properxt ffl e incidentally axiom erased figure 6 presence axiom since follows therefrom assuming underlying logic ensures 8xt ffl x disadvantage proper functions include rather exotic elements frequently exclude explicitly cluttering specifications hand liberal view often convenient calculationally particular tell appearance whether function f proper hence whether f subject instantiation whether fij applies f argument higher order function conservative view embodied axiom e 8xt ffl e proper e specificational functions delta 15 states effect proper functions partial functions mathe matics however calculations may hard prove given abstraction proper exists proper function satisfying property stance show x ffl e proper refinement ie 9f ffl x ffl e v f show 9f ffl 8x ffl e v f x enough exhibit mapping x x 8x ffl e v x must find monotone mapping although liberal conservative views seem roughly equally attractive surface conservative view rejected subtle anomaly consider function g else 1 would seem two refinements ie g 1 g 2 else 1 however g 2 rejected monotone conclude help law 2 g j g 1 contradiction assumption g 1 proper g seems reasonable escape include g among propers 2 implies g 6j g 1 g g proper refinement whereas g 1 root cause anomaly certain seemingly natural refinements functions lost monotonicity requirement although true liberal conservative views significant former view parent function retained among proper refinements information lost conclusion specificational functions axiomatized figure 6 axiom replaced prop 53 total functions function types bring new subtlety notion properness point property e proper refinements longer holds function types introduced example although functions proper let us say expression e type say total satisfies total e iff refinements ie iff x example xz ffl 2 total xz ffl x0 gamma 2 flat types pair types derived flat types totality properness identical function types however totality stronger properness fact specializes usual sense word totality obviously important concept use rescue skolem axiom shown cannot hold specificational functions general prove still remains irritation however although skolem promises existence function f satisfying property p guaranteed refinements f also satisfy p restrict predicates monotone sense v 0 x condition automatically satisfied type flat 54 recursive functions recursively defined functions form f u ffl xt ffl e e type u may contain free occurrence f notation allows us write recursive function without naming usually recursive functions simultaneously morris bunkenburg unfold f ffl x ffl e j x ffl efnf ffl x ffl e prefix x ffl efnf e v f fig 8 axioms recursive functions described named writing f may occur e body recursive function must monotone f ensure fixpoint exists details given section denotational semantics axiomatize recursion standard way fixpoint least prefixpoint respect refinement see figure 8 types omitted program development abstractions refined recursive functions recursive refinement suppose set implement specification x ffl e via recursion modus operandi proceed series refinements beginning e ending term form f x ffl e x ffl e appears within f along path transmuted nonalgorithmic notation algorithmic substitutes almost conclude f ffl x ffl f f recursive function ie x ffl e v f ffl x ffl f f say almost ensured recursion wellfounded programming terms invocations recursive function terminate every programmer knows although necessarily formal terms ensure termination recursive function argument recursive call must less incoming arguments respect wellordering added requirement captured formal statement recursion introduction theorem theorem fun e v f fny ffl yx gamma exny x x ffl e v wellorder source type f proof begin e v f ffl x ffl f axm unfold e v x ffl f fnf ffl x ffl f prove 8xt ffl e v f fnf ffl x ffl f wellfounded induction p x arbitrary x type specificational functions delta 17 assumption theorem v transitive mon expression variable f axm unfold thm ff thm mon 55 example construct small program decompose natural number sum two squares starting specification ss proceed standard way problems choosing finite search space containing j assuming repeatedly testing pairs contains candidate j test done reduce search space removing pairs eliminate time choose search space js lo lo hi naturals initially 0 b nc respectively summary ss v nn ffl ss 1 0 xip ss 1 lo let e denote body ss 1 difficult conclude following facts e lo lo lo using elementary properties else infer else lo 2 else ss 1 termination argument observe first e implies lo hi second observe comparison e ss 1 lo hi absolute difference two arguments ss 1 less 1 similarly ss 1 morris bunkenburg 1 practitioners recognize ingredients wellfounded ordering show termination e holds omit details e hold termination issue hence shown ss1 v f else lo 2 else 6 booleans propositions naturally every refinement calculus booleans given basic type flat type although common define boolean connectives strict distributive see example larsen hansen 1996 leftto right evaluating see example partsch 1990 turn seriously unattractive many familiar laws boolean algebra break result booleans become awkward handle calculationally turns however boolean connectives extended accommodate bottom choice quite different way almost familiar laws boolean algebra continue hold main loss law excluded middle described morris bunkenburg 1998a 1998b actually language refinement calculus used make specifications superset programs operations every type rich mathematics provide particular specificational languages boolean type includes arbitrary universal existential quantifications even infinite domains turns quantifiers suitably extended allow bottom choice retaining laws predicate calculus loss instantiation carried proper terms see morris bunkenburg 1998b details including hilbertstyle axiomatic presentation made assumptions logic reason specifications theory pretty much independent choice choice unusual construct comprehensive axiomatization booleans including quantifiers elected avoid duplicated effort adopting logic reasoning specifications short distinguish propositions booleans means example even something exotic e v f e j f boolean expression hence specification advantages disadvantages one disadvantage refinement equivalence primary sources nonmonotonicity abstractions advantage facilitates smooth transition specifications programs propositions migrate effortlessly specifica tionsprograms often want formally extract programs specifications see morris bunkenburg 1998b example 7 model theory section provide denotational semantics language constructs given purpose ensure consistency calculus underpin understanding particularly recursion model parameterized models base types logic specificational functions delta 19 theta u theta u fig 9 interpretations types grammar types type given base types type interpreted complete partial order element none contain extend partial order usual way giving semantics functional programming language interpret every expression type element however approach accommodate choice accommodate choice interpreting every expression e subset intuitively contains interpretations possible outcomes e model recursion refinement need order sets order appropriate total correctness calculus ie one e u j one smyth order v 0 see plotkin 1976 smyth 1978 defined b subsets inconveniently v 0 antisymmetric make antisymmetric restricting upclosed sets upclosure subset partial order p written defined pg avoid double subscripts abbreviate conveniently upclosed sets v 0 identical therefore interpret every expression type upclosed subset meaning recursion refinement using every type denote p set fs g upclosed subsets abbreviate p base type b set b given ordered simply equality pair types interpreted product constituent types function type tu interpreted functions f p 1 u monotone sense u interpretation base type z interpretations pair functiontypes collected figure 9 0 denote left right projections pairs constituents construction universal domain superset every type clerical using definitions figure 9 readers familiar models untyped calculus note require since dealing typed language environment ae mapping variable type element addition maps recursiondummy f type tu element expressions interpreted induction structure every expression e type interpreted environment ae set eae element j morris bunkenburg proposition interpretation ae fig 10 interpretation refinement equivalence expression x type interpretation xae p e else f p c fcg ape f rec dummy f ae f fig 11 interpretation expressions constant c base type given element c every operator symbol f base types given matching function f matching mean argument types f result type u f function 0 dont give model logic rather assume every proposition p interpreted environment ae element p ae assume tt interpretation theorem logic ff interpretation antitheorem logic twovalued logic domain propositions would ftt ffg interpretations true false give interpretations propositions figure 11 gives semantics typed expressions easily verified every expression e type interpretation eae set upclosed respect recursive function f ffl x ffl e interpreted fixpoint functional f defined f acts p u complete lattice order language restriction x ffl e must refinementmonotone f ensure f monotone therefore generalized limit theorem hitchcock park 1972 nelson 1989 ensures least fixpoint exists mathematics construction exclude cases f empty set f specificational functions delta 21 set containing functions map arguments empty set one choose specification language way cannot happen fact f element p 1 finally give examples three expressions 2 2 u 3 z interpreted f2g f2 3g f 0 g abstraction xz ffl 2 interpreted singleton set containing function maps every element z f2g abstraction xz ffl 2 u 3 interpreted set containing functions mapping element z nonempty subset f2 3g 8 conclusion related work specificational functions made combining regular functions choice bottom taking special care accommodate higherorder functions shown examples usefulness making specifications extracting computational functions specifications technical difficulties stand way establishing consistent set laws reasoning well known led severe restrictions use past see commentary related work picked way around difficulties arrive axiomatic treatment fall foul anomalies key elements approach 1 richer notion equivalence extensionality based refinement 2 restriction quantifications range proper elements properness carefully defined type 3 imposition monotonicity requirement functions clearly compromises made believe practicioners could comfortably live compromises arrived two standard ways combining functions choice move setvalued functions generalize functions binary relations reject moving setvalued functions calculations leads frequent packing unpacking values sets even though often set singleton set relational approach lends well calculation see eg bird de moor 1997 brink schmidt 1996 however would like stick functions capture better directional nature programs inputtooutput mappings decision means dont lose direct connection current program languages functions relations munich cip development method based widespectrum language cipl comprehensive account given partsch 1990 cipl similar concepts choice equivalence strong equality refinement descendancy bottom properness functions defined possibly recursive abstractions ever severe limitations placed functions cipl importantly choice quantification functions forbidden clear us restriction enforced paper bodies abstractions must monotone bound variable cipl automatic since every language construct monotone anyway abstractions considered proper main transformation rules ff fiv called unfold theorem exnf f concise axiomatization given partsch 1990 clear rules axioms theorems 22 delta j morris bunkenburg calculation functions dealt thesis hoogerwoord 1989 language underdetermined clauses specify value asserting property enjoys closely related hilberts ffl refinement pretty much impossible norvell hehner present refinement calculus expressions norvell hehner 1993 giving incomplete list axioms language similar one discussed main differences lie treatment termination properness functions calculus term bottom representing nontermination therefore partial correctness calculus termination recursive programs annotate expressions abstract execution times clear refinement timing relate abstraction x ffl e proper function terminology element iff e proper x since language bottom implies traditional functions elements seems intention flat types would avoid anomalies subsections 34 52 however believe system inconsistent since abstractions nonmiraculous refinements proper functions implies function types nonflat closely related work hehner 1993 1998 halfandhalf approach distributivity functions choice arguments described distinguish occurrences parameter body function distribution appropriate direct substitution argument appropriate occurrences syntactically decided course fixed function therefore abstractions distribute choice arguments others dont however approach seems impose host trivial concerns programmer clear whether sufficient compensating gains wards thesis ward 1994 presents functional specification programming language defined semantics models demonic angelic choice however language given proof theory suggestion given refinement laws sufficient practice new refinement laws generated proving candidates sound using semantics abstractions proper therefore function types nonflat inconsistency described subsection 34 occurs addressed language vdm includes loose letexpressions form let xt st p e intended meaning e x bound arbitrary value satisfying p ever axiomatization proved elusive bicarregui et al 1994 suggest approach taken larsen hansen 1996 larsen hansen larsen hansen 1996 present denotational semantics functional language underdeterminism type language extended comprehensiontypes form fe j xt ffl pg expression language extended choice underdeterministically selecting element type however element chosen depends whole environment even variables dont occur proof system based generalized type inference propositions rather equivalence refinement relations indeed hard see equivalence refinement would specificational functions delta 23 fit larsen hansen consider lambdaabstractions proper map propers bottom propers therefore anomalies subsections 34 52 could reproduced strong operators j added language previous work one present authors morris 1997 gives weakest condition semantics expression language choice bottom style semantics fits weakestprecondition semantics imperative refinement calculus however axioms logic given issues pertaining functions addressed acknowledgment thank david watt richard botting reviewing drafts paper r proof vdm practioners guide algebra programming relational methods computer science supplemental volume expression refinement avoiding undefined underspecification practical theory programming unified algebra induction rules termination proofs design functional programs calculational approach semantics underdetermined expressions mathematical logic hilberts fflsymbol eiffel language e3 logic reasoning equationally presence partiality undefinedness nondeterminacy program proofs generalization dijkstras calculus specification transformation programs powerdomain construction power domains refinement calculus nondeterministic expressions systematic programming tr themunich project cip generalization dijkstras calculus specification transformation programs formal approach software development eiffel language nondeterminism functional languages practical theory programming proof vdm algebra programming nondeterministic expressions predicate transformers relational methods computer science systematic programming applicative assertions logical specifications functional programs ctr j morris bunkenburg source inconsistency theories nondeterministic functions science computer programming v43 n1 p7789 april 2002 joseph morris malcolm tyrrell terms unbounded demonic angelic nondeterminacy science computer programming v65 n2 p159172 march 2007
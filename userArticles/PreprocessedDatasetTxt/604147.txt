type theory memory allocation data layout ordered type theory extension linear type theory variables context may neither dropped reordered restriction gives rise natural notion adjacency show language based ordered types use property give exact account layout data memory fuse constructor ordered logic describes adjacency values memory mobility modal describes pointers heap choose particular allocation model based common implementation scheme copying garbage collection show permits us separate allocation initialization memory locations way account optimizations coalescing multiple calls allocator b introduction highlevel programming languages ml java allow programmers program terms abstractions pairs records objects welldefined semantics whose realizations terms underlying concrete machine left unspecified unobservable sometimes necessary program without abstractions programmer may need interact operating system network another programming language way require exact knowledge control manner data laid memory compiler must choose concrete implementation highlevel abstractions provided source level languagesuch actual layout data memory manner memory gets allocated initialized traditionally needs addressed un typed weakly typed fashion languages c give programmers relatively precise control data layout initialization expense type memory safety traditional compilers represent programs internally using untyped languages relying correctness compiler preserve safety properties enjoyed source program recently research areas typed compilation certified code 12 21 11 focused providing type systems lowlevel languages abstractions control flow data layout made explicit ideas used number compilers 12 21 9 2 19 6 however mechanisms invented describe lowlevel operations fairly ad hoc yet interpretation standard type ory example typed assembly language formalism11 allocation initialization separated expense annotate type flag indicating whether value classifies initialized kind lowlevel technique seems unlikely integrate well highlevel programming language paper attempt give type theoretic account data layout provides foundation defining highlevel constructs pairs laid memory realize system concrete allocation model based common implementation copying garbage collector show separate process allocating block memory process initializing individual memory words system flex 23 3 4 5 1 figure 1 three possible layouts term 345 ible enough permit multiple allocation calls coalesced memory multiple source level objects allocated si multaneously ensuring calls allocator never invalidate assumptions made state partially initialized data important contribution work remains completely within framework lambda calculus enjoys standard metatheoretic properties way reconcile lowlevel notion allocated memory substitution properties expected highlevel programming language particular interest suggests possibility ideas could made available programmers even programs requiring detailed control memory layout could written highlevel language 2 data layout allocation specifying layout data memory essential part realizing highlevel program concrete collection machine instructions data one usually direct interest programmers programmer cares ability construct objects time cares layout memory insofar affects performance operations object terms laid memory therefore matter policy compiler writer example lambda calculus term 345 type int intint defines pair whose first element 3 whose second element pair containing 4 5 figure shows several possible representations term one compiler might choose represent pointer pair whose elements integer pointer another pair however another might choose add indirection integers attempt flatten whole term three adjacent cells memory high level notion pairing captures certain operational properties useful programmer uniquely specify implementation strategy commonly compiler simply chooses interpret pair type meaning one particular strategy purposes giving general account data layout clearly unsatisfactory permit us break highlevel concept constituent concepts first step general type theory data layout observe seem two key concepts used different interpretations pairing given figure 1 adjacency indirec tion different choices representation corresponds different choice data represented physically adjacent bytes memory data represented via indirection another portion memory first notion shall attempt capture type system 21 allocation layout data memory made explicit becomes possible consider process new memory created initialized suggest useful think terms three stages regardless mechanism employed reservation process new block uninitialized memory created initialization process values get written reserved memory potentially changing type important type safety either memory treated linearly stage else initialization operations refine type 3 allocation process section reserved presumably initialized memory made available ordinary unrestricted object different memorymanagement systems combine stages different ways example tal framework 11 reservation allocation done atomically hence initialization restricted change type concrete memory management system choose model one commonly used practice copying garbage collectors hence particular interest choice essential systems expressed using similar techniques present copying garbage collector available memory divided two adjacent contiguous sections heap containing data allocated since last garbage collection perhaps youngest generation thereof possibly empty freespace containing memory yet allocated allocator maintains allocation pointer freespace pointer points end allocated data start free memory heaplimit pointer points end free memory create new heap object requiring n bytes program first compares allocation pointer heaplimit pointer ensure least n bytes available freespace calls garbage collector free enough space step corresponds reservation phase discussed sufficient memory foundeither existing freespace calling garbage collectorthe program may assume n bytes space exist front allocation pointer refer initialized area frontier space reserved frontier values written individual cells memory via offsets allocation pointer corresponds initialization phase point program may move prefix frontier heap value allocation pointer becomes pointer new heap value allocation pointer advanced past allocated space corresponds allocation phase figure 2 gives example process first line shows schematic diagram heap freespace ap stands allocation pointer lp stands limit pointer heap freespace lp ap x c 3 freespace x5heap lp ap x reserve 4 abcd 4 b c lp ap freespace c heap lp ap x freespace figure 2 reservation initialization allocation 345 ragged boundary freespace indicates information extentit may potentially exhausted second line figure shows result reserving four words spacesufficient allocating term 345 using first layout strategy figure 1 refer individual cells frontier names abc note step may invoked garbage collector free memory freespace previously line fact exhausted create pair 45 assign 4 5 b allocate b heap getting back heap pointer x shown third line figure initialize toplevel pair writing 3 c x final allocation step gives us pointer refers heap allocated structure form pictured first line figure 1 example shows require entire frontier allocated single object program may choose reserve space several objects initialize allocate individually optimization avoids multiple checks heaplimit pointer two constraints process must captured type system ensure safety firstly manner move objects heap means objects cannot allocated middle end fron tier prefixes frontierthat contiguous blocks memory adjacent allocation pointermay allocated secondly reserved space frontier cannot persist across successive reservations across function calls garbage collector called copy live data new heap change allocation pointer point new location partially initialized data previously frontier lost process corresponds kind destructive effect state frontier cannot assumed preserved across evaluation term could potentially call allocator type system must therefore ensure assumptions state frontier persist across evaluation term might reserve allocate memory 3 ordered linear type theory ordered noncommutative linear logic variant standard linear logic hypotheses must used exactly must also used order 17 16 18 15 corresponding proof terms make ordered lambda calculus characterized lack exchange property ordered context addition usual linearity restrictions present small fragment ordered lambda calculus way introduction ideas presentation simpler previous work omits linear context retaining ordered unrestricted contexts modal therefore moves directly ordered terms unrestricted terms typing rules ordered lambda calculus form gw indicating type variable assumptions declared unrestricted context g ordered context w distinguish syntactically ordered variables must used linearly order unrestricted variables x may used arbitrarily often unlike standard linear type theory ordered comma operator interpreted simple list concatenation permit intermingling hypotheses unambiguous write instead singleton contexts unrestricted arrow multiplicative unrestricted contexts x unrestricted variables n integer literals fuse intro leta 1 2 minm fuse elim lxte lambda intro lambda elim figure 3 standard ordered lambda calculus syntax definition means concatenation contexts preserves order entries contexts multiplicative connective fuse demonstrates use concatenation operator elimination rule fuse splits components places ordered context notice variables representing components 1 go ordered context place w finally mobility modal permits terms orderedly closed moved unrestricted context g g 31 size preservation adjacency three interesting observations make ordered lambda calculus terms motivate application ordered type theory data layout 1 ordered variables may exchange position context may think ordered variables simply standing locations ordered context 2 may break ordered terms components reform may change order particu lar term splits apart ordered pair reforms opposite order welltyped let 1 2 1 viewed linear rather ordered term code would welltyped 3 modality takes ordered term whose location fixed moves unrestricted context location become indeterminate based observations propose following three intuitions basis system 1 ordered context may thought describing particular region memory consideration ordered variables correspond locations offsets region adjacent variables context correspond physically adjacent lo cations extents given types variables 2 fuse constructor 1 2 describes terms physically adjacent memory fact cannot reorder ordered terms corresponds naturally fact cannot reorder bytes memory 3 modality corresponds indirection region memory described ordered context another unspecified part heap standard ordered lambda calculus entirely justify intuitions ordered terms preserve order subcomponents general preserve adjacency essence problem seen derived ordered substitution principle notice portion ordered context passed term bound replaced variable typechecking rest body intention operations done inplace memory described ordered context however following term demonstrates hold general ordered lambda calculus g problem able insert unrestricted terms ordered terms arbitrary places violate notion ordered variables correspond locations mean locations fixed operationally would seem would forced shift w 2 memory make room new term context alternative way looking general ordered lambda calculus size preserving subderivation g produces term size one context size zero interpret ordered context describing region mem ory term inserts wordsized value empty region memory order prevent problematic terms necessary carefully restrict calculus way ensure operations memory preserve size notion size preservation last insight necessary formulate lambda calculus give full account data layout use fuse type describe adjacency modal type describe indirection restricting terms way enforce various key size preservation properties allocation model described section 2 accounted using ordered context describe frontier ordered variables become offsets frontier reservation initialization allocation become operations ordered terms linearity ns n v v lxte v ns n lxte v reserve n e alloc q xin e let let let x x e let x e figure 4 syntax ordered context permit destructive operations frontier initialization size preservation property ensure operations frontier may done inplace 4 orderly lambda calculus ideas need define language data layout allocation shall call orderly lambda calculus l ord short sake brevity paper focus small core language captures essential ideas syntax core language given figure 4 use notation n nary fuse data layout purposes require new types ordered lambda calculus fuse constructor models adjacency modal constructor models indirection multiplicative unit types include base type integers type unrestricted functions ns nonsense type type single uninitialized word memory important purposes distinguish types unit size hence kept registers stack types must heap allocated accomplished kinding distinction k kind reg classifies types values may loaded registers whereas kind h classifies types may heapallocated strict superset former important property language types uniquely determine size data classify simplicity smallest unit size consider single machine word multiplicative unit type size zero since inhabited single value therefore need rep resented view function type unit size since expect practical implementation would use closures represent functions closure conversion lambdas become existentially quantified records allocated heap hence represented pointer unit size assume actual code function statically allocated ordered contexts w map ordered variables types used describe regions memory particular frontier notion sizing types extends naturally ordered contexts exchanging discarding duplicating variables ordered context permitted unrestricted contexts g map ordinary variables x types wellformedness judgement unrestricted contexts checks unrestricted variables unitsized typesthat types whose kind reg ordinary variables correspond registers stack slots underlying machine restricted word size via kinding mechanism key point orderly lambda calculus large objects required explicitly allocated initialized term level l ord split four separate syntactic classes coercion terms q heap values v terms expressions e main typing judgements described figure 5 along comments size properties enjoy complete definitions typing rules found appendix making allocation explicit introduces kind effect lan guage reserving allocating memory effectful operation saw previous section effects may interfere order control effects interaction introduce distinction terms expressions e style pfenning davies 14 without explicit modal type computations computation type seem useful setting since inclusion expressions terms instead taking partial arrow primitive syntactic form impose overly restrictive actually related permissive anormal cps forms many compilers typically use 41 terms terms correspond values reserve allocate course evaluation may contain free references ordered variables frontier presentation terms valuesbut straightforward useful include primitive operations allocate integer oper ations level typing judgement terms form term may refer variables g arbitrarily often must refer variable w exactly ordered fashion typing rules terms part unsurprising labstraction case body function checked expression argument placed unrestricted context notice permit free references frontier functions since function application lies category expressions judgement size properties meaning w w wellformed ordered context wellformed unrestricted context wellformed type look like nonallocatingnonreserving term type typed expression type consumes w closed value type welltyped frontier ordered context w figure 5 typing judgements l ord defer discussion elimination form section 44 terms must closed respect ordered context nonstandard term v term corresponds pointer heap location occupied heap value v canonical form terms type g trm interesting facet presentation account heap allocation without requiring explicit heap example style morrisett harper 10 heap semantics pointer value v represented label bound v explicit heap datastructure since sharing observable simple calculus avoid extra complexity representing values directly v denoting pointer location occupied v stress purely technical convenienceit straightforward give heap semantics sharing made explicit usual fashion 42 heap values may occur memory therefore essential closed open heap term would require new copy implicitly allocated every time different values substituted contrary aims l ord typing judgement heap values val enforces property primary motivation heap values comes operational semantics language however intended play role socalled semantic objects permitted introduced course evaluation perfectly reasonable programmer write heap values source program corresponds precisely notion statically allocated datathat data present heap start program important difference heap values terms heap values may arbitrary size reflected syntax value denoting contiguous block memory v 1 laid adjacent value v 2 fact fused terms adjacent means constructor associative sense term 3 4 5 representation memory term 3 4 5 terms describe three successive words memory occupied integers 3 4 5 respectively fundamental difference ordinary lambda calculus pairing 345 almost certain different representation 345 associativity one example values different types representations examples include values involving ordered unit since choose represent value expect representations 3 3 3 runtime coercion terms exist provide mechanism convert values different typing structure underlying representation 43 coercions level coercion terms fragment language extremely simple consisting variables ordered unit fuse q 1 q 2 coercion binding elimination forms provided expression level section 44 intuitively coercion terms package frontier new forms without changing underlying representation example term 1 2 takes section frontier described 1 section described 2 combines single fuse could bound new name using expression level coercion let orderedness terms ensures two sections already adjacent hence combining fuse change representation typing judgement coercion terms form w crc signifying q reassociates w form coercive nature terms exhibited size preservation property holds judgement unit term welltyped empty context 44 expressions far seen value forms occupy coerce memory modify memory operations reservation allocation initializationare done level expressions wellformedness judgement expressions given ordered context w typing judgement describes current state frontier destructive nature reserve allocate operations interpretation frontier consumed expression e space frontier must either allocated e explicitly destroyed saw section 2 memory operations effectful type system expressions must carefully designed ensure effects interfere enforced always passing entire ordered context hence entire frontier subexpression subterm way ensure every possibly allocatingreserving expression correct view entire frontier evaluated expressions conceptually divided four basic categories ordinary expressions inclusion values expressions given expression retm g g value form expressions consumes sources unsound permit term contain ordered vari ables since may substituted unrestricted variable primitive let form discussed function application expression since evaluation body function may engender memory effects applications syntactically restricted permit application term another term g trm term applied permitted refer ordered variables argument must closed since unrestricted functions may duplicate drop arguments application allows us define termlevel let construct following derived typing rule g let fully general since way bind result application variable therefore introduce primitive let form bind expressions variables notice pass entire ordered context first sub expression crucial point e 1 may memory effects could invalidate previous assumptions state frontier e 2 might make therefore e 2 cannot assume anything state frontierthat must welltyped empty ordered context somewhat surprisingly safe permit e 1 free references ordered context reasonable expressions consume resources contain mean value form expressions retm welltyped empty ordered context therefore ordered context w empty e 1 must explicitly destroy allocate memory described w reaches value since value orderedly closed safe substitute freely unrestricted variable x memory expressions interesting nonstandard expressions dealing directly frontier recall three operations interest reserving space frontier initializing pieces frontier allocating prefixes frontier heap three operations captured directly primitives shall see later entirely necessaryby extending type system somewhat give types primitives constants simplicity however first present primitive notions first operation reservation discards resources previously mentioned ordered context introduces n words nonsense frontier reserve n corresponds exactly reservation operation described section 21 destroys existing data frontier provides block new uninitialized space memory must written using assignment g ordered term q gives location ordered context value written location referred body expression linearity ordered context important since destructively changing type memory location point space allocated left side frontier alloc construct coercion term q describes section frontier packaged boxed heap value splitting ordered context ensures term allocated prefix frontier new heap value given pointer type permitted used unrestrictedly rest program coercion expressions memory expressions manipulate frontier using ordered variables stand offsets frontier coercions used manipulate ordered variables combining bigger terms breaking smaller pieces simplest coercion expression elimination form unit g fuse load x mi e load load fuse figure 6 example directload defined terms split since unit term considered zero size may eliminate freely ordered context without changing size adjacency properties terms frontier elimination form fuse also coercion expression intuition since 1 2 describes two adjacent blocks memory free view single block memory described q two adjacent blocks offsets named 1 2 last coercion operation simple ordered let form permits ordered terms packaged renamed load expressions memory operations account creation heap objects equally important ability load values heap object heap must way accessing components pointers small objects dereferenced directly g kinding restriction ensures values loaded operation fit register access fields larger objects provide composite elimination construct takes pointer large object produces two pointers immediate subcomponents object g notice variables bound components rather pointers components using expression may successively iterate large composite objects arrive pointer small object loaded directly construct somewhat disturbing practical standpoint two reasons first place seems require pointers interior objects sometimes called locatives order implemented efficiently completely question interior pointers quite problematic copying garbage collectors least implemented direct pointers interior heap objects importantly however construct permit constant time access fields heapallocated record example access last element nary tuple rightassociated form requires computations arrive term loaded directly clearly impractical choose use split operation primitive notion provides simple natural elimination form practice however likely term would eliminated favor one number directload constructs definable terms split figure 6 taking directload primitive giving direct implementation need interior pointers eliminated fields records loaded constant time 45 frontier semantics order make connection orderly lambda calculus frontier model allocation clear semantics keeps explicit frontier means reduction relation defined expressions rather frontier expression together frontier terms w defined figure offsets values v standpoint operational se mantics frontier plays role similar explicit substi tution typing judgement frontier w w asserts ordered context w describes frontier looks like w evaluation relation orderly lambda calculus given terms frontierexpression pairs relation w indicates frontier w expression reduces single step expression e new frontier w complete definition relation given appendix b straightforward show reduction preserves typing welltyped terms values may always reduced theorem 1 progress preservation 1 either w 2 w proof proof proceeds induction derivation help several substitution lemmas auxiliary lemmas proving properties ordered contexts frontiers 46 size properties important property orderly lambda calculus types uniquely determine size data represent informally mentioned number sizing properties calcu lus particular coercion terms preserve size terms expressions always unit size kept registers properties formalized follows theorem 2 size 1 2 3 w crc 4 val 5 gw trm 6 gw exp 7 w proof clause proceed separately induction typing derivations 5 representing lambda calculus one intended uses l ord target language translation higherlevel languages show done provide intuition language used present section translation simply typed lambda calculus products unit orderly lambda calculus begin defining translation ptq maps ordinary lambda calculus type l ord type product case unsurprising represent pair pointer heapallocated record containing subcomponents discussed section 2 representations possible represent ordinary lambda calculus unit pointer orderly lambda calculus unit recall l ord means chosen representation unit pointer zeroword object corresponds precisely standard implementation values type unit distinguished pointer nothing eg null pointer analogous translation defined term level interesting case translation pairing since pairs terms requiring allocation begin defining l ord function pair reserve 2 1 leta 1 leta 2 1 x 1 1 5 2 x 2 2 6 alloca 1 ret x 8 first line function reserves space frontier pair created binds single ordered variable points beginning space line 2 gives names 1 2 respectively first second words newly allocated space typing rule reserve see second location extra zerobyte value type unit attached lines 3 4 serve split eliminate lines 5 6 initialize two locations renaming 1 2 finally line 7 allocates initialized space heap names result x becomes return value function line 8 definition demonstrates various operations interact permit lowlevel code written relatively highlevel man ner particular mention offsets everything done terms standard alphavarying variables may seem code somewhat verbose simple define syntactic abbreviations composite terms eliminate much verbosity example common case initialization terms coercion term q variable may take advantage alphaconversion simply reuse old variable name yielding standard looking assignment syntax also trivial define composite reserve operation precomputes offset variables working definition term left exercise reader using abbreviations write pair constructor quite succinctly reserve 1 x 1 2 x 2 alloca 1 ret x elimination forms pairs given succinct definitions using direct load defined figure 6 fst load ret x 1 load ret x 2 remainder translation simply typed lambda calculus straightforward variables introduced translation assumed fresh plxteq pe let x x 1 x 2 let x let x let ret x fst x snd x 51 coalescing reservation translating simply typed lambda calculus terms orderly lambda calculus breaks high level memory abstractions exposes finer grain detail exposing details enable optimizations expressible abstract level simple example ability coalesce multiple calls allocator example consider result translating term 345 translation minor simplifications 1 4as 1 2 5as 2 alloca 1 2 x ret x reserve 2 asa 3 4 3 3as 3 4 x 4 alloca 3 4 x ret x code fragment makes two separate calls allocator reserving two words space easy see second reserve operation coalesced first reducing total number calls allocator opt reserve 4 asa 1 2 3 4 1 4as 1 2 5as 2 alloca 1 3 3as 3 4 x 4 alloca 3 4 x ret x kind optimization commonly done untyped compilers easily express typed setting step consider try coalesce two allocation op erations addition coalescing reservations unfortunately general possible setting problem currently cannot express pointers frontiersuch pointers would difficult typecheck since types locations frontier change therefore unable initialize second field top level pair moved pair heap 6 extensions future work paper given detailed presentation core orderly lambda calculus developing highlevel framework discussing issues allocation datalayout full language includes account sums recursive types permits sum allocation tagging done using memory mechanisms already described addition extended coercion level include ordered functions application forms shown rich language coercions definable setting finally shown reserve alloc write primitives replaced typed constants eliminating need incorporate special memorymanagement primitives language full language described separate technical report 13 important question yet addressed give account allocation objects dynamic extent system developed far predicated ability statically predict size object based type objects arrays however clearly true adhoc treatment arrays fairly easily integrated language unsatisfactory since intention make allocation explicit mechanism interesting possibility use dependent type formalism 23 type analysis formalism 4 introduce notion dynamic extent type system intend explore avenue future another important area future research attempt account pointers frontier saw section 5 forced allocate object heap initialize objects pointer prevents useful optimizations destination passing style optimization 8 7 related work ordered logic ordered type theory explored extensively pfenning polakow 16 15 significant amount previous work applying ordinary linear type theory memory management 1 22 5 7 none addresses intended address question separating allocation initialization giving foundational account data layout work closely addresses issues discuss alias type formalism smith walker morrisett 20 alias types allow aliasing information tracked exactly type system quasilinear type system allows memory locations destructively updated since aliasing tracked exactly explicit free operation provided deallocates space useful optimizations destination passing style optimization encoded fairly easily language alias type formalism seem provide explicit coalescing allocator calls provide explicit type theory describing data layout manner attempted r reference counting computational interpretation linear logic certifying compiler java type structure lowlevel programming langauges flexible type analysis garbage collection based linear type system safe dialect c functional represention data structures hole realistic typed assembly language semantics memory management polymorphic languages system f typed assembly language design implementation certifying compiler frank pfen ning judgmental reconstruction modal logic ordered linear logic applications natural deduction intuitionistic noncommutative linear logic relating natural deduction sequent calculus intuitionistic noncommutative linear logic properties terms continuationpassing style ordered logical framework overview flintml compiler alias types operational interpretations linear logic eliminating array bound checking dependent types tr functional representation data structures hole eliminating array bound checking dependent types design implementation certifying compiler quasilinear types semantics memory management polymorphic languages flexible type analysis operational interpretations linear logic system f typed assembly language certifying compiler java type structure lowlevel programming languages natural deduction intuitionistic noncommunicative linear logic ordered linear logic applications ctr byoungro mary w hall heidi e ziegler custom data layout memory parallelism proceedings international symposium code generation optimization feedbackdirected runtime optimization p291 march 2024 2004 palo alto california lars birkedal noah torpsmith john c reynolds local reasoning copying garbage collector acm sigplan notices v39 n1 p220231 january 2004 amal ahmed david walker logical approach stack typing acm sigplan notices v38 n3 march
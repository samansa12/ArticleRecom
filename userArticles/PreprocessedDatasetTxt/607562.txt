factored edgevalued binary decision diagrams factored edgevalued binary decision diagrams form extension edgevalued binary decision diagrams associating additive multiplicative weight edges fevbdds used represent wider range functions concisely result computational complexity certain operations significantly reduced compared evbdds additionally introduction multiplicative edge weights allows us directly represent socalled complement edges used obdds thus providing one one mapping obdds fevbdds applications integer linear programming logic verification proposed evbdds also benefit extension also present complete matrix package based fevbdds apply package problem solving chapmankolmogorov equations b introduction past decade drastic increase integration vlsi chips taken place conse quently complexity circuit designs risen dramatically todays circuit designers rely sophisticated computeraided design cad tools goal cad tools automatically transform description algorithmic behavioral domains one physical domain ie layout mask chip production divide process four different levels system behavioral logic layout logic level behavior circuit described boolean functions efficiency algorithms applied level depends largely chosen data structure originally representations sum products form factored form representations predominant today popular data structure boolean functions ordered binary decision diagram obdd provides compact canonical representation wake successful introduction concept function graphs obdds various function graphs proposed constrained boolean functions used denote arithmetic functions function graphs used state reduction finite state machines logic verification higherlevel specifications additionally applied problems outside cad integer linear programming matrix representation since introduction obdds r e bryant 5 several different forms function graphs proposed functional decision diagrams fdd presented alternative obdds representing boolean functions 3 ordered kronecker functional decision diagrams okfdd introduced 10 generalization obdds fdds multiterminal binary decision diagrams mtbdd 9 proposed represent integer valued functions extended functions finite sets 2 edgevalued binary decision diagrams evbdd 121314 provide compact means representing functions recently binary moment diagrams bmd bmd 7 introduced permit efficient wordlevel verification arithmetic functions including multipliers 62bit word size paper presents factored edgevalued binary decision diagrams fevbdd extension evbdds associating additive multiplicative weight edges fevbdds used represent wider range functions concisely result computational complexity certain operations significantly reduced compared evbdds additionally introduction multiplicative edge weights allows us directly represent complement edges used obdds paper also describes uses fevbdds applications integer linear programming logic verification matrix representation manipulation 2 review edgevalued binary decision diagrams edgevalued binary decision diagrams proposed lai et al 121314 offer direct extension concept obdds associating socalled edge value ev every thenedge obdd capable representing pseudoboolean functions integer valued functions application proven successful areas formal verification integer linear programming spectral transformation function decomposition definition 21 evbdd tuple hc fi c constant value f rooted directed acyclic graph e consisting two types vertices ffl nonterminal vertex f 2 v represented quadruple child f child e f evi variablef 2 fx binary variable ffl single terminal vertex f 2 value 0 denoted 0 nonterminal vertex f child child e f ev 0 two nonterminal vertices f g g furthermore exists index function following holds every nonterminal vertex child f also nonterminal must child e f nonterminal must definition 22 evbdd hc fi denotes arithmetic function c f function f denoted evi terminal node 0 represents constant denotes arithmetic function definitions 21 22 provide graphical representation pseudoboolean functions consequence integer variables encoded binary nbit integer variable shown evbdds form canonical representation functions definition 23 given evbdd hc fi representing fx function f variable x assigns value fx equal either 0 1 function evbddeval defined c f terminal node 0 child e fi f boolean arithmetic table 1 arithmetic equivalents boolean functions boolean functions represented evbdds using integers 0 1 denote boolean values true false boolean operations implemented arithmetic operations shown table 1 method described lai et al converts obdd representation boolean function corresponding evbdd representation proven function graphs obdd v evbdd denoting function f share topology except terminal node 1 absent evbdd edges connected redirected single terminal node 0 additionally shown boolean operations executed evbdds time complexity ojf j delta jgj boolean operations obdds concept complement edges realized evbdds done obdds generic operation apply defined implements arbitrary arithmetic operations evbdd representations two arithmetic functions f g general time complexity operation two evbdds flattened evbdds respectively flattened evbdd defined exactly manner mtbdd operations addition subtraction scalarmultiplication etc time complexity apply drastically reduced exploiting certain properties scalar multiplication c delta f done time complexity ojhc f f ij simply multiplying edge values c operations op addition fulfill additive property reduced time complexity ojhc f based evbdds concept structured evbdds sevbdds developed 14 sevbdds allow modeling conditional expressions vectors main use lies field formal verification 3 factored edgevalued binary decision diagrams factored edgevalued binary decision diagrams fevbdd extension evbdds associating additive multiplicative weight trueedges 1 fevbdds offer compact representation linear functions since common subfunctions differing affine transformation expressed single subgraph additionally allow notion complement edges transferred obdds fevbdds definition 31 fevbdd tuple hc w f rulei c w constant values f rooted directed acyclic graph e consisting two types vertices rule set weight normalizing rules applied graph ffl nonterminal vertex f 2 v represented 6tuple 2 child f child e f ev w binary variable ffl single terminal vertex f 2 value 0 denoted 0 definition branches leading 0 associated weight nonterminal vertex f child two nonterminal vertices f g g furthermore exists index function following holds every nonterminal vertex child f also nonterminal must child e f nonterminal must definition 32 fevbdd denotes arithmetic function c f function f denoted terminal node 0 represents constant denotes arithmetic function definition 33 given fevbdd representing variable x assigns value fx equal either 0 1 function fevbddeval defined 1 gcd rule requires also multiplicative weight associated elseedges 2 use rational rule holds w nodes thus represent nonterminal vertex 5tuple hvariablef child f child e f ev w c f f terminal node 0 figure example construct various function graphs based different decompositions function f given tabular form figure 1 2 9 3 y3 2 z equation 2 form directly corresponds function decomposition mtbdds adds tabular form equations 3 4 reflect structure decomposition rules evbdds fevbdds respectively different function graphs shown figure 1 figure goes figure 3 goes figure 4 goes representations signed integers based fevbdds presented figure 2 representations wordlevel sum product given figures 3 4 lemma 31 given two fevbdds generated using weight normalizing rule f g nonisomorphic holds exists assignment f 2 f0 1g n c f w f delta f 6 c g w g delta g assignment proof case 1 c f 6 c g let case 2 c definition nonisomorphism holds 9f consequently assignment f case 3 c assume holds f g nonisomorphic assignments f implies w f g consequently f g isomorphic contradicts original assumption thus holds 9f c f g 2 theorem 31 two fevbdds generated using weight normalizing rule ie rule denote function ie c f g isomorphic proof sufficiency c f g isomorphic 8f directly definitions isomorphism fevbddeval necessity c f 6 c g let holds fevbddevalhc f let f arbitrary assignment fevbddevalh0 holds fevbddevalhc f g isomorphic holds definition isomorphism fevbddeval follows c f w f delta val 6 c g w g delta val f g nonisomorphic lemma 31 holds nowwe prove lemma last condition f isomorphic g need show f g isomorphic 9f 2 f0 1g n fevbddevalh0 without loss generality assume indexvariablef indexvariableg let prove lemma induction k base g terminal nodes furthermore g isomorphic induction hypothesis assume holds induction show hypothesis holds case 1 ev f 6 ev g let fx ngammak holds ev g w f let f arbitrary assignment fx ngammak holds fevbddevalh0 deltafevbddevalh0 g isomorphic holds fevbddevalh0 val thus ev f w f g nonisomorphic lemma 31 applicable almost identical prove given ev w e f f e g e nonisomorphic subcase 1 f g nonisomorphic induction hypothesis see exists f fevbddevalh0 let f 0 defined f 0 subcase 2 otherwise f e g e nonisomorphic similar arguments letting definition reduced fevbdd cannot ev isomorphic f e ev f 6 0 let fx ngammak fevbddevalh0 g independent first n gamma k bits ev let f assignment fx ngammak indexvariableg furthermore let f fevbddevalh0 val f 6 0 fevbddevalh0 corresponding subgraph f topvariable x ngammak g isomorphic holds val val g graphs nonisomorphic apply reasoning proof lemma 31 oth erwise f f e nonisomorphic least one isomorphic g f nonisomorphic induction hypothesis exists assignment f 1 f 0 holds fevbddevalh0 shown fevbdds form canonical representation function specific weight normalizing rules uniquely determine node weight new node computed based descendants propose two basic rules used guarantee canonicity fevbdds given two fevbdds rule node weight w hc w f rulei computed follows 1 gcd rule 2 rational rule make new nodex hc f compute new weights guarantee uniqueness return table 2 make new node weight normalizing rules cf table applied whenever new node generated using make new node routine cf table 2 routine enforces canonicity function graph well uniqueness routine find add preserves uniqueness nodes new node actually created quick hash table lookup performed node already member table stored node unique id returned otherwise new node entry hash table created new node unique id returned thus guaranteed every node stored hash table although gcd rule requires multiplicative weight associated true elseedges cases might rule choice function range purely integer gcd rule avoids dealing fractions particularly valuable since arithmetic operations fractions significantly time consuming built hardware routines integers furthermore restriction integers use gcd rule brings clear advantage memory efficiency even though need store additional weight memory consumption per node less using rational rule requires use fractions every fraction internally represented one integer numerator one norm weightev w f case gcd else ifw 6 else returnsign case rational return else ifw 6 return else return ev break table 3 norm weight denominator course soon application requires use fractions rational rule preferred nevertheless gcd rule still applicable since define gcd u 31 operations done obdds 5 evbdds 14 provide generic algorithm apply implements arbitrary arithmetic operations two fevbdds cf table 4 apply takes two fevbdds rule g well operation op arguments fevbdds based weight normalizing rule algorithm recursively branches top variable ie variable least index f g reaches terminal case terminal cases depend operation op example op terminal case computational efficiency algorithm improved significantly taking advantage computation cache recursive process started quick lookup computation cache performed successful result op returned immediately without computation entries cache uniquely identified key consisting operands operation op whenever new result computed stored computation cache general complexity operations performed apply okhc ik mentioned improve computational complexity apply making use properties specific operations adapt concept additive property proposed evbdds lai et al 14 extend socalled affine property fevbdds definition 34 operator op applied said satisfy affine property factor w defined arbitrary value 3 3 similar rational rule alternatively define affine property follows benefits affine property remain check terminal case ifterminal return result op already available computation cache ifcomp table lookuphc rule g iophc ans w ans ans rule ans return hc ans w ans ans rule ans perform recursive computation op child g rulei else f child f rulei child e f rulei else f ge store result computation cache comp table inserthc return table 4 apply operations satisfy affine property addition subtraction scalar multiplication logical bit shifting main advantage affine property lies reducing computational complexity apply since separately compute parts result generated constants c f c g two subgraphs h0 w rulei hit ratio computation cache drastically increased separating influence constants always storing results concept applied every recursion step constant value never passed next recursion level unfortunately still pass multiplicative weights w f w g since cannot separated functions f g achieve improvement hit ratio extract common divisor w w f w g promote w 0 f w 0 g advantage cases reducing problem performing already computed problem 0 quantify influence gcd extraction worst case computational complexity operations satisfying affine property given ojhc f evbdds corresponding fevbdds respectively scalar multiplication logicalbit shifting offer better computational complexity since computed time independent size function graph scalar multiplication requires weights root node multiplied case evbdds multiply every edge weight scalar task complexity ojf j since multiplication satisfy affine property basically required use original version apply multiplication two functions high percentage reconverging branches following approach tends improve cache efficiency ojhc calls multiply every call requires three calls apply adding separate terms first addition costly since first term always constant however second third addition potentially costly addition additive property two properties bounding property domainreducing property introduced lai et al 14 12 done additive property properties easily adapted fevbdds 32 representation boolean functions boolean functions represented fevbdds encoding boolean values true false integers 1 0 respectively basic boolean operations easily represented using arithmetic operations thus easily represent boolean function using fevbdds although could implement boolean operations based corresponding arithmetic functions far better terms computational complexity directly use apply boolean operations need provide necessary terminal cases applyhc boolean op case boolean conjunction operation example terminal cases 1 2 3 ifhc convert boolean function obdd fevbdd representation adapt algorithm suggested lai 14 additionally concept multiplicative weights allows us directly represent called complement edges need take care case algorithm 1 convert terminal node 0 h0 0 0 rulei 1 h1 0 0 rulei 2 nonterminal node hx ei obdd e already converted fevbdds following conversion rules applied 3 branch leading fromnode hx ei e complement edge perform complementation computing e respectively achieved multiplying weights c c e w w e gamma1 later adding 1 c c e four basic conversion rules listed conversion rules complete case fevbdds since also variations multiplicative weights either 1 gamma1 cases however handled exactly according norm weighting rule presented explicitly list done evbdds 14 shown following theorems hold theorem 32 given obdd representation v boolean function complement edges allowed fevbdd topology except terminal node 1 absent fevbdd v 0 edges connected redirected terminal node 0 theorem 33 given two obdds f g complement edges allowed corresponding fevbdds time complexity boolean operations fevbdds using apply ojfj delta example fevbdd representing boolean function complement edges given figure 5 fevbdd represents four output functions 3bit adder topology except terminal edges corresponding obdd depicted figure shown example fevbdds successfully extend use evbdds represent boolean functions inherently offer way represent complement edges furthermore boolean operation performed constant time since requires manipulation weights root node figure 5 goes 33 logic verification purpose logic verification formally prove actual implementation satisfies conditions defined specification done formally showing equivalence combinational circuit ie description design specification intended behaviour general implementation represented array boolean functions f b specification given wordlevel function fw order transform bitlevel representation wordlevel use encoding function encode binary input signals circuit set input signals partitioned several subsets binary signals x every array x encoded using encoding function encode provides wordlevel interpretation binary input signals common encoding functions signedinteger onescomplement twoscomplement corresponding fevbdds shown figure 2 thus implementation described array boolean functions f b specification given wordlevel function fw x verification done proving equivalence encoding binary output signals circuit ie array boolean functions wordlevel function encoded input signals encode f b strategy logic verification first proposed lai et al using evbdds 1214 since fevbdds describe bitlevel wordlevel functions successfully applied logic verification although wordlevel operations represented fevbdds space complexity certain operations becomes exponential application limited small wordlength evbdd fevbdd representations wordlevel multiplication exponential fevbdds however offer significant savings memory consumption evbdds seen figure 4 wordlevel multiplication two threebit integers evbdd contains 28 internal nodes whereas fevbdd representation requires 10 nodes general evbdd denoting multiplication two nbit integers n nodes corresponding fevbdd contains n nodes ratio evbdd nodes fevbdd nodes n1 seen ratio savings number nodes fevbdd representation order n example 16bit multiplier requires 1114095 evbdd nodes 65551 fevbdd nodes even take account fevbdd node requires 20 bytes versus 12 bytes per evbdd node savings remain significant evbdd133 mbyte fevbdd 13 mbyte done evbdds 14 fevbdds also extended structured fevbdds allow modeling conditional expressions vectors 34 integer linear programming algorithm fgilp solving integer linear programming ilp problems based evbdds proposed lai et al 15 fgilp realizes ilp solver based function graphs uses mixed branchandboundimplicitenumeration strategy shown approach successfully compete branchandbound strategies require solution corresponding linear programming problems latter strategy one widely applied commercial programs ilp problem formulated follows minimize subject x integer since evbdds fevbdds allow binary decision variables encodings shown figure 2 applied 32bit integer example represented evbdd fevbdd nodes since fevbdds form extension evbdds also apply fevbdds solve ilp problems expect reduction memory requirement fgilp using fevbdds due fact different multiples integer variables x appear equations 5 6 use evbdds represent multiples x build evbdd every different coefficient ij since scalar multiplication evbdds performed multiplying edge weights factor use fevbdds however store fevbdd representing x multiples x easily realized associating corresponding multiplicative edge weights dangling incoming edges leading x example storing 6x 7x 5x requires 96 nodes use evbdds nodes apply fevbdds 35 implementation arbitrary precision arithmetic introduction multiplicative weights combination rational rule weight normalizing makes necessary extend value range edge weights integer domain rational domain done way future expansion domains complex domain easily achieved operations edge weights accessed standardized interface invokes specified function executes requested operation depending current mode thus fevbdd code remains fully independent selected domain changing another mode easily switch integer domain rational domain example means still use fast routines single precision integers necessary multiple precision integers realized arrays integers arithmetic operations implemented based algorithms multiple precision arithmetic given knuth 11 multiple precision fractions implemented arrays two multiple precision integers one integer represents numerator one denominator enforced package numerator denominator remain relative prime numerator signed achieved computing greatest common divisor gcd numerator denominator dividing numerator denominator gcd operation performed whenever input given internally data guaranteed remain normalized form form strictly enforced operations thus rational value always uniquely represented numerator denominator gcd computed fast euclids algorithm binary gcd algorithm 11 multiprecision fractions use binary gcd algorithm since works fast integers multiple word length relies subtraction right shifting require division operations single word precision fractions employ classical version euclids algorithm since division executed efficiently single word integers basic arithmetic operations fractions realized follows ffl multiplication ffl division u ffl addition 351 symbolic operations finite fields fevbdds constrained integer valued functions one already see use rational rule easily represent functions rational function values complex values also feasible additionally use symbolic computation even though value ranges extended using rational complex edge weights decision variables still binary thus want represent linear functions containing variables value ranges encode binarily done integers generally approach leads means represent function finite fields fevbdds proposed adds 2 case fevbdd generally represents function phi fi denote operations finite field ite operator acts switch either selects subfunction denoted true elseedge contrary add approach exploit relationships subgraphs 4 matrix representation manipulation matrices successfully represented using mtbdds 8 9 adds 2 implementations basic matrix operations addition multiplication given popular class matrices efficiently represented mtbdds evbdds class walsh matrices generated recursive rule 41 representation matrices basic idea using function graphs represent matrices encode row column position matrix elements using binary variables 8 theta 8 matrix example requires 3 binary variables rows another 3 columns basically view problem representing theta n matrix representing function finite set element positions finite set r elements binary variables giving row position called row designators x 2 fx g ones denoting column position called column designators 2 fy g imposed variable ordering row column designators mixed together order g chosen variable ordering subtrees function graph directly correspond submatrices given matrix seen figure 6 based correspondence pseudoboolean function denoting matrix given easily fm xy figure 6 goes furthermore ordering allows matrices represented compactly submatrices identical mtbdds transformed affine transformation 4 fevbdds since concept square matrices ie vertical size keep many algorithms efficient simple consider square matrices maxmn make nonsquare matrices square easily pad rows columns filled zeros significantly increase memory consumption storing matrix since padded blocks uniform therefore represented nodes already mentioned mtbdds offer compact memory efficient representation matrices feature identical subblocks require different terminal node distinct matrix element fevbdds far better concept fevbdds allows two subblocks represented subgraph differ affine transformation elements introduce special class matrices always represented fevbdd linear size class matrices sizes corresponding mtbdd evbdd bmd likely exponential definition 41 recursivelyaffine matrix recursively generated using following rules 1 begin 1 theta 1 matrix integer rational constant value 2 every recursion step new matrix n1 created based previous result n arbitrary integer rational numbers 4 affine transformation transformation form figure 7 shows general structure fevbdd corresponds recursion step building recursively affine matrix every recursion step structure shown figure 7 added already constructed fevbdd figure 7 goes seen figure 7 need 3 nodes represent recursivelyaffine matrix size n x n example recursively affine matrix build figure 8 fevbdd matrix given 9 5 26 22 64 figure 8 goes important class matrices belongs family recursivelyaffine matrices set walsh matrices hadamard ordering 17 matrices used compute spectral transforms boolean functions recursively defined follows figure 9 shows fevbdd evbdd representations walsh matrix h h 3 seen figure 9 size fevbdd representation 2 delta n n denotes order walsh matrix size evbdd representation 4 figure 9 goes generally speaking employing function graphs mtbdds fevbdds represent sparse matrices offers following advantages 1 comparison normal sparse data structures function graphs provide uniform log 2 n access time n number real elements stored function graph example nonzero elements sparse matrix 2 function graphs may able beat sparsematrix data structures terms worst space complexity however recombination isomorphic subgraphs may give considerable practical advantage function graphs data structures particularly valid fevbdds since subgraph represent matrices generated affine transformation matrix represented subgraph 42 operations operations matrices divided two major groups first group comprises termwise operations scalar multiplication addition etc second group formed matrix multiplication matrix transpose matrix inversion termwise operations easily implemented based function graphs simply use apply compute termwise operations matrices obviously possible since applyop performs operation op every single function value ie works termwise manner matrix specific operations transposition require tailored algorithms matrix multiplication clearly nontermwise operation since requires computing scalar vector product row left matrix column right matrix get value single matrix element product matrix therefore present two different recursive procedures perform matrix multiplication function graphs first method proposed mcgeer 9 algorithm direct link common conventional method matrix multiplication every recursion step problem divided four subproblems terminal case reached steps operands expanded regard pair row column designators expansion even takes place function graphs actually dependent current pair internal variables need scaling step necessary second method let matrix multiplication denoted matrix addition method formally stated written terms matrices4 h xy h xy f xz f xz5 4 g zy g zy zy g zy5 computations performed every recursion step obviously method requires eight calls matrix multiply four calls matrix add every recursion step ie every internal variable pair second method proposed bahar 2 unlike previous method expands top variable two operands ffx g process matrix multiplication following variable order imposed decide whether top variable f g selected top variable expansion depending character expansion variable var one following computations made every recursion step approach expands internal variables actually encountered function graphs f g requires keep track missing z variables f g since every z expansion step corresponds performing matrix addition p gives number omitted z expansions two recursion steps scale result 2 p returning using cache always store unscaled results scale entry accordingly reading cache another method proposed clarke 9 basic idea take products first compute sums matrix package implemented second method appears superior two 2 implemented two different versions method version 1 passes value edge weights every recursion step matrix multiply okfk delta kgk complexity done multiplication two fevbdds suggest second version function graphs high ratio reconverging branches eg recursivelyaffine matrices follows f operations rowadd coladd generate matrices 0i complexity ojf j second version requires ojf j delta jgj calls matrix multiply every recursive call matrix multiply also requires three calls matrix add improves cache efficiency matrix multiplication considerably operands represented fevbdds high ratio reconverging branches outweighs added overhead three calls matrix add case better use original approach since require additional overhead matrix transposition performed exchanging roles column row designators belonging expansion level maintain imposed variable ordering nodes function graph exchanged sufficient interpret row column designators vice versa transposition done ojf matrix inversion done performing gaussian elimination original matrix identity matrix time words solve system linear equations use pivoting row transformations steps required gaussian elimination consist 19 ffl selecting partial pivot every step j ja pj ffl normalizing selected row multiplying row inverse pivot 1 ffl swapping rows j p according pivot selection subtracting multiples pivot row j rows j operations except row swapping implemented efficiently time ojaj ojaj delta jrj r denotes fevbdd representing pivot row row swapping performed matrix multiplication matrix permutation matrix p therefore complexity permutation matrices obtained denotes permutation matrix swapping rows j represents identity matrix ij designates matrix rs rs general partial pivoting done order improve numerical accuracy gaussian elimi nation since implementation relies fractions arbitrary precision always use exact values numerical stability issue order avoid unnecessary row swapping perform partial pivoting holds step j addition basic matrix operations fast search operations specific matrix elements implemented algorithms searching value position minimal maximal absolute maximal element given matrix developed approach makes use min max fields associated every node computational complexity finding value position minimal maximal element n theta n matrix olog 2 dne explain basic idea behind algorithms case searching maximal element given fevbdd node f two successors f f e easily determine edge leads maximal element based values max min fields f f e simply recompute max field f select successor originally generated max field f value maximal minimal element interest computed directly min max field top node f without computation value evbdd fevbdd range gcd rational integer 12 bytes 20 bytes 24 bytes fractions table 5 memory requirement per node 43 experimental results applied fevbdd based matrix package problem solving chapmankolmogorov equations 18 arise computing global state probabilities fsms though memory consumption inversion routine relatively low 8m inverting 64x64 matrix run time high due several factors first algorithm gaussian elimination purely sequential whereas fevbdds recursively defined consequently computation caching matrix inversion exist recursive algorithm matrix inversion perform much better fevbdds secondly using fractions arbitrary length operations need substantially time necessary ordinary integers therefore use obtained inverses primarily examples real life nonsparse matrices represented compactly using fevbdds compare evbdd representations seen table using fevbdds gives savings 50 compared evbdds number nodes required represent nonsparse inverse course one consider storage requirement per node higher fevbdds evbdds overview memory usage per node various modes available evbdds fevb dds given table 5 assume every evbdd node consists integer fractional edge value two pointers children every fevbdd node consists two fractional edge weights two pointers rational mode three integer edge weights two pointers gcd mode total memory consumption storing matrices using evbdds fevbdds shown tables 6 7 respectively given memory usage based evbdds fevbdds using fractions fevbdds generated using rational rule case ck equations use fractions edge weights since matrix elements fractions seen tables fevbdds better inverses lose original matrices terms total memory consumption due fact original matrices sparse whereas inverses nonsparse case sparse matrices additional properties fevbdds exploited evbdds fevbdds perform similarly number nodes fevbdds however lose terms memory requirement higher cost per fevbdd node since evbdds least good mtbdds also gives idea performance fevbdds compared mtbdds 5 conclusion showed associating additive multiplicative weight edges edgevalued binary decision diagram evbdds could successfully extended factored edgevalued binary decision diagrams new data structure preserves canonical property evbdd allows efficient caching operational results properties defined evbdds could adapted fevbdds additive property extended affine property shown fevbdds provide compact representation arithmetic functions evbdds additionally complexity certain operations could reduced significantly showed fevbdds representing boolean functions allow us incorporate concept complement edges originally proposed obdds furthermore showed evbdd based integer linear programming solver fgilp benefits using fevbdds instead evbdds combination fevbdd package also implemented arithmetic package supplies arithmetic operations integers fractions arbitrary precision complete matrix package based fevbdds introduced applied package solving chapmankolmogorov equations experimental results show majority cases fevbdds win corresponding evbdd representation matrices terms number nodes memory consumption acknowledgement authors like thank yt lai supplying evbdd package many helpful discussions r binary decision diagrams al gebraic decision diagrams applications relation bdds fdds efficient implementation bdd package graphbased algorithms boolean function manipulation symbolic boolean manipulation ordered binarydecision diagrams verification arithmetic functions binary moment diagrams spectral transforms large boolean functions application technology mapping multiterminal binary decision diagrams efficient data structure matrix representation efficient representation manipulation switching functions based ordered kronecker functional decisiond diagrams art computer programming volume 2 seminumerical algorithms edgevalued binary decision diagrams multilevel hierarchical verification vrudhula evbddbased algorithms integer linear programming spectral transformation function decomposition edgevalued binary decision diagrams vrudhula fgilp integer linear program solver based function graphs representation switching circuits binarydecisionprograms fast transforms algorithms analyses applications first course probability introduction numerical analysis factored edgevalued binary decision diagrams application matrix representation manipulation tr graphbased algorithms boolean function manipulation efficient implementation bdd package symbolic boolean manipulation ordered binarydecision diagrams edgevalued binary decision diagrams multilevel hierarchical verification spectral transforms large boolean functions applications technology mapping algebraic decision diagrams applications art computer programming volume 2 3rd ed fast transforms formal verification using edgevalued binary decision diagrams verification arithmetic functions binary moment diagrams ctr rolf drechsler bernd becker stefan ruppertz kbmds new data structure verification proceedings 1996 european conference design test p2 march 1114 1996 rolf drechsler wolfgang gnther stefan hreth minimization wordlevel decision diagrams integration vlsi journal v33 n1 p3970 december 2002
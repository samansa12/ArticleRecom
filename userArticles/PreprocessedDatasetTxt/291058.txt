value speculation scheduling high performance processors recent research value prediction shows surprising amount predictability values produced registerwriting instructions several hardware based value predictor designs proposed exploit predictability eliminating flow dependencies highly predictable values paper proposed hardware software based scheme value speculation scheduling vss static vliw scheduling techniques used speculate value dependent instructions scheduling instructions whose results dependent prediction hardware used provide value predictions allowing execution speculated instructions continue case misspredicted values control flow redirected patchup code execution proceed correct results paper experiments vss load operations specint95 benchmarks performed speedup 17 shown using vss empirical results value predictability loads based value profiling data also provided b introduction modern microprocessors extract instruction level parallelism ilp using branch prediction break control dependencies using dynamic memory disambiguation resolve memory dependencies 1 however current techniques extracting ilp still insufficient recent research focused value prediction hardware dynamically eliminating flow dependencies also called true dependencies 2 3 4 6 7 8 9 results shown values produced registerwriting instructions potentially highly predictable using various value predictors lastvalue stride contextbased twolevel hybrid predictors work illustrates value speculation future high performance processors useful breaking flow dependencies thereby exposing ilp paper examines isa hardware compiler synergies exploiting value speculation results indicate synergy enhances performance difficult integer benchmarks prior work value speculation utilizes hardwareonly schemes eg 2 3 schemes instruction address pc registerwriting instruction sent value predictor index prediction table beginning fetch stage prediction generated fetch dispatch stages forwarded dependent instructions prior execution stages value speculative dependent instruction must remain reservation station even execution continues prevented retiring verification predicted value predicted value compared actual result stateupdate stage prediction correct dependent instructions release reservation stations update system states retire predicted value incorrect dependent instructions need reexecute correct value figure 1 figure 1 pipeline stages hardware value speculation mechanism flow dependent instructions dependent instruction executes predicted value cycle predicted instruction illustrates pipeline stages value speculation utilizing hardware scheme little work done softwarebased schemes perform value prediction value speculation dependent instructions related approach different problem memory conflict buffer 1 presented dynamically disambiguate memory dependencies allows compiler speculatively schedule memory references possibly dependent memory instructions patchup code generated compiler ensures correct program execution even memory dependencies actually occur speculatively scheduled memory references improves performance aggressively scheduling references highly likely independent likewise valuespeculative scheduling attempts improve performance aggressively scheduling flow dependencies highly likely eliminated value prediction patchup code used values misspredicted apply scheme value speculation propose combined hardware software solution call value speculation scheduling vss hardware pipeline stages vss scheme shown figure 2 two new instructions ldpred udpred introduced interface value predictor execution stage ldpred loads predicted value generated predictor specified generalpurpose register udpred updates value predictor actual result resetting device future predictions missprediction figure 3 shows example using ldpred udpred perform vss original code sequence figure 3a instructions i1 i6 form long flow dependence chain must execute sequentially flow dependence figure 2 pipeline stages value speculation scheduling scheme two new instructions ldpred udpred interface value predictor execution stage original code i3 lw r4 0r3 i4 add r5 r4 1 i5 next b new code value speculation r4 predicted instruction i3 i3 lw r4 0r3 i7 ldpred r8 index load prediction r8 i5 i8 bne patchup r8 r4 verify prediction next patchup i9 udpred r4 index update predictor r4 i4 add r5 r4 1 i5 i10 jmp next figure 3 example value speculation scheduling instruction i3 i4 broken via vss dependence height resulting dependence chain shortened furthermore ilp exposed resulting data dependence graph figure 4 shows data dependence graphs code sequence figure 3 breaking flow dependence instruction i3 i4 assume latencies arithmetic logical branch store ldpred udpred instructions 1 cycle latency load instructions 2 cycles schedule length original code sequence figure 4a instructions i1 i6 seven cycles breaking flow dependence instruction i3 i4 vss results schedule length five cycles figure 4b illustrates schedule possible due reduced overall dependence height ilp exposed new data dependence graph fetch dispatch execute state update value predictor prediction verification fetch dispatch execute state update predicted value actual value predicted dependent fetch dispatch execute state update value predicted value ldpred udpred improved schedule length seven cycles five cycles consider penalty associated miss prediction due required execution patchup code impact patchup code performance discussed section 3 figure 4 data dependence graphs codes figure 3 numbers along edge represent latency instruction 4a schedule length seven cycles 4b exposed ilp dependence height reduction schedule length reduced five cycles figure 3b value speculation scheduler breaks flow dependence instruction i3 i4 instructions i4 i5 i6 form separate dependence chain allowing execution speculated scheduling become instructions i4 i5 i6 respectively operand instruction i4 modified r4 r8 register r8 contains value prediction destination register r4 predicted instruction i3 instruction i7 ldpred loads value prediction instruction i3 register r8 prediction incorrect r8r4 instruction i9 udpred updates value predictor actual result predicted instruction register r4 note resulting udpred instruction part patchup code execution required value misspredicted ensure correct program execution compiler inserts branch instruction i8 store instruction i6 branch patchup code predicted value equal actual value patchup code contains udpred original dependent instructions i4 i5 i6 executing patchup code program jumps next instruction i8 execution proceeds normal ldpred udpred instruction pair corresponds value prediction uses table entry index value predictor index assigned compiler avoid unnecessary conflicts inside value predictor number table entries limited possible conflicts deterministic factored choosing values predict compiler approach value predictor design featuring new ldpred udpred instructions described section 2 combining hardware compiler techniques strengths dynamic static techniques exploiting ilp leveraged see several possible advantages vss static scheduling provides larger scheduling scope exploiting ilp transformations identifying long dependence chains suitable value prediction reordering code aggressively valuespeculative dependent instructions execute early possible predicted instruction depend compiler controls number predicted values assigns different indices accessing prediction table instructions compiler deems good candidates predictions predicted reducing conflicts hardware patchup code automatically generated reducing need elaborate hardware recovery techniques instead relying statically predicted values eg profile data ldpred udpred access dynamic prediction hardware enhanced prediction accuracy vss applied dynamicallyscheduled processors staticallyscheduled vliw processors epic explicitly parallel instruction processors 14 drawback vss static scheduling techniques employed valuespeculative instructions committed speculative therefore always require predicted values hardware schemes dynamically decide appropriate speculatively execute instructions dynamic decision based value predictors confidence predicted value avoiding missprediction penalty low confidence predictions remainder paper organized follows section 2 examines value predictor design value speculation scheduling section 3 introduces vss algorithm section 4 presents experimental results vss section 5 concludes paper mentions future work 2 value predictor design microarchitectural support value speculation scheduling vss form specialpurpose value predictor hardware value prediction accuracy directly relates performance improvements vss various value predictors lastvalue stride contextbased two level hybrid predictors 2 3 4 6 7 9 breaking dependence b breaking dependence i3 i4 provide different prediction accuracy value predictors design complexity general provide highest prediction accuracy order feature ldpred udpred instructions vss previously proposed value predictors must redesigned slightly figure 5 shows block diagram value predictor includes ldpred udpred instructions value predictor three fundamental units current state block old state block prediction hardware block current state block may contain register values finite state machines history information machine flags depending prediction method employed old state block hardware duplicate current state block hardware predictions generated prediction hardware input current state block various prediction mechanisms used example generating prediction last value last value predictors 2 3 generating prediction sum last value stride difference recent last values stride predictors 4 6 7 9 also twolevel predictors 7 allow prediction recently computed values twolevel predictors value history pattern indexes pattern history table turn used index value prediction recently computed values twolevel value prediction hardware based twolevel branch prediction hardware figure 5 block diagram value predictor featuring ldpred udpred ldpred udpred instructions contain immediate operand specifies value predictor table index general independent prediction hardware chosen ldpred instruction performs three actions compiler assigned number indexes action first prediction hardware generates predicted value using input current state block second current state information shifted old state block last current state block updated based predicted value prediction hardware information used prediction hardware updated simultaneously current state block update note ldpred instruction predicted value used update current state block speculatively compiler assigned number also indexes operation udpred instruction value prediction incorrect patchup basic block figure 3b must executed execution udpred instructions occurs patchup code values miss predicted udpred instruction causes update current state block prediction hardware actual computed value old state block compiler ensure ldpredudpred instruction pair executed turn prediction verified value predictions nested old state block requires one table entry table entry old state block updated every ldpred instruction used every udpred instruction case missprediction figure 6 hybrid predictor stride twolevel saturating counters compared select prediction techniques vss scheme prediction needs generated ldpred instruction flag value predictor indicate value prediction valid goal value predictor generate many correct predictions possible paper stride twolevel hybrid value predictors 7 implemented find design provides highest prediction accuracy use vss scheme stride predictors predict arrays loop induction variables well twolevel predictors capture recurrence recently used values generate predictions based previous patterns values however neither alone obtain high prediction accuracy programs exhibit different characteristics therefore hybrid value predictors consisting stride twolevel prediction designed cover situations current state old state prediction hardware actual value ldpred predicted value ldpred udpred prediction index stride twolevel counters counters twolevel figure 6 shows hybrid predictor obtains high prediction accuracy selection stride predictor twolevel predictor different 7 every table entry saturating counter stride predictor twolevel predictor saturating counter increments corresponding prediction correct decrements prediction incorrect saturating counters predictors updated prediction regardless prediction actually selected hybrid predictor selects predictor maximum saturating counter value event tie hybrid predictor favors prediction twolevel predictor prediction accuracy results three value predictors presented section 4 3 value speculation scheduling performance improvement value speculation scheduling vss affected prediction accuracy number saved cycles schedule length reduction number penalty cycles execution patchup code suppose breaking flow dependence valuespeculative dependent instructions speculated saving cycles overall schedule length prediction correct patchup code also generated requires p cycles prediction accuracy speculated value x case speedup positive 1 holds example figure 3b vss saves 2 cycles 7 cycles 5 cycles resulting patchup code contains 5 instructions requiring 3 cycles ilp processor therefore positive speedup prediction accuracy must greater 33 actual prediction accuracy less performance degraded vss performance considerations mind algorithm vss proposed figure 7 first step perform value profiling scheduler must select highly predictable instructions improve performance vss results value profiling different inputs parameters shown strongly correlated 5 6 therefore value profiling used select highly predictable instructions perform value speculation value profiling performed registerwriting instructions profiling overhead concern filter may used perform value profiling select instructions select instructions may reside critical paths long dependence height long latency eg load instructions 5 estimating convergent profiling proposed reduce profiling overhead determining invariance instructions similar techniques could applied determining value predictability instructions next value speculation scheduler performs region formation treegion formation 10 region type chosen experiments treegion nonlinear region includes multiple execution paths form tree basic blocks larger scheduling scope treegions allows scheduler perform aggressive control value speculation data dependence graph constructed treegion step four threshold prediction accuracy used determine whether perform value speculation instruction instruction scheduler queries value profiling information get estimate predictability predictability estimate greater threshold value prediction performed aggressive scheduling instructions speculated choosing low threshold suggested values threshold derived experimental results section 4 instruction selected value prediction ldpred instruction inserted directly ldpred instruction immediate value assigned scheduler chosen index value predictor new register also assigned destination ldpred instruction new destination register chosen ldpred instruction dependent instructions need update source registers reflect new dependence ldpred instruction first dependent instruction chain dependent instructions needs update register source remaining dependencies chain 1 perform value profiling 2 perform region formation 3 build data dependence graph region 4 select instruction prediction accuracy based value profiling greater threshold 5 insert ldpred predicted instruction selected instruction step 6 change source operand dependent instructions destination register ldpred 7 insert branch patchup code 8 generate patchup code contains udpred 9 repeat steps 4 8 candidates found 10 update data dependence graph region 11 perform region scheduling 12 repeat steps 2 11 region figure 7 algorithm value speculation scheduling unaffected even though one chain dependent instructions may result one value prediction one ldpred instruction needed value prediction step seven branch patchup code inserted repairing misspredictions one branch per data value prediction required scheduler determines branch inserted location branch set instructions dependence chains predicted instruction branch patchup code candidates valuespeculative execution therefore desirable schedule instructions predicted instruction actual hardware resources restrict ability speculatively execute candidates value speculation also candidates value speculation duplicated patchup code number directly affects penalty missprediction factors affect schedulers decision place branch patchup code step eight patchup code created repairing miss predictions patchup code contains udpred instruction copy candidate valuespeculative execution unconditional jump back instruction following branch patchup code udpred instruction uses immediate value assigned scheduler corresponding ldpred instruction indexing value predictor source operand udpred instruction destination register predicted instruction actual result predicted instruction udpred instruction index actual result used update value predictor finally steps ten eleven data dependence graph updated reflect changes treegion scheduling performed machine resource restrictions dependencies candidates value speculation speculated predicted instruction section 4 shows results using different threshold values determining value speculation 4 experimental results specint95 benchmark suite used experiments programs compiled classic optimizations impact compiler university illinois 11 converted rebel textual intermediate representation elcor compiler hewlettpackard laboratories 12 lego compiler research compiler developed north carolina state university used insert profiling code form treegions schedule instructions 10 instrumentation value profiling intermediate code lego compiler converted c code executing resultant c code generates value profiling data experiments value speculation scheduling vss load instructions filtered targets value speculation load instructions selected usually critical paths long latencies value profiling load instructions performed programs table 1 shows statistics profiling runs number total profiled load instructions represents total number load instructions benchmark load instructions instrumented profiled number static load instructions represents number load instructions actually executed difference total profiled static load instructions number load instructions visited number dynamic load instructions total ed ic 0 10 20 30 40 50 70 80 90 100 res 130 132 peg 134 pe rl 147 vo rt e x ri hm e ic ean prediction accuracies load instructions tr de two leve hy b r figure 8 prediction accuracy load instructions stride twolevel hybrid predictors load executed multiplied execution frequency stride twolevel hybrid value predictors simulated value profiling evaluate prediction accuracy load instruction since goal paper measure performance vss rather required capacities hardware buffers indices conflicts loads modeled intelligent index assignment algorithm likely produce results similar development algorithm outside total profiled load instructions static load instructions dynamic load instructions 129compress 96 72 4070431 132ijpeg 5104 1543 118560271 134perl 6029 1429 4177141 147vortex 16587 10395 527037054 table 1 statistics total profiled static dynamic load instructions scope paper left future work value profiling every execution load instruction simulated prediction compared actual value determine prediction accuracy value predictor simulators updated actual values would hardware prepare prediction next use entry stride value predictor used two fields stride current value prediction always current value plus stride stride equals difference recent current values stride value predictor always generates prediction finite state machine hardware required determine prediction used twolevel value predictor design 7 four data values six outcome value history patterns value history table first level value history patterns index pattern history table second level pattern history table employs four saturating counters used select likely prediction amongst four data values saturating counters pattern history table increment three twelve decrement one zero selecting data value maximum saturating counter value always generates prediction hybrid value predictor stride twolevel value predictors utilizes previous description illustrated earlier figure 6 section 2 hybrid design saturating counters used select stride twolevel prediction also increment three twelve decrement one zero figure 8 shows prediction accuracy load instructions stride twolevel hybrid predictors prediction accuracy twolevel predictor higher stride predictor benchmarks except 129compress 132ijpeg however average prediction accuracy stride predictor higher twolevel predictor large performance difference 129compress examining value trace 129compress shows many long stride sequences predicted correctly historybased twolevel predictor hybrid predictor capable leveraging advantages prediction method highest prediction accuracy 63 average across benchmarks figures show prediction accuracy distribution load instructions using hybrid predictor figure 9 distribution static loads figure 10 distribution dynamic loads 124m88ksim 90 dynamic load instructions prediction accuracy 90 129compress 80 dynamic load instructions prediction accuracy 90 124m88ksim 45 static loads prediction accuracy 90 representing dynamic load instructions 129compress 70 static loads prediction accuracy 90 loads excellent candidates vss high prediction accuracy results low overhead due execution patchup code however benchmarks 099go 132ijpeg respectively 15 25 figure 9 prediction accuracy distribution static load instructions using hybrid predictor red ic tor103050709090 80 7 0 60 5 0 40 30 20 10 0 pred ict ion accurac ies percentage load 124 m88ksim 126 gcc 129 compress li 132 ijpeg 134 per 147 vor tex figure 10 prediction accuracy distribution dynamic load instructions using hybrid predictor hybrid pred ictor103050709090 80 70 60 50 40 30 20 10 0 prediction accuracies percentage dynamic load 126gcc 129compress 130 li 132 ijpeg 134perl 147vortex dynamic load instructions prediction accuracy 50 therefore gain much performance benefit vss vss algorithm figure 7 performed programs specint95 prediction accuracy threshold values 90 80 70 60 50 evaluated number candidates valuespeculative execution limited three value prediction parameter varied evaluation value three providing good results evaluation speedup long instruction word architecture machine model based hewlettpackard laboratories playdoh architecture 13 chosen one cycle latencies assumed operations including ldpred udpred except load two cycles floatingpoint add two cycles floatingpoint subtract two cycles floatingpoint multiply three cycles floatingpoint divide three cycles lego compiler statically schedules programs specint95 scheduler uses treegion formation 10 increase scheduling scope including treelike structure basic blocks single nonlinear region compiler performs control speculation allows operations scheduled branches universal functional units execute operation types assumed eight universal unit 8u machine model used functional units fully pipelined integer latency 1 cycle load latency 2 cycles program execution time measured using schedule length region execution profile weight effects instruction data cache ignored perfect branch prediction assumed effort determine maximum potential benefits vss figure 11 shows execution time speedup programs scheduled vss without vss five different prediction accuracy thresholds used select load operations value speculated maximum speedup benchmarks 17 147vortex illustrated figure 10 147vortex many dynamic load operations highly predictable 147vortex highest predictability load operations sheer number illustrated table 1 results best performance benchmarks 124m88ksim 129compress also show impressive speedups 10 115 respectively using threshold 50 speedup 124m88ksim actually goes even prediction threshold goes 90 50 result deduced distribution dynamic loads 124m88ksim steady increase number dynamic loads available threshold decreases 90 50 tapering speedup though misspredictions seen near threshold 50 129compress step distribution dynamic loads 80 70 reflected corresponding step speedup performance gains 126gcc reflective large number dynamic load operations predictability penalties missprediction lower thresholds reduce speedup 126gcc benchmark 130li distribution dynamics loads similar 126gcc lower performance due fewer dynamic loads benchmark 134perl clearly suffers 8u machine model10210611114118 099go 124m88ksim 126gcc 129compress 130li 132ijpeg 134perl 147vortex 90 80 70 60 50 figure 11 execution time speedup vss vss prediction accuracy threshold values 90 80 70 60 50 used many dynamic loads benchmarks 099go 132ijpeg good predictability load operations based performance results predictability threshold 70 appears good selection distribution predictability dynamic loads figure 10 threshold 70 includes large majority predictable dynamic loads choosing threshold predictability lower 70 results tapering performance benchmarks due higher penalty missprediction saturation functional unit resources resulting fewer saved execution cycles 5 conclusions future work paper presents value speculation scheduling vss new technique exploiting high predictability registerwriting instructions technique leverages advantages hardware schemes value prediction compiler schemes exposing ilp dynamic value prediction used enable aggressive static schedules value dependent instructions speculated way vss thought static ilp transformation relies dynamic value prediction hardware results vss presents paper impressive especially considering load operations considered value speculation future work include study heuristics selecting registerwriting operations critical paths available functional unit resources remaining data dependencies affect ability improve static schedule penalty patchup code vss also applied operations loads based predictability potential benefit speedup many candidates value speculative execution dependent instructions predicted instruction branch patchup code allow also important parameter general better heuristics deciding speculate values many vss candidates allow directly affecting amount patchup code studied 6 acknowledgments work funded grants hewlettpackard ibm intel national science foundation mip9625007 would like thank bill havanki sumedh sathaye sanjeev banerjia members tinker group also thank anonymous reviewers valuable comments 7 r dynamic memory disambiguation using memory conflict buffer value locality load value prediction exceeding dataflow limit via value prediction predictability data values value profiling program profiling support value prediction highly accurate data value prediction using hybrid predictors effect instruction fetch bandwidth value prediction speculative execution based value prediction treegion scheduling wideissue processors superblock effective technique vliw superscalar compilation analysis techniques predicated code hpl playdoh architecture specification version 10 intel hp make epic disclosure tr superblock dynamic memory disambiguation using memory conflict buffer value locality load value prediction analysis techniques predicated code exceeding dataflow limit via value prediction predictability data values value profiling program profiling support value prediction highly accurate data value prediction using hybrid predictors treegion scheduling wide issue processors ctr dean tullsen john seng storageless value prediction using prior register values acm sigarch computer architecture news v27 n2 p270279 may 1999 tarun nakra rajiv gupta mary lou soffa value prediction vliw machines acm sigarch computer architecture news v27 n2 p258269 may 1999 mikio takeuchi hideaki komatsu toshio nakatani new speculation technique optimize floatingpoint performance preserving bitbybit reproducibility proceedings 17th annual international conference supercomputing june 2326 2003 san francisco ca usa daniel connors wenmei w hwu compilerdirected dynamic computation reuse rationale initial results proceedings 32nd annual acmieee international symposium microarchitecture p158169 november 1618 1999 haifa israel huiyang zhou jill flanagan thomas conte detecting global stride locality value streams acm sigarch computer architecture news v31 n2 may compiler controlled value prediction using branch predictor based confidence proceedings 33rd annual acmieee international symposium microarchitecture p327336 december 2000 monterey california united states youfeng wu dongyuan chen jesse fang better exploration regionlevel value locality integrated computation reuse value prediction acm sigarch computer architecture news v29 n2 p98108 may 2001 lucian codrescu scott wills james meindl architecture atlas chipmultiprocessor dynamically parallelizing irregular applications ieee transactions computers v50 n1 p6782 january 2001 martin burtscher amer diwan matthias hauswirth static load classification improving value predictability datacache misses acm sigplan notices v37 n5 may 2002 chaoying fu jill bodine thomas conte modeling value speculation optimal edge selection problem ieee transactions computers v52 n3 p277292 march
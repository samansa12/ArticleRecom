fixedparameter complexity ai nonmonotonic reasoning many relevant intractable problems become tractable problem parameter fixed however various problems exhibit different computational properties depending runtime required solving related fixed parameter chosen theory parameterized complexity deals issues provides general techniques identifying fixedparameter tractable fixedparameter intractable problems study parameterized complexity various problems ai nonmonotonic reasoning show number relevant parameterized problems areas fixedparameter tractable among problems constraint satisfaction problems bounded treewidth fixed domain restricted forms conjunctive database queries restricted satisfiability problems propositional logic programming stable model semantics parameter dimension feedback vertex set programs dependency graph circumscriptive inference positive kcnf restricted models bounded size also show circumscriptive inference general propositional theory attention restricted models bounded size fixedparameter intractable actually complete novel fixedparameter complexity class b introduction many hard decision computation problems known become tractable problem parameter fixed bounded fixed value example wellknown nphard problems checking whether graph vertex cover size k computing vertex cover become tractable integer k fixed constant rather part problem instance similarly np complete problem finding clique size k graph becomes tractable every fixed k note however important difference problems vertex cover problem solvable linear time every fixed constant k thus problem polynomially solvable fixed k moreover time bounded polynomial p k whose degree depend k best known algorithms finding clique size k graph exponential k typically require runtime nomega k2 thus fixed k problem solvable time bounded polynomial p k whose degree depends crucially k problems first type called fixedparameter tractable fptractable problems second type classified fixedparameter intractable fpintractable 8 clear fixedparameter tractability highly desirable feature theory parameterized complexity mainly developed downey fellows 8 6 5 deals general techniques proving certain problems fptractable classification fpintractable problems hierarchy fixedparameter complexity classes paper study fixedparameter complexity number relevant ai nmr problems particular show following problems fixedparameter tractable parameters fixed added square brackets problem description constraint satisfiability computation solution constraint satisfaction problem csp fixed parameters cardinality domain treewidth constraint scopes satisfiability cnf fixed parameter treewidth variable connection graph prime implicants qcnf fixed parameters maximal number q literals per clause size prime implicants computed propositional logic programming fixed parameter size minimal feedback vertex set atom dependency circumscriptive inference positive qcnf fixed parameters maximal number q literals per clause size models considered believe results useful better understanding computational nature problems development smart parameterized algorithms solution related problems also study complexity circumscriptive inference general propositional theory attention restricted models size k problem referredto small model circumscription smc easily seen fixedparameter intractable seem complete fpcomplexity classes defined downey fellows introduce new class sigma 2 w sat miniaturized version class sigma p 2 polynomial hierarchy prove smc complete sigma 2 w sat seems natural given nonparameterized problem corresponding smc sigma p complete 9 note however completeness results parameterized classes difficult obtain fact obtaining completeness result resort general version circumscription called pzcircumscription propositional letters theory circumscribed partitioned two subsets p z atoms p minimized z float restricted problem p consists atoms z empty seem complete sigma 2 w sat even though nonparameterized version still sigma p paper organized follows section 2 state relevant formal definitions related fixed parameter complexity section 3 deal constraint satisfaction problems section 4 study fp tractable satisfiability problems section 5 deal logic programming finally section 6 study problem circumscriptive inference small models parameterized complexity parameterized complexity 8 deals parameterized problems ie problems associated parameter instance parameterized problem p regarded consisting two parts regular instance usually input instance classical non parameterized version p associated parameter ks usually integer type definition 1 parameterized problem p fixedparameter tractable algorithm correctly decides input whether yes instance p time fks c n size ji n ks parameter c constant f arbitrary function notion problem reduction proper theory parameterized complexity defined definition 2 parameterized problem p fpreduces parameterized problem p 0 fpreduction exist two functions f f 0 constant c associate instance p instance satisfying following conditions parameter ks 0 0 fks ii regular instance 0 computable time yes instance p 0 yes instance parameterized class problems c possibly infinite set parameterized problems problem p ccomplete p 2 c every problem p 0 2 c fpreducible p hierarchy fpintractable classes called w hierarchy defined properly characterize degree fpintractability associated different parameterized problems relationship among classes problems belonging w hierarchy given following chain inclusions natural number 0 definition class w based degree complexity suitable family boolean circuits prominent w 1complete problem parameterized version clique parameter clique size w 1 characterized class parameterized problems fpreduce parameterized clique similarly w 2 characterized class parameterized problems fpreduce parameterized hitting set parameter size hitting set ktruth value assignment formula e truth value assignment assigns true exactly k propositional variables e consider following problem parameterized sat instance boolean formula e parameter k question exist ktruth value assignment satisfying e class parameterized problems fpreduce parameterized sat w sat contained w p boolean circuits used instead formulae known whether inclusionships proper however difference classes conjectured aw hierarchy defined order deal problems fit w classes 8 aw hierarchy represents sense parameterized counterpart pspace classical complexity setting paper mainly interested class aw sat consider following problem parameterized qbfsat instance quantified boolean formula question phi valid 9 k x denotes choice k truth value assignment variables x 8 k j x denotes choices k j truth value assignments variables x class parameterized problems fpreduce parameterized qbfsat 3 constraint satisfaction problems bounded treewidth fptractability section prove constraint satisfaction problems bounded treewidth fixed domain fp tractable order get results need number definitions section 31 give general definition csps section 32 define treewidth csp problems quote recent results section 33 show main tractability result 31 definition csps instance constraint satisfaction problem csp also constraint network triple v ar u c ar finite set variables u finite domain values finite set constraints constraint c pair list variables length called constraint scope r ary relation u called constraint relation tuples r indicate allowed combinations simultaneous values variables solution csp instance substitution ar gamma u 1 problem deciding whether csp instance solution called constraint satisfiability cs definition taken almost verbatim 16 csp instance v ar u c associate hypergraph denotes set variables scope constraint c constraint hypergraph csp instance primal graph graph e set variables vertices hi edge connecting pair variables xy 2 v fx g h h 2 h 32 treewidth csps treewidth graph measure degree cyclicity graph definition 3 19 tree decomposition graph e tree labeling function associating vertex p 2 n set vertices p v following conditions satisfied 1 vertex b g p 2 n b 2 p 2 edge fb dg 2 f p 2 n fb dg p 3 vertex b g set fp 2 n j b 2 pg induces connected subtree width tree decomposition gamma1 treewidth g minimum width tree decompositions bodlaender 2 shown fixed k linear time algorithm checking whether graph g treewidth bounded k computing tree decomposition g width k thus problem computing tree decomposition graph width k fptractable parameter k treewidth csp instance treewidth primal graph gi accordingly tree decomposition tree decomposition gi 33 fptractable csps constraint satisfaction easily seen npcomplete moreover parameterized version parameter total size constraint scopes w 1complete thus fptractable follows wellknown results conjunctive query evaluation 7 18 equivalent constraint satisfaction cf 14 therefore also bounded treewidth csp fpintractable w 1hard indeed csps total size constraint scopes k form subclass csps treewidth k note fixed k csps width k evaluated time k log n 15 section show however additional parameter fix size domain u bounded treewidth csp fixed parameter tractable worthwhile noting general csp problem remains npcomplete even constant domain u see eg 3sat problem discussed theorem 1 constraint satisfaction parameters treewidth k universe size problem computing solution csp problem parameters k u proof sketch let v ar u c csp instance treewidth k ju exhibit fp transformation equivalent csp instance assume wlog constraint scope contains multiple occurrences variables fact occurrences easily removed simple preprocessing input instance note bound k treewidth follows constraint scope contains k variables thus constraint relations arity k kwidth tree decomposition gi jv j cjgij fixed predetermined constant c always possible bodlaenders algorithm runs linear time vertex 0 constraint c scope list containing variables belonging p r associated relation computed described relations associated constraints 0 computed following two steps 1 constraint c ie jvars 0 jfold cartesian product domain u 2 constraint constraint 0 vars constraint must exist definition tree decomposition primal graph gi modify r 0 follows r rg database terms r 0 semijoinreduced r hard see instance 0 equivalent exactly set solutions note size 0 ju j k cjgij even computing 0 feasible linear time thus reduction actually fpreduction resulting instance 0 acyclic constraint satisfaction problem equivalent acyclic conjunctive query fixed database 14 checking whether query nonempty result positive case computing single tuple result feasible linear time yannakakis wellknown algorithm 23 ut note since csp equivalent conjunctive query evaluation result immediately gives us corollary program complexity conjunctive queries ie complexity evaluating conjunctive queries fixed database 22 following result complements recent results fixedparameter tractability database problems papadimitriou yannakakis 18 corollary 1 evaluation boolean conjunctive queries fptractable wrt treewidth query size database universe moreover evaluating nonboolean conjunctive query fptractable input output size wrt treewidth query size database universe 4 fptractable satisfiability problems 41 boundedwidth cnf formulae application general result fp tractable csps show relevant satisfiability problem also fp tractable graph gf cnf formula f vertices set propositional variables occurring f edge fx yg iff propositional variables x occur together clause f treewidth f defined treewidth associated graph gf theorem 2 cnf satisfiability parameter treewidth k fptractable problem computing model cnf formula parameter k proof sketch fptransform cnf formula f csp instance defined follows v ar contains variable x p propositional variable p occurring f clause f contains constraint r constraint scope list containing variables x p p propositional variable occurring p constraint relation r u jdj consists tuples corresponding truth value assignments satisfying obvious every model f correspond solution vice versa thus particular f satisfiable positive csp instance since gf isomorphic gif f treewidth moreover cnf formula f treewidth k clauses cardinality k therefore reduction feasible time thus fpreduction wrt parameter k fpreduction fptractability cnfsat treewidth parameter follows fptractability csps wrt treewidth stated theorem 1 ut 42 cnf short prime implicants problem finding prime implicants cnf formula relevant large number different areas eg diagnosis knowledge compilation many ai applications clearly set prime implicants cnf formula f viewed compact representation satisfying truth assignments f worthwhile noting restriction parameterized sat cnf formulae fpintractable precisely deciding whether qcnf formula f ktruth value assignment w 2complete 8 recall ktruth value assignment assigns true exactly k propositional nevertheless identified natural parameterized version satisfiability fptractable simply take parameter length prime implicants boolean formula given qcnf formula f short prime implicants problem spi problem computing prime implicants f length k parameters k q theorem 3 spi fixedparameter tractable proof sketch let f qcnf formula wlog assume f contain tautological clauses generate set im k implicants f possible compute set prime implicants f length k similar wellknown procedure generating vertex covers bounded size cf 4 8 pick arbitrary clause c f clearly implicant f must contain least one literal c construct edgelabeled tree whose vertices clauses f follows root c nonleaf vertex edge labeled descendant literal 2 child attach edge clause e f intersect set edgelabels root current position branch closed set exist length path k rootleaf branch fi tree let ifi set containing k literals labeling edges fi check whether ifi consistent implicant f add ifi set im k easy see size tree bounded q k every prime implicant f length k holds implicant 2 im k moreover note q k implicants im k implicant 2 im k set consistent prime implicants f included easily obtained time o2 k jf j follows spi fptractable wrt parameters q k ut 5 logic programs negation logic programming negation stable model semantics 13 wellstudied form nonmonotonic reasoning literal l either atom called positive negated atom called negative literals complementary literal l denote l complementary literal set lit literals normal clause rule form atom l literal normal logic program finite set normal clauses normal logic program p stratified 1 assignment strdelta integers 01 predicates p clause r p following holds p predicate head r q predicate l body strp strq l positive strp strq l negative reduct normal logic program p herbrand interpretation 13 denoted p obtained p follows first remove every clause r negative literal l body l 2 remove negative literals remaining rules interpretation normal logic program p stable model p 13 least herbrand model p general normal logic program p may zero one multiple even exponentially many stable models denote stabmodsp set stable models p wellknown every stratified logic program unique stable model computed linear time following problems main decision search problems context logic programming main logic programming problems let p logic program 1 consistency determine whether p admits stable model 2 brave reasoning check whether given literal true stable model p 3 cautious reasoning check whether literal true every stable model p 4 sm computation compute arbitrary stable model p 5 sm enumeration compute set stable models p normal logic program p dependency graph gp labeled directed graph v set atoms occurring p set edges p q 2 exists rule r 2 p p head q body moreover q appears negatively body edge p q labeled symbol undirected dependency graph g p p undirected version gp feedback vertex set undirected directed graph g subset x vertices g cycle directed cycle contains least one vertex clearly feedback vertex set removed g resulting graph acyclic feedback width g minimum size feedback vertex sets shown downey fellows 8 4 determining whether undirected graph feedback width k positive case finding feedback vertex set size k fptractable wrt parameter k let p logic program defined set u propositional atoms partial truth value assignment pta p truth value assignment subset u 0 u pta p denote p program obtained p follows eliminate rules whose body contains literal contradicting eliminate every rule body literals whose literals made true following lemma easy verify lemma 1 let stable model logic program p let pta consistent stable model p theorem 4 logic programming problems 15 listed fptractable wrt feedback width dependency graph logic program proof sketch given logic program p whose graph g p feedback width k compute linear time see 8 feedback vertex set g p st consider set 2 k partial truth value assignments atoms pta 2 p stratified program whose unique stable model computed linear time denotes set stable models p latter done linear time suitable data structures used definition sigma suffices note every stable model p belongs sigma indeed let pta determined lemma 1 follows stable model p hence 2 sigma thus p 2 k stable models whose computation fptractable actually feasible linear time therefore problem 5 stable model enumeration fptractable fptractability problems follows ut appears overwhelmingly large number natural logic programs low feedback width thus technique presented seems useful practice note however technique apply important rather obvious cases fact method take care direction labeling arcs dependency graph gp hence positive programs width large feedback width recognized tractable although trivially tractable applies instance stratified programs large feedback width programs whose high feedbackwith exclusively due positive cycles unfortunately known whether computing feedback vertex sets size k fixedparameter tractable directed graphs 8 another observation leading possible improvement following call atom p logic program malignant lies least one simple cycle gp containing marked negated edge call atom benign malignant easy see malignant atoms responsible large number stable models particular every stratified program contains benign atoms exactly one stable model suggest following improved procedure identify set benign atoms occurring p drop benign vertices g p yielding hp compute feedback vertex set size k hp pta compute unique stable model p check whether actually stable model p output easy see procedure correctly computes stable models p unfortunately shown next theorem unlikely procedure run polynomial time theorem 5 determining whether atom propositional logic program benign npcomplete proof sketch follows rather simple reduction npcomplete problem deciding whether two pairs vertices directed graph g two vertexdisjoint paths linking x 1 x 2 1 2 11 detailed explanation given full paper ut thus propose related improvement somewhat weaker tractable atom p logic program p called weakly malignant lies least one simple cycle g p containing marked negated edge atom called strongly benign weaklymalignant lemma 2 determining whether atom propositional logic program strongly benign weakly malignant done polynomial time proof sketch sufficient show determining whether vertex p undirected graph g boolean edge labels lies simple cycle containing marked edge solved checking marked edge hy 1 2 g pair neighbours x whether graph g gamma fxg contains two vertexdisjoint paths linking x 1 1 x 2 2 respectively latter polynomial time result robertson seymour 20 ut next present improved algorithm enumerating stable models logic program p based feedback width suitable undirected graph associated p modular stable model enumeration procedure msme 1 compute set c strongly connected components scc gp 2 scc c 2 c let pc set rules p define atoms belonging c ie pc contains rule r 2 p whose head belongs c 3 determine set uc c strongly connected components scc gp whose corresponding program pc stratified 4 scc c 2 uc compute set strongly benign atoms sbc occurring pc 5 let p 6 let hp 0 subgraph g p 0 obtained dropping every vertex p occurring set strongly benign atoms sbc c 2 uc 7 compute feedback vertex set size k hp 0 8 pta compute unique stable model p check whether actually stable model p output feedback width graph hp 0 called weak feedbackwidth dependency graph p following theorem follows fptrectability computing feedback vertex sets size k undirected graph wellknown modular computation methods stable model semantics 10 theorem 6 logic programming problems 15 listed fptractable wrt weak feedback width dependency graph logic program note methods used section adapted show fixedparameter tractability results extended versions logic programming disjunctive logic programming types nonmonotonic reasoning case disjunctive logic programming sufficient extend dependency graph contain labeled directed edge every pair atoms occurring together rule head different perspective computation stable models recently considered 21 size stable models taken fixed parameter turns computing large stable models fixedparameter tractable whereas computing small stable models fixedparameter intractable 6 small model circumscription problem section study fixedparameter complexity tractable parametric variant circumscription attention restricted models small cardinality 61 definition small model circumscription small model circumscription problem smc defined follows given propositional theory set atoms given propositional formula vocabulary decide whether satisfied model small size ie k propositional atoms true written jm j k p zminimal wrt small models 1 ie model 0 jm 0 j k 1 paper whenever speak p zminimality mean minimality defined problem appears miniaturization classical problem brave reasoning minimal models believe smc useful since many contexts one large theories mainly interested small models eg abductive diagnosis clearly fixed k smc tractable fact sufficed enumerate jaj k candidate interpretations outer loop interpretation check whether latter done inner loop enumerating small interpretations performing easy checking tasks also hard see smc fpintractable fact hitting set problem shown 2complete 8 fpreduced smc actually regarded restricted version smc consists cnf positive literals section 62 present fptractable subclass version smc maximum clause length theory taken additional parameter however section 63 show soon set z floating variables empty problem becomes fpintractable since brave reasoning minimal models shown sigma p 2 complete 9 thus one level complexity classical reasoning would interesting determine precise fixedparameter complexity general version smc wrt parameter k problem tackled section 63 62 tractable restriction smc restrict smc requiring theory qcnf negative literal occuring minimizing atoms occurring theory problem restricted small model circumscription rsmc thus defined smc except required purely positive qcnf formula floating set z empty parameters maximum size k models considered maximum size q number literals largest conjunct clause theorem 7 rsmc fixedparameter tractable proof sketch since positive set minimal models considered exactly prime implicants size k theorem 3 computing prime implicants qcnf theory fptractable wrt parameters k q thus theorem easily follows ut 63 fixedparameter complexity smc first show slight modification fptractable problem rsmc z 6 fpintractable fact w sat problem positive small model circumscription psmc defined smc except required purely positive qcnf formula parameters maximum size k models considered maximum clause length q let us define boolean formula count k x x list variables 1in ia krn r count k intuitively satisfying truth value assignment count k x propositional variable q j gets value true iff x j th true variable among x note size count k x okn 2 variables x formula called external variables formula variables occurring formula called private variables whenever theory contains count subformula assume wlog private variables subformula occur outside subformula particular contains two count subformulas set private variables disjoint lemma 3 let f formula x list variables occurring f exists truth value assignment oe f assigning true exactly k variables x every ktruth value assignment oe satisfying f extended unique way assignment oe 0 satisfying f count k x every satisfying truth value assignment f count k x assigns true exactly k private variables count k x true exactly k variables x theorem 8 psmc w sat hard problem remains hard even 2cnf theories proof sketch let phi boolean formula propositional variables fx g fpreduce w sat complete problem deciding whether exists ktruth value assignment satisfying phi instance psmc maximum model size 2k maximum clause length 2 private variables count k subformula moreover let following 2cnf positive theory take g note set p z minimal model size 2k subset z jm j 2k lemma 3 every satisfying truth value assignment phi 0 must make true exactly k variables variables set private variables count k follows exists minimal model jm j 2k exists ktruth value assignment satisfying phi ut let us focus general smc problem arbitrary theories considered floating variables permitted appear smc contained w sat hand seen smc contained aw sat seem hard thus complete class fact aw sat miniaturization pspace sigma p class corresponding levels polynomial hierarchy defined far theory fixedparameter intractability reasoning problems smc seem require definitions classes next define exact correspondent sigma p 2 fixedparameter level definition class sigma 2 w sat defined similarly aw sat quantifier prefix restricted sigma 2 parameterized qbf 2 sat instance quantified boolean formula 9 k1 x8 k2 ye question 9 k1 x8 k2 ye valid 9 k1 x denotes choice k 1 truth value assignment variables x 8 k2 denotes choices k 2 truth value assignments variables definition 4 sigma 2 w sat set problems fpreduce parameterized qbf 2 sat membership smc sigma 2 w sat let problem parameterized qbf 2 sat variant parameterized qbf 2 sat quantifiers 9 k1 x 8 k2 replaced quantifiers 9 k1 x 8 k2 following meaning 9 k1 x ff means exists truth value assignment making k 1 propositional variables x true ff valid simmetrically 8 k2 ff means ff valid every truth value assignment making propositional variables true lemma 4 parameterized qbf 2 sat sigma 2 w sat proof sketch suffices show parameterized qbf 2 sat fpreducible parameterized qbf 2 sat instance parameterized easy see following instance phi 0 parameterized qbf 2 sat equivalent phi 9 new variables ex 1 x 0 obtained e substituting x ut theorem 9 smc sigma 2 w sat proof sketch lemma 4 sufficient show every smc instance fpreduced equivalent instance phis parameterized qbf 2 sat let smc instance two sets fresh variables phis defined follows 9 k obtained p z substituting p 0 first part phis guesses model k atoms among p z satisfies second part makes sure p z minimal checking model 0 either equivalent p variables least one p variable true whereas variable false hence bravely entails small models p z circumscription phis valid ut hardness smc theorem 10 smc sigma 2 w sat hard thus sigma 2 w sat complete proof sketch show parameterized qbf 2 sat fpreducible smc let phi following instance parameterized qbf 2 sat 9 k1 x 1 define corresponding instance smc w fresh variable consists variables occurring namely variables private variables two count subformulae prove phi valid sphi yes instance smc part assume phi valid exists k 1 truth value assignment oe variables x every k 2 truth value assignment variables formula e satisfied let interpretation constructed follows contains k 1 variables x made true oe first k 2 variables addition contains w private variables make true two count subformulae possible lemma 3 easy see model show p z minimal model assume 0 p z smaller model due count k1 x subformula 0 must contain exactly k 1 atoms x therefore 0 coincide wrt x atoms follows w 62 0 however validity phi construction 0 part assume exists p z minimal model entails w jm j k note lemma 3 must hold contains exactly k 1 true variables x exactly k 2 true variables towards contradiction assume phi valid must hold every k 1 truth value assignment oe variables x exists k 2 truth value assignment oe 0 variables oe oe 0 falsifies e particular k 1 variables x true according possible make true exactly k 2 variables formula e satisfied consider interpretation 0 containing true variables plus true two count subformulae 0 model whose p variables coincide except w belongs 0 therefore p z minimal contradiction finally note transformation phi sphi fpreduction indeed feasible polynomial time linear k ut corollary 2 parameterized qbf 2 sat sigma 2 w sat complete proof sketch completeness follows fact shown lemma 4 problem belongs theorem 10 shows sigma 2 w sat hard problem smc fpreducible parameterized qbf 2 sat ut downey fellows 8 pointed completeness proofs fixed parameter intractability classes generally involved classical intractability proofs note also case proof deal subtle counting issues straightforward downscaling standard sigma pcompleteness proof propositional circumscription appears possible particular observe obtained completeness result general version propositional minimal model reasoning variables minimized p floating variables z wellknown minimal model reasoning remains sigma p complete even variables formula minimized ie z empty result seem carry setting fixed parameter tractability clearly problem restricted version smc sigma 2 w sat moreover easy see problem hard w 2 thus fixed parameter intractable however able show problem complete class range w 2 sigma 2 w sat leave issue open problem open problem determine fixedparameter complexity smc variables theory minimized r towards theory declarative knowledge lineartime algorithm finding treedecompositions small treewidth optimal implementation conjunctive queries relational databases fixed parameter tractability completeness fixed parameter intractability extended abstract fixed parameter tractability completeness basic results parametric complexity relational database queries sharper characterization w parameterized complexity propositional circumscription extended closed world reasoning disjunctive datalog directed subgraph homeomorphism problem computers intractability stable model semantics logic programming complexity acyclic conjunctive queries comparison structural csp decomposition methods closure properties constraints complexity database queries graph minors ii graph minors xx computing large small stable models complexity relational query languages algorithms acyclic database schemes tr sufficient condition backtrackbounded search theory diagnosis first principles constraint satisfaction deductive viewpoint research note towards theory declarative knowledge tree clustering constraint networks research note propositional circumscription extended closedworld reasoning myampersandpgrsupscrptpsupscrptsubscrpt2subscrptcomplete fixedparameter tractability completeness lineartime algorithm finding treedecompositions small treewidth closure properties constraints complexity database queries extended abstract conjunctivequery containment constraint satisfaction desirability acyclic database schemes computing large small stable models complexity acyclic conjunctive queries graph algorithms declarative problemsolving using dlv system computers intractability propositional lower bounds smodels implementation stable model wellfounded semantics normal lp pushing goal derivation dlp computations stable model semantics weight constraint rules descriptive parameterized complexity comparison structural csp decomposition methods complexity relational query languages extended abstract ctr stefan szeider minimal unsatisfiable formulas bounded clausevariable difference fixedparameter tractable journal computer system sciences v69 n4 p656674 december 2004 carsten sinz visualizing sat instances runs dpll algorithm journal automated reasoning v39 n2 p219243 august 2007 logic programming knowledge representationthe aprolog perspective artificial intelligence v138 n12 p338 june 2002
scalable algorithms association mining abstractassociation rule discovery emerged important problem knowledge discovery data mining association mining task consists identifying frequent itemsets forming conditional implication rules among paper present efficient algorithms discovery frequent itemsets forms compute intensive phase task algorithms utilize structural properties frequent itemsets facilitate fast discovery items organized subset lattice search space decomposed small independent chunks sublattices solved memory efficient lattice traversal techniques presented quickly identify long frequent itemsets subsets required also present effect using different database layout schemes combined proposed decomposition traversal techniques experimentally compare new algorithms previous approaches obtaining improvements order magnitude test databases b introduction association mining task discover set attributes shared among large number objects given database example consider sales database bookstore objects represent customers attributes represent books discovered patterns set books frequently bought together customers example could 40 people buy jane austens pride prejudice also buy sense sensibility store use knowledge promotions shelf placement etc many potential application areas association rule technology include catalog design store layout customer segmentation telecommunication alarm diagnosis task discovering frequent associations large databases quite challenging search space exponential number database attributes millions database objects problem io minimization becomes paramount however current approaches iterative nature requiring multiple database scans clearly expensive methods especially using form sampling sensitive dataskew adversely aect performance furthermore approaches use complicated internal data structures poor locality add additional space computation overheads goal overcome limitations paper present new algorithms discovering set frequent attributes also called itemsets key features approach follows 1 use vertical tidlist database format associate itemset list transactions occurs show frequent itemsets enumerated via simple tidlist intersections 2 use latticetheoretic approach decompose original search space lattice smaller pieces sublattices processed independently mainmemory propose two techniques achieving decomposition prexbased maximalcliquebased partition 3 decouple problem decomposition pattern search propose three new search strategies enumerating frequent itemsets within sublattice bottomup topdown hybrid search 4 approach roughly requires database scans minimizing io costs present six new algorithms combining features listed depending database format decomposition technique search procedure used include eclat equivalence class transformation maxeclat clique maxclique topdown aprclique new algorithms minimize io costs making small number database scan also minimize computation costs using ecient search schemes algorithms particularly eective discovered frequent itemsets long tidlist based approach also insensitive dataskew fact maxeclat maxclique algorithms exploit skew tidlists ie support itemsets reorder search long frequent itemsets listed rst furthermore use simple intersection operations makes new algorithms attractive option direct implementation database systems using sql help extensive set experiments show best new algorithm improves current methods order magnitude time proposed techniques retain linear scalability number transactions database rest paper organized follows section 2 describe association discovery problem look related work section 3 section 4 develop latticebased approach problem decomposition pattern search section 5 describes new algorithms previous methods used experimental comparison described detail section 6 experimental study presented section 7 conclude section 8 mining complexity results frequent itemsets link graphtheory highlighted appendix problem statement association mining task rst introduced 1 stated follows let set items database transactions transaction unique identier tid contains set items set items also called itemset itemset k items called kitemset support itemset x denoted x number transactions occurs subset k length subset itemset called ksubset itemset maximal subset itemset itemset frequent support userspecied minimum support min sup value set frequent kitemsets denoted f k association rule expression b b itemsets support rule given b condence ie conditional probability transaction contains b given contains rule condent condence userspecied minimum condence min conf data mining task generate association rules database support greater min sup ie rules frequent rules must also condence greater min conf ie rules condent task broken two steps 2 1 find frequent itemsets step computationally io intensive given items potentially 2 frequent itemsets ecient methods needed traverse exponential itemset search space enumerate frequent itemsets thus frequent itemset discovery main focus paper 2 generate condent rules step relatively straightforward rules form xny generated frequent itemsets x provided rules least minimum condence consider example bookstore sales database shown figure 1 dierent items names authors bookstore carries ie fa c dt wg database consists six customers bought books authors figure 1 shows frequent itemsets contained least three customer transactions ie min also shows set association rules min conf 100 itemsets actw cdw maximal frequent itemsets since frequent conan doyle sir arthur agatha christie c jane austen marktwain wodehouse p g w c w c w c w c w c w246 transaction items items 33 ac w cw ac aw cd ct acw 100 50 3 itemsets support ctw maximal frequent itemsets dw tw act atw cdw actw cdw actw association rules act 33 cw 33 figure 1 bookstore database b frequent itemsets condent rules itemsets subsets one two maximal itemsets reduce frequent itemset search problem task enumerating maximal frequent itemsets hand generating condent rules need support frequent itemsets easily accomplished maximal elements identied making additional database pass gathering support uncounted subsets 3 related work several algorithms mining associations proposed literature 1 2 6 15 19 20 21 23 26 27 apriori algorithm 2 best known previous algorithm uses ecient candidate generation procedure frequent itemsets level used construct candidates next level however requires multiple database scans many longest frequent itemset dhp algorithm 23 tries reduce number candidates collecting approximate counts previous level like apriori requires many database passes longest itemset partition algorithm 26 minimizes io scanning database twice partitions database small chunks handled memory rst pass generates set potentially locally frequent itemsets second pass counts global support partition may enumerate many false positives rst pass ie itemsets locally frequent partition globally frequent local frequent set doesnt memory additional database scans required dlg 28 algorithm uses bitvector per item noting tids item occurred generates frequent itemsets via logical operations bitvectors however dlg assumes bit vectors memory thus scalability could problem databases millions transactions dic algorithm 6 dynamically counts candidates varying length database scan progresses thus able reduce number scans apriori another way minimize io overhead work small sample database analysis eectiveness sampling association mining presented 29 27 presents exact algorithm nds rules using sampling ascpa algorithm sampling versions 20 build top partition produce much smaller set potentially frequent candidates requires two database scans approaches using generalpurpose dbms systems relational algebra operations also studied 14 15 detailed architectural alternatives tightintegration association mining dbms presented 25 also pointed benets using vertical database layout algorithms generate possible frequent itemsets methods nding maximal elements include allmfs 12 randomized algorithm discover maximal frequent itemsets pincersearch algorithm 19 constructs candidates bottomup manner like apriori also starts topdown search time help reducing number database scans maxminer 5 another algorithm nding maximal elements uses ecient pruning techniques quickly narrow search space new algorithms range generate frequent itemsets hybrid schemes generate maximal along remaining itemsets worth noting since enumeration task computationally challenging number parallel algorithms also proposed 3 7 13 31 4 itemset enumeration latticebased approach embarking algorithm description brie review terminology lattice theory see 8 good introduction denition 1 let p set partial order p binary relation xy z 2 p relation exive x x set p relation called ordered set denition 2 let p ordered set let xzy 2 p say x covered denoted x element z p x z denition 3 let p ordered set let p element x 2 p upper bound lower bound x x 2 least upper bound also called join denoted greatest lower bound also called meet denoted greatest element p denoted called top element least element p denoted called bottom element denition 4 let l ordered set l called join meet semilattice x xy 2 l l called lattice join meet semilattice ie x exist pairs elements l l complete lattice exist subsets l set l sublattice l c w ct cd ad acw adt atw acdw acdt acdtw cdt act acd dtw ac actw maximal frequent itemsets actw cdw figure 2 complete powerset lattice pi set ordered set ps power set complete lattice join meet given union intersection respectively i2i i2i top element ps bottom element ps fg l ps l called lattice sets closed nite unions intersections ie l lattice partial order specied subset relation x figure 2 shows powerset lattice pi set items example database fa c dt wg also shown frequent grey circles maximal frequent itemsets black circles observed set frequent itemsets forms meet semilattice since closed meet operation ie frequent itemsets x x also frequent hand doesnt form join semilattice since x frequent doesnt imply x frequent mentioned infrequent itemsets form join semilattice subsets frequent itemsets frequent lemma consequence closure meet operation set frequent itemsets corollary get supersets infrequent itemset infrequent observation forms basis powerful pruning strategy bottomup search procedure frequent itemsets leveraged many association mining algorithms 2 23 26 namely itemsets found frequent previous level need extended candidates current level however lattice formulation makes apparent need restrict purely bottomup search lemma 2 maximal frequent itemsets uniquely determine frequent itemsets observation tells us goal devise search procedure quickly identies maximal frequent itemsets following sections see eciently 41 support counting denition 5 lattice l said distributive xy z 2 l denition 6 let l lattice bottom element x 2 l called atom x ie x covers set atoms l denoted al denition 7 lattice l called boolean lattice distributive elements member x lattice complement begin noting powerset lattice pi set database items boolean lattice complement x 2 l given inx set atoms powerset lattice corresponds set items ie associate atom database item x tidlist denoted lx list transaction identiers containing atom figure 3 shows tidlists atoms example database example consider atom looking database figure 1 see occurs transactions 1 3 4 5 forms tidlist atom a41 13564 figure 3 tidlist atoms lemma 3 8 nite boolean lattice l x 2 l words every element boolean lattice given join subset set atoms since powerset lattice pi boolean lattice join operation corresponding set union get lemma 4 x 2 pi let lemma states itemset obtained join atoms lattice support itemset obtained intersecting tidlist atoms generalize lemma set itemsets lemma 5 x 2 pi let lemma says itemset given union set itemsets j support given intersection tidlists elements j particular determine support kitemset simply intersecting tidlists two k 1 length subsets simple check cardinality resulting tidlist tells us whether new itemset frequent figure 4 shows process pictorially shows initial database tidlist item ie atoms intermediate tidlist cd obtained intersecting lists c ie similarly thus lexicographically rst two subsets previous level required compute support itemset level41 13564 intersect intersect c w ct cd ad acw adt atw acdw acdt acdtw cdt act acd dtw ac actw initial database tidlists figure 4 computing support itemsets via tidlist intersections lemma 6 let x two itemsets x lx ly proof follows denition support lemma states x subset cardinality tidlist ie support must less equal cardinality tidlist x practical important consequence lemma cardinalities intermediate tidlists shrink move lattice results fast intersection support counting 42 lattice decomposition prexbased classes enough mainmemory could enumerate frequent itemsets traversing powerset lattice performing intersections obtain itemset supports practice however limited amount mainmemory intermediate tidlists memory brings natural question decompose original lattice smaller pieces portion solved independently mainmemory address question denition 8 let p set equivalence relation p binary relation relation exive x x equivalence relation partitions set p disjoint subsets called equivalence classes equivalence class element x 2 p given x g dene function length prex x dene equivalence relation k lattice pi follows 8xy 2 pi x k px two itemsets class share common k length prex therefore call k prexbased equivalence relation c w ct cd ad acw adt atw acdw acdt acdtw cdt act acd ctw ac actw acdtw acdw acdt actw ad ac acw adt atw act acd figure 5 equivalence classes pi induced 1 b 1 induced final lattice independent classes figure 5a shows lattice induced equivalence relation 1 pi collapse itemsets common 1 length prex equivalence class resulting set lattice equivalence classes fa c w g lemma 7 equivalence class x induced equivalence relation k sublattice pi proof let u v two elements class x ie u v share common prex x u implies u v 2 x u implies u sublattice pi x 1 boolean lattice set atoms example atoms 1 top bottom elements application lemmas 4 5 generate supports itemsets class sublattice intersecting tidlist atoms two subsets previous level enough mainmemory hold temporary tidlists class solve x 1 independently another interesting feature equivalence classes links classes denote dependencies say want prune itemset exists least one infrequent subset see lemma 1 process classes specic order particular solve classes bottom top corresponds reverse lexicographic order ie process w followed c nally guarantees subset information available pruning practice found one level decomposition induced 1 sucient however cases class may still large solved mainmemory scenario apply recursive class decomposition lets assume large mainmemory since boolean lattice decomposed using 2 figure 5b shows equivalence class lattice induced applying 2 collapse itemsets common 2 length prex equivalence class resulting set classes fac ad aw g like class solved independently solve reverse lexicographic order enable subset pruning nal set independent classes obtained applying 1 pi 2 shown figure 5c links show pruning dependencies exist among classes depending amount mainmemory available recursively partition large classes smaller ones class small enough solved independently mainmemory 43 search frequent itemsets section discuss ecient search strategies enumerating frequent itemsets within class actual pseudocode implementation details discussed section 5 431 bottomup search bottomup search based recursive decomposition class smaller classes induced equivalence relation k figure 6 shows decomposition 1 smaller classes resulting lattice equivalence classes also shown atoms within class elements class determined equivalence class lattice traversed either depthrst breadthrst manner paper show results breadthrst traversal ie rst process classes followed classes fact acw atw g nally actw computing support itemset simply intersect tidlists two subsets previous level since search breadthrst technique enumerates frequent itemsets ac ad aw adt act acd acdt acdw adtw acdtw actw ac aw actw act equivalence classes atoms class figure 432 topdown search topdown approach starts top element lattice support determined intersecting tidlists atoms requires kway intersection top element kitemset advantage approach maximal element fairly large one quickly identify one avoid nding support subsets search starts top element frequent done otherwise check subset next level process repeated identied minimal infrequent itemsets figure 7 depicts topdown search scheme enumerates maximal frequent itemsets within sublattice however maximal elements sublattice may globally maximal thus generate nonmaximal itemsets search starts top element acdtw since infrequent check four length 4 subsets actw frequent mark subsets frequent well examine unmarked length 3 subsets three infrequent subsets search stops ad minimal infrequent itemset identied acdt acdw adtw adt acw act acd ad ac aw acdtw actw minimal infrequent itemset ad figure 7 topdown search gray circles represent infrequent itemsets black circle maximal frequent white circle minimal infrequent set 433 hybrid search hybrid scheme based intuition greater support frequent itemset likely part longer frequent itemset two main steps approach begin set atoms class sorted descending order based support rst hybrid phase starts intersecting atoms one time beginning atom highest support generating longer longer frequent itemsets process stops extension becomes infrequent enter second bottomup phase remaining atoms combined atoms rst set breadthrst fashion described generate frequent itemsets figure 8 illustrates approach case better show bottomup phase assumed ad adw also frequent search starts reordering 2itemsets according support frequent rst combine ac aw obtain frequent itemset acw extend next pair get actw extension ad fails concludes hybrid phase found maximal set actw bottomup phase ad combined previous pairs ensure complete search producing equivalence class ad solved using bottomup search hybrid search strategy requires 2way intersections enumerates long maximal frequent itemsets discovered hybrid phase also nonmaximal ones found bottomup phase another modication scheme recursively substitute second bottomup search hybrid search mainly maximal frequent elements enumerated acd ac acw aw ad acdtw actw hybrid phase ad ac ac ad aw pairs sort support phase figure 8 hybrid search 44 generating smaller classes maximal clique approach section show produce smaller sublattices equivalence classes compared pure prexbased approach using additional information smaller sublattices fewer atoms save unnecessary intersections example k atoms perform k intersections next level bottomup approach fewer atoms thus lead fewer intersections bottomup search fewer atoms also reduce number intersections hybrid scheme lead smaller maximum element size topdown search denition 9 let p set pseudoequivalence relation p binary relation relation exive x x pseudoequivalence relation partitions set p possibly overlapping subsets called pseudoequivalence classes denition 10 graph consists set elements called vertices set lines connecting pairs vertices called edges graph complete edge pairs vertices complete subgraph graph called clique 12 13 14 15 16 17 18 23 25 27 28 34 35 36 45 46 56 58 68 78 frequent 2itemsets maximal cliques association graph maximalcliquebased classes figure 9 maximal cliques association graph prexbased maximalcliquebased classes denote set frequent kitemsets dene kassociation graph given g e vertex set zg let k denote set maximal cliques g k figure 9 shows association graph g 1 example shown maximal clique set dene pseudoequivalence relation k lattice pi follows 8xy 2 pi x k 9 c 2 k xy c px two itemsets related ie pseudoclass subsets maximal clique share common prex length k therefore call k maximalcliquebased pseudoequivalence relation lemma 8 pseudoclass x induced pseudoequivalence relation k sublattice pi proof let u v two elements class x ie u v share common prex x exists maximal clique c 2 k u v c clearly u implies u v 2 x u implies u thus pseudoclass x 1 boolean lattice supports elements lattice generated applying lemmas 4 5 atoms using three search strategies described lemma 9 let k denote set pseudoclasses maximalcliquebased relation k pseudoclass induced prexbased relation k subset class x induced k conversely x k union set pseudoclasses given x g proof let x denote neighbors x graph g k x xgg words x consists elements prex x extended possible subsets neighbors x graph g k since clique subset fy g prex x hand easy show x prex xg lemma states pseudoclass k renement ie smaller class k using relation k instead k therefore generate smaller sublattices sublattices require less memory processed independently using three search strategies described figure 9 contrasts classes sublattices generated 1 1 apparent 1 generates smaller classes example prex class class containing elements maximalclique classes 1568g classes much smaller prexbased class smaller classes k come cost since enumeration maximal cliques computationally expensive general graphs maximal clique decision problem npcomplete 10 however kassociation graph usually sparse maximal cliques enumerated eciently edge density association graph increases clique based approaches may suer k thus used g k dense factors aecting edge density include decreasing support increasing transaction size eect parameters studied experimental section 441 maximal clique generation modied bierstones algorithm 22 generating maximal cliques kassociation graph class x 2 x said cover subset x given class c rst identify covering set given fy 2 cjcovy 6 covy 6 covz z 2 c z yg example consider class 1 shown gure 9 similarly example since 1 covering set 1 given set f2 3 5g item 4 covering set since subset shows complete clique generation algorithm elements covering set need considered generating maximal cliques current class step 3 recursively generate maximal cliques elements covering set class maximal clique covering set prexed class identier obtain maximal cliques current class step 7 inserting new clique duplicates subsets eliminated new clique subset clique already maximal list inserted conditions test shown line 8 1for 4 cliq 2 xcliqlist 5 7 insert fig icliqlist 8 figure 10 maximal clique generation algorithm weak maximal cliques database parameters edge density kassociation graph may high resulting large cliques signicant overlap among cases clique generation take time redundant frequent itemsets may also discovered within sublattice solve problem introduce notion weak maximality cliques given two cliques x say related jxy j ie ratio common elements distinct elements cliques greater equal threshold weak maximal clique g generated collapsing two cliques one provided related clique generation weak maximal cliques generated user specied value note obtain regular maximal cliques obtain single clique preliminary experiments indicate using appropriate value overhead redundant cliques avoided found 05 work well practice 5 algorithm design implementation section describe several new algorithms ecient enumeration frequent itemsets rst step involves computation frequent items 2itemsets next step generates sublattices classes applying either prexbased equivalence relation 1 maximalcliquebased pseudo equivalence relation 1 set frequent 2itemsets f 2 sublattices processed one time reverse lexicographic order mainmemory using either bottomup topdown hybrid search describe steps detail 51 computing frequent 1itemsets 2itemsets current association algorithms 2 6 20 23 26 27 assume horizontal database layout one shown figure 1 consisting list transactions transaction identier followed list items transaction contrast algorithms use vertical database format one shown figure 3 maintain diskbased tidlist item enables us check support via simple tidlist intersections computing f 1 given vertical tidlist database frequent items found single database scan item simply read tidlist disk memory scan tidlist incrementing items support entry computing f 2 let jij number frequent items average idlist size bytes naive implementation computing frequent 2itemsets requires n idlist intersections pairs items amount data read n n 12 corresponds around n2 data scans clearly inecient instead naive method one could use two alternate solutions 1 use preprocessing step gather counts 2sequences user specied lower bound since information invariant computed cost amortized number times data mined 2 perform vertical horizontal transformation onthe done quite easily item scan tidlist memory insert item array indexed tid 2 li example consider idlist item shown figure 3 read rst tid 1 insert array indexed transaction 1 repeat process items tidlists figure 11 shows inversion process works addition item complete horizontal database recovered vertical item tidlists process entails trivial amount overhead fact partition performs opposite inversion horizontal vertical tidlist format onthe little cost also implemented appropriate memory management recovering block database time recovered transactions memory finally optimize computation f 2 directly updating counts candidate pairs upper triangular 2d array experiments reported section 7 use horizontal recovery method computing f 2 shall demonstrate inversion done quite eciently add c add add w add add a246246246 figure 11 verticaltohorizontal database recovery 52 search implementation bottomup search figure 12 shows pseudocode bottomup search input procedure set atoms sublattice frequent itemsets generated intersecting tidlists distinct pairs atoms checking cardinality resulting tidlist recursive procedure call made itemsets found frequent current level process repeated frequent itemsets enumerated terms memory management easy see need memory store intermediate tidlists two consecutive levels frequent itemsets next level generated itemsets current level deleted atoms 2 atoms j 2 j r min sup figure 12 pseudocode bottomup search since sublattice processed reverse lexicographic order subset information available itemset pruning fast subset checking frequent itemsets stored hash table however experiments synthetic data found pruning little benet mainly lemma 6 says tidlist intersection especially ecient large itemsets nevertheless may databases pruning crucial performance support pruning datasets topdown search code topdown search given figure 13 search begins maximum element r sublattice check made see element already known frequent perform kway intersection determine support frequent done otherwise recursively check support k 1subsets also maintain hash table ht itemsets known infrequent previous recursive calls avoid processing sublattices already examined terms memory management topdown approach requires tidlists atoms class memory r 62 f jrj r min sup else r jy figure 13 pseudocode topdown search hybrid search figure 14 shows pseudocode hybrid search input consists atom set sorted descending order support maximal phase begins intersecting atoms one time frequent extension possible atoms involved phase stored set 1 remaining atoms enter bottomup phase atom 2 intersect atom 1 frequent itemsets form atoms new sublattice solved using bottomup search process repeated atoms 2 maximal phase requires mainmemory atoms bottomup phase requires memory two consecutive levels hybrids sorted support 2 1 maximal phase r min sup else break bottomup phase figure 14 pseudocode hybrid search 53 number database scans processing sublattice initial decomposition relevant item tidlists scanned memory tidlists atoms frequent 2itemsets initial sublattice constructed intersecting item tidlists frequent itemsets enumerated intersecting tidlists atoms using dierent search procedures initial classes disjoint set items items tidlist scanned disk entire frequent itemset enumeration process sublattices general case degree overlap items among dierent sublattices however database portion corresponding frequent items need scanned lot smaller entire database furthermore sublattices sharing many common items processed batch mode minimize disk access thus claim algorithms usually require small number database scans computing f 2 54 new algorithms dierent algorithms propose listed algorithms dier search strategy used enumeration relation used generating independent sublattices 1 eclat uses prexbased equivalence relation 1 along bottomup search enumerates frequent itemsets 2 maxeclat uses prexbased equivalence relation 1 along hybrid search enumerates long maximal frequent itemsets nonmaximal ones 3 clique uses maximalcliquebased pseudoequivalence relation 1 along bottomup search enumerates frequent itemsets 4 maxclique uses maximalcliquebased pseudoequivalence relation 1 along hybrid search enumerates long maximal frequent itemsets nonmaximal ones 5 topdown uses maximalcliquebased pseudoequivalence relation 1 along topdown search enumerates maximal frequent itemsets note topdown search using larger sublattices generated 1 likely ecient 6 aprclique uses maximalcliquebased pseudoequivalence relation 1 however unlike algorithms described uses horizontal data layout two main steps possible subsets maximum element sublattice generated inserted hash trees 2 avoiding duplicates one hash tree length ie ksubset inserted tree c k internal node hash tree depth contains hash table whose cells point nodes sublattices induced 1 k 2 k jrj insert ksubset r c k transactions 2 ksubsets k 2 k jtj set frequent itemsets figure 15 pseudocode aprclique algorithm depth 1 itemsets stored leaves insertion procedure starts root hashing successive items inserts candidate leaf ii support counting step similar apriori approach transaction database form possible ksubsets search subset c k update count found database thus scanned frequent itemset generated pseudocode shown figure 15 6 apriori partition algorithms discuss apriori partition detail since experimentally compare new algorithms apriori algorithm apriori 2 iterative algorithm counts itemsets specic length given database pass process starts scanning transactions database computing frequent items next set potentially frequent candidate 2itemsets formed frequent items another database scan made obtain supports frequent 2itemsets retained next pass process repeated frequent itemsets enumerated complete algorithm shown gure 16 refer reader 2 additional details three main steps algorithm 1 generate candidates length k frequent k 1 length itemsets self join f k 1 ex ample f bcdbcebdeg 2 prune candidate least one infrequent subset example acd pruned since cd frequent pruning get new set c 3 scan transactions obtain candidate supports candidates stored hash tree facilitate fast support counting note second iteration optimized using array count candidate pairs items instead storing hash tree ffrequent 1itemsets transactions 2 ksubsets set frequent itemsets figure 16 apriori algorithm partition algorithm partition 26 logically divides horizontal database number nonoverlapping partitions partition read vertical tidlists formed item ie list tids item appears locally frequent itemsets generated via tidlist intersections locally frequent itemsets merged second pass made partitions database converted vertical layout global counts chosen itemsets obtained size partition chosen accommodated mainmemory partition thus makes two database scans key observation used globally frequent itemset must locally frequent least one partition thus frequent itemsets guaranteed found 7 experimental results experiments used 200mhz sun ultra2 workstation 384mb main memory used dierent synthetic databases used benchmark databases many association rules algorithms 1 2 6 15 19 20 23 26 30 wrote dataset generator using procedure described 2 generator produces longer frequent itemsets parameters code available sending email author datasets mimic transactions retailing environment people tend buy sets items together called potential maximal frequent set size maximal elements clustered around mean long itemsets transaction may contain one frequent sets transaction size also clustered around mean may contain many items let denote number transactions average transaction size size maximal potentially frequent itemset l number maximal potentially frequent itemsets n number items data generated using following procedure rst generate l maximal itemsets average size choosing n items next generate transactions average size choosing l maximal itemsets refer reader 4 detail database generation experiments set conducted databases dierent values database parameters shown table 1 database size table 1 database parameter settings figure 17 shows number frequent itemsets dierent sizes databases used ex periments length longest frequent itemset total number frequent itemsets database shown table 2 example t30i16d400k total 13480771 frequent itemsets various lengths longest frequent itemset size 22 025 support database longest freq itemset number freq itemsets t30i16d400k 05 minsup 22 13480771 table 2 maximum size number frequent sequences 025 support number frequent itemsets frequent itemset size min support 025 figure 17 number frequent itemsets dierent sizes comparative performance figure 18 figure 19 compare new algorithms apriori partition 3 10 database partitions decreasing values minimum support dierent databases support decreases size number frequent itemsets increases apriori thus make multiple passes database 22 passes t30i16d400k performs poorly partition performs worse apriori high support since database scanned times points overheads associated inverting database onthe dominate partition however support lowered partition wins apriori since scans database twice results agreement previous experiments comparing two algorithms 26 one problem partition number partitions increases number locally frequent itemsets globally frequent increases reduced somewhat randomizing partition selection partition thus spend lot time performing redundant intersections example compare time partition3 partition10 datasets partition10 typically takes factor 15 2 times time partition3 t30i16 1 support takes 13 times figure 20 shows number tidlist intersections dierent algorithms dierent datasets makes clear partition10 performing four times intersections partition3 aprclique scans database outperforms apriori partition higher support values t10 t20 datasets aprclique sensitive quality maximal cliques sublattices generated small support increasing transaction size xed edge density kassociation graph increases consequently increasing size maximal cliques aprclique doesnt time sec minimum support partition3 aprclique topdown eclat clique maxeclat maxclique4080120025 05 075 10 time sec minimum support partition3 aprclique topdown eclat clique maxeclat maxclique10010000 05 075 10 time sec minimum support partition3 aprclique topdown eclat clique maxeclat maxclique100025 05 075 10 time sec minimum support partition3 aprclique topdown eclat clique maxeclat maxclique10010000 05 075 10 time sec minimum support partition3 aprclique topdown eclat clique maxeclat maxclique10010000025 05 075 10 time sec minimum support partition3 aprclique topdown eclat clique maxeclat maxclique figure total execution time time sec minimum support partition3 eclat clique maxeclat maxclique figure 19 total execution time perform well conditions topdown usually performs better aprclique shares characteristics aprclique ie better apriori partition higher support values except t30 t40 datasets lower support maximum clique size worst case become large number frequent items forcing topdown perform many kway intersections determine minimal infrequent sets eclat performs signicantly better algorithms cases usually outperforms apriori order magnitude partition3 factor two partition10 factor four eclat makes database scans requires hash trees uses simple intersection operations generate frequent itemsets eclat able handle lower support values dense datasets eg t20i12 t40i8 apriori partition run virtual memory 025 support look comparison remaining four methods main contributions work ie eclat maxeclat clique maxclique clique uses maximalcliquebased decomposition generates smaller classes fewer number candidates however performs slightly better eclat clique usually 510 better eclat since cuts number tidlist intersections shown figure 20 clique performs anywhere 2 46 fewer intersections eclat dierence methods substantial since savings number intersections doesnt translate similar reduction execution time graphs maxeclat maxclique indicate reduction search space performing hybrid search provides signicant gains maximal cliquebased strategies outperform prex1e07 number intersections min support 025 partition3 topdown eclat clique maxeclat maxclique figure 20 number tidlist intersections 025 support based counterparts maxclique always better maxeclat due smaller classes biggest dierence methods observed t20i12 maxclique twice fast maxeclat interesting result t40i8 could run cliquebased methods 025 support prexbased methods eclat maxeclat able handle low support value reason cliquebased approaches fail whenever edge density association graph increases number size cliques becomes large signicant overlap among dierent cliques cases clique based schemes start suer best scheme databases considered maxclique since benets smaller sublattices hybrid search scheme figure 20 gives number intersections performed maxclique compared methods one see maxclique cuts candidate search space drastically anywhere factor 3 t20i4 35 t40i8 eclat performs fewest intersections method terms raw performance maxclique outperforms apriori factor 2030 partition10 factor 5 eclat much factor 10 t20i12 furthermore method able handle support values 05 t30i16 see figure 19 longest frequent itemset size 22 bottomup search methods would enumerate least 2 22 subsets maxclique performed 197601 intersections even though 13480771 total frequent itemsets see table 2 maxeclat quickly identies 22 sized long itemset also long itemsets thus avoids enumerating subsets 075 support maxclique takes 69 seconds apriori takes 22963 seconds factor 332 partition10 ran virtual memory summarize several reasons last four algorithms outperform previous approaches 1 use simple join operation tidlists length frequent sequence increases size tidlist decreases resulting fast joins 2 complicated hashtree structure used overhead generating searching customer subsequences incurred structures typically poor locality 24 hand new algorithms excellent locality since join requires linear scan two lists 3 minimum support lowered larger frequent sequences found apriori makes complete dataset scan iteration eclat three methods hand restrict usually scan cutting io costs 4 hybrid search approaches successful quickly identifying long itemsets early able avoid enumerating subsets long itemsets size 19 22 hybrid search methods able run methods run virtual memory101000 relative time number transactions t10i4 min support 025 partition aprclique topdown eclat clique maxeclat relative time transaction size min support 250 eclat clique maxeclat maxclique figure 21 scaleup experiments number transactions b transaction size scalability goal experiments measure new algorithms perform increase number transactions average transaction size figure shows dierent algorithms scale number transactions increases 100000 5 million times normalized execution time maxclique 100000 transactions minimum support value 025 used number partitions partition varied 1 50 algorithms scale linearly new algorithms continue outperform apriori partition figure shows dierent algorithms scale increasing transaction size times normalized execution time maxclique transactions instead percentage used absolute support 250 physical size database kept roughly keeping constant value used goal setup measure eect increasing transaction size keeping parameters constant see gradual increase execution time algorithms increasing transaction size however new algorithms outperform apriori partition transaction size increases number cliques increases clique based algorithms start performing worse prexbased algorithms0206114memory usage 2mean time eclat figure 22 eclat memory usage memory usage figure 22 shows total mainmemory used tidlists eclat computation frequent itemsets progresses t20i6d100k mean memory usage less 0018mb roughly 2 total database size gure shows cases memory usage twice mean peaks graph usually due initial construction 2itemset atom tidlists within sublattice gure conrms sublattices produced 1 1 small enough intermediate tidlists class kept mainmemory conclusions paper presented new algorithms ecient enumeration frequent itemsets presented latticetheoretic approach partition frequent itemset search space small independent subspaces using either prexbased maximalcliquebased methods subproblem solved mainmemory using bottomup topdown hybrid search procedure entire process usually takes database scans experimental evaluation showed maximalcliquebased decomposition precise leads smaller classes combined hybrid search obtain best algorithm maxclique outperforms current approaches order magnitude showed new algorithms scale linearly number transactions r mining association rules sets items large databases fast discovery association rules parallel mining association rules fast algorithms mining association rules dynamic itemset counting implication rules market basket data fast distributed algorithm mining association rules introduction lattices order arboricity bipartite subgraph listing algorithms computers intractability guide theory np completeness data mining discovering speci scalable parallel data mining association rules perspective databases data mining generation maximum independent sets bipartite graph maximum cliques circulararc graph interpretation graphs complexity characteristics search speci zarankiewicz numbers new algorithm discovering maximum frequent set mining association rules antiskew algorithms fast sequential parallel algorithms association rule mining comparison corrections bierstones algorithm generating cliques memory placement techniques parallel association mining integrating association rule mining databases alternatives implications sampling large databases association rules evaluation sampling data mining association rules new algorithms fast discovery association rules parallel algorithms fast discovery association rules tr ctr xiuli yunhai tong shiwei tang dongqing yang efficient incremental maintenance frequent patterns fptree journal computer science technology v19 n6 p876884 november 2004 zengyou xiaofei xu shengchun deng mining topk strongly correlated item pairs without minimum correlation threshold international journal knowledgebased intelligent engineering systems v10 n2 p105112 april 2006 valerie guralnik george karypis parallel treeprojectionbased sequence mining algorithms parallel computing v30 n4 p443472 april 2004 peiyi tang li ning ningning wu domain data partitioning parallel mining frequent closed itemsets proceedings 43rd annual southeast regional conference march 1820 2005 kennesaw georgia toon calders bart goethals michael mampaey mining itemsets presence missing values proceedings 2007 acm symposium applied computing march 1115 2007 seoul korea bart goethals memory issues frequent itemset mining proceedings 2004 acm symposium applied computing march 1417 2004 nicosia cyprus alexandros nanopoulos apostolos n papadopoulos yannis manolopoulos mining association rules large clustered domains information systems v32 n5 p649669 july 2007 supportordered trie fast frequent itemset discovery ieee transactions knowledge data engineering v16 n7 p875879 july 2004 yudho giri sucahyo raj p gopalan ctitl efficient frequent item set mining using compressed prefix tree pattern growth proceedings fourteenth australasian database conference p95104 february 01 2003 adelaide australia raj p gopalan yudho giri sucahyo efficient mining long frequent patterns large dense datasets design application hybrid intelligent systems ios press amsterdam netherlands nele dexters paul w purdom dirk van gucht probability analysis candidatebased frequent itemset algorithms proceedings 2006 acm symposium applied computing april 2327 2006 dijon france jauji shen powei hsu robust associative watermarking technique based similarity diagrams pattern recognition v40 n4 p13551367 april 2007 jie dong min han bittablefi efficient mining frequent itemsets algorithm knowledgebased systems v20 n4 p329335 may 2007 mohammad elhajj osmar r zaane cofi approach mining frequent itemsets revisited proceedings 9th acm sigmod workshop research issues data mining knowledge discovery june 13 2004 paris france bassem sayrafi dirk van gucht paul w purdom effectiveness efficiency computing bounds support itemsets frequent itemsets mining problem proceedings 1st international workshop open source data mining frequent pattern mining implementations p4655 august 2121 2005 chicago illinois son n nguyen maria e orlowska study data partitioning approach frequent itemsets mining proceedings 17th australasian database conference p3137 january 1619 2006 hobart australia yaochun huang hui xiong weili wu ping deng zhongnan zhang mining maximal hyperclique pattern hybrid search strategy information sciences international journal v177 n3 p703721 february 2007 congnan luo anil l pereira soon chung distributed mining maximal frequent itemsets data grid system journal supercomputing v37 n1 p7190 july 2006 mohammed j zaki chingjui hsiao efficient algorithms mining closed itemsets lattice structure ieee transactions knowledge data engineering v17 n4 p462478 april 2005 mohammed j zaki karam gouda fast vertical mining using diffsets proceedings ninth acm sigkdd international conference knowledge discovery data mining august 2427 2003 washington dc geller xuan zhou kalpana prathipati sripriya kanigiluppai xiaoming chen raising data improved support rule mining raise far raise intelligent data analysis v9 n4 p397415 july 2005 mukund deshpande george karypis using conjunction attribute values classification proceedings eleventh international conference information knowledge management november 0409 2002 mclean virginia usa charu c aggarwal towards long pattern generation dense databases acm sigkdd explorations newsletter v3 n1 july 2001 p valtchev r missaoui p lebrun partitionbased approach towards constructing galois concept lattices discrete mathematics v256 n3 p801829 28 october 2002 massimo coppola marco vanneschi parallel distributed data mining parallel skeletons distributed objects data mining opportunities challenges idea group publishing hershey pa claudio silvestri salvatore orlando distributed approximate mining frequent patterns proceedings 2005 acm symposium applied computing march 1317 2005 santa fe new mexico doug burdick manuel calimlim jason flannick johannes gehrke tomi yiu mafia maximal frequent itemset algorithm ieee transactions knowledge data engineering v17 n11 p14901504 november 2005 bart goethals mohammed j zaki advances frequent itemset mining implementations report fimi03 acm sigkdd explorations newsletter v6 n1 june 2004 r j kuo lin c w shih mining association rules integration clustering analysis ant colony system health insurance database taiwan expert systems applications international journal v33 n3 p794808 october 2007 gosta grahne jianfei zhu fast algorithms frequent itemset mining using fptrees ieee transactions knowledge data engineering v17 n10 p13471362 october 2005 john holt soon chung parallel mining association rules text databases journal supercomputing v39 n3 p273299 march 2007 toon calders bart goethals nonderivable itemset mining data mining knowledge discovery v14 n1 p171206 february 2007 chihming chen incremental personalized web page mining utilizing selforganizing hcmac neural network web intelligence agent system v2 n1 p2138 august 2004 chihming chen incremental personalized web page mining utilizing selforganizing hcmac neural network web intelligence agent system v2 n1 p2138 january 2004 michihiro kuramochi george karypis efficient algorithm discovering frequent subgraphs ieee transactions knowledge data engineering v16 n9 p10381051 september 2004 taneli mielikinen frequencybased views pattern collections discrete applied mathematics v154 n7 p11131139 1 may 2006 aaron ceglar john f roddick association mining acm computing surveys csur v38 n2 p5es 2006 mukund deshpande michihiro kuramochi nikil wale george karypis frequent substructurebased approaches classifying chemical compounds ieee transactions knowledge data engineering v17 n8 p10361050 august 2005
filterbased model checking partial systems recent years seen dramatic growth application model checking techniques validation verification correctness properties hardware recently software systems work aimed reasoning properties complete systems paper describes automatable approach building finitestate models partially defined software systems amenable model checking using existing tools enables application existing model checking tools system components taking account assumptions behavior environment components execute illustrate application approach validating verifying properties reusable parameterized programming framework b introduction modern software increasingly built collection independently produced components assembled achieve systems requirements typical software system consists instantiations generic reusable components components built specifically work supported part nsf darpa grants ccr9633388 ccr9703094 ccr9708184 nasa grant nag021209 system software development approach offers many potential advantages also significantly complicates process verifying validating correctness resulting software systems developers wish validate verify correctness properties software components face number challenges definition reusable components built systems incorporate thus detailed knowledge context component used unavailable components oftened designed general breadth applicability yet configurable needs specific systems generality may impede component verification typ ically components subjected unitlevel testing delivered informal documentation intended component interface behavior required component parameter behavior highassurance systems lacking number respects unitlevel reasoning focuses solely local properties component consideration ii informal documentation cannot directly incorporated rigorous reasoning processes iii system developers may knowledge context component use means exploiting information pa per describe automatable approach applying existing model checking tools verification partial software systems ie systems missing components addresses concerns model checking performed finitestate model system behavior actual system artifacts eg design code thus application model checking software must describe model construction approach models partial systems constructed two independent steps first partial system completed source code representation behavior missing system components converts open partialsystem closed system model checking tools applied second techniques partial evaluation abstract interpretation 19 18 applied transform completed source code input format existing finitestate system generation tools finitestate models built way safe thereby insuring correctness verification results may overly pessimistic respect missing components behavior enhance precision reasoning filter 16 missing components behavior based assumptions allowable behavior components approach supports model checking systems different kinds missing components including components call called execute parallel components partial sys tem flexibility enables verification properties individual components collections components systems work described paper extends applicability existing model checking techniques tools partial software systems illustrates practical benefits filterbased approach automated anal ysis illustrate approach benefits verifying correctness properties expressed linear temporal logic ltl 24 realistic generic reusable com ponents written ada using spin model checker 20 principle approach described paper used setting supports filterbased analysis 16 following section discuss relevant background material section 4 discusses abstractions used constructing finitestate software models section 5 describes approach completing partial software sys tems present experiences results applying analysis approach generic reusable software component section 6 section 7 describes related work conclude section 8 summary plans future work section overview ltl model checking variant model checking open systems called module checking technique refining model checking results using filter formulae ideas form basis approach constructing checking finitestate models partial software systems 31 model checking model checking techniques 7 20 found success automating validation verification properties finitestate systems particularly effective analysis hardware systems 26 communication protocols 20 30 recent work seen model checking applied general kinds software artifacts including requirements specifications 2 3 architectures 28 implementations 13 9 model checking software one describes software finitestate transition system specifies system properties temporal logic formula checks exhaus tively sequences transition system states satisfy formula variety temporal logics might used coding specifications use linear temporal logic work supports filterbased analysis supported robust efficient model checking tools spin 20 ltl pattern states defined characterizes possible behaviors finitestate system describe ltl operators using spins ascii notation ltl propositional logic standard connectives includes three temporal operators p says p holds point future p says p holds points future binary puq operator says p holds points first point q holds example ltl specification response property requests resource followed granting resource request granted spin accepts design specifications written promela language accepts correctness properties written ltl users specify collection interacting processes whose product defines finitestate model system behavior spin performs efficient nonempty language intersection test determine state sequences model conform negation property specification sequences property holds otherwise sequences presented user exhibits erroneous system behavior 32 module checking computer system design closed system system whose behavior completely determined state system open system module 22 23 system interacts environment whose behavior depends interaction given open system temporal logic formula module checking problem asks whether possible environments composition model environment satisfies formula fortunately ltl module checking problem coincides basic model checking problem22 often dont want check formula respect environments respect satisfy assumptions assumeguarantee paradigm 29 specification module consists two parts one part describes guaranteed behavior module encode finite state system analyzed part specifies assumed behavior environment module interacting combined property formula analyzed 33 filterbased analysis filters 16 constraints used incrementally refine naively generated state space help validate properties space via model checking filters represented variety forms eg automata temporal logic formulae used flavers static analysis system 14 filters flavers originally developed sharpen precision analysis relative internal components complete software system purposefully modeled safe abstract manner filters serve equally well refining analysis results respect external component behavior analysis partial software systems 11 paper encode filters ltl formulae perform assumeguarantee model checking given property encode assumptions environment model check combined refer individual f filters combined formula filter formula note many specification formalisms support filterbased analysis popular formalisms ctl may possible encode filter ctl formula general however multiple temporal operators cannot lie directly scope single path quantifier simple method constructing filter formula ctl principle model checking applied finitestate system nontrivial software systems cannot render finitestate system precisely models systems behavior since general system finitestate even finitestate software size precise finitestate model general exponential number independent components ie variables threads control rea sons would like use finitestate system models reflect execution behavior software precisely possible enabling tractable analysis use techniques abstract interpretation construct models remainder section introduce notion abstract interpretation describe collection abstract interpretations use model construction finally describe approach selection abstractions used given software system 41 safe models verification say finitestate model software system safe respect model checking property specification model checking succeeds property holds real system ltl model checking fundamentally allpaths analy sis abstraction behavior must preserve information possible system executions class abstractions described abstract interpretations ai 10 systems execution semantics abstractions similar kinds approximations introduced program representations eg control flow graphs used compiler analyses 27 behaviors abstracted way exhaustively compared ltl specification found conformance one sure true executable system behaviors conform specification one strengths ais guarantee safety information gathered analyses incorporate achieve need precisely define ai formalize ai sigmaalgebra 18 defines concrete type signature source pro gram type abstract domain ai abstract definitions operations signature operationally view sigmaalgebra data abstraction defined domain values implementations operations domain operational view allows systematic abstraction substituting abstract definitions concrete definitions abstracted program variables computation abstract values operations proceed way would concrete values operation unlike concrete operations program define abstract operations produce sets values operations return type mechanism encoding lack precise information variable values mechanism exploited partial evaluation capabilities discussed section 5 partial evaluator treat set values returned operation equally likely possibilities create variant program fragment value ie simulating nondeterministic choice allows subsequent analyses eg model checking detect presence specific values may returned operation technical details performed given 18 simple imperative language scaled techniques applied real ada program section 6 conceptually one think partial evaluation engine drives systematic application selected abstract interpretations given source program 42 sample abstract interpretations space constraints make impossible give complete formalization ais used example section 6 section describe main idea ai illustrate selected abstract operations point ai extreme form abstraction ai variables abstract domain single value representing lack knowledge possible variable values abstract operations variable defined constant function producing domain value abstract relational operations test value variable defined constant function returning set ftrue falseg point ai extreme abstraction never theless uncommon existing fsv approaches many state reachability analyses eg cats 32 use abstraction program variables closely related point ai choice ai ai also encodes complete lack knowledge possible program variables different way abstract operations defined produce set possible domain values abstract relational operations test value variable retain concrete semantics cases possible values reaching test consist set domain values result test set ftrue falseg exposing distinct domain values partial evaluator gives opportunity specialize program fragments respect possible variable values ex ample control flow branch variable value introduced program subsequent program fragments hoisted branch fragment specialized branch variable value tests abstracted variable within branch single domain value flowing thus refined test result eg true false may computed resulting program model precise using point ai care taken applying choice ai since result larger program model kordered data ai provides ability distinguish identity k data elements completely abstracts values elements 2ordered data ai pair concrete data values mapped abstract values 1 2 values mapped ot value like choice ai abstract operations defined return sets values model lack knowledge specific abstract values operations except assignment constant function returning fd 1 2 otg used assignment identity function used relational test operations slightly subtle relational operations equality inequality return falseg equality defined ffalseg x 6 inequality defined analogously special case classic signs ai 1 zeropos ai capable differentiating valuations variable positive zero abstract domain ranges three values unknown zero positive ai find convenient introduce unknown value represents fact variable either zero positive value abstract operations assignment constant zero increment decrement positive value greaterthan test zero defined positive operations defined analogously also possible define ai safe respect restricted class ltl properties one abstraction used commonly verifying message ordering requirements communication protocols wolper 31 shown reasoning pairwise ordering questions communication channel accepts large domains values achieved using domain size three 1 achieved data channel modified tested program 2 support reasoning class questions use 2ordered list ai ai represents behavior list data items abstracted 2ordered data ai conceptually values abstracted list record whether specific inserted list removed yet nonot 2ordered data list ordering also recorded attempt made represent number ot elements list relative position respect values abstract list values zero ot values mixed zero ot values mixed zero ot values mixed zero ot values 1 front 2 1 mixed zero ot values 2 front 1 technically ai safe ltl eg allow lists multiple instances 1 values however abstraction safe system executions inserted list thus ai safe ltl formulae requirements involving pair data items handled simple scaling approach described condition enforced using approach similar restriction errors discussed section 5 p arbitrary ltl formula call return prefixes indicate program actions invoking returning operation filter formula described section 3 restricts checking p paths consistent information preserved 2ordered list ai illustrate abstract list operations inserting elements tail removeing elements head operations defined analogously fot lg otherwise since list operations may produce values update list contents define abstract operations tuples first component return value indicates value returned rest components define components ai updated based operation next section discuss use 2ordered abstraction completing partial system enables verification ordering properties dataindependent systems 43 abstraction selection given collection program variables collection ais must select variable ai define semantics finitestate model believe process completely automated cases experience applying ais model construction however left us methodology set heuristics selecting abstractions methodology bind variables ais use additional program information refine modeling variable binding precise ai start point ai initially variables modeled point ai use choice variables small domains variables domains size less 10 used conditional expressions modeled choice ai semantic features specification property checked includes form propositions different semantic features program eg valuations specific program variables features must modeled precisely ai hope checking property select controlling variables addition variables mentioned explicitly specification begin y0 figure 1 example ai selection consider variables control de pendent conditional expressions controlling variables suggest semantic features modeled ai select variables broadest impact confronted multiple controlling variables model select one appears often conditional selection process complete generate finitestate model using variableai bindings check property model checker output either proves property presents counterexample whose analysis may lead refinement ais used model program variables illustrate methodology consider program fragment figure 1 variables x assume interested reasoning response property xiszero callp key features mentioned explicitly specification values variable x calls procedure p must model x precision point ai provides order determine states value zero effective ai x must able distinguish zero values nonzero values choose zeropos ai point could generate abstracted model check property consider additional refinements model choose latter illustrating example using control dependence information determine variables appear conditionals determine whether statements related x p execute example two variables could refine modeling variables prefer incremental refinement avoid unnecessary expansion model choosing variables see appears conditionals choose model since may broader impact modeling since boolean variable conditional tests falsity choose retain concrete semantics point would generate abstracted model check property true result obtained sure property holds program even though finitestate system models two variables precision false result obtained must examine counterexample produced model checker may reveal true defect program may reveal infeasible path model latter case identify variables conditionals along counterexamples path candidates binding precise ais methodology foolproof based fixed collection ais given program variable may require ai collection heuristics choosing variables refine may cause generation finitestate models overly precise whose analysis costly necessary nevertheless approach worked well variety examples continue improve incorporating additional ais mechanisms identifying candidates refinement fullyautomatable methodology could benefit automated support computing controlling variables analysis counterexamples currently investigating best provide kind support partial system collection procedures tasks 3 complete partial system generating sourcecode implements missing components call contexts context components combined given partial system stubs drivers defined represent three different kinds missing components calling called parallel contexts calling contexts represent possible behavior portions application invoke procedures partial system called contexts represent possible behavior application procedures invoked procedures tasks partial system parallel contexts represent portions application execute parallel engage intertask communication procedures tasks partial system simplicity discussion examples section phrase system models properties terms events ie actions performed software often convenient use mixture event statebased descriptions models properties example section 6 begin construction system model one must definition events possible ada programs events include entry calls accepts calls returns procedures designated statements executed variables achieving specified value partition events 3 approach section easily extended support packages program structuring mechanisms procedure p begin task body begin accept accept procedure stub choice begin loop case choice 1 3 p 4 null otherwise exit task body driver begin task body choice begin accept call missing loop case choice 1 3 null 4 null otherwise exit return missing accept task body driver choice begin loop case choice 1 3 te c 4 null otherwise exit figure 2 partial ada system stubs drivers internal components analyzed external events may executed missing components based partitioning construct stub procedure represents possible sequences external events calls public routines entries partial system figure 2 illustrates left side partial system consisting procedure p task internal events calls e entry execution c two external events defined b stub procedure driver task also given figure external entries parallel context defined existing model checking tools require single finitestate transition system input generate system source program procedures requires inlining form procedure integration describe construction sourcelevel model completed partial system series inlining operations assume recursive calls systems procedures stubs drivers given assumption figure 3 gives steps assemble completed system applying steps example gives code right side figure 2 stub procedure used model behavior missing called components enable model checking based assumptions behavior input collection procedures tasks description external alphabet output source level system without external references steps 1 generate stub procedure nondeterministically chooses actions external alphabet calls procedures entries program components must also capable choosing nothing return 2 inline calls procedures made stubs 3 stubs may contain inlined calls task entries task calls missing component specialize stub calls tasks entries replaced error indication 4 calls missing components tasks replaced stub routine indications call return missing component inserted stub body 5 driver parallel contexts formed inlining stub body figure 3 system completion algorithm specific missing components bracket inlined stub indicators call return events missing component eg call missing return missing goal system completion process produce legal ada source code subsequent tools process system somewhat odds fundamental lack knowledge event ordering missing components model lack knowledge nondeterminism introducing new variable choice tested stub conditionals variable abstracted point ai subsequent model construction tools represent conditionals nondeterministic choice must take care insure potential runtime errors preserved completed system since contribute actual behavior software example possible system tasks call stubs turn call system procedures containing entry calls task runtime error ada preserve possible behavior introduce error event example figure 2 point event introduced marked allows user test possibility runtime error filter allowable behavior missing components eliminate error ie using error property checked filter conversion done separately task amounts specialization stub body task interpreting selfentry calls error event completing partial program yield finitestate system next step selectively abstract program variables transform dynamic program behavior static form 51 automating model construction approach automating construction safe finitestate models software systems builds recent work abstractionbased program specialization 18 figure 4 illustrates steps converting ada source promela submitted spin model checker first partial system completed sourcelevel model execution environment apply sourcetosource partial evaluation tool transforms program form readily modeled finitestate system partial evaluation program transformation specialization approach exploits partial information program data essentially performs parts programs computation statically result simplified program specialized statically available data values widevariety source transformations applied aid finitestate model construction including procedure integration bounded static variation migration dynamically allocated data tasks compiletime 19 novel feature approach use ability incorporate ais selected variable 18 use variableai bindings discussed section 4 partial evaluation tool applied convert resulting ada sedl internal form used inca 4 toolset 4 converted promela promela submitted along ltl specification spin produces either indication successful model check counterexample aside selection ais approach completely automatable present system completion partial evaluation tools fullyimplemented used experiments described section 6 tools depicted figure 4 run without user intervention stubs drivers ab stracted specialized ada experiments constructed byhand using algorithms implemented partial evaluation tool implementing approach stub driver generation using ideas work synthesis program skeletons temporal logic specification 25 approach able encode filters environment behavior directly stubs drivers thereby eliminating need including filters formula checked remains seen whether encoding filters transition system formula checked results better performance plan explore question future work 4 inca previously referred constrainedexpressions toolset inca partial evaluator aibased adatosedl stateevent predicate definitions aivariable bindings external eventsstates promela true counterexample ada ada source ada system completor figure 4 model construction process 6 experiences section describe experiences applying techniques described paper model checking real partial software system begin description partial system 61 replicated workers computations replicated workers framework rwf parameterizable parallel job scheduler user configures computation performed job degree parallelism several predefined variations scheduler behavior instance framework collection similar computational elements called workers worker repeatedly accesses data shared work pool processes data produces new data elements returned pool users define number workers type work data computations performed worker data item version framework written ada 15 implements workers pool lock dynamically allocated instances task types figure 5 illustrates structure replicated workers framework sample interaction user application procedure entry calls depicted dashed solid arrows respectively figure applications create collection workers work pool configure certain details framework operation eg whether execute routine operates synchronous asynchronous invocation compu worker worker worker c create inputc v create input execute users application dowork figure 5 replicated workers framework tation initialized calls input routine started calling execute communicating way workpool collection workers cooperate perform desired computation terminate execution complete detailed description behavior rwf provided 15 execution state rwf consists local control flow states single pool single lock workers addition tasks maintains local data original ada code pool task left figure 6 boolean variable executedone three natural variables numwait numidle workcount two linked lists workpoollist newwork two variables work type array task accesses workers accessed discriminant value c lock task single boolean variable worker task boolean variable done three linked lists task access variable integer variable addition internal state rwf need consider state context represented stub driver code data component state work value passed input refer driverinput see variables abstracted variety different ways finitestate models used system validation 62 building rwf models use approach described section 5 produce finitestate systems represent behavior replicated workers framework framework built three active components task type activepool pool task type activeworker worker task mediates access shared resource resultlock user provided access framework functionality collection public procedures constructor create input task body activepool collection discriminant begin accept startup workcount 0 outer loop loop select accept execute cdone false 1 cmax loop exit end select loop select accept putnewworkin wlist removenewwork workitem 1sizenewwork loop insertwork workitem workcount removenewwork workitem numidle end select executedone true exit synchronous accept complete cdone true loop outer type zero pos zero positive task body gen1activepool choice begin accept startup workcount zero outer loop loop select accept execute gen1collectioninfo done false gen2activeworkerexecute gen3activeworkerexecute exit end select loop select accept put choice workcount positive end select numidle3 workcountzero executedone true exit numwait3 accept complete gen1collectioninfo done true loop outer figure original ada abstracted specialized ada activepool task output routines routine execute com putation activeworkers call user provided functions doworkdoresults perform subcomputations given work result data validating rwf implementation assume one task creates accesses instance framework means single driver used complete system model assumption relaxed would incorporate multiple drivers parallel component illustrate analysis configuration rwf three workers synchronous execution semantics reason local correctness properties system either internal rwf related semantics rwfs application interface reason external alphabet empty stub generated algorithm figure 3 case consists choices among calls rwf procedures defining generic parameters parameters create call consistent assumptions enables program specialization eliminate number program variables particular pools work variables array task accesses workers three linked lists task access variable integer variable eliminated variables eliminated values known constant others eliminated copy propagation transfer values variables significant number variables ranging large domains remain program apply ais section 4 remaining variables construct three different abstracted versions rwf system model 1 model aggressively ab stracted variables numwait numidle workcount workpoollist newwork driverinput abstracted point ai variables executedone done locks boolean retain concrete semantics initial attempts validate rwf properties use model used model 2 developed model order see existing properties could checked compact model 2 results presented confirm possible parameters passed dowork doresult routines modeled stubs also require abstraction model input work parameter abstracted point ai boolean output parameter uses choice ai model 2 figure 6 gives original ada source abstracted specialized ada code activepool task rwf due space limitations details example elided figure denoted interesting transformations remain first model several local vari ables workpoollist newwork driverinput abstracted point ai variables influence branch decisions nondeterminism used since nondeterministic choice construct ada introduce new variable choice indicates convention model construction tools nondeterministic choice value variable desired remaining variables executedone numwait numidle retain concrete semantics workcount abstracted zeropos ai note numwait numidle act bounded counters number workers thus relatively small impact size model activeworker tasks model model 1 details specialization process illustrated figure 6 knowledge number workers exploited unroll loop specialize body consequence resulting ada contains static task references eg gen1activeworker fact partial evaluation applied example converts dynamically allocated data tasks static form indirect data task references static form loop unrolled rather zeropos ai used body specializer determines two possible values workcount loop unchanged positive produces conditional model 3 model 2 insufficient validation ordering properties work items rwf constructed third rwf model incorporated 2ordered data ai worktype data 2ordered list abstraction workpoollist data even though model uses nontrivial domain variables worktype resulting model explicitly require modeling pools local variables since serve transfer values lists possible generate compact finitestate stub driver input sequence work data partial system analysis properties wish check generality required stub driver models 2 3 require information input sequence consequently point ai suffices model require finer abstraction stub driver model incorporated 2ordered environment abstraction binding driverinput variable 2ordered data ai thus input sequences modeled sequences values fd 1 2 otg 63 properties model checked collection correctness requirements replicated workers framework requirements derived english language description framework encoded ltl formulae using patterns 12 expressed formulae terms event state predicates converted automatically inca toolset propositions use defining ltl formulae spin event refers occurrence rendezvous procedure call designated program statement event predicate true task containing specified event state immediately following transition event state predicates define points selected program variables hold given value eg states workcount zero note defining boolean expressions encoding state predicates quite involved cases example inca predicate definition states workcount zero defpredicate workcountiszero intask activepooltask workcount zero causes generation disjunction 123 individual state descriptions ie one state activepool task workcount value zero experience suggests automated support definitions necessary component finitestate software verification toolset selection specifications checked given figure 7 model checks performed using spin version 309 sun ultra5 270mhz ultrasparc iii 128meg ram figure 8 gives data model checking runs transition system model used run given report usersystem time running spin convert ltl spin input format compile promela model checker execute model checker model construction tools run alphastation 200 4233 128meg ram longest time taken 1 call doresultsi return doresultsi call doresultsj u return doresultsi mutually exclusive execution doresults 2 call execute call dowork u call execute work scheduled execution 3 return execute call execute call dowork u call execute scheduled termination call execute return execute u done w1 jj done w2 jj done w3 jj workcounteqzero jj return execute computation terminates workpool empty worker signals termination done w1 jj done w2 jj done w3 call dowork worker ready get work workpool empty computation done work scheduled schedules work input order work item scheduled scheduled work item processed scheduled figure 7 ltl specifications convert completed ada sedl model 3 took 663 seconds generating promela sedl vary due differences predicate definitions required different properties longest time taken step also model 3 took 164 seconds 64 discussion specified properties known hold rwf implementation analyzed specifications 13 filters required obtain true results remaining specifications required form filter properties 68 required filter section 4 insure safety model check results 2ordered ai incorporated transition system discuss filters properties 45 specifications 1 7 shorthand collections specifications different worker tasks ids model checks times equal different versions specification one time given figure 8 modeling missing components using permissive stubs drivers described section 5 advantage yielding safe models system configuration considered drawback may precisely describe required behavior missing components reason model checks specifications 4 property time result model 4f 07 3443 88 true 2 6f 13 36587 13081 true 3 figure 8 performance data 5 failed boost precision analyzing prop erties code assumptions required behavior missing components eg dowork filterformulae model checked analysis counter example provided spin specification 4 showed doresults calls made gen1activeworker call activepoolfinished entry stub routine allows doresults perform computation api documentation rwf warns users calling rwf operations dowork doresults assume users heed warning define two filters eliminate calls resulting filter mula 4f callexecute returnexecute u workcountiszero returnexecute call stubrwf w call stubrwf r rather large conjunctions events correspond calls rwf operations stubs inlined dowork doresult callsites within workers generation propositions relatively simple using incas predicate definition mechanism filters used specification 5f use filters properties 68f required since ais incorporated model guaranteed safe assumption single insert work datum abstracted workpoollist even though unfiltered versions properties returned true result results cannot trusted may case ai caused certain possible system executions excluded analysis execution violated specified property true result might returned defect system insure case checked following filter formula 6f properties 78f referred d1 include filter restricts inserts d1 65 lessons learned experience using filters model checking example consistent previous work filterbased verification 11 14 28 many cases filters necessary necessary relatively filters sufficient achieve level precision necessary property verification model checking properties sample system fast enough usable practical development setting note second component model check time figure 8 sum time spin compile promela input c program time compile c program bulk cost cases compiling c program reader interpret times inherent component cost using spin inca tools use generate promela code encode local task data control flow promela task rather promela variables cause dramatic increase size c program generated consequently compile times significant study required determine whether direct mapping promela would yield significant reductions times interesting note addition filters cases reduce analysis cost eg property 4f others dramatically increase analysis cost eg property 6f conceptually analysis cost reduced paths finitestate model inconsistent filters considered model checking analysis cost increased hand effective state space ie product model property significantly larger study needed understand situations reduction increase analysis cost expected using filters methodology incorporating ais finitestate models yields aggressively abstracted transition sys tems nevertheless one might expect even relatively small changes abstractions incorporated three models dramatically change space consequently time required model check ing checks properties 1 2 using model 1 required order 1000 states searched whereas checks properties 68 using model 3 required order 100000 states searched believe constructing compact transition systems retaining sufficient precision enable successful model checks requires ais selected incorporated independently properties refer set propositions experiments cost model construction dominant factor analysis time benefits independently abstracted models may yield overall reduction analysis time important note observations based checking local properties cohesive partial system relatively narrow welldefined inter principle may necessary include large number filters may dramatically increase model check cost believe application approach described paper sensible points development process unit integration level testing currently applied context believe subsystems analysis similar rwf system ie highly cohesive loosely coupled environment evaluation necessary determine conclusively study cost filterbased model checking partial systems strongly coupled environment work described paper touches model checking software systems model checking open partial systems abstractions model checking section 3 already discussed bulk related work recent efforts apply model checking techniques abstracted software systems eg 13 30 work adhoc abstraction performed hand transforming source code models suitable analysis automating selection abstractions difficult problem application abstractions relatively wellunderstood unlike adhoc methods work builds solid semantic foundations rich history existing abstractions developed twenty year history abstract interpretation 10 furthermore explore use partial evaluation techniques eg 21 means automating application abstractions use filters refine model environment similar work compositional verifica tion divideandconquer approaches decompose system subsystems derive interfaces summarize behavior subsystem eg 6 perform analyses using interfaces place details subsystems notion capturing environment behavior interfaces also appears recent developments theoretical issues related model checking partial systems eg 22 23 considerably less work practical issues involved finitestate verification partial systems aside work flavers discussed section 3 two recent related practical efforts avrunin dillon corbett 5 developed technique allows partial systems described mixture source code specifications work specifications thought assumptions filters naive completion partial system given code unlike work approach targeted automated analysis timing properties systems colby godefroid jagadeesan 8 describe automatable approach completing reactive partial sys tem unlike approach work aimed producing completed system executable context verisoft toolset 17 system completion acts controlling environment causes given partial system systematically explore behavior compare specifications correctness prop erties produce tractable completion perform number analyses determine portions partial system influenced external behavior example tests externally defined variables modeled nondeterministic choice equivalent abstracting external data point ai happens default approach use filters allows restriction external component behavior possible approach approaches sensitive elimination abstraction program actions may cause runtime errors case manifested modeling selfentry calls error actions described automatable approach safely completing definition partial software system shown completed system selectively abstracted transformed finitestate system input existing model checking tools illustrated approach strikes balance size precision way enables model checking system requirements real software components finally shown refine representation system behavior cases precision base representation insufficient enable proof additional system requirements number questions plan investigate follow work work described pa per encode filter information model check onthefly alternate method encode directly finitestate system currently comparing two approaches order characterize circumstances one approach preferable paper consider individual abstrac tions encoded ai know systems desired abstraction composition two ais investigating extent construction compositions automated finally continuing development tools make approach plan evaluate utility applying additional real software systems along completed toolset plan produce library abstractions users selectively apply program variables allow nonexpert users begin experiment model checking source code real componentbased software systems 9 acknowledgements thanks john hatcliff nanda muhammad helping specialize versions replicated workers framework hand thanks james corbett george avrunin access inca toolset special thanks james responding request predicate definition mechanism implementa tion thanks anonymous referee gave detailed useful comments paper r abstract interpretation declarative languages analyzing partiallyimplemented realtime systems checking subsystem safety properties compositional reachability analysis automatic verification finitestate concurrent systems using temporal logic specifications automatically closing open reactive programs evaluating deadlock detection methods concurrent software abstract interpretation unified lattice model static analysis programs construction approximation fixpoints modular flow analysis concurrent soft ware property specification patterns finitestate verification model checking graphical user interfaces using abstractions data flow analysis verifying properties concurrent programs applicationindependent concurrency skeleton ada95 limiting state explosion filterbased refinement model checking programming languages using verisoft staging static analysis using abstractionbased program specializa tion automatically specializing software finitestate verification model checker spin partial evaluation automatic program generation module checking module checking revis ited temporal logic reactive concurrent systems specification synthesis communicating processes temporal logic specifications symbolic model checking advanced compiler design imple mentation transition global modular temporal reasoning programs model checking software systems case study specifying interesting properties programs propositional temporal logics tr automatic verification finitestate concurrent systems using temporal logic specifications abstract interpretation declarative languages transition global modular temporal reasoning programs automated analysis concurrent systems constrained expression toolset temporal logic reactive concurrent systems partial evaluation automatic program generation data flow analysis verifying properties concurrent programs concurrency analysis tool suite ada programs model checking software systems checking subsystem safety properties compositional reachability analysis model checking large software specifications applicationindependent concurrency skeleton ada 95 analyzing partiallyimplemented realtime systems model checker spin model checking programming languages using verisoft applying static analysis software architectures model checking graphical user interfaces using abstractions automatically closing open reactive programs advanced compiler design implementation property specification patterns finitestate verification synthesis communicating processes temporal logic specifications expressing interesting properties programs propositional temporal logic abstract interpretation symbolic model checking statebased model checking eventdriven system requirements evaluating deadlock detection methods concurrent software module checking modular flow analysis concurrent software ctr oksana tkachuk matthew b dwyer adapting side effects analysis modular program model checking acm sigsoft software engineering notes v28 n5 september frank huch verification erlang programs using abstract interpretation model checking acm sigplan notices v34 n9 p261272 sept 1999 matthew b dwyer john hatcliff roby joehanes shawn laubach corina psreanu hongjun zheng willem visser toolsupported program abstraction finitestate verification proceedings 23rd international conference software engineering p177187 may 1219 2001 toronto ontario canada patrice godefroid lalita j jagadeesan radha jagadeesan konstantin lufer automated systematic testing constraintbased interactive services acm sigsoft software engineering notes v25 n6 p4049 nov 2000 john penix willem visser eric engstrom aaron larson nicholas weininger verification time partitioning deos scheduler kernel proceedings 22nd international conference software engineering p488497 june 0411 2000 limerick ireland g j holzmann h smith automated verification method distributed systems software based model extraction ieee transactions software engineering v28 n4 p364377 april 2002 victor braberman miguel felder verification realtime designs combining scheduling theory automatic formal verification acm sigsoft software engineering notes v24 n6 p494510 nov 1999 ji zhang betty h c cheng specifying adaptation semantics acm sigsoft software engineering notes v30 n4 july 2005 john hatcliff matthew b dwyer hongjun zheng slicing software model construction higherorder symbolic computation v13 n4 p315353 dec 1 2000 ji zhang betty h c cheng modelbased development dynamically adaptive software proceeding 28th international conference software engineering may 2028 2006 shanghai china john penix willem visser seungjoon park corina pasareanu eric engstrom aaron larson nicholas weininger verifying time partitioning deos scheduling kernel formal methods system design v26 n2 p103135 march 2005
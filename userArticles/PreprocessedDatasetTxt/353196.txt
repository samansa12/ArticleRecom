approach safe object sharing essential security able isolate mistrusting programs one another protect host platform programs isolation difficult objectoriented systems objects easily become aliased aliases cross program boundaries allow programs exchange information without using system provided interface could control information exchange java mistrusting programs placed distinct loader spaces uncontrolled sharing system classes still lead aliases programs paper presents object spaces protection model objectoriented system model decomposes application set spaces object assigned one space method calls objects different spaces mediated security policy implementation model java presented b introduction age internet programming importance sound security mechanisms systems never greater host execute programs unknown network sources needs able run program distinct protection domain program running protection domain prevented accessing code data another domain control security policy domains protect mistrusting programs also protect host environment several aspects protection domains access control resource allocation control safe termination paper concentrates access control several ways implement protection domains programs operating systems traditionally implement domains using hardwareenforced address spaces trend towards portable programs mobile code led nonetheless virtual machines enforce protection software one example objectoriented context guarded object 10 approach guard object maintains reference guarded object request gain access guarded object mediated upon guard another example software enforced protection found java 2 protection domain possesses name space set classes objects 17 domains share basic system classes isolation java protection domains enforced runtime controls assignment object reference variable another domain signaled type error classcastexception difficulty implementing protection domains objectoriented context ease object aliases created 12 object aliased least two objects hold reference aliasing difficult detect unexpected aliasing across domains constitute storage channel since information intended external access leaked modified 15 aliasing domains avoided making object sets disjoint data needs shared domains exchanged value instead reference partitioning protection domains disjoint object graphs cumbersome object needs accessible several domains simultaneously especially true object mutable eg application environment objects necessitates continuous copies object made transmitted serious problem system objects must directly shared domains eg systemprovided communication objects even limited sharing enough create aliases lead storage channels instance nothing prevent error code guard object leaking reference guarded object outside world techniques control object aliasing often cited means enforce security controlling spread object references programs 12 techniques fundamentally software engineering techniques goal enforce stronger object encapsulation security requires two main reasons first aliasing control techniques often classbased aim prevent objects class referenced though cannot protect selected instances class second security constraints dynamic nature aliasing constraints one example server containment 7 goal allow server process client request request server must forget references holds objects transmitted client goal server containment reduce servers ability act covert channel 15 crux problem reference ob tained used name object invoke methods object believe naming invocation must separated thus introducing access control language least privilege 23 one example system security property requires access control imple mentation least privilege means program assigned minimum rights needed accomplish task using example file system security least privilege insists directory object able gain access files stores 7 order minimize effects erroneous directory objects thus directory name file objects neither modify extract contents paper introduces object spaces model objectoriented system java 2 chosen implementation platform space lightweight protection domain houses set objects method calls objects different spaces mediated security policy though attempt made control propagation object references spaces model allows safe efficient object sharing efficiency stems fact copybyvalue object parameters domains longer needed model safe sense ever object reference leaked program another space invocation method using reference always mediated security policy addition access objects different spaces prohibited default space must explicitly granted access right space invoke object owner space may time revoke right implementation model made java thus modifications java vm language needed application object implicitly assigned space object object create object another space though receives indirect reference object bridge object returned references new object implementation assures basic property access object another space always goes bridge object bridges contain security policy mediate crossspace method call space lightweight protection domain models access control element domain thread management resource control issues treated since require modifications java virtual machine remainder paper organized follows section 2 outlines object space model explains design choices section 3 presents java api model examples use section 4 describes implementation model java 2 gives performance results section 5 reviews related work section 6 concludes 2 object space model basis object space model separate ability name object ability invoke methods object done partitioning applications set objects several object spaces space contains set objects possibly children spaces every object application inside exactly one space object may invoke method object resides space method invocation objects different spaces mediated applicationprovided security policy start section 21 overview object space model formal definition model given section 22 present examples model wellknown protection problems section 23 21 model overview set spaces application created dynami cally application startup initial objects occupy rootspace objects space may create spaces new spaces owned rootspace children spaces may turn create spaces space created object enclosing space creator object becomes owner space new space space graph thus tree ownership relation b c figure 1 ownership authorization relations spaces object space may invoke methods object another space second space owned calling objects space calling object owner space called object calling space must explicitly granted right invoke methods objects second space owner second space set spaces organized hierarchically models well control structure many applications 22 typically system separates programs set protection domains since must protected programs components may also need isolated one another since example may use code different libraries object space model program space map components distinct spaces decided include space destruction within space model difficultly implementing safely efficiently space like object removed system spaces longer possess reference objects inside object may create objects space without prohibition space may also create objects children spaces spaces initial objects created space s1 may create objects another space s2 s1 parent space s2 goal restriction prevent s1 inserting trojan horse object space s2 tricks s2 granting s1 right s2 figure 1 gives example space graph application develops access rights introduced ownership represented arrows access rights represented dashed line arrows system starts rootspace represented space s0 figure created example space s0 creates two children spaces s1 s2 permits objects space s1 invoke objects space s2 objects space s0 invoke objects spaces s1 s2 default since space s0 owning space s1 s2 figure 1b space s1 creates child space s3 grants copy access right s2 space s1 possesses right s3 though figure 1c s3 created child space s4 granted space s2 access right s4 means objects spaces s2 s3 call objects space s4 access control model could seen introducing programming complexity object possesses reference longer assured method call referenced object succeed also case applets java calls issued applets system objects mediated securitymanager objects reject call 22 formal definition state object space protection system defined triple r set spaces ownership relation r represents space access rights let n denote set space names generated subset names newly created spaces taken nns relation spaces n theta n fnullg use s1 s2 mean space s1 owned space s2 expression s1 s2 evaluates true s1 s2 null value definition denotes owner rootspace finally r relation type n theta n s1 r s2 means space s1 possesses right invoke methods space s2 space always right invoke objects owned spaces s1 s2 s2 r s1 object always invoke methods objects space 8ss r define semantics object space opera tions grants0 s1 s2 operation allows object space s0 give objects space s1 right invoke objects space s2 operation succeed s0 must owning space s2 s0 must already access right s2 owner s1 logic behind parent space decides access chil dren space may always copy right possesses children spaces s2 s0 s0 r s2 s1 s0 r fs1 s2g else r access rights spaces also revoked space revoke right space possesses right space owned space loses right descendant spaces space hierarchy implicitly lose right also space might acquired right granted copy right child space child execute code behalf exploits access right operation revokes0 s1 s2 used object space s0 remove right objects space s1 access objects space s2 operation reverse grant ds denotes set descendant spaces space tree said spaces also right revoked dsg operation allow owner lose right access child space s2 s0 s1 s0 s1 r s2 r n fs1 s2 else r space may create new space becomes owner new space given fresh name 62 createss r system startup rootspace s0 created initial system state thus fs0 g fs0 nullg fs0 s0g finally time method call effected system access control decision made using checkaccess operation determine space s0 may invoke methods objects space s1 figure 1a fs0 s1 s2g fs1 s0 s2 s0 s0 nullg r contains fs0 s1 s0 s2 s1 s2g well pairs figure 1b sets fs3g fs3 s1g fs3 s2 s1 s3g included three elements system state figure 1c s3 created child space s4 granted space s2 access right s4 thus s3 r s4 s2 r s4 s4 s3 23 examples give brief examples model ex ploited detail added section 3 java api model presented 231 program isolation todays computer users cannot realistically trust programs run bug virus free crucial host able run nontrusted program isolation services means client programs able communicate services control security policy decides whether method call program servers permitted basis achieving isolation using object space model shown figure 2a root space creates space server host service objects client space user programs hosts security policy placed root space controls whether user programs may access services using grant revoke operations code example given section 32 comparison ability isolate programs fashion awkward java using loader spaces java program allocated class loader 17 responsible loading versions classes pro gram object instantiated class loaded one loader considered possessing distinct type objects class loaded another loader means assignment object reference one domain variable another domain constitutes type error classcastexception model inconvenient clientserver communication since parameter objects must serialized transferred value b root root guard gobj c user root client server client1 client2 server user packet figure examples spaces 232 guarded objects common example mechanism controlled sharing guarded objects consider two different versions guarded object notion java 2 version 10 second traditional version 23 java guard object contains guarded object application startup guard object possesses reference guarded object object contains method executes checkaccess method encapsulates security policy returns reference guarded object checkaccess permits mechanism useful contexts client must authenticate server gaining access server objects eg file server authenticates access using checkaccess returning reference file implementation traditional guarded object notion would never return reference guarded object rather method call guarded object would mediated guard would transfer call checkaccess permits transfer back result object approaches weaknesses however java version way revoke reference guarded object reference copied outside guard object revocation needed practice confine spread access rights system problem traditional notion guarded object method guarded object may return object contains reference guarded object clearly undermines role guard figure 2b illustrates guarded objects implemented object space model guard object placed space guard guard creates child space gobj instantiates guarded object space guard controls spaces access gobj implement traditional version guarded object paradigm guard would never grant access gobj spaces implement java version getobject guard grants client space access gobj event checkaccess succeeding guard time revoke access something cannot done traditional implementations even reference leaked grant operation must also effected access guarded object possible give code example section 32 guards required systems stronger encapsula tion goal encapsulation able make object public accessible programs without making component objects directly accessible often requirement kernel interface objects since serious error could occur user program gained hold reference internal object example security bug allowed applet gain reference list code signers jdk111 applet could modify 4 adding signer objects list applet could inherit privileges associated signer private vector object signers public vector getsigners return signers jdk actually used array represent signers 4 arrays require special treatment object space model seen section 4 example also shows declaring variable private enough control access object bound variable object space model stronger encapsulation internal objects eg signers achieved objects instantiated space gobj owned kernel interface objects space guard 233 server containment servers shared several client programs environment mistrusting programs execute server allowed act covert channel holding onto references objects passed parameters service request subvertly passing references third party security requires server contained 7 server longer gain access object request serviced schema using spaces shown figure 2c packet space objects passed parameter server granted access objects duration service call access revoked following call server containment requires ability isolate programs one another ability revoke rights spaces uses features also present preceding two examples 3 object space api section describes classes object space system api presents example use 31 basic java classes three classes application requires use object space model iosobject space remotespace briefly describe role presenting implementation java 2 section 4 class iosobject 1 describes object possesses attribute space attribute denotes space houses object objects application need inherit iosobject requirement first object instantiated within space subclass iosobject since way least one object others may obtain pointer enclosing space object api iosobject following public class iosobject protected space myspace public iosobject public final space getspace getspace method enables object get handle enclosing space iosobject space class represents objects handle enclosing space handles spaces instances remotespace class spaceobject empty interface implemented space remotespace public final class space implements spaceobject public static remotespace createrootspaceiosobject iosobj protected public remotespace createchildspace public void grant spaceobject sourcespace spaceobject targetspace public void revoke spaceobject sourcespace spaceobject targetspace public object newinstance string classname remotespace target public remotespace getparent protected void setparentspace parent static boolean checkaccess space protectedobjspace ios comes internet operating system name project space model developed space callerspace recall spaces organized hierarchy root hierarchy created static method createrootspace method returns remotespace ob ject system ensures method called createchildspace method creates child space invoking objects space grant revoke methods implement access control commands model see section 22 space object invokes either operation grantor revoker space operation newinstance method creates object within specified space objects initially created inside space implementation verifies class specified extends iosobject subsequently created objects means obtain reference space parent space may execute method goal prevent spaces injecting malicious code space aim forcing space execute grant would allow malicious object space gain access right attacked space setparent method executed system initiating space checkaccess method consults security policy two methods used object space model implementation third classes object space api remotespace public final class remotespace implements spaceobject public remotespacespace sp represents handle another space uservisible public operation constructor allows object generate remote space pointer pointer enclosing space enables space transfer pointer spaces thus allow spaces grant access rights important note object possess space reference enclosing space never spaces way system assures object one space force another space grant access right since grant revoke operations defined space meaning system always identify space invoking object thus authorize call note also space remotespace classes final meaning malicious program cannot introduce trojan horse versions classes system 32 example code extracts first example continues program isolation discussion section 231 taken newspaper system production distribution articles 19 concentrate program compiles article security reasons wish isolate program rest system particularly storage graphical editor objects requires able meditate method calls client program services security requirements summarized figure 3 typical example need isolate user programs rest system section 4 gives performance comparison implementation example using java loader spaces copybyvalue semantics object spaces implementation root storage article client client space service space editor figure 3 article packager example code root application startup program creates two object spaces instantiates objects domain class application uses object space model api methods editor class uses several swing components offer frontend user exchanges request messages events client program public class root extends iosobject public void start create client server spaces remotespace remotespace allocate access rights create services newinstanceguieditor child1 storage newinstancekernelstorage child1 create client client newinstancekernelclient child2 start things running editor ed einitc ainitcinited public static void main string args remotespace example application main starts instance root creates two child spaces child1 child2 grants right space invoke object methods editor object storage object created space child1 client program installed child2 editor given reference client object forward events gui interface client given reference two service objects root class almost identical used implementation guarded object model figure 2b guard object client created distinct spaces extract example guard string class iosstring guarded object class iosstring version string motivation class given section 4 import internetos import internetoslang public class guard extends iosobject iosstring guardedobject remotespace guardedspace public void init newinstanceinternetoslangiosstring guardedobject setnew iosobjectthe secret text public object getobjectiosstring password remotespace caller checkaccesspassword myspacegrantcaller guardedspace return guardedobject guard object init method called root method creates child space guardedspace instantiates guarded object space initializes using set method defined iosstring role guard mediate access requests getobject client must furnish password string guard verifies password using guard objects checkaccess method check succeeds guard grants access client space returns object reference public class client extends iosobject guard g public void initguard g g iosstring new iosstringthis password iosstring iosstringggetobjectpassword new remotespacemyspace systemoutprintlnstring client program requests access guard supplying password pointer space getobject 4 object space implementation section describe implementation model first describe notion bridge mechanism separates spaces implementation level portability prototyping reasons current implementation made java 2 platform modifications virtual machine language made future implementation could integrate model jvm way aspects protection domains resource control safe termination also treated begin section 41 describing basic role bridge objects section 42 describes interposed method calls spaces section 43 explains bridge classes generated section 44 describes detail object space model interacts cases conflicts features java language section 45 presents performance evaluation implementation 41 bridge objects far seen objects belong spaces interact either locally inside space issue method calls across space boundaries interactions objects different spaces allowed security policy permits implement object space model bridge object interposed caller callee object located different spaces caller authorization issue call bridge forwards call callee otherwise security violation exception raised call callee protected object since protected external accesses bridge use term possessor refer caller illustrated figure 4 real references denoted arrows dashed line arrow denotes protected reference whose use meditated security policy security policy represented access matrix accessible bridges encodes authorization relation r defined section 22 access matrix bridge protected object possessor space 1 figure 4 bridge object interposed object spaces bridges hidden application programmers purely implementation technique appear api assuming security permits program behaves direct reference objects remote spaces main exception rule array references always refer local copies arrays even entries array refer remote objects return question arrays section 44 consider class root section 32 start method contains call cinited transfer references editor storage objects client program three objects different space root object references used fact references bridge objects even though programmer root class see bridges implemented using instances java bridge classes bridge interface provide class c bridged class bc constructed interface bc c bc defined subclass c makes possible use instances bc ie bridges anywhere instance c expected role bridge threefold 1 verifies caller issue call protected object precise results verifying space caller access space callee according security policy consulted using checkaccess method class space method shown figure 7 2 forwards request possessor protected object possessor right access protected object 3 ensures objects exchanged parameters possessor protected object become directly accessible outside spaces protection model broken object obtains direct reference object another space reference direct bridge interposed objects happen call arguments directly passed callee therefore bridge interposed callee arguments ceives similarly wrapping occur object returned method call protected object avoid reference leaks exploiting java exception mechanism bridges also responsible catching exceptions raised execution protected objects method throwing bridged versions exceptions caller 42 interposition bridges bridges introduced system application object creates object child space using newinstance method method furnished system space cannot redefined users since defined final class addition creating required object assigning space newinstance creates bridge new object reference bridge returned object initiates object creation making new object accessible creator bridge instance example 32 references e c point bridge instead pointing directly editor storage client object since objects created using newinstance way bridge objects appear system crossdomain calls need protection arguments returned objects arise default reference object passed bridge bridge object referenced object generated destination space nevertheless bridge object protected object already exists destination space reference bridge returned instead new bridge object generated implemented using map maps protected object space pairs bridge used objects space refer protected object advantage solution bridge shared among objects space referring protected object however objects reside different spaces cannot share bridge second advantage time needed consult bridge cache inferior time needed generate new bridge object final advantage concerns equality semantics operator applied two bridge references protected object always evaluates true however cases bridge interposition necessary instance object creates another object resides space creator direct reference new object allowed case java new operator used ie object created new belongs space creator direct invocations allowed bridge receives bridge reference argument call observes protected object bridge actually destination space protected object reference returned place bridge space 1 o3 space 3 space 1 o3 o2 o2 o4 figure 5 creation bridges spaces example interposition bridge objects shown figure 5 space 1 possesses object o1 creates object o2 space 2 using newinstance bridge b1 created reference o1 passes reference o2 b1 detects reference remote creates bridge b2 o2 creates object o3 locally space using new obtains direct reference o3 creates object o4 space 3 bridge b3 created finally o2 passes reference o1 o4 via o3 new bridge b4 created notes reference space 3 space 1 exception exchange remotespace objects objects type freely passed foreign spaces without bridge intervention con sequently direct access objects allowed objects used spaces granting revoking accesses children allowing direct sharing remotespace objects lead reference leaks since methods instance fields remotespace accessible user programs seen api space object transmitted bridge converted remotespace needed ensure invariant space object referenced object enclosed space 43 generating bridge classes subsection describes generation system bridge class bc mediates accesses instances class c bridge generation always starts call getbridge method bridgefactory class method expects three arguments object bridge guard protected object space protected object space possessor method getbridge returns bridge whose class subclass protected objects class class file bridge exist time method called construction class file started instantiation new object follows method also responsible management map caches bridges interposed given space protected object returns cached bridge another object given space refers protected object outline code class bridgefactory shown figure 10 bridge classes placed package object space implementation constructors protected prevents user code directly creating instances main task behind generation bridge pro duce method defined class c well superclasses corresponding method mb bc implements expected functionality bridge described section 41 structure mb method generated uni form first piece code inserted beginning method consult security policy access granted bridge instead argument passed protected object forwarding call done argument except argument primitive class remotespace case value argument copied ensures protected object cannot possess direct access arguments arguments converted method forwards call protected object call returns nonprimitive value arguments bridge instead returned value returned caller object figure 9 presents bridge generated user class fileupdater shown figure 8 avoid exceptions leaking internal objects bridges catch exceptions thrown protected object generate bridge encapsulates exception throwing exception back caller code checks whether access protected object allowed performed static method checkaccess defined class space method takes space protected object well space caller input consults access matrix stored two dimensional array called authorizations deciding whether access granted code interposes bridge arguments call protected object present method getbridgeforarg whereas code interposes bridge returned value possessor bridge located inside method getbridgeforreturn methods defined inside class bridgefactory shown figure 10 notice methods handle several cases either argument respectively returned object bridge remotespace space instance user class bridge object protected bridge extracted appropriate bridge interposed protected object callee respectively caller public class bridgeinternal object protectedobj space protectedobjspace space callerspace initialize fields initialize object go space gospace space pspace figure 6 class bridgeinternal class space access matrix static boolean authorizations static boolean checkaccess space protectedobjspace space callerspace return figure 7 method checkaccess controls access bridge contains bridgeinternal object role object store information related state bridge ie protected object latters space space possessor class bridgeinternal shown figure 6 possible reserve field information inside user bridge class generic methods getbridgeforarg getbridgeforreturn need access information receive bridge argument returned object soot framework manipulating java bytecode 24 used generating bridge classes public class fileupdater public file concatfilesfile file1 file file2 throws filenotfoundexception throw new filenotfoundexceptionfile found return file1 figure 8 user class example 44 caveats java section looks detail implications object space implementation java programs partic ular several features language final classes methods incompatible implementation ap proach dealing issues means imposing restrictions classes objects referenced across space boundaries final private clauses important software engineering notions controlling visibility classes application object space implementation work class c object transfered bridge class bc generated subclasses c final classes thus cannot bridges generated current implementation bridge generator complains object passed whose class contains final clauses though public class fileupdaterbridge extends fileupdater implements bridge bridgeinternal new bridgeinternal fileupdaterbridge fileupdaterbridge object obj space protectedobjspace space callerspace biinitialize obj protectedobjspace callerspace bridgeinternal getbridgeinternalreturn bi public file concatfilesfile arg1 file arg2 throws filenotfoundexception bicallerspace try file file file returnedobjfileupdaterbiprotectedobj concatfiles arg1bridge arg2bridge return filebridgefactory catch filenotfoundexception e throw filenotfoundexceptionbridgefactory getbridgeforreturne bi catch throwable e throw runtimeexceptionbridgefactory getbridgeforreturne bi else throw new accessexceptionunauthorized call figure 9 example bridge class generated restriction apply javalangobject see low order handle final methods classes object space system loader could remove final modifiers class bridgefactory maps pair objecttoprotect callerspace bridge interposed map objandcallerspacetobridge static bridge getbridge object object space protectedobjspace space callerspace method first checks map already contains bridge interposed object callerspace returns bridge checks whether bridges class file exists class file exist method asks soot build one finally creates returns new instance bridge static object getbridgeforargobject arg bridgeinternal currentbi bridgeinternal call argument bridge object located space callee return direct reference object argbiprotectedobjspace currentbiprotectedobjspace return argbiprotectedobj call argument located another space get handle return bridgefactory argbiprotectedobjspace currentbiprotectedobjspace else arg instanceof remotespace required around remetospace return arg else arg instanceof space allow transfer space objects return new remotespacespacearg else call argument lives callers space get handle return bridgefactory currentbicallerspace currentbiprotectedobjspace idea getbridgeforarg time returned object protected caller static bridge getbridgeforreturn object returnedobj bridgeinternal currentbi figure class files linking prevent illegal subclassing loader must record final modifiers class already loaded verify classes loaded violate final constraints loader must also remove private modifiers classes bc rewriting approach used loaders javaseal 6 system remove catchs threaddeath exceptions since catching exceptions would allow applet ignore terminate signals parent rewriting approach work system classes loaded linked basic system loader system classes classes include javalang javautil javaio classes problem classes final eg javalangstring contain final methods cannot overridden class javalangobject must permitted since every class subclasses final methods class notifyall notify wait getclass methods cannot overridden invocation methods objects cannot controlled former three methods used thread synchronization however locking scope access control model issue fullyfledged protection domain model requires modification virtual machine case concerning method getclass program calls getclass bridge class gets class object bridged object ever constructor bridge class protected program nothing object special treatment also given system classes like string integer final classes java 2 implementation provides tailored versions classes represent strings integers exchanged across boundaries class iosstring instance simply wrapper around string object exchanged spaces reader may noticed class iosstring papers examples object space implementation also provides bridged class iosstring class contains copy wrapped string object iosstring used transfer value string across spaces set method api iosstring given second constructor takes string object allows space create iosstring string locally transmit string value another domain public class iosstring implements serializable protected string mystring public iosstring public iosstringstring public iosstring getstring public void setiosstring public void print lastly since string final cannot bridge defined bridge classes define tostring method return null order avoid direct references strings remote domains cases strings need exchanged convenience like exceptions instance user class define getmessage method returns iosstring field accesses access fields also form interobject communication must controlled security current implementation however yet cater solution would loader instrument bytecode instructions consult access matrix field access field accesses converted method calls former approach applied java 21 current implementation bridges access fields remote objects become access fields bridges fields reflect corresponding fields protected object static fields methods static methods pose two problems first cannot redefined subclasses sec ond objects referenced static variables could shared protection domains without access control check taking place fully fledged implementation protection domains classes shared domains 6 avoid undetected sharing domains object space implementation bridge generator signals error receives object user class contains static methods problem static variables looked 8 proposal strengthens isolation loader spaces keeping different copy objects referenced static variables copy class used loader unfor tunately cannot use solution object space implementation since classes shared across domains remote array figure 11 treatment arrays object space implementation arrays arrays java objects sense methods defined object executed array objects unfortunately array object sense element selection using method call requires special treatment approach outlined figure 11 whenever reference array object copied across space boundary ie bridge array copied locally copy even made array contains primitive types like int char implication approach method calls array objects traverse space boundaries array selection done locally effect copy value used array ob jects array entry modified one space without corresponding change another domain entries copied arrays objects become bridges already means nonarray objects always named using bridge object within space even though array objects may copied sharing arrays required programmer must furnish array class entry selectors methods solution interesting repercussion regarding example bug java cited section 232 signers object fact represented array identity signers object space model used implement copy signer array would returned caller whose modifications array would remain innocuous synchronization objects intricately influenced interposition bridges objects two objects located different spaces willing synchronize protected object would experience undesired behavior since implicitly performing operations two different bridges protecting protected object instead acting protected object problem arises synchronized statements used instead relying solutions exploit synchronized methods latter perfectly valid since bridges forward calls protected objects consequently locking occurs protected objects native methods also lead security flaws since could used leak object references spaces way control code current implementation java allow bridges classes possess native methods except objects methods eg hashcode 45 performance evaluation efficiency one goals object space model particular cost mediation interspace calls bridge generally inferior cost copybyvalue serialization example exchange byte array communication channel conducted performance measures implementation running sunos 56 333 mhz ultrasparciii processor using suns vm jdk121 measures obtained averaging large number iterations one basic measures taken compare cost method call protection domains using space bridge model loader java serialization model also made comparisons jkernel 25 latter allows domains exchange parameters either using java serialization mechanism using faster serialization tool developed jkernel passing capabilities jkernel capability object denotes object remote domain jkernels equivalent bridged object table shows comparisons method call parameters b method call string parameter c method call article object parameter article class used application section 32 consists hashtable files representing article contents well strings article attributes times shown microseconds estimated basic method call without arguments serialization around 5 nanoseconds crossdomain call without arguments faster approach jkernel basic call jkernels overhead mainly explained thread context switch performed crossing domains implementation overhead resides security policy check required crossdomain calls cost quite low since check reduces lookup access matrix implemented static two dimensional array stored class space even though accessing matrix fast tradeoff space required 2 number spaces present system mechanisms use copy passing parameters expected slower counterpart jkernel capability object space model scale well size arguments cost parameter passing object space model approximately two times slower passing parameters capabilities jkernel overhead comes dynamic creation lookup bridges model ever cost comes benefit model stricter controls access objects jkernel capability released environment possible control spread among domains whereas model selectively grant revoke access certain domains space serial jkernel serial fast copy capability c 25 3632 10042 5872 14 figures give estimate basic mechanism get general overview implemented article packager example section 32 using object space model java loader model space implementation described earlier loader implementation class loader object created load client article classes service classes storage editor loaded system loader communication channel object installed client service objects exchange serialized messages application highly interactive direct comparison obvious therefore compared two types com munication cost saving article stored within program disk cost sending event message gui editor client loader version time save small article approximately 5617 microseconds cost includes time serialize article space version figure slightly less 5520 micro seconds also article serialization since article must serialized saved disk figure includes creation bridge object article passed storage object time send message gui program 143 microseconds space implementation loader implementation figure around 1511 microseconds due serialization cost serialization reduced making classes objects exchanged sharable loaded system loader ever result weaken isolation greater scope aliasing domains regarding space usage bridge requires 4 words reference bridgeinternal object contains 3 words reference guarded object references guarded possessor spaces space object requires 3 words internal integer identifier reference parent space reference hashmap object containing children spaces pointer access matrix static shared space objects n spaces active system overhead space n 2 access matrix entries nm entries hashmap maintained bridgefactory maps object space pairs bridges denotes number objects space referenced objects spaces spaces contains objects maximum number bridges system represents case objects spaces referenced objects spaces measures taken installed bridge classes implementation bridge class generated fly class cannot found disk costly process instance bridge editor class takes around 367 seconds generate due parsing class file startup article packager application root service client spaces created necessitates creation 10 bridges takes around 624 seconds 5 related work section compares object space model related work divided java related work general work program security 51 java security java advanced security model includes protection domains whose design goal isolate applets basic mechanism used class loader applet java assigned class loader loads distinct private version class protection domain 17 java possesses property class one loader distinct type class loaded another loader typing therefore basis isolation since creating reference one loader space another signaled type error problem model dynamic typing violate property spaces reference classes loaded basic system loader shared loader spaces never reloaded system loader loads basic classes eg javalang sharing loader spaces en demic sharing enough lead aliasing loader spaces consider class password loaded two loader spaces j resulting class versions password password j class implements interface passwordid methods init value suppose interface passwordid loaded system loader case following program allows one password read value password object loader space uid 2 directly invoke password object space public final class password implements passwordid private int uid private passwordid sister private string password public static void mainstring args throws exception create two loader spaces myloader new myloader myloader new myloader root leaks references space child1init1 hth3tgh3 child2 child2init2 tr54ybb child1 public void initint string passwordid r public string value return password program starts creating two loaders class myloader loader reads files fixed directory delegates loading basic java classes passwordid interface parent system loader program creates instance password loader space asking loader load instantiate instance class program grants password reference despite fact domain distinct loader call value second password first succeeds loader spaces used implement protection domains several javabased systems eg 3 14 6 25 isolation obtained shared classes make leaks example object space approach model least guarantees ever reference object escapes leaked another space use reference nevertheless mediated security policy security policy prohibits calls spaces default access right space must explicitly granted grant undone subsequent revocation one advantage loader space model object space model former allows program control classes loaded protection domain important preventing code injection attacks malicious code inserted domain attempt steal corrupt data object space model parent force child space execute code foreseen program newinstance method however way control classes used particular space section 4 compared implementation object space model jkernel 25 recall protection domains jkernel made selected shared system classes user classes loaded domain loader well instances classes capability object used reference object remote domain call capability object transfers control called domain parameters call copied value unless capability objects copied directly comparison object space model jkernel uses copybyvalue default whereas object space model uses copybyreference jkernel must explicitly create capability object transfer reference object space model must explicitly serialize object copy value latter approach natural objectoriented choice access control based capabilities j kernel problem capabilities propagation cannot controlled domain exports capability one objects longer control domain receives copy capability revocation exists entails revoking copies capability meaning distribution access rights object must start scratch object space model owner grant revoke rights spaces selectively spaces another difference two systems presence hierarchy object space model absence multiple class loaders class instances goal javaseal kernel 6 isolate mobile agents host platform protection domain javaseal known seal also implemented using java loader mechanism set seals organized hierarchy message exchanged two seals routed via common parent seal suppress message security reasons fact experience programming newspaper application 19 javaseal first motivated object space model many objects environment variables article objects needed distributed several seals meant copybyvalue semantics found cumbersome mutable objects like key certificates article files wanted safe form object sharing simplify programming interesting similarities exist object space model memory management realtime java 5 latter scopedmemory objects act memory heaps temporary objects newly created realtime thread assigned scopedmemory alternatively threads enter context scopedmemory executing enter method memory object contains reference counter incremented time thread enters object created thread scopedmemory allocated memory object object scopedmemory may create scopedmemory objects thus introducing hi erarchy goal scoped memory model avoid use slow garbage collector remove objects reference counter scopedmemory object becomes 0 objects contains removed prevent dangling references object cannot hold reference object sibling scopedmemory jvm dynamically checks reference assignments verify constraint compared object space model approaches use hierarchy accesses spaces dynamically checked however access restrictions object space model dynamically modified accesses nonrelated spaces possible hand object space model deal resource termination 52 program security mechanisms much work integrating access control programs approaches annotate programs calls security policy checker 21 9 java instance 9 system class contains method call securitymanager object checks whether calling thread right pursue call another approach program security uses programming language support instance languages 13 18 include notion access rights programs possess rights objects access program object progress possesses access right language designers today tend equate security type correctness way security another good havior property program verified using static analysis dynamic checking 20 16 leroy rouaix use typing enforce security environments running applets 16 security context means applet cannot gain access certain objects private environment function objects accessible assigned specified set permitted values system type special versions define set permitted values instance may string classpath possible values appletpublic binjava conversion object entails verifying object respects permitted values environment functions available applets bridgelike sense incoming reference type cast similar object space model implementation java since class bridge class constructed contains code verify systems access control policy access permissions specified access matrix object space model rather permitted object values goal jflow 20 information flow security deals controlling attackers ability infer information object rather controlling access objects methods jflow extends java language associating security labels variables security label denotes sensitivity objects information jflow static analyzer ensures object transfer reference data object inferior security label would constitute leak complexity mechanism comes ensuring information objects used conditional expression evaluation implicitly leaked objects modified scope conditional expression comparison works object space implementation relies typing ensure object access made using secure version class ie one includes access control checks annotation classes checks could included check field accesses objects 21 mentioned section 4 related topic access control aliasing control eg confined types 4 balloons 1 islands 11 confined types recent effort control visibility kernel objects controlling visibility class names confined type class whose objects invisible specific user programs advantage approach confinement type verified compiler hand classes cannot confined nonconfined time important one designate objects class protected objects public instance visibility strings represent passwords must confined though class string general class accessible programs another problem aliasing control object visibility vary objects lifetime instance object given server must remain accessible server servers worktime server completed task object removed servers visibility server containment property 7 object space model controls access object basis visibility constraints dynamically altered 6 conclusions paper presented access control model objectoriented environment model api strongly influenced java loader spaces programming model though aims overcome weaknesses java access control caused aliasing evaluated proposition implementation java 2 though implementation advantage portability means cannot address resource control domain termination issues issues must treated object spaces become fullyfledged protection domains virtual machine support could also useful overcome limitations model java eg prohibition field accesses work around final modifiers results show interposition access control programs objects different domains efficient simple copybyvalue data loader spaces believe object space model natural object programming style copybyvalue especially objects need accessed many programs whose value change often eg environment vari ables model also advantage leak reference spaces innocuous receiving space explicitly granted right use space referenced object even access granted right may always removed acknowledgments authors grateful anonymous referees jan vitek valuable comments content presentation paper work support swiss national science foundation grant fnrs 205339998 r balloon types controlling sharing state data types java programming language confined types realtime specification java javaseal mobile agent ker nel protection hydra operating system application isolation java virtual chine inside java 2 platform security architecture islands aliasing protection objectoriented languages geneva convention treatment object alias ing language extension controlling access shared data security ajanta mobile agent system note confinement problem security properties typed ap plets dynamic class loading java virtual machine access control parallel programs commercialization electronic information jflow practical mostlystatic information flow control providing finegrained access control java programs protection information computer systems optimizing java bytecode using soot framework feasible tr islands geneva convention treatment object aliasing use name spaces plan 9 security properties typed applets dynamic class loading java virtual machine java programming language 2nd ed jflow inside java 2 platform security architecture api design implementation confined types commercialization electronic information application isolation java virtual machine note confinement problem jkernel realtime specification java providing finegrained access control java programs optimizing java bytecode using soot framework signing sealing guarding java objects javaseal mobile agent kernel protection hydra operating system ctr chris hawblitzel thorsten von eicken luna flexible java protection system proceedings 5th symposium operating systems design implementation due copyright restrictions able make pdfs conference available downloading december 0911 2002 boston massachusetts chris hawblitzel thorsten von eicken luna flexible java protection system acm sigops operating systems review v36 nsi winter 2002 laurent dayns grzegorz czajkowski lightweight flexible isolation languagebased extensible systems proceedings 28th international conference large data bases p718729 august 2023 2002 hong kong china grzegorz czajkowski laurent dayns multitasking without comprimise virtual machine evolution acm sigplan notices v36 n11 p125138 11012001 krzysztof palacz jan vitek grzegorz czajkowski laurent daynas incommunicado efficient communication isolates acm sigplan notices v37 n11 november 2002
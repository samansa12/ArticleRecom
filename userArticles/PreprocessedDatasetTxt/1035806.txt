randomized naming using waitfree shared variables naming protocol assigns unique names keys every process set communicating processes construct randomized waitfree naming protocol using waitfree atomic readwrite registers shared variables process intercommunication primitives process private register read others addressesnames one uses others possibly different processes ipi iqi address register process iri way known ini processes 0 protocol uses name space size 1 ini ioiini log ini log log ini running time readwrites shared bits probability least 1ioi1 ioiinilogsup2supini overall expected running time protocol based waitfree implementation novel testsetonce object randomly fast selects winner set iqi contenders probability least face strongest possible adaptive adversary b introduction naming protocol concurrently executed process subset n processes selects host process unique name common name space name space small preferably size n processes may may name start resulting variant naming problem called renaming problem distributed concurrent system distinct names useful sometimes mandatory variety situations including mutual exclusion resource allocation leader election choice coordination cases naming protocol put good use processes created terminated dynamicallya common occurrence distributed concurrent systemsthe name space may grow number processes remains bounded renaming procedure used size name space examples network protocols crash duplicate names perform efficiently small name ranges found 27 30 naming protocol also useful allocation identical resources name permit resource since algorithms waitfree see also highly faulttolerant managing assignment resources competing processes corresponds repetitive variant naming problem 7 sequel also write key name key range name space interprocess communication use interprocess communication shared memory allow arbitrarily initialized shared memory dirty memory model 23 shared memory primitives waitfree atomic readwrite registers 21 22 widely used theory distributed algorithms 16 deterministic protocol executed n processes waitfree finite function f every nonfaulty process terminates protocol executing number fn steps regardless processes execution speeds crash failures words waitfree solution 1resilient process crash failures randomized protocol waitfree fn upper bounds expectation number steps expectation taken randomized system executions worstcase adversary class adversaries considered results adaptive adversaries constructions use singlewriter multireader waitfree atomic registers constructed 29 22 used 8 9 19 also write shared variable register anonymous communication model every register written exactly one process read processesthis way writing process send messages processes processes use common index scheme processes registers initial consistent numbering among processes called 8 9 19 optimal naming trivial every process rank number among values choose ranknumber key make problem nontrivial every process private register read registers processes use possibly different index schemes processes p q address register owned process r possibly different way known may happen large dynamically changing systems consistency requirement difficult impossible maintain 23 cryptographical systems consistency avoided model cannot use consensus protocols 5 6 18 testandset implementation outlined 2 symmetric shared memory another way prevent trivial ranking using symmetric shared memory model shared memory symmetric consists set identical processes communicating pool shared variables read written 20 13 complexity measures computational complexity distributed deterministic algorithms using shared memory commonly expressed number type intercommunication primitives required maximum number sequential readwrites single process system execution local computation usually ignored use waitfree atomic readwrite registers primitives primitives must ultimately implemented waitfree singlereader singlewriter waitfree atomic readwrite bits turn implementable mathematical versions hardware flipflops 21 efficient implementations use 22 reduce multiuser multivalue register singlereader singlewriter multivalue registers 21 reduce latter singlereader singlewriter waitfree atomic readwrite bits standardize complexity make comparisons algorithms unambiguous express time space complexity terms readwrites elementary shared bits randomization algorithms executed process randomized process flip coins access random number generator randomized algorithms answers always correcteach process always gets unique keybut small probability protocol takes long time finish use customary assumption coin flip subsequent write shared memory separate atomic actions express computational complexity algorithms use worstcase complexity probability ii expected complexity system executions respect randomization processes worstcase scheduling strategy adaptive adversary previous work agreement problem deterministic model computation shared memory message passing unsolvable presence faults 15 17 24 sur prisingly 7 showed renaming problem requires nontrivial form interprocess agreement solvable message passing model solution tresilientup crash failures toleratedand uses name space size nt takes exponential time n protocol later transformed 8 two solutions asynchronous shared memory model waitfree achieve running times n key range sizes recently 10 demonstrated waitfree longlived shared memory implementation renaming k n processes using achieving key range size ok 2 deterministic waitfree solution asynchronous shared memory model key range size 2n gamma 1 necessary 19 results use asymmetric shared memory form singlewriter multi reader waitfree atomic readwrite registers step reads writes one register moreover global address register known plethora work naming problem using shared memory cited 23 20 13 discuss relevant paper 20 shown using bounded symmetric shared memory deterministic solution randomized waitfree solution adaptive adversary appendix impossible give waitfree randomized unbounded symmetric shared memory solution fair adaptive adversary key range size n logarithmic expected number roundstime units every process makes least one stepassuming log nbit registers show unbounded memory also necessary adaptive adversary also give olog n expected time solution key range size n fair oblivious adversary using shared memory consisting log nbit registers independently 13 gave randomized solution bounded symmetric memory model key range size n running expected 6 fair oblivious adversary using 4 shared atomic multiwriter multireader bits summarize asynchronous bounded shared memory deterministic waitfree solutions expensive terms achievable key range asymmetric case impossible symmetric case even allowing randomization assuming adaptive adversary remaining case treated results show randomization yield waitfree inexpensive solutions terms time space key range asynchronous asymmetric bounded shared memory models singlewriter multireader waitfree atomic shared registers use anonymous communication model processes initial names equivalently global consistent indexing processors construction requires several algorithms end give randomized waitfree naming algorithm assume adaptive adversary strongest adversary first algorithm implementation fftestsetonce object oneshot test andset guarantees among q n competing processes invoking unique winner probability ff ff parameter chosen arbitrarily close 1 object safe one process winner invoked q n processes uses olog q 1writer nreader shared bits per process running time log q readwrites bits properties shown theorem 1 applications typically n high probability using complex primitives object implemented using n copies 1writer nreader olog log q bit readwrite registers running time log q readwrites registers b single nwriter nreader 1writerpercomponent ncomponent composite register log log nbit components snapshot memory 4 1 running time olog q readwrites composite register second algorithm waitfree naming algorithm segment using fftestsetonce objects given ffl 0 segment uses name space size 1 ffln n number processes protocol always correct sense nonfaulty processes receive distinct names running time random variable whose value log n log log n bit operations high probability high probability mean probability running time exceeds value o1 quantity tends 0 n grows lemma 3 fact prove maximum running time among noncrashing processes log n log log n bit operations probability still possible expectation running time coin flip sequences infinite next theorem 2 shows minor modification proof similar lemma 3 demonstrates expected running time modified protocols involved processes bounded log 2 n hence segment waitfree paper organized follows section 2 appendix spell assumptions model computation appendix b shows simple approach doesnt work motivates introduction fftestsetonce object section 3 object used section 4 obtain naming protocol preliminaries sequentially executed finite programs bounded local variables communicating singlewriter multireader bounded waitfree atomic registers shared variables latter common model interprocess communication shared memory discussed briefly section 1 details see 21 22 use motivation distributed protocols see 8 9 19 21 shared registers anonymous communication atomicity every readwrite register owned one process owner register write processes read one step process either read value register ii write value one registers iii flip local coin invoke random number generator returns random bit followed local computation communication anonymous process private register read others addressname uses others possibly different processes p q address register process r way known require system atomic every step process thought take place indivisible instance time every indivisible time instance one step one process executed atomicity requirement induces actual system execution total orders set steps different processes set steps every individual process set readwrite operations executed individual register state system gives process contents program counter contents local variables contents owned shared registers since processes execute sequential programs state every process single step executed next steps enabled state adversary scheduling demon state decides enabled step executed next thus determines sequence steps system execution two main types adversaries oblivious adversary uses fixed schedule independent system execution much stronger adaptive adversary dynamically adapts schedule based past initial segment system execution results hold adaptive adversarythe strongest adaversary possible computational complexity randomized distributed algorithm adversarial setting corresponding notion waitfreeness require careful definitions distract reader delegated rigorous novel formulation adversaries restricted measures set system executions appendix believe interesting right useful elsewhere assume notions system execution waitfreeness adaptive adversary expected complexity familiar randomized distributed algorithm waitfree expected number readwrites shared memory every participating process bounded finite function fn n number processes expectation taken probability measure randomized system executions worstcase adaptive adversary 22 obvious strategy doesnt work appendix b analyze naming strategy first comes mind show doesnt work sense fn bounding expected number readwrites shared memory least exponential namely soon one process claiming key adversary make processes fail problem resolved testandset mechanism ensures winner among set claiming processes however existing constructions 2 require processes consistent numberingthe model anonymous pointed introduction would render naming problem trivial rank numbering choose rank key see also 8 9 19 resolve problem introduce probabilistic fftestsetonce object selects winner high probability doesnt require consistent initial numbering among processes 3 probabilistic fftestsetonce object fftestsetonce object shared n processes probabilistic waitfree object functionality every ff construct object concurrently invoked subset user processes selects winner probability ff q n processes competing object maximum number shared bit accesses performed process expectation log q typically q olog n expectation log log n object based following property geometric distribution 1 suppose 1 referee pointed collision resolution analysis distributed network algorithms 12 q random variables x identically geometrically distributed prx good probability unique maximum j 6 31 synchronous algorithm consider n processes numbered 1 n n theta 1 matrix n enter competition expressed initially setting 1p filling remainder zero entries game divided rounds k round every process still game independently flips identical coin probability success gamma 1 failure round k every process p kp coin p coin flip successful steps forward sets k1p round three mutuallyexclusive possible outcomes exactly one process steps forward others backoffthe process declared winner game ends ii processes backoff case game ends winner iii one process steps forward case game continues one two aforementioned events occurs let fq denote probability game ends winner initial number q competing processes exact behavior fq seems hard analyze fortunately next lemma gives easy proof statement good enough purposes define ii q 2 fq f2 proof suppose first coin flip k q initial processes step forward since number rows available game unbounded probability winner point exactly fk let x random variable denoting number processes step forward probability game ending winner recalling equation rewritten 11 14 3 papers apparently address different issues methods analyses ones presented probability exactly k q processes stepping forward next row given case two equations give implies first part lemma prove second part lemma induction base case f2 f2 trivial inductive step assume fk f2 2 k q using 1 2 follows induction hypothesis last inequality equivalent verified using 2 3 2 next lemma shows high probability game ends quickly winner probability winner within r rows least ns r proof let w r event winner within r rows 1 values q prthere prthere winner r rows process makes least r rows ns r important corollary lemma choosing r appropriately probability winner within olog q rows set arbitrarily close 1 words infinitely many rows needed simplify analysis want probability success need satisfy 2s ns r setting number rows needed would r 2ffl lognffl instance need r need 32 asynchronous implementation let entries matrix correspond state 1writer nreader bits let r rows r theta n matrix jth bit array written process j read processes definition 1 process steps forward row row k first sets private bit row k 1 reads bits row k 0 process said luckyatrow k even though asynchronous system process cannot determine whether reached certain row alone whether slower processes eventually reach row suffices determine whether lucky geometric distribution ensures process backedoff many rows say k log n high probability one left trivially luckyatrow k 1 k r necessary winner show lucky row r sufficient winner theorem 1 every fftasonce protocol implements fftestsetonce object selects unique winner among set invoking processes probability least never selects one winner object invoked repeatedly key assigned provided crashes occur object invoked q n processes invocation uses log q 1writer nreader atomic single bit registers worst case running time log q readwrites shared bits proof figure 1 process p owns array atomic bits denoted a1r pone bit row game ith row ai 1n one bit ai p owned process n initially line 1 figure 1 process checks whether object currently occupied processes trying grab key whether initial memory dirty possibly previous competition exits reporting failure way line 9 line 9 resets bits ai p 1 r owned process 0 clean possibly dirty memory future tries course needs done start process add line code effect lines 2 8 implement following algorithm determine lucky current row yes step forward probability 1 otherwise probability value processes process wins luckyatrow r otherwise fails show one process win hence protocol safe exiting reporting failure protocol cleans private bit row line 9 done make object reusable process wins crashes occur eventually every non faulty process gets name probabilistic point view immaterial whether coins flipped synchronously asynchronously coin flips independent rate processes back remains essentially unchanged key probabilistic analysis asynchronous process another main ingredient proof simple upper bound number lucky processes per row notice also process actually winner rowall processes backed offfrom step one row next probability 1 relevant properties protocol liveness every non faulty process executes protocol bounded number steps regardless processes speeds crash failures safety one process wins number rows olog q probability among q n competing processes winner ffa parameter set arbitrarily close 1 2 fftasonce waitfree uses 2nr r readwrites 1writer nreader shared bits proof process p invoking protocol either backs immediately executing joins competitition either win executing 2nr steps back lose executing 2nr remainder section consider system q n processes executing protocol figure 1 executions system crashes occur show case process gets keyand hence capturedwith probability ff set processes back execution let b jbj row number lucky processes b 1 one outside b proof process exit right away executing line 1 called competing process every row row 1 row r every still competing process p first sets arow p 1 executing writearow p 1 line 3 protocol subsequently 2 case crashes need bother estimate probability adversary forced sacrifice processes every invokation either process crashes one process wins game probability ff 1 given enough objects nonfaulty processes sooner later get key problem discussed make happen fast processes using objects possible fshared declarationsg param r int fnumber rows game olog qg param 0 var shared array boolean fa1r p owned process p g procedure invoking processg var var tmp1n array boolean begin 1 row startedmemory dirtyg od 2 row 0 fjoin gameg 4 fcheck contention row g 5 fif alone rowg else 7 row r goto l2 8 else goto l1l2 probability 9 l2 row 0 writearow p figure 1 protocol fftasonce q n processes p invoking process reads bits row executing loop line 4 suppose way contradiction two process p p 0 back luckyatrow row assume p executes writearow p 1 p 0 executes writearow p 0 1 since backing bits stay 1 order atomic events contradicts p 0 lucky arow time p 0 reads 2 consequently among processes back one lucky certain row processes back could lucky consider instance processes 3 standing row row suppose adversary freezes first two possible b 3 step ahead luckyatrow row eventually b 3 processes ahead b 1 b 2 back reinitialize bits zero line 9 protocol figure 1 afterwards b 2 could unfrozen adversary lucky row row later one process win proof process luckyatrow r backoff particular clean row bits line 9 protocol hence two lucky processes row r contradicts 2 2 consider set executions process crashes occur bits fftestsetonce object initialized correctly 0 success probability fftasonce q n invoking processes least ff 2s proof intuitively aim adversary prevent process winning bound probability adversary succeeds increasing power since assume crashes occur two ways adversary prevent win occurring either two processes reach row r processes back prior row r make two copies game allow adversary play consider two objects invoked number processes one game adversary try maximize probability first two spoiling events occurs tries maximize probability second spoiling event adversary succeeds wins least one two games clearly upper bound probability succeeds playing one game consider first case focus subset c processes backoff adversary bring one process p row r probability 1 probability another process p 0 2 c reaches row r processes c reach row r definition claim 2 row one process c lucky therefore p 0 reaches row r sequence coin tosses bring process p 1 row 1 row 2 another process p 2 row 2 row 3 processes might different case probability consecutive successes r hence probability adversary spoils game case prsome reaches row r reaches row reaches row consider case since assume crashes occur participating processes must toss coins either back reach row r long takes immaterial coin flips independent since interested probability back row r disadvantageous adversary processes stepping forward probability 1 indeed probability 1 events increase number forward steps processes hence probability winner bounded synchronous game namely ns r 2 setting r log q theorem proven 2 analysis uses 1writer nreader 1bit registers intercommunication primitives course use complex primitives complexity figures decrease corollary 1 every implementation fftestsetonce object succeeds probability least ff invoked q n processes uses n copies 1writer nreader olog log qbit shared readwrite variables running time log q readwrites shared bits proof replace array a1r p fftasonce single olog log qbit variable used counter counts log q modify protocol obvious way implementation would imply slightly higher running time measured accesses 1writer 1reader shared bits advantage fftasonce point view space complexity shared variables implemented using 1writer 1reader shared bits 22 29 31 2 4 notion composite register snapshot object constructed multiuser waitfree atomic readwrite registers composite register useful obtain snap shot states set shared variables system waitfree readwrite register r written process without changing process atomically read r atomic linearly ordered definition read process gives snapshot contents shared variables r corollary 2 every implementation fftestsetonce object succeeds probability least ff q n processes uses single nwriter nreader 1writerpercomponent ncomponent composite register log log nbit components running time olog q readwrites composite register proof array counters previous corollary replaced composite register aka snapshot object defined 4 1 improves complexity figures would simplify protocol given availability snapshot object implementation 2 4 waitfree naming protocol base waitfree randomized naming protocol fftestsetonce object competing processes key space consists fftestsetonce objects one key param n int fnumber processesg param ffl real fspecify keyrange g f segment size l bc delta log ncg procedure var start begin start l bstartl cl fbeginning segment g repeat fphase 1 try get key within segmentg succeed fftasonce key succeed 0 fphase 2 linear searchg succeed fftasonce key od figure 2 protocol segment process p 41 simple hard analyze strategy first glance simple strategy appendix b may suffice process repeatedly invokes object selected uniformly random succeeds getting key process get key average expect ffm objects fire correctly sense assign key one invoking processes choosing nfffi take care random fluctuations ensure every process eventually gets key running time simple strategy seems hard analyze point time set processes still vying key matched set available objects keys number available objects determines probability getting key randomly selected object must least available turn probability determines number rounds needed slowest process gets key problem number empty objects given round depends adversary processes stopped let go occupy object clear us frame possible adversarial strategies 42 trickier easy analyze strategy segment imposing little bit structure way objects invoked possible come simple efficient protocol segment amenable clean analysis set ff reliability fftestsetonce object fi parameter take care random fluctuations show fi therefore setting taken arbitrarily small must fixed divide key space segments length l c constant specified later ln denotes natural logarithm think segment ring objects ith il th objects segment protocol shown figure 2 follows process selects random key start automatically determines segment whose initial position denote l processes start invoking keys walking around segment process first try get key invoking fftestsetonce object corresponding first random choice start necessary invoke next modulo l object ring gets back starting point start shall see high probability every process get key reaching point extremely unlikely event process find key segment whole key range scanned repeatedly key found phase 2 protocol ensure processes eventually get name lemma 3 every solves naming problem n using fftestsetonce objects protocol safe correct running time log n log log n readwrites 1writer nreader shared atomic bits proof show high probability processes segment captured find key crash inside segment therefore every fftestsetonce object invoked ol times high probability well consequently apply theorem 1 q olog n nonfaulty processes means find key within segment first show processes distribute evenly among segments let segment prprocess p selects l prprocess p selects since segments chosen independently invoke chernoffbounds estimate tails binomial distribution following form see example setting c ensure probability segment receives 1 ffl processes also need ensure every segment captures processes need take care adversary basically problem follows whenever object invoked adversary may may crash process object invocation happens say object corrupt consider case one process walks around whole segment without finding key happens objects segment invoked number corrupt objects l gamma amany noncorrupt objects succeeds probability ff independently objects words considering l gamma bernoulli trials probability success equal ff success means invoking processes given key notice small values l gamma large deviations mean likely therefore advantageous adversary crash processes thereby corrupting objects hope segments capture processes aim ensure segments capture processes show appropriate choice constant c almost surely never happens notation recalling definition captured expected number captured processes least least corrupt object adversary must crash least one process chernoff bounds true number captured processes least probability least know high probability segment p processes straightforward computation shows p every 0 long left verify matter chosen adversary segments capture processes high probability end notice p therefore implies probability segment fails capture processes bound independent adversary straightforward computation shows exceptional probability 2n 2 provided since ml n segments probability segment fails together equation 5 gives probability process finds key within olog n object invocations similarly every object invoked ol times probability theorem 1 every object invocation running time olog log n readswrites 1writer nreader 1bit atomic registers probability protocol safe every process obtain distinct key every circum stance process fails find key segment scans whole key space key found saw section 3 fftestsetonce objects safe never give key one process since objects processes noncorrupt objects invoked repeatedly assign key sooner later every correct process find key probability 1 lemma proven 2 proved maximum running time among noncrashing processes log n log log n bit operations probability imply average running time coin flip sequences outcomes used processes involved expected running time log n log log n bit operationsthe expected running time may still infinite expectation bounded meet definition wait freeness protocol achieve bounded expected running time required waitfreeness protocol need use log n bit operations per object invocation rather log log n see problem recall theorem 1 states object succeeds probability ff provided log q bits used q number competing processes thetan log n bits must used otherwise bound given lemma 2 becomes worthless although unlikely event entirely possible linearly many processes fail segment start scanning whole key space cases average running time high would take exponentially long time scanning processes gets key willing use log n bits per fftestsetonce object average running time still log 2 n bit operations theorem 2 every solves naming problem using fftestsetonce objects protocol waitfree safe correct expected running time log 2 n readwrites 1writer nreader shared atomic bits proof saw proof lemma 3 probability process resort scanning whole key space o1 denote total number corrupt keys time process scanned whole space corrupt objects firing independently probability ff probability least bound independent least 1 object assigned key implying gamma correct processes receives unique key define p kn fffflkn3g probability p 2n second scan needed average running time bit operations log 2 n1 clear together claim 3 claim 1 imply protocol segment waitfree solution process naming problem even average sense theorem proven 2 remark 1 practice protocol much faster keys expected number processes per object first random object selected mn 1 also large fraction processes need one invocation get wellknown results martingale inequalities state n processes select random key keys fraction keys chosen process nearly hence high probability nearly ffn1 gamma 1e processes get key one invocation fftestsetonce object results hold implement fftestsetonce object 1writer n reader olog log nbit shared readwrite variables nwriter nreader 1writerpercomponent ncomponent composite registers log log nbit components acknowledgment thank referees constructive comments resulted substantial improvement presentation system execution adversary computational complexity system execution infinite sequence alternating steps states c satisfying enabled state c igamma1 c configuration system execution 0 technically process halts enters infinitely many times distinguished idle state c 1 idle step 1 registers initialized zero contents unique start state c 0 initialize dirty shared memory registers arbitrary initial contents set system executions denoted omegagamma adversary best explained identifying conditional probability density function c je initial segment e step enabled state c igamma1 c state resulting executing step state c igamma1 probability initial execution segment realized given e igamma1 happened adversary randomized cs asc je summation taken different enabled steps state c igamma1 states c result step single state randomized states randomized step coin flip adversary deterministic chooses deterministically step cs asc je starting e 0 c 0 adversary induces measure legal system executions defined ae lim i1 adversary adaptive since schedules process executing next step based complete knowledge initial segment system execution including random outcomes past coin flips arbitrarily delay processes even crash executing enabled steps particular processes express strongest adversary adaptive infinite computing power probability measure set executions 32 without loss generality assume randomized steps protocols use fair coin flips assume notation adaptive adversary probability measure 1 initial execution segment 2 summation enabled steps state c c resulting executing step state c 3 coinflip step c h state resulting c outcome heads c state resulting c outcome tails denoting finite initial segment execution andomega set infinite executions e traditional notation instead ae cylinder g use first two conditionsalready implied notion probability measureare included completeness third condition ensures adversary control outcome fair coin flip outcomes equally likely definition readily generalized biased coins multibranch decisions adversaries de fined define expected length ee process p j final execution following finite initial execution segment e let e infinite execution starting number nonidle steps process definition 3 assume notation define since summation includes case expected length infinite necessarily set infinite histories operation execution infinitely many events positive measure normalization wrt e gives adversary free choice starting configuration running time deterministic protocol maximum number nonidle steps taken legal executions executed non faulty process definition 4 implementation concurrent object shared n processes wait free finite bound fn adversaries expected length ee approach work related observation made respect symmetric communication model 13 case use method bounded differences mobd 25 suppose n independent random variables x taking values finite set let measurable function vectors b differing ith coordinate use ballandbin scenario x denotes bin ends measure things number bins exactly k balls number bins least k balls like cases easy see c bound becomes n processes name space size 1 naming algorithm good want c running time small possible param n int fnumber processesg param c real 2 0 fspecifies key rangeg var shared int shared array boolean feach b1m p owned process pg procedure begin readbkey i1 writebkey p 0 returnfailure fi fnot aloneg od procedure simpname int 2 f0mg begin repeat key random 2 f1mg figure 3 simple approach naming protocol process p obvious naming algorithm works follows process chooses uniformly independently tentative random key checks whether process claiming key process secures key otherwise tries another random key check whether process claimant key use following mechanism key k vector bk 1n bit bk p owned process p 1 p n bits read processes upon choosing specific key value k process sets bit bk p 1 subsequently reads bits vector see whether claimant figure 3 process alone success returned otherwise failure notice bit bk p reset 0 case failure process try easy verify solution safe sense two processes ever get key difficult see running time unsatisfactory c 1 adversarial strategies force process take exponentially many steps high probability problem adversary knows key k chosen process p executes subsequent writebk p 1 step therefore adversary postpone execution step process q chooses key k point adversary schedules steps p q dont secure key k adversarial strategy step writebkey p 1 enabled process p adversary delays execution say p frozen p chosen k yet executed writebk p 1 say process claiming k let c adversary schedules processes turn perform first random choices define event least ffln keys chosen exactly two processes standard application mobd shows probability occur e gammac 1 n c 1 constant depending ffl adversary selects ffln keys freezes set f 1 corresponding processes adversary schedules operations remaining processes claims one remaining keys key claimed one process one process claims one keys adversary schedules events one back try unique claimants keys point least 1 gamma claimed unique process call red keys processes f 1 unfrozen adversary schedules operations first attempt fails second tentative random key choice define event b ffln red keys claimed exactly one process f 1 let f 2 set processes claiming keys key claimed exactly two processes jf adversary repeat scenario f 2 substituted f 1 tedious standard application mobd shows probability b occur e gammac 2 n c 2 constant depending ffl therefore high probability adversary able force process try exponential number keys r atomic snapshots shared memory elections anonymous networks distributed computing 6 fast randomized consensus using shared memory randomized consensus expected log 2 n operations per processor renaming asynchronous environment tree algorithms packet broadcast channels free synchronous access packets broadcast channel feedback estimating multiplicities conflicts speed resolution multiple access channels impossibility distributed consensus one faulty processor distributed algorithms acm trans randomized waitfree concurrent objects asynchronous computability theorem tresilient tasks lasvegas processor problem unique distributed computing share concurrent waitfree variables solving processor identity problem space memory requirements agreement among unreliable asynchronous processes method bounded differences randomized algorithms choice coordination problem optimal time randomized consensus making resilient algorithms fast practice elusive atomic register revisited computer networks construct atomic variable randomized waitfree testandset tr sharedmemory vs messagepassing asynchronous distributed environment renaming asynchronous environment fast randomized consensus using shared memory processor identity problem waitfree synchronization randomized waitfree concurrent objects extended abstract optimal time randomized consensusmyampersandmdashmaking resilient algorithms fast practice atomic snapshots shared memory immediate atomic snapshots fast renaming asynchronous computability theorem italictitalicresilient tasks elusive atomic register randomized algorithms impossibility distributed consensus one faulty process longlived renaming made fast share concurrent waitfree variables distributed algorithms computer networks construct atomic variable extended abstract waitfree testandset extended abstract ctr harry buhrman alessandro panconesi riccardo silvestri paul vitanyi importance identity consensus really universal distributed computing v18 n3 p167176 february 2006 james aspnes faith ellen fich eric ruppert relationships broadcast shared memory reliable anonymous distributed systems distributed computing v18 n3 p209219 february 2006 john tromp paul vitnyi randomized twoprocess waitfree testandset distributed computing v15 n3 p127135 july 2002
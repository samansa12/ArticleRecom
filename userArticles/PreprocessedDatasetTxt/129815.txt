controlflow normalization algorithm complexity single method normalizing controlflow programs facilitate program transformations program analysis automatic parallelization presented previous methods result programs whose control flowgraphs reducible programs normalized technique satisfy stronger condition reducibility therefore simpler syntax structure previous methods particular controlflow cycles normalized singleentry singleexit loops gotos eliminated furthermore method avoids problems code replication characteristic nodesplitting techniques restructuring obviates control dependence graph since afterwards control dependence relations manifest syntax tree program transformations effect normalization presented complexity method studied b introduction problem considering normalization controlflow programs goal facilitating program transformations program work supported part national science foundation grant nsf mip8410110 us department energy grant defg02 85er25001 office naval research grant onr n0001488k0686 us air force office scientific research grant afosrf4962086c 0136 donation ibm corporation analysis automatic parallelization several ways technique makes processes easier first reduces number syntactic constructions must treated system analysis transformation lessens complexity many compilation algorithms often driven structure program program structure highly regular number cases conditions must considered analyze parallelize program simply decreased second converts controlflow cycles singleentry singleexit loops eliminates branching instructions may dramatic consequences compilation example loops contain exit branches difficult parallelize since number iterations perform unknown prior execution likewise gotos may used create cycles controlflow hidden loops may cause loss parallelism loops describe missed techniques parallelization apply loops also controlflow loops sometimes entire subroutines may disturbed cycles similarly use gotos makes program transformations analyses difficult inefficient general reason simple compositionality controlflow lost terms semantics may say absence gotos direct semantics may given whereas presence continuation semantics needed increased complexity continuation semantics translated increased complexity program analysis models semantics eg abstract interpretation dataflow analysis third technique obviates control dependence graph much effort spent traditional parallelizing compilers treatment control dependences 3 argue controlflow program properly normalized control dependence relations manifest syntax tree normalized program need separate representation dependences similarly method makes unnecessary perform interval analysis part dataflow analysis normalization internal structure program obvious trivial may therefore used simplify implementation dataflow analysis since pathological flowgraphs 38 exist unnormalized programs may arise several ways first unstructured programs written languages common lisp fortran pascal c second compiler may produce unstructured code applies classical program transformations tail recursion elimination 14 example see figures 1 2 transformations recursion splitting 22 result even complex output tail recursion elimination wish compiler work always normalized program may apply normalization following transformations lot work done normalization controlflow programs 10 47 12 5 techniques result programs reducible defun f lambda begin cond null x f car x figure 1 sample recursive lisp program defun f lambda begin 1 cond null x set r go 2 2 return r figure 2 tail recursion elimination control flowgraphs however method normalization presented results programs highly regular produced methods words condition much stronger reducibility satisfied control flowgraphs result method furthermore previous methods controlflow normalization result excessive code replication show code replication necessary method elimination irreducibility condition rare even unstructured programs 2 presentation normalization method normalization works transforming program system simultaneous equations whose unknowns represent continuations associated program labels solution system equations normalized form program effect detect loops eliminate pathological syntactic constructions program contains williams ossher 47 proved elimination necessary sufficient obtain structured form program theorem bohm jacopini 13 says may transform program another one following three control structures used assignment conditional ffl iteration however theorem constructive give method deriving program technique presented exactly simple efficient way normalizing controlflow program consists transforming program another equivalent one three foregoing control structures used input language treat lisplike syntax includes branching instructions gotos labels toplevel procedures applied method fortran 77 lelisp 16 6 applying common lisp c 25 output language contains singleentry singleexit loops neither gotos labels represents normalized form program 21 denotational semantics semantics programming language precise mathematical specification meaning programs language 42 45 40 idea approach define functions map syntactic constructs algebraic ones method based scott stracheys work used define languages like algol 60 31 pascal 45 clu 39 input language contains branching instructions simple jumps make semantics programs complex lose compositionality semantics commands must switch direct semantics semantics continuations theory continuations developed c wadsworth l morris independently notion originated tail function mazurkiewicz 30 211 continuations continuations powerful tool allow us give straightforward meaning branches exceptions errors allow us regain degree compositionality lose branches continuation instruction function applied store gives final result program execution begins instruction result new store state memory usually continuations associated point program approach point represent program label author provides interested reader denotational semantics continuations primitive expressions language 7 8 language described following section 22 abstract cste 2 cste constants commands expressions lambda 2 proc lambda expressions cmd unop unary operator gamma biop binary operator purpose simplicity grammar includes scalar variables normalization method presenting applied fortran lisp programs 6 24 means restricted treatment scalar data require restrictions upon side effects aliasing 23 continuation equations procedure p may give syntactic representation continuation associated program label call x figure 3 illustrates sample lisp program obtain program system continuations equations figure 4 x 0 source continuation contains solution system resolution x 1 x 2 x 3 x 4 continuations associated labels 1 2 3 4 respectively unknowns system control structures used systems three proposed bohm jacopini 13 solution system represent normalized form procedure next section present method choose solve system 24 gaussian eliminationlike resolution straightforward gaussian eliminationlike resolution method may used solve system continuation equations method yields solution defun h lambda j begin 2 10 go 3 1 set j 1 4 set j k 3 figure 3 sample lisp program figure 4 continuation equations program figure 3 number equations unknowns solution presenting refinement method see later paper refinement improves complexity considerably gaussian elimination method consists substitution elimination unknown appears system want satisfy two criteria first minimize code size accomplished factorization second convert every controlflow cycle loop accomplished derecursivation solving system style gaussian elimination performing transformations along way gives normalized form program 25 transformations look continuation equations built may remark contain branches regular structure general equation following form true false parts statement may contain state ments statement may absent altogether let us present transformations use solve system 251 precalculation effect subtransformation useful transformations presented rest paper puts boolean expression conditional statement new temporary variable temporary defined program example following statement become precalculation pred 1 exp pred 1 begin cmd 1 252 distribution like precalculation subtransformation useful transformations presented rest paper rewrites statement containing continuation variables sequence two statements first contains condition captured temporary variable precalculation second one contains continuation variables controlled temporary variable condition saved temporary variable avoid multiple computations also guarantee correct result since arguments may affected cmd example let us consider equation x distribution equation pred 1 exp pred 1 begin cmd 1 pred 1 x 253 factorization one unknown may appear several times single equation avoid increasing code size elimination process factor equation two different factorization may used factor unknown factorization boolean expressions factorization selector variables factorization boolean expressions consists assembling conditionals boolean expressions governing one unknown using distribution replacing equation one unknown appears consider continuation equation whose form x j guarded boolean expression exp true rewrite equation pred 1 exp pred 1 cmd 1 cmd 2 pred 1 pred 1 equivalent pred 1 exp pred 1 cmd 1 cmd 2 add another nesting level another unknown x k begin exp 2 begin cmd 3 x j x j guarded exp 1 exp 1 exp 2 x k guarded rewrite equation pred 1 pred 1 begin set pred 2 exp 2 pred 2 begin cmd 3 pred 1 build selection tree pred 1 order unknowns appearing inside x increasing order number appearances case x k appears inside x x j appears twice thus x k treated first selection tree case number appearances unknowns taken order appearance inside equation heuristic order allows us create boolean expressions manageable size case several nesting levels factorization selector expressions consists replacing unknown assignment selector variable single integer value associated unknown case statement added sends control appropriate continuation consider continuation equation add variable selector assign value unknown equation x j replaced set selector 1 rewrite equation begin cmd 2 set selector 1 selector 1 x j add another nesting level another unknown x k begin exp 2 begin cmd 3 x j rewrite equation using selector variable follows begin exp 2 begin cmd 2 set selector 2 begin cmd 3 set selector 1 selector1 x j selector 2x k course order place unknowns selection tree irrelevant since guard case simply test value selector compare two methods measure respective cost run experiment normalizes scientific computations perfect club 34 see figures 24 25 section 5 254 derecursivation derecursivation like 1 hechts transformation 20 consists making loop explicit selfrecursive equation form intuitively equation loop whose entry instruction labeled x whose condition iteration condition leads x case iterate loop exp becomes false case perform begin form associated false part fixed point equation begin cmd set pred 1 exp pred 1 cmd 1 cmd 2 pred 1 semantics statement iterate begin form contained inside form pred 1 false semantics repeat therefore supposes loop body performed least consider equation another level nesting begin exp 2 begin cmd 3 x k must study boolean expressions guarding continuation inside equation x j guarded exp 1 x k guarded finally x guarded exp 1 exp 2 latter condition represents exit condition loop induced continuation pred 1 pred 1 cmd 2 begin set pred 2 pred 2 cmd 3 cmd 4 pred 1 pred 2 pred 1 x j begin pred 2 x k 255 substitution elimination 0 consists substituting unknown continuations system eliminating equation system however hecht 20 performs 2 unknowns single use system 0 transformation constrained condition since replaces unknown anywhere appears system ie unknown may replaced several different 2 performed checked unknown eliminating nonrecursive case derecursivated first equations appears factorized avoid several substitutions unknown single equation system figure 5 elimination x 2 system figure 4 substitution x j x elimination system obtain following equivalent system begin cmd 3 x k application 0 transformation reduces number n unknowns system n gamma 1 26 example resolution system continuation equations resulting program figure 3 presented figure 4 solve system use transformations presented may begin resolution eliminating x 2 appears equation x 0 x 4 equivalent system elimination figure 5 next step may eliminate x 1 resulting system equivalent system figure 6 since x 4 recursive want apply derecursivation transformation create corresponding loop elimination transformation replace eliminate unknown system resultant systems figure 7 figure 8 respectively point x 3 appears twice x 0 need factor x 0 resultant system shown figure 9 finally substitution elimination x 3 obtain normalized form figure 10 27 structure original program build continuation equations attempt preserve much possible original structure program say input procedure contains control constructs already normalized normalized mean neither branching instructions leaving construct branching instructions entering construct preserved normalized figure 11 loop already normalized associated figure elimination x 1 system figure 5 pred 1 10 pred 1 pred 1 figure 7 derecursivation x 4 system figure 6 begin begin set j k set pred 1 10 pred 1 pred 1 x 3 figure 8 elimination x 4 system figure 7 pred 2 10 pred 2 begin set j k set pred 1 10 pred 1 pred 1 figure 9 factorization x 0 system figure 8 defun h lambda j begin pred 2 10 pred 2 begin begin pred 1 10 pred 1 pred 1 figure 10 normalized form program figure 3 continuation equations system figure 12 treated assignment statement look program figure 13 loop exit inside case loop first rewritten terms gotos ifs shown figure 14 converted normalized form 3 order resolution system figure 4 eliminated unknowns arbitrary order easy see quality normalized form program terms code size depends upon order unknowns eliminated system give idea importance order let us take previous system equations figure 4 try eliminate unknowns different order let us choose following order resolution system elimination x 1 figure 15 variable x 3 x 4 occur equation x 2 elimination x 4 leads equivalent system figure 16 x 2 recursive derecursivation substitution obtain system figure 17 finally elimination x 3 obtain normalized program figure 18 course programs figures 10 semantically equivalent second one contain replicated code body loop restrained strictly code dependent upon ie code inside loop body need defun f lambda j b n begin 1 set 1 begin set b j figure 11 program containing normalized control structure figure 12 continuation equations system program figure 11 defun g lambda j b n begin 1 set 1 begin set b j 2 set b j 1 figure 13 program containing nonnormalized control structure defun g lambda j b n begin 1 set 1 g n go g 1 2 set b j 1 figure 14 equivalent form program figure 13 figure 15 elimination x 1 system figure 4 figure elimination x 4 system figure 15 begin set pred 1 10 pred 1 pred 1 x 3 figure 17 elimination x 2 system figure defun h lambda j begin begin pred 1 10 pred 1 pred 1 figure normalized form program figure 3 observe order resolution important impact running time resolution process code replication order resolution propose follows first sort extended topological order nodes graph associated equations second move loop headers order appear unknowns representing bodies note algorithm slightly different classical method interval analysis normalization method makes use strongly connected component topological sort acyclic continuations flowgraph solve system continuations next sections describe elimination order unknowns 31 graph topological sort graph e associated system equations represents control flowgraph program defined taking nodes unknowns system creating edge unknown x j appears inside equation x jn number nodes edges example graph associated system equations figure 4 figure 19 topological ordering nodes graph labeling nodes integers course graph must acyclic ordering meaningful since general input graphs contain cycles order nodes first eliminating back cross edges graph sorting resulting graph topological order call extended topological sort graph visiting graph nodes depthfirst order complexity combined algorithm kept figure 19 x 2 single loop header body consists unknowns x 1 x 4 extended topological order next step figure 19 graph associated system figure 4 reorder loop headers x 2 must appear x 1 x 4 two unknowns body order resolution used previous example follows order 32 algorithm find order resolution input list h loop headers list b h labels body loop header h list l unknowns ordered extended topological order output ordered list unknowns unknown x l ffl delete x l insert immediately unknowns constituting body loop designated x unknowns given b x 33 algorithm resolution system input ordered list unknowns l output source label whose equation represents normalized form program 1 select first unknown x l 2 x selfrecursive ffl derecursivate x apply x j x element unknown set ffl factorize occurrences x x j ffl substitute x x j apply 0 3 l nonempty goto 1 34 example let us consider irreducible program figure 20 give details transformations performed continuation equations system present system figure 21 associated continuation graph figure two nested loops graph whose headers order resolution normalized form relative order figure 23 defun g lambda j x begin 1 2 set x 3 set 1 x begin x go 5 4 set j 1 5 set j 2 figure 20 irreducible program figure 21 continuation equations program figure 20 figure 22 continuation graph system figure 21 defun g lambda j x begin begin pred 1 0 pred 1 begin pred 2 x pred 2 begin set pred 3 x j pred 2 pred 3 pred 1 pred 2 pred 3 pred 2 pred 1 pred 3 figure 23 normalized form irreducible program figure 20 4 complexity section analyze complexity normalization method counting number transformations necessary solve system continuations equations complete time space complexity study would involve us details data structures beyond scope paper however analysis reveals important aspects complexity normalization algorithm extended complete one considering cost applying individual transformations chosen representation program let system continuation equations e graph associated 2 n let jn represents set nodes entering node alternatively set unknowns whose equation appears dj degree multiplicity edge j ie number times appears equation j n total number substitutions performed resolution pro cess n f represents number factorizations n number derecur sivations 41 number substitutions show number substitutions performed resolution exceed number unknowns n system case g reducible theorem 1 g reducible equation substituted system proof let means appears least equation k want substitute unknown system seen algorithm substitution equation k k factorized occurs equation k several cases may appear substituted system case appears several equations system may inside loop whose header h may represent header loop 1 finally may neither two cases let source node graph case 1 simplest case several predecessors neither loop header inside loop accordance resolution order chosen predecessors treated come substitute appear equation nearest dominator h 2 factorization h appear h substituted case 2 loop whose header h h distinct case order chosen fact g reducible predecessors loop except treated come substitute appear equation h fact h dominates factorization h appear system therefore replaced substitution case 3 loop header according resolution order described earlier treat every node inside loop header let h header innermost loop containing loop loop treat therefore selfrecursive variable appears reducible every controlflow cycle g unique loop header dominates every node body loop also equation h derecursivation factorization h substituted system since n equations system nin irreducible graph method may replicate code worst case without preliminary factorization number substitutions unknown bounded number predecessors theorem 2 g irreducible unknown substituted n times proof first step elimination first unknown substituted worst case times second time substituted ngamma2 times since first substitution one unknown definitely eliminated system eliminate unknowns number substitution note bound conservative assumes control flowgraph program clique 42 number factorizations look algorithm resolution section 33 see factorization applied predecessor x j x substituting x factorization course unnecessary x occurs equation must noted applying one single step factorization x j effect reducing instances occurrences x j one degree edge x j every occurrence x j 1 number instances variable inside equation bounded n single factorization step able reduce instances one worst case factorization necessary every substitution therefore n f n 43 number derecursivations derecursivation performed every time node occurrence number derecursivation depends upon number loop headers entire graph worst case every node graph loop header conservative bound summary number transformations performed case reducible flowgraph order number continuation equations system course study complexity take account size continuation equations time necessary substitu tion find within equation unknown substitute factorization cost collecting simplifying boolean conditions 5 application normalization process normalization method presented put several uses projects author involved paf 44 miprac 24 paf experimental fortran parallelizer developed university paris 6 france paf normalization method two applications first convert every cycle explicit implicit loops transformed loops whenever possible 9 finally doall loops dependences permit words even programmer writes loops using gotos writes unstructured loops made eligible parallelization normalization second purpose vectorization order vectorize statements conditionally executed loop one must attach boolean variables mode vectors statements 29 48 17 32 controlflow normalization may accomplish easily program miprac multilingual compiler shared memory machines implemented university illinois applications normalization method much ambitious first allows us write genuinely multilingual compiler miprac accepts programs common lisp c scheme fortran together four languages contain many control structures dolist dotime loop cond block return break case switch exit goto continue pause normalization three controlstructures remain begin moreover intermediate form properly structured words multilinguality miprac means programs various languages simple structured representation mipracs intermediate form accomplished normalization second application simplify program analysis effect normalization allows programs require continuation semantics gotos converted programs may given direct semantics ex ample program gotos might meaning function type normalization program would meaning function type store store simplification shows write analysis program well whereas abstract interpretation unnormalized program might function type store abstraction memory abstract interpretation normalized program could function store makes analysis simpler implement efficient reader may contrast interprocedural analysis continuations used 22 direct semantics applied programs whose procedures bodies normalized 23 third application simplify program transformations restructuring expression need concerned branches middle middle expression control flows expression orderly way reader may look harrisons work 21 see difficulties may encounter program transformations exitloop parallelization recursion splitting 22 performed code structured controlflow normalization effectively make loop transformations applicable iterative structures replacing arbitrary controlflow cycles singleentry singleexit loops reducing number different syntactic structures program points normalization quite different program points program text known user problem fairly easily solved observing expression normalized program comes exactly one expression source map transformed program original source welldefined maintained stated section 253 compared running experiments perfect code factorization using boolean expressions selector expres sions measured number boolean expressions selector expressions generated code replication results without factorization see figures 24 25 column ebn gives number expressions present program normalization column eanf gives number expressions program normalization factorization column bexp gives number boolean expressions added factorization column sexp gives number selector expressions selector expression assignment selector variable added factorization column bexpeanf gives ratio counts likewise ratio sexpeanf column ean gives number expressions program normalization without represents growth code factorization performed ebn growth code normalized factorization note factorization used neither boolean selector expressions added program normal ization factorization boolean expressions requires every predicate guarding conditional statement stored temporary variable see transformation distribution temporary variables necessary factorization selector expressions performed reason ebn code different value factorization performed using selector expressions versus using boolean expressions average ratio boolean expressions bexp created total number expressions program eanf 001 average ratio selector expressions sexp created total number expressions program eanf 0004 compare gf g may see gf always smaller g except factorizing trfd selector expressions boolean expressions created reasonable size codes gf negative due fact normalization process simplifies source code produces compact form code example labels gotos source code eliminated nb miprac fortran c cl frontends translate every loop using gotos labels 2 therefore column ebn includes labels gotos added frontends accounts much negative code growth clear look measures factorizing selector expressions results less code growth factorizing boolean expres sions although cases growth seems manageable main reason small number boolean expressions use heuristic order allows us create boolean expressions manageable size case several nesting levels miprac use phase boolean expression simplification rather factorization selector expressions used excessive boolean expressions created appears however boolean expressions generated normalization small enough simplification would major expense 6 position work several techniques exist structuring flowgraphs 13 28 33 11 12 5 techniques consist modifications eliminating goto statements adding controlflow variables copying code creating calling procedures adding levels iteration may appropriate cases however programs produce often less regular produced method often contain replicated code 27 none presents simple comprehensive algorithm normalization control flowgraphs present limited overview methods however emphasize kennedys method 5 since recent closest method bohm jacopini 13 present two normalization methods flow diagrams decompose flow diagrams base diagrams three types two types methods like add boolean variables replicate code 2 motivations first single representation source code written three different languages second uniform representation loops gotos breaks code ebn eanf bexp ean bexpean gf g mdg 13870 13648 43 19342 0003 222 5472 migration 43369 42716 154 43899 0003 653 530 total 426648 416968 4915 605491 001 10774 178843 figure 24 factorization boolean expressions code ebn eanf sexp ean bexpean gf g migration 42349 41912 178 42632 0004 437 283 total 414088 401772 1868 587513 0004 12316 173425 figure 25 factorization selector expressions even normalizing reducible flowgraphs furthermore authors present simple algorithm rather describe method patternmatching flowgraphs could complex costly implement knuth floyd 28 study program transformations eliminate goto statements without introducing new variables modifying sequence program computations first possibility eliminate gotos introducing procedures sometimes quite clean solution except procedurecalling overhead may important programs involve many loop iterations second possibility write flowchart according bnf defined methods replicate code normalizing reducible flowgraphs authors declare methods suffice eliminate gotos programs peterson kasami tokura 33 define wellformed program program loops conditional statements properly nested single entry obtain program use node splitting transformation may replicate code procedure calls case code replication big method replicates code normalizing reducible flowgraphs bound given size resulting program resulting programs multipleexit loops branches exit several nested control structures ashcroft manna 11 introduce two transformations translate programs gotos programs without first one adds temporary variables second adds logical variables program first method replicates code normalizing reducible flowgraphs methods result loops multiple exits baker 12 concentrates making programs understandable rather eliminating goto statements entirely goto statements generated give clearer description controlflow syntactic restrictions imposed upon input program well algorithm divided two steps locating loops flowgraph adding branching statements first step uses classical notion dominators 2 building depthfirst spanning tree flowgraph second step algorithm adds branching statements basic form program generated first step algorithm extended handle irreducible graphs shortcomings bakers method first gotos remain second loops may left multiple exits third number control forms greater method resultant syntax still fairly complex allen kennedys method converting control dependences data dependences called conversion 5 primary goal transformation transform programs purpose vectorization takes every loop program transforms statement guarded one beyond goal transformation may useful applications code structuring goto elimination conversion performed three steps first step analyzes branches code classifying goto 300 200 figure 26 program cycles either exit branches backward branches forward branches second step branch relocation last step branch removal exit branch defined one terminates loop forward branch defined one whose target loop nesting level precedes target lexically backward branch defined one whose target loop nesting level follows target lexically branch relocation moves branch loop branch target loop nest level branch removal eliminates forward branches attaching guard expressions targets conversion goals similar normalization method shortcomings presented along differences work examples used taken allen kennedys paper 5 written fortranlike syntax normalized forms also written syntax order make differences apparent first problem conversion backward branches improperly identified whose targets precede lexically thus program figure 26 treated reference paper 5 cycle conversion algorithm detects goto 100 backward branch follow carefully controlflow code loop program program obtained conversion figure 27 method factorization performed since two different paths could taken arrive label 300 final normalized form shown figure 28 written fortranlike syntax facilitate comparison second problem conversion adhoc treatment irreducible programs let us take example program figure 29 transformed conversion program figure 30 boolean variable used record branches taken reach statements loop body resulting program contains goto cycle controlflow replaced structured loop subsequent transformation described reference paper 5 must used replace backward branch loop contrast method produces program figure 31 using uniform treatment reducible irreducible flowgraphs since flowgraph irreducible code replication notice conversion introduced additional loopcarried dependence variable bb1 goto 300 eliminated 200 bb1 br1 s2 bb1 br1 goto 100 figure 27 program figure 26 conversion pred162 pred162 andpred164 s1 figure 28 normalized form program figure 26 present program figure 31 dependence may inhibit parallelization loop third problem conversion extra generation boolean expressions guarding statement program program figure equivalent conversion one figure 33 look normalized form figure 34 corresponding program figure 32 see latter form straightforward dataflow analysis would accurate two reasons first statement 5 guarded condition therefore may easily conclude definition array b reaches program whereas program figure 33 necessitates deeper analysis accounts boolean guards arrive conclusion second easy see control structure program figure 34 definition variable x statement 2 reached last definition statement 1 200 figure 29 example irreducible code 200 goto 100 figure 30 conversion program figure 29 pred50 pred50 andnot pred52 repeat pred52 figure normalized form program figure 29 figure reachable uses br1 br1 br1 br1 andnot br2 ornot br1 andnot br2 figure 33 conversion program figure previous definitions x converted code deeper analysis necessary perhaps conservative decision would taken 7 related application gaussian elimination like method several problems closely related controlflow normalization make use gaussian elimination resolution include global flow analysis 19 20 shortest path problems 15 18 26 conversion finite automata regular expressions 41 fundamental framework problems build system equations based regions flowgraph solve system using gaussian resolution following give overview methods allen cockes interval analysis hecht ullmans analysis tar jans interval analysis finally graham wegmans analysis latter three improvements first one literature algorithms pred20 pred22 notnot pred20 pred22 figure 34 normalized form program figure called elimination algorithms ryder paull present comparison four algorithms 38 general described specific implementa tion therefore difficult see common points differences goal give presentation algorithms describing complexity performances want emphasize following four algorithms methods program normalization rather presented show reader gaussian eliminationlike solution systems widely used similar problems several improvements complexity studied algorithms used global dataflow analysis e represents number edges flowgraph assumed order n number nodes flowgraph 71 allen cocke method method known interval analysis introduced allen cocke 35 treat irreducible graphs adjusted handle equations uses quite different represent dataflow equations program describe reaching definitions variable program 4 38 allen cocke algorithm consists iteration three phases partitioning algorithm finds single entry regions dependency graph elimination dataflow equations finally propagation elimination process turns application successive substitution loopbreaking transformations latter transformation equivalent derecursivation transformation described earlier paper unknowns system eliminated natural order node graph added interval propagation backsubstitutions performed propagate global dataflow side effects regions apply consists finding variable correspondences substituting interval head variables solutions reduced equations process reducing system smaller one produces 2 solution 72 hecht ullman method algorithm also applicable reducible graphs takes input system equations analogous one described allen cocke algorithm dependency graph ie control flowgraph elimination process directed region graph much allen cocke algorithm consists applying transformations 1 2 described paper earlier regions search common factors reduced equations allows saving calculation 1 37 46 improvement provides complexity log n rather 2 allen cockes complexity 73 tarjan method tarjan method uses different notion intervals methods sense represent loops control flowgraph calculating intervals implicit order arises allen cocke method order used calculate reduced equations clear order follow one depthfirst orders graph resolution like hechts method based upon 1 2 transformations shown 3 transformation composition two previous ones method applied reducible flowgraphs graph algorithm requires time onffn ff inverse ackermans function simpler algorithm runs log n exists 43 74 graham wegman method algorithm close tarjans interval analysis handles irreducible graphs without need eliminating irreducibility notion intervals called ssets 19 represent loops flowgraph ssets defined numbering nodes dependency graph associated equations numbering performed using depthfirst order elimination process performed using three transformations similar hecht ullman algorithm named 1 2 3 application transformations restricted nodes one predecessor 1 1 consists loopbreaking derecursivation frame work 2 consists substitution node several successors transformations necessary eliminate node k successors substitution performed way hecht ullman algo rithm term substituted successively rather substituting entire right hand side equation allen cocke algorithm finally 3 eliminates node successors algorithm runs time log n 75 conclusion algorithms presented refinement gaussian elimination like algorithm two relationships work described first methods uses gaussian elimination method similar respects second solves dataflow analysis problem much difficulty comes irregular structure underlying control flowgraph using method like structure made regular result analysis algorithm made simpler normalization program anticipates much computation dataflow solutions program solving dataflow problem much efficient normalization process performed program simplifications affect forward backward dataflow problems solved program backward flowgraph normalized program also normalized whereas flowgraph merely structured may unstructured edges reversed finally even though closures may still required loops especially nonfast problems 19 43 simpler nonnormalized program 8 conclusion paper presented algebraic framework normalization controlflow framework made easy us prove transformations preserve semantics programs applicable variety languages powerful existing methods several respects first methods based upon nodesplitting 12 conversion 5 branching instructions remain transformations code replication may occur even normalizing programs whose flowgraphs reducible method eliminates branching instructions replicates code eliminating irreducibility rare condition even unstructured programs second previous methods result programs reducible flow graphs method yields programs whose control flowgraphs highly structured yet particular controlflow cycles normalized single entry singleexit loops loops may transformed conventional loops induction variable recognition 6 9 makes method particularly helpful automatic parallelization highly regular loop structures essential 32 22 simplifies forward backward dataflow analyses transforming program one obvious trivial internal structure third method makes separate representation control dependences unnecessary program normalized method control dependences effect represented directly syntax tree since conditional structure contains expressions controls since analysis control dependences central work parallelizing programs 3 significant simplification work implemented paf 44 parallelizer fortran programs written university paris 6 miprac multilingual parallelizer programs university illinois miprac measured handful examples ratio total normalization time total compilation time approximately 002 total compilation time includes parsing normalization interprocedural analysis intraprocedural dataflow analysis restructuring average compilation time examples 185 seconds expect ratio decrease time measure take account additional passes miprac currently implemented acknowledgments wish thank luddy harrison helpful ideas suggestions improve paper also thank anonymous referees comments earlier drafts paper r design analysis computer algorithms theory parsing overview ptran analysis system multiprocessing program data flow analysis procedure conversion control dependence data dependence restructuration des programmes fortran en vue de leur parallelisation normalization program control flow controlflow normalization algorithm complex ity translation goto programs programs translating program schemas whileschemas algorithm structuring flowgraphs flow diagrams algebra network routing problems kaps1 advanced sourcetosource vectorizer s1 mark iia supercomputer shortest path fast usually linear algorithm global flow analysis flow analysis computer programs efficient algorithms shortest paths sparse networks structured programming goto statements notes avoiding go statements structure advanced vectorized pipelined processors proving algorithms tail functions mathematical semantics algol 60 advanced compiler optimizations super computers capabilities perfect club report combinatorial algorithms theory practice incremental data flow analysis based unified model elimination algorithms elimination algorithms data flow analysis denotational semantics clu denotational semantics representation events nerve nets finite automata denotational semantics schottstrachey approach programming language theory fast algorithms solving path problems paf un paralleliseur automatique pour fortran denotational semantics programming languages fast algorithms elimination common subexpres sions conversion unstructured flow diagrams structured optimizing supercompilers supercomputers tr advanced compiler optimizations supercomputers elimination algorithms data flow analysis automatic recognition induction variables recurrence relations abstract interpretation fast usually linear algorithm global flow analysis efficient algorithms shortest paths sparse networks algorithm structuring flowgraphs fast algorithms solving path problems structured programming italicgo toitalic statements program data flow analysis procedure denotational semantics programming languages capabilities repeat exit statements flow diagrams turing machines languages two formation rules algorithm 97 shortest path denotational semantics flow analysis computer programs incremental data flow analysis conversion control dependence data dependence theory parsing translation compiling design automatic parallelizers symbolic numeric programs optimizing compiler lexically scoped lisp denotational semantics clu optimizing supercompilers supercomputers ctr j bergstra b dinesh j field j heering toward complete transformational toolkit compilers acm transactions programming languages systems toplas v19 n5 p639684 sept 1997 fubo zhang erik h dhollander using hammock graphs structure programs ieee transactions software engineering v30 n4 p231245 april 2004 g j van den brand p klint c verhoef reverse engineering system renovationan annotated bibliography acm sigsoft software engineering notes v22 n1 p5768 jan 1997 todd proebsting scott watterson krakatoa decompilation java dose bytecode reveal source proceedings 3rd conference usenix conference objectoriented technologies coots p1414 june 1620 1997 portland oregon johan janssen henk corporaal making graphs reducible controlled node splitting acm transactions programming languages systems toplas v19 n6 p10311052 nov 1997 larry carter jeanne ferrante clark thomborson folklore confirmed reducible flow graphs exponentially larger acm sigplan notices v38 n1 p106114 january baowen xu ju qian xiaofang zhang zhongqiang wu lin chen brief survey program slicing acm sigsoft software engineering notes v30 n2 march 2005 peng zhao jos nelson amaral ablego function outlining partial inlining framework research articles softwarepractice experience v37 n5 p465491 april 2007 j koehler r hauser sendall wahler declarative techniques modeldriven business process integration ibm systems journal v44 n1 p4765 january 2005
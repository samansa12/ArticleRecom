efficient interprocedural array dataflow analysis automatic program parallelization abstractsince sequential languages fortran c machineindependent current parallel languages highly desirable develop powerful parallelizationtools generate parallel codes automatically semiautomatically targeting different parallel architectures array dataflow analysis known crucial success automatic parallelization analysis performed interprocedurally symbolically often needs handle predicates represented conditions unfortunately powerful program analysis extremely timeconsuming carefully designed enhance efficiency analysis practical level remains issue largely untouched date paper presents techniques efficient interprocedural array dataflow analysis documents experimental results implementation research parallelizing compiler techniques based guarded array regions resulting tool runs faster one two orders magnitude similarly powerful tools b introduction program execution speed always fundamental concern computationintensive applications exceed execution speed provided stateoftheart uniprocessor machines programs need take advantage parallel computers past several decades much effort invested efficient use parallel architectures order exploit parallelism inherent computational solutions progress made areas parallel languages parallel libraries parallelizing compilers paper addresses issue automatic parallelization practical programs particularly written imperative languages fortran c compared current parallel languages sequential languages fortran 77 c machineindependent hence highly desirable develop powerful automatic parallelization tools generate parallel codes targeting different parallel architectures remains seen far automatic parallelization go nevertheless much progress made recently understanding future directions one important finding many critical role array dataflow analysis 10 17 20 32 33 37 38 42 aggressive program analysis support array privatization 29 33 43 removes spurious data dependences thereby enable loop parallelization also support compiler techniques memory performance enhancement efficient messagepassing deployment existing tools however capable interprocedural array dataflow analysis furthermore previous studies paid much attention issue efficiency analysis quite understandably rapid prototyping tools suif 23 polaris 4 emphasize compilation efficiency tend run slowly hand also believe important demonstrate aggressive interprocedural analysis performed efficiently efficiency important development largesized programs especially intensive program modification recompilation retesting conducted taking hour longer compile program example would highly undesirable programming tasks paper present techniques used panorama parallelizing compiler 35 enhance efficiency interprocedural array dataflow analysis without compromising capabilities practice focus kind array dataflow analysis useful array privatization loop parallelization important transformations benefit program performance various parallel machines make following key contributions paper ffl present general framework summarize propagate array regions access conditions enables array privatization loop parallelization fortranlike programs contain nonrecursive calls symbolic expressions array subscripts loop bounds conditions may directly affect array privatizability loop parallelizability ffl show hierarchical approach predicate handling reduces time complexity analyzing predicates control different execution paths ffl present experimental results show reducing unnecessary setdifference operations contributes significantly speed array dataflow analysis ffl measure analysis speed panorama applied application programs perfect benchmark suite 3 suite well known difficult parallelize automatically way show quality parallelized code also report speedups programs parallelized panorama executed sgi challenge multiprocessor results show panorama runs faster one two orders magnitude known tools similar capabilities note order achieve program speedup additional program transformations often need performed addition array dataflow analysis reductionloop recognition loop permutation loop fusion advanced induction variable substitution techniques discussed elsewhere implemented polaris 16 recently panorama techniques already implemented consume quite insignificant portion total analysis transformation time since array dataflow analysis timeconsuming part hence discuss details paper rest paper organized follows section 2 present background materials interprocedural array dataflow analysis use array privatization loop parallelization point main factors analysis potentially slow compiler drastically section 3 present framework interprocedural array dataflow analysis based guarded array regions section 4 discuss several implementation issues also briefly discuss array dataflow analysis performed programs recursive procedures dynamic arrays section 5 discuss effectiveness efficiency analysis experimental results reported show parallelization capabilities panorama high time efficiency compare related work section 6 conclude section 7 background section briefly review idea array privatization give reasons aggressive interprocedural array dataflow analysis needed important program transformation 21 array privatization variable modified different iterations loop writing conflicts result iterations executed multiple processors quite often array elements written one iteration loop used iteration overwritten next iteration kind arrays usually end figure 1 simple example array privatization serve temporary working space within iteration array values different iterations unrelated array privatization technique creates distinct copy array processor storage conflict eliminated without violating program semantics parallelism program increased data access time may also reduced since privatized variables allocated local memories figure 1 shows simple example doall loop transformation executed parallel note value a1 copied outside doall loop since a1 written within doall loop values written ak original loop live end loop nest ie values used statements loop nest additional statements must inserted doall loop last loop iteration copy values ak example assume ak dead loop nest hence absence copyout statements practical cases array privatization much complex example figure 1 benefit transformation hand significant early experiments manually performed program transformations showed without array privatization program execution speed alliant fx80 machine 8 vector processors would slowed factor 5 programs mdg ocean track trfd wellknown perfect benchmark suite 15 recent experiments automatically transformed codes running sgi challenge multiprocessor show even striking effects array privatization number perfect benchmark programs 16 22 data dependence analysis vs array dataflow analysis conventional data dependence analysis predecessor current work array dataflow analysis pioneering work dj kuck defines flow dependence anti dependence output dependence 26 latter two due multiassignments variable imperative languages flow dependence defined two statements one reads value written thus original definition flow dependence precisely reachingdefinition relation nonetheless early compiler techniques able compute array reachingdefinitions therefore long time flow dependence conservatively computed asserting one statement depends another former may execute latter may access memory location thus analysis three kinds data dependences reduces problem memory disambiguation insufficient array privatization array dataflow analysis refers computing flow values array elements purpose array privatization loop parallelization parallelizing compiler needs establish fact case figure 1 array values written one iteration used another 23 interprocedural analysis order increase granularity parallel tasks hence benefit parallel execution important parallelize loops outer levels unfortunately outerlevel loops often contain procedure calls traditional method deal loops inlining substitutes procedure calls bodies called procedures illinois polaris 4 example uses method unfortunately many important compiler transformations increase consumed time storage quadratically even higher rates number operations within individual procedures hence severe limit feasible scope inlining widely recognized largescale applications often better alternative perform interprocedural summary analysis instead inlining interprocedural data dependence analysis discussed extensively 21 24 31 40 recent years seen increased efforts array dataflow analysis 10 17 20 32 33 37 38 42 however tools capable interprocedural array dataflow analysis without inlining 10 20 23 24 complications array dataflow analysis reality parallelizing compiler needs analyze effects procedure calls may also need analyze relations among symbolic expressions among branching conditions examples figure 2 illustrate cases three examples privatizing array make possible parallelize loops figure 2a shows simplified loop mdg program routine interf 3 difficult example requires certain kind inference conditions although b privatizable discuss b simple case suppose condition kcne0 false result last loop k within loop gets executed a6 gets used want determine whether a6 may use values written previous iterations loop condition kcne0 false implies within iteration statement executed thus bkgtcut2 false 9 first loop k fact implies bk 4gtcut2 false second loop k ensures gets written use iteration therefore privatizable loop figure 2b illustrates simplified version segment arc2d programroutine filerx3 i1 nmol1 k19 enddo k25 1 enddo k1114 enddo 2 enddo enddo notp enddo enddo call ina call outam enddo xsize return enddo subroutine outb mm xsize return enddo end b c figure 2 complex examples privatizable arrays condition notp invariant loop result ajmax modified one iteration thus exposing use ajmax modified iteration therefore ajmax never uses value written previous iterations moreover easy see use ajlow jup upward exposed hence privatizable loop parallel loop example condition loop invariant makes sure loopcarried flow dependence otherwise whether loopcarried flow dependence exists figure 2b depends upon condition figure 2c shows simplified version segment ocean programroutine ocean3 interprocedural analysis needed case order privatize loop compiler must recognize fact call loop use a1 call iteration must modify a1 use aj must take value defined iteration requires check whether condition x size subroutine infer condition x size subroutine three examples necessary manipulate symbolic operations previous current work suggests handling conditionals symbolic analysis interprocedure analysis provided powerful compiler array dataflow analysis must performed large scope deal whole set subroutines program algorithms information propagation symbolic manipulation must carefully designed otherwise analysis simply timeconsuming practical compilers handle issues simultaneously designed framework described next 3 array dataflow analysis based guarded array regions traditional frameworks dataflow analysis meet point control flow graph dataflow information different control branches merged meet operator merged information typically distinguish information different branches meet operator therefore said pathinsensitive illustrated last section pathsensitive array dataflow information critical success array privatization hence loop parallelization section present pathsensitive analysis uses conditional summary sets capture effect conditions array accesses call conditional summary sets guarded array regions gars 31 guarded array regions basic unit array reference representation regular array region definition regular array region array denoted ar dimension r range form l symbolic expressions values l u step simply denoted l l u array region represented unknown array region represented regular array region defined restrictive original regular section proposed callahan kennedy 6 regular array region contain interdimensional relationship makes set operations simpler however diagonal triangular shape array cannot represented exactly instance array diagonal ai triangular approximated regular array region regular array regions cover frequent cases real programs seem advantage efficiency dealing common cases guards gars defined used describe complex array sections although primary use describe control conditions regular array regions accessed definition guarded array region gar tuple p r contains regular array region r guard p p predicate specifies condition r accessed use delta denote guard whose predicate cannot written explicitly ie unknown guard say gar p r omega unknown similarly either p f alse r say order preserve much precision possible try avoid marking whole array region unknown multidimensional array region one dimension truly unknown dimension marked unknown also one item range tuple l say u unknown write tuple l let program segment n piece code unique entry point unique exit point use results set operations gars summarize two essential pieces array reference information n listed ffl uen set array elements upwardly exposed n elements used n take values defined outside n ffl modn set array elements written within n addition following sets also represented gars used describe array references loop l body denoted b set array elements used arbitrary iteration loop l upwardly exposed entry loop body b subset array elements ue b upwardly exposed entry loop l ffl mod b set array elements written loop body b arbitrary iteration loop l confusion results may simply denoted mod mod b ffl mod b set array elements written iterations prior arbitrary iteration loop l confusion results may simply denoted mod ffl mod l mod b ffl mod b set array elements written iterations following arbitrary iteration loop l confusion results may simply denoted mod ffl mod l mod b take figure 2c example loop j subroutine ue j empty mod j equals rue bj therefore mod j 1 mod loop j 1 hence mod subroutine similarly ue j loop j subroutine rue bj ue loop 1 lastly ue subroutine x dataflow analysis requires three kinds operations gars union intersection difference operations turn based union intersection difference operations regular array regions well logical operations predicates next first discuss operations array regions gars 32 operations regular array regions operands region operations must belong array drop array name array region notation hereafter whenever confusion given two regular array regions dimension array define following operations sake simplicity presentation assume steps 1 leave section 4 discussion step values let r 1 ae note keep max min operators regular array region therefore relationship symbolic expressions determined even demanddriven symbolic analysis conducted mark intersection unknown since regions symbolic ones care must taken prevent false regions created union operations example knowing r r 1 r 1 r 2 valid guaranteed nicely imposing validity predicates guards 20 union two regular regions computed without concern validity two regions since introduces additional predicate operations try avoid usually keep union two regions without merging like constant regions known valid mdimensional array result difference operation generally 2 regular regions range difference results two new ranges representation could quite complex large however useful describe general formulas set difference operations first define r 1 k r 2 k last k ranges within r 1 r 2 respectively according definition r 1 computation r 1 recursively given following ae following examples difference operations order avoid splitting regions due difference operations routinely defer solving difference operations using new data structure called garwd temporarily represent difference results shall show later using garwds keeps summary computation efficient exact garwds defined following subsection 33 operations gars garwds given two gars following frequent cases union operations two kinds union becomes p 1 r result p two array regions safely combined due unknown symbolic terms keep two gars list without merging discussed previously r 1 may multiple array regions making actual result potentially complex however shall explain via example difference operations often canceled intersection union operations therefore solve difference unless result single gar last moment actual result must solved order finish data dependence tests array privatizability tests difference yet solved formula represented garwd definition gar difference list garwd set defined two components source gar difference list source gar ordinary gar defined difference list list gars garwd set denotes members source gar gar difference list written f source gar difference list g 2 following examples show use formulas garwd note cannot postpone a1n1 denoted 3 denoted 2 denoted 1 enddo enddo figure 3 example garwds solving difference solve garwd operations operations two garwds garwd gar easily derived example consider garwd gwdfg g gar g result subtracting g gwd following 1 fg 3 2 3 g 3 single gar first formula applied result g exactly single gar g 3 g 1 g may symbolic difference result may single gar hence third formula similarly intersection gwd g 1 fg 4 2 g gamma 3 unknown otherwise g 4 also single gar union two garwds usually kept list merged cases concrete examples given illustrate operations garwds enddo end c i1m figure 4 example hsg figure 3 example showing advantage using garwds righthand side summary result body outer loop subscript ue mod indicates two sets belong arbitrary iteration ue represented garwd simplicity omit guards whose values true example recognize array privatizable need prove loopcarried data flow exists set mods within iterations prior iteration denoted mod equal mod theory mod nonetheless invalidate analysis since gars mod list difference list garwd ue obvious intersection mod ue empty therefore array privatizable implement assigning gar unique region number shown parentheses figure 3 makes intersection simple integer operation shown difference operations used calculation ue sets result loss information helps improve effectiveness analysis hand intersection operations may result unknown values due intersections sets containing unknown symbolic terms demanddriven symbolic evaluator invoked determine symbolic values relationship symbolic terms intersection result cannot determined evaluator marked unknown array dataflow framework based gars intersection operations performed last step analyzer tries conduct dependence tests array privatization tests point conservative assumption must made intersection result marked unknown intersection operations however involved propagation mod ue sets therefore affect accuracy sets 34 computing ue mod sets ue mod information propagated backward end beginning routine program segment routine two sets summarized one pass results b u paddmods2 u modinout p figure 5 computing summary sets basic control flow components saved summary algorithm invoked demand particular routine summarize routine unless necessary parameter mapping array reshaping done propagation crosses routine boundaries facilitate interprocedural propagation summary information adopt hierarchical supergraph hsg represent control flow entire program hsg augments supergraph proposed myers 36 introducing hierarchy among nested loops procedure calls hsg contains three kinds nodes basic block nodes loop nodes call nodes loop represented loop node compound node whose internal flow subgraph describes control flow loop body procedure call site represented call node outgoing edge pointing entry node flow subgraph called procedure incoming edge unique exit node called procedure due nested structures loops routines hierarchy control flow derived among hsg nodes flow subgraph highest level representing main program hsg resembles hscg used pips project parallel task scheduling 25 figures 4 shows example hsg note flow subgraph routine never duplicated different calls routine unless multiple versions called routine created compiler enhance potential parallelism details hsg implementation found reference 20 18 propagation array dataflow information use mod n represent array elements modified nodes forwardly reachable n lower hsg level n use ue n represent array elements whose values imported n used nodes forwardly reachable n suppose loop l body denoted b represented loop node n flow subgraph b entry node n ue b equal ue n ue n equal expansion ue b see similarly mod b ilus loop figure expansion loop summaries equal mod n modn equal expansion mod b mod mod sets represented list gars ue ue sets list garwds figure 5 b show mod ue sets propagated direction opposite control flow basic block flow subgraph statement thenbranch s1 elsebranch s2 respectively propagation variables appearing certain summary sets may modified assignment statements therefore righthand side expressions substitute variables simplicity variable substitutions shown figure 5 figure 5 b shows summary sets propagated branches conditions put guards branch indicated function padd figure whole summary process quite straightforward except computation ue sets loops needs analysis support summary expansion illustrated figure 6 given loop index 2 l u suppose ue mod already computed arbitrary iteration want calculate ue mod sets entire loop following formula mod sigma summation also called expansion projection denoted proj figure 6 used eliminate summary sets ue calculation given takes two steps first step computes ue represents set array elements used iteration exposed outside whole loop second step projects result step 1 domain ie range l remove expansion list gars list garwds consists expansion gar garwd lists since detailed discussion expansion would tedious provide guideline paper see appendix i11100 i21100 enddo enddo end i11n11 enddo end b figure 7 examples symbolic expressions guarded array regions implementation considerations extensions 41 symbolic analysis symbolic analysis handles expressions involve unknown symbolic terms widely used symbolic evaluation abstract interpretation discover program properties values expressions relationships symbolic expressions etc symbolic analysis requires ability represent manipulate unknown symbolic terms among several expression representations normal form often used 7 9 22 advantage normal form gives representation congruent expressions addition symbolic expressions encountered array dataflow analysis dependence analysis mostly integer polynomials operations integer polynomials comparison two polynomials straightforward therefore adopt integer polynomials representation expressions normal form essentially sum products given index variable term given equation 2 p j product c j integer constant possible integer fraction x j k integer variable index variable n nesting number loop containing e number products l j number variables p j take program segments figure 7 examples subroutine sub1 mod set statement contains single gar true an1 i2 mod set loop i2 contains true 100 mod set loop i1 contains true lastly mod set whole subroutine contains true an2 delta subroutine sub2 mod set statement s2 contains single gar true ai1 mod set loop i1 contains n1 1 1 mod set statement contains n1 n6 lastly mod set whole subroutine contains n2 expressions e p j sorted according unique integer key assigned variable since l j control complexity polynomial chosen design parameters example using l j control complexity expressions e linear expression affine limited 1 l j zero controlling complexity expression representations properly control time complexity manipulating symbolic expressions symbolic operations additions subtractions multiplications divisions integer constant provided library functions addition simple demanddriven symbolic evaluation scheme implemented propagates expression upwards along control flow graph value expression known predefined propagation limit reached 42 range operations subsection give detailed discussion range operations step values 1 describe range operations use functions following however functions solved otherwise unknown usually returned result given two ranges r 1 r 2 r 1 assuming r 2 r 1 otherwise use r ffl union operation l 2 cannot combined one range otherwise assuming r 1 r 2 valid unknown moment whether valid combine 2 known constant value following l divisible c use formulas case 1 compute intersection difference union otherwise r 1 r union r 1 r 2 usually cannot combined one range must maintained list ranges special case jl 1 gammal 3 may symbolic expressions use formulas case 1 perform intersection difference union 4 1 divisible 2 check see r 2 covers r 1 r 5 cases result intersection marked unknown difference kept difference list level garwds union remains list two ranges 43 extensions recursive calls dynamic arrays programming languages fortran 90 c permit recursive procedure calls dynamically allocated data structures subsection briefly discuss array dataflow analysis performed presence recursive calls dynamic arrays recursive calls treated array dataflow analysis essentially way array data dependence analysis 30 recursive procedure calls either directly indirectly forms cycles call graph whole program proper order must established traversal call graph first maximum stronglyconnected components mscs must identified call graph msc reduced single condensed node call graph reduced acyclic graph array data flow analyzed traversing reduced graph reversed topological order condensed node ie msc visited proper order established among members msc iterative traversal member procedure sets modified used array regions guards visible callers must summarized respectively iterating calling cycles msc simple cycle common case practical programs compiler determine whether visible array regions member procedure grow recursion analyzing procedure twice region grows certain array dimension recursive calls conservative estimate made dimension worst case example range modification use array dimension marked unknown complex msc requires complex traversal order 30 dynamically allocated arrays summarized essentially way static arrays main difference backward propagation array regions guards control flow graph ie hsg paper current node contains statement allocates dynamic array ue sets mod sets array killed beyond node discussion based assumption true aliasing exists procedure ie references different variable names must access different memory locations either reference write assumption true fortran 90 fortran 77 programs may false c programs performing array dataflow analysis c programs alias analysis must first performed alias analysis studied extensively recent literature 8 11 14 27 28 39 44 45 5 effectiveness efficiency section first discuss gars used array privatization loop parallelization present experimental results show effectiveness efficiency array dataflow analysis 51 array privatization loop parallelization array privatization candidate loop l elements overwritten different iterations l see 29 candidacy established examining summary array mod set intersection mod modi nonempty candidate privatization candidate privatizable exist loopcarried flow dependences l array loop l index mod ue exists flow dependence carried loop l let us look figure 2c ue privatizable within loop another example let us look figure 2b since mod loopvariant mod empty array privatization candidate furthermore last difference operation easily done gar difference list therefore ue mod empty guarantees array privatizable explained section 21 copyin copyout statements sometimes need inserted order preserve program correctness general rules 1 upwardly exposed array elements must copied 2 live array elements must copiedout already discussed determination upwardly exposed array elements currently perform conservative liveness analysis proposed 29 essence loop parallelization prove absence loopcarried dependences given loop l index existence different types loopcarried dependences detected following order ffl loopcarried flow dependences exist ue loopcarried output dependences exist mod loopcarried anti dependences suppose already determined exist loopcarried output dependences loopcarried antidependences exist ue mod 6 loopcarried antidependences considered separately ue formula replaced de de stands downwardly exposed use set iteration take output dependences example figure 7a mod loop i2 contains single gar contains loopcarried output dependences exist loop i2 mod contrast loop i1 mod contains true loopcarried output dependences exist loop i1 mod mod 6 note array privatized loopcarried output dependences exist write references private copies array 52 experimental results implemented array dataflow analysis prototyping parallelizing compiler panorama multiple pass sourcetosource fortran program analyzer 35 roughly consists phases parsing building hierarchical supergraph hsg interprocedural scalar uddu chains 1 performing conventional data dependence tests array dataflow analysis advanced analyses parallel code generation table 1 shows fortran loops perfect benchmark suite parallelizable array privatization necessary transformations induction variable substitution parallel reduction event synchronization placement table also marks loops require symbolic analysis predicate analysis interprocedural analysis respectively details privatizable arrays loops found 18 columns 4 5 mark loops parallelized polaris version 15 panorama respectively one loop interf1000 parallelized polaris panorama one privatizable arrays recognized privatize array requires implementation special pattern matching done panorama hand panorama parallelizes several loops cannot parallelized polaris table 2 compares speedup programs selected table 1 parallelized polaris panorama respectively programs parallelizable either tools selected speedup numbers computed dividing real execution time sequential codes divided real execution time parallelized codes running sgi challenge multiprocessor four 196mhz r10000 cpus 1024 mb memory average speedups comparable polarisparallelized codes panoramaparallelized codes note speedup numbers may table 1 parallelizable loops perfect benchmark suite required privatization techniques program routine sa pa ia parallel ocean total 80 32 80 7 sa symbolic analysis pa predicate analysis ia interprocedural analysis improved number recently discovered memoryefficiency enhancement techniques techniques implemented versions polaris panorama used experiment table 3 shows wallclock time spent main parts panorama table 3 parsing time time parse program although panorama currently parses program three times first time constructing call graph rearranging parsing order source files second time interprocedural analysis last time code generation column hsg doall checking time taken build hsg uddu chains conventional doall checking column array summary refers array dataflow analysis applied loops whose parallelizability cannot determined conventional doall tests figure 8 shows percentage time spent array dataflow analysis rest panorama even though time percentage array dataflow analysis high 38 average total execution time small 31 seconds maximum get perspective overhead table 2 speedup comparison polaris panorama 4 r10000 cpus program speedup polaris speedup panorama adm 11 15 mdg 20 15 bdna 12 12 ocean 12 17 arc2d 21 22 trfd 22 21 interprocedural analysis last column marked f77 shows time spent f77 compiler option compile corresponding fortran program sequential machine code table 4 lists analysis time polaris alongside panorama includes three times parsing instead one table 3 difficult provide absolutely fair comparison two sets numbers listed together provide perspective timing polaris version 15 measured without passes array privatization dependence tests list timing results suif suifs current public version perform array dataflow analysis timing results publically available panorama polaris compiled gnu gccg compiler optimization level time measured gettimeofday elapsed wallclock time using sgi challenge machine large memory time gap polaris panorama reduced probably polaris written c huge executable image size executable image 14mb panorama written c executable image 11mb even memory size large 1gb panorama still faster polaris one two orders magnitude 53 summary vs inlining believe several design choices contribute efficiency panorama next subsections present choices made panorama foremost reason seems panorama computes interprocedural summary without inlining routine bodies polaris subroutine called several places program inlining causes subroutine body analyzed several times panorama needs summarize subroutine summary result later mapped different call sites moreover data dependence tests involving call statements panorama uses summarized array region information polaris performs data dependences every pair array references loop body inlining since time complexity data dependence tests 2 n number individual references tested inlining significantly increase time dependence testing experiments polaris limit number inlined executable statements 50 default table 3 analysis time seconds distribution 1 program parsing hsg tradi array code total f77 analysis summary generation adm 363 1268 1176 353 3160 541 qcd 104 371 304 122 901 203 mdg 082 258 211 077 628 123 bdna 241 741 380 245 1606 452 ocean 137 849 331 135 1453 393 dyfesm 377 604 226 248 1456 202 mg3d 167 746 1487 170 2571 340 arc2d 246 624 1014 196 2081 377 trfd 054 070 048 018 190 72 total 2456 721 7031 2037 18738 3498 1 timing measured sgi indy workstations 134mhz mips r4600 cpu 64 mb memory table 4 elapsed analysis time seconds program lines excl sgi challenge sgi indy 2 comments panorama polaris panorama polaris adm 4296 1703 435 3880 2601 mdg 935 302 123 790 551 ocean 1917 870 333 182 1801 trfd 417 105 62 298 290 1 sgi challenge 1024mb memory 196mhz r10000 cpu 2 sgi indy 134mhz mips r4600 cpu 64 mb memory 3 means polaris takes longer four hours adm qcd mdg track bdna ocean dyfesm mg3d arc2d flo52 trfd spec77 total rest summary figure 8 time percentage array dataflow summary value used polaris modest number data dependence tests still account 30 total time believe another important reason panoramas efficiency efficient computation propagation summary sets two design issues particularly noteworthy namely handling predicates difference set operations next discuss issues details 54 efficient handling predicates general predicate operations expensive compilers often perform fact majority predicatehandling required array dataflow analysis involves simple operations checking see two predicates identical loopindependent contain indices affect shapes sizes array regions implemented rather efficiently canonical normal form used represent predicates patternmatching normal form easier arbitrary forms conjunctive normal form cnf disjunctive normal form dnf widely used program analysis 7 9 cited works show negation operations expensive cnf dnf fact also confirmed previous experiments using cnf 20 negation operations occur due else branches also due gar garwd operations elsewhere hence design new normal form negation operations often avoided use hierarchical approach predicate handling predicate represented high level predicate tree pt v e r v set nodes e set edges r root pt internal nodes v nand operators except root operator leaf nodes divided regular leaf nodes negative leaf nodes regular leaf node represents negative leaf operator regular leaf figure 9 high level representation predicates predicate condition negative leaf node represents negation predicate theoretically representation normal form two identical predicates may different predicate trees may render patternmatching unsuccessful however believe cases rare happen program extremely complicated figure 9 shows pt leaf regular negative token represents basic predicate condition condition program level keep basic predicate unit split predicate operations based tokens check details within basic predicates negation predicate tree simple way nand operation shown figure 10 may either increase decrease one level predicate tree according shape predicate tree one regular leaf node one negative leaf node tree regular leaf node simply changed negative leaf node vice versa operations also easily handled shown figure 10 use unique token basic predicate simple common cases easily handled without checking contents predicates content predicate represented cnf examined necessary table 5 lists several key parameters total number arrays summarized average length mod set column ave gars average length ue set column ave garwds data concerning difference predicate operations total number arrays summarized given table sum number arrays summarized loop nest array appears two disjoint loop nests counted twice since time set operations proportional square length mod ue lists important lists short encouraging see indeed short benchmark application programs columns 7 8 marked high low table 5 show 95 total predicate operations high level ones negation binary predicate operation two basic predicates counted one operation numbers dependent strategy used handle predicates currently defer checking predicate contents last step result low level negation increase 1 negation decrease 1 b c figure 10 predicate operations table 5 measurement key parameters program array ave ave difference ops predicate ops summarized gars garwds total reduced high low qcd 414 141 127 512 41 4803 41 bdna 285 127 143 267 3 3805 4 ocean 96 172 153 246 19 458 36 mg3d 385 279 262 135 total 4011 155 149 3675 314 42391 618 predicate operations needed results show strategy works well array privatization since almost privatizable arrays tested programs recognized cases need handle guards containing loop indices need low level predicate operations hierarchical representation scheme serves well reducing unnecessary difference operations solve difference using general formula presented section 2 unless result single gar difference cannot simplified single gar difference represented garwd instead union gars implied formula strategy postpones expensive complex difference operations absolutely necessary avoids propagating relatively complex list gars example let garwd g 1 g 2 oe two difference operations represented g 1 reduced ie need perform table 5 total number difference operations total number reduced difference operations illustrated columns 5 6 respectively although difference operations reduced 9 average reduction dramatic programs one third mdg half mg3d let us use example figure 2b illustrate significance delayed difference operations simplified control flow graph body outer loop shown figure 11 suppose 1st j p branch 2nd j figure 11 hsg body outer loop figure node summarized summary results listed following description given section 34 propagate summary sets node following steps get summary sets body outer loop 1 mod 2 mod difference operation kept garwd reduced step 4 3 mod p inserted guards gars propagated true edge p inserted guards propagated false edge 4 mod step computation ue p1 removes one difference operation fp jlow equal words need perform difference operation represented garwd g advantage garwd representation difference postponed rather always performed using garwd difference operation step 2 always performed necessary thus increases execution time therefore summary sets body outer loop determine array privatizable need prove exists loopcarried flow dependence first calculate mod set array elements written iterations prior iteration giving us mod intersection mod ue conducted two intersections formed one mod component mod ue respectively first mod appears difference list ue thus result obviously empty similarly intersection p jmax second mod p jmax empty guards contradictory intersection mod ue empty array privatizable intersections avoid performing difference operation ue therefore improve efficiency 6 related work exist number approaches array dataflow analysis far know work particularly addressed efficiency issue presented efficiency data one school thought attempts gather flow information array element acquire exact array dataflow analysis usually done solving system equalities inequalities feautrier 17 calculates source function indicate detailed flow information maydan et al 33 34 simplify feautriers method using last writetreelwt duesterwald et al 12 compute dependence distance reaching definition within loop pugh wonnacott 37 use set constraints describe array dataflow problems solve basically fouriermotzkin variable elimination maslov 32 well pugh wonnacott 37 also extend previous work category handling certain conditions generally approaches intraprocedural seem easily extended interprocedurally group analyzes set array elements instead individual array elements early work uses regular sections 6 24 convex regions 40 41 data access descriptors 2 etc summarize moduse sets array accesses array dataflow analyses recently array dataflow analyses based sets proposed gross steenkiste 19 rosene 38 li 29 tu padua 43 creusillet irigoin 10 hall et al 21 one using conditional regions gars even though handle conditions using approaches although second group provide many details reachingdefinitions first group handles complex program constructs better easily performed interprocedurally array dataflow summary part second group mentioned focus parallelizing compiler area essential information array dataflow summary upwardly exposed use set summary approaches compared two aspects set representation path sensitivity set representation convex regions highest precision also expensive complex representation bounded regular sections regular sections simplest representation thus inexpensive early work tried use single regular section single convex region summarize one array obviously single set potentially lose information may ineffective cases tu padua 43 creusillet irigoin 10 seem use single regular section single convex region respectively hall et al 21 use list convex regions summarize references array unclear representation precise list regular sections upon approach based regarding path sensitivity commonality previous methods distinguish summary sets different control flow paths therefore methods called pathinsensitive shown inadequate real programs approach far know pathsensitive array dataflow summary approach parallelizing compiler area distinguishes summary information different paths putting conditions guards approaches handle conditions context array dataflow summary 7 conclusion paper presented array dataflow analysis handles interprocedural symbolic predicate analyses together analysis shown via experiments quite effective program parallelization important design decisions made analysis performed efficiently hierarchical predicate handling scheme turns serve well many predicate operations performed high levels avoiding expensive lowlevel operations new data structure garwd ie guarded array regions difference list reduces expensive setdifference operations 50 programs although reduction unimpressive programs another important finding mod lists ue lists kept rather short thus reducing set operation time far know first time efficiency issue addressed data presented powerful analysis believe important continue exploring efficiency issue unless interprocedural array dataflow analysis performed reasonably fast adoption real programming world would unlikely continued advances parallelizing compiler techniques hope fully partially automatic parallelization provide viable methodology machineindependent parallel programming r mechanism keeping useful internal information parallel programming tools data access descriptor perfect club benchmarks effective performance evaluation supercomputers parallel programming polaris symbolic analysis techniques needed effective parallelization perfect benchmarks analysis interprocedural side effects parallel programming environment efficient flowsensitive interprocedural computation pointerinduced aliases side effects applications symbolic evaluation interprocedural array region analyses interprocedural mayalias analysis pointers beyond klimiting practical dataflow framework array reference analysis use optimizations automatic parallelization perfect benchmarks experience automatic parallelization four perfect benchmark programs automatic parallelization perfect benchmarks dataflow analysis array scalar references structured dataflow analysis arrays use optimizing compiler symbolic array dataflow analysis array privatization program parallelization interprocedural analysis parallelization symbolic dependence analysis parallelizing compilers maximizing multiprocessor performance suif compiler implementation interprocedural bounded regular section analysis semantical interprocedural parallelization overview pips project structure computers computations safe approximate algorithm interprocedural pointer aliasing interprocedural modification side effect analysis pointer aliasing array privatization parallel execution loops interprocedural analysis parallel computing program parallelization interprocedural analysis lazy array dataflow dependence analysis array dataflow analysis use array privatization accurate analysis array references interprocedural parallelizing compiler support memory hierarchy research precise interprocedural dataflow algorithm exact method analysis valuebased array data dependences incremental dependence analysis direct parallelization call statements interprocedural analysis program restructuring parafrase gated ssabased demanddriven symbolic analysis parallelizing compilers automatic array privatization efficient contextsensitive pointer analysis c programs program decomposition pointer aliasing step towards practical analyses tr ctr array resizing scientific code debugging maintenance reuse proceedings 2001 acm sigplansigsoft workshop program analysis software tools engineering p3237 june 2001 snowbird utah united states thi viet nga nguyen franois irigoin efficient effective array bound checking acm transactions programming languages systems toplas v27 n3 p527570 may 2005
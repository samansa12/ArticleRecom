event detection algebra reactive systems reactive systems execution driven external events system respond appropriate actions events simple systems often supposed react sophisticated situations involving number simpler events occurring accordance pattern systematic approach handle type systems separate mechanism detecting composite events rest application logicin paper present event algebra composite event detection show number algebraic laws facilitate formal reasoning justify algebra semantics showing extent operators comply intuition finally present implementation algebra identify large subset expressions detection performed bounded resources b introduction many realtime embedded systems reactive meaning execution driven external events system react appropriate response many applications system react complex event patterns sometimes called composite events rather permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee september 2729 2004 pisa italy single event occurrence systematic approach handle type systems separate mechanism detecting composite events rest application logic detection mechanism takes input primitive events detects occurrences composite events used input application logic separation concerns facilitates design analysis reactive systems detection complex events given formal semantics independent application used remaining application logic free auxiliary rules information partially completed patterns example 1 consider system input events including button b pressure alarm p temperature alarm one desired reaction system perform action button pressed twice within two seconds unless either alarms occurs achieved set rules specifies reactions three events combined behaviour implements desired reaction alternatively separate detection mechanism used define composite event e corresponds described situation single rule stating occurrence e trigger action two approaches illustrated figure 1 application logic event detection application logic figure 1 implicit explicit detection composite events mechanism detect composite events constructed event algebra ie number operators expressions built represent event patterns interest paper propose event algebra specifically targets applications limited resources embedded realtime systems present number algebraic laws facilitate formal reasoning justify algebra semantics showing extent operators comply intuition finally identify criteria detection performed limited resources present transformation algorithm allows many expressions transformed form criteria met proposed algebra consists five operators disjunction b represents either b oc curs denoted ab conjunction means events occurred possibly simultaneously denoted ab negation denoted ab occurs occurrence occurrence b sequence ab occurrence followed occurrence b finally temporal restriction occurs occurrence shorter time units example 2 composite event e previous example corresponds expression bb2pt algebra operator semantics described informally specify handle situations occurrence could participate several occurrences composite event example three occurences followed two occurrences b result six occurrences ab may acceptable even desirable applications memory requirements occurrence b must remembered forever increasing number simultaneous events means unsuitable many cases common way deal introduce variants operators impose stronger constraints addition basic conditions give example possible sequence variant require addition occurring b recent occurrence far variants defined means general restriction policies combination operator restriction policy yields operator variant specific semantics restriction applied individual operator occurrences expression existing event algebras restriction policies user algebra must understand interference nested restrictions eect restriction dierent operator combinations developed novel restriction policy conceptually applied expression whole rather individual operators results algebra simpler intuitive semantics policy carefully designed applying top level semantically consistent applying recursively subexpressions allows ecient implementation far know previous research event algebras addressed conformance algebraic laws particular event algebras suited systems limited resources typically exhibit unintuitive semantics poor algebraic prop erties throughout paper proofs reduced left due space limitations reader referred 3 full proofs rest paper organised follows section 2 surveys related work algebra defined section 3 followed presentation algebraic properties section 4 section 5 presents implementation including analysis time memory complexity section 6 describes semanticpreserving transformation algorithm section 7 concludes paper 2 related work operators algebra well use interval semantics restricted detection influenced work area active databases snoop 6 ode 9 samos 8 examples active database systems event algebra used specify reactive behaviour systems dier primarily choice detection mechanism samos based petri nets snoop uses event graphs ode event definitions equivalent regular expressions detected state automata area active databases event algebras often given formal semantics algebraic properties operators investigated also resource eciency typically main concern common systems consider composite events instantaneous ie occurrence associated single time instant normally time detected galton augusto shown results unintended semantics operation compositions 7 example occurrence followed b c accepted occurrence composite event bac since b occurs occurrence ac also present core alternative intervalbased semantics handle problems use similar semantic base algebra extend restriction policy allow algebra implemented limited resources retaining desired algebraic properties solicitor 12 intervalbased event specification language based snoop language targets realtime systems particular achieves predictable resource requirements composite events explicit expiration time liu et al use real time logic define system composite events expressed timing constraints handled general timing constraint monitoring techniques present mechanism early detection timing constraint violation show upper bounds memory time derived 11 middleware platforms event detection techniques used handle high volumes event occurrences allowing consumers subscribe certain event patterns rather single event types sanchez et al present event correlation language event expressions translated nested petri net like automata 14 event detection mechanisms described provide assistance developer terms algebraic properties event expression equivalence theory cases memory usage addressed example means restriction policies results complicated nonintuitive semantics knowledge representation techniques use similar operators reason event occurrences rather detecting complex events occur focus express formally fact event occurred defining inferences rules type statements examples include interval calculus 1 event calculus 10 propose algebra large class composite events detected limited resources algebra defined simple declarative semantics present number algebraic laws facilitate formal reasoning supports claim intuitive meaning operators valid also complex nested expressions preliminary version algebra less useful algebraic properties memory bound described previous paper 4 3 declarative semantics simplicity assume discrete time model throughout paper declarative semantics algebra used dense time model well restrictions prevent primitive events occur infinitely many times finite time interval definition 1 temporal domain set natural numbers 31 primitive events assume system predefined set primitive event types able react events external sampled environment originating another system internal violation condition system state timeout detection mechanism distinguish categories primitive events useful associate additional information occurrence example occurrences temperature alarm might carry measured temperature value used responding ac tion values manipulated algebra grouped forwarded part system reacts detected events definition 2 let p finite set identifiers represent primitive event types interest system identifier p p let domp denote domain values p taken occurrences primitive events assumed instantaneous atomic algebra represented event instances contain event type occurrence time value formally represent primitive instance singleton set allow primitive complex instances treated uniformly definition 3 p p domp singleton set p primitive event instance together occurrences certain event type form event stream allow simultaneous occurrences gen eral occurrences primitive event type assumed nonsimultaneous definition 4 primitive event stream set primitive event instances identifier dierent times set identifiers value domains capture static aspects system instances event streams ever dynamic concepts describe happens particular scenario interpretation formal representation single scenario describes one possible ways primitive events occur definition 5 interpretation function maps identifier p p primitive event stream containing instances identifier p example 3 let high low st 12 2t 14 3t 8 5 p low 4 examples primitive event streams ips possible interpretation 32 composite events composite events represented expressions built identifiers operators algebra definition 6 ap event expression b event expressions ab ab ab ab event expressions next extend concepts instances streams composite events well primitive way instances constructed defined algebra semantics define structure definition 7 event instance union n primitive event instances 0 n informally instance composite event represents primitive event occurrences caused occurrence composite event since semantics interval based associate instance interval following definition definition 8 event instance define interval starta enda thought smallest interval contains occurrences primitive events caused occurrence note primitive event instance event instance primitive instance example 4 let 12 2p low 4t 8 5 event instance starta2 enda 5 also need definition general event streams used represent instances composite event according definition primitive event stream event stream names suggest definition 9 event stream set event instances naming convention use u event streams b c event expressions lower case letters used event instances general belongs event stream event stream defined etc 33 semantics interpretation provides occurrences primitive events mapping identifier event stream role algebra semantics extend mapping composite events defined event expressions following functions event streams form core algebra semantics define basic characteristics five operators definition 10 event streams define negs semantics algebra defined recursively applying corresponding function operator expression definition 11 meaning event expression given interpretation defined follows simplify presentation use notation instead choice obvious arbitrary definitions result algebra simple semantics intuitive algebraic properties dicult implement limited resources deal resource limitations define formal restriction policy require implementation compute valid restriction event stream specified algebra semantics formally restriction policy defined relation rem rems means valid restriction alternatively seen nondeterministic restriction function family acceptable restriction func tions reasons repeatability typically desirable implementation algebra deterministic theoretical point view however prefer leave many detailed design decisions possible open ensure implementation consistent restriction policy relation guaranteed properties described paper basis restriction policy restricted event stream contain multiple instances end time one eciency issues formally instances end time restriction policy keeps exactly one maximal start time definition 12 two event streams rems holds following conditions hold 1 2 ss startsstarts 3 ss endsends ss rather computing given event expression implementation algebra computes event stream rema holds user alge bra means time one occurrences one detected 4 properties aid user algebra present selection algebraic laws laws facilitate reasoning formally informally algebra system embedded also show extent operators behave according intuition first define expression equivalence definition 13 event expressions b define hold interpretation trivially equivalence relation moreover following theorem shows satisfies substitutive con dition hence defines structural congruence event expressions theorem 1 proof follows straightforward way definitions laws formulated extensive set laws formal proofs reader refered 3 theorem 2 event expressions b c following laws hold following laws describes temporal restrictions propagated expression section 6 laws used define algorithm transforming event expressions equivalent expressions detected eciently theorem 3 event expressions b following laws hold p min ab b ab b ab ab ab b ab ab laws identify expressions semantically equiv alent order handle resource limitations expect implementation algebra compute event stream rema rather computing result detecting might yield dierent stream detecting even consequently clarified extent laws presented still applicable restriction applied theorem 4 event expressions rema holds rema holds well thus ensures result implementation detecting always valid result long reasoning based algebra semantics restriction policy details particular detection algorithm equally valid equivalent expressions investigate relation equivalent expressions restriction applied notice restriction policy implies detected event streams equivalent expressions always contain instances corresponding start end times means part system responds detected event occurrences notified time equivalent expressions possibly dierent values attached detected occurrences formally express follows definition 14 event streams define hold following holds starts ends trivially equivalence relation theorem 5 event streams rems rems holds proof take since second condition definition rem exists also thus according third condition definition rem implies means startt startt startt thus startt startt start end time trivially opposite holds well corollary 1 rema rema thus ensures implementation consistent restriction policy instances found detecting start end times means part system responds detected event occurrences notified time equivalent expressions possibly dierent values attached detected occurrences order get desired eciency subexpressions expression must detected ecient way thus restriction policy applied recursively every subexpression scenario would normally require user algebra understand restrictions dierent subexpressions interfere eect dierent operator combinations avoid operators restriction policy carefully designed support following theorem informally states restricting subexpressions well whole expression gives result valid also case restriction applied top level theorem 6 rems remt holds event stream u following implications hold proof present proof negation refer 3 full proof assume remnegs u subset requirement definition rem u exists startu startt endt endu must exist startt startt contradicts fact u negs since exist u negs thus u negs satisfying first condition definition rem next take arbitrary u negs u exists u endu exists startu startt endt endu fact contradicts exist means exists u u startu startu endu second constraint definition rem finally remnegs u ensures instances u dierent end times together shows three constraints definition 12 satisfied thus remnegs u holds 5 event detection algorithm section present imperative algorithm given event expression e computes event stream reme holds throughout section e denotes event expression detected numbers 1 assigned subexpressions e bottomup order let e denote subexpression number consequently p figure 2 presents algorithm algorithm executed every time instant computes current instance e current instances primitive events stored information past operator occurrence expression requires state variables thus variables indexed 1 variable used store current instance thus contains output algorithm execution auxiliary variables l r q store information past needed detect e properly l r single event instance stored stores time instant q contains set event instances symbol used represent nonoccurrence define startend1 simplify algorithm algorithm designed detection arbitrary ex pressions main loop selects dynamically part algorithm execute subexpression systems event expressions interest static known time development main loop unrolled toplevel conditionals well dices statically determined concrete example given figure 3 51 algorithm correctness next relation algorithm algebra semantics described previous sections must estab lished purpose need formalise algorithm output constructing corresponding event streams definition 15 1 define outi denotes value executing algorithm times 0 due space limitations give informal description operator refer 3 formal proofs 1 current instance e current instance ak else j l else startak starta j j r else l ak ak foreach e q e ak j else figure 2 algorithm detecting event expression initially 1 l r disjunction operator fairly simple requires auxiliary variables e j e k occur time restriction policy requires one latest start time selected start times implementation gives precedence right subexpression fact implementation disjunction operator corresponds declarative semantics restriction respect instances detected subex pressions formulated remdisaj ak ai conjunctions necessary store instance maximum start time far two subexpres sions start time instant l element e eaj ende maximum start time set empty corresponding property holds r ak first two conditionals conjunction part algorithm correctly update state next time stant new state used construct current output instance conjunction one current instance none a2 current instance p none a4 current instance b none t5 starta4 t5 starta4 t5 starta3 a5 a3 else a5 figure 3 statically simplified algorithm detecting tpb initially t5 1 according semantics negation operator instance b instance bc unless invalidated instance c occurring within interval current instance b invalidated invalidated instance c maximum start time occured far thus sucient store single start time since end time trivially known less end time current instance b start time instant maximum start time elements e e ak ende set empty first conditional updates state valid next time instant updated variable used check current instance e j invalidated sequence operator requires complex algorithm reason order detect sequence bc correctly must store several instances b c occurs start time instance determines stored instances b combined form instance bc following hold start time instant maximum start time elements e eaj ende 1 set empty q first conditional selects best match current instance instances stored q creates output instance matching instance found second conditional state updated ensure q contain fully overlapping instances e j instance checked added temporal restriction temporal restriction fairly straightforward implement requires auxiliary state variables putting together following theorem establishes correctness algorithm stating subexpression e including detected instances correspond valid restriction theorem 7 1 reme ai holds proof p assumption interpretation correctly represents realworld scenario thus reme ai holds trivially ak foreach e q e ak foreach e q q q e l e figure 4 algorithm next assume reme x ax holds 1 x according discussion remdisaj ak ai since subexpressions numbered bottomup j k assumption reme j aj reme k ak holds according theorem 6 remdise j holds means reme ai holds similar proof constructed operators duction theorem holds 52 memory complexity instances fixed size instance subexpression e contains m2 primitive stances one identifier occurrence e thus assuming elements value domains constant size size single event instance bounded quick analysis algorithm reveals dis junction conjunction negation temporal restriction event expression requires limited amount storage storage required sequence operator depends maximum size q bound exists general case important class sequence expressions however detection algorithm redefined ensure limited memory time complexity sequence ab know maximum length instances b expressed b b limits number instances must stored order detect sequence correctly informally start instance b time units back time thus need store one instance ends earlier store one maximum start time instances end later point time need store several original algorithm improved algorithm detecting ab b b bounded memory presented figure 4 c used access current time instant state similar state used sequences original algorithm q contains sux q variable original version remaining elements single element maximum start time stored l since size q never exceeds 1 type sequences detected limited memory large values example systems fine granularity timebase resource bound might sufficient practice also ab bound large overapproximation unless occurs frequently information minimum separation time primitive events ie minimum time two consecu figure 5 transformation function tive occurrences event precise worst case memory estimates derived 3 53 time complexity result instances fixed size assigning instance variable might constant operation rather proportional instance size thus operator contributes least factor complexity whole algorithm sequences straightforward representation q variables gives linear time complexity finding best matching instance respect size limit q variable gives total complexity omn number subexpressions e n maxmn n maximum size limit due particular characteristics q elaborate implementation possible best match found logarithmic time updates bounded factor variablesized instances details see 3 using implementation total complexity omn 6 transformation algorithm section describes event expressions automatically transformed equivalent expressions allow ecient detection transformation algorithm based algebraic laws describing temporal restrictions propagated expression presented theorem 3 simplify presentation extend algebra syntax two constructs symbol added temporal domain allow temporally restricted unrestricted expressions treated uniformly formally define since improved sequence algorithm defined sequences ab b b introduce notation b label sequences information transformation algorithm based recursive function takes expression time input returns transformed expression time function defined figure 5 input time represents temporal restriction applied expression without changing meaning expression whole returned time represents temporal restriction applied transformed expression without changing meaning meaning expression unchanged algo rithm sequences labeled correctly specified following theorem proof reader refered 3 theorem 8 transforme e also sequences e labeled form b holds trivially time complexity transformation algorithm linear respect size e sequence e labeled e consequently e correctly detected limited memory example 5 transformbb2 ppt b0b2p2 pt2 2 means expression detected limited memory note temporal restriction left subexpression negation propagated right subexpression making detectable limited memory 7 conclusions future work presented fully formal event algebra operators disjunction conjunction negation sequence temporal restriction allow ecient implementation formal restriction policy defined restriction policy applied expression whole rather individual operator occurrences means user algebra required understand eects nested restrictions number algebraic laws presented facilitate formal reasoning justify algebra semantics showing extent operators comply intuition presented imperative algorithm computes restricted version event stream specified algebra semantics accordance restriction policy user algebra means time one occurrences composite event one detected algorithm finally criteria detection performed limited resources identified described algorithm many expressions transformed meet criteria ongoing work includes investigating combine algebra languages specifically target reactive systems particular esterel 2 frp 13 15 timber 5 also considering extending algebra delay operator allow definition timeout events adding support manipulating values associated event occurrences 8 r actions events interval temporal logic esterelv5 language primer intuitive resourceecient event detection algebra intervalbased algebra restricted event detection semantic layers timber expressive event specification language active databases two approaches event definition events active objectoriented database system compose system composite specification detection logicbased calculus events unified approach specifying timing constraints composite events active realtime database systems functional reactive programming event correlation language semantics tr logicbased calculus events snoop expressive event specification language active databases functional reactive programming continued eventdriven frp compose two approaches event definition unified approach specifying timing constraints composite events active realtime database systems
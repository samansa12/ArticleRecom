data structure circular string analysis visualization csdawg circular strings obtained making simple modifications compact symmetric directed acyclic word graph csdawg linear strings proposed data structure contain extraneous vertices consequently avoids disadvantages previous methods using method algorithms make use csdawg linear strings extended circular strings trivial modifications extended algorithms continue time space complexities moreover extensions take form postprocessing preprocessing steps simple add system built linear strings particularly objectoriented language b introduction circular string data type used represent number objects circular genomes polygons closed curves research molecular biology involves identification recurring patterns data hypothesizing causes andor effects 1 2 research pattern recognition computer vision involves detecting similarities within object objects 3 detecting patterns visually tedious prone error 4 model proposed alleviate problem model consists identifying recurring patterns string highlighting identical patterns color 4 also listed number queries model would support 5 efficient mostly optimal algorithms proposed queries linear strings algorithms perform operations traversals symmetric compact directed acyclic word graph scdawg 6 linear string scdawg used represent string set strings evolved string data structures position trees suffix trees directed acyclic word graphs etc 7 8 9 10 one approach extending techniques circular strings arbitrarily break circular string point becomes linear string techniques linear strings may applied however disadvantage significant patterns circular string may lost patterns broken linearizing string indeed would defeat purpose representing objects circular strings 3 defined polygon structure graph extension suffix trees circular strings however suffix tree powerful scdawg cannot used solve problems scdawg solve paper define scdawg circular strings algorithms 5 6 make use scdawg linear strings extended circular strings minor modifications extended algorithms continue efficient time space complexities extensions take form postprocessing preprocessing steps simple add system built linear strings particularly object oriented language e c c figure 1 circular string section 2 contains definitions section 3 describes scdawg linear strings section 4 describes extension circular strings section 5 deals computation occurrences displayable entities section 6 introduces notion conflicts section 7 lists queries implemented section 6 also explains algorithms implementing queries linear strings modified work circular strings finally section 8 mentions applications visualization analysis circular strings let denote circular string size n consisting characters fixed alphabet sigma constant size figure 1 shows example circular string size 8 shall represent circular string linear string enclosed angle brackets distinguishes linear string linear string obtained traversing circular string clockwise order listing element traversed starting point traversal chosen arbitrarily consequently n equivalent representations example could represented abcdabce bcdabcea etc characterize relationship circular strings linear strings defining functions linearize circularize linearize maps circular strings linear strings onemany mapping circular string general mapped one linear string example dabcg assume purpose paper linearize arbitrarily chooses one linear strings convenience assume chooses representation obtained removing angle brackets linearizeabcd abcd circularize maps linear strings circular strings manyone function represents inverse linearize use lower case letters represent circular strings upper case letters represent linear strings lower case letter say used represent particular circular string corresponding upper case letter assumed linearizes single character occurring th position denoted respectively substring denoted ij j substring denoted ij j example use symbol fl denote either circular string linear string example predecessor predflij substring fl ij fl defined linear successor succflij substring fl ij fl defined fl linear fl circular immediate context contextflij substring fl ij fl ordered pair predecessor predfl ff successor succfl ff sets pattern ff string fl defined predfl g succfl g immediate context set contextflff pattern ff fl set g example string figure 1 succs pattern occurring fl said maximal iff occurrences preceded character followed character pattern ff length n fl maximal iff jpredfl ffj 2 jsuccfl ffj 2 necessarily true patterns length greater equal n example maximal since neither preceded followed character jpreds pattern said displayable entity displayable fl iff maximal occurs least twice fl note fl represents circular string pattern arbitrarily long rest discussion assume displayable entities circular strings length less n 3 scdawgs linear strings scdawg corresponding string directed acyclic graph defined set vertices v set rs labeled directed edges called right extension edges set labeled directed edges ls called left extension le edges vertex v represents substring specifically v consists source represents empty word sink represents vertex corresponding displayable entity let dev denote string represented vertex v v ffl v define implication imps ff string ff smallest superword ff fdevj v ffl v sg superword exists otherwise imps ff exist edges v 1 v obtained follows letter x sigma imps dev 1 x exists equal edge v 1 v 2 label xfl fi empty string edge known prefix extension edge le edges v 1 v obtained follows letter x sigma imps xdev 1 exists equal dev 2 gabcde de e de c abc bc de gabcde fabcgabcde gabcde fabcgabcde cde sink abc c source figure 2 scdawg edges shown le edge v 1 v 2 label flx fi empty string edge known suffix extension edge figure 2 shows v srs corresponding cde c displayable entities two edges vertex representing abc correspond g impsabcd consequently edges incident sink edges corresponding letters alphabet impsabcx exist x ffl fg notice number edges vertex v equals jsuccs dev f1gj number le edges equals jpreds dev f1gj example number right edges leaving vertex corresponding 1 space required scds time needed construct 7 6 defined scdawg data structure single string extended represent set strings 6 4 extension circular strings section 41 present constructive definition scdawg circular strings section 42 analyzes complexity algorithm section 41 construct scdawg circular string section 43 identifies proves properties scdawg 41 scdawgs circular strings notion scdawg may extended circular strings scdawg circular strings defined constructively algorithm figure 3 scdawg circular string obtained first constructing scdawg linear string linearizes bit associated edge rt indicating whether prefix extension edge similarly bit associated le edge lt identify suffix extension edges two pointers suffix pointer prefix pointer associated vertex v v suffix prefix pointer points vertex w v dew largest suffix prefix dev represented vertex v suffix prefix pointers reverse suffix prefix extension edges derived figure 4 shows scdt cabcbab broken edge vertex c vertex abc suffix extension edge solid edge vertex ab vertex abc prefix extension edge next step 2 suffix prefix redundant vertices scdt identified suffix prefix redundant vertex vertex v satisfies following properties v exactly one outgoing le edge vertex said redundant either prefix redundant suffix redundant figure 4 vertex c prefix redundant vertex ab suffix redundant vertices figure redundant particular vertex representing redundant even though one one le edge n fact step 2 fact identify redundant vertices established later vertices scdt processed reverse topological order step 3 redundant algorithm step1 construct scdt fidentify suffix redundant verticesg v 6 source begin v exactly one outgoing edge mark v suffix redundant else exit step 2a fidentify prefix redundant verticesg fsimilar step 2 ag step3 v source begin case v suffix redundant prefix redundant processsuffixredundantv prefix redundant suffix redundant processprefixredundantv suffix redundant prefix redundant processbothredundantv redundant fdo nothing figure 3 algorithm constructing scdawg circular string tss c cabcbab cabcbab cabcb abcbab c bab cabcb c c ab cabc abcbab bab ab c c ab c abc ab figure 4 scdt tcabcbabcabcbab procedure processsuffixredundantv 1 eliminate left extension edges leaving v least two 2 exactly one right extension edge e leaving v let vertex leads w let label right extension edge xfl delete edge 3 right edges incident v updated point w labels modified represent concatenation original labels xfl 4 left edges incident v updated point w labels modified however suffix extension edges bit indicates reset edges longer suffix extension edges 5 delete v figure 5 algorithm processing vertex suffix redundant vertices eliminated vertex eliminated edges incident tofrom redirected relabeled described figures 5 10 resulting graph cscds set vertices cscds denoted cv set right left edges denoted crs cls figure 11 shows cscds notice vertices c ab eliminated two incoming edges c three incoming edges ab figure 4 point abc ul ur ur ul u u figure procedure processprefixredundantv 1 eliminate right extension edges leaving v least two 2 exactly one left extension edge e leaving v let vertex leads w let label left extension edge flx delete edge 3 left edges incident v updated point w labels modified represent concatenation flx original labels 4 right edges incident v updated point w labels modified however prefix extension edges bit indicates reset edges longer prefix extension edges 5 delete v figure 7 algorithm processing vertex prefix redundant ul ur ur ul u u figure 8 v prefix redundant procedure processbothredundantv 1 exactly one right extension edge e 1 leaving v let vertex leads w 1 let label edge xfl delete edge 2 exactly one left extension edge e 2 leaving v let vertex leads w 2 let label edge flx delete edge fwe establish later w 1 w 2 fact vertexg 3 right edges incident v updated point w 1 labels modified represent concatenation xfl edges prefix edges bit indicates reset 4 similarly left edges incident v updated point w 2 labels modified represent concatenation flx edges suffix extension edges bit indicates reset 5 delete v figure 9 algorithm processing vertex prefix suffix redundant e l l l fiy e r l r xfl e l l l ul ur ur ul u u figure 10 v suffix prefix redundant lemma 1 every substring ij length n exists substring lm ij contextt proof case case subcase contexts subcase subcase possible since length corollary 1 every pattern ff length n contexts ff contextt ff corollary 2 every pattern ff length n preds ff predt ff succs ff substring 6 1 substring lm ij preds l proof result follows definition predt choose lm length ij greater n lm assumed wrap around preds l corollary 3 every pattern ff length n predt theorem 1 every pattern ff length less n preds proof corollary 2 preds ff predt ff preds ff f1g predt ff f1g hence preds ff predt ff f1g since preds ff contain cabc ab tss source abcbab cabcb cabcbab cabcbab bab c c c abc abc abc figure 11 scdawg 1 corollary 3 preds ff predt ff f1g preds f1g proof succs theorem 2 vertex v jdevj n v non redundant iff dev displayable entity proof suppose ff displayable entity jpreds ffj 2 jsuccs ffj 2 theorem 1 jpredt 2 ff displayable entity corresponding vertex v least two le two edges leaving hence v redundant next suppose non redundant vertex v scdt dev since v redundant jpredt 2 theorem 1 jpreds ffj 2 jsuccs ffj 2 ff displayable entity scorollary 4 redundant vertex v displayable entity lemma 3 vertex v v exactly one le edge dev suffix prefix b vertex v dev jdevj n suffix prefix one le edge vertex w dew suffix prefix dev suffix prefix redundant proof suppose dev suffix 1 element succt dev 2 v least two edges contradiction hence dev must suffix b since dew suffix dev successor dev must also successor dew dev least two edges w must least two edges cannot suffix redundant 2 show step 2a algorithm identifies suffix redundant vertices sufficient examine vertices corresponding suffixes lemma 3a step 2a follows chain suffix pointers starting sink vertex chain representing displayable entity length n one edge marked suffix redundant traversal chain terminates either source reached vertex one edge encountered lemma 3b similarly step 2b identifies prefix redundant vertices v 42 complexity analysis worst case traverse vertices scdt spending o1 time number vertices bounded 6 step 2 takes time step 3 traverses scdt vertex processed edge processed twice incoming edge vertex currently processed edge vertex currently processed step 3 takes time note scdt edges 43 properties cscds define implication imps ff string ff respect cscds smallest superword fifffl ff represented vertex cv exist substring fi 1 fffl 1 length least common suffix less minjfij length least common prefix lcpfl less minjflj jfl 1 j superword exists otherwise imps ff exist additional condition referred uniqueness condition imposed imps ff guaranteed impt ff definition scdt smallest set superword displayable entities abc superword displayable entity abc superword element r des abc must one elements r jlcsb abc neither babcaa cabcaa since jlcsaaaa aaj abcaaaa lemma 4 let v suffix prefix redundant vertex scdint scdint represents intermediate configuration scdt cscds statement step 3 algorithm let le edges incident w 1 w 2 respectively dew 1 redundant w proof case 1 jdew 1 cannot nil w 1 prefix redundant since jdew 1 j n occurrences dev except prefix preceded similarly must form fi 3 ydevxfl 1 since letter precedes dev similarly dew 2 must form fi 2 ydevxfl 3 show fi assume case since jdew 1 redundant least 2 must exist displayable entity fi ydevxfl fi largest common suffix fi 3 fi 2 fl largest common prefix fl 1 fl 3 fi dev dev dev dev642s figure 12 illustration proof prefixsuffix redundancy invariant imps ydev contradicts statements made case 2 jdew 1 j n cannot nil otherwise w 2 suffix redundant dew 2 x letter follows dev arguments similar case 1 show since jdew 2 j must prefix fl 3 fi 1 suffix fi 2 contradiction hence case 2 cannot exist case 3 jdew 2 j n similar case 2 case 4 jdew 2 j n figure 12 shows case occur prefixsuffix redundancy invariant figure assumes jdew 1 dev prefix dew 1 jdevj n2 divides n however prefixsuffix redundancy invariant shown true cases two copies shown figure first copy shades occurrence n dev ff 2m ff vertices ff ff ff ff ff ff ff ff ff figure 13 scdff 2m extension dew 1 second shades occurrence n1 n jdevj extension dew 1 since shaded regions strings represent next assume without loss generality fi call smallest repetition assumption occurrences ff 1 jffj jffj1 2jffj gamma 1ff1 2n argument similar one figure 12 contradicts smallest repetition assumption takes form figure 13 vertex representing ff exactly one le one edge shown remaining displayable entities subwords ff 2 size less jffj argument identical one figure 12 contradicts smallest repetition assumption vertices representing displayable entities represented box figure 13 none vertices box edges incident vertices representing displayable entities g particular edges vertices box incident vertices representing displayable entities length greater n 2m processed algorithm incoming edges vertices corresponding ff ff 2 scdff 2m incident vertex corresponding cscdff 2m follows prefix suffix redundant vertex scdff 2m processed step 3 algorithm edges incident w 1 w 2 least n dew 1 properties p1 p2 p3 stated theorem 3 properties ensure algorithms 5 extended circular strings consists source sink v cv source sink following true jdevj n iff dev displayable entity b jdevj n dev displayable entity exists edge corresponding letter x sigma vertex v 1 cv vertex exists equal dev 2 dev 2 label edge xfl edge prefix extension edge 3 similar p2 le edges theorem 3 cscds satisfies p1 p2 p3 proof property p1 established knowledge scdt contains displayable entities algorithm eliminates displayable entities length less n displayable entities corollary 4 p2 p3 proved induction induction hypothesis let u subset u remains vertex set u v processed step 3 algorithm let rus set edges incident vertices u edge r ffl rus vertex u w label xfl imps condition holds le edges ii vertex u u edge corresponding letter x succt incident vertex u condition holds le edges u definition r cv establishes edges incident correct vertices labels correct ii establishes crs complete p2 holds similarly p3 holds induction base u fg rus lus empty apply ii established definition scdt induction step consider vertex v v ffl v processed step 3 algorithm let u 0 u 0 denote u u respectively v processed must show ii hold u 0 u 0 since vertices processed reverse topological order edges v incident vertices u therefore elements rus lus must satisfy case 1 v redundant u 0 since v eliminated must show true incoming edges v additions rus lus ie r u 0 fincoming right edges vg l u 0 fincoming left edges vg let e edge label xfl u v definition scdt smallest superword deux fdewjw ffl v g since cv sg true since v ffl cv symmetric argument made incoming le edges v letter alphabet le edge corresponds first last character label since edges added deleted redirected labels edges unchanged vertex rele edge corresponding letter alphabet prior processing vertex v ii holds induction hypothesis case 2 v redundant u 0 since v eliminated subcase v suffix redundant definition v consists single edge e vertex w u let labele xfl induction hypothesis imps first establish ii dev prefix dew imps dev 6 dev v redundant imps dev must correspond vertex one edges v incident since edge corresponding element preds dev succs dev ii single edge incident w represents imps devx left edges v incident vertices represent imps x dev 2 definition imps dev none vertices possibly represent imps dev instance imps x dev imps dev string imps x j dev 6 j would invalidate definition imps dev must dew however true must show nil therefore dev prefix dew occurrences dev followed x jpredt 2 argument similar one previous paragraph shows imps devx exist ru 0 edge vg fincoming edges vg lu 0 edges vg fincoming le edges vg ii apply edges deleted rus lus need prove ii incoming edges v let e r edge incident v vertex ur label yfl 1 must redirected imps deu r hold impt deu r dev smallest superword deu r fdeaj ffl v g imps deu r smallest superword deu r satisfies uniqueness condition fdeaj ffl cv sg fdeaj ffl v g since v imps deu r smallest superword dev satisfies uniqueness condition fdeaj ffl cv sg imps deu r xfl updated edge e r incident w label yfl 1 xfl obtained step 3 algorithm concatenating continues prefix extension edge e r satisfies let e l le edge incident v ul z using argument used e r imps zdeu l redirected w label remains unchanged clearly e l longer suffix edge even fi notice ii continues satisfied edge corresponding vertex u 0 continues associated character particular labele r continues begin labele l continues end z edge continues leave vertex particular e r continues leave ur e l continues leave ul subcase b v prefix redundant symmetric subcase subcase c v prefix suffix redundant v one edge e 1 vertex w 1 cv let labele 1 also v one le edge e 2 vertex w 2 induction hypothesis dew 1 imps conditions lemma 4 satisfied since w 1 w 2 redundant otherwise would eliminated thus dew 1 imps dev either imps devx imps ydev expressions equal dew imps proof ii satisfied similar subcase note however incoming prefixsuffix extension edges v longer remain prefixsuffix extension edges xfl fiy nil 2 computing occurrences displayable entities procedure linearoccurrencess v figure 14 based outline 6 reports end position occurrence dev v ffl v linear string however invoking linearoccurrencest v v ffl cv immediately yield occurrences dev section 51 present modification obtains occurrences displayable entities section 52 show modification correct time complexity optimal 51 algorithm auxiliary boolean array reported1n used conjunction cscds initially elements array set false procedure circoccurrencess v figure 15 computes end positions dev v ffl cv linearoccurrencest v line 1 necessarily compute occurrences dev since executed cscds scdt note also occurrence dev ending position n identical occurrence ending position n occurrences correspond occurrence dev reports occurrences single corresponding occurrence dev must eventually reported lines 47 transform occurrence l necessary represents value 1 n occurrence already listed added list occurrences corresponding element reported set true occurrence listed duplicate lines 812 occurrences computed elements reported reset false lines 1415 reported subsequently reused compute occurrences displayable entity example figure 11 linearoccurrencest v v represents abc report end positions occurrences abc ie 4 8 11 lines 2 12 transform list end positions abc ie 1 4 corresponding 61 24 respectively figure shows devs dews dexs hypothetical string figure shows fragments scdawg v suffix redundant scdt single edge incident w edge x v x redundant construction edge x v scdt becomes edge x w cscds procedure linearoccurrencest x x cscds fail yield rightmost occurrence dex since occurrence neither subword dew procedure linearoccurrencessstring vvertex fobtain occurrences dev v ffl v sg procedure occurrencesslinear string vvertex iinteger begin dev suffix edge e v scds begin let w vertex e incident figure 14 obtaining occurrences displayable entity linear string procedure circoccurrencesscircular string vvertex fv vertex cscdsg 2 reported occurrence l dev 6 else 8 reportedk 9 begin add k final list occurrences 14 occurrence l dev figure 15 obtaining occurrences displayable entity circular string dev dew figure example string suffix next section show circoccurrencess x computes occurrences dex spite fact linearoccurrencest v compute occurrences dex 52 proof correctness substring assume ij suffix define immediate right extension irescdt ij ij scdt occurrence igammajfijjjflj1 displayable entity substring assume ij suffix define immediate right extension irecscdst ij ij cscds occurrence igammajfijjjflj1 displayable entity figure 16 occurrence dev corresponding suffix however represent valid substring ff figure 17 fragments scdawgs corresponding figure 16 iredawg ire occurrence said right retrievable rr scdt iff one following true rr scdt similarly occurrence said right retrievable rr iff one following true rr cscds defined occurrence ij rr cscds irecscdst ij represent substring iiirecscds ij valid substring rr cscds example figure 16 2ngammajdexffj12ngammajffj rr scdt rr cscds notice substring iff lemma 5 k 1 ire substrings proof assume exists pair substrings assuming ires defined symmetry occurrences represent displayable entity say dev definition ire n applying argument repeatedly proves lemma 2 lemma 6 rr occurrences dev v v cv scdt cscds exactly occurrences dev obtained linearoccurrencest v proof follows definition rr occurrences 2 corollary 5 occurrences pattern dev v ffl v obtained linearoccurrencest v lemma 7 occurrences dev v ffl cv jdevj n obtained proof follows corollary 5 construction cscds right edges vertices representing displayable entities size n modified rr cscds proof assume lemma false exists occurrence ij dev rr cscds clearly j 6 2n otherwise ij would rr cscds let last denote smallest value k ire k cscds ij substring last 1 must exist since ij rr let last j last denote ire last cscds ij let z vertex cv last j last corresponds case 1 last last 2n consider string 1j last length greater n two occurrences string would displayable entity length n ij last predecessor ii dez maximal occurrences followed letter vertex corresponding displayable entity would eliminated algorithm since length would n 1j last would rr cscds lemma 7 must exist one occurrence string represented ij last string proper suffix dez means one occurrences preceded character two occurrences string leads contradiction case 2 last 2n proof similar one case 1 2 lemma 9 least one two occurrences ij injn dev ffl cv rr cscds proof assume lemma false let last smallest value k either substring let last cscds ij q last cscds injn case 1 ire last cscds ij substring ire last cscds injn substring ie rr cscds since q j q satisfies conditions lemma 8 case 2 ire last cscds ij substring ire last cscds injn substring symmetric case 1 case 3 ire last cscds ij substring ire last cscds injn substring 5 shown cause contradiction argument similar one lemma 8 2 theorem 4 procedure circoccurrencessv correctly obtains occurrences dev shows linearoccurrencest v computes rr occurrences dev cscds lemmas 8 9 show occurrence dev least one corresponding occurrence rr cscds circoccurrences computes occurrences transforms represent occurrences removing duplicates output list occurrences dev 2 theorem 5 procedure circoccurrences optimal proof procedure circoccurrencess v takes ojocct vj time jocct vj number occurrences dev loop takes ojocct vj time number occurrences dev complexity ojoccs vj joccs vj size output algorithm optimal 2 6 computing conflicts efficiently 4 defines concept conflicts explains importance analysis visualization strings formally subword conflict two displayable entities 1 2 exists iff 1 substring 2 ii prefixsuffix conflict two displayable entities 1 2 exists iff exist substrings p sms occurs p string sm known intersection conflict conflict said occur 1 2 respect sm 4 also identified number problems relating computation conflicts linear string 5 presented efficient algorithms problems listed next section algorithms typically involve sophisticated traversals operations scdawg linear strings extension scdawgs circular strings makes possible use algorithms solve corresponding problems circular strings minor modifications outlined conceptually two kinds traversals algorithms 5 perform scdawg corresponding linear string traversal displayable entities string traversals vertex traversed specifically represents displayable entity string ii incidental traversals traversals vertex traversed displayable entity performs function example includes vertices traversed linearoccurrencest v traversals type cscds required traverse vertices represent displayable entities size greater equal n may achieved simply disabling edges cscds leave vertex representing displayable entity size less n incident vertex representing displayable entity size greater equal n traversals type ii however may required traverse vertices representing displayable entities size greater equal n achieved associating bit edge set 1 represents edge vertex whose displayable entity size less n vertex whose displayable entity size greater equal n otherwise set 0 type traversals check bit type ii traversals ignore finally calls linearoccurrences replaced calls circoccurrences 7 queries section list queries system visualization analysis circular strings would support 5 contains algorithms queries linear strings previous section showed algorithms could modified support queries size restricted queries experimental data show random strings contain large number displayable entities whose lengths small applications small displayable entities uninteresting hence useful list displayable entities whose lengths greater integer k similarly useful report exactly conflicts conflicting displayable entities length greater k gives rise following problems 1 list occurrences displayable entities whose length greater k 2 compute prefix suffix conflicts involving displayable entities length greater k 3 compute subword conflicts involving displayable entities length greater k alternative formulation problem also seeks achieve goal outlined based reporting conflicts whose size greater k size conflict defined overlap conflict defined string common conflicting displayable entities overlap subword conflict subword displayable entity overlap prefixsuffix conflict intersection size conflict length overlap formulation problem particularly relevant conflicts interest displayable entities also ensures conflicting displayable entities reported size greater k following problems 4 obtain prefixsuffix conflicts size greater integer k 5 obtain subword conflicts size greater integer k pattern restricted queries queries useful applications fact two patterns conflict important number location conflicts following problems arise result list pairs displayable entities subword conflicts list triplets displayable entities 1 2 dm prefix suffix conflict 1 2 respect dm 6 size restricted 5 7 size restricted 4 statistical queries queries useful conclusions drawn data based statistical facts 10 pair displayable entities 1 2 involved subword conflict 1 subword 2 obtain number occurrences 1 occur subwords 2 number occurrences 1 11 pair displayable entities 1 2 involved prefixsuffix conflict number occurrences 1 prefixsuffix conflicts number occurrences 1 greater statistically determined threshold following could said confidence presence 1 implies presence 2 applications circular strings may used represent circular genomes 1 g4 oex174 detection analysis patterns genomes helps provide insights evolution structure function organisms 1 analyzes g4 oex174 linearizing constructing scdawg work improves upon 1 analyzing circular strings without risking loss patterns ii extending analysis visualization techniques 5 linear strings circular strings circular strings form chain codes also used represent closed curves computer vision 11 objects figure 18a represented chain code follows 1 arbitrarily choose pixel curve passes diagram starting pixels chain code representation objects 1 2 marked arrows 2 traverse curve clockwise direction move one pixel next direction move recorded according convention shown figure 18b objects 1 2 represented 1122102243244666666666 666666661122002242242446 respectively alphabet f0 1 2 3 4 5 6 7g fixed constant size 8 therefore satisfies condition section 2 may use visualization techniques 5 compare two objects example methods would show objects 1 2 share segments s1 s2 figure 18c corresponding 0224 2446666666661122 respectively information common segments would also available techniques paper make possible detect patterns irrespective starting pixels chosen two objects circular strings may also used represent polygons computer graphics computational geometry 3 figure 19 shows polygon represented following alternating sequence lines angles bfiaffeffeffcficfiefiaffeffeffcficfibffcffdffcff ff denotes 90 degree angle fi 270 degree angle techniques paper would point instances self similarity polygon affeffeffcfic note however methods work efficiently number lines angles used represent polygons must small fixed 9 conclusions paper defined scdawg circular strings shown used solve problems visualization analysis patterns circular strings expect also used string matching applications involving circular strings important feature scdawg circular strings easy implement use corresponding techniques scdawgs linear strings already available c b starting position object 2 starting position object 16420 chain code representations directions figure representing closed curves circular strings e c c c c c c e e figure 19 representing polygons circular strings acknowledgement grateful professor gerhard ritter pointing application circular strings representation closed curves r sequence landscapes matching protein sequences using color intrasequence homology displays method detecting structure polygons string visualization computing display conflicts string visualization complete inverted files efficient text retrieval analysis smallest automaton recognizing subwords text efficient online construction correction position trees spaceeconomical suffix tree construction algorithm efficient elegant subword tree construction processing 2nd edition tr digital image processing 2nd ed complete inverted files efficient text retrieval analysis matching protein sequences using color intrasequence homology displays computer graphics principles practice 2nd ed models techniques visualization labeled discrete objects spaceeconomical suffix tree construction algorithm ctr p mehta sahni computing display conflicts string visualization ieee transactions computers v43 n3 p350361 march 1994
sort n items using sorting network fixed io size abstractsorting networks fixed io size p used thus far sorting set p elements somewhat surprisingly important problem using sorting network sorting arbitrarily large data sets addressed literature main contribution propose simple sorting architecture whose main feature pipelined use sorting network fixed io size p sort arbitrarily large data set n elements noteworthy feature design extra data memory space required used storing input turns architecture feasible vlsi implementation time performance virtually independent cost depth underlying sorting network specifically show using design n elements sorted thetafrac np log frac np time without memory access conflicts finally weshow use at2optimal sorting network fixed io size p construct similar architecture sorts n elements thetafrac np log frac nplog p time b introduction sorting networks well studied class parallel sorting devices early treatment subject see 4 12 recent surveys refer reader 2 3 7 19 22 23 general sorting networks suitable vlsi realization due part fact processing elements typically simple comparators structure network fairly regular several parameters used characterize quality sorting network cost denoted ct number constant fanin processing nodes network depth denoted dt maximum number nodes path input output work supported onr grant n000149710526 nsf grants ccr9522093 ecs9626215 louisiana grant leqsf199699rda16 department computer science old dominion university norfolk va 235290162 usa z istituto di elaborazione dellinformazione cnr pisa 56126 italy x department computer science louisiana state university baton rouge la 70803 usa example batchers classic bitonic sorting network oddeven merge sorting network 4 5 cost op log 2 p depth olog 2 p p network io size time performance sorting network number parallel steps performed usually depth network ajtai komlos szemeredi 1 proposed sorting network commonly called aks sorting network io size p depth olog p cost op log p later leighton 13 paterson 21 developed comparatorbased sorting networks io size p cost op depth olog p elements olog p time aks network costoptimal depthoptimal ie timeoptimal context sorting p elements comparator used interesting note spite fact sorting networks fixed io size p extensively investigated context sorting p elements efficient use sorting large number say n elements received much attention literature reallife applications number n input elements sorted much larger p situation sorting network must used repeatedly pipelined fashion order sort input elements efficiently assume input well partial results reside several constant port memory modules scheduling memory accesses io sorting network becomes key achieving best possible sorting performance clearly appropriate answer problem found power sorting network fully utilized problem building sorting networks smaller components psorters mergers received attention literature 7 8 15 20 bilardi preparata 8 use tree mergers various sizes sort using cubeconnected cycles nassimi sahni 15 construct sorting networks combining mergers various sizes tseng lee 25 construct sorting network io size p 2 using op layers psorters recently parker parberry 20 showed arbitrary n sorting network io size n constructed using psorters thus answering open question posed 12 related problem namely sorting n elements repeatedly using psorter received attention late 6 18 20 psorter sorting device capable sorting p elements constant time computing models psorter exist example known p elements sorted o1 time reconfigurable mesh size p theta p 11 14 16 17 reconfigurable mesh multiprocessor system processors connected bus system whose configuration dynamically changed suit computational needs beigel gill 6 showed task sorting n elements n p n log n log p calls psorter also presented algorithm sort n elements using theta n log n log p calls psorter algorithm however assumes p elements sorted psorter fetched unit time regardless locations memory since general address patterns operands psorter operations irregular appears algorithm 6 cannot realistically achieve time complexity n log n log p unless one solve constant time addressing problem realistic machines address problem olariu zheng 18 proposed psorterbased architecture allows sort n elements n log n stricly enforcing conflictfree memory accesses conjunction results 6 result completely resolves time complexity issue sorting n elements using psorter turns psorter much expensive device sorting network use avoided whenever possible besides clear whether possible replace psorter pipelined sorting network architecture 18 guaranteeing performance main contribution work propose simple sorting architecture whose main feature pipelined use sorting network fixed io size sort arbitrarily large number n elements specifically show using design n elements sorted log n design consists sorting network fixed io size p set prandom access memory modules control unit memory access patterns regular one step elements two rows memory modules supplied input sorting network andor output sorting network written back two memory rows architecture feasible vlsi implementation show use 2 optimal sorting network fixed io size p construct similar architecture sorts arbitrary number n elements theta n log n time important feature architectures extra data memory space required needed storing input remainder paper organized follows section 2 discuss details proposed architecture section 3 show obtain rowmerge schedules critical ingredient efficiency design section 4 extends results sections 2 3 showing use 2 optimal sorting network fixed io size p obtain architecture log n finally section 5 offers concluding remarks poses number open problems 2 architecture sorting network modeled directed graph whose nodes represent processing elements whose edges represent links connecting nodes illustrated figure 1 processing elements simple comparators complex processors capable performing arithmetic operations comparator two inputs two outputs used perform compare exchange operation comparatorbased sorting network sorting network whose processing elements comparators remainder work use term sorting network refer exclusively comparatorbased sorting network figure 1 figure 2 illustrate batchers classic sorting networks io size 8 illustrated figure 1 two types comparators used type 0 comparator smaller larger two input numbers emerge comparison top bottom output respectively comparator type 1 produces output reverse order unless stated otherwise assume sorting network fixed io size p used sort p elements comparators used exactly figure 1 bitonic sorting network io size 8 figure 2 oddeven merge sorting network io size 8 referring figures 1 2 say sorting network layered comparators assigned one ds layers l k 1 k ds follows ffl assign layer l 1 comparators whose inputs outputs comparators network exclude consideration ffl every k 2 k ds assign layer l k comparators whose inputs outputs comparators layers l layer l j 1 exclude consideration simple inductive argument shows every k 2 k ds every comparator layer k receives least one input comparator layer l kgamma1 therefore layered sorting network longest paths network input comparators layer l k must length say sorting network pipelined every k 2 k ds paths network input comparators layer l k length 1 illustration bitonic sorting network shown figure 1 pipelined network whereas oddeven merge sorting network figure 2 intuition terminology pipelined sorting network io size p used sort sets p elements concurrently pipelined fashion easy confirm pipelined network layer contains exactly pcomparators context shall refer layers stages denote 1 given sorting network one always introduce additional buffer nodes latches nec essary way nodes resulting network comparators latches partitioned stages 1 specifically every k 1 k ds place comparators layer l k k one two inputs comparator c layer l k output comparator c 0 layer l sequence latch nodes l 0 edge c 0 c l 0 j stage ij output comparator c layer k k ds also output network add latch nodes output edge reader difficulty confirming resulting network paths network input nodes layer length thus transformation converts nonpipelined network pipelined one example adding latches oddeven merge sorting network figure 2 obtain network shown figure 3 proposed architecture call rowmerge architecture rma short illustrated figure 4 8 rma involves following components pipelined sorting network fixed io size p inputs 1 outputs ii pconstantport memory modules pcollectively referred data memory every k 1 k p memory module k connected inputs k p k outputs k p 2 k sorting network 1 length path taken number edges path figure 3 oddeven merge sorting network latches added i12 3 control unit sorting memory modules network figure 4 rowmerge architecture iii control unit cu consisting control processor cp control memory words local address memory modules collectively referred memory row n input elements stored evenly possible 2n consecutive memory rows dummy elements value 1 added necessary ensure memory modules contain number elements dummy elements removed sorting readwrite operations carried single instruction address stream multiple data stream fashion controlled cu specifically cu responsible generating memory access addresses every step address broadcast memory modules use local address current read write operation assume address broadcast operation takes constant time cu disable memory readwrite operations necessary appropriately using mask operating pipelined fashion generic step p elements two memory rows fed sorting network end step sorted sequence p elements two rows emerges output ports written back two memory rows process continued input elements sorted simplify analysis assume one memory cycle sufficient reading writing comparator operations assumption reasonable memory module say two ports reading two ports writing memory module one port reading writing performance degrades small constant factor let b ordered pair memory rows data memory process sorting elements memory row resp b read left resp right half network input corresponding elements sorted nondecreasing order finally left resp right half resulting sorted sequence emerging network output written back data memory replace original row resp b clear refer design rowmerge architecture order efficiently sort 2n memory rows rma wish identify finite sequence ms pairs memory rows following sequence elements sorted rowmajor order call sequence ms rowmerge schedule simply merge schedule time reader may wonder power rma theorem 1 provide partial answer question establishing lower bound time required algorithm sorts n elements using rma theorem 1 algorithm correctly sorts n elements rma using sorting network io size p must log n proof ignore time delay caused depth sorting network consequently assume sorting network takes o1 time sort group p elements assumption reasonable since help algorithm show even favorable assumption sorting algorithm must take omegagamma n log n purpose need exhibit particular sequence n memory rows algorithm operating rma log n consider arbitrary sequence real numbers stored array a1 2n every 2n memory rows assumed every p p words memory row equal consider arbitrary merge schedule ms correctly sorts resulting 2n memory rows ms construct algorithm b comparison tree model sorts array idea algorithm b simulates actions ms set memory rows precisely ms sorts memory rows j algorithm b compares necessary interchanges entries ai aj assume merge schedule ms sorts 2n memory rows n log n time simulation described implies algorithm b sorts array n log n impossible lower bound sorting 2n elements comparison tree model log n completes proof theorem 2 generating rowmerge schedules order sort n input elements correctly efficiently rma need find merge schedule ms guide computation ms specifies left right order pairs memory rows supplied input sorting network pipelined fashion example ordered pair supplied first time unit followed ordered pair second time unit reasons discussed later interested merge schedules satisfy following three conditions 1 rma must sort correctly psorter used instead sorting network sorting networks depth one 2 row number appears subsequence ms 3 length ms close possible omegagamma n log n p time lower bound sorting rma psorter perceived sorting network io size p depth dt therefore condition 1 necessary condition correctly sorting n elements general condition 2 violated ms may guide pipelined operations correctly sort n elements possible data dependencies see consider pairs memory rows updated possible element originally row duplicated rows b row b ij element originally row b row b ij lost condition 3 impacts time performance present general framework generating rowmerge schedules central idea approach motivated following wellknown fact mentioned 9 12 p 241 proposition 1 parallel algorithm using compareexchange operations sorting elements processors corresponding algorithm sorting rm elements processors every comparison first algorithm replaced mergesorting two lists r elements second later reference refer proposition 1 compareexchangemergesplit principle let sorting network io size knuth 12 suggested representing way shown figure 5b specifically horizontal lines labeled integer left right endpoints line labeled represent respectively ith input ith output network comparator represented directed vertical segment originating line ending line j causes interchange inputs necessary smaller number appears line larger number appears line j call representation line representation memory row 1 memory row 2 memory row 4 memory row 3 memory row 5 memory row 6 memory row 7 memory row 8 b figure 5 illustrating correspondence memory address space b line representation network sorting network shown figure 1 constructing line representation sorting network io size graph representation straightforward perceive comparator 2 theta 2 switch two states straight cross assign input value network input 1 set switches comparators straight state input values propagate switches values j k received switch define corresponding vertical segment endpoints lines j k line representation type corresponding comparator determines direction vertical segment figure 6 illustrates propagation process network figure 1 pair integers arrow input comparator define directed vertical line segment line representation shown figure 5b figure illustrating method obtaining line representation network figure 1 assume n elements sort located memory rows 1 generate merge schedule ms line representation layer partition following greedy algorithm initially inputs comparators unmarked let c 1 arbitrary fifo first firstout queue comparators level l 1 obtain fifo queue c i1 comparators level l i1 follows set c i1 empty scan comparator queue c order comparator c mark two output edges soon two input edges comparator c marked include c layer c i1 point reader fail note comparator c must indeed belong layer l i1 process continued described c constructed finally concatenate c j obtain sequence c comparators c precedes c i1 ks cs sequence comparators obtained using greedy algorithm described comparator c k j whose corresponding directed vertical segment originates line j ends line b j line representation associate ordered pair ms resulting sequence ordered pairs corresponding c consider correspondence data memory line representation horizontal line corresponds memory row compareexchangemergesplit principle proposition 1 know elements memory sorted rowmajor order merge rows sequentially following merge schedule ms figure 5 illustrates correspondence data memory four modules eight words per module ie line representation network figure 1 applying greedy algorithm shown figure 1 obtain following merge schedule bitonic sorting network io size assuming even exactly mcomparators per layer shown shortly n pdt ms generated greedy algorithm bitonic sorting network io size satisfies conditions 1 2 therefore used correctly sort n elements rma however exist sorting networks cannot used generate merge schedule satisfies condition 2 fact restricts applicability ms generating scheme example ms generated directly network featured figure 7 satisfy condition 2 remedy problem introduce concept augmenting sorting networksl figure 7 line representation variant bubble sort network given arbitrary sorting network io size augmented sorting network 00 io size derived obtained follows ffl transform pipelined network 0 adding latches described section 2 ffl group latches layer 0 pairs arbitrary way replace pair latches dummy comparators odd delete remaining latch stage network obtained end simple algorithm desired augmented sorting network 00 clearly layer 00 exactly b comparators distinguished real comparators dummy comparators represented node labeled vertical line segment without arrow graph line representation respectively illustration augmented network oddeven sorting network shown figure 2 given figure 8 still use greedy algorithm generate ms augmented network 00 comparator selection process exactly described however task translating comparator sequence corresponding ms slightly modified accommodate dummy comparators translate comparator sequence ks ms dummy comparator order two row numbers involved arbitrary use ms generated augmented network 00 write operations step dt disabled corresponds dummy comparator 00 note possible since specified section 2 architecture supports masked write operations operating fashion ms generated augmented network 00 clearly satisfies condition 1 compareexchangemergesplit principle propositions 1 shall prove theorem 2 ms also satisfies condition 2 length ms cost sorting network using ms generated 00 depth 00 increased cost compared note first would seem though using 00 derive ms condition 3 satisfied however sorting networks io size known authors including network featured figure 7 omds cost therefore cost 00 within constant factor cost summarize findings state prove following important result theorem 2 let sorting network io size 2np let sorting network io size p n pdt merge schedule obtained augmented network greedy algorithm used correctly sort n elements rowmerge architecture sorting device n dummy comparators introduced convenience amount nooperation figure 8 augmented oddeven merge sorting network proof need show n pdt ms generated augmented network 00 satisfies condition 2 let ms arbitrary merge schedule corresponding comparator sequence ks generated 00 greedy algorithm conceptually treat network 00 datadriven ie dataflow architecture processing elements precisely comparators whose activation driven data availability say comparator c ready activation whenever two inputs available yet used prove theorem need show j comparators preceding c k j used c k j yet used comparators subsequence ready activation let jl j denote number comparators layer l similarly let jc j stand length subsequence c constructed comparators l greedy algorithm clearly c initially exactly b n c comparators c 1 ready activation consider arbitrary j 1 comparators preceding c k j used c k j ready activation suppose c k j rth comparator c number comparators c ready activation clearly jl 1 since first comparators c provides two inputs comparators layer l i1 since comparator l i1 receives least one inputs comparator layer l follows least first r gamma 1 comparators c i1 ready activation therefore total number consecutive comparators starting c k j c least jl j least b n remaining comparators c starting c k j ready activation b n b n c input comparator c ks depend output comparators c k tgammadt c proved ms used merge schedule network note also previous discussion time required sort n elements os cost 00 bounded omds completes proof theorem 2 note theorem 2 following important implications sorting network whose depth dt satisfies n pdt used sort correctly n elements pipelined fashion b n p 2 sorting network depth larger p used since depth practical sorting networks io size p smaller p networks used rma important note implies performance rma virtually independent sorting network used sorting device c n p 2 rowmerge schedule generated augmented network network greedy algorithm used sort n elements correctly words correctness merge schedule independent sorting network used generate time required sorting n elements proportional ds depth select wide range sorting networks depending vlsi feasibility also wide range sorting networks choose deriving merge schedules know depth bitonic oddeven merge sorting network io size olog 2 thus using either derive merge schedule n elements sorted n log 2 n time well known depth aks sorting network io size bounded olog hence using aks network n elements sorted n log n therefore take note following extension theorems 1 2 theorem 3 rowmerge architecture uses sorting network io size p depth p sorting device sort n elements n p theta n log n best knowledge known sorting networks including aks network defined recursively graph representations recursively defined sorting networks constructed linear time given graph representation sorting network io size 2n estimate time takes cu generate ms comparators first layer easily identified next nodes divided ds layers described section 2 clearly process takes ocs time scanning nodes layer layer latches added convert pipelined network 0 n time employing layerbylayer scan nodes 0 pairs latches layer combined dummy comparators obtain augmented network 00 process takes n time easy see task constructing line representation 00 graph representation 00 also carried n time finally greedy algorithm performed 00 algorithm essentially breathfirst search running n time hence total time generating ms network bounded n interesting note even ms schedule available rma needs n time complete task sorting n elements thus time takes cu compute ms time needed network perform sorting perfectly balanced words time complexity claimed theorem 3 also holds computation required generating ms taken account important note available ms used sort many problem instances working space requirement control memory proportional mds words olog n bits rather remarkably rma require extra data memory space used storing input 4 generalized rowmerge architecture number contexts especially vlsi complexity concern desirable use 2 optimal network parallel sorting device main goal section show possible design sorting architecture uses 2 optimal sorting network parallel sorting device turns time performance new design call generalized rowmerge architecture grma short slightly better rma discussed section 2 grma uses sorting network fixed io size p inputs 1 outputs p constantport data memory modules collectively referred data memory every k 1 k p memory module k connected input k output k one parallel read operation one memory row read supplied input one parallel write operation output written back one memory row like rma memory accesses operation sorting network controlled control unit cu however three major differences grma rma grma p memory modules rather pmemory modules b sorting network sort odt memory rows rowmajor order odt c simplicity assume grma operates different pipelining mode rma specifically group r memory rows fed network r consecutive time steps sorting r rows written back memory r consecutive time steps another group r memory rows fed network process repeated elements groups r memory rows sorted value r proportional depth dt note changing control mechanism grma also operate fully pipelined mode ie network fed continuously select leightons optimal sorting network 13 known 2 optimal network hardware implementation well known columnsort algorithm io size q log q depth c log q c constant greater 1 two designs proposed 13 one value c significantly smaller leightons sorting network sorts array size log q theta q log q rowmajor order pipelined fashion specifically first log q steps q log q elements fed network c log q steps elements emerge sorted output network log q consecutive steps let q log q partition n memory rows log q superrows containing log qconsecutive memory rows ith superrow consists memory rows log q 1 log q operation grma partitioned iterations two superrows sorted iteration iteration consists two phases ffl feeding phase two superrows contains log q memory rows fed continuously sorting network ffl clearing phase elements sorting network drained let b ordered pair superrow numbers procedure merge two superrowsa b whose details given figure 9 performs mergesplit operation superrows b use layered sorting network size log q obtain merge schedule ms list comparators layer l concatenate lists obtain sequence c comparators c precedes c i1 let ks cs sequence comparators obtained based c line representation obtain merge schedule ms guided ms sorting process proceeds nonoverlapping iterations consisting call procedure merge two superrowsa b perform mergesplit operation two superrows specified ms compareexchangemergesplit principle grma sorts n elements correctly since iteration takes olog q time task sorting n elements grma using ms procedure merge two superrowsa b begin feeding phase log qdo read row agamma1 log q feed row input endfor log qdo read row bgamma1 log q feed row input endfor idling log q noop clearing phase log q write output row agamma1 log q endfor log q write output row bgamma1 log q endfor figure 9 procedure merge two superrows takes clog qs time using layered aks network obtain valid ms length n log q log n log q used sort n elements grma takes n log n log q n log n log p time argument similar used proof theorem 1 shows every algorithm sorts n elements grma requires log n summarize findings state following result theorem 4 generalized rowmerge architecture uses 2 optimal network io size p parallel sorting device sorts n elements n op log p theta n log n notice case grma computation merge schedule require augmented network length merge schedule somewhat shorter using network smaller io size depth without dummy comparators extra data memory required used storing input 5 conclusions open problems main motivation work provided observation sorting networks fixed io size p used sort set p elements reallife applications however require sorting arbitrarily large data sets rather surprisingly important problem using fixed io size sorting network context addressed literature main contribution propose simple sorting architecture whose main feature pipelined use sorting network fixed io size p sorting arbitrarily large data set n elements noteworthy feature design require extra data memory space used store input turns time performance design call rowmerge architecture rma virtually independent cost depth underlying sorting network specifically showed using rma n elements sorted theta n log n memory access conflicts addition showed use 2 optimal sorting network fixed io size p construct similar architecture termed generalized rowmerge architecture grma sorts n elements theta n log n point know whether better performance achieved removing restriction rigid memory access scheme rma allowing flexible yet regular memory access patterns case time lower bounds rma grma longer hold results 6 indicate n elements cannot sorted less n log n log p time using parallel sorting device io size p interesting open question close gap lower bound time performance offered designs best performance designs proposed paper proportional depth aks network used construct merge schedules constant associated depth complexity aks network large considered practical however results reveal potential rowmerge based simple sorting architectures along line thought longstanding open problem obtain realistic sorting network logarithmic depth equally important discover network depth c log log log network io size c small constant networks useful deriving practically short merge schedules r sorting c log n parallel steps parallel sorting algorithms parallel computation bitonic sorting networks sorting p objects ksorter taxonomy parallel sorting minimum area vlsi network olog n time sorting optimal sorting algorithms parallel computers optimal vlsi circuits sorting optimal sorting algorithm reconfigurable mesh art computer programming tight bounds complexity parallel sorting sorting o1 time reconfigurable mesh size p parallel permutation sorting algorithms new generalized sorting network sorting p numbers p new deterministic sampling scheme applications broadcast efficient sorting reconfigurable mesh sorting n items using psorter optimal time current progress efficient sorting networks constructing sorting networks ksorters improved sorting networks olog n depth parallel sorting bibliography acm sigact news bibliography parallel sorting vlsi complexity sorting parallel sorting scheme whose basic operation sorts n elements tr ctr stephan olariu cristina pinotti si qing zheng optimal hardwarealgorithm sorting using fixedsize parallel sorting device ieee transactions computers v49 n12 p13101324 december 2000 giuseppe campobello marco russo scalable vlsi speedarea tunable sorting network journal systems architecture euromicro journal v52 n10 p589602 october 2006 classifying matrices separating rows columns ieee transactions parallel distributed systems v15 n7 p654665 july 2004 shunwen cheng arbitrary long digit integer sorter hwsw codesign proceedings conference asia south pacific design automation january 2124 2003 kitakyushu japan
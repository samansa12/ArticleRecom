optimal algorithm anglerestricted nearest neighbor problem reconfigurable mesh applications abstractgiven set n points plane two directions r1 r2 anglerestricted nearest neighbor problem arann short asks compute every point p nearest point lying planar region bounded two rays directions r1 r2 emanating p arann problem generalizes wellknown ann problem finds applications pattern recognition image processing computational morphology main contribution present algorithm solves instance size n arann problem o1 time reconfigurable mesh size nn algorithm optimal sense omegan2 processors necessary solve arann problem o1 time using arann algorithm provide o1 time solutions tasks constructing geographic neighborhood graph relative neighborhood graph n points plane reconfigurable mesh size nn also show somewhat stronger reconfigurable mesh size ntimes n2 euclidean minimum spanning tree n points computed o1 time b introduction recently effort enhance power flexibility meshconnected architecture endowed various reconfigurable features examples include bus automaton 21 22 reconfigurable mesh 15 mesh bypass capability 8 content addressable array processor 29 reconfigurable network 2 polymorphic processor array 13 14 reconfigurable bus shift switching 11 gatedconnection network 23 24 polymorphic torus 9 10 among reconfigurable mesh emerged attractive versatile architecture essence reconfigurable mesh rm consists mesh augmented addition dynamic bus system whose configuration changes response computational communication needs precisely rm size n theta consists nm identical simd processors positioned rectangular array n rows columns usual assumed every processor knows coordinates within mesh let p denote processor placed row column j p 1 1 northwest corner mesh processor p j connected four neighbors p gamma p exist 4 ports denoted n e w figure 1 local connections ports established program control creating powerful bus system changes dynamically accommodate various computational needs assume setting local connection destructive sense setting new pattern connections destroys previous one results paper assume model allows two connections set processor one time furthermore two connections must involve disjoint pairs ports illustrated figure 2 models proposed literature allow two connections set every processor 9 10 one results uses model accord workers 9 10 1316 21 assume communications along buses take o1 time although inexact recent experiments yuppie gcn reconfigurable multiprocessor system 16 23 24 seem indicate reasonable working hypothesis worth mentioning least figure 1 reconfigurable mesh size 4 theta 5 figure 2 examples allowed connections corresponding buses two vlsi implementations performed demonstrate feasibility benefits twodimensional reconfigurable mesh one yuppie yorktown ultraparallel polymorphic image engine chip 9 10 16 gcn gatedconnection network chip 23 24 two implementations suggested broadcast delay although constant small example 16 machine cycles required broadcast 10 6 processor yuppie gcn shortened delay adopting precharged circuits newer developments seem suggest feasibility implementations involving emerging optical technology one fundamental features contributes perceptionally relevant description useful shape analysis distance properties among points planar set context nearest furthestneighbor computations central pattern recognition classification techniques image processing computer graphics computational morphology 4 20 26 27 image processing example proximity simple important metric potential similarities objects image space pattern recognition concept appears clustering computing similarities sets 4 mor phology closeness often valuable tool devising efficient algorithms number seemingly unrelated problems 26 classic problem domain involves computing every point given set point closest problem known allnearest neighbor problem ann short well studied sequential parallel 1 4 20 26 recently jang prasanna 5 provided o1 time algorithm solving ann problem n points plane rm size n theta n paper address generalization ann problem namely angle restricted nearest neighbor problem arann short ann problem arann problem wideranging applications pattern recognition image processing morphology points p q plane let dp q stand euclidean distance p q say q r dominated p q lies inside closed planar region determined two rays directions r 1 r 2 emanating p terminology point q said r nearest neighbor p q r dominated p dominated pg arann problem involves determining r nearest neighbor every point refer figure 3 illustration p 2 0 3dominated p 1 0 3 dominated p 4 0 3nearest neighbor p 1 p 2 class related problems pattern recognition morphology involves associating certain graph set graph course applicationspecific example pattern recognition one interested euclidean minimum spanning tree relative neighborhood graph geographic neighborhood graph symmetric furthest neighbor graph gabriel graph delaunay graph name 20 2527 euclidean minimum spanning tree denoted emsts minimum figure 3 illustrating 0 domination corresponding arann graph figure 4 lune p q spanning tree weighted graph vertices edges weighted corresponding euclidean distance words edgeset sg p q dp q edge connecting points p q weight dp q relative neighborhood graph rngs set points plane introduced toussaint 26 effort capture many perceptually relevant features set specifically given set points plane rngs vertices points together edge p q whenever dp q max s2s fdp sdq sg equivalent definition states two vertices p q joined edge rngs points lie inside lunep q lune p q defined set points gng figure 5 illustrating emst rng gng gng 1 plane enclosed region determined two disks radius dp q centered p q respectively refer figure 4 illustration undirected graph vertexset edgeset fp qjq i3nearest neighbor pg gng denoted gngs graph vertexset whose edges 1i6 e refer figure 5 example concepts defined given set n points plane two directions r 1 r 2 anglerestricted nearest neighbor graph denoted aranns directed graph whose vertices points points p q linked directed edge p q whenever q r nearest neighbor p reader fail note problem computing r closest neighbor point problem computing graph aranns intimately related sense solution either immediately yields solution reason remaining part work shall focus problem computing graph aranns shall refer task informally solving arann problem referring figure 3 corresponding arann graph contains directed edges 0 closest neighbor p 1 p 3 0 closest neighbor p 2 points p 3 p 4 0 closest neighbor arann graph show isolated vertices several sequential algorithms computing emst gng arann rns graphs set points proposed literature 3 7 25 26 particular 3 shown arann graph set n points plane computed sequentially log n time main contribution work present algorithm compute arann graph n points o1 time rm size n theta n also show algorithm optimal sense n 2 processors necessary compute arann n points o1 time hard see ann problem easier arann ann corresponds computation arann particular directions 0 2 second main contribution extend arann algorithm solve o1 time problems computing geographic neighborhood graph relative neighborhood graph euclidean minimum spanning tree set n points plane already mentioned jang prasanna 5 shown nearest neighbor problem set n points plane solved o1 time rm size n theta n key idea algorithm 5 follows first stage points partitioned n 14 horizontal groups n 34 points n 14 gamma 1 horizontal lines n 14 vertical groups n 34 points n vertical lines point nearest neighbor points horizontal vertical group retained candidate nearest neighbor whole set points computed set candidates second stage algorithm 5 uses fact candidates 8 n points correct nearest neighbors points computing nearest neighbor exceptional 8 n points ann problem solved angle restricted algorithm work possible none candidates retained stage 1 actual angle restricted nearest neighbor situation depicted figure 6 develop new tools dealing arann problem tools interesting right may import resolution related problems time clear using arann algorithm ann problem task computing gng solved o1 time n theta n rm furthermore rng computed o1 time n theta n rm emst computed o1 time n theta n 2 rm algorithms based fact rng subgraph gng emst subgraph rng 2526 section 2 demonstrate lower bound size reconfigurable mesh necessary compute arann gng rng figure none candidates stage 1 true 0 nearest neighbors emst o1 time section 3 presents basic algorithms used arann algorithm section 4 presents optimal arann algorithm section 5 presents algorithms gng rng emst finally section 6 offers concluding remarks poses open problems let us consider arann problem directions gamma2 2 consider set points xaxis point assigned ith column rm size theta n computation arann processors ith column know gamma2 2nearest neighbor 1 n2 point 2nearest neighbor point in2 0 therefore information n2 points n2 0 n21 must transferred links connect n2 gamma 1th column n2th column rm hence time required solve arann problem therefore following result theorem 21 processors necessary solve instance size n arann problem rm o1 time since proof applied gng rng emst corollary 22 processors necessary compute gng rng emst n points o1 time rm 3 basic algorithms section reviews basic computational results reconfigurable meshes used subsequent algorithms recently lin et al 12 benasher et al 2 jang prasanna 6 nigam sahni 17 proved variants following result lemma 31 set n items stored one per processor one row one column reconfigurable mesh size n theta n sorted o1 time sequence n numbers prefixmaxima sequence gg prefixminima defined way prefixmaxima prefixminima lemma 32 given sequence n numbers stored one per processor one row reconfigurable mesh size n theta n ffl prefixmaxima resp prefixminima computed time every fixed ffl 0 proof olariu et al 18 shown compute maximum n items o1 time reconfigurable mesh size n theta n essentially assign n processors number determine number larger number found maximum since n theta n rm find maximum n elements o1 time easy extension shows n theta n 2 rm compute prefixmaxima n numbers o1 time based idea devise o1 time algorithm n theta n ffl rm assume number assigned row platform partition sequence n numbers n ffl2 sequences 1 ffl2 contains n 1gammaffl2 numbers next compute local prefixmaxima 1 n ffl2 n 1gammaffl2 theta n ffl submesh recursively let maximum within compute global prefix maxima sequence g done o1 time o1 time algorithm discussed finally number j 2 compute maximum local prefixmaximum global prefixmaximum maxfa corresponds prefixmaximum j since depth recursion o1ffl maximum computed o1 time 2 prefixsums n binary values computed similar fashion reader referred 19 details lemma 33 every fixed ffl 0 prefixsums binary sequence computed o1 time reconfigurable mesh size n theta n ffl next result assumes reconfigurable mesh wherein processor connect fuse arbitrary number ports 28 platform show basic graph algorithms essentially previously presented 28 however number processors reduced careful implementation algorithms rm graph e consists set v n vertices edgeset e edges u e said numbered vertex set ng graph e weighted edgeset positive number reachability problem 28 vertex u g involves determining vertices g reached path u u referred source lemma 34 given numbered graph e node u 2 v single source reachability problem solved o1 time n theta e rm edge assigned column rm proof let n edge assigned ith column rm size n theta e p connect four ports one figure 7 bus configuration reachability problem processors connect e w ports well n ports pairs note bus configuration thus obtained corresponds graph sense horizontal buses row u row v row connected vertical bus column illustrated figure 7 next processor p u 1 sends signal e port every processor p v 1 reads e port hard see vertex v reachable u processor v 1 received signal sent p u 1 therefore reachability problem solved o1 time n theta e reconfigurable mesh allows ports fused togetherby using single source reachability algorithm following lemma lemma 35 given numbered weighted graph g n vertices e edges minimum spanning tree computed o1 time reconfigurable mesh size e theta ne provided every processor fuse ports together proof 1 e let g graph lexicographically larger w determined whether u v reachable graph g edge mst otherwise mst edge lemma 34 reachability determined o1 time e theta n rm mst edges determined o1 time e theta ne rm claimed 2 4 optimal algorithm arann problem consider collection n points plane directions r 1 r 2 2 main goal section present optimal o1 time algorithm computing corresponding graph aranns begin discussion pointing trivial suboptimal solution problem hand lemma 41 every fixed ffl 0 task solving arbitrary instance size n arann problem performed o1 time rm size n theta n 1ffl proof partition rm n submeshes size n theta n ffl assign submesh point point p find submesh nearest neighbor q points dominated p report edge p q edge aranns note task finding nearest neighbor every point seen instance prefix minimum problem solved o1 time algorithm lemma 32 2 remainder section show improve naive algorithm run o1time rm size n theta n first assume given directions 0 r angle closed region acute consider set points plane stored one per processor first row rm size n theta n 1 n processor p 1 stores point p details algorithm spelled follows step 1 sort points ycoordinate partition n 13 subsets n 23 points ycoordinate points smaller ycoordinate points step 2 point p compute x 0 sort points x ycoordinate p next partition points figure 8 partitioning xs subsets points every choice points p step 3 point p x rnearest neighbor xp points x step 4 point p rnearest neighbor p points step 5 j 1 point 0 rnearest neighbor zp points z ij step 6 point p find closest three points xp p zp return 0 rnearest neighbor p refer reader figure 8 example actually 4 inconsistency nonessential next goal show algorithm presented implemented run o1 time rm size n theta n virtue lemma 31 steps 1 2 completed o1 time rm size n theta n step 3 submesh size n theta n 23 minimap 3 figure 9 illustrating maximas minimas directions 0 3 assigned x consequently step 3 completed o1 time naive algorithm lemma 41 way step 4 implemented run o1 time step 6 involves local computation performed obvious way o1 time remainder section devoted showing careful implementation step 5 run o1 time shall begin presenting technical results key understanding implementation works consider set points point p 0 rmaximal resp minimal point p 0 rdominated resp 0 rdominate point shall use maximas resp minimas denote chain maximal points specified counterclockwise order resp minimal points clockwise order concepts illustrated figure 9 directions 0 3 next propose show points maximax may 0 r nearest neighbor z ij moreover 0 rnearest neighbor point maximax j lies z ij minimaz ij lemma 42 three points direction r 0 proof consider triangle let u point edge 3 triangle cuts one rays directions 0 r emanating p 2 shall assume without loss generality point u lies ray direction 0 must larger 2 implies angle larger angle larger 2 hence note lemma 42 hold direction r larger 2 reason restricted angle r less 2 consider two sets points p q points p 0 rdominate points q let arann r p q set edges p q p belongs p q belongs q q 0 rnearest neighbor p following lemma 43 two edges arann r p q intersect proof suppose two edges p q p intersect point u triangle inequality applied triangles puq 0 p 0 uq 1 implies either must hold however contradicts assumption p q p edges arann r hence graph arann r p q planar lemma 44 p proof p belong minimap exists point p 0 minimap dominates q lemma 42 guarantees contradiction case q belong maximaq show contradiction essentially similar fashion 2 lemma 44 following important consequence corollary 45 arann r corollary 45 guarantees order compute arann r p q examining pairs points p p q q necessary needed compute arann r minimap maximaq pursue idea write minimap assume fixed ffl 0 motivates following approach compute arann r minimap maximaq let sampleminimap subset n ffl2 points fp n ffl2 minimap partition minimap n ffl2 chains way ffl every k g refer figure 10 illustration k 1 2 q 0 rnearest neighbor p kn ffl2 q observe points q j k thus defined induce partition set q n ffl2 chains ffl2 ffl every k g note q j k 43 guarantees order compute 0 r nearest neighbor point p p k respect maximaq restrict computing 0 rnearest neighbor p q k words arann r arann r p k maximaq therefore task computing arann r minimap maximaq reduces computing arann r sampling strategy outlined leads following algorithm computing arann r minimap maximaq o1 time rm size n theta n ffl fixed assume point minimap assigned one column point maximaq assigned one row rm partition columnwise original rm size n theta n ffl n ffl2 submeshes size n theta n ffl2 kth submesh 1 k n ffl2 compute dp kn ffl2 q points q maximaq step 2 every k 1 k n ffl2 use kth submesh compute figure 10 partitioning minimap maximaq ffl 0 rnearest neighbor q j k p kn ffl2 finding smallest distances computed ffl using point q determine q k 0 rnearest neighbor every point p p k precisely q j k thus shall therefore assume jq k j 2 k step 3 partition given rm size nthetan ffl rowwise n ffl2 submeshes follows kth submesh size jq k j k original mesh kth submesh compute arann r follows step 31 partition kth submesh size jq k submeshes size jq k assign point p p k submesh compute dp q point q q k step 32 using algorithm lemma 32 compute minimum dp q q q k submesh assigned p return 0 rnearest neighbor p reader difficulty confirm steps 1 2 performed constant time using prefixsums algorithm lemma 33 partitioning step 3 performed constant time steps 31 32 also implemented run constant time summarize proved following result lemma 46 minimap maximaq assigned columns rows respectively rm size n theta n ffl arann r minimap maximaq computed o1 time every fixed position discuss o1 time implementation step 5 computes zp p simplicity assume rm n theta 2n processors step 51 partition n theta 2n rm columnwise n 23 submeshes size n theta jx step 52 submesh ri step 53 submesh ri step 54 submesh ri ij step 51 complicated number columns submesh different partitioning specified step 51 completed o1 time using sorting algorithm lemma 31 sort n points lexicographical order x 0 p yp clearly j points x consecutive sorted points smallest point largest one sth tth sorted order submesh assigned columns step 51 completed o1 time steps 52 completed follows let k compute postfixmaxima g algorithm lemma 32 maxfyp k1 yp k2 yp k3 computed o1 time step 53 completed way apply algorithm lemma 46 step 54 serial number must assigned points minimax minimaz 0 ij numbering obtained obvious way using prefixsum algorithm lemma 33 executing algorithm lemma 46 step 54 completed o1 time therefore arann r computed o1 time n theta 2n rm since algorithm uses n theta 2n processors implemented n theta n rm simple scheduling technique arann r also computed o1 time n theta n rm furthermore arann r r 2 computed partition angle several acute angles example arann 23 computed follows 1 compute arann 2 2 rotate points angle 2 clockwise origin 3 compute arann 6 4 point determined nearest two points computed 1 2 corresponds nearest point arann 23 therefore proved following result theorem 47 given arbitrary set n points plane direction r 0 r 2 corresponding instance arann problem solved o1 time reconfigurable mesh size n theta n 5 application proximity problems goal section show result theorem 47 leads o1 time algorithms gng rng emst begin theorem 47 computed o1 time n theta n rm therefore corollary 51 given n points plane gng computed o1 time reconfigurable mesh size n theta n since gng planar gng 3n gamma 6 edges thus gng edges furthermore rng subgraph gng 7 therefore theorem 52 given n points plane corresponding rng computed o1 time n theta n rm proof edge gng check whether point lune point exist edge rng edge vice versa checking done o1 time n processors edge since gng n points 18n gamma 36 edges rng computed o1 time n theta n rm 2 furthermore using mst algorithm lemma 35 following theorem theorem 53 given n points plane emst computed o1 time reconfigurable mesh size n theta n 2 proof applying mst algorithm graph rng emst n points computed emst subgraph rng since rng 3n gamma 6 edges n theta n 2 rm sufficient compute emst o1 time 2 6 concluding remarks shown optimal algorithm reconfigurable mesh computing angle restricted nearest neighbor problem using algorithm also shown optimal algorithms reconfigurable mesh computing geographical neighborhood graph relative neighborhood graph algorithms optimal sense o1time algorithm solves instances size n problems reconfigurable mesh furthermore also shown euclidean minimum spanning tree set n points plane computed o1 time n theta n 2 reconfigurable mesh provided every processor fuse ports remains open find o1time emst algorithm n theta n reconfigurable mesh matches lower bound r parallel computational geometry power reconfiguration voronoi diagrams based convex functions pattern classification scene analysis parallel geometric problems reconfigurable mesh optimal sorting algorithm reconfigurable meshes computing relative neighborhood graphs plane ieee transactions computers reconfigurable buses shift switching concepts appli cations sorting o1 time reconfigurable mesh size n ieee transactions parallel distributed systems hardware support fast reconfigurability processor arrays parallel computations reconfigurable meshes connection autonomy simd computers vlsi implemen tation sorting n numbers n fundamental data movement international journal high speed computing fundamental algorithms reconfigurable meshes computational geometry introduction ultimate limitations parallel processing bus automata bit serial associate processor gated interconnection network dynamic programming relative neighborhood graph application minimum spanning trees relative neighborhood graph finite planar set symmetric allfurthest neighbor problem constant time algorithms transitive closure problem applications ieee transactions parallel distributed systems image understanding architecture tr ctr hongga li hua lu bo huang zhiyong huang two ellipsebased pruning methods group nearest neighbor queries proceedings 13th annual acm international workshop geographic information systems november 0405 2005 bremen germany ramachandran vaidyanathan jerry l trahan chunming lu degree scalability scalable reconfigurable mesh algorithms multiple addition matrixvector multiplication parallel computing v29 n1 p95109 january dimitris papadias yufei tao kyriakos mouratidis chun kit hui aggregate nearest neighbor queries spatial databases acm transactions database systems tods v30 n2 p529576 june 2005
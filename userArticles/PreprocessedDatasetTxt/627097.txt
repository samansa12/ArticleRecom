algorithm exact bounds time separation events concurrent systems abstractdetermining time separation events fundamental problem analysis synthesis optimization concurrent systems applications range logic optimization asynchronous digital circuits evaluation execution times programs realtime systems present efficient algorithm find exact tight bounds separation time events arbitrary process graph without conditional behavior result general methods presented several previously published papers handles cyclic graphs yields tightest possible bounds event separations algorithm based functional decomposition technique permits implicit evaluation infinitely unfolded process graph examples presented demonstrate utility efficiency solution algorithm form basis exploration timingconstrained synthesis techniques b introduction paper derive exact algorithm determines tight upper lower bounds separation time arbitrary pair system events depending level abstraction specifica tion events may represent lowlevel signal transitions circuit interface control flow abstract behavioral view able determine bounds separation time two events use information simplify combinational sequential logic extracting temporal dont care information verify logic implementation meets specified timing constraints identify remove hazards asynchronous circuits focus optimization efforts datapath synthesis generating useful scheduling constraints thus determining time separation events fundamental problem analysis synthesis optimization concurrent systems develop efficient solution determining time separation bounds also take account effects starting system specific reset start state model concurrent system cyclic connected graph nodes graph represent events arcs annotated lower upper bounds delays events currently solution limited graphs without conditional havior however still leaves large useful class concurrent specifications analysis applies approaches problem finding bounds separation time two events either inexact based restrictive graph topology loose bounds may enable possible optimizations obtained 8 7 10 handle acyclic graphs 2 supports limited form synchronization concurrency paper composed five sections follow introduction formalization problem review foundation provided solution finite acyclic graphs examples section 3 provides details algorithm based structural decomposition unfolded process graph practical examples presented section 4 finally section 5 summarizes contributions paper problem formalization consider simple concurrent system consisting three processes synchronize two channels b internal computation delay ranges specified brackets repeat f synchronize compute repeat f synchronize compute synchronize b compute repeat f synchronize b compute represent system directed graph called process graph vertices represent events synchronizations edges annotated delay information process graph system shown figure 1 initial state processes specified marking edges execute initially formalize problem use simple modification eventrule system developed 3 1 let process graph composed finite set repeatable events e 0 vertices graph finite set rule templates r 0 edges graph edge labelled two objects delay range integers 0 occurrence index offset 2 example r 7gamma 120 7gamma bg restrict analysis wellformed graphs graphs stronglyconnected c 0 cycles c graph c sum values edges cycle c figure 1 three processes synchronizing points b number lines drawn edge indicates value occurrence index offset 21 execution model denote k th occurrence event refer k occurrence index v k let e set event occurrences infinite one direction ie k 0 model initial startup behavior process also include e single event occurrence named root thus set r consists rules generated instantiating rule template r 0 occurrence introduced similarly modified system model also viewed extension 7 10 consider cyclic maxonly type2 graphs 2 occurrence index offset used specify much occurrence index incremented edge executedsee section 21 ae oe special startup rules included set r 0 nonempty finite subset froot dd call infinite directed graph constructed vertex set e edge set r unfolded process graph figure 2 shows unfolded process graph example figure 1 root a3 4 10 4 10 4 10 4 10 5 20 5 20 5 20 5 20 16 16 16 16 figure 2 portion unfolded process graph process graph figure 1 two startup edges added specifying 0 b 0 must occur root execution process graph consistent assignment time values event occurrences timing assignment maps event occurrences global time thus v k time k th occurrence event v delay information r restricts set possible timing assignments formally define constraints time values introduced event occurrence ae oe ae oe constraints v k embody underlying semantics process graphs execution ie events correspond synchronizations event occur incident events occurred incident event delayed number bounded interval thus earliest time v k occur constrained values latest values 22 problem definition problem address paper given two events e 0 separation occurrence index fi strongest bounds ffi delta ff max0 fi example determine bounds time separation two consecutive events would set consider bounds ff address problem finding maximum separation since ffi obtained ff 23 algorithm finite unfolded process graph build solution problem variation graph algorithm developed mcmillan dill 7 applies finite unfolded graphs section 3 generalize algorithm infinite unfolded graphs let delta ff strongest bound separation problem given ff ie determine delta ff analyzing finite acyclic graph created including vertices unfolded process graph path either ff ffgammafi name resulting graph r algorithm consists two simple steps first compute mvalues backwards ffgammafi event occurrences dh sum values edges path h compute values linear time size r reverse topological traversal ffgammafi path v k ffgammafi denoted assign arbitrary constant value mv k use mv k compute delta assigning occurrences normal topological order 1 v k 6 ffgammafi minimization 0 omitted root root411 104 0110100 6 b figure 3 finite acyclic graph r obtaining process graph figure 1 given parameters edges labeled values vertices labelled mvalues obtained first step algorithm b edges labeled values vertices labelled mvalues obtained second step obtain applying algorithm example figure 1 see figure 3 computation yields following maximum separations compute delta maximum separation time occurrences separated occurrence fi maximize delta ff values ff problem course requires infinite number applications algorithm present algebraic solution allows us analyze infinite unfolded graph illustrate difficulties analysis examples 24 examples first example figure 4 process graph represents two coupled pipelines pipelines coupled c maximum separation e would unbounded first pipeline choosing delay consecutive 2 could arbitrarily slower second pipeline choosing delay consecutive es 1 coupling pipelines forces one pipeline wait gets far ahead e c figure 4 process graph represents two coupled pipelines unspecified delay ranges 0 0 start pipeline rooting initial occurrences zero eg root 00 7gamma 0 ff 0 shown ff second example figure 5 exhibits interesting behavior root initial occurrences zero f e c b 3 3 3 3 3 3 3 3 figure 5 process graph unusual timing behavior unspecified delay ranges 1 1 change e c 10 10 10 10 figure two processes synchronizing c final example figure 6 corresponds two simple processes synchronize event c clearly startup rules affect initial timing behavior processes however example demonstrates initial startup rules also determine maximum separation every point infinite execution two startup rules root 7gamma 0 determine every delta ff e ff process graph repetitive system presumably delta ff values eventually reach steady state example large ff unfortu nately examples illustrate behavior ff values nonmonotonic periodic might even start periodic later stabilize constant value thus simple criteria determining steady state reached derived based behavior delta ff values 3 functional solution solution problem based structural decomposition unfolded process graph exploits repetitive nature dividing unfolded process graph segments representing computation finite graph algorithm symbolic manner reuse computations segment 31 introducing functions introduce symbolic execution acyclic algorithm presented section 23 instead computing numeric mvalues 1 compute functions relate mvalues one another present algebra representing manipulating functions functions represented sets pairs singleton set fhl wig represents function general set wn ig 2 corresponds function associate two operators functions function maximization f max g function composi g follows 3 function maximization defined set union f g following observation leads important efficiency optimization pruning rule 2 l l j w prune pair hl since x minx l thus function 2 always represented function composition h defined notice use lefttoright function composition 4 g g h contain one pair g h singleton sets function composition performed using distributivity ie express mvalues using functions associate function f edge u kgamma unfolded process f ae function f incorporates minpart 1 maxpart 1 corresponds function maximization functions incoming edges using function composition function maximization create function f v k relates root f f root figure 7 fragment unfolded process graph annotated functions corresponding edge mvalues given figure 3 example figure 3 see figure 7 relate root b 0 function f 0ig evaluating function yields gamma1 exactly value obtained b 0 figure 3 b functions f b0 f a0 used relate root 1 etc function relates root ff created example ff 2 construction produces f find separation ffgammafi ff f ff 0 example get f a2 evaluated using 3 32 decomposition instead forming single function relating root ff perform construction segments determine functional relationship root mvalues interior nodes compose functions functions relating mvalues interior nodes ff see process akin matrix multiplication consider unfolded process graph used determine decompose graph three seg ments initial segment r containing root event terminal segment containing ffgammafi ff interior segment see figure 8 root root b ffgammafiomega ffomega vk vk r figure 8 decomposing unfolded process graph segments cutset set event occurrences every path root ff goes element cutset let x two cutsets say x shifted right omegagamma construct square matrix maps mvalues events x mvalues events ie eventsomega occurrences lateromega 0 simi larly construct matrix r maps root mvalues events x matrix maps mvalues events ff restate maximum separation problem matrix form using tion function maximization scalar addi tion function composition scalar multiplica tion form rst 1 theta 1 matrix containing single function relating root ff used obtain delta ff graph figure 7 possible decomposition yielding f 9 consider finding ffomega add another segment graph defined cutsets z z shifted right byomega see figure 8 b get matrix product r 0 0 st r 0 0 may differ r since mvalues computed ffgammafiomega instead ffgammafi decomposition useful arrange symbolic computation r ie adding segment change functional representation next section characterizes behavior mvalues allows us utilize decomposition effectively 33 repetition mvalues since mvalues constructed repetitive system process graph values eventually determined maximum ratio cycles process graph see 5 maximum ratio cycle c cycle ratio dcc equal maximum c simple cycle g 0 dc c mvalues repeat precisely values events determined repetitively using maximum ratio cycles formally exists integers k number unfoldings process graph relative ffgammafi mvalues repeat occurrence period repetition multiple cycles maximum ratio mvalues computed different events may use different maximum ratio cycles thus simple upper bound least common multiple c maximum ratio cycle c figure 9 illustrates behavior mvalues process graph figure 1 k values specific particular process graph exam ple changing delays 4 10 5 20 9991000 10001000 respectively changes k 3 998 note lower delay bounds affect k b522 figure 9 portion unfoldedprocess graph process graph figure 1 labeled mvalues occurs three unfoldings relative 10 thus 3 occurrence period repetition one making 34 matrices unfoldings process graph mvalues repeating let matrix obtained cutsets property mvalues vertices topologically left x k repeat occurrence period implies edges topologically left makes mvalues independent k fore k unfolding process graph relative ffgammafi functional representations r remain independently number unfoldings let matrix product rt solve delta ff find adding segment ie rst repeatedly adding segments graph compute maximum n 0 found matrix algebra rewritten r identity matrix elements 1 identity elements function maximization composition respectively note 0 annihilator function composition matrix closure algorithm 1 used compute middle part 6 con text function maximization composition form closed semiring key observation allows us implicitly compute infinite number values compute need able compute closure diagonal elements wn ig scalar closure operation efficiently computed ae pairs ordered 4 w q corresponds first positive l ie l q 0 q 1 l form closure n theta n matrix 3 scalar semiring operations rs used compute maximum delta ff values subset integers ff max0 fi need compute maximum finite number additional delta ff precisely since rt used compute delta ff done applying finite graph algorithm ff max0 fi ff need also compute ff divide ffgammaff accomplished choosing different initial matrices named r 0 r 1 corresponding 0 unfoldings process graph thus compute maximum delta ff ff ff creating function r 0 35 example apply details decomposition method example figure 1 decompose unfolded process graph matrices r shown figure 10 size segment determined k unfoldings relative ffgammafi node size segment ings functions relate 0 b 0 b 1 example root r figure 10 decomposed unfolded process graph corresponding process graph figure 1 closure yielding final product maximum separation ffgamma1 ff computed function ie yielding 25 36 efficiency considerations two potential inefficiencies associated algorithm 1 depend delay ranges polynomial size process graph 2 size representation particular function may large number paths two events related function point 1 potentially serious however process graphs derived circuits concern large exists cycle c dcc almost equal r although theoretical interest point 2 likely practical concern practice functions efficiently pruned size functions seems linear respect size process graph applications section describes two applications demonstrating practicality algorithm realistic examples 41 memory management unit consider edge u kgamma arbitrary process graph minimum time separation u kgamma v k larger event u kgamma never constrain time event v k ie v k must always wait event occur edge u kgamma removed process graph without changing behavior system idea used remove redundant circuitry asynchronous circuits given conservative bounds actual delays speedindependent design superfluous edges removed analyzing process graph corresponding circuit approach taken myers meng 8 use inexact timing analysis algorithm ie algorithm doesnt necessarily give tight bounds separation times clearly able obtain tight bounds potentially enables removal edges one examples 8 memory management unit mmu designed interface caltech asynchronous microprocessor 6 process graph one possible execution modes mmu consists 16 events 23 edges chosen delay intervals k analyzing 23 edges using exact algorithm takes average cpu seconds sparc 2 edge analysis results removal six edges process graph equivalently removal six transistors circuit result 8 42 asynchronous microprocessor subset caltech asynchronous microprocessor 6 modelled analyzed using techniques described paper process graph simplified model consists 60 events 127 edges using implementation techniques described paper computations instruction fetch cycle period pipeline latency performed 2 cpu seconds sparc 2 similar computations used determine realtime properties asynchronous microprocessor example bound execution time code fragment use minimum maximum separation cycle period instruction type 9 furthermore information useful interfacing microprocessor external synchronous component especially cases synchronous component clocked using signal produced microprocessor 5 conclusion presented efficient exact solution fundamental problem circuit synthesis opti mization namely determination bounds separation time events concurrent systems major contribution paper structural decomposition infinitely unfolded process graph enables implicitly analyzed obtain tightest possible bounds aspect algorithm algebraic formulation enables efficient enough practical use furthermore algorithm handles wide range process graphs thus useful variety domains looking adaptations technique graphs include conditional behavior thus process everlarger class graphs may require exploration tradeoffs tightness bounds computation time concern high efficiency algorithm practice concert effort also investigating problem domains highlevel synthesis hardwaresoftware codesign potential application areas acknowledgments work supported nsf pyi award mip8858782 nsf yi award mip9257987 darpacsto microsystems program onr monitored contract n0001491j4041 ibm graduate fellowship technical university denmark authors wish thank chris myers several stimulating technical discussions r design analysis computer algorithms approach symbolic timing verification performance analysis optimization asynchronous circuits topics algebra combinatorial optimization networks matroids design asynchronous mi croprocessor algorithms interface timing verification synthesis timed asynchronous circuits experiments program timing tool based sourcelevel timing schema specification analysis timing constraints signal transition graphs tr ctr dinesh ramanathan ravindra jejurikar rajesh k gupta timing driven codesign networked embedded systems proceedings 2000 conference asia south pacific design automation p117122 january 2000 yokohama japan nicholas h zamora xiaoping hu radu marculescu systemlevel performancepower analysis platformbased design multimedia applications acm transactions design automation electronic systems todaes v12 n1 p2es january 2007 steve haynal forrest brewer model scheduling protocolconstrained components environments proceedings 36th acmieee conference design automation p292295 june 2125 1999 new orleans louisiana united states sangyun kim sunan tugsinavisut peter beerel reducing probabilistic timed petri nets asynchronous architectural analysis proceedings 8th acmieee international workshop timing issues specification synthesis digital systems december 0203 2002 monterey california usa ali dasdan anmol mathur rajesh k gupta ratan tool rate analysis rate constraint debugging embedded systems proceedings 1997 european conference design test p2 march 1720 1997 anmol mathur ali dasdan rajesh k gupta rate analysis embedded systems readings hardwaresoftware codesign kluwer academic publishers norwell 2001 anmol mathur ali dasdan rajesh k gupta rate analysis embedded systems acm transactions design automation electronic systems todaes v3 n3 p408436 july 1998 tod amon gaetano borriello taokuan hu jiwen liu symbolic timing verification timing diagrams using presburger formulas proceedings 34th annual conference design automation p226231 june 0913 1997 anaheim california united states vijay k madisetti lan shen interface design corebased systems ieee design test v14 n4 p4251 october 1997 abhijit davare kelvin lwin alex kondratyev alberto sangiovannivincentelli best worlds efficient asynchronous implementation synchronous specifications proceedings 41st annual conference design automation june 0711 2004 san diego ca usa peggy b mcgee steven nowick e g coffman jr efficient performance analysis asynchronous systems based periodicity proceedings 3rd ieeeacmifip international conference hardwaresoftware codesign system synthesis september 1921 2005 jersey city nj usa michael kishinevsky jordi cortadella alex kondratyev asynchronous interface specification analysis synthesis proceedings 35th annual conference design automation p27 june 1519 1998 san francisco california united states ali dasdan sandy irani rajesh k gupta efficient algorithms optimum cycle mean optimum cost time ratio problems proceedings 36th acmieee conference design automation p3742 june 2125 1999 new orleans louisiana united states yiping cheng dazhong zheng minmax inequalities timing verification problem max linear constraints discrete event dynamic systems v15 n2 p119143 june 2005 r marculescu nandi probabilistic application modeling systemlevel perfromance analysis proceedings conference design automation test europe p572579 march 2001 munich germany ali dasdan experimental analysis fastest optimum cycle ratio mean algorithms acm transactions design automation electronic systems todaes v9 n4 p385418 october 2004 henrik hulgaard steven burns bounded delay timing analysis class csp programs formal methods system design v11 n3 p265294 oct 1997 jeremy gunawardena maxplus algebra nonexpansive mappings nonlinear theory discrete event systems theoretical computer science v293 n1 p141167 3 february
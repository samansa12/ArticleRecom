optimal elections faulty loop networks applications abstractloop networks hamiltonian circulant graphs popular class faulttolerant network topologies include rings complete graphs class fundamental problem leader election extensively studied assuming either faultfree system upperbound number link failures consider loop networks arbitrary number links failed processor detect status incident links show leader election protocol faulty loop network requires log n messages worstcase n number processors moreover show optimal proposed algorithm also detects network partitions also show provides optimal solution arbitrary nonfaulty networks sense direction b introduction 11 loop networks common technique improve reliability ring networks introduce link redun dancy node connected two additional nodes network alternate paths nodes network sustain several nodes links failures several ring networks suggested 3 8 27 34 40 based prin ciples overall topological structure redundant rings always highly regular particular set ring edges regular additional edges bypass form loop network since least one hamiltonian cycle figure 1 2 4 loop network faulty links b loop networks particular cases circulant graph uncoordinated literature numerous terms used name topology depending model circulant graph chordal ring distributed loop computer networks common detailed survey topologies presented 5 sake simplicity use term loop network remaining paper loop network c n 1 2 k size n kchord structure 1 2 k ring r n n processors p 0 processor also directly connected processors distance n additional incident chords link connecting two nodes labeled distance separates two nodes ring ie following order nodes ring node p connected node p id j mod n link labeled j shown figure 1a particular link two processors p q labeled distance processor p link labeled n incident processor q n number processors note rings complete graphs circulant graphs denoted c n respectively worth pointing designs redundant meshes redundant hypercubes also circulant graphs 7 distinction regular bypass links purely functional one typically bypass links used strictly reconfiguration purposes faults detected absence faults regular links used special classes loop networks widely investigated analyze faulttolerant properties 3 7 8 9 27 33 solutions proposed reconfiguration links andor node failures 30 39 applications eg distributed systems links chords circulant graph always used improve performance computation 12 election distributed systems one fundamental control problem leader election 29 informally election problem moving system initial situation nodes computational state final situation exactly one node distinguished computational state called leader others state called defeated election process may independently started subset processors election problem occurs instance tokenpassing token lost owner failed case remaining processors elect leader issue new token several problems encountered distributed systems solved election example crash recovery new server found continue service previous server crashed mutual exclusion values election defined last time process entered critical section group server choice server incoming request made election among available servers managing replicated resource etc following failures network might partitioned several disconnected components shown figure 1b respect election process component called active least one processor component independently starts election process leader election protocol must determine unique element active component distinguished elements determine additional information eg size component etc needed particular application nature applications irrelevant election process assumed every processor p distinct id chosen infinite totally ordered set id processor aware identity particular know identities neighbours processors perform distributed algorithm distributed algorithm protocol program contains three types executable statements local computations message send message receive statements assume messages arc arrive error unbounded finite delay fifo order complexity measure maximum number messages sent possible execution 13 election faulty loop network leader election problem loop networks extensively studied assuming failures systems 4 18 23 24 32 problem becomes rather dicult failures system asynchronous systems particular election problem unsolvable ie deterministic solution protocol exists failures undetectable occur time impossibility result holds even one processor may fail failstop mode follows result 10 research thus focused studying problem restricted environments r1 failures detectable faults r3 r1 r2 graph links nodes detectability occurrence termination arbitrary loop network complete complete complete r5 n2 per node 0 intermittent possible 2 38 ring arbitrary loop network unbounded unbounded yes prior possible paper table 1 impossibility versus possibility results k constants bounding number failstop faults r2 failure occurs prior execution election protocol r3 number failures bounded constant r4 failures failstop r5 every processor directly connected every processor existing results election faulty loop networks developed assumptions r2 r3 r4 assuming network either complete graph r5 1 16 28 31 37 ring 14 41 42 see table 1 far without detectability algorithms breaking free bounded number failures assumption r3 generate expensive communication complexity 2 messages bits 19 paper consider election problem asynchronous arbitrary loop networks arbitrary number links failed processor detect status incident links make assumptions r2 r4 relaxed version assumption r1 thus unlike previous investigations restrict complete graphs make priori restriction number failures however assume processor detect failure incidents links note assumption detectability assumption r1 required cope unbounded number faulty components see table 1 prove assumptions leader election protocol faulty loop network requires log n messages worstcase n number processors moreover show optimal case failures partitioned network algorithm detect distinctive element determined active component depending application distinctive elements thus take appropriate actions processors links may fail following assume processor fails incident links fail thus without loss generality consider link failures emphasize fact regular bypass links fail shown figure 1b processor detect failure incident links knowledge link faulty either line line line case hardware subsystem provides directly knowledge processors thus information priori respect execution protocol line case knowledge acquired upon attempt transmit link link operational message transmitted otherwise error signal issued system see figure 2 computational point view line case dicult line one particular transform priori knowledge case eg preprocessing phase active processor tests incident links would cost additional messages number nonfaulty links thus log n lution case faults detected upon transmission attempt important since faultdetection performed links used computation furthermore solution obviously applied complexity case priori knowledge faulty links thus following concentrate dicult case algorithm presented combines known techniques election nonfaulty networks 13 17 21 original routing paradigms based structural information 12 order avoid faulty components algorithm uses asynchronous promotion steps merge rooted spanning trees election algorithm present election algorithm loop network arbitrary number links failed failure link detectable incident node attempts transmit full algorithm given appendix see also 26 node independently spontaneously start election process model node receive wakeup message network partitioned algorithm detect elect leader case failures partitioned network distinctive element determined active component detect partition occurred depending application distinctive elements thus take appropriate actions describe algorithm executed active component 21 description active component algorithm builds rooted spanning tree kingdom repeatedly combining smaller spanning trees final root spanning tree distinctive element component following describe algorithm executed one component algorithm proceeds phases rounds initially node king know links crashed end nodes citizen except one still king intermediate phase algorithm king tries expand kingdom rooted directed tree attacking another kingdom attack carried particular node warrior kingdom tree two distinguished nodes king warrior king assigned level initialized zero node p stores identity king p level level p king well label outgoing chord king war rior node attacked stores label incoming chord attack came algorithm warrior p maintains local view list p others processors indication belong kingdom attack message request message defined request status reqstatus reqking reqlevel reqlist contains local view reqlist informally attack carried warrior warrior select randomly outgoing link leads another kingdom one connected processor belong kingdom attempts transmit request message link link faulty failure detection signal notify warrior situation appropriate action see taken otherwise request message carry attack kingdom shown figure 2 failure algorithm system attempt request transmission figure 2 local failure detection attacks kingdom follow depth first search strategy state r chord defined specify chord unused initially branched part spanning tree failed determined attempt transmission branched chord substate subs r introduced specify chord closed faulty lead another kingdom still opened incident node completely explored thus lead nodes reached yet initially nonfaulty chords opened used control backtracking closing subtree whose visit completed warrior j cannot reach node outside kingdom locally determined state incident links local view list j state warrior together list j backtracked parent chord became closed strategy main advantage limit amount backtracking combination compared breadth first search strategy state transition diagram chord shown figure 3a node saves label w w k incident chord leading warrior p warrior attacking p king p respectively define status p node p level p king p list p following lexicographic total order say status p status j either level p level j b level king p king j algorithm obeys two main rules promotion rule warrior p successfully attack kingdom status less let attack warrior p successful case node kingdom lost informed identity new king king p updates level level p note value level p unchanged attacking kingdom case b node attacked kingdom receives identity king p new king nodes kingdoms increases level one level kingdom never decreases successful attack warrior p warrior j warrior new kingdom warrior j say processor enters new round level changes ie kingdom defeated kingdom successfully attacked kingdom identical level asynchronous rule controls number messages phase three dierent cases theoretically possible attack warrior p reaches node another kingdom 1 status p status j warrior strong enough attack kingdom thus attack fails message killed attacking kingdom waiting get attacked 2 status p status j attack p must forwarded warrior j subsequent attack kingdoms killed delayed attack resolved j ie j receives new status forwarding attack node path warrior j greater status ie status status p request killed situation occurs previously visited nodes yet informed become part greater kingdom ie level increased attack reaches warrior j still lower status surrender message sent back warrior p node path waits new status 3 status proved later case ie attack within king dom cannot occur execution algorithm warrior p receives message surrender broadcasts new status absorbed kingdom kingdoms depending promotion rule new local view list obtained merging two lists initial local view list bits list initialized 10 ie bits set 0 except list0 set 1 concurrency number concurrent incoming attacks kingdom must limited order guarantee message complexity round substate substate p node p introduced specify node waitingforsurrender forwarded attack message waitingforstatus forwarded surrender message waiting new level regular ready receive attack state transition diagram processor shown figure 3b substates introduced deal two specific situations may occur due inherent concurrency model first citizen j forwarded attack warrior j subsequent attack greater status delayed wait j killed asynchronous rule 2 secondly incoming attack received knowing kingdom already absorbed absorbed another kingdom level may increased cases citizen knows afterwards receives new status forwarded attack successful time status forwarded attack smaller new received status attack killed thus citizen go branched opened closed branched failed chords unused regular status waitingfor surrender waitingfor b nodes figure 3 state transition diagrams back regular substate otherwise current attack status still legal thus inhibition waiting substate must kept progress problem occurs warrior q receives surrender message warrior already engaged wait status process warrior w q attacked w attacking p consistently asynchronous rule warrior q wait new status warrior w send new status warrior p extreme case occurs complicate scenario involving nodes deduced w waiting p p attacked w deadlock situation proved later theorem 21 total lexicographic order status forbids creation waiting cycles structural information knowledge size network topology globally consistent assignment labels labelings interconnection nodes communication links used reduce communication cost since loop network nodesymmetric graph nodes similar one another node represent nodes relative distance along cycle actually available edge labeling used pass knowledge processors represented distances already reached node p 1 receives message node p 2 incident chord labeled 1 unambiguously decode information nodes contained message namely message contains information node linked p 2 chord 2 information refers node distance 1 2 mod n p 1 ring ordering fact used determine whether unused chord ie messages sent outgoing connected dierent kingdom function combined local view processor provides message consistent representation kingdom passed processor processor decoding function corresponds circular bit shift length chord denoted transpose exact code function given end algorithm termination partitioning algorithm terminates kingdom includes nodes connected nonfaulty subgraph determination event may dier depending whether network disconnected consider first case partitioned network reachable nodes become part kingdom king become warrior bactracking inherent depth first search strategy incident chords closed outgoing link towards node belong kingdom point detect termination local view also determined size kingdom disconnection occurred network disconnected termination detection occur earlier soon warrior determines local view kingdom includes nodes network list full ie set 1 cases warrior possibly king broadcasts along tree termination message since message contains view warrior upon termination every node component determine whether graph disconnected well nodes component case disconnection depending application king take appropriate action example attack shown figure 5 kingdom k greater status kingdom k corresponding loop network c 16 3 8 shown figure 4 result successful attack shown figure 6 messages used requeststatus attack warrior forwarded adversary message also considered first attempt chord provides failure detection chord faulty surrenderstatus sent defeated warrior inform winner success newstatusstatus broadcast winner appropriate tree de pending promotion rule branch sent successful warrior chord connecting two trees backtrackstatus sent warrior parent chords closed nodes reachable chord part kingdom faulty movewarriorstatus sent warrior one opened chords backtracking termination broadcast sole remaining warrior connected component terminate execution algorithm number processors spontaneously start execution algorithm modeled reception wakeup message active components least one processor spontaneously start algorithm ie receives wakeup message king request branched l c e f figure 4 kingdoms c 22 correctness protocol fully asynchronous messages received processor order processor receives messages depends initial input nondeterminist however algorithm eventdriven messages processed first infirstout order order processor processes communication relies tree structures asynchronous progress rules correctness follows establishing safety warrior never attacks node kingdom progress eventually tree spans nodes connected compo nent appropriate termination exactly one elected node connected component network following numbers parentheses refer corresponding sections algorithm appendix lemma 21 request message initiated warrior unused opened chord request message traversed citizen nodes branched chords leading warrior kingdom traversed proof warrior sends request attempt successful unused opened arc 4 5 7 procedure attempt end description algorithm citizen king send request upon receipt request 1 forward warrior links labeled w used chord citizen 2 g c j k f c g l request branched warrior king g figure 5 two kingdoms c corollary 21 status chord becomes used warrior previously sent request chord detected faulty lemma 22 local view list p warrior p represents exactly list processors belong kingdom warrior p proof induction clearly true initialization local view set 10 assuming local view list p warrior w correct complete attack warrior modifies view either successful attack receiving surrender message 8 warrior becomes citizen combines two views pass warrior privilege new combined kingdom defeated warrior defeated receiving newstatus message 7 receives view winning kingdom combination obtains complete view merged kingdom cases new local view contains exact list processors new kingdom proves induction 2 lemma 23 safety warrior never attacks node kingdom proof shown lemma 22 attack done upon receipt new status creates new list nodes belong kingdom 7 chords linked nodes closed remaining unused chord even randomly chosen leads processor dierent kingdom therefore cycle created kingdom 2 several facts properties observed clarify correctness fact 21 1 asynchronous rule waiting citizen king process request messages c l g f request branched warrior king g figure attack c fact 22 eventually node kingdom receives status kingdom indeed end phase defeated 8 designated warrior broadcasts new status along traversed chords waiting cycle requests may created proof immediate since sending request change regular state warrior 7 therefore requests wait non regular node block warrior initiated 2 theorem 21 progress deadlock may introduced waiting arises nodes must wait condition holds proof message sending nonblocking case node blocked waiting event warrior waits new status message sending surrender 1 similarly surrender message deferred successful warrior node surrendered another warrior attack 8 repeating setting chain waiting surrender processors occur however chain cannot become circular wait surrender message initialized successful attack status attacking warrior j strictly lexicographically larger status defending warrior p total ordering status defined promotion rule forbids waiting cycle processors status j status p status j contradicts definition 2 corollary 22 eventually node waiting substate theorem 22 kingdom rooted directed tree proof induction initially kingdom one node tree 0 kingdom defined subgraph composed chords marked k incident nodes rooted king also defined subgraph composed chords marked w incident nodes case tree rooted warrior following successful attack chord connecting two trees absorbing absorbed ones becomes part kingdom upon receipt newstatus message initiated winner warrior broadcast absorbed kingdom outgoing chord king stored k label king nil value k 0 node citizen andor king 3 warrior 7 changes label k receiving new status message announcing absorption another kingdom case k set incoming arc message received change orientation guarantees tree rooted new king note similar observation repeated tree rooted warrior 2 lemma 25 appropriate termination algorithm terminates forest one rooted spanning tree connected components proof safety lemma 23 progress theorem 21 theorem 22 connected component least one processor initiated election protocol algorithm builds rooted spanning tree 2 main theorem deduced theorem 23 algorithm correctly elects leader proof theorem 21 theorem 22 lemma 25 theorem holds election protocol independently started subset processors electing particular node active connected component king 10 group processors par titioned active component forms consistent view containing exact list reachable processors single elected node king depending application distinctive elements thus take appropriate actions eg promote leader majority basis wait recovery faulty components simulate nonfaulty topology embedding active connected group form restricted connected working group 2 23 analysis measure eciency analyzed communication complexity number size messages sent lemma 26 number rounds log k kingdom k independent nodes start algorithm proof promotion rule based tournament n2 nodes enter phase fact k2 k independent nodes start algorithm maximum number rounds maximum value level winning kingdom ie log k 2 corollary 23 number surrender messages sent warrior particular execution log k k independent nodes start algorithm lemma 27 given round given nonfaulty chord l kingdom two requests transmitted chord l proof given round given nonfaulty chord l kingdom request passing chord face several possible outcomes 1 request successful identical level cause round increase kingdom forthcoming requests previous level discarded incident node 2 request successful dierent ie larger level level value updated absorbed kingdom lemma 23 requests sent dierent kingdom may occur another request level behave described case 1 limiting number occurrences two 3 request unsuccessful message killed path warrior implies level increased another attack nodes incident chord know yet concurrency rule enforcing delay one request wait incident node discarded newstatus arrives similar argument used branched chord two kingdoms 2 corollary 24 given round given nonfaulty chord l kingdom two surrender resp new status messages transmitted chord l precisely theorem 24 total number messages used algorithm exceed proof number messages kind following sent given round n 1 nonfaulty chords see lemma 27 hence total number request messages sent whole execution bounded 2 n log k sent path kingdom modification level hence total number messages sent whole execution also bounded 2 n log k broadcast kingdom increase level hence total number messages sent whole execution also bounded sent branched chord kingdom ie n 1 messages sent branched chord kingdom subtree cannot reach nodes hence total number messages bounded size spanning tree ie n 1 sent openedbranched chord kingdom node cannot reach nodes hence total number messages also bounded size spanning tree ie n 1 termination n 1 messagesonly seven dierent types message exists status composed identity king value level takes log n values list n bits array therefore size message n bits theorem 25 algorithm optimal worstcase message complexity proof given loop network c let f c denote set possible combination links failures c clearly cardinality f c 2 e e set chords c given f f c denote mc f number messages required solve election problem c failures described f occurred worst case complexity wcc solve election problem c arbitrary number link failures n number processors r n ring without bypass last equality follows lower bound 6 rings 2 24 sensitivity absence failures algorithm presented uses log n messages worst case regardless amount faults system consider case faults occurred system election required nodes priori knowledge absence failures could execute optimal election protocol nonfaulty networks case depending chord structure lower complexity cases achieved 4 18 23 24 32 however achieve complexity required absence failures priori known specifically common knowledge 15 processors show achieve result without requiring commonknowledge first observe existing optimal algorithms election nonfaulty loop networks use specific subset chords transmit messages basic idea quite sim ple processor assumes specific incident arcs nonfaulty based assumption starts corresponding topologydependent optimal election algorithm processor x detects failure attempting transmit message protocol x start execution algorithm proposed section 2 thus failures algorithm terminates using messages failures overall cost strategy log n log n since log n approach actually leads stronger result obtain topologydependent optimal bound nonfaulty case sucient chords used faultfree 3 extensions applications consider section election problem dierent setting fact study arbitrary networks sense direction absence faults show previous results presented paper immediately used prove positive impact availability sense direction message complexity distributed problems arbitrary faultfree networks 31 sense direction sense direction refers capability processor distinguish adjacent communication lines according globally consistent scheme 12 36 example ring network property also usually referred orientation expresses processors ability distinguish left right left means processors oriented tori ie sense direction labelings added existence intuitive labeling based dimension provides sense direction hypercube 11 edge two nodes labeled node dimension bit identity dier similarly natural labeling loop networks discussed previous section sense direction networks availability sense direction shown impact message complexity election problem arbitrary network define globally consistent labeling links extending natural way existing definitions particular topologies fix cyclic ordering processors network distance sense direction processor incident link labeled according distance cycle node reached link particular link processors p q labeled distance processor p link labeled n processor q n number processors example sense direction arbitrary network shown figure 7 note definition intrinsically requires knowledge size n network includes special cases definition sense direction topologies referred oriented ring left right correspond 1 n 1 respectively oriented complete networks n set number links plus one oriented loop network circulant graph furthermore hypercubes sense direction derivable messages traditional one 11 32 election faultfree arbitrary networks consider impact sense direction message complexity election problem g f b177a f g figure 7 arbitrary network sense direction b obvious every graph subset complete graph arbitrary network incomplete complete graph less obvious fact every arbitrary network sense direction incomplete loop network every arbitrary network loop network edges removed simple observation immediate important consequences implies arbitrary graph sense direction faulty loop network compare figure 1 figure 7 missing links correspond faulty ones moreover setting every processor already know links faulty ie missing consequence algorithm described section 2 also solution election problem faultfree arbitrary graphs sense direction 25 theorem 24 follows sense direction solution log n messages exists election problem log n lower bound message complexity election problem bidirectional ring sense direction 6 follows log n also lower bound general case thus bound tight contrast arbitrary networks n processors links globally consistent labeling sense log n messages required elect leader 35 bound achievable 13 importance result shows positive impact sense direction communication complexity election problem arbitrary network confirming existing results specific topologies interesting consequence result follows comparing obtained assuming processor knows identities neighbours 20 22 namely shows possible obtain reduction message complexity requiring much less information port labels instead neighbours name concluding remarks paper presented n log n solution election problem loop networks arbitrary number links failed processor detect status incident links network partitioned algorithm detect elect leader case failures partitioned network distinctive element determined active component detect partition occurred depending application distinctive elements thus take appropriate actions moreover algorithm worstcase optimal previous results established complete graphs assumed priori bound number failures ecient solution yet developed arbitrary circulant graphs failures bounded undetectable result quite general fact algorithm easily modified solve election problem complexity faultfree arbitrary networks sense direction r election asynchronous complete networks intermittent link failures analysis chordal ring distributed loop computer networks survey new lower bound techniques distributed leader finding problems rings processors doubly link ring networks designing faulttolerant systems using automorphisms impossibility distributed consensus one faulty process optimal elections labeled hypercubes sense direction formal definition properties distributed algorithm minimum spanning tree electing leader ring link failures knowledge common knowledge distributed environ ment optimal distributed tresilient election complete networks distributed spanning tree algorithm towards optimal distributed election chordal rings distributed election protocol unreliable networks modular technique design e tight lower upper bounds class distributed algorithms complete network processors fully distributed minimal spanning tree algorithm election complete networks sense direction optimal distributed algorithms unlabeled tori chordal rings impact sense direction arbitrary networks optimal faulttolerant leader election chordal rings tolerance doubleloop computer networks multinode failures optimal faulttolerant distributed algorithms election complete networks global sense direction distributed systems reliability analysis chordal rings comments tolerance doubleloop computer networks multinode failures reliable loop topologies large local computer networks message complexity distributed problems sense direction optimal asynchronous agreement leader election algorithm complete networks byzantine faulty links leader election presence link failures multiple faulttolerant processor network architecture pipeline computing design distributed faulttolerant loop network faults faulttolerance distributed systems election problem election faulty rings incomplete size information tr ctr paola flocchini bernard mans nicola santoro sense direction distributed computing theoretical computer science v291 n1 p2953 4 january
coordinating firstorder multiparty interactions firstorder multiparty interaction abstraction mechanism defines communication among set formal process roles actual processes participate firstorder interaction enroling roles execution interaction proceed roles filled distinct processes csp enrolement statements serve guards alternative commands enrolement guardscheduling problem enable execution firstorder interactions judicious scheduling roles processes currently ready execute enrolement guards present fully distributed messageefficient algorithm enrolement guardscheduling problem first solution aware also describe several extensions algorithm including generic roles dynamically changing environments processes created destroyed run time nestedenrolement allows interactions nested b introduction multiparty interaction set io actions executed jointly number processes must ready execute action actions set occur attempt participate interaction delays process participants available actions executed participating processes continue local computation usually asynchronously languages like csp ada support interaction two processes ever many applications higher level abstraction obtained permitting interaction among arbitrary number processes example consider wellknown dining philosophers problem natural unit process interaction setting philosopher two neighboring forks ie multiparty synchronization involving three processes useful distinguish zerothorder multiparty interactions participants fixed advance firstorder multiparty interactions participants may vary dynami cally example zerothorder multicast interaction process p sends message q r captured code research supported national science foundation grant ccr8704309r notation use based ip 7 8 b interaction name x variables local p q r respectively interaction describes action taken process engaged interaction eg x means assigns x nonlocal value many existing constructs multiparty interaction zerothorder including shared actions 16 joint actions 1 interactions raddle 4 interactions ip interaction types 13 firstorder multiparty interaction abstraction mechanism defines activities among set roles serve formal process param eters actual processes participate interaction enroling 1 roles first consider partnersunnamed enrolement 9 process permitted name potential participants interaction question scheme instance interaction activated roles filled distinct processes enrolers communicate manner described interaction notion script 9 team construct raddle ip support firstorder multiparty interactions consider multicast example define firstorder interaction three roles transmitter two recipients follows firstorder interaction 2cast role recipient 1 role recipient 2 z n francez r forman suggest new word en role mean enter role execute following en rolement statements activate instance firstorder interaction transmitterm2cast x2cast r enrole recipient 2 y2cast three processes reuse 2cast interaction communicate thus decision must made whether allow concurrent activations firstorder interaction rad dle script firstorder interactions reentrant thereby permitting concurrent activations ip decision currently left unspecified paper also view firstorder interactions reentrant potential concurrency lead increased performance pointed n francez 5 absence sequentialization activations leaves interaction sole source process synchronization however also pointed 5 accompanying proof system may become complex light concurrent activations csp multiparty interactionsboth zerothorder firstordercan serve guards alternative repetitive commands zerothorder case interaction statement appearing guard executed participants agreement example consider following program r execute q r agree execute actions guardscheduling problem zerothorder interactions elegantly characterized chandy misra one committee coordination 3 professor university serves one committees members fixed furthermore committee cannot convene members present two committees common member convene simultaneously firstorder case enrolement statement appearing guard process p executed set processes including p self agree fill roles targeted interaction 2 illustrate consider following program r u firstorder interactions roles respectively p execute en role 1 two processes agree enrole 2 3 following issues peculiar implementation firstorder guards ffl since participants firstorder interaction vary dynamically determining set processes together enrole instance interaction complex zerothorder case fact show closely related maximum matching problem 11 ffl instances firstorder interaction concurrently activated ffl one process enrole role failure one preclude others filling role thus firstorder interactions inherently faulttolerant distributed algorithms 17 3 2 13 15 multiparty interaction guard scheduling zerothorder nature algorithms 3 2 15 employ fixed coordinator interaction ip situation somewhat different ips team abstraction mechanism multiparty interactions zerothorder construct ip enrolement team delay process rather multiparty interactions executed first within role 6 thus cannot realize concurrent activations firstorder interaction tolerate failure coordinator algorithms 17 13 employ mutual coordination among participants highly dependent fact participants interaction fixed therefore straightforward way adapt algorithms firstorder setting summary technical results main contribution paper section 3 distributed algorithm enrolement guard scheduling problem first firstorder solution aware algorithm admits possibility process upon reaching alternative command behave coordinator firstorder interaction thus unlike zerothorder algorithms permits concurrent activations activation coordinator also faulttolerant coordinator designated advance moreover algorithm low message complexity 6m messages per process per interaction guard number processes potentially enrole interaction algorithm bipartite graph data structure used associate processes potential roles coordinator required perform maximum matching graph decide processes schedule bestknown bound problem currently 25 time n number nodes graph 11 section 5 show setting process target one role interaction one time maximum matching safely avoided instead coordinator decide processes schedule linear time moreover use generic roles argue restriction alternative commands quite palatable practice section 6 consider partnersnamed enrolement enroler name participants firstorder interaction type enrolement initially presented context script 9 show gen eral enrolement guard scheduling setting npcomplete even enrolement statements cannot act guards however partnersnamed enrolement desirable applications example process p may times desire multicast particular group g recipients ensure message received processes g p names exactly processes recipients present two restricted naming conventions seem reasonable practice problem solved efficiently finally section 7 extend algorithm work dynamically changing environment processes may created destroyed run time problem suggested 9 6 simple model firstorder multiparty interactions consider distributed system set concurrent processes interact engaging firstorder multiparty interactions interaction 3 fixed set ri roles processes enrole role r 2 ri fixed set pr processes potentially enrole role r let ie set processes potentially enrole role assume ri pr finite known every process pi time time process enters enrole ment phase ready enrole single role set potential roles possibly different interactions define quorum set enrole r g additionally pairs quorum required componentwise mutually distinct p together leave enrolement phase activate instance p filling role r firstorder guard scheduling problem establish quorums involving mutually disjoint sets processes processes currently enrollment phases 3 sequel unless stated otherwise interaction mean firstorder type 3 description algorithm assume underlying network processes completely connected via reliable fifo communication channels processes communicate exclusively message passing furthermore messages timestamped processes use timestamps maintain logical clocks 14 31 overview process p enters enrolement phase chooses interaction ready enrole attempts establish quorum p builds quorum incrementally initially partial quorum ready assume role r g called coordinator partial quorum tries capture processes fill roles role r p chooses process p j pr sends capture request p j ready assume role r willing captured p request provides p set r j roles p j ready assume p adds pairs p r 2 r j partial quorum however request ready assume role wish captured p p must find another process role r succeed partial quorum contains quorum directs process quorum assume role quorum releases additional processes may cap tured however p determines role cannot capture process aborts attempt releases members partial quorum p another interaction 0 ready enrole attempts build quorum 0 otherwise enters idle state waiting captured reduce message complexity algo rithm allow coordinator capture older processes measure age process unique entry time obtained contents processs logical clock entered current enrolement phase 4 larger entry time process possesses younger process allowing coordinator capture older processes means youngest process quorum assemble quorum prevents processes wasting many messages attempt build quorum learn younger process yet ready ensure coordinators establish quorums involve mutually disjoint sets processes process captured one coordinator time obviously requirements different coordinators may conflict conflicts resolved using unique entry times obtained coordinator technique also proven useful implementing dynamically structured multiparty interactions 12 conflict arises coordinator attempts capture process already belongs another coordinator conflicts resolved favor older coordinators order prevent coordinator locked capturing pro cesses let older two coordinators captureretain process say p contention younger coordinator find alternative process role played p wait hoping p eventually released older coordinator either older coordinator could build quorum decided quorum excluded p coordinator p waiting captured process p j released older coordinator say capture request deferred maintain wait ing relation either one following occurs finishes succeeds aborts coordination withdraws capture request p j successfully builds quorum involving cannot build quorum involving p j p j grants p capture request 4 entry times made unique additionally considering process ids show section 4 algorithm guarantees quorum contained partial quorum p involves p prevents p coordinating one quorum another given enrolement phase assuming p old enough win contentions allowing p coordinate many quorums could severely limit systems concurrency fact show given enrolement phase exists least k quorums involve mutually disjoint sets processes least k coordinators establish quorums involve mutually disjoint sets processes 32 algorithm process p executes concurrently two compo nents coord slave use coord realize behavior p p acts coordinator partial quorum described earlier slave behavior reacting capture requests algorithm coordinators communicate exclusively slaves vice versa recall coordinator p starts partial quorum involving slave initially captured coord strategy resolving conflicts guarantees slave remain captured coord coord established quorum entered idle state due inability build quorum coord j attempts capture slave p j older allowed capture slave however p j younger coord wins contention retains slave therefore never case two components get outof synch eg coord still busy building quorum slave already advanced next enrolement phase coord proceeds follows coord maintains following variables current partial quorum contains pairs r p j ready assume role r slave j captured coord set pairs p r p j ready assume role r slave j deferred capture request coord r set slaves coord requested capture coord starts quorumbuilding activity process p enters enrolement phase begins selecting interaction process p ready enrole sets ready assume role r g g coord executes following procedure build quorum suc cessful ie p contains quorum q coord sends successi r j slave j p directing p j enrole role r j coord also releases additional slaves may captured sending slave release message withdraws capture request made slave sending withdrawal message coord fails establish quorum releases every captured slave except slave withdraws capture request made slave coord another yettobetried interaction 0 continues attempting build quorum building activity becomes idle procedure build quorum follows contains quorum q must involve versely coord fails build quorum ei ther exists role r every slave pr requested coord ready assume role every slave pi either captured coord rejected capture coord p contain quorum ffl coord yet succeeded failed proceed conservativelyby waiting slave process grant reject deferred capture request aggressively sending new capture request slave process p r hoping p ready fill role would assist coord reach quorum choice constitutes fine tuning algorithm conservative approach may result fewer messages aggressive approach may give better response time slave j grants coord deferred request coord moves pairs form p r p slave j rejects coord deferred request coord deletes pairs coord wishes capture another slave k adds p k r sends requestt slave k waits response slave k entry time p response coord adds p k r p r 2 r response deferred r adds p k rs otherwise nothing meanwhile coord receives switch message captured slave j asking release slave j coordinator older coord wishes capture slave j coord replies switch ok request moves pairs p slave proceeds follows slave maintains priority queue triples p slave deferred capture request highest priority given triple smallest timestamp slave waits captor coord k establish quorum slave initially captured coord coord starts quorumbuilding ac tivity slave receives successi r coord k sends triple p queue ie deferred requests jected slave enroles role r ever coord k sends release message slave without placing p quorum slave deletes queue triple p smallest 0 set roles p assume interaction 0 slave grants oldest deferred capture requests consistent strategy resolving conflicts queue empty slave idles waiting captured slave may also receive requestt j 0 coordinator coord j p ready enrole 0 p younger p j slave rejects coord j request otherwise two cases slave captured coordinator grants coord j request 2 slave captured coord k p k older p j slave remains captured coord k inserts triple p priority queue sends deferred r 0 coord j r 0 set roles p assume interaction 0 else slave sends switch coord k asking release slave receiving confirmation switch ok slave grants coord j request inserts triple p queue thereby deferring coord k capture request also slave receives withdrawal coord l simply deletes coord l capture request queue algorithms coord slave given figures 1 2 respectively together constitute algorithm firstorder guard scheduling problem algorithm presented csplike repetitive construct guarded command numbered ease reference assume weakfairness ie every command whose guard continuously enabled eventually exe cuted note coordinator slave process p logically separate guarded commands components combined single repetitive construct figures 1 2 entry time process respect current enrolement phase given variable also variable g represents set roles p ready assume contains pairs r p ready assume set r roles g updated enrolement phase reset p leaves phase 33 example illustrate algorithms behavior consider interaction three roles r 1 r 3 assume ready role r 1 r 2 p 5 r 3 furthermore entry times six processes increasing youngest following give possible scenario events six processes 11 active aborted send release slave j send withdrawal slave j tried send release slave active false 12 active target recruit send r 13 active contains quorum q gamma p send slave j send release slave j send withdrawal slave j active false 14 receive yest r 0 slave j gamma r 2 r r 2 r p target else gamma skip receive 0 slave j gamma target else gamma skip 16 receive switch slave j gamma contain quorum send switch ok slave j else gamma skip 17 receive deferred r slave j gamma r 2 r f p target current partial quorum set pairs p r p j ready assume role r slave j deferred capture request coord r set slaves p requested capture active flag true iff coord coordinating quorum interaction active denotes interaction coord coordinating target slave coord sent capture request yet received response tried flag true iff coord tried establish quorum aborted returns true iff attempt build quorum failed ie either 9r 2 p contain quorum initially aborted true command 11 applied recruit returns slave process p j coord attempt capture returns nil otherwise fewer messages return nil whenever 6 better response time return slave process role r coord needs process assume r figure 1 algorithm coord 21 receive successi r coord j gamma p send queue enrole role 22 receive release coord j gamma captured false 23 receive requestt gamma queue captured gamma let captor p gamma reply reply send switch coord k swflag true gamma send deferred coord j captured gamma reply reply else gamma send 24 receive switch ok coord j gamma queue captured false 25 receive withdrawal coord j gamma captor gamma captured false queue reply gamma reply reply else gamma skip delete p j queue send coord j captor p j reply gamma reply reply reply let send deferred reply swflag false captured flag true iff slave captured slave sets captured true upon entering enrole ment phase swflag flag true iff slave already sent switch current captor coordinator older slave captor wishes capture slave captor triple p slave captured entry time j coordinating interaction slave sets captor p upon entering enrolement phase queue priority queue triples p capture request requestt deferred slave highest priority given triple smallest oldest j delete operation returns triple reply set coordinators slave yet replied capture requests figure 2 algorithm slave executing algorithm requests capture slave 3 jected issues request slave 4 rejected p 1 older p 3 p 4 coord 1 releases slave 1 idles ffl similarly coord 2 coord 3 release companion slaves become idle rejected slave 5 slave 6 captures slave 1 coord 6 request capture slave 4 belongs coord 4 requests deferred slave 4 younger p 4 requests capture slave 5 slave 6 rejected releases slave 1 slave 4 idles slave 4 grants coord 5 capture request captures slave 1 requests capture slave 1 since p 5 older p 6 captures slave 1 coord 6 capture request deferred slave 1 coord 5 established quorum involving p 5 ffl capturing slave 2 slave 3 coord 6 established another quorum 4 analysis algorithm section prove algorithm satisfies requisite safety liveness properties analyze message complexity theorem 1 safety time process participate one established quorum proof consequence fact coordinator establish quorum captures processes involved quorum process captured one coordinator time request cannot deferred forever infinitely often proof capture request issued coordinator slave p j may granted rejected deferred p j however capture request granted may later need deferred order resolve conflict defer p capture request forever infinitely often must exist p k older p p j remains captured p k ever p k continually recaptures p j infinitely ten however p k must stay enrole ment phase time recaptures younger p p k obtains new entry time therefore slave would also deferred p k capture request forever infinitely often would imply existence infinite sequence coordinators strictly increasing ages con tradiction 2 theorem 2 liveness whenever exists quorum within finite amount time process quorum enrole interaction proof sketch suppose exists quorum q interaction let p youngest process q either 1 process q participates established quorum 2 eventually establish q since process q reject p lemma 1 eventually processes q captured p either case theorem proven 2 established process must involve p fact p youngest process quorum proof process p cannot captured different process unless p entered idle state due inability build quorum exists quorum q interaction p youngest process process capture p p attempted build quorum proof theorem 2 succeed establishing q unless process q participated established quorum 2 analyze algorithms message complexity define p number messages transmitted p generated processes response p messages p coordinating consider worstcase scenario 1 coord sends request message slave j 2 slave j captured coord k younger coord slave j sends switch message coord k 3 coord k sends confirmation switch ok slave j coord k capture request deferred slave j 4 slave j sends yes message coord 5 coord establishes quorum involving p j sends success message slave j 6 p j placed quorum slave j sends coord k rejecting coord k deferred capture request somewhat different scenario coord fails place p j quorum thus sends release slave j slave j would send coord k yes message grant deferred capture request therefore attempt capture slave j coord generates 6 messages theorem 3 let p number messages transmitted p generated processes response p messages p coordinating p 6 j pi j 5 maximum matching symmetric roles activation instance interaction requires role filled distinct process however process enrollment phase may ready different roles interaction let p partial quorum coordinator p decide whether p contains quorum p needs find p subset q size jrij two elements q specify role process instance maximum matching problem thus solved om 25 time number processes captured coordinator p clearly avoid performing maximum matching therefore reduce time complexity linear allow process ready one role interaction fact many multiparty applications certain roles interaction symmetric sense process enrole one without observing difference process tries symmetric roles unaware targeted processes wants avoid locked example recipient roles firstorder multicast interaction section 1 symmetric deadlock could arise two processes specify unwittingly role recipient 1 even though role recipient 2 would equally suffice avoid dilemma process attempting participate recipient would somewhat unnaturally target recipient roles facilitate pleasant form enrole ment symmetric roles replaced single generic role constant indicating number instances role filled process target generic role without concern instance actually fill constant could even parameterized supplied run time another enroler considering multicast example define firstorder interaction transmitter generic recipient role filled processes transmitter would supply actual value therefore instances interaction activated somewhat different role structures within setting generic roles reasonably restrict process ready one role interaction time without raising risk deadlock 6 partnersnamed enrolement partnersnamed enrolement process name enrolers 9 set processes activate interaction naming specifications must consistent sense fill role r k p j indeed enroles r k note naming need bilateral unfortunately guard scheduling problem becomes intractable even process ready one interaction enrole ment phase ie enrolement statements cannot act guards theorem 4 given set partnersnamed en rolement statements specified distinct pro cess problem deciding whether subset consistent naming partners npcomplete proof reduction monotone oneinthree discussed introduction partnersnamed enrolement desirable applications following present two less severe forms scheme efficient implementations even enrolement statements serve guards first define communication graph interaction undirected graph node set ri edges r directly communicate partnersfullynamed enrolement process wants name partners names directpartnersnamed enrolement process names processes communicates directly moreover set enrolement guards alternative command must satisfy disjointedness condition two guards target role name common partner first restriction simpler formulate second may useful practice example multicast reasonable transmitter names recipients recipients required name transmitter fellow recipients disjointedness condition second form crucial allowing enrolement statements serve guards otherwise one show guard scheduling problem still intractable regarding two restricted forms partners named enrolement finding set enrolement statements consistent naming specifications done linear time assuming interactions communication graph connected algorithm presented section 3 easily extended implement two forms 7 dynamically changing environment algorithm also extended dynamically changing environment processes created destroyed run time assume model time processes spawn new processes however process destroyed parent enrolement phase process p j creates new child capable playing role r informs existing process p 2 pi identity new process p update pr return p sends p j acknowledgement message timestamp p j sets logical clock new process larger waiting parent set clock new child defers capture requests may arrive deferred requests rejected new process clock finally set similarly process p j 2 pi destroyed informs existing processes pi remove p j pi since process destroyed enrolement phase safety property theorem 1 still guaranteed liveness property holds well newly created process p j always younger existing coordinator p hence unable contend p capturing slave see section 3 also need attempt capture p j attempt doomed fail anyway coordinator cannot capture younger slave therefore p need request capture processes created current enrolement phase tunately set processes finite 8 conclusion presented efficient distributed algorithm firstorder guard scheduling problem first algorithm aware also described several extensions algorithm including generic roles directpartners named enrolement dynamically changing environments addressed possibility allowing enrolement statements within roles leads notion nested enrolement nthorder interaction nested enrole ment exists form already ip script algorithm safely applied level enrolement level n enrolement involve roles level eventually filled actual processes reducing problem firstorder en rolement future work focus lowering constant message complexity currently o6m finding probabilistic completely symmetric solution problem acknowledgement thank prof nissim francez providing us several references ip valuable insights language shaji bhaskar constructive comments presentation algorithm r distributed cooperation action systems process synchronization design performance evaluation distributed algorithms foundation parallel program design design large distributed systems private communication conflict propaga tion interacting pro cesses multiparty approach coordinated distributed programming interacting pro cesses language coordinated distributed pro gramming script communication abstraction mecha nism computers intractability guide theory np completeness n 52 algorithm maximum matching bipartite graph efficient dynamically structured multiprocess communication implementation nparty synchronization using tokens time clocks ordering events distributed system distributed synchronization scheme fair multiprocess hand shakes new class highlevel programs distributed computing systems new efficient implementation multiprocess synchronization tr script communication abstraction mechanism verification multiway rendezvous new efficient implementation multiprocess synchronization appraising fairness distributed languages distributed cooperation action systems parallel program design foundation communication concurrency synchronization asynchronous processes csp process synchronization multiparty interactions interprocess communication synchronization distributed synchronization scheme fair multiprocess handshakes fairness hyperfairness multiparty interactions interacting processes language coordinated distributed programming design implementation multiparty interaction comprehensive study complexity multiparty interaction interacting processes time clocks ordering events distributed system communicating sequential processes solution problem concurrent programming control new class high level programs distributed computing systems ctr yuhjzer joung scott smolka strong interaction fairness via randomization ieee transactions parallel distributed systems v9 n2 p137149 february 1998 yuhjzer joung strongfeasibilities equivalencecompletions proceedings fifteenth annual acm symposium principles distributed computing p156165 may 2326 1996 philadelphia pennsylvania united states yuhjzer joung scott smolka comprehensive study complexity multiparty interaction journal acm jacm v43 n1 p75115 jan 1996
randomness hard study set incompressible strings various resource bounded versions kolmogorov complexity resource bounded versions kolmogorov complexity study polynomial time cd complexity defined sipser nondeterministic variant cnd due buhrman fortnow polynomial space bounded kolmogorov complexity cs introduced hartmanis measures define set random strings mathrmrmathitcdt mathrmrmathitcndt mathrmrmathitcst set strings x mathitcdtx mathitcndtx mathitcssx greater equal length x polynomials show following mathrmma subseteq mathrmnpmathrmrmathitcdt mathrmma class merlinarthur games defined babai mathrmam subseteq mathrmnpmathrmrmathitcndt mathrmam class arthurmerlin games mathrmpspace subseteq mathrmnpmathrmcrmathitcss last item mathrmcrmathitcss set pairs langle xy rangle x random given results show set random strings various resource bounds hard complexity classes nondeterministic reductionsthis paper contrasts earlier work buhrman mayordomo show polynomial time deterministic reductions set exponential time kolmogorov random strings complete exp b introduction holy grail complexity theory separation complexity classes like p np pspace well known classes possess complete sets thus sucient separation show complete set one class contained therefore lots eort put study complete sets see bt98 kolmogorov lev94 however suggested focus attention sets complete intuition complete sets possess lot structure hinders possible lower bound proof suggested look set time bounded kolmogorov random strings paper continue line research study variants set kolmogorov complexity measures amount regularity string informally kolmogorov complexity string x denoted cx size smallest program prints x stops string x cx less equal length x additive constant strings holds cx greater equal length x called incompressible random simple counting argument shows random strings exist sixties theory kolmogorov complexity developed martin mar66 showed core set kolmogorov random strings complete respect resource unbounded turing reductions kummer kum96 shown strengthened show set also truthtable complete resource bounded version random strings rst studied ko ko91 polynomial time bounded kolmogorov complexity c p x p polynomial smallest program prints x pjxj steps har83 ko showed exists oracle set random strings respect time bounded kolmogorov complexity complete conp strong nondeterministic polynomial time reduc tions also constructed oracle set complete conp deterministic polynomial time turing reductions buhrman mayordomo bm95 considered exponential time kolmogorov random strings exponential time kolmogorov complexity smallest program prints x tjxj steps functions showed set tn random strings deterministic polynomial time turing hard exp showed class sets reduce set p measure 0 hence set even weakly hard exp results paper contrast buhrman mayordomo show set random strings hard various complexity classes nondeterministic polynomial time reductions consider three well studied measures kolmogorov complexity lie c p x c x p polynomial consider distinguishing complexity introduced sipser sip83 distinguishing complexity cd x size smallest program runs time tn accepts x nothing else show set random strings r cd xed polynomial hard nondeterministic reductions class merlin arthur games introduced babai bab85 immediate consequence obtain bpp np bpp np r cd next shift attention nondeterministic distinguishing complexity dened size smallest nondeterministic algorithm runs time tn accepts x dene r cnd xed polynomial show np r cnd class arthurmerlin games bab85 follows complement graph isomorphism problem gi np r cnd polynomial r cnd sn space bounded kolmogorov complexity cs xjy dened size smallest program prints x given uses sjxj tape cells har83 likewise dene cr cs sn polynomial show pspace np cr cs rst two results use oblivious sampler construction zuckerman zuc96 lemma bf97 measures size sets terms cd complexity prove lemma shows rst bits random string sense random whole string last result make use interactive protocol lfkn92 sha92 qbf show optimality results relativizing techniques construct oracle world rst result improved deterministic reductions show oracle bpp 6 p r cd polynomial construction oracle extension techniques developed beigel buhrman fortnow bbf98 denitions notations assume reader familiar standard notions complexity theory found eg bdg88 strings elements string integers n jsj use notation snm string consisting nth mth bit use empty string also need notion oblivious sampler zuc96 denition 21 universal r oblivious sampler deterministic algorithm input uniformly random rbit string outputs sequence points z collection functions case pr application denition always use single function f fix universal turing machine u nondeterministic universal machine u n results independent particular choice universal machine denition kolmogorov complexity need fact universal machine input p halt output string x denition distinguishing complexity need fact universal machine input p x either accept reject also need resource bounded versions property dene kolmogorov complexity function cxjy see lv97 xg dene unconditional kolmogorov complexity hartmanis dened time bounded version kolmogorov complexity har83 resource bounded versions kolmogorov complexity date back far bar68 see also lv97 sipser sip83 dened distinguishing complexity cd need following versions resource bounded kolmogorov complexity distinguishing complexity uses see har83 1 x accepts rejects runs see sip83 1 u n p x accepts rejects runs see bf97 0 1 dene following sets strings maximal cd p cnd p complexity note sets sets mentioned introduction case omit use r cd r cnd also dene set strings maximal space bounded complexity cr cs c notation emphasize randomness conditional also cr cs technically set pairs rather set strings unconditional space bounded random strings would r cs g theorems concerning set ccomplexity string always upperbounded length plus constant depending choice universal machine cd cndcomplexity string always upperbounded c complexity string plus constant depending particular choice universal machine quantiers used paper polynomially bounded often particular polynomial important sequel clear context omitted sometimes need explicit bounds particular bound given superscript quantier eg use 9 denote exists jyj 8 n x denote x length n classes dened follows denition 22 l 2 exists jxj c time bounded machine 1 x 2 l 9yprmx 2 r chosen uniformly random f0 1g jxj c exists jxj c time bounded machine 1 x 2 l pr9ymx 2 r chosen uniformly random f0 1g jxj c known np bpp pspace bab85 let mx represent number accepting computations nondeterministic turing machine input x language l p exists polynomial time bounded nondeterministic turing machine x let g function say advice function f gbounded n holds jfnj gn paper interested functions g polynomial notation sn used strong nondeterministic turing reductions dened sn distinguishing complexity derandomization section prove hardness r cd r cnd arthurmerlin merlinarthur games respectively npreductions theorem 31 tn 2 n log n np r cd theorem 32 tn 2 n np r cnd proof theorems roughly follows first guess string high cd poly complexity respectively cnd poly complexity next use nondeterministic reductions play role merlin use random string derandomize arthur note straightforward might look randomness used arthur interactive protocols used hiding general substituted computational randomness idea using strings high cdcomplexity zuckermans sampler derandomization stems bf00 section 8 full version bf97 though explicitly dene set r cd use approach derandomize bpp computations proof needs string high cd p respectively cnd p complexity polynomial rst show nondeterministically extract string longer string high cd complexity respectively cnd complexity xed tn 2 n log n lemma 33 let f fn n let 0 suciently large cd holds cd 0 proof suppose contradiction constant 0 innitely many cd holds cd 0 log jfjsjj 0 exists program p runs recognizes s1fjsj jp j fjsj 2 log jfjsjj 0 following program recognizes string input check rst fjsj bits equal using p assume jfjsjj stored program cost log jfjsjj bits check last jsj fjsj bits equal bits also stored program program runs time therefore takes tjsj steps u suciently large hs66 lose log n factor algorithm must run xed machine simulation deterministic programs length jp log jfjsjj less jsj almost hence cd jsj contradicts assumption 2 corollary 34 every polynomial n c 2 n log n suciently large string cd c proof take 0 c apply lemma 33 2 lemma 33 corollary 34 following nondeterministic analogon lemma 35 every polynomial n c 2 n suciently large string cnd c proof proof applies lemma similar lemma 33 ever nondeterministic case simulation costs linear time bgw70before proceed proof theorems also need earlier results rst need following theorem zuckerman theorem 36 zuc96 constant c exists universal r oblivious sampler runs polynomial time uses bits outputs also need following lemma buhrman fortnow lemma 37 bf97 let set p string x 2 n holds cd p x 2 logjja n jj olog n polynomial p noted bf97 analogous lemma holds cnd p np lemma 38 bf97 let set np string x 2 n holds cnd p x 2 logjja n jj olog n polynomial p results prove theorems theorem 31 want prove np machine oracle oracle r cd recognize set positive side proof easy x exists machine string 23 fraction strings r length jxj c makes mx accept np machine certainly guess one pair x proof x 2 negative side harder show 2 substitute r string high enough cd complexity cnd complexity theorem 32 make mx accept grasp intuition behind proof let us look much simplied example bpp machine 13 error probability input x string r maximal unbounded kolmogorov complexity 2 jxj k possible computations input x jxj k runtime suppose must accept x 13 fraction ie 2 jxj c computations reject x rejecting computation consists deterministic part described x set jxj c coin ips set coin ips binary string rejecting computation uniquely identies string length jxj c call set b would like show contradiction random string cannot member set hence random string used sequence coin ips leads correct result string b described x index b length log jjbjj jxj c log 3 far grounds contradiction since description consisting elements length greater jxj c however amplify computation input x repetition taking majority repeating computation x times blows number incorrect computations using x c1 random bits however large enough x description jxj plus minus additive constant depending denition kolmogorov complexity used smaller jxj c1 thus lead contradiction unfortunately case situation bit complicated factor 2 lemma 37 renders standard amplifaction randomized computation useless fortunately theorem 36 allows dierent type amplication using much less random bits type argument used proceed show amplication given theorem 36 situation lemma 39 1 let l language constant k constant 0 1there exists deterministic polynomial time bounded machine r chosen uniformly random strings f0 1g 11km 2 let l language constant k constant 0 exists deterministic polynomial time bounded machine x 2 l pr9ymx r chosen uniformly random strings f0 1g 11km proof 1 furer et al showed fraction 23 see denition 22 replaced 1 fgm 89 let ml deterministic polynomial time machine corresponding l denition 22 adapted accept probability 1 x 2 l assume ml runs means ml 9y 8y denition assumed 9 n c 8 n c respectively also random string may assumed drawn uniformly random f0 1g n c obtain value 2 km second item use theorem 36 16 given x let f xy fp function input z computes ml x use oblivious sampler get good estimate ef xy feed random string length 11km oblivious sampler returns sample points z compute 1 machine computes sum input x r accepts value greater 12 x 2 l prml x matter sample points returned oblivious sampler probability 1 sample points returned oblivious sampler 1 probability 2 km 2 2 proof analogous proof part 1 explain dierences 1 rst item claim refer fgm 89 theorem 2ii paper part ml deterministic polynomial time machine corresponding amlanguage l dene function f x f0 1g 7 0 1 function input z computes 9 n c fp np computable function sample points z z returned case following properties x 2 l matter string returned z every possible sample point z ml x set sample points z sampler may return exists ml x half sample points probability 1 pr less 2 km let mx r deterministic polynomial time machine uses r generate sample points interprets counts number accepts ml x accepts number greater 1d get exactly desired result 2 next lemma show string high enough cd poly cnd poly used derandomize protocol lemma 310 1 let l language 0 1 exists deterministic polynomial time bounded machine polynomial q 0 integers k c almost n every r 2 let l language 0 1 exists deterministic polynomial time bounded machine polynomial q 0 integers k c almost n every r proof 1 choose k 6 let deterministic polynomial time bounded machine corresponding l k lemma 39 item 1 polynomial n c time bound machine witnessing l 2 lemma determine q later assume r string length 1 cd q r jrj ease notation set suppose x 2 l follows exists length 1 1 particular holds mx suppose x 62 l show case suppose true let 0 xy 0 follows xy0 2 p essentially program simulates x 0 hardwired although xy0 nite therefore trivially p crucial size polynomial program roughly amplication protocol since r 2 xy0 follows lemma 37 polynomial p hand chose r cd q r jrj gives contradiction q p 2 choose k 5 let deterministic polynomial time bounded machine corresponding l k lemma 39 item 2 n c time bound machine witnessing determined later assume r string length 1 c cnd q r jrj suppose x 2 l follows exists 1 particular r mx r suppose l show 8ymx true dene 1g x 2 np program x hardwired guesses simulates amplication protocol jja x jj 2 11km km since r 2 x follows lemma 38 exists polynomial p hand chose r cnd q r jrj gives contradiction whenever q pthe following corollary shows string high enough cd poly complexity used derandomize bpp machine see also theorem 82 bf00 corollary 311 let set bpp 0 exists polynomial time turing machine polynomial q cd q r jrj x length n holds x 2 proof theorem 31 let language let q lemma 310 item 1 nondeterministic reduction behaves follows input x length n first guess size check 2 r cd set accept exists mx 1 corollary 34 follows cd q r jrj2 correctness reductions follows directly lemma 310 item 1 proof theorem 32 follows directly lemma 310 item 2 npalgorithm analogous one corollary 312 2 n log n 1 bpp np bpp included np r cd 2 gi 2 np r cnd follows r cnd graph isomorphism problem gi np conp limitations previous section showed set r cd hard reductions one might wonder whether r cd also hard stronger reduction like deterministic polynomial time turing reduction section show true need nonrelativizing proof derive following theorem theorem 41 relativized world every polynomial proof theorem given lemma 42 says statement theorem 41 true world p np poly theorem 43 precisely shows existence world lemma 42 oracle 0 1 holds exp np np poly p proof suppose contradiction lemma true exp np nppoly exp nppoly exp ph yap83 furthermore exp np nppoly certainly exp np exppoly follows bh92 exp see bft97 denition p vv86 np bpp implies ph bpp zac88 finally fact uniquesat p equivalent x c poly xjy cd poly xjy o1 shown fk96 use proof fk96 show uniquesat p also implies r cd particular universal machine note need contradict assumption one particular type universal machine turn implies assumption bpp hence exp np p np however contradicts hierarchy theorem relativized turing machines hs65 parts proof relativize get result oracle theres one caveat though r cd clearly meaningful terpretation talk p r cd one must course allow p access oracle clear p ask question machine ask question random strings therefore one might argue p r cd aa actually statement lemma aect proof universal machine say u following input p x u uses cooklevin reduction produce formula f jxj variables property x satises f p accepts x u uses selfreducibility f assumed polynomial time algorithm uniquesat make acceptance x unique rst number variables equal jyj rejects using wellknown substitute reduce algorithm sat veries assignments successively obtained algorithm algorithm precisely accepts rejects algorithm accepts using universal machine every program accepts one string therefore r cd via obvious predicate argued gives us contradiction 2 proceed construct oracle theorem 43 exists oracle exp np proof proof parallels construction beigel buhrman fortnow bbf98 construct oracle p np use similar setup let nondeterministic linear time turing machine language l dened p complete every every oracle let k linear time computable complete set np let n k deterministic machine runs time 2 n every accepts language h complete exp np construct exists n 2 bounded advice function f w condition condition 1 condition 0 guarantee exp np nppoly use term 0strings strings form 0 w 1 jwj 2 1strings strings form 1 z w v strings immediately put first give intuition proof linear time turing machine therefore setting 1strings forces setting 0 strings condition 0 automatically fullled describing set 1strings force 0strings dened condition 0 fullling condition 1 requires bit care since n k query exponentially long double exponentially many 0 1strings consider 1string 1 z w v 01 valued variable zwv whose value determines whether 1 z w v construction wil force correspondence computation n k x low degree polynomial variables values gf 2 encode computation properly use fact function high degree assign polynomial p z gf2 0strings 1strings z ensure z 1 p z 2 p z first 1string z 1 z w v let p z single variable polynomial zwv assign polynomials 0strings recursively note x query 0strings jwj jxj consider accepting computation path mx assuming oracle queries guessed correctly let queries path b query answers b query guessed b note let p set accepting computation paths mx dene polynomial p z follows p remember working gf2 addition parity setting variables zwv thus 1strings forces values z 0strings set things properly following lemma straightforward lemma 44 0string 2 condition 0 satised polynomial p z degree proof simple proof induction jxj 2 construction done stages stage n code strings length n h setting 1strings automatically 0strings thus fullling condition 0 1 stage need know degree multivariate multilinear polynomials representing function lemma 45 representation functions oru um um multivariate multilinear polynomials gf2 requires degree exactly proof every function gf2 unique representation multivariate multilinear polynomial note product using de morgans laws write construction oracle treats strings length n lexicographic order first forcing phase oracle set computations n k remain xed future extensions oracle next coding phase rst advice string picked computations forced coded oracle way retrieved np machine advice string great care course taken two phases dont disturb disturb earlier stages construction rst describe forcing phase without loss generality assume machine n queries strings form q 2 k note since n runs time 2 n may query exponentially long strings k let x 1 rst string length n examine computation nx 1 encounter rst query q 1 k try extend oracle 0 q 1 2 k 0 extension exist may assume q 1 never k matter extend future must however take care disturb previous queries forced k end build set containing previously encountered queries forced k extend q 2 holds q 2 k 0 call extension sconsistent extension returning computation nx 1 q 1 ask whether sconsistent extension q 1 2 k 0 extension exists choose sconsistent extension adds minimal number strings put q 1 next continue computation answered yes otherwise continue q 1 answered next lemma shows minimal extension never add 2 3n strings lemma 46 let q query k suppose stage n exists sconsistent extension q 2 k 0 exists one adds 2 3n strings proof let mk machine accepts k given oracle consider computation machine l smallest set strings adding sconsistent extension 0 k q accepts consider leftmost accepting path 0 k q let q queries 0 1queries path moreover let b 1 dene q following polynomial p adding strings l p lemma 44 degree p q 2 2n hence degree p q 2 3n consider happens take number strings l 0 resulting 00 since minimal extension follows 00 k q rejects p computes l strings since lemma 45 degree unique multivariate multilinear polynomial computes l variables gf2 l follows l 2 3n 2 dealt queries encountered n k continue process strings length n lexicographic order note since extend sconsistently never disturb computation n k lexicographic smaller strings follows since queries forced yes remain yes queries could forced sconsistent extension never forced 0 consistent extension 0 nished process code computations n strings length n easy see jjsjj 2 2n point lemma 46 2 5n strings added stage closing forcing phase pick advice string proceed coding phase standard counting argument shows string z length n 2 strings form 1 z w v added string z advice strings length n show code every string x length n correctly fulll condition 1 lexicographic order suppose coded strings x j j correctly want code x two cases case put strings 1 z x thus set variables 0 since change oracle sconsistent extension properly extend sconsistently adding strings form 1 z x following lemma shows always done proper extension one adds one strings lemma 47 let jjsjj 2 2n suppose n k exists proper sconsistent extension adding strings form proof suppose proper sconsistent extension exists consider following polynomial q2s p q dened lemma 46 equation 2 initially q degree q x 2 5n since every extension strings w consistent follows q x computes variables zx w since 2 n 2 many variables lemma 45 contradiction degree q x hence exists proper sconsistent extension adding strings form properly coded 2 stage n ends coding strings length n completes proof theorem 43 2 theorem 43 together proof lemma 42 also gives following corollary corollary 48 exists relativized world exp np bpp oracle also extends oracle ko ko91 cd poly complexity follows corollary 49 exists oracle r cd 2 n logn 0 complete np strong nondeterministic reductions oracle theorem 43 world conp bpp poly poly xjyo1 hence follows r cd corollary 312 relativizes item 1 bpp np r cd 2 byproduct oracle shows following corollary 410 9a uniquesat 2 p p np corollary indicates current proof shows unique pcan improved yield collapse p np using relativizing techniques 5 pspace cr cs section study connection cr cs interactive proofs far established strings suciently high cnd poly complexity used derandomize ip protocol two rounds way role prover verier played np oracle machine see also true ip provided random strings high enough space bounded kolmogorov complexity class quantied boolean formulas qbf dened closure set boolean variables x negations x operations 8x 9x qbf variables quantied called closed qbfs called open need following denitions theorems sha92 denition 51 sha92 qbf b called simple given syntactic representation every occurrence variable separated point quantication one universal quantier arbitrarily many symbols technical reasons also assume simple qbfs contain negated variables negations loss generality since negations pushed way variables denition 52 sha92 arithmetization expression obtained b replacing every positive occurrence x variable z every negated occurrence x 1 z every every every 8x z 2f01g every 9x z 2f01g follows arithmetization simple qbf closed form integer value whereas arithmetization open qbf equivalent possibly multivariate function denition 53 sha92 functional form simple closed qbf univariate function obtained removing arithmetization b either z 2f01g z 2f01g least index variable possible simple qbf quantiers boolean formula obtained b removing quantiers denote b arithmetization b 0 wellknown language true qbfs complete pspace restriction true qbfs simple qbfs remains complete theorem 54 sha92 language closed simple true qbfs complete pspace polynomial time manyone reductions straightforward arithmetization qbf takes positive value qbf true fact also holds relative large prime theorem 55 sha92 simple closed quantied boolean formula b true exists prime number p size polynomial jbj value arithmetization b positive modulo p moreover b false value arithmetization b 0 modulo prime theorem 56 sha92 functional form every simple qbf represented univariate polynomial degree 3 theorem 57 sha92 every simple qbf exists interactive protocol prover p polynomial time bounded verier v 1 b true p honest v always accepts proof 2 b false v accepts proof negligible probability proof theorem 57 essentially uses theorem 56 translate simple qbf polynomial following way first arithmetization simple qbf b closed form integer value v positive b true bs functional form f recall arithmetization qbf obtained b deleting rst quantier univariate polynomial p 1 degree 3 property p 1 substituting value r 1 p 1 gives new integer value v 1 course value get substitute r 1 f however f r 1 converted low degree polynomial deleting rst p q sign game repeated thus obtain sequence polynomials rst polynomial sequence v computed last polynomial p n property p n r things needed first sequence polynomials q property q 1 q r intersection point p q second calculations done modulo prime number polynomial size theorem 55 summarize following observation actually skeleton proof theorem 57 observation 58 sha92lfkn92 let b closed simple qbf wherein quantiers q read left right syntactic representation let arithmetization let v value exist prime number p size polynomial jbj sequence r numbers taken 1p sequence polynomials degree 3 size polynomial jbj 1 2 3 4 sequence univariate polynomials q b q c q n r n minimal p intersection point p q inequalities hold modulo p hold modulo prime polynomial size b false moreover p computed space jbj b p r reformulation theorem 57 obtain sequence univariate polynomials q sequence values r items 2 3 observation 58 holds either q 1 true value arithmetization b polynomial q sequence r intersection point p q p observation 58 p computed quadratic space b latter case r cannot high space bounded kolmogorov complexity relative b p hence r high space bounded kolmogorov complexity r intersection point rst case must hold ie value computed q 1 true value arithmetization b following lemma makes precise lemma 59 assume following b p n 1 b simple false closed qbf n variables 2 p prime number 2 jbj size polynomial jbj 3 sequence polynomials degree 3 coecients 4 r numbers 1p 5 7 8 proof take calculations modulo p suppose q 1 follows observation 58 exists sequence items 1 3 lemma furthermore since b false prime follows must minimal p 6 q r intersection point p q however p computed space jbj b p r p q degree 3 follows cs n r bounded constant contradiction 2 suces main theorem section let polynomial theorem 510 pspace np cr cs proof prove lemma proof padding extended polynomial exists np oracle machine accepts language simple closed true quantied boolean formulas follows input b rst check b simple guess prime number p size polynomial b sequence polynomials degree 3 coecients 1p finally guess sequence numbers size jp j check 1 2 3 4 nally least jp j n b true lemma 58 guarantees items guessed tests passed b false test fails lemma 59 guarantees p 1 rst check must fail 2 fact pspace closed complement fact cr cs also pspace theorem 510 gives cr cs complete pspace strong nondeterministic reductions lon82 corollary 511 cr cs complete pspace strong nondeterministic reductions buhrman mayordomo bm95 showed set r c jxjg hard exp deterministic turing reductions theorem 510 made use relativized kolmogorov complexity ie cs xjy using exactly proof bm95 one prove set cr c jxjg hard exp turing reductions hand proof theorem 510 also works set pspace np cr c suspect possible extend show exp np cr c far unable prove acknowledgements thank paul vitanyi interesting discussions providing title paper also thank two anonymous referees helped number technical issues cleared much proofs pointed us correct references one referees also pointed corollary 48 r trading group theory randomness complexity programs determine whether natural numbers greater n belong recursively enumerable set np might easy detecting unique solutions resource bounded kolmogorov complexity revisited resource bounded kolmogorov complexity revisited six hypotheses search theorem superpolynomial circuits excursion kolmogorov random strings complete sets structure subrecursive classes completeness soundness interactive proof systems generalized kolmogorov complexity structure feasible computations computational complexity algorithms two tape simulation multitape turing machines complexity learning minimum timebounded turing machines complexity random strings extended abstract personal communication strong nondeterministic polynomialtime reducibilities completeness recursion theorem e complexity theoretic approach randomness np easy detecting unique solutions consequences nonuniform conditions uniform classes probabilistic quanti tr
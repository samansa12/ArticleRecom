randomnessrounds tradeoff private computation study role randomness multiparty private computations particular give several results prove existence randomnessrounds tradeoff multiparty private computation fxor show single random bit thetan rounds necessary sufficient privately compute fxor n input bits dge 2 random bits omegalog n rounds necessary olog n log sufficient generally show private computation boolean function f using dge 2 random bits requires omegalog sf rounds sf sensitivity f using single random bit omegasf rounds necessary b introduction 1private simply private protocol computing function f protocol allows possessing individual secret input x compute value fx way single player learns initial inputs players revealed value fx input 1 players assumed honest curious namely follow prescribed protocol could try get additional information considering messages receive execution protocol private computations setting subject considerable amount early version paper appeared advances cryptology proceedings crypto 94 desmedt ed springerverlag lecture notes computer science vol 839 pp 397410 1994 dept computer science technion haifa israel email eyalkcstechnionacil httpwwwcstechnionacileyalk work research supported e j bishop research fund fund promotion research technion part research performed author aiken computation laboratory harvard university supported research contracts onrn0001491j1981 nsfccr9007677 z dept computer science telaviv university telaviv israel email adiromathtauacil 1 literature general definition tprivacy given definition case work eg bgw88 ccd88 bb89 ck89 k89 b89 fy92 ck92 cgk90 cgk92 kmo94 one crucial ingredient private protocols use randomness quantifying amount randomness needed computing functions privately subject present work randomness resource extensively studied last decade methods saving random bits range pseudorandom generators bm84 y82 n90 techniques recycling random bits iz89 cw89 sources weak randomness cg88 vv85 z91 constructions different kinds small probability spaces nn90 aghp90 s92 km93 km94 kk94 sometimes even allow eliminate use randomness different direction research quantitative study role randomness specific contexts eg rs89 kpu88 bgg90 cg90 bgs94 bsv94 work initiate quantitative study randomness private computations mainly concentrate specific task computing xor n input bits however results extend boolean function task computing xor subject previous research due basic linear operation relative simplicity fy92 ck92 known folklore theorem difficult show private computation xor cannot carried deterministically n 3 hand single random bit computation becomes possible first round player p n chooses random bit r sends p 1 bit x n phi r round xors bit x igamma1 message received previous round sends result p finally p n xors message received random bit r correctness privacy protocol easy verify main drawback protocol takes n rounds another protocol task computes xor two rounds requires linear number random bits first round player p chooses random bit r player p sends x phi r p 1 r second round p 2 xors random bits received first round sends result p 1 xors messages received protocol get value function correctness privacy protocol hard verify work prove tradeoff amount randomness number rounds private computations xor example show single random bit thetan rounds necessary sufficient 2 two random bits olog n rounds suffice 3 namely single additional random bit number rounds significantly reduced additional bits give much modest saving precisely prove bits olog n log rounds suffice andomegagammad3 nd rounds required upper bound achieved using new method enables us use linear combinations random bits preserving privacy lower bounds proved using combinatorial arguments strong sense also apply protocols allowed precisely dn2e rounds upper bound achieved slight modification first protocol assume simplicity n even first round player pn sends xn phi r player p 1 time sends r player pngamma1 players continue protocol forwarding messages parallel two messages meet precisely round xors message received input sends player p player p ngammaigamma1 xors message received input sends player pngammai round n player p nreceives two messages compute value function xoring two messages together input 3 logarithms base 2 unless otherwise indicated make errors actually show lower bound expected number rounds also show protocols restricted certain natural types include particular protocol achieves upper bound even improve lower bound show thetalog n log rounds necessary sufficient lower bound techniques apply xor function fact give lower bounds number rounds boolean function terms sensitivity function namely prove 2 random bits omegagammats sfd rounds necessary privately compute boolean function f whose sensitivity sf single random bit rounds necessary question whether private computations general carried constant number rounds previously addressed bb89 bfkr90 light results promising approach investigate question may proving constant number rounds sufficient large number random bits required subsequent work several works done regarding amount randomness privacy particular amount randomness required computing function xor tprivately 2 studied bdpv95 km96 kor96 shown boolean functions computed privately constant number random bits exactly functions linear size boolean circuits rest paper organized follows section 2 give definitions section 3 give upper bound number rounds required privately compute xor section 4 give lower bounds number rounds privately compute boolean function terms sensitivity conclude section 5 lower bounds expected number rounds terms average sensitivity function computed appendix contains improved lower bounds restricted types protocols preliminaries give description protocols consider define privacy property protocols rigorous definitions protocols given section 41 1g boolean function set n players p 1 n possessing single input bit x known collaborate protocol compute value fx protocol operates rounds round player may toss coins sends messages players messages sent private channels intended receiver player listen receives messages sent players addition player certain round chooses output value function assume player knows serial number total number players n may also assume player p provided readonly random tape r reads random bits rather toss coins player p receives execution protocol sequence messages let c random variable communication string seen player p let c particular communication string seen p informally privacy respect player p means player anything particular inputs players c except implied input bit value function computed formally definition 1 privacy protocol computing function f private respect player p two input vectors x sequence messages c random tape r provided p probability random tapes players 3 upper bound section presents protocol allows n players use 2 random bits computing xor privately protocol takes olog n rounds case similar protocol uses dn2e rounds already described introduction arithmetic operations section done modulo 2 consider following protocol call basic protocol first organize n players tree degree root tree 1 degree internal node assume simplicity n forms complete tree computation starts leaves goes towards root sending messages single bit follows leaf player p sends input bit x parent tree internal node receiving messages children sums modulo 2 together input bit x sends result parent finally root player sums receives together input bit result output protocol simple induction shows correctness protocol clearly runs olog n rounds obvious maintain required privacy second idea mask messages sent basic protocol appropriate random bit constructed using random bits available way masks disappear end left unmasked output assign nodes tree vectors gf 2 follows meaning vectors become clear soon assign root vector 0 children root assigned vectors vectors dsize subset linearly independent sum vectors example unit vectors together satisfy requirements finally recursive way given internal node assigned vector v assign children linearly independent vectors whose sum v note particular none vectors 0 vector 4 show use vectors assigned nodes get private protocol assume random bits b chosen external processor 4 example collection vectors constructed follows since v 6 0 exists index v 1 first gamma 1 vectors last vector obviously sum vectors v linearly independent later see assumption eliminated easily let v vector assigned player leaf tree give player single bit r vector consisting random bits product inner product modulo 2 players use basic protocol described modification player leaf also xors message bit r v received players behave exactly claim every player p basic protocol sends message input vector x modified protocol sends message v delta b v vector assigned player proof goes induction trivially true leaf players internal nodes message calculated adding input players sum incoming messages using induction hypothesis sum message received kth child basic protocol v k vector assigned kth child since construction v vector assigned p satisfies v simple algebraic manipulation proves induction step particular since root assigned vector output equals output basic protocol hence correctness follows prove privacy property protocol leaf players receive message hence nothing prove let p j internal node tree denote messages receives claim every vector input vector probability random choice b note protocol players make internal random choices words fix specific input vector x every vector w exists exactly one choice values b messages p j receives protocol executed input x vector w denote vectors corresponding children p j tree let messages send basic protocol given input vector x claimed every message kth child sends modified protocol expressed r notation following linear system satisfied 2 linearly independent system exactly one solution needed root player argument applied fixed dsize subset receives gives us given input vector x dsize messages vectors take two input vectors x x root root correctness protocol given specific dsize messagesvector 1st message x thus privacy property holds respect root finally note assumed random choices made external processor however let one leaf players randomly choose bits b supply leaf players appropriate bit r v leaf players send messages protocol special processor selects random bits gets advantage note player nonhonest easily prevent players computing correct output however cannot get additional information protocol since message player gets sending message value function thus proved following theorem theorem 1 function xor n input bits computed privately using 2 random bits olog n log rounds 4 lower bounds section prove several lower bounds number rounds required privately compute boolean function given total number random bits players toss lower bound given terms sensitivity function section 41 give formal definitions section 42 introduce notion sensitivity present lemma central proofs sensitivity functions proof lower bound appears section 43 41 preliminaries first give formal definition protocols protocol operates rounds round player p based value input bit x values messages received previous rounds values coins tossed previous rounds tosses certain number additional coins sends messages players values messages may depend including coins tossed p player may also choose output value function calculated done player player p receives messages sent players define protocol formally give following definition definition 2 view ffl timet partial view player p consists input bit x messages received first gamma 1 rounds coins tossed first gamma 1 rounds denote ffl timet view player p consists input bit x messages received first rounds coins tossed first rounds denote v iew intuitively partial view player p round determines many coins toss round view includes newly tossed coins determines messages p send round whether value output value f formal definition protocol given definition 3 protocol consists set functions r k determine many coins tossed p round k set functions k finite domain possible message values determine message sent p p j round k quantify amount randomness used protocol give following definition definition 4 drandom protocol protocol input assignment total number coins tossed players execution note definition allows different executions different players toss coins may depend input players previous coin tosses next define correctness protocol usually consider protocols always correct protocols allowed err considered section 51 definition 5 protocol compute function f protocol input vector x every player p always correctly outputs value fx sometime convenient assume player p provided random tape r reads random bits rather assume player tosses random coins number random coins tossed player p thus rightmost position tape reads thus denote r specific random tape provided player p vector random tapes players denote random variable tapes vector tapes note fix r obtain deterministic protocol furthermore v iew function input assignment x random tapes players thus write v iew denote x r round number player p outputs result given input assignment x random tapes players r definition rounds complexity rround protocol compute function f protocol compute f x r x purpose proofs slightly modify view protocol following way fix arbitrary binary encoding messages consider protocol player sends instead single message set boolean messages represent binary encoding message sent original protocol messages sent parallel round henceforth refer messages refer binary messages clearly number rounds remains 42 sensitivity functions section include definitions related functions f finite domain present useful properties related definitions definition 7 sensitivity ffl binary vector denote binary vector obtained flipping ith entry ffl function f sensitive ith variable assignment fy 6 fy set variables function f sensitive assignment ffl sensitivity function f denoted sf sf 4 ffl average sensitivity function f denoted asf average js f j 2f01g n js f j ffl set variables f depends denoted df df 4 g say f depends ith variable following claim gives lower bound degree error evaluate function f means another function g terms average sensitivities use property proofs 1 consider two functions f proof consider ndimensional hypercube f good edge edge fy definitions number fgood edges exactly 2 n asf therefore least 2 n asfgammaasgedges fgood ggood edge either fx 6 gx fy 6 gy since degree vertex hypercube n must least 2 n delta asfgammaasg inputs f g agree next prove lemma bounds growth sensitivity combination func tions lemma plays central role proofs lower bounds improvement immediately improve lower bounds lemma 2 let set functions assume j define function f 4 f assumes 2 different values different vectors sensitivity f c delta 5 obvious bound sf however reasons become clear soon interested bounds independent proof let assignment f largest sensitivity ie js f j js f 0 j assignment 0 without loss generality assume f consider set neighbors f value different cardinality set sensitivity f 2 gamma 1 values f attained assignments set consider one value q 2 f0 1g least one index j q since sensitivity f j c c assignments value q get total number assignments f value c delta 43 lower bound number rounds subsection prove following theorem theorem 3 let rround drandom 2 private protocol compute boolean function f r first step proof uses drandomness property protocol show number views player see fixed input x 2 different random tapes players note obvious although coins tossed every execution identity players toss coins may depend outcome previous coin tosses lemma 4 consider private drandom protocol compute boolean function f fix input x let c k communication string seen player p round k input x vector random tapes r every player p c k assume 2 different values different vectors random tapes r proof execution order coin tosses ie readings local random tapes according rounds protocol within round according index players toss identity player toss first coin fixed x identity player toss next coin determined x outcome previous coins therefore different executions input x described using following binary tree node tree name player p j tosses coin two outgoing edges node labeled 0 1 according outcome coin lead two nodes labeled p k p respectively k j need distinct identity player toss next coin additional coin toss occurs node labeled nil outgoing edges nil node drandomness property protocol depth tree hence 2 roottoleaf paths every possible run protocol described one roottoleaf path path determines messages sent protocol player tosses coins outcome coins particular path determines p value c k k hence c k 2 different values following proof restrict attention specific deterministic protocols derived original protocol fixing specific vector random tapes players deterministic protocol views players functions input assignment x lemma 5 consider private drandom protocol compute boolean function f fix random tapes view player p round k input x vector random tapes r p v iew k r assume 2 d2 different values values proof partition input assignments x 4 groups according value x 0 1 value fx 0 1 argue number different values view assume within group 2 fix input x one 4 groups consider input pertaining group recall c k r communication string seen player p round k input random tapes players r value c k r communication string c privacy requirement 6 communication c must also occur round k input x vector random tapes r thus value c k r must also appear vector random tapes however lemma 4 c k assume values values r thus c k r assume 2 values possible input assignments pertain group observe v iew k determined input bit communication string random tape r therefore r two input assignments 0 group particular r c k r thus v iew k r assume 2 different values input assignments pertain group following lemma gives upper bound sensitivity view player given round terms number random bits round number enable us give lower bound number necessary rounds lemma consider private drandom protocol compute boolean function f consider specific vector random tapes r deterministic protocol derived every player r function x sensitivity qk 4 proof first note since fix random tapes views players functions input assignment x prove lemma induction view player depends single input bit thus claim obvious k 1 assume claim holds k implies particular messages received player p included view consideration sensitivity qk gamma 1 clearly 6 privacy requirement defined final communication string clearly implies requirement prefix input bit sensitivity 1 qk gamma 1 thus view consideration composed bits sensitivity qk gamma 1 moreover lemma 5 view assume 2 d2 values follows lemma 2 sensitivity view consideration qk qk note lemma 2 allows us give bound depend number messages received p give lower bound number rounds terms sensitivity function number random bits theorem 7 given private drandom protocol 2 compute boolean function f consider deterministic protocol derived given random tapes r player least one input assignment x x proof consider fixed arbitrary player p denote largest round number outputs value ie rg claim long sensitivity view p reach sf least one input assignment p cannot output correct value f let input assignment sensitivity sf obtained value f different value f sf neighbors hence sensitivity view p less sf output p must wrong either least one neighbors sensitivity view upper bound sensitivity output thus sv iew 6 get 2 d2tgamma1 sf ie log sf 1 proves theorem 3 moreover shows input assignment x random tapes r protocol runs long time also vector random tapes r input assignment following corollary follows function xor using fact corollary 8 let rround drandom private protocol 2 compute xor n bits 431 lower bound single random bit case single random bit 1 following lower bound theorem 9 let rround 1random private protocol compute boolean function f prove theorem restrict attention one two deterministic protocols derived original protocol fixing value random bit 7 messages views protocol functions input vector x let assignment sf sensitivity f obtained given function variables x j called good f sensitive x j denote gm set good variables ie gm 4 first prove following two lemmas 7 let identity player tosses coin possibly depend input x however note want privacy 1randomness properties hold cannot case lemma 10 consider player p denote 1 message p receives 1 message 2 received p jg 2 either gm 1 b jg 1 proof assume towards contradiction b hold first since two variables x k 2 gm 1 k 6 6 moreover assumption hold assume without loss generality names 1 assumption b hold variable x j j 6 f sensitive x j 1 2 sensitive x j consider following three input assignments consider v iew 3 inputs assume without loss generality 1 sensitive x j 1 j sensitive x k 1 sensitive x 1 1 different values 0 1 2 function f sensitive j k therefore equal three assignments however proof lemma 5 shown number values v iew corresponding inputs value f value x 2 following lemma gives upper bound sensitivity view player terms round number use lemma give lower bound number necessary rounds lemma 11 let sfgamma12 round number p player jg v iew proof prove claim induction getting messages view depends x assume claim holds k denote set messages received p included view consideration clearly g v iew could one three cases 1 message case claim clearly holds 2 two messages jg 1 g follows jg v iew induction hypothesis jg jg v iew 3 two messages jg 1 gm 1 g lemma 10 jg 1 without loss contradicts induction hypothesis received round k sf gamma 12 therefore generated view round k induction hypothesis jg give proof theorem 9 proof theorem 9 consider player p denote largest round number outputs value ie 0g proof theorem 7 must function xor following corollary corollary 12 let rround 1random private protocol compute xor n bits 5 lower bounds expected number rounds protocols consider randomized possible input x different random tapes players result executions run different number rounds hence natural consider worst case running time also expected running time usually saying protocol expected running time r means every input x expected time players finish execution bounded r expectation choices random tapes players consider weaker definition requires existence player whose expected running time bounded r proving lower bound makes result stronger would mean every player input assignment expected running time high note necessarily case first player computes value function announce value thus players compute value within one round reason fact certain player computes function certain round may reveal information inputs hence announcing may violate privacy requirement see cgk90 first define expected rounds complexity protocol definition 8 expected rounds complexity expected rround protocol compute function f protocol compute f exists player p x lower bound prove section terms average sensitivity computed function particular prove anomegagamma28 nd lower bound expected number rounds required protocols privately compute xor n bits prove following theorem theorem 13 let f boolean function let expected rround drandom private protocol 2 compute function f prove theorem consider protocol fix player p say protocol late input x vector random tapes 1 define 1 protocol late x r purpose proofs section define uniform distribution 2 n input assignments say input actually drawn distribution moreover note domain vectors random tapes enumerable first show deterministic protocol derived private protocol compute f least one input protocol late happens large fraction inputs lemma 14 consider player p fixed vector random tapes asf proof consider views p given vector random tapes r round log asf function g computed view sensitivity thus clearly average sensitivity asf claim 1 function g correct value function f 2 n asf assignments since assume correct input assignments follows least 2 n asfgamma asf input assignments late give lower bound expected number rounds lemma 15 consider player p least one input assignment x asf log asf proof lemma 14 e rx lx r asfgamma asf hence least one input assignment x e r lx r asfgamma asf x get asf log asf needed theorem 13 follows lemma following corollary applies function xor corollary 16 let expected rround drandom private protocol 2 compute xor n bits r proof follows theorem 13 fact 51 weakly correct protocols section consider protocols allowed make certain amount errors given protocol denote x r output protocol player p given input assignment x vector random tape definition 9 fficorrect protocol compute function f protocol every player p every input vector x satisfies p r r x note designing protocol one usually wants stronger requirement high probability players compute correct value definition possible every execution protocol least one players wrong however aim prove lower bound weak definition makes result stronger following theorem give lower bounds number rounds expected number rounds weakly correct protocols theorem 17 let f boolean function ffl let 1 gamma fficorrect rround drandom private protocol 2 compute f asf r asfd ffl let expected rround drandom private protocol 2 compute f asf proof first prove lower bound number rounds turn attention expected number rounds correctness requirement implies player p implies exists vector random tapes r least 2 n 1 gamma ffi input assignments x x proof lemma 14 using claim 1 follows round number log asf 1 protocol correct 2 n asf inputs random tapes r since require least correct least asf asf inputs late get lower bound r rround protocol sufficient single input vector x execution x r long note asf random tapes r number late inputs greater 0 gives us lower bound r omegagamma112 asfd 1 gamma fficorrect rround drandom protocol ffi turn lower bound expected number rounds 1 gamma fficorrect protocols consider player p define 1 x correctness requirement implies e r gx r x follows r probability ffiis least 1 gamma 2ffi 8 vector random tapes r consider deterministic protocol derived protocol least asf asf late input assignments e x lx asf ffi thus asf follows least one input assignment x asf implies asf delta log asf claimed following gives lower bounds function xor corollary 18 fixed 1 gamma fficorrect drandom expected rround private protocol compute xor n bits r nd obviously lower bound holds rround protocols proof follows theorem 17 fact n note expression greater 0 ffi 12 sufficiently large n thus least one input assignment x e r gx contradiction protocol correct 6 conclusion paper initiate quantitative study randomness private computations mentioned introduction work already followed additional work topic bdpv95 km96 kor96 give upper bounds lower bounds number rounds required computing xor privately given number random bits alternatively give bounds number random bits required computing xor privately within given number rounds lower bounds extend functions terms sensitivity average sensitivity obvious open problem close gap upper bound lower bound computing xor using random bits one possible way improve bound given lemma 2 acknowledgments thank gabor tardos improving constant simplifying proof lemma 2 demetrios achlioptas help simplifying proof lemma 19 also thank benny chor useful comments r simple constructions almost kwise independent random variables noncryptographic faulttolerant computing constant number rounds perfect privacy twoparty protocols security low communication overhead randomness interactive proofs completeness theorems noncryptographic faulttolerant distributed computation generate cryptographically strong sequences pseudorandom bits dealers randomness required secret sharing schemes randomness distribution protocols number random bits totally private computations bounds tradeoffs randomness communication complexity multiparty unconditionally secure protocols zeroone law boolean privacy communicationprivacy tradeoff modular addition unbiased bits sources weak randomness probabilistic communication complexity dispersers deterministic amplification weak random sources communication complexity secure computation recycle random bits derandomized construction small sample spaces nc constructing small sample spaces satisfying given con straints construction kwise independent random variables timerandomness tradeoff oblivious routing privacy communication complexity randomness private computations reducibility completeness multiparty private computations characterizing linear size circuits terms privacy smallbias probability spaces efficient constructions appli cations pseudorandom generator space bounded computation memory vs randomization online algorithms sample spaces uniform neighborhoods random polynomial time equal slightlyrandom polynomial time theory applications trapdoor functions simulating bpp using general weak random source tr ctr balogh jnos csirik yuval ishai eyal kushilevitz private computation using pez dispenser theoretical computer science v306 n13 p6984 5 september anna gal adi rosen lower bounds amount randomness private computation proceedings thirtyfifth annual acm symposium theory computing june 0911 2003 san diego ca usa anna gl adi rosn theorem sensitivity applications private computation proceedings thirtyfirst annual acm symposium theory computing p348357 may 0104 1999 atlanta georgia united states eyal kushilevitz rafail ostrovsky adi rosn amortizing randomness private multiparty computations proceedings seventeenth annual acm symposium principles distributed computing p8190 june 28july 02 1998 puerto vallarta mexico
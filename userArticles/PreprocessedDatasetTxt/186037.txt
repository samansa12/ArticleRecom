fixpoint computation polyvariant static analyses higherorder applicative programs paper presents optimized generalpurpose algorithm polyvariant static analyses higherorder applicative programs polyvariant analysis accurate form analysis produces many abstract descriptions program conventional analysis may also compute intermediate abstract descriptions irrelevant final result analysis optimized algorithm addresses overhead preserving accuracy analysis algorithm also parameterized abstract domain degree polyvariance implemented instance algorithm evaluated performance compared unoptimized algorithm implementation runs significantly faster average algorithm benchmarks reported b introduction abstract interpretation abramsky hankin 1987 cousot 1981 jones nielson 1990 used formulate wide variety static analyses aimed optimizing programs practical programming languages research area focusing conceptual formal aspects topic special emphasis put issues accuracy termination relating nonstandard standard semantic definitions however practical aspects involved implementing abstract interpreter received much attention situation even pronounced analyses languages higherorder functions static analysis includes critical phase consists finding fixpoint set possibly recursive abstract functions derived analyzed program practical use analysis include efficient accurate fixpoint algorithm efficiency depends mostly accuracy exam ple analyses determine one abstract description object eg functions data structures program analogy partial evaluation consel danvy 1993 said monovariant analyses accurate determine multiple abstract descriptions object research partially supported nsf grant ccr9224375 authors addresses j michael ashley computer science department lindley hall 215 bloom ington indiana 47405 email jashleycsindianaedu charles consel oregon graduate insti tute department computer science po box 91000 portland oregon 97291 email con selcseogiedu ashley c consel program depending context objects used analogy partial evaluation analyses said polyvariant make fixpoint computation expensive yield abstract descriptions unlike firstorder programs higherorder programs static control flow graph since higherorder languages treat procedures values consequence controlflow dataflow aspects higherorder programs intertwined fact controlflow analysis higherorder programs also called closure analysis sestoft 1989 includes dataflow aspects polyvariant analysis separating controlflow dataflow analyses desirable since firstorder higherorder values used differentiate contexts object used consel 1993a indeed accuracy scheme obtained cost iterating controlflow dataflow analyses rytz gengler 1992 alternatively controlflow dataflow analyses combined polyvariant analysis approach yields accurate information consel 1993a presented young 1989 analyzing set mutually recursive functions consists processing function fixpoint iteration changes occur precisely iteration process complete abstract values propagated every control flow path abstract descriptions functions stabilized okeefe okeefe 1987 hall kennedy hall kennedy 1992 others noticed strategy causes needless recomputations performed indeed given abstract function reanalyzed even though changes triggered new iteration affect one solution remedy situation consists maintaining dependencies change occurs abstract functions affected change reanalyzed another problem discussed literature eg charlier musumbu hentenryck 1991 way control flow analyzed program traversed analysis traversal strategies cause abstract functions analyzed times necessary example traversing controlflow graph depthfirst opposed breadthfirst affect rate analysis reaches fixpoint analyzed program first order call graph determined statically one pass analysis use information accelerate convergence fixpoint process example subsets abstract functions derived stronglyconnected components controlflow graph solved individually strategies firstorder programs presented literature eg charlier musumbu hentenryck 1991 however analyzed program higher order approximation call graph computed importantly callgraph analysis requires fixpoint process consequently exploiting callgraph information accelerate fixpoint process requires analysis higherorder programs construct callgraph information incrementally paper presents new algorithm implementing accurate fixpoint analyses algorithm applies callbyvalue programs higherorder procedures data structures introduce optimization technique designed deal overhead polyvariance preserving accuracy implemented algorithm polyvariant bindingtime analysis bindingtime analysis part preprocessing phase offline partial evaluator jones sestoft sndergaard 1989 nielson nielson 1992 aims determining invariants partialevaluation process fixpoint computation polyvariant static analyses delta 3 test else fig 1 simple higherorder language experimentally evaluated new algorithm compared performance unoptimized version algorithm give precise bounds running time algorithm implementation run significantly faster implementation algorithm estimation based series benchmarks given paper overview next section present version algorithm may used monovariant polyvariant analyses illustrate example accuracy performance may hampered presence polyvariance section 3 revise algorithm improve performance accuracy preliminary performance results given section 4 approach put perspective related work section 5 close section 6 conclusions 2 generic analysis present generic static analysis simple higherorder programming language analysis presented scheme clinger j rees eds 1991 dybvig 1987 extended simple record facility facility allows new record type name fields x xn defined expression definerecord name fields record accessed updated procedures namex setnamex respectively convenience construct variantcase allows one dispatch type record extract value records fields name see figure 2 example evaluates unspecified value record match case language treated analysis given lefthand part figure 1 righthand part figure lists record declarations associated syntactic rule program sequence mutually recursive definitions followed initial expression corresponds record program containing two fields defs definitions exp initial expression simplify presentation procedures may take one argument also data structures sideeffects discuss returning data structures language concluding remarks address issue sideeffects value program value expression evaluated environment established definitions program generic analysis abstracted abstract domain polyvariant func tion instantiation analysis must meet following requirements ashley c consel 1 abstract domain must form complete lattice finite height abstract closures abstract descriptions runtime closures explicitly represented domain function ff abstraction function mapping constants elements 2 polyvariant function maps context analysis element finite index set consel 1993a different descriptions object grouped ie folded together respect index finite height abstract domain ensures fixpoint computation terminates furthermore explicitly representing abstract closures allows analysis manipulate components eg environment text let us give example abstract domain polyvariant function could used instantiate generic analysis suppose interested developing form closure analysis analysis could collect set possible closures could occur call site program use following domain sets jng labels lambda abstractions environments abstract values defined domain abstract values infinite height contradicts first requirement listed domain used polyvariant analysis may create infinite number descriptions lambda expressions obtain finite domain control polyvariance analysis introduce polyvariant function used create two different kinds abstract descriptions abstract closures abstract applications fact family functions since applied elements different domains shown first used partition set abstract closures created lambda expression partition represented closure variant abstract closure representing abstract closures partition lambda expression analyzed abstract closure formed text lambda expression current lexical environment result analysis however closure variant identifying partition abstract closure lies let us give example polyvariant function domain although domain 0 infinite codomain finite since maps closures labels equipped define polyvariant function closure ae xn xn g fixpoint computation polyvariant static analyses delta 5 domain closure variants finite version domain noted defined follows noticed domain closure variants finite thus descriptions abstract closures finite well function domain defined used second time partition set values closure variant applied determines partition application partitions represented application variant application variant represents application closure variant abstract values partition records result application well application variant element domain considering purpose analysis function ff would map firstorder value higherorder value singleton set consisting corresponding label example shows infinite domains finitely partitioned make abstract descriptions objects finite achieved introducing functions components infinite domain wide spectrum functions defined detailed description approach found consel 1993a examples polyvariant functions generally contexts analysis include current call chain lexical context abstract values arguments procedure calls eg see consel 1993a harrison iii 1989 shivers 1991 notice monovariant analysis obtained defining constant function mapping unique partition turn describing concrete algorithm implements generic analysis essence algorithm driven need analyze application variants besides computing controlflow dataflow program algorithm must construct maintain dependency graph graph used initiate computations application variants updated note convenience use ff mathematical formulas programs 21 analyzing expressions application variant represents application closure variant abstract value algorithm compute result application given figure 2 procedure analyzeexp receives arguments expression lexical environment mapping identifiers abstract values application variant analyzed returns abstract value analyzeexp dispatches syntactic category expression literal mapped abstract value domain variable looked current 6 delta j ashley c consel definerecord cv exp env creators avs closure variant definerecord av cv callers arg return application variant definerecord callsite av exp arg define analyzeexp exp env self variantcase exp lit value ff value cond test else abstractcond analyzeexp test env self analyzeexp env self analyzeexp else env self proc formal body let cv lookupclosvariant exp env cvcreators cv self env buildabsval cv app rator rand let arg analyzeexp rand env self cvs cvsofabsval analyzeexp rator env self let callsite makecallsite self exp arg fold lambda cv acc let av lookupappvariant cv arg avcallers av callsite setcvavs cv union cvavs cv makeset av lub avarg av acc cvs define updateenvironment cv variantcase cv cv env creators avs let newenv creatorsenv creators unless env env newenv setcvenv cv newenv pushmany workstack avs define updateargument av variantcase av av arg callers let newarg callersarg callers unless arg arg newarg setavarg av newarg push workstack av fig 2 algorithm analyze expressions fixpoint computation polyvariant static analyses delta 7 lexical environment abstract value conditional determined abstract values subexpressions analysis lambda expressions applications causes dependency information recorded two abstract data types creators callers used help maintain information creators abstract data type adt notes context closure variant enter data flow program callers adt notes closure variant may applied operations datatypes introduced needed note adts simply abstract bookkeeping details straightforward implement analysis lambda expression yields closure variant creators closure variant updated include application variant analyzed environment analysis occurs done updatecreators operation creators adt procedure updateenvironment called update environment closure variant another operation lubcreatorsenv used obtain least upper bound environments creators recording environment creator effectively recording environment abstract closure partition named closure variant update ensures closure variant accurately reflects abstract closures partition environment closure variant may change adding new application variant set creators environment creator changed applications closure variant must reanalyzed avs field cv record notes dependencies pushmany operation updateenvironment initiates reanalyses pushing application variants onto workstack compute abstract value application closure variants collected application site applied abstract value argument one time application yields abstract value representing result application least upper bound resulting set abstract values result application closure variant applied abstract value first finding application variant represent application similar updatecreators callers adt operation updatecallers records closure variant applied context represented application variant procedure updateargument called update argument application variant operation lubcallersarg analogous lubcreatorsenv used obtain least upper bound arguments callers recording argument caller effectively recording abstract values partition named application variant update ensures application variant accurately reflects values partition argument application variant may change reasons similar environment closure variant changing changes application variant must reanalyzed finally application variant representing application context added avs field closure variant applied updates dependency application variant closure variants environment continue algorithm analyzing complete programs ashley c consel define workstack makestack define analyzeprog prog variantcase prog prog defs exp push workstack buildrootvariant exp buildinitialenv defs letrec loop lambda unless emptystack workstack let av top workstack analyzevariant av define analyzevariant av variantcase av av cv arg variantcase cv cv exp env variantcase exp proc formal body let env extendenv env formal arg updatereturnvalue av analyzeexp body env av define updatereturnvalue av newreturn variantcase av av callers return unless absval return newreturn setavreturn signature newreturn pushmany workstack callersavs callers fig 3 algorithm analyzing programs 22 analyzing programs algorithm compute abstract value entire program given figure 3 procedure analyzeprog takes program computes abstract value upon termination argument result application variant program computed analyzeprog first creates initial environment definitions program buildinitialenv root application variant buildrootvariant variant describes programs expression workstack represented stack initialized variant procedure iterates stack empty since changes monotonic lattice abstract values finite height iteration terminates finite number steps procedure analyzevariant analyzes application variant updates variants return value extends lexical environment closure variant applied binding argument calls analyzeexp value returned used update variant fixpoint computation polyvariant static analyses delta 9 define f lambda x k h g x define g lambda x x define h lambda x jlambda x define k lambda f f 1 f fig 4 example program step application variants fig 5 fixpoint computation example program figure 4 variants return value changes application variants call modified variant must reanalyzed variants depend results obtained callersavs third operation callers abstract data type 23 evaluation algorithm given perform well instantiated monovariant analysis ie constant function unfortunately may lose accuracy suffer performance penalties presence polyvariance identify problem turn solving consider program given figure 4 trace analysis figure 5 example program labeled anonymous lambda expression convenience carry example assume abstract domain function beginning section trace shows application variants created changed step analysis recall step constitutes analysis one application variant steps omitted change variant step following notation used table hf va denotes closure variant obtained label procedure f environment mapped abstract value v application variant denoted c v 0 c closure variant whose application represented application argument application v 2 result ashley c consel let us follow trace step 1 show root variant initially created result applying procedure f next step application variant f analyzed resulting creation three new application variants g h k since argument application evaluated first application variant k pushed onto workstack last analyzed step 3 change since closure variant applied application variant h analyzed next yielding closure variant j since result variant changed application variant f analyzed causes creation new application variant k since analysis new variant k causes application variant hj x created put onto workstack however analysis causes change application variants finally application variant g analyzed result propagated yielding new application variant h since 6 analysis new variant also yields new closure variant passed k step 9 crucial longer called hf since accurate information argument hh obtained also implies hk longer applied hj x step 11 see least upper bound new variant passed hk old argument taken obtain new argument hk lost precision controldata flow since two closure variants part argument really one practice application variants may analyzed repeatedly become useless dependency information record appropriately updated controlflow dataflow information changes due polyvari ance example illustrates application variant may created intermediate point fixpoint computation longer used fixpoint reached also shows data flow program may become less precise values returned intermediate variants part final set variants intermediate variants necessary fixpoint reached fixpoint computations fixpoint computation accelerated made accurate detecting variants become useless eliminating computation next section presents revision algorithm intended achieve improvement 3 improving analysis changes algorithm illustrated figures 6 7 aim maintaining accurate dependency information presence polyvariance detecting eliminating useless variants changes bookkeeping purposes extra field added application variants note whether variant useful also extend record type call sites include set closure variants applied call site finally lookup operation call sites introduced lookup operation creates new record instance matching instance exist otherwise returns preexisting instance hence application variantexpression pair exist exactly one callsite record represent fixpoint computation polyvariant static analyses delta 11 definerecord av cv signature callers useful definerecord callsite self exp cvs arg define analyzevariant av variantcase av av cv signature useful let env extendenv env formal arg cond setavuseful av updatereturnvalue av analyzeexp body env av setavuseful av f sweepexp body env av define analyzeexp exp env self variantcase exp app rator rand let arg analyzeexp rand env self cvs cvsofabsval analyzeexp rator env self callsite lookupcallsite self exp updatecallsite callsite cvs arg define updatecallsite callsite newcvs newarg variantcase callsite callsite cvs arg let droppedcvs pi arg newarg setdifference cvs newcvs cleanup droppedcvs callsite setcallsitearg callsite newarg setcallsitecvs callsite newcvs fig 6 revised algorithm analyzing expressions ashley c consel define sweepexp exp env self variantcase exp test pred else sweepexp pred env self sweepexp env self sweepexp else env self proc let cv lookupclosvariant exp env app rator rand let callsite lookupcallsite self exp cleanup cvs callsite setcallsitecvs callsite sweepexp rator env self sweepexp rand env self define cleanup cvs callsite let piarg callsitearg callsite foreach lambda cv let av lookupappvariant cv piarg define stilluseful av letrec loop lambda avs seen cond null avs f memq car avs seen loop cdr avs seen rootvariant car avs highest car avs else loop append callersavs avcallers car avs avs cons car avs seen loop list av define highest av variantcase av av cv arg andmap lambda av absval lub avarg av arg arg cvavs cv fig 7 auxiliaries revised algorithm fixpoint computation polyvariant static analyses delta 13 call sites updated updatecallsite operation addition simply updating record fields determines closure variants either longer applied call site else applied different context analysis procedure cleanup called update affected variants cleanup considers closure variant determines application variant representing application call site question removes call site callers application variant using new adt operation removecallers calls updateargument record changes application variant effect remove callers dataflow contribution called variant changes analysis already cause accurate controlflow dataflow information gathered since calls one variant another erased dataflow information becomes precise turn removing useless variants analysis revised procedure analyzevariantchecks see variant useful analyzing stilluseful variant useful reachable either root application variant rootvariant highest application variant highest derived closure variant indeed useful analysis proceeds useful variant must swept remove contributions data controlflow analysis marked longer live considering variant useful reachable highest application variant closure variant ensures monotonicity fixpoint finding process without algorithm may terminate argument result values closure variant oscillate points abstract domain procedure sweepexp traverses abstract syntax tree application variant self find lambda expressions applications lambda ex pression closure variant created self point determined self removed creators closure variant using new operation removecreators updateenv called update environment closure variant application cleanup called update application variants longer called call site call site also reset indicate closure variants called site implementation issues efficient version algorithm easily implemented example procedure stilluseful quadratic number application variants controlflow graph linear version implemented extra bookkeeping also discovered empirically analysis reaches fixpoint much quickly variants analyzed somewhat greedily instead putting variant onto workstack analysis reanalyzed immediately unless analysis variant already pending also limit number pending analyses applied improvements implementation used report results next section 14 delta j ashley c consel ds cps prolog mp match db proof 1 proof 2 size 437 483 1183 2197 454 701 1083 3151 functions 7 7 43 68 15 27 62 171 initial variants 36 153 962 136 time 36 299 1965 162 27 41 1162 2906 revised variants 20 103 568 133 time 13 165 1118 171 27 25 84 974 ratio 28 18 18 9 1 16 138 3 reused fig 8 benchmarks 4 results revised algorithm implemented bindingtime analysis partial evaluator schism consel 1993a consel 1993b generalpurpose algorithm compare also implemented schisms bta figure 8 tabulates results analyzing eight programs using new analyzer four eight programs interpreters first program ds interpreter extension callbyvalue lambda calculus second cps continuationpassing style version interpreter third prolog interpreter prolog consel khoo 1991 fourth interpreter subset algol mp consel danvy 1991b remaining four programs pattern matcher patterns expressed using regular expression language match consel danvy 1991a implementation simple database system db daniels vance 1993 two encodings theorems proof 2 program report size measured number words program number toplevel definitions lambda expressions reported number variants number application variants reachable analysis terminated times reported seconds ratio shown indicates speedup initial algorithm number variants reused number variants became unreachable point analysis called later point analysis revised algorithm shows strategy eliminating useless variants generally performs well result analyzing program proof 1 shows drastically reduce number variants created time spent analyzing result analyzing program mp particularly interesting illustrates price detecting discarding useless variants three variants found useless took time perform analysis finding handling useless variants expensive implementation principal overhead comes determining whether variant reachable eliminating useless variants also costly many variants subsequently reused since time invested detecting eliminating wasted observed variants usually reused cases number significant initial benchmarks indicate possible execute accurate polyvariant analyses keeping overhead polyvariance manageable degree fixpoint computation polyvariant static analyses delta 15 5 related work martin hankin martin hankin 1987 discuss practical methods performing strictness analysis higherorder language optimize abstract interpretation attempting reduce number functionargument pairs analyzed techniques however dedicated twopoint abstract domains henglein developed efficient constraintbased bindingtime analysis henglein 1991 higherorder programs bondorf jrgensen bondorf jrgensen 1993 implemented approach partial evaluator similix bondorf 1991 analysis monovariant however unclear time whether analysis made polyvariant preserving efficiency okeefe okeefe 1987 gave efficient fixpoint algorithm similar hengleins terms rewritten intermediate form better suited analysis algorithm able find solutions sets equations arbitrary lattices finite height algorithm parameterized respect degree polyvariance however address specific issues arise analysis higherorder programs using pending list eagerly traversing controlflow graph technique applied elsewhere eg charlier musumbu hentenryck 1991 however used context firstorder programs also appears computation minimal function graphs jones mycroft 1986 intended use firstorder programs well hall kennedy hall kennedy 1992 describe efficient callgraph analysis fortran procedures reanalyzed use context changes le charlier et al describe algorithm analyzing prolog programs charlier musumbu hentenryck 1991 strategies reanalyze equations need several static analyzers higherorder languages appear literature eg harrison iii 1989 shivers 1991 young 1989 none works address parameterized polyvariance make attempt optimize analysis process eg reanalyzing equations byneed 6 conclusions presented generalpurpose algorithm computing fixpoints polyvariant static analysis higherorder applicative programs algorithms presented previously compute polyvariant analyses date none attempted optimize efficency analysis language considered analysis cannot express data structures fact data structures added language without significantly complicating analysis treated exactly like closures perspective implementing algorithm consel 1990 consel 1993a data variants associated partitions abstract data structures construction abstract data structure corresponds creation abstract closure access data structure corresponds application abstract closure also analogous closure variants data variants must removed dataflow program longer referenced future work includes formalizing algorithm proving correctness crucial component proof showing arguments return values application variants stabilize despite removing closure variants also plan undertake complexity analysis assess cost polyvariance ashley c consel hope extend approach sideeffects one direction follow shiv erss strategy shivers 1991 strategy involve major modifications analysis studying strategies could cast framework well acknowledgments thank olivier danvy karoline malmkjaer careful reading drafts paper r abstract interpretation declarative languages automatic autoprojection higherorder recursive equations efficient analyses realistic offline partial evaluation journal functional programming generic abstract interpretation algorithm complexity analysis revised 4 report algorithmic language scheme binding time analysis higher order untyped functional languages polyvariant bindingtime analysis higherorder acm symposium partial evaluation semanticsbased program manipulation tour schism partial evaluation system higherorder applicative languages better support static data flow static dynamic semantics processing tutorial notes partial evaluation semantic foundations program analysis theory applications muchnick n partial evaluation simple database system scheme programming language efficient call graph analysis interprocedural analysis automatic parallelization scheme programs efficient type inference higherorder bindingtime analysis abstract interpretation semanticsbased tool program analysis mix selfapplicable partial evaluator experiments compiler generation proofs structural induction using partial evaluation finding fixed points finite lattices finite fixedpoint problems polyvariant binding time analysis replacing function parameters global variables theory practice semantic program analysis higherorder programming languages tr finding fixed points finite lattices abstract interpretation declarative languages scheme programming language binding time analysis high order untyped functional languages replacing function parameters global variables static dynamic semantics processing controlflow analysis higherorder languages taming lambda efficient type inference higherorder bindingtime analysis better support static data flow twolevel functional languages automatic autoprojection higher order recursive equations efficient call graph analysis polyvariant bindingtime analysis applicative languages tour schism proofs structural induction using partial evaluation tutorial notes partial evaluation revised report algorithmic language scheme data flow analysis applicative programs using minimal function graphs theory practice semantic program analysis higherorder functional programming languages ctr olivier danvy karoline malmkjr jens palsberg etaexpansion trick acm transactions programming languages systems toplas v18 n6 p730751 nov 1996 tim sheard nathan linger searchbased binding time analysis using typedirected pruning proceedings asian symposium partial evaluation semanticsbased program manipulation p2031 september 1214 2002 aizu japan annefranoise le meur julia l lawall charles consel specialization scenarios pragmatic approach declaring program specialization higherorder symbolic computation v17 n12 p4792 marchjune 2004 j michael ashley r kent dybvig practical flexible flow analysis higherorder languages acm transactions programming languages systems toplas v20 n4 p845868 july 1998 j michael ashley effectiveness flow analysis inlining acm sigplan notices v32 n8 p99111 aug 1997 annefranoise le meur julia l lawall charles consel towards bridging gap programming languages partial evaluation acm sigplan notices v37 n3 p918 march 2002 kenichi asai bindingtime analysis static dynamic expressions new generation computing v20 n1 p2751 january 2002 niels h christensen robert glck offline partial evaluation accurate online partial evaluation acm transactions programming languages systems toplas v26 n1 p191220 january 2004
theorem proving guided development formal assertions resourceconstrained scheduler highlevel synthesis paper presents formal specification proof correctness widelyused forcedirected list scheduling fdls algorithm resourceconstrained scheduling data flow graphs highlevel synthesis systems proof effort conducted using higherorder logic theorem prover proof effort many interesting properties fdls algorithm discovered properties formally stated proved higherorder logic theorem proving environment properties constitute detailed set formal assertions invariants hold various steps fdls algorithm inserted programming assertions implementation fdls algorithm productionstrength highlevel synthesis system turned programming assertions 1 certify whether specific run fdls algorithm produced correct schedules 2 event failure help discover isolate programming errors fdls implementationwe present detailed example several experiments demonstrate effectiveness assertions discovering isolating errors based experience discuss role formal theorem proving exercise developing useful set assertions embedding scheduler code argue absence formal proof checking effort discovering useful set assertions would arduous impossible task b often expensive ramifications since could lead synthesis finally fabrication incorrect designs therefore reliability correctness tools become important issues need addressed simulation traditionally used check correct operations digital systems however increase system functionality complexity proving inadequate due computational demands task involved formal verification correctness determined independent input values design thus exhaustive validation implicit formal verification approaches like theorem proving model checking techniques powerful techniques employed formally verify rtl designs support use formal specification languages rigorous semantics formal proof methods support mechanization rtl design synthesized realworld specification often comprises large state space makes formal verification rtl design postdesign activity rather tedious often resulting tremendous strain verification tool verification engineer model checking environment increase rtl design size results combinatorial explosion number global states theorem proving limited design size tends extremely tedious requiring lot time user interaction moreover synthesis rtl design highlevel synthesis information specification refined implementation longer available end synthesis compounds problems faced formal verification techniques several researchers proposed alternatives postsynthesis verification effort idea formal hardware synthesis originally proposed johnson 19 presented technique 19 deriving synchronoussystem descriptions recursive function definitions using correctness preserving functional algebraic transformations since several techniques proposed attempt guarantee correct construction synthesized designs eliminating need separate verification stage 4 7 11 20 techniques employ formal logic require user closely interact synthesis tool specification refined implementation eisenbiegler et al 1 introduced general scheme formally embedding high level synthesis algorithms hol 6 high level synthesis performed sequence logical transformations input specification data flow graph fed synthesis system theorem prover stage synthesis control information passed hol environment corresponding transformation executed within logic control information generated external system faulty corresponding transformation cannot performed within logic exception raised approach probably reported attempt formalizing conventional synthesis process however methodology requires tight integration synthesis system formal verification environment formal verification rtl designs generated conventional highlevel synthesis environment long challenge hls 3 8 14 behavioral specification goes series transformations leading finally design meets set performance goals hls synthesis flow usually comprised following four main stages ffl scheduling stage stage specifies partial order operations input specification data control operation bound time step operations may also mapped functional units component library stage ffl register allocation stage carriers specification additionally identified scheduling phase mapped physical registers ffl binding stage interconnection among different components design established ffl control generation stage controller generated sequence operations rtl design propose formal assertions approach building formal highlevel synthesis system approach works premise stage synthesis system like scheduling register optimization interconnect optimization etc verified perform correct transformations input compositionality assert resulting rtl design equivalent input specification divide conquer approach verification powerful technique well researched area transformationbased synthesis systems algorithmic complexities involved conventional hls renders verification process formal proof system rather complex approach attempts bypass problem formal assertions approach limited state space design since never attempt verify rtl design directly changes made process synthesis paper look closely important stage highlevel synthesis namely scheduling stage illustrate approach verifying implementation stage conventional hls system formalism achieved context theorem proving exercise embedded within synthesis domain appealing aspect approach verification exercise conducted within framework conventional synthesis system thus avoiding complexities involved integrating synthesis system verification tool seamlessly integrating conventional automatic synthesis formal assertions approach introduces formalism synthesis subtasks transparent designer section 2 gives outline verification approach section 3 introduce verification problem present core set correctness conditions section 4 present well known scheduling algorithm formulate conditions verification approach discuss proof strategy section 5 discusses applicability proof exercise within context high level synthesis environment results presented section 7 scope verification approach discussed section 8 make conclusions section 9 assertions based verification outline verification approach based higherorder logic theorem proving leading formal assertions program code stage highlevel synthesis well understood scope welldefined input specification passes stage synthesis undergoes specific modifications bring closer final rtl design therefore possible capture specification stage synthesis precise manner 21 verification outline ffl characterization identify base specification model synthesis task model cover aspects correctness particular synthesis task task synthesis welldefined base specification model usually tight set correctness properties completely characterizes synthesis task ffl formalization specification model formalized collection theorems higherorder logic theorem proving environment form base formal assertions algorithm chosen realize corresponding synthesis task described formal environment ffl verification formal description algorithm verified theorems characterize base specification model inconsistencies base model identified verification exercise model enhanced several additional formal assertions derived verification formal assertions represent invariants algorithm ffl formal assertions embedding develop software implementation algorithm formally verified previous stage embed much enhanced formally verified set formal assertions within software implementation program assertions synthesis implementation task continually evaluated specification model specified assertions design error synthesis detected highlevel synthesis system wherein task embedded formal specification model constitutes formal synthesis system strives generate errorfree rtl designs rest paper explain verification approach context scheduling task highlevel synthesis scheduling task base specification model scheduling task one crucial steps highlevel synthesis since directly impacts tradeoff design cost performance maps operation specification time step given constraints imposed input specification user time steps correspond clock cycles rtl design scheduling done either resource constraints design area component library time constraints design speed paper illustrate verification technique resourceconstrained scheduling algorithm scheduling stage views input specification dependency graph dependency graph directed acyclic graph dag vertex associated operation specification presence edge two vertices graph denotes data dependency control dependency operations associated vertices data dependencies capture operation assignment statements input specifications hence order execution control dependencies make semantics conditional loop constructs consider simple dependency graph shown figure 1 op1op2op3 op4 denote four vertices graph operation type specified inside vertex primary inputs feed op1 op2 op 3 edges denote data dependencies specify order operations executed final rtl design addition dependency graph scheduling stage expects valid module bag library components enough functionality fully implement operations specification module bag typically generated module generation stage usually precedes scheduling synthesis flow 31 base specification model scheduling task let n set operation nodes e set dependency edges dependency graph let r bag denote bag resources available sched func schedule function maps every operation graph positive time step given following three correctness conditions capture base specification model 1 existence schedule function maps every operation input specification positive time step op2 op3 op4 figure 1 simple dependency graph 2 dependency preserved directed edge exists two operations graph operation source edge scheduled earlier time step operation destination sched sched thus figure 1 op2 always scheduled op 4 3 resource sufficiency operations mapped time step must satisfy resource constraints 1 let set time steps operations graph scheduled let ots set operator types graph op map function maps operator type set operations time step n let rmap map operator type modules r bag implement operator type two operations op1 op2 dependency graph shown figure 1 scheduled time step provided r bag least two adders every correct schedule satisfy three correctness conditions 2 properties far removed algorithmic details hold entire class resourceconstrained scheduling algorithms treatment scheduling stage paper concentrated primary function scheduler timestamping operations input specification highlevel synthesis systems addition primary function scheduling stage also performs functional unit allocation either concurrently stepwise refinement manner methodology quite easily extended reflect additional tasks performed scheduling stage sake paper assume scheduling stage support multicycling chaining operations therefore operation input specification consumes exactly one time step assume highlevel synthesis system generates nonpipelined rtl designs therefore scheduling task consider structural pipelining functional pipelining issues additional correctness conditions easily included base specification model order reflect extensions primary scheduling task assume least one resource r bag implement operation graph 2 conceivablyadd 4th condition captures desirable property scheduler tightness property states every time step 1 maximum time step scheduled graph must least one operation scheduled let tmax maximum time step nodes input graph scheduled state property following sections discuss verification strategy closely looking scheduling algorithm used widely highlevel synthesis force directed list scheduling algorithm proposed paulin knight 13 theory formal verification scheduling algorithm force directed list scheduling fdls 13 resourceconstrained scheduling algorithm popular scheduling technique widely used many synthesis tools exist current literature fdls algorithm shown figure 2 based classic list scheduling algorithm 16 uses global measure concurrency throughout scheduling process 13 41 overview force directed list scheduling algorithm operations dependency graph sorted topological order based control data dependencies time step step list operations ready scheduled called ready list l ready formed includes operations whose predecessor operations scheduled long resource bag r bag insufficient schedule operations l ready inner loop see figure 2 keeps deferring operation iteration order select operation defer deferral force calculated ready list operations least force operation picked resources sufficient remaining operations ready list scheduled current time step first step computing deferral forces determine time frames every operation evaluating asap alap late possible schedules next step determine distribution graphs measure concurrency similar operations 12 finally forces operation computed given time frames distribution graphs calculation forces operations performed deferral produces lowest force chosen repeated resources sufficient implement operations ready list operations pruned ready list assigned time step 42 formalization base specification model base specification model scheduling task described earlier section 3 formalized theorems higherorder logic formulation done pvs prototype verification system 17 specification language environment order understand formal specification model better first introduce basic type information formal model fdls algorithm based describe formalization correctness properties theorems higherorder logic 421 fdls type specification input scheduling algorithm dependency graph operations input specification form nodes graph dependencies operations represented directed edges type specification shown figure 3 describes type structure input specification operations arithmetic logical conditional etc therefore model operation node op node desired set data values declaring uninterpreted type thus behaves placeholder arbitrary set data values type declaration denotes op node nonempty type exist least one variable type avoid certain typecheck conditions dep edge declared interpreted type actually type name tuple type defines ordered pair op node thus capturing semantics directed edge input dependency force directed list schedulingdfg r bag begin length dfg step tmax iteration corresponds step evaluate time f rames ready f operations whose time frames intersect step g r bag sufficient need defer operation compute op operation l ready least force ready l ready gamma fopg defer operation op critical path evaluate time f rames operation op 2 l ready schedule op step end end figure 2 force directed list scheduling algorithm graph tuple type op graph captures semantics input dependency graph defined ordered pair sets first projection type op node set second projection type dep edge set actually dependent type defined terms first projection ensures input dependency graph g wellformed terms edges defined terms nodes graph addition input dependency graph scheduling task expects bag resources initial schedule function type declaration shown figure 3 module uninterpreted nonempty type bag modules derived represent input resource bag scheduling function type schedule maps domain op node naturals figure 4 shows relevant variables used description correctness theorems input graph defined terms finite set nodes n set edges e three function variables type schedule declared module bag variable rbag declared scheduling algorithm represented fdls function recursive function takes input graph n e bag resources rbag initial schedule placeholder function initiate recursion final sched func output function scheduling algorithm 422 existence theorem existence theorem shown figure 5 theorem states final sched func schedule function obtained execution fdls function maps every operation input graph positive natural fdls function expects three arguments dependency graph bag resources initial scheduling function output fdls function final schedule theorem asserts final schedule maps every node graph positive time step existence function accepts set nodes schedule function returns true nodes node set scheduled opnode type depedge e edge proj1e proj2e prededepedge nodesetproj1e proj1e1proj1e proj2e1proj2e module type modules schedule figure 3 types formal model fdls algorithm n var finitesetopnode e var preddepedge rbag var modules schedfunc var schedule initschedfunc var schedule finalschedfunc var schedule figure 4 variables pvs model scheduling 423 dependencies preserved theorem theorem shown figure 6 ensures final schedule violate dependencies specified input dependency dependencies preserved function takes graph final schedule ensures dependencies graph preserved final schedule function visits every edge input graph checks partial order maintained schedule existence theorem forall n e rbag initschedfunc finalschedfunc existencen finalschedfunc existencen figure 5 existence theorem scheduling dependenciespreserved theorem forall n e rbag initschedfunc finalschedfunc dependenciespreservedn e finalschedfunc dependenciespreservedog figure dependencies preserved theorem scheduling forall n e rbag initschedfunc fdlsn e rbag initschedfunc constraintssatisfiedn e rbag finalschedfunc constraintssatisfiedog rbag schedfunc forall tstep posnat proj1ogn resourcesuffros finitesetopnode rbag exists opnoderesourcemap memberopnoderesourcemapn1 mbag memberopnodereourcemapn2 mbag true else false figure 7 resources sufficient theorem scheduling 424 resources sufficient theorem theorem shown figure 7 asserts correct scheduling function obeys resource constraints specified input resource bag specific resource constrained scheduler algorithm attempts optimize time steps given limited set resources schedule satisfies constraints function performs resource suff test time step resource suff function returns true operations given time step denoted executed resources rbag resource suff function specified pvs model fdls theory shown figure 7 resource suff function accepts set selected nodes known ready set bag resources declare function opnode resource map maps set op node resource bag rbag resource suff function returns true mapping injective nodes ros mapped resources rbag three base theorems specify functional correctness resource constrained scheduling algorithm make assumptions implementation details scheduling algorithm assert properties satisfied correct scheduling task attempts timestamp input dependency graph two choices modeling fdls algorithm pvs constructively explicitly defining result algorithm constructed descriptively ie stating set properties axioms algorithm satisfy chose former style since conducive topdown approach verifying fdls algorithm function algorithm constructively defined use pvs language mechanisms ensure functions hence algorithm well defined total purely descriptive style could introduce inconsistent axioms lemmas although would useful underspecification fact judicious mix styles specification would best suit verification strategy since verification exercise concentrates developing correctness properties scheduling task axiomatize portions formal model fdls algorithm pertain purely optimization issues example fdls algorithm shown figure 2 compute deferral forces function decides operations ready set selected scheduled current time step set axioms quite easily stated capture requirements function exact construction function necessary conduct verification exercise 43 formal verification fdls algorithm given formal model fdls algorithm three theorems formal assertions capture general correctness criteria fdls algorithm next verify formal model algorithm indeed satisfies theorems pvs proof checking environment pvs verifier employs sequent calculus 18 sequent conjunction antecedents imply disjunction consequents sequent calculus proof viewed tree sequents whose root sequent form property proved antecedent empty proof pvs ends every path root tree terminates leaf node implication indeed true fdls theory pvs shown figure 8 fdls function defined recursively captures semantics fdls algorithm shown figure 2 pseudocode shown figure 2 outer loop terminates inside loop tmax conditionally stretched modeling loop structure recursive function terminating condition would lead illdefined function recursive function pvs required specify measure function ensure recursive function welldefined measure applied arguments recursive call compared measure applied original arguments case measure function specifies cardinality set unscheduled op node input graph reduce recursive call due lack space formalization force update using time frames distribution graphs calculation asap alap schedules shown pvs model figure 8 present insight verification approach partially walking portion proof exercise one theorems namely existence theorem existence theorem states truth nodes input graph proof theorem proceeds induction variable n set op node using induction scheme cardn results base case easily discharged grinda builtin strategy induction case displayed sequent figure 9 proof goal specified formula 1 consequent antecedent formula f1g reiterates induction step carefully studying sequent one observe proof goal actually embedded within formula 3 appropriate proof steps isolate right side implication formula f3g proper instan tiations extract formula matches proof goal shown formula 1 order isolate proof goal thus prove theorem carefully introduce four additional lemmas specification lemmas form first hierarchy lemmas existence theorem categorized level 1 lemmas shown figure 10 assert set correctness properties specific fdls algorithm example lemma delete ros card lemma states function new unsched nodes always returns set whose cardinality always smaller original node set n words formalizes assertion nonempty set operators scheduler theory begin importing fdlstypes getmaxparenttstepr finitesetopnode og opgraph schedfunc schedule emptyp 0 else maxrecp endif getmaxschedschedfunc updatedschedros nonemptyfinitesetopnode schedfunc schedule maxsched nat lambda n opnode rosn maxsched updatedrosros nonemptyfinitesetopnode mbag modules getrosog n opnode finalrosog opgraph mbag modules newschedfuncog opgraph mbag modules schedfunc schedule updatedschedfinalrosog mbag schedfunc getmaxschedschedfunc newedgesog opgraph n finitesetopnode e depedge proj2oge nproj1e nproj2e newunschednodesog opgraph mbag modules fdlsog opgraph mbag modules schedfunc schedule fdlsnewunschednodesog mbag restrictnewedgesog newunschednodesog mbag mbag newschedfuncog mbag schedfunc end scheduler figure 8 overview pvs theory fdls algorithm fdlsnewunschednodess1 restricte1 rbag1 restrictnewedgess1 restricte1 newunschednodess1 restricte1 rbag1 newschedfuncs1 restricte1 rbag1 initschedfunc1 3 implies forall e rbag initschedfunc finalschedfunc existences2 finalschedfunc figure 9 induction step proof sequent fdls algorithm verification scheduled recursive call fdls function new unsched nodes function lemma takes given graph returns smaller node set removing graph operators scheduled current iteration proof steps delete ros card lemma lemma shown table 11 proof lemma easily discharged introduction three additional lemmas shown table lemmas introduced prove delete ros card lemma form second hierarchy level 2 lemmas adopted topdown approach simplify proof exercise theorems proved using lemmas level 1 lemmas appropriate inference rules provided proof system proofs level 1 lemmas sometimes require introduction additional lemmas level 2 lemmas sufficient care taken ensure lemmas introduced consistent relevant verification exercise lemmas next proved course proofs additional lemmas introduced process continues additional lemmas need introduced theorem thus considered proved proved lemmas hierarchies successfully proved topdown approach results wellstructured proof exercise addition making overall proof effort manageable added advantage systematically deriving large set formal correctness properties lemmas large complex task scheduling rather difficult identify task invariants makes verification algorithms hard problem approach presents systematic way identify invariants generate formal environment existence theorem alone total 26 invariants formulated part proof exercise large set formally derived invariants provide considerable insight correctness issues concerning existence theorem fdls algorithm similar proof approach adopted verify two theorems concerning dependency preservation resource sufficiency thus starting three base theorems able formulate set 43 lemmas formal assertions consequence formal proof system formal assertions organized four levels hierarchy assert several invariant properties fdls algorithm without introducing formalism specification model would hard identify task invariants formal assertions express precision assured correctness next section show used set formal assertions make enhanced specification model deleteroscardlemma lemma nonemptyn cardnewunschednodesn e deleteexistencelemma lemma finalschedfunc schedule initschedfunc schedule rbag modules existencenewunschednodesn e rbag finalschedfunc existencedifferencen newunschednodesn e rbag newschedfuncn e rbag initschedfunc existencen finalschedfunc rosconstructionlemma lemma forall e preddepedge n finitesetopnode rbag modules n opnode membern n membern newunschednodesn e rbag membern finalrosn e rbag rosexistencelemma lemma initschedfunc schedule rbag modules n opnode membern finalrosn e mbag newschedfuncn e mbag initschedfuncn 0 figure 10 level 1 lemmas existence theorem fdls algorithm fdls algorithm formalize c implementation fdls algorithm implementation formal assertions embedding program code section discuss used set formal assertions make specification model fdls algorithm verify scheduler implementation existing highlevel synthesis system dss 5 dss accepts algorithmic behavioral specifications written subset vhdl generates rtl design also expressed vhdl subject constraints clock period area schedule length power dissipation scheduling phase dss implemented variation fdls algorithm extended handle vhdl specifications multiple processes signal assignments wait statements fdls algorithm enhanced perform global process scheduling operations across processes share data path resources addition assigning timesteps stage also binds operations functional units target library scheduling stage currently support pipelining chaining multicycling overall structure implemented scheduler dss modeled closely fdls algorithm described section 4 theorems lemmas formulated theorem proving exercise constitute set formal assertions invariants represent functional specification fdls algorithm execution run scheduler faithful formal specification model assert correct schedule generated assert assert assert figure 11 proof steps delete ros card lemma since formal specification model formulated higherorder logic implementation scheduler dss c software domain establishing equivalence imp spec straightforward procedure formalized specification model set formal assertions specifies invariants different portions fdls algorithm formal assertions translated c program assert statements embedded portions scheduler implementation correspond spatial locality invariants formal model algorithm scheduler thus embedded formal specification model giving rise autoverifying scheduler sake illustration figure 12 shows fdls algorithm small sample formally derived program assertions embedded within three base program assertions correspond three base formal assertions stated originally carefully translate theorems c assert statements place outside body fdls implementation since verify truths scheduling technique used checkpoint order ensure final state scheduler violation three universal correctness properties scheduler completed execution generated schedule base program assertions executed schedule incorrect schedule generated one assertions raises exception thus schedule generated formally embedded scheduler guaranteed errorfree correct scheduler completely specified three base assertions capable detecting error scheduler implementation might result incorrect schedule base formal assertions due spatial location code highlevel notion correctness usually provide useful information incorrect schedule apart detecting presence lemmas axioms systematically formulated formal assertions verified result pvs proof exercise play important role error diagnostics illustrate referring embedded fdls algorithm shown figure 12 formal assertions introduced different levels hierarchy proof exercise carefully translated program assertions hierarchy preserved organization program assertions thus level 1 program assertions narrower scope time focus detecting errors local areas scheduler implementation assertions embedded code shown inner loop loop assert invariant properties loop statement delete ros card assertion states invariant property true end every iteration outer loop placing portion code ensure identification violations assertion every iteration scheduler contrast error showing base assertions iterations scheduler completed level 1 assertions thus offer better diagnostics user promptly made aware error implementation proceed hierarchy formal assertions finer details implementation subjected verification formal assertions correspond levels specific verifying smaller portions scheduler code thus expose errors code pinpoint accurately going back force directed list schedulingdfg r bag begin length dfg level 3 assertions schedule invariant ordered schedule strict subset nonempty oe step tmax evaluate time f rames ready f operations whose time frames intersect step g r bag sufficient compute assertions ros invariant ros construction ros nondependence card strict sub oe op operation l ready least force ready l ready gamma fopg op critical path evaluate time f rames end level 1 assertions final ros sufficiency edge dependence final ros wellformed ros sufficiency oe operation op 2 l ready schedule op step end level 1 assertions delete ros card delete existence graph wellformed edge wellformed oe base assertions existence dep preserved res sufficiency oe end figure 12 fdls algorithm sample formal assertions previous example although program assertion delete ros card virtue position code able detect errors within one iteration outside loop scheduler might still good enough locate source problem card strict subset one lemmas used complete proof delete ros card property theorem proving environment corresponding level 2 formal assertion verifies invariance iteration inner loop algorithm assertion concentrates smaller portion implementation promptly detect violations base assertionsthe verification approach thus extended many levels hierarchy formal assertion tree source error isolated detection localization example dss since inception used synthesize benchmarks largescale specifications design examples carefully chosen test wide range synthesis issues ranged single process arithmeticdominated specifications multiple process specifications complicated synchronization protocols various combinations control constructs like conditionals loops fact effort part concerted endif assertdependencies preservedfdls map endif endif figure 13 base program assertions scheduler attempt systematically validate dss using simulation formal techniques 9 10 15 course exercise sometimes incorrect rtl designs synthesized analysis faulty designs eventually lead discovery implementation errors hls system notably errors rtl designs attributed conceptual flaws scheduler implementation errors identified using systematic simulation methods traditional software debugging aids although exercise led increased confidence reliability synthesis system given limited number test cases involved one could never sure isolating bugs system also complexity synthesis system rendered error trace back often quite laborious time consuming formal assertions approach hope address problems validating synthesized rtl designs particular since formal specification model scheduler embedded within implementation c assertions incorrect schedule almost always guaranteed violate specification model violation immediately flagged exception user notified properly enabling formal derived program assertions trace back source bug performed almost effortlessly illustrate approach walk error detection exercise scheduling stage synthesis system using formal assertions technique formally embedded scheduler seeded error would result synthesis rtl design incorrect schedule begin enabling base program assertions first run scheduler since assertions checked execution run overhead introduced minimal necessary could systematically enable levels hierarchy formal assertions tree build error trace would guide us problem area scheduler implementation bug scheduler code fires dependencies preserved base program assertion synthesis rtl design shown figure 13 assertion situated end scheduling task along two base assertions figure function fdls graph implements fdls algorithm returns final schedule fdls map base assertions placed outside actual implementation scheduler assertion checks see schedule preserves dependencies boldfaced italicized figure input graph fails due error introduced code tells us final schedule somehow violates partial order specified input graph order get information source error level 1 program assertions enabled scheduler executed set test cases time assertion failure occurs within body fdls graph function portion scheduler function embedded assertion shown figure 14 assertion edge dependency lemma placed termination inner loop assertion c translation following pvs lemma unschednodesp readylistn f break end inner loop assertedge dependency lemmaready list unsched nodes original unsched nodes endif assertdeleteroscardexistencelemmaunschednodeslength endif figure 14 level 1 program assertions scheduler forall og opgraph e depedge membere membere newedgesog newunschednodesog mbag memberproj2e newunschednodesog mbag lemma states edge present present graph present next update graph one nodes must ready set ros node must updated graph thus failure formal assertion shown boldfaced figure 14 gives user insight nature error portion scheduler code around formal assertion examined closely errors immediate cause error discovered level 2 assertions enabled hope would provide information cause error scheduler executed time one assertions level 2 class program assertions fails snapshot code shown figure 15 time program assertion ros nondependence assertion shown boldfaced figure 15 fails placed inner loop checks resource sufficiency figure 12 assertion translated following pvs lemma rosnondependence lemma forall og opgraph n opnode opnode membern ros memberm ros membern proj2og memberm n proj2og lemma states property nodes ready set ros must satisfy property asserts two nodes ready set edge means ready set comprised nodes dependency relations among clearly assertion failure indicates current ready set somehow violates property need look routine builds ready set order find error build ready list n check unscheduled parent allparentsarescheduled error p allparentsarescheduled break allparentsarescheduled f assertros nondependenceready list unsched nodes endif defer operations resource constraints met figure 15 level 2 program assertions scheduler upon examining portion code located failed assertion easily noticed selection process culprit selection process erroneously admits node ready set even one parents scheduled yet caused statement code shown figure 12 selection process admit node ready set parents scheduled achieved replacing erroneous construct construct constraining scheduler implementation abide formal specification every step execution run ensure efficient reliable error detection trace mechanism errors traced back source using technique systematically enabling higher levels formal assertions 7 errors discovered formal assertions order test effectiveness formal assertions approach synthesis system seeded 6 programming errors formally embedded scheduling stage errors represent actual implementation errors earlier discovered period time traditional validation techniques like simulation code walk throughs hoped approach would serve two purposes discover least 6 seeded errors little user intervention provide error trace source program errors scheduler executed synthesis system number design examples table 1 shows details experiment seven examples range size little 12 operation nodes many 300 operation nodes test assertion levels detect errors op nodes 26 fbase12g pass fbaseg fbase1g f1g pass pass test3 50 fbase12g fbase1g fbaseg pass f1g pass pass test6 200 fbase12g fbase1g fbaseg pass f1g fbase1g fbaseg table 1 verification results formally embedded scheduler columns 37 tabulate error detection results five program errors detected execution scheduler code entries columns indicate levels formal assertions needed pinpoint source error pass entries table 1 indicate successful execution test cases program errors adverse effects correct schedule generated implementation none formal assertions triggered base formal assertions sufficient ascertain source error base alone appears corresponding entry table thus error 3 detected one base formal assertions test cases next observe results error 1 error involved incorrect way building ready set earlier illustrated previous section walked error detection exercise test error went undetected since none nodes test case one parent result error code result incorrect schedule rest test cases formal assertions base level 2 detected error cases although error detected three levels formal assertions level 2 enabled order pinpoint source error discovered formal assertions approach error hitherto escaped detection even simulation code inspection defer operation routine culprit available resources incorrectly analyzed building ready list result discontinuity schedule numbers assigned operators input specification conceptual error detected enabling level 1 program assertions introduced error asap alap routines manifests last three test cases fact needed formal assertions level 1 hierarchy enabled order locate source error error 6 effect schedule first four test cases since enough resources schedule operations hence bug goes undetected error 7 represents program error force calculation routine scheduler generated correct schedules test cases 1 2 3 since enough resources schedule operations hence defer operation routine never executed scheduling test cases rest four test cases error discovered source pinpointed base assertions overhead formal assertions approach significant table 2 shows timing information test cases presented experiment conducted sparc 5 workstation 60mb resident memory second column represents fdls algorithm run time none assertions enabled entries third column denote run times algorithm three base assertions enabled increase run times hardly noticeable expected since base assertions evaluated scheduling algorithm assigns time steps fourth column represents run times levels program assertions enabled algorithm appreciable increase run times since assertions embedded within algorithm evaluated several times execution algorithm quite clearly seen overhead introduced formal assertions approach pose serious problems performance fdls algorithm typically base assertions switched normal synthesis process assertion failure signals synthesis process fault somewhere implementation design resynthesized test fdls algorithm run time seconds assertions base assertions assertions table 2 runtime overhead due formal assertions scheduler enabling lower levels program assertions order trace back source program error synthesis system 8 scope verification effort formal assertions technique ensures detection incorrect schedule schedule directly indirectly violates base formal assertions therefore validity verification approach hinges completeness set theorems make base specification model lemmas derived formulated thorem proving exercise usually limited identifying errors result violations base theorems experiment observed except error 5 errors led incorrect schedule identified base assertions reinforced confidence completeness set base theorems exploited absence base correctness condition ensured tightness property discussed earlier second footnote end section31 discussed possibility adding fourth base theorem captured socalled tightness property states cannot discontinuity schedule input graph since strictly correctness issue include base theorems happened one level 1 lemmas engendered induction strategy deductive analysis used prove base theorems explicitly specified property explains error 5 discovered level 1 assertions slipped past base assertions typically lower level assertions axioms enable error detection finer granularity possible base assertions error detecting capabilities limited specific compared base formal assertions verification formal assertions translated program assertions synthesis system given expressive differences logic software domain translation process often could get quite complicated ultimately correctness formal assertions approach hinges translation process convenient data structures exist allow us conveniently conduct translation process sometimes theorems cannot translated directly software domain cases develop equivalent formal assertions amenable software domain formally establish equivalence relationships ensure translation process indeed correct portability issues formal assertions approach need addressed base assertions typically quite easily ported across different algorithms perform task synthesis lower level assertions formulated course formal proof exercise present limited portability formal assertions modifications fairly easily ported across implementations belong class algorithms portability across classes algorithms could restricted would require additional proof exercises order formulate appropriate formal assertions formal assertions approach verifies single execution run synthesis process guarantees correct design specification violated process synthesis therefore entirely feasible bugs synthesis system go undetected manifest execution shown table 1 bugs exposed soon introduce errors rtl designs synthesized 9 conclusions future work insertion assertions invariants 2 programs known effective technique establishing correctness outcome executing program discovering isolating errors however determination appropriate set assertions often tedious errorprone task paper made use mechanical theorem proving systematically discover set sufficiently capable assertions presented formal approach verifying rtl designs generated highlevel synthesis verification conducted program assertions discovered theorem proving environment paper focused resourceconstrained scheduling task synthesis correctness conditions resourceconstrained scheduling formally specified higherorder logic formal specification fdls algorithm verified using deductive techniques large set additional properties systematically discovered verification exercise properties embedded program assertions implementation scheduling algorithm highlevel synthesis tool assertions act watchpoints collectively ensure detection errors synthesis process appealing aspect approach systematic incorporation design verification within traditional highlevel synthesis flow conduct formal verification exercise synthesized rtl design synthesis environment design synthesized avoiding need functional verification synthesized design later using formal verification tool simulator time taken onthefly verification approach scales tolerably size design synthesized contrast blind postfacto simulation model checking theorem proving based verification approaches use reasoning based properties synthesis algorithms one criticism approach may concern care effort involved manual process converting formal assertions higherorder logic program assertions c experience indeed proved process requiring considerable diligence often express formal assertions several different ways higherorder logic time carefully constructing necessary datastructures c enable implementation program assertions process repeated discovered form formal assertion lent straightforward transliteration c estimate entire process fdls formalization verification embedding assertions implementation took 260300 person hours another criticism approach concerns sufficiency assertions isolate error error cannot caught source first causes assertion violation however problem assertionbased approaches program correctness sufficiency base correctness conditions never formally established conditions represent formalization intuitive understanding scheduler effort currently underway adopt verification strategy presented paper formalize stages highlevel synthesis system approach allow early detection errors synthesis process rtl design completely generated r implementation issues embedding existing high level synthesis algorithms hol science programming highlevel synthesisintroduction chip system design integration formal methods system design dss distributed highlevel synthesis system introduction hol engineering approach formal system design synthesis optimization digital circuits synchronous controller models synthesis communicating vhdl processes validation synthesized registertransfer level designs using simulation formal verification vhdl efficient firsttime right designs formal approach force directed scheduling behavior synthesis asics scheduling binding algorithms highlevel synthesis highlevel vlsi synthesis experiences functional validation high level synthesis system experiments local microcode compaction horizontal machines pvs prototype verification system user guide pvs specification verification system language proof checker synthesis digital designs recursion equations interplay synthesis verification survey highlevel synthesis systems tr scheduling binding algorithms highlevel synthesis highlevel synthesis experiences functional validation high level synthesis system vhdl efficient firsttimeright designs science programming synthesis digital design recursive equations synthesis optimization digital circuits highlevel vlsi synthesis dss engineering approach formal digital system design implementation issues embedding existing high level synthesis algorithms hol effectiveness theorem proving guided discovery formal assertions register allocator highlevel synthesis system pvs facet synchronous controller models synthesis communicating vhdl processes theorem proving guided development formal assertions resourceconstrained scheduler highlevel synthesis
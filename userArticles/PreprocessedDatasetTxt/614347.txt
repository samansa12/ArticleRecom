realtime photorealistic visual flythrough abstractin paper present comprehensive flythrough system generates photorealistic images true realtime high performance due innovative rendering algorithm based discrete ray casting approach accelerated ray coherence multiresolution traversal terrain well 3d objects represented textured mapped voxelbased model system based pure software algorithm thus portable first implemented workstation ported generalpurpose parallel architecture achieve realtime performance b introduction quest realtime photorealistic rendering one major goals 3d computer graphics recent years techniques adding realism image shading shadow textures transparency developed generation realistic images realtime currently researched flight simulator applications always led way realtime performance 3 specialpurpose machines dedicated flight simulation developed machines generate images reasonable realism realtime expensive million us dollars 7 15 main contribution work presented paper realtime performance achieved commercial generalpurpose parallel architecture opposed specialized rendering hardware generating images arbitrary complex scenes within reach current technology however rate image generation flight simulation achieve realtime scenes viewed sky complex typical views contain terrains merely 25d 3d objects seen relatively simple featureless objects nevertheless simulating photorealistic aerial views realtime means easy 10 term visual flythrough distinguished flight simulation visual flythrough generates simulated images seen video camera attached flying object camera generates photorealistic images although necessarily color since many video cameras greylevel output emphasized generation true photorealistic images critical applications user needs recognize area identify objects ground ie targeting mission rehearsal see photorealistic impression images presented figure 1 typical flythrough scenario camera views large area especially camera pitch angle high ie towards horizon many applications camera flies high speed long distances area covered seconds flight vast suggests possible load entire terrain data onto main memory applications even gigabyte ram enough safe say size ever suffice since application demands always increase according availability space suggests flythroughs require large secondary storage together fast paging mechanism image aerial view gains realistic impression mapping digital photograph onto terrain model order achieve high quality full resolution digital terrain model corresponding aerial photograph need employed causes major load conventional graphics hardware based geometric pipeline first high resolution polygonal terrain model contains vast number polygons need processed geometric pipeline processing tiny polygons loses costeffectiveness rasterization hardware high resolution photograph needs texturemapped rasterization creates problem since large photographic maps need loaded onto expensive cache example realityengine board cannot hold kilobytes texture 1 larger textures need paged main memory realtime 8 avoid many flight simulators use repetitive patterns ground texture applications specific target area vital requirement true photograph mapped terrain photographs huge must loaded fly rasterization hardware forming serious bottleneck rendering pipeline instead using polygonal model geometric pipeline favored software solution model represented voxelbased representation texturemapping photograph model preprocessing stage decoupled rendering stage 9 voxelbased modeling also lends representing fine grained geometry voxel data regular internally represented array offers easy fast access data 5 voxel represents stores discrete local attributes model voxels representing terrain contain height value color value voxels representing 3d model contain texture photograph described section 5 voxelbased visual flight simulator realtime performance developed hughes training inc flight simulator runs special purpose hardware yields poor results graphics workstation 15 visual flythrough developed hardware independent thus portable portability important since enables integration flythrough system rapid progress hardware platforms however software rendering algorithm must fast enough around second two per frame running sequential machine parallel machine processors achieves rate higher 20 frames per second figure 1 two aerial photorealistic images generated flythough course assuming little overhead imposed parallel version algorithm although employed parallel machine real time performance mainly due innovative rendering algorithm new algorithm generates photorealistic image figure 1 within two seconds common workstation implementation parallel version algorithm 32way multiprocessor architecture sped rendering achieve desired realtime rates noted hard ware independent ray casting algorithms reached reasonable speeds 13 5 11 point sampling avoiding aliasing artifacts quite involved time costly algorithm presented resembles principles projection algorithm 15 however algorithm based forward mapping method designed implemented hard ware algorithm presented next section simple ray casting figure 2 image footprint terrain defined viewing parameters forward mapping accelerated ray coherence multiresolution traversal highly optimized hardware independent implementation remainder paper structured follows section 2 describes rendering algorithm section 3 presents ibm power visualization system current parallel platform parallel algorithm implementation details concerning parallelization algorithm results discuss generation voxelbased objects section 5 conclude brief discussion current activity final remarks 2 rendering algorithm sequence images generated rendering algorithm independent image defined location camera 3d space camera field view orientation namely pitch roll yaw angles image resolution figure 2 depicts image footprint defined projection image frame terrain terrain model represented voxelbased map generated discrete elevation map colored corresponding aerial photo map rendering algorithm based backward mapping approach known ray casting image generated casting rayofsight emanating viewpoint image pixels towards model see figure 3 ray traverses figure 3 discrete ray casting voxelbased terrain terrain voxels intersects terrain terrain color sampled mapped back source pixel since model discrete explicit intersection calculation sequential search hit ray voxel speed ray traversal crucial achieving realtime performance technique employ based discrete grid traversal steps along ray performed projection ray plane rather 3d heights along ray incrementally uniformly sampled compared height terrain hit occurs color terrain hit point mapped back source pixel hit background color sky mapped apparently naive traversal flat 12 contrast hierarchical traversal 5 5 pyramidal elevation map used multiresolution pyramid treated hierarchy bounding boxes ray traverses recursive topdown traversal number steps hierarchical traversal proportional height pyramid binary pyramid used number steps logarithmic terrain length rather linear terrain size case flat traversal figure 4 assuming terrain caves ray emanate previous hit point algorithm based incremental flat traversal shown rays hierarchically traversed since terrain height field map assume terrain model vertical cavities overhangs ie vertical line one intersection terrain traversal accelerated using ray coherence 6 11 basic idea long camera roll ray cast pixel vertically adjacent always hits terrain greater distance viewpoint ray image pixels generated column column bottom top ray emanating ray always traverse distance shorter distance ray see figure 4 thus ray traversal distance equal range previous hit ray feature shortens rays traversal considerably total number steps required generate one column equal length column footprint eliminating factor number pixel columns words naive generation one column time complexity oml l length column footprint number pixels image column using ray coherence time complexity reduced ol providing order magnitude speed rays emanating bottom column cannot gain previous hit thus accelerated hierarchical traversal 5 using vertical ray coherence consecutive rays terrain voxel virtually traversed time complexity traversal proportional number voxels image footprint still huge number since image footprint extend horizon moreover number viewdependent causes instability frame generation rate due perspective projection rays diverge distance caus figure 5 multiresolution traversal voxel map resolution corresponds sampling rate ing nonuniform sampling rate terrain voxels rays rays emanating bottom image frame hit terrain closer range upper rays assuming terrain dataset represented single resolution close voxels tend oversampled far voxels undersampled using hierarchy data resolutions improves sampling since rays adaptively traverse sample voxels appropriate size proportional pixel footprint see figure 5 optimally every step one pixel generated multiresolution traversal voxel sampling rate becomes proportional number rays ie pixels number steps becomes independent viewing direction number steps terrain order image space rather object space thus adaptive hierarchical traversal speeds rendering also helps stabilize frame generation rate implementation use pyramid data resolutions level half resolution level using resolutions even successful sense uniformity sampling would use space another advantage binary pyramid simplicity alternating consecutive levels step sizes either multiplied divided two taking advantage integer arithmetic traversal 5 moreover pyramid offers fast first hit first rays emanate bottom row pixel array rays cannot benefit coherency previous rays rays topdown traversal hierarchy speeds first hit 5 one important issue must taken care realtime hierarchical rendering creating soft transition switching levels sharp transition noticeable causes aliasing effect wave sweeps terrain simple solution interpolate adjacent hierarchies 14 interpolation weights defined distance viewpoint sampled voxels since range gradually changes weights causing soft transition synthetic objects trees buildings vehicles placed terrain 3d objects represented sticks run voxels three types uniform sticks colored single color like terrain voxel textured sticks contain vertical sequence colored voxels complex sticks textured sticks contain semitransparent fully transparent voxels see 15 synthetic objects described set adjacent sticks ray hits textured stick climbs onto stick maps back stick texture screen semitransparent value encountered secondary ray continues voxel results secondary ray blended values primary ray according value semitransparent voxels many cases transparency value indicates cavity stick case blending performed colors secondary rays directly mapped pixels since cavities cause spawning secondary rays clear slow rendering process one way reduce cavities fill coarse resolutions assuming cavities small enough contribution final image insignificant one note typical scenes small fraction sticks need complex example viewing woods trees boundary needs fully represented non convex parts trees hidden tops seen typical scene contains many replicated objects placed different locations orientations thus many sticks common many objects complex voxel contains pointer instead color points stick table stick consists header sequence values header contains several attributes like stick type stick length 21 basic algorithm section present detail basic algorithm generates single column image algorithm based fast traversal column footprint terrain voxels along footprint tested visibility colors visible ones sampled mapped back image column pseudocode shown figure 7 let e location eye p location column pixel parametric equation ray emanating e passing p e denote ray direction given x coordinates along ray explicitly given assuming ray x major ie qx qy sequence voxel coordinates x along q generated forward differences evaluation line equation z signqx using fixed point arithmetic integral coordinate denoted byc retrieved shift operation binary representation fraction part used linear interpolation sampling point see hit ray q terrain detected comparing heightx byc height terrain x byc z z heightx byc x z incrementally updated otherwise hit detected terrain color x byc sampled mapped pixel p j process proceeds next ray q j1 emanating p j1 since terrain height field ray q j1 hit terrain reaches hit point algorithm continues evaluate sequence x coordinates heights need compared height ray q j1 see figure 6 slope qzqx height image plane figure climbing hit point ray q ray q ray q j1 x evaluated equation 3 note small error introduced since plane defined rays emanating column image plane perpendicular main plane may slightly slanted due perspective projection however field view small say degrees error insignificant let e location eye let p location bottom pixel column let vector direction image columns let e direction ray emanating p assume qx qy e terrain let n distance x end terrain n f reaching end terrain z heightx bycf test hit yield subvoxel weight sample voxels back map results column done return move next pixel climb new ray move next voxel along ray x signqx move along major axes qyqx incrementally update coordinate z qzqx incrementally update ray height n sky seen color rest pixels sky color figure 7 integer base incremental traversal function samplex byc w samples terrain colors integer coordinates x however resolution fixed point values higher voxel space fraction value denoted w yields subvoxel location hit point exact hit point lies vertical grid line x byc x byc 1 see figure 8 thus voxel colors x byc linearly interpolated w since size double step size figure 8 samples always vertical grid lines w indicates subvoxel vertical sample location switch double step size must occur even step pixel footprint size voxel simple filter satisfactory traversal algorithm switch lower resolution point since steps unit size along major direction rather simple double step size respectively ray vector slopes preserve property steps always integer coordinates major axes switching double step size lower resolution must occur even step current resolution see figure 8 switch lower resolution occurs distance voxel footprint image narrower pixel words avoid undersampling voxels since vertical field view equal horizontal field view consider horizontal one allowing vertical oversampling undersampling occur rare cases particular viewing pitch angle low ie shallow pixel footprint tends elongate may cause significant undersampling vertically supersampling pixels compensate elongated footprints costly since require accessing larger number voxels implemented variation supersampling pixel supersampled parallel rays relaxed assumption rays cast single pixel parallel enables efficient implementation without significant loss quality 3 parallel implementation sequential implementation rendering algorithm cannot deliver desired realtime rates contemporary workstations vital use powerful parallel machine speed rendering also support processing large databases application requires flying thousands square kilometers including many 3d objects taking account hierarchical data structures total amount data 35 gigabytes see moreover relevant data ie image footprint must continuously loaded main memory thus machine needs large first secondary memories high speed channels requirements need support machine high speed large storage capacity large bandwidth busses however postprocessor used accelerate image generation rate enhance image quality described block diagram system illustrated figure 9 ibm power visualization system pvs parallel machine described controlled ibm rs6000 support processor also serves connection external world reads commands users control stick sends control command pvs post rendering processor prp see ethernet lan images generated pvs sent via hippi 100mbsec channel prp displayed standard ntsc monitor 31 ibm power visualization system ibm power visualization system pvs designed provide computational power highspeed memory io realize large amounts complex data pvs shared memory architecture consisting parallel processing units 25gb internal local global memory architecture consists eight processor cards processor card consists four processor elements composed intel i860xr i860xp microprocessor operating 40 45 mhz processor storage consists 16 mbytes local memory per processor global memory increased 2048 mbytes global memory consists four memory cards card designed disk array support processor monitor bus interface rs6000 post rendering processor memory scsi interface interface hippi 2gb 512mbcard shared memory system interface pvs 100mbsec control stick system bus ethernet figure 9 block diagram system provide data bandwidth 640mbsec 720mbsec accomplished partitioning memory four interleaved memory banks perform memory reads writes thus reducing latency improving throughput addition interleaving cards multiple memory cards system scsi interface card four fastwide peak 20 mbsec controllers used connect disk array using scsi disk reduces system price promises upgradability pvs strips data controllers giving throughput 70mbsec thus contain database load memory fast enough pvs also provides means producing outputting frames realtime video controller attached via hippi channel server includes two logically distinct frame buffers total capacity 32mb first 8bit buffer used workstation graphics text xwindows system 24bitpixel doublebuffered full color rgb image buffer hdtv resolutions 32 implementation details rendering task partitioned among processors one selected arbitrarily operates master rest slaves master processor among many tasks sets viewing parameters next frame including new positioning camera orientation according trajectories flight generated image treated pool columns slave processor renders one column pixels atomic task soon slave terminates rendering one column picks new column pool access pool monitored semaphore operation provided pvs library semaphore forces exclusive access pool one processor time pick column moreover soon last columns frames picked generated free processors start generate first columns next frame using strategy processors kept busy perfect load balancing although pvs contains much two gigabytes ram database cannot loaded entirely main memory entire database stored disk array relevant sections ie image footprint loaded dynamically memory terrain database partitioned small square tiles according viewing parameters master draws rectangular frame image footprint terrain makes sure tiles fall frame footprint already memory loads missing tiles diskarray since footprint changes incrementally tiles need loaded frame large configuration main memory consists two gigabytes contain size one frame footprint thus use extended footprint tiles larger footprint would otherwise loaded next frame thus extended footprint saves many critical loadings tiles loaded actually prefetched presence critical correct rendering current frame mechanism found efficient treat fast changes camera much one entire field view per second pitch 32p 16p 8p 4p 2p 146 110 54 25 11 036 table 1 frames per second fps generated pvs function number processors line table shows fps sampled different pitch angles 33 results quantitative results presented table 1 frame generation rate pvs measured three different angles different numbers processors rates accelerated prp achieve steady frame rate per second however numbers learn performance algorithm first linear speed achieved numbers imply doubling number processors frame generation rate doubled one processor dedicated master processor second observation dependency performance pitch angle pitch angle gets smaller frame generation rate decreases small pitch angles frame footprint extends however since use hierarchy size footprint bounded noted speed quality tradeoff scaling pixeltovoxel ratio possible speed frame generation rate voxels used scaled footprint sizes voxelwise decrease course pixeltovoxel ratio increases voxels oversampled image blurred however ratio used tool tune quality image frame generation rate guaranteed prp typical database consists large terrain tens target areas global terrain 1 meter resolution playground 55x80 square kilo meters 45giga voxels voxel four bytes thus size global terrain 176 gigabytes adding hierarchy requires third 59g thus 235g bytes total target area consists three levels detail 25x25 square kilometers 05 meter resolution 125 125 square kilometers 025 meter resolution 625 625 square meters 125 centimeters highest resolution single target area database size bytes hierarchy needed coarser levels given global terrain assuming example 40 target areas require 12g bytes total 35g bytes needed terrain data 3d objects consume space typical object requires 15m bytes mention true colors needed grey levels database would almost double size 4 post rendering processor images generated pvs asynchronous since rate dependent viewing direction frames created rate 1015hz images ntsc video signal produced image fields evenodd ntsc rows transmitted rate interlaced fields contain last frame generated pvs human eye would detect jumps every time frame changed achieve smooth sequence images irritate eye necessary generate frames synchronous rate idea simulate small changes camera position 2d transformations applied last frame available however unlike interpolation method 2 image needs extrapolated image digitally warped fly respect flying trajectories warping done using machine maxvideo serves post rendering processor also used 2d functions automatic gain control agc filtering scaling rolling image emphasized interpolating available frames possible since would cause small critical latency acceptable realtime systems realtime feedback vital extrapolated images may minor differences next real frame however since flying trajectories known relatively smooth transition extrapolated frame real frame smooth since warping function might mapped back point outside source frame real frames slightly larger include margins margins relatively small since flying trajectories smooth recalling real images created rate 1015hz given image generated camera position goal warp image approximates image b would generated new camera position let us define f function maps b back p point 3d space seen pixel x b pixel x 0 f known pixel color x determined bilinear interpolation x 0 perspective warp function would best however maxvideo supports second degree polynomial warp thus f composed two functions f two second degree polynomials f determine 12 coefficients set 2n 12 equations explicitly defined n control points system 2n equations solved using least squares method 2n equations defined calculating position n points 3d world coordinate camera position b projecting back image space used nine points evenly distributed image plane rendering 3d coordinates terrain point seen nine fixed locations registered denote vector unknown coefficients c j system need solve two sets n equations six variables assuming n larger six least squares solution gives us f x note note also since roll rotation simple 2d transformation implemented directly using maxvideo warper modeling voxelbased objects process known voxelization converts continuous geometry discrete representation 4 many existing models represented polygon mesh approximates real object however photorealistic application photo mapping 9 essential see figure 10 requires warping photograph object matches 3d model applying texture map voxels alternatively sculpting technique figure 10 voxelbased objects houses trees tank employed given set images object known directions one craft shape model peeling away background voxels around projected images start solid box black voxels given image rays cast background pixels back voxels clearing voxels encountered background color repeating process many images view model different direc tions leaves nonbackground voxels shape model process reconstruction projection yields texture mapping inherently projecting nonbackground pixels back towards voxels means ray casting simplified implementation sculpting technique employed use three photographs toy object example three photographs toy scud shown figure 11a three photographs scaled voxel space resolution seen figure 11b stage object separated background pixel achieved color thresholding contour drawn manually around object result sculpting process photomapping images 3d voxelbased textured object rendered arbitrary viewing direction images shown figures 12 14 rendered close object order observe fine details note b figure toy scud three photographs sidefronttop b images scaling voxel space resolution figure 12 voxelized scud three different viewing directions figure 13 three photographs t62 tank figure 14 voxelized t62 three different viewing directions resolution object higher terrain however objects seen distance shown previous images 6 current porting activity development project started 1992 pvs stateof theart since processing power single processor grown factor 10 compared i860 although performance achieved pvs satisfactory clear faster platform allow us deal better higher resolutions objects richer detail portability application permits adoption new parallel shared memory architecture according behavior commercial market using distributed memory machine ruled since application designed shared memory architecture company manufactures shared memory architecture price range pvs silicon graphics inc sgi sgis machines similar architecture pvs exception sgi uses large cache 4 mbytes contrast 16mbytes pvss local memory sgi offers challenge maximum 36 r4400250mhz cpus power challenge maximum cpus power challenge designed floating point applications cpu twice fast applications integer applications r4400 r8000 performance giving challenge double performance power challenge machines store 688 gbytes internally 63 tbytes externally primary results sgi challenge indicate speed 45 times faster pvs scalability remains linear achieved minor changes code used pvs mainly compensate absence local memory 7 final remarks presented discrete ray casting algorithm accelerated ray coherence multiresolution traversal time complexity algorithm proportional number image pixels regarded con stant combination efficient rendering algorithm powerful parallel machine results realtime photorealistic visual flythrough parallel rendering task partitions image space among pvs processor elements putting load scene space stored pvs shared memory due data prefetching wide bandwidth busses linear speedup observed well hardly read write contentions shared memory achieved perfect load balancing overlapping frames noted sequential version rendering algorithm runs well two seconds sgi workstation terrain size fit main memory expected future progress memory bandwidth cpu speed visual flythrough able run realtime advanced sequential workstations acknowledgments work developed tiltan system engineering collaboration ibm israel thanks meir nissimnir built terrain database sylvia kohn built objects developed new ideas process thank stuff ibm helped us along many different ways r reality engine graphics view interpolation image synthesis photorealistic terrain imaging flight simulation 3d scanconversion algorithms linear quadratic objects shaded display digital maps evans sutherland computer corporation hierarchical data structures realtime three dimensional visual simulation visualization system efficient ray tracing method terrain ren dering grid tracing fast ray tracing height fields height distributional distance transform methods height field ray tracing pyramidal parametrics voxelbased tr ctr david cline parris k egbert terrain decimation quadtree morphing ieee transactions visualization computer graphics v7 n1 p6269 january 2001 dan gordon floating column algorithm shaded parallel display function surfaces without patches ieee transactions visualization computer graphics v8 n1 p7691 january 2002 huamin qu ming wan jiafa qin arie kaufman image based rendering stable frame rates proceedings conference visualization 00 p251258 october 2000 salt lake city utah united states omer shibolet daniel cohenor coloring voxelbased objects virtual endoscopy proceedings 1998 ieee symposium volume visualization p1522 october 1920 1998 research triangle park north carolina united states christian henning peter stephenson accelerating ray tracing height fields proceedings 2nd international conference computer graphics interactive techniques australasia south east asia june 1518 2004 singapore boris rabinovich craig gotsman visualization large terrains resourcelimited computing environments proceedings 8th conference visualization 97 p95102 october 1824 1997 phoenix arizona united states arie kadosh daniel cohenor roni yagel tricubic interpolation discrete surfaces binary volumes ieee transactions visualization computer graphics v9 n4 p580586 october baoquan chen j edward swan ii eddy kuo arie kaufman lodsprite technique accelerated terrain rendering proceedings conference visualization 99 celebrating ten years p291298 october 1999 san francisco california united states ming wan nan zhang huamin qu arie e kaufman interactive stereoscopic rendering volumetric environments ieee transactions visualization computer graphics v10 n1 p1528 january 2004 joachim pouderoux jeaneudes marvie adaptive streaming rendering large terrains using strip masks proceedings 3rd international conference computer graphics interactive techniques australasia south east asia november 29december 02 2005 dunedin new zealand david cline parris k egbert interactive display large textures proceedings conference visualization 98 p343350 october 1823 1998 research triangle park north carolina united states brandon lloyd parris egbert horizon occlusion culling realtime rendering hierarchical terrains proceedings conference visualization 02 october 27november 01 2002 boston massachusetts reynald dumont fabio pellacini james ferwerda perceptuallydriven decision theory interactive realistic rendering acm transactions graphics tog v22 n2 p152181 april
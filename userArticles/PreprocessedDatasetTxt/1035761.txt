constraintbased structuring network protocols complexity designing protocols led compositional techniques designing verifying protocols propose technique based notion parallel composition protocols view composite protocol interleaved execution component protocols subject set constraints using constraints building blocks define several constraintbased structures structure combining properties component protocols different way instance component protocols multifunction protocol structured composite protocol performs individual functions concurrently performs one depending order initiation component protocols provide inference rules infer safety liveness properties composite protocol properties derived component protocols others derived structuring mechanism set constraints used combine component protocols b introduction distributed protocols typically complex perform several functions modules performing various functions may interact one another complex manner makes design verification protocols difficult task several formalisms specifying protocols proposed 9 2 14 provide basic operators process synchronization modular design protocols several structuring techniques protocols specified formalisms pro posed structuring techniques follow separation concerns paradigm functionality protocol first decomposed subfunctions protocols various subfunctions designed separately combined using fixed set rules obtain protocol entire problem advantage technique allows designer focus one aspect subfunction time addition certain cases properties composite protocol inferred component protocols sequential composition one structuring technique allows design protocols performing multiple functions sequence 8 7 6 16 13 15 let two protocols p performs first subtask q performs second subtask sequential composition p q requires p execute q site example p performs connection establishment q data transfer protocol p q denotes protocol first establishes connection transfers data sufficient conditions derived infer properties combined protocol example showed component protocols deadlock free properly terminating composite protocol also deadlockfree properly terminating many multifunction protocols several activities may performed concurrently cases combine component protocols execute interleaved manner interact one another refer parallel composition protocols wherein component protocols execute concurrently several formalisms based parallel composition proposed 3 proposed notion superimposition parallel composition basic computation p control protocol q case q observes events p constrains execution example deadlock avoidance protocol superimposed basic computation controls basic computation prevent deadlocks methodology proposed 12 operational constraints form propositions added guards send statements p q constrain execution constraints p may include variables q union construct proposed 5 also allows interleaved execution component protocols without constraints propose technique parallel composition protocols model parallel composition interleaved execution component protocols p q subject set constraints constraints local nature describe interactions p q paper study two types constraints synchronizing inhibiting describe interactions using constraints building blocks define several constraintbased structures combine set component protocols structure combining properties component protocols different way using structures show several existing protocols redesigned modular fashion synchronizing constraint requires certain actions p q synchro nized constraint used combine p q produce multifunction protocol performs functions p q concurrently example problem nprocess mutual exclusion decomposed subproblems enforcing mutual exclusion pair processes using synchronizing constraint combine twoprocess mutual exclusion protocols one pair processes obtain nprocess protocol combining protocol data transfer protocol flow control also design protocol transfer data flow control inhibiting constraint specified processes may require q inhibited initiation p q constraint used inhibit execution one protocol may already executing initiation another protocol inhibiting constraint useful example design multifunction protocols potentially perform functions specified component protocols must perform one example design leader election protocol elect site leader must elect one give set rules infer safety liveness properties composite protocol safety liveness properties composite protocol inferred component protocols whereas inferred structure imposed constraints proof system closely related one 10 projection method verify protocol proposed projection technique already designed protocol decomposed purpose analysis technique viewed inverse projection method example p q composed obtain r projection r variables messages p gives protocol identical p except guards may additional boolean conjuncts show different protocols obtained imposing different constraints set component protocols mentioned sequential composition allows construction multifunction protocols perform functions sequence 15 modeled sequential composition using ordering constraints p q technique proposed paper also views composition terms set constraints allows construction multifunction protocols either perform component functions concurrently performs one together ordering constraint proposed technique used design complex protocols also advocate use technique conjunction stepwise refinement techniques 11 17 first simple protocol maybe inefficient one correct derived using technique refined stepmanner optimize paper organized follows next section present formalism specify protocols section 3 discusses examples section 4 present composition principle section 5 describes properties composite protocols finally conclude section 6 model protocol p set processes model communication channel p p j sequence ch ij messages message form mpara list type message para list list parameters statement j marg list executed p causes marg list appended end ch ij statement mpara list executed p j removes message head ch ij exists message type head channel stores contents message para list execution mpara list blocked exists message type head channel p following normal form 1 init l1 l ena l init initialization action used specify initial values variables therefore assume contain local computation l guarded action l label ena l guard l computation associated action guard ena l form bool l rec l bool l boolean expression rec l receive statement parts optional bool l rec l evaluates true bool l true message indicated rec l received head channel computation l may contain send statements local computation execution alternative statement l1 l ena l gamma l involves evaluating guards action executing action x ena x true statement involves repetitive execution statement figure 1 gives twoprocess mutual exclusion protocol mut j processes j protocol single token circulated processes process holding token enter critical section variable hold ij true holds token variable ext set true wants enter critical section holds token checks whether pending request one exists enters critical section setting true check made check ij set true exiting critical section sets false check ij true holds token critical section sends token j protocol site j similar except initialization section hold set false denote set variables appear p varp denote set messages sent received p messp state p defined values variables varp use predicate initp characterize initial state p predicate reflects assignments made init state channel p p j value ch ij state system tuple states processes represent states channels initial state system state channels empty initp 1 event associated action event occurs computation associated action executed use denote event corresponds true rtoken ij j token gamma hold ij trueenter ij check ij hold ij gamma check ij true ext gamma check ij gamma j token check ij hold ij falserequest ij gamma ext true figure 1 protocol mut j site th execution action assume execution event atomic respect events execution protocol maximal sequence 0 initial state l event e l enabled state g l execution computation associated e l transforms state g l g l1 say reachable g 0 exists sequence em e l transforms state g l g l1 1 l define proposition initiatep follows initiatep initially false becomes true action loop statement p executed informally whether p site initiated since init used specify initial values p considered initiated executes action loop statement also define initiate initiate pn active p initiate pn say p initiator p exists execution p p sends message receiving message informally initiator protocol process start protocol sending messages processes without first receiving message protocol one initiator assertion invariant p true initial state p states reachable initial state define relation follows ff fi execution p iff following holds x ff true g x exists state g x fi holds g ff fi executions p informally ff fi implies ff becomes true fi become true future example ext mut implies wants enter critical section eventually prove properties assume following strong fairness condition action enabled infinitely often execution cannot delayed indefinitely 3 compositional approach let p q two component protocols composite protocol r framework structured set interacting component protocols interactions protocols specified set constraints constraints local nature ie specified processes site therefore r derived processes site p q component protocols r constraints introduce constraints using examples 31 synchronizing constraint synchronizing constraint actions p q requires execution synchronized ie system treats p q single action enabled ena p ena q true synchronizing constraint useful designing protocols performing multiple functions concurrently function may impose different restrictions common actions synchronizing constraints ensure restrictions component protocols satisfied first set example protocols use synchronizing constraints involves problems decomposed subproblems subproblem original problem smaller size example mutual exclusion problem three sites 1 2 3 decomposed three subproblems involving mutual exclusion pair sites figure 1 shows twoprocess mutual exclusion protocol mi j pair j sites threeprocess protocol mut1 2 3 obtained combining m1 2 m1 m2 follows mut1 2 3 want ensure 1 protocol m1 2 maintains 1 2 requiring enter 12 sets 1 true executed receiving permission 2 form token mut1 ensures 1 3 similar way imposing synchronizing constraint enter 12 enter 13 ensure mut1 2 3 enenter 12 enenter 13 true 1 assigned value true maintains invariants similar constraints need enforced sites protocol extended nprocess mutual exclusion protocol another example consider protocol sender sends set data items number receivers synchronized manner sender sends data item receivers receives acknowledgements receivers sends next data item consider corresponding protocol datas ri sender single receiver ri iterative protocol iteration sender sends next data item waits acknowledgement increments next original protocol obtained combining synchronizing action incrementing next shared variable ensures next data item sent acknowledgements received receivers another class multifunction protocols designed using synchronizing constraints consists protocols involve distinct types subproblems consider protocols data f low shown figure 2 protocol data performs function sending sequence data items array sdata11 sender receiver r stores rdata11 data data item sent variable used incremented action send data item ready transmission assume higher layer protocol producing data items sets readyx true placed data item x sdatax protocol f low performs function flow control protocol sends req message r credit whenever credit left receiving req message r sends credit spend incrementing used action spend whenever credit available protocol dataf low performs data transfer flow control obtained executing data f low interleaved manner synchronizing constraint actions spend send action imposes different constraint variable used incremented discussed later used incremented spend send executed result data item sent ready transmission credit available add properties dataf low incremental fashion f low avail 0 used 0 used avail gamma used used data used 0 readyused used used low r grant 0 grant sreqx gamma grant data r next 0 recr sdatay gamma next figure 2 data flow control protocols instance channels may reorder messages dataf low guarantee sdatai guarantee ordered delivery composing low protocol seq ensures ordered delivery messages imposing restrictions array rdata updated receiver site notion superimposition 3 composition mechanism modeled using synchronizing constraint superimposition requires p superimposed q message type q action send ingreceiving q must synchronized action sendingreceiving p since superimposition framework designed reason control protocols synchronization allowed sendingreceiving actions 32 inhibiting constraint inhibiting constraint specified pair p indicates initiation p execution q must inhibited use constraint describe interaction wherein one protocol may inhibit execution another protocol constraint useful deriving several types multifunction protocols shown following examples certain multifunction protocols may require one component protocol explicitly terminate another component protocol example connection management protocol typically performs following two functions connection establishment disconnection disconnection protocol initiated time initiation protocol execution data transfer phase inhibited case site sender receiver initiation process belonging disconnection protocol terminates process belonging connection protocol specify interaction disconnection protocol terminating connection establishment protocol implement p terminates q specifying p inhibits q terminates relation asymmetric one general may allow p q inhibit one another relationship useful designing multifunction protocol perform one possible multiple functions time consider case component protocol single initiator p q initiator site define conf lict relation specifying p q inhibit case initiation one inhibit initiation p q initiators different sites initiated concurrently case specify priority relationship say p priority q q inhibited initiated concurrently implement specifying p inhibits q p j initiator p q inhibits p j thus q initiated first leads initiation q selected execution figure 3 gives threeprocess traversal protocol traverse1 1 initiator network three sites identities 1 2 3 protocol node 1 sends message containing identity 2 3 sets leader 1 true receiving ack message 2 3 protocol performs function electing 1 leader obtain leaderelection protocol combining traverse1 traverse2 traverse3 specifying constraint traversei priority traversej j constraint implements rule traversal initiated node larger identity encounters traversal smaller identity traversal smaller identity inhibited another example consider simple connection establishment protocol sent 1 gamma 2 captureid 1 sent 1 trueelect 1 win 12 gamma leader 1 true recd 21 recd 31 figure 3 3process traversal algorithm initiator site establishes connection j consider composition connect1 2 connect2 1 fullduplex protocol connections allowed directions concurrently designed combining connect1 2 connect2 1 constraints however connection one direction allowed specify connect1 2 priority connect2 1 viceversa initiators different sites case initiate connection establishment time connection 1 2 established 1 consider protocols connect1 2 connect1 3 1 allowed establish connection one site time instance 1 server 2 3 clients server may allowed connect one client time achieve specifying using sequential composition combine resulting protocol get iterative protocol connection established disconnected protocol returns initial state choice available establish connection either direction connect1 2 connect1 conflicting protocols initiators site using combination constraints many complex protocols designed illustrated section set component protocols structured different ways using different set constraints although protocols discussed designed use technique makes design modular helps understanding overall structure protocol aim make disciplined use constraints combine protocols welldefined structures discussed order ensure properties combined using inference rules next section develop framework formalizes restrictions constraints 4 composition principle section give formal definition composition technique discuss algorithm obtaining composite protocol consider composition two component protocols let two component protocols assume p q share messages p q may share variables composite protocol r obtained p q specifying one type constraints synchronizing constraints inhibiting constraints constraints given p q constraints composite protocol involves interleaved execution p q subject specified constraints following section discuss composition using synchronzing constraints inhibiting constraints 41 composition using synchronizing constraint synchronizing constraints specified using set synchp q pair b belonging synchp q specifies actions b subject synchronizing constraint b actions belonging p q respectively section give first give algorithm obtain composite protocol r p q constraints discuss rules infer r p q presenting algorithm define certain restrictions constraints ensure properties component protocols combined using welldefined rules first define notion matching actions actions ap aq p q respectively matching actions update variable actions enter 12 enter 13 computations check 12 true ext 1 1 true ext 1 false check 13 true ext 1 1 true ext 1 false matching denote set actions p q update variable example fenter request 12 request 13 g say p q matching protocols action sharedp q belongs p q exists distinct matching action q p matching function onetoone example protocols mut1 2 mut1 matching since fenter 12 enter 13 g fexit 12 exit 13 g frequest request 13 g matching pairs actions say action p belongs synchp q b 2 synchp q action b q require following restriction must matching every matching pair actions must belong synchp q belongs synchp q ena involve receiving message 2 note addition actions required present restriction s1 additional pairs actions also restrictions given defined match inference rules given folowing possible define ways using constraints associated inference rules less restrictions general imply complex inference rules extreme case allow arbitrary constraints specified provide inference rules would require analysis composite protocol directly 2 since channels shared restriction required ensure deadlock freedom framework assume p q share messages extend framework allow message sharing relax s3 allow action receive shared message case matching action b also involve receiving shared message 411 algorithm generating composite protocols section discusses algorithm obtain composite protocol r p q synchp q constraints implemented several ways instance create control process node superimposed p q enforce constraints following give implementation constraints creates single process r p q constraints a1 initialization action p q respectively initialization action r a2 actions loop statement r obtained follows action p q ffl 62 synchp q ena gamma r ffl let ena gamma c 1 c c 2 action sharedp q b enb gamma 4 matching action ab r ab new label case say action ab obtained fusing actions b derive three process mutual exclusion protocol using protocol figure 1 discussed mut1 2 mut1 matching hence first obtain 0 combining mut1 2 mut1 3 synch set protocol 0 three processes 0 1 obtained combining mut1 mut1 protocols 0 mut2 3 following pairs matching actions enter req belong sharedm also matching combine protocols obtain mut1 2 3 shown figure 4 412 properties composite protocol present rules enable us infer properties composite protocol component protocols let f p set formulas hold 12 true hold 13 rtoken 12 2 token gamma hold 12 truertoken 13 3 token gamma hold 13 check 13 hold 12 hold 13 gamma check 12 true check 13 1 gamma hold 12 check 12 gamma 2 token check 12 hold 12 falsestoken 13 hold 13 check 13 1 gamma 3 token check 13 false hold 13 falserequest 1 gamma ext true figure 4 three process mutual exclusion protocol refer variables varp let ef p set formulas refer variables varp propositions form 2 ch ij message set ef p allow reference number messages channel position message channel let r protocol obtained combining p q synchp q following lemma allows us infer invariants r p q condition s1 update shared variable q p made p q ready make update hence updates shared variables made consistent manner lemma 41 2 ef p invariant p invariant r know invariant mut j corresponding invariants mut1 2 mut2 using lemma 41 infer 8i invariant mut1 2 3 use shared variables invariants relating variables p q also inferred example protocol low grant next implies receiver never receives data item granted permission inferred invariant grant used invariant f low used next invariant data invariants inferred constraints imposed lemma 42 reflects nature structure imposed synchronizing constraint let occure proposition true event e occurred defined earlier refers th execution action lemma 42 b 2 synchp q ff occura invariant p invariant q ff fi invariant r example mut1 2 3 let recd1 2 sent1 3 auxiliary variables indicating number times 1 received token 2 number times 1 sent token 3 recd1 12 invariant mut1 2 since 1 token initially occurenter x invariant mut1 3 hence recd1 invariant mut1 2 3 used show mut1 2 3 process sends tokens ready send one addition invariants design proof rules general safety properties example p satisfies ff unless fi execution ff true g either ff remains true subsequent states exists ff true g k true g j ff unless fi p ff fi 2 ef p ff unless fi r informally follows fact state g k belongs q cannot invalidate ff cannot refer variables ff e k since invalidate ff e k cannot invalidate ff discuss liveness properties first give set proof rules infer liveness properties protocol following let fffg ffig mean ff true execution fi true execution ff fi via p following holds invariant p 2 fffg ffig 3 actions b fff enbg b fff fig ff fi p one following true invariant action p set formulas 8b 2 disjunction formulas let firstch ij denote message head channel ch ij protocol p free unspecified receptions exist reachable state g state g j firstch ij action p j receives enabled g p free unspecified receptions message ch ij communication channels need ensure r free unspecified receptions restriction s3 following lemma lemma 43 p q free unspecified receptions r free unspecified receptions following assume r free unspecified receptions give inference rules derive liveness properties r lemma 44 ff fi via p ff fi 2 ef p synchp q ff fi r say local p derivation involve application rule l1 action synchp q corollary lemma 44 corollary 41 ff fi local p ff fi r combining mut1 2 mut1 3 example hold 21 check 21 hold 12 local mut1 2 therefore holds composite protocol 0 consider case b belongs synchp q ff fi via c action obtained fusing b assume ff holds r state g ena holds g show c eventually executed enb must become true since thus following lemma lemma 45 b 2 synchp q ff fi via p ena ff enb r invariant r ff fi r consider flow control protocol shown figure 2 know readyy data infer property low follows infer used invariant lemma 42 following invariants invaraint f low using rule l1 used avail used local f low used composite protocol rule l4 used used lemma 45 readyy holds composite protocol special cases identified checking c always executed irre spective ff example show b 2 synchp q p implies ff fi r instance shown following class compositions let iterative protocols p 1 executing actions executing actions iteration p 2 q 2 similar synchp example would satisfy given restrictions synchronizing constraints must respect cyclic order condition generalized iterative protocols two processes 42 composition using inhibiting constraint discuss composition using inhibiting constraint require inhibiting constraints specified using set inhibitp q consists pairs processes p belongs inhibitp q initiation p inhibits initiatep becomes true action q execute require inhibitp q satisfy following restrictions use inhibition constraint specify terminate priority conflict relations define relation dominates follows p q belongs dominates p terminates q p priority q require dominates relation acyclic 421 algorithm generating composite protocols use following rules derive composite process r p q b1 let initialization actions p q p q respectively introduce two new variables enable p enable q initialization action r b2 actions loop statement r obtained follows let action p first apply rule modify action apply b modify rules applied modify actions q p modified ena gamma false else modified b q modified adding enable p conjunct guard addition involves command new action new enable p introduced r new new label optimization rule b2 first action loop statement executed p known need add enable q false action section 3 discussed derivation threeprocess leader election protocol combining traversal protocols protocol constructed algorithm using constraint discussed section 32 shown figure 5 422 properties composite protocol inhibitp q nonempty shared variables allowed however case protocol inhibited additional actions added modify channel contentsm therefore invariants referring channel contents may preserved hence following lemma lemma 46 inhibitp q nonempty 2 f p invariant p invariant r using lemma 46 infer leader recd 21 recd 31 invariant leader election protocol fact invariant traverse 1 lemma 46 refined special cases example 2 ef p invariant p terminates q p priority q p q conflict initiate p invariant r intuitively initiate p implies p inhibit q therefore execution p impacted q hence invariants referring channel contents preserved 1 gamma sent 12 sent 12 gamma 2 captureid 1 sent 12 sent 13 gamma 3 captureid 1 sent 13 win 12 gamma leader 1 figure 5 three process election algorithm recall initiate p true execution p initiated initiators active p true processes p initiated let enable enable pn definitions initiate p active p false intial state stable predicates become true remain true hand enable p true initial state stable enable p assigned false q lemma 47 p terminates q initiate p invariant r b p priority q initiate p invariant r c p q conflict initiate p invariant r corollary 42 ff initiate p fi active q invariants p q respectively ff 2 f p fi 2 f q p priority q p conflict ff invariant r consider leader election protocol discussed earlier know leader 1 active raverse1 leader 2 initiate raverse2 invariants traverse1 traverse2 respectively since traverse2 priority traverse1 invariant composite protocol similarly using corollary 42 show protocol obtained combining connect1 2 connect2 1 connection established one direction protocol obtained combining connect1 2 connection established either 2 3 since p q share communication channels need ensure r free unspecified receptions additional transitions added rule b2b following lemma lemma 48 p q free unspecified receptions r free unspecified receptions consider case inhibitp q nonempty initially protocols enabled exists pair q p possible ff becomes true p inhibited fi never becomes true fore general state exists pair q ff fi p ff enable p fi r however may sufficient infer interesting liveness properties r following lemma exploits properties inhibition constraint infer additional liveness properties lemma 49 let ff fi p ff fi 2 ef p p terminates q p priority q p q conflict ff initiate p fi q priority active corollary 43 true fi p p true fi q q inhibitp q empty true application corollary 43 consider composition traverse1 traverse2 since true leader 2 traverse2 true leader 1 traverse1 corollary 43 infer true composite protocol using lemma 49 also show true active p p true active q q p priority q p q conflict true active p phi active q r reflects nature composition dictates one becomes active 5 conclusion presented framework compose protocols using synchronizing inhibiting constraints synchronizing constraints allow derivation multifunction protocols perform component functions concurrently inhibiting constraint used design multifunction protocols perform one component functions demonstrated use constraints designing several protocols presented set rules infer safety liveness properties composite protocol 15 modeled sequential composition set protocols executing ordering constraints proposed formalism views composite protocol concurrent execution component protocols subject set constraints future work involve development unified formalism allows ordering synchronizing inhibiting constraints find many composite protocols require combination constraints instance ordering synchronizing constraints two protocols several types control protocols structured using inhibiting constraint example consider snapshot protocol 4 recording global states typically initiated whenever change network state observed node dynamic network snapshot protocol progress node detects change may reinitiate protocol nodes required participate new initiation initiation protocol considered new execution inhibits old execution modeling would require extension framework allow message sharing protocols interacting using inhibiting constraints part future work r two normal forms theorems csp programs finite state description communication protocols compositional approach superimposition distributed snapshots determining global states distributed systems parallel program design decomposition method analysis design finite state protocols discipline constructing multiphase communicating protocols decomposition distributed programs communication closed layers communicating sequential processes methodology constructing communication protocols multiple concurrent functions improved method constructing multiphase communications protocols hierarchical correctness proofs distributed algo rithms construction multiphase protocols designing distributed algorithms means formal sequentially phased reasoning latticestructured proof technique applied minimum spanning tree algorithm tr hierarchical correctness proofs distributed algorithms compositional approach superimposition relational notation state transition systems discipline constructing multiphase communication protocols distributed snapshots communicating sequential processes improved method constructing multiphase communications protocols designing distributed algorithms means formal sequentially phased reasoning extended abstract decomposition method analysis design finite state protocols
agebased garbage collection modern generational garbage collectors look garbage among young objects high mortality however objects include youngest objects clearly still live introduce new garbage collection algorithms called agebased postpone consideration youngest objects collecting less whole heap requires write barrier mechanisms track pointers collected region describe new efficient write barrier implementation works agebased traditional generational collectors compare several collectors configurations program behavior use accurate simulator models heap objects pointers among model cache memory effects objectoriented languages results demonstrate olderfirst collector collects older objects youngest ones copies average much less data generational collectors results also show olderfirst collector track pointers combined cost copying pointer tracking still favors olderfirst generational collector many cases importantly reopen consideration question heap policies copying collectors achieve best performance b introduction dynamic memory management management heapallocated ob jects using garbage collection become part mainstream computing advent java language uses requires work supported part nsf grant iri9632284 gifts compaq corp sun microsystems hewlettpackard kathryn c kinley supported nsf career award ccr 9624209 opinions findings conclusions recommendations expressed material authors necessarily reflect views national science foundation sponsors appear oopsla99 denver november 1999 garbage collection wider use garbage collection makes important ensure fast garbage collection investigated decades varying contexts functional objectoriented language implementation eg lisp ml smalltalk consensus uniprocessor systems operating within main memory class algorithms known generational copying collection performs quite well situations breadth variation within class considerable algorithms common objects grouped according age time elapsed since object allocation younger groups generations examined often older ones particular recently allocated objects collected first paper present new copying collection algorithm called olderfirst maintains grouping age chooses collect older objects following particular policy describe section 2 algorithm achieves lower total cost sometimes dramatically traditional copying generational collection number java smalltalk programs improve performance let us consider costs copying garbage collection imposes runtime system first cost copying objects survive collection second allow collector examine portion heap time bookkeeping actions must log changes pointers references go one portion call pointertracking pointertracking interleaved program execution whenever program writes pointer ie write barrier done garbage collection time third program garbage collection algo rithms different cache memory behaviors interact complex ways effects beyond scope paper left future work paper total cost collection refers combined cost pointer tracking copying collection generational copying collection performs better non generational ie full heap copying collection achieves markedly lower copying costs hand must incur cost pointer tracking whereas nongenerational collection need track pointers always examines entire heap thus generational collection incurs pointertracking cost offset much reduced copying cost discovered tradeoff copying pointertracking costs exploited beyond generational copying collection olderfirst algorithm usually incurs much higher pointertracking costs generational algorithms also enjoys much lower copying costs find pointer stores objects point among youngest objects moving collected region outside youngest objects must track pointers however lowers copying costs gives objects time die collect youngest objects clearly time die balance total cost usually lower total cost generational copying collection cases factor 4 promising importantly success reveals potential flexible collection policies exploit tradeoff improve garbage collection performance section 2 describe new collection algorithm within broader classification agebased algorithms present benchmark suite section 3 assess copying performance family agebased collectors section 4 consider implementation issues including new fast write barrier section 5 section 6 evaluates combined costs copying pointertracking results call reevaluation premises explanations observed performance copying collectors subject section 7 upon garbage collection scheme consider partitions heap two regions collected region c collector examines objects liveness live survive collec tion uncollected remainder region u collector assumes objects live examine non generational collector degenerate case uncollected region empty collector partitions set c set survivor objects set garbage objects g computing root pointers c closure pointsto relation within c make freed space conveniently available future allocation collector manipulates survivors copying compacting amount work involved first approximation proportional amount survivor data minimized ideally choose c empty absence ora cle must look schemes organize heap objects partition c u trivial find heuristics make small restrict attention class schemes keep objects linear order according age imagine objects heap arranged left right oldest left youngest right figure 1 region collected c restricted contiguous subsequence sequence heap objects thus cost initial partition practically nil call schemes agebased collection traditional generational collection schemes main age based region collected subsequence youngest recently allocated objects copying collectors may reorder objects somewhat copying since typically follow pointers breadthfirst instead age order compacting collectors reordering occur paper introduce categorize alternative collection schemes according choice objects collection collectors fix size collected region rather allowing vary program execution simplify analysis previous research shows dynamically sizing collected region improve performance 29 36 34 1 5 investigation beyond scope paper youngestonly yo collector always chooses youngest rightmost subsequence sequence heap objects figure 2 implementation yo collector fills entire heap repeatedly collects youngest portion heap including objects surviving last collection time allocation collections amount yo collector frees collector might good performance object death mainly among new objects generational collector schemes variants youngestonly col lection differing however trigger collections 5 basic design 17 p147 new allocation one fixedsize part heap nursery remainder reserved older objects oldest youngest allocation direction figure 1 viewing heap ageordered list jcj collected region u regions collected region survivors area freed new allocation legend figures 25 youngest collection 1 u u collection 2 oldest figure 2 youngestonly yo collection reserve reserve youngest collection 1 u collection 2 reserve nursery older generation oldest reserve reserve put freed u freed freed oldest oldest full heap figure 3 generational youngestonly collection older generation whenever nursery fills collected survivors promoted older generation figure 3 older generation fills following collection collects together nursery twogeneration collector collection considers entire heap note generational collector deliberately allocate directly space reserved older generations unlike yo region chosen collection contains exactly objects allocated since last collection except full heap collec tions study two three generation schemes 2g 2 genera tions youngestonly 3g assume size generation strictly greater 0 therefore 3g never degenerates 2g 1 oldestonly oo collector always chooses oldest leftmost subsequence sequence heap objects figure 4 imple mentation oo collector initially waits entire heap fill repeatedly examines oldest objects including surviving previous collection yo collector resulting free amount available allocation object likely dead longer wait hence oo collector might good performance course suffer objects survive entire length program copy repeatedly olderfirst collector chooses middle subsequence heap objects immediately right survivors previous collection figure 5 thus region collection sweeps heap rightwards window collection resulting free blocks memory move nursery initially objects fill entire heap window positioned oldest end heap collecting youngest right end heap window reset left old end intuition potentially good performance collector gleaned diagram figure 6 shows series eight collections indicates window collection moves across heap collector performing well window position results small survivor sets collections 48 window moves small amount one collection next remaining window size freed becomes available allocation window continues move slowly remains long time region corresponding age objects great deal allocation takes place without many objects copied almost window size successive collections long window remains good position long takes find sweet spot leaves determine performance collector particular workload heap size window size refer oo yo collectively fc collectors collection window base point comparisons nongenerational collector ng considers entire heap collection note possible fc collector find garbage collected region happens let collector fail purposes study implementation could increase heap size temporarily retry collection another region perhaps whole heap increase window size adaptively generational schemes design occasionally consider whole heap enjoy advantage new schemes simulated table lists benchmarks include smalltalk java programs basic properties relevant garbage collection perfor mance amount data allocated words word 4 bytes number objects allocated maximum live amount also also examined scheme older generation allowed grow nursery vice versa 1 performed similarly 2g 3g oldest youngest u collection 1 collection 2 figure 4 oldestonly collection youngest u u collection 2 oldest u collection 3 u c figure 5 olderfirst collection collection 1 collection 2 collection 4 collection 5 collection 6 collection 7 collection 8 collection 3 oldest youngest figure olderfirst window motion example pointer stores benchmark words alloc objects alloc max live total allocst nonnull java bloatbloat 37 364 458 3 429 007 202 435 4 927 497 758 4 376 798 888 toba 38 897 724 4 168 057 290 276 3 027 982 1285 2 944 672 972 standardnoninteractive 204 954 treereplacebinary 209 600 treereplacerandom 925 236 189 549 13 114 168 513 549 140 029 831 richards 4 400 543 652 954 1 498 763 626 576 611 767 801 table 1 benchmark properties minimum required heap size execute program total number pointer stores words allocation per pointer store number nonnull pointer stores percentage pointer stores nonnull describe individual benchmarks providing possible details structure set java programs follows ffl javabytemark port bytemark benchmarks java byte magazine website ffl bloatbloat program bloat version 06 21 analyzing optimizing class files distribution ffl toba javabytecodetoc translator toba working pizza 22 class files 23 set smalltalk programs follows ffl standardnoninteractive subset standard sequence tests specified smalltalk80 image 12 comprising tests basic functionality ffl heapsim program simulate behavior garbagecollected heap unlike simplest tools used study however instructed simulate heap object lifetimes follow synthetic exponential distribution consequently objects simulator exhibit highly synthetic behavior ffl lambdafact5 lambdafact6 untyped lambdacalculus interpreter evaluating expressions 5 6 standard church numerals encoding 4 p140 previously used ref 15 used input sizes explore effects scale ffl swim spec95 benchmark translated smalltalk authors shallow water model square grid ffl tomcatv spec95 benchmark translated smalltalk authors meshgeneration program treereplacebinary synthetic program builds large binary tree repeatedly replaces randomly chosen subtrees fixed height newly built subtrees benchmark named destroy ref 15 14 treereplacerandom variant replaces subtrees randomly chosen heights ffl richards wellknown operatingsystem eventdriven simulation benchmark previously used ref 15 idea olderfirst collection sufficiently diverges established practice instructive first determine whether feasible principle going details implemen tation understanding pointertracking costs likely higher olderfirst collection generational collection sought quick estimate copying cost discover promise figure 6 delivered actual programs built objectlevel simulator executes actions collectors exactly depicted figures 25 simulator much simpler actual implementation objects collection windows arbitrary sizes allowed age order perfectly preserved collection pointers tracked simulator produce statistics amount data copied run program divided amount allocated gives markcons ratio traditionally used firstorder measure garbage collector performance discuss copying cost estimate results two java benchmarks javabytemark bloatbloat summarize make general observations figures 7 8 present two graphs graph compares best performance collection scheme oo yo 2g 3g plotting markcons ratio copying cost would like minimize relative ng heap size performance depends heap size available collector laid along horizontal axis heap size simulated many configurations collection scheme graph includes best configuration collector graph b provides details different configurations collector one representative heap size plotting relative markcons ratio size collected region nursery fraction heap size javabytemark program scheme copies significantly less data schemes configurations fact copies factor 10 fewer objects 3g collector see figure 7b attains performance even keeping window collection small 20 total heap size smaller heaps shown best window size grows 40 heap generational collectors figure 7b approach best configurations nursery constitutes 50 heap thus scheme copies much less using smaller window size small window sizes desirable contribute keeping pause times collection short especially important interactive programs reason dramatic reduction copying cost exactly scenario described figure 6 many objects wait middle age die collector able find die 100000150000 200000250000300000 350000400000 markcons ratio best configuration relative heap size words javabytemark oo yo markcons ratio relative fraction collected total heap size 238885 javabytemark oo yo b representative heap size figure 7 copying cost estimates javabytemark02061 400000 600000 800000 1e06 markcons ratio best configuration relative heap size words bloatbloat oo yo markcons ratio relative fraction collected g total heap size 446984 bloatbloat oo yo b representative heap size figure 8 copying cost estimates bloatbloat stay sweet spot long time collector occasionally sweep heap result revisits oldest objects repeatedly examine lifetimes objects program 25 find number long lived objects thus collector repeatedly copying objects whereas generational collectors design rarely copy objects nevertheless copies factor 10 less data trend benchmarks collection outperforms oo yo collection achieves similarly low copying costs also integer factors better generational collectors using small window size standardnoninteractive heapsim richards lambdafact6 lambdafact5 bloatbloat figure 8a illustrates best configurations 2g 3g exhibit comparable low copying cost fur thermore figure 8b shows 3 collectors achieve close minimums window size around 40 entire heap collector simulated study fails window size 20 longlived data spans collection window 25 results representative remaining 8 programs comparing 2g 3g collection figure 8a b reveals significant differences best configurations many configurations 3g collector perform worse sometimes much worse 2g collector 41 comparing 2 3 generations several programs follow trend see figure 7a javabytemark 3g copies fewer objects 2g jav abytemark program suite 3g collector enjoys largest advantage 2g collector detailed presentation figure 7b reveals however many configurations 3g collector 2g collector outperforms trend true programs well demonstrates difficulty configuring generations well remaining 9 programs toba bloatbloat lambdafact5 lambdafact6 heapsim swim tomcatv treereplacebinary treereplacerandom 2g collector copies amount less 3g collector 42 comparing fc collectors demonstrated javabytemark bloatbloat collector usually copies significantly less data oo yo collec tors however programs oo collector performs best treereplacerandom treereplacebinary programs little longlived data 25 random replacement random subtrees interior node connected leaves binary tree indeed imply longer collector waits likely object garbage however synthetic programs probably representative behaviors users programs programs longlived data 10 43 conclusion copying cost estimates show great promise olderfirst algorithm set benchmarks therefore consider issues involved actual implementation proceed evaluation prototype simplify investigation presenta tion focus twogeneration collector 2g since found usually comparable threegeneration one olderfirst algorithm collection reduces copying costs may increase write barrier costs potential increase prompted us consider carefully pointer stores need remembered prototype imple mentation generational collectors remember pointers older younger generations within generations thus stores youngest generation including objects allocated nursery never need remembered corresponding rule collection based following observation store creates reference p q need remember q might collected p figure 9 shows diagrammatically pointers collector must remember according direction different regions heap example pointer store creates pointer theta theta q need remembered object theta necessarily fall collected region earlier theta q oldest region next collection youngest allocation direction figure 9 directional filtering pointer stores crossedout pointers need remembered allocation copying youngest oldest region next collection high addresses low addresses figure 10 directional filtering addressordered heap first glance would appear complex expensive filtering suggested figure 9 although flexible generational collectors 15 however reorder regions heap physically shown figure 10 test simpler still need test store creates pointer particular direction possibly crossing region boundary large zone virtual address space set aside allocation higher addresses lower collection region also moves higher addresses lower lags behind allocation survivors evacuated next similarly sized zone lower addresses collection region catches allocation equivalent reaching right end logical layout figure 9 former allocation zone leased former copying zone becomes allocation zone new copying zone acquired organization figure 10 especially attractive large address space cooperation operating system acquire release address space heap progresses higher lower addresses implementation based allocating fixedsize blocks various heap regions collector constrained collect integral number blocks structure block table simply quickly maps addresses remembered sets since block size power two blocks aligned block size collection window moves higher lower addresses essentially test p q p q mask remember p qs remset adjusting one pointers using mask eliminates stores within block test important since vast majority stores nearby objects thus tend cross block boundaries 25 directional test also reduces number pointers remembered write barrier filters stores inline outofline code remember pointer executed crossblock pointers source block pointer may collected target block test also filters stores null pointers essence treating null pointer value 0 referring object never collected without need additional explicit test assuming p q registers mask fits immediate field instruction sequence requires three instructions mask compare conditional branch alpha processor indeed obtain sequence sparc requires additional instruction construct mask since immediate fields small reasonable block sizes one dedicate register hold mask thereby reduce sequence three instructions slow path remember pointer write barrier consists following determine target objects block shift address right index block table base register load pointer blocks remembered set decrement remembered set pointer check underflow explained moment save pointer remembered store decremented remembered set pointer back block table organize blocks genera tions generational collector remembered set linked list chunks chunk holds 15 remembered pointers sequential memory addresses allocate chunks aligned memory boundaries underflow test consists checking low bits remembered set pointer 0 garbage collection requires space overhead auxiliary data structures pointer remembering since evaluation time overhead respect given heap size fair comparison different collectors requires space allowed collector ordinary data diminished amount needed auxiliary data difficult priori study collectors greater space overhead 2g pointer filtering less efficient however measured space overhead suite benchmarks 1 heap sizetherefore consequent time overheads negligible 6 evaluating total collection costs evaluate proposed collection algorithm write barrier benchmark suite using combination simulation prototyp ing obtained heap traces described detail program runs smalltalk java virtual machine traces independent storage management scheme system collected collection algorithm study process traces using driver routine performs relevant actions object allocation mutation objects heap actual implementation particular collection algorithm manages heap implementation obtain exact counts various relevant quantities number objects copied number bytes copied write barrier actions use estimate execution times 61 obtaining counts volumes describe detail obtained counts volumes report results traces traces indicate object allocation size object update pointer field heap object object death object dies ceases reachable object death precisein tracing system perform complete garbage collection immediately object allocation note trace objects died since previous allo cation tracing technique timeconsuming mean present traces actual collection algorithm observe exactly collection behavior would obtained corresponding program without running program driver driver routine straightforward concept simply reads obeys trace record taking appropriate action prototype heap implementation key difference driver live program since traces include manipulations local global variables driver keeps table side live objects driver processes object death record deletes corresponding object table live ob jects point view collector driver thus differs live program objects referred directly rather reached via objects prototype heap implementations write barriers heap implementations share common infrastructure heap consists collection blocks aligned 2 k byte portions memory varied block size experiments heap also remembered set data structures write barriers appropriate heap example generational heap uses generational comparison whereas heap uses sameblock directional filtering note implementations highly instrumented tell many pointer stores go filtering path write barrier likewise collector cores highly instrumented obtain accurate counts copying actions obtain wallclock timings prototype heap implementations 62 estimating execution times pending complete implementation carefully implemented write barriers actions timed code fragments advantages ie execute tight loops important quantities registers argue ratio timings gives reasonable orderofmagnitude estimate ratio would expect actual implementation even though absolute values timings optimistic used 292 mhz alpha 21164 took cycle count measurement running piece code without fragment wished measure many iterations loop taking difference times dividing clock period write barrier depending details loop embedded barrier fast path took 1 2 3 cycles expected since original sequence 3 instructions alpha issue width 4 ie alignment matters use 2 cycles estimates remembering pointer slow path write barrier takes average 11 cycles including original test time needed chunk management overflow finally fetch remembered set entry examine target object possibly start copy object takes 13 cycles average thus total cost create process remembered set entry exclusive copying target object 24 cycles copying timing object copying involves simply copying bytes one place another one must also decode object header determine fields object contain pointers handle one pointers thus accomplishing transitive closure pointsto relation breadthfirst manner 9 since prototype heaps slightly simplified actual language implementations ie deal special cases arise java finalization locks comparisons likely underestimate copying cost thus underestimate benefits modelled total copying collection processing costs using equation costs per occurrence case n number times case occurs subscript obj concerns number objects processed w number words copied skp number pointer fields skipped null point collected region dup number pointers collected region objects already copied note encounter pointer object collected region yet copied charge cost discovery copying object measured following values operation data structures primary cache cycles cycles aside note costs indicate copying words large component cost processing pointerrich objects given instrumentation gather counts n well number times different write barrier actions occur careful estimates times various collector write barrier operations project cycle costs collection algorithm previously mentioned would claim difference predicted cycle counts would exactly match practice ratios predicted cycle costs would reliable order magni tude put another way predict ratio collection costs 21 would surprising implementation showed inversion costs schemes 63 results applied blockbased evaluator benchmark suite examine resulting evaluation olderfirst generational collectors detailed cost model described takes account copying pointertracking costs similar markcons ratio plots examined section 4 plots total cost figures 1122 show lowest total cost collector achieve among examined configurations given heap size minimum heap size equals maximum amount live data evaluated heap sizes range 2 6 times min imum pointer costs work favor 2g collector diminish advantages enjoyed estimate copying costs section 4 nevertheless succeed changing qualitative relationship observed previously one subset benchmarks javabytemark standardnoninteractive heapsim lambdafact5 lambdafact6richards collector clear advantage except small heap sizes remaining benchmarks performance two collectors similar 2e06 200000 250000 300000 350000 400000 total cost cycles estimated heap size words javabytemark figure 11 total collection cost javabytemark5e0715e0825e08 200000 400000 600000 800000 1e06 12e06 total cost cycles estimated heap size words bloatbloat figure 12 total collection cost bloatbloat5e0715e08500000 1e06 15e06 total cost cycles estimated heap size words toba figure 13 total collection cost toba2000006000001e062000 3000 4000 5000 6000 7000 8000 total cost cycles estimated heap size words standardnoninteractive figure 14 total collection cost standardnoninteractive2e076e071e08100000 200000 300000 400000 500000 600000 total cost cycles estimated heap size words figure 15 total collection cost heapsim1e063e065e067e069e06 5000 10000 15000 20000 25000 30000 35000 40000 total cost cycles estimated heap size words figure total collection cost lambdafact5 15e0725e0710000 20000 30000 40000 50000 60000 70000 80000 90000 total cost cycles estimated heap size words figure 17 total collection cost lambdafact65e0615e0725e0735e0745e07 20000 40000 60000 80000 100000 total cost cycles estimated heap size words figure total collection cost swim5e0615e0725e07 total cost cycles estimated heap size words tomcatv figure 19 total collection cost tomcatv1e063e065e067e069e06 10000 20000 30000 40000 50000 60000 total cost cycles estimated heap size words treereplacebinary figure 20 total collection cost treereplacebinary5e0615e0725e0720000 30000 40000 50000 60000 70000 80000 90000 total cost cycles estimated heap size words treereplacerandom figure 21 total collection cost treereplacerandom1e073e075e072000 3000 4000 5000 6000 7000 8000 9000 10000 total cost cycles estimated heap size words richards figure 22 total collection cost richards 7 discussion comparing collectors straightforward comparison 2g collectors shows achieves lower total costs many cases main contributing factor reduction copying cost supporting factor containment increase pointer tracking cost copying costs markedly lower generational collection collector scavenges areas youngest perplexing light widely recognized good performance generational collectors nevertheless entirely accord intuition youngest objects live collect wasteful generational collection tension need increase size nursery reduce wasteful copying young objects need increase size older generations collected frequentlya tension cannot resolved heap finite size contrast olderfirst collection able focus age range wasteful copying minimized results good performance programs range prominently exists whereas diagram figure 6 shows desirable behavior may arise tempting consider designer could encourage example improvements may achieved dynamically adaptively choosing size collection window ambitiously looking window motion policies sophisticated one described pointer tracking everincreasing latitude collection policy may reduce copying costs generational collection simple olderfirst scheme also necessary keep pointertracking costs within reason pointertracking costs albeit high respect generational collection excessive window motion policy allows efficient pointer filtering blockbased collector apply filter ignore pointer stores cross block boundaries found filter eliminate 60 stores reasonable configurations note blocks cannot arbitrarily large lest collector degenerate nongenerational one directional filtering figure 9 ignores 95 stores many generational filtering ignores 99 enough cost remaining remembered stores substantially offset copying cost reduction developed directional filtering scheme collected statistics pointer stores according position ageordered heap pointer source target ie object containing reference referent object shed new light longheld beliefs pointer structure heaps widely assumed pointers tend point younger objects older ones belief surely justified functional pro grams generally true objectoriented programs ex amined youngertoolder oldertoyounger directions well represented neither dominant benchmarks supposed predominance youngertoolder pointers often cited cause justification efficacy generational pointer filter ing faithful explanation arises observations pointer stores objects young install pointers target objects also young whether relatively younger older source generational filter ignores stores objects generation figure provides example bloatbloat oldertoyounger pointers negative age distances account 40 stores ever histogram source positions b well target positions c show stores establish pointers young objects caching memory effects since copying collectors touch live data leave untouched newly dead objects collectors copy less also good locality however visits entire heap regularly compared generational collectors02061 cumulative probability log2absdistance sgndistance bloatbloat distribution pointer age distances50000015e0625e0635e060 20000 40000 60000 80000 100000 120000 140000 histogram source position bloatbloat b distribution pointer source ages50000015e0625e0635e06 histogram target position bloatbloat c distribution pointer target ages figure 23 pointer store heap position bloatbloat may decrease locality cache increase paging activity clearly study effects context complete implementation future work overwhelming consensus studies generational garbage collection youngerfirst discipline used ie collector decides examine one generation must time examine younger generations scheme introduce may understood ignore policy details similar requiring older generation collected apart younger ones possibility indeed mentioned dismissed wil sons survey garbage collection 32 p 36 jones lins monograph 17 p151 two accessible sources state art uniprocessor garbage collection generational garbage collection employs fixed boundaries generations order minimize pointertracking effort needed boundary barrett zorn explored possibility using flexible generation boundaries remaining however within youngestfirst discipline found increase pointertracking effort need excessive 5 scheme uses flexible collection region boundaries combine efficient mechanisms keep pointertracking costs check even without youngestfirst discipline clinger hansen proposed collector scheme base collection decisions object age rather time elapsed since last collection 11 focuses objects time longest historical precursors idea 2 18 6 although algorithm agebased prompted us investigate similarly flexible agebased ones context objectoriented languages examined found latter superior generally schemes suggested divide heap regions necessarily agebased collected independently andor incrementally bishop proposed segregation accordance usage objects 8 hudson mosss mature object space algorithm managing verylonglived data introduced policies approximate ageorder criterion 16 garbage collection inherent tradeoff space time overheads tradeoff reducing total time overhead reducing time single collection incremental operation different authors applied different measures system evaluation focus time overhead collection within given space constraints therefore without making specific comparisons difficult evaluation metrics well underlying languages widely different recognize study draws previous experience generational garbage collection implementations 19 27 20 24 28 35 policies 29 30 31 34 1 13 write barrier mechanisms 33 15 14 evaluation respect object allocation lifetime behavior 3 26 11 achieving performance improvements generational collection critically depends setting adapting configuration parameters rightincorrectly chosen generation sizes cause performance degrade severely confirmed matters observations multigenerational collectors benchmark traces choosing good regime generations easy task yet fully understood despite numerous studies 29 36 34 1 5 however also say matter tuning performance within class youngestonly collection schemes goal study examine tune particular scheme instead compare schemes whether optimal configurations chosen priori system might adaptively arrive questions separate investigation 9 generational collection achieves good performance considering portion heap collection achieves good performance even imposing additional costs mutator namely write barrier track pointers older younger gen erations found reduce copying costs many cases dramatically including youngest objects col lection call general scheme agebased collection since still determines objects collect based age considered detail particular agebased algorithm term older first found never needed copy substantially data generational collection copied ten times less programs require write barrier work generational collection perhaps ten times savings copying outweigh extra pointer tracking costs obtained results exact heap contents simulation prototype collector implementation careful timing crucial code fragments given factor outperforms generational collectionoften factor 2 moreit also perform well actual implementation integration java virtual machine progress improved performance one measure significance work also feel contributes substantially understanding memory usage garbage collector behavior put another way garbage collection long tradition study yet shown widely accepted state art generational col lection leaves considerable room improvement also question widely held beliefs generational collection offering new intuition clearly agree tenet one wait objects die collecting recognized considerable body work concerning avoidance early tenuring objects show practical avoid copying youngest objects saves much work even though imposes heavier burden running program past write barrier cost thought high permit exploring algorithms like results encouraging consideration wide range new techniques future work include considering window motion al gorithms dynamically changing window size using multiple windows eg one younger objects one mature objects mature object space collection experimentation mea surement programs platforms languages acknowledgements acknowledge gratitude assistance david detlefs java topics group sun microsystems laboratories chelmsford massachusetts collecting providing traces work thank margaret martonosi anonymous referees valuable comments drafts paper r simple generational garbage collection fast allocation list processing realtime serial computer infant mortality generational garbage collec tion lambda calculus syntax se mantics garbage collection using dynamic threatening boundary mali memory realtime garbage collector implementing logic programming languages international workshop memory management st computer systems large address space garbage collection nonrecursive list compacting algorithm generational stack collection profiledriven pretenuring generational garbage collection radioactive decay model key objects garbage collection remembered sets also play cards comparative performance evaluation write barrier implementa tions incremental collection mature objects garbage collection algorithms automatic dynamic memory management incremental incrementally compacting garbage collection garbage collection large lisp system pizza java translating theory practice java applications lifetimebased garbage collector lisp systems generalpurpose computers properties agebased automatic memory reclamation algorithms characterisation object behaviour standard ml new jersey generation scavenging nondisruptive high performance storage reclamation algorithm design evaluation high performance smalltalk system tenuring policies generationbased storage reclamation adaptive tenuring policy generation scavengers simple bucketbrigade advancement mechanism generationbased garbage collection uniprocessor garbage collection techniques cardmarking design opportunistic garbage collector barrier methods garbage collection comparative performance evaluation garbage collection algorithms tr smalltalk80 language implementation incremental incrementally compacting garbage collection design evaluation high performance smalltalk system tenuring policies generationbased storage reclamation simple bucketbrigade advancement mechanism generationbases garbage collection myampersandldquocardmarkingmyampersandrdquo scheme controlling intergenerational references generationbased garbage collection stock hardware simple generational garbage collection fast allocation design opportunistic garbage collector adaptive tenuring policy generation scavengers comparative performance evaluation write barrier implementation infant mortality generational garbage collection key objects garbage collection characterization object behaviour standard ml new jersey garbage collection using dynamic threatening boundary garbage collection generational garbage collection radioactive decay model pizza java generational stack collection profiledriven pretenuring realtime garbage collector based lifetimes objects list processing real time serial computer nonrecursive list compacting algorithm memory management incremental collection mature objects uniprocessor garbage collection techniques garbage collection large lisp system generation scavenging comparative performance evaluation properties agebased automatic memory reclamation algorithms ctr feng xian witawas srisaan hong jiang service oriented garbage collection improving performance robustness application servers companion 21st acm sigplan conference objectoriented programming systems languages applications october 2226 2006 portland oregon usa stephen blackburn john cavazos sharad singhai asjad khan kathryn mckinley j eliot b moss sara smolensky profiledriven pretenuring java poster session addendum 2000 proceedings conference objectoriented programming systems languages applications addendum p129130 january 2000 minneapolis minnesota united states richard jones five perspectives modern memory management systems hardware theory science computer programming v62 n2 p9597 1 october 2006 matthew hertz stephen blackburn j eliot b moss kathryn mckinley darko stefanovi errorfree garbage collection traces cheat get caught acm sigmetrics performance evaluation review v30 n1 june 2002 darko stefanovi matthew hertz stephen blackburn kathryn mckinley j eliot b moss olderfirst garbage collection practice evaluation java virtual machine acm sigplan notices v38 n2 supplement p2536 february stephen blackburn sharad singhai matthew hertz kathryn mckinely j eliot b moss pretenuring java acm sigplan notices v36 n11 p342352 11012001 narendran sachindran j eliot b moss markcopy fast copying gc less space overhead acm sigplan notices v38 n11 november clinger fabio v rojas linear combinations radioactive decay models generational garbage collection science computer programming v62 n2 p184203 1 october 2006 stephen blackburn kathryn mckinley putting write barriers place acm sigplan notices v38 n2 supplement february stephen blackburn antony l hosking barriers friend foe proceedings 4th international symposium memory management october 2425 2004 vancouver bc canada stephen blackburn matthew hertz kathryn mckinley j eliot b moss ting yang profilebased pretenuring acm transactions programming languages systems toplas v29 n1 p2es january 2007 lars hansen william clinger experimental study renewalolderfirst garbage collection acm sigplan notices v37 n9 p247258 september 2002 stephen blackburn richard jones kathryn mckinley j eliot b moss beltway getting around garbage collection gridlock acm sigplan notices v37 n5 may 2002 stephen blackburn perry cheng kathryn mckinley oil water high performance garbage collection java mmtk proceedings 26th international conference software engineering p137146 may 2328 2004 david detlefs christine flood steve heller tony printezis garbagefirst garbage collection proceedings 4th international symposium memory management october 2425 2004 vancouver bc canada samuel z guyer kathryn mckinley finding cronies static analysis dynamic object colocation acm sigplan notices v39 n10 october 2004 martin hirzel johannes henkel amer diwan michael hind understanding connectivity heap objects acm sigplan notices v38 n2 supplement february matthew hertz stephen blackburn j eliot b moss kathryn mckinley darko stefanovi generating object lifetime traces merlin acm transactions programming languages systems toplas v28 n3 p476516 may 2006 martin hirzel amer diwan matthew hertz connectivitybased garbage collection acm sigplan notices v38 n11 november exploiting prolific types memory management optimizations acm sigplan notices v37 n1 p295306 jan 2002 david f bacon perry cheng v rajan unified theory garbage collection acm sigplan notices v39 n10 october 2004 matthew hertz yi feng emery berger garbage collection without paging acm sigplan notices v40 n6 june 2005 godmar back wilson c hsieh kaffeos java runtime system acm transactions programming languages systems toplas v27 n4 p583630 july 2005
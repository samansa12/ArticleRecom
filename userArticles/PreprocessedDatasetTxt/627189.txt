automatic accurate costbound analysis highlevel languages paper describes languagebased approach automatic accurate costbound analysis approach consists transformations building costbound functions presence partially known input structures symbolic evaluation costbound function based input size parameters optimizations make overall analysis efficient well accurate sourcelanguage level calculated cost bounds expressed terms primitive cost parameters parameters obtained based language implementation measured conservatively approximately yielding accurate conservative approximate time space bounds implemented approach performed number experiments analyzing scheme programs results helped confirm accuracy analysis b introduction analysis program cost running time space consumption important realtime systems embedded systems interactive environments compiler optimizations performance evaluation many computer applications extensively work supported part nsf grant ccr9711253 onr grants n0001499 10132 n000140110109 yanhong lius address computer science department state university new york stony brook stony brook ny 117944400 gustavo gomezs address computer science department indiana university bloomington 474057104 corresponding author yanhong liu email liucssunysbedu tel 6316328463 fax 6316328334 url httpwwwcssunysbeduliu studied many elds computer science algorithms 25 16 17 53 programming languages 50 26 41 44 systems 46 37 43 42 particularly important many applications realtime systems embedded systems able predict accurate time bounds space bounds automatically eciently particularly desirable able highlevel languages 46 37 38 analyzing system running time since shaw proposed timing schema highlevel languages 46 number people extended analysis presence compiler optimizations 37 12 pipelining 20 28 cache memory 4 28 14 etc however remains obvious serious limitation timing schema even absence lowlevel complications inability provide loop bounds recursion depths execution paths automatically accurately analysis 36 3 example inaccurate loop bounds cause calculated worstcase time much 67 higher measured worstcase time 37 manual way providing information potentially even larger source error addition inconvenience 36 various program analysis methods proposed provide loop bounds execution paths 3 13 19 21 ameliorate problem completely solve apply classes programs use approximations crude analysis similarly loop bounds recursion depths needed also space analysis 38 paper describes languagebased approach automatic accurate costbound analysis approach combines methods techniques studied theory languages systems call languagebased approach primarily exploits methods techniques static program analysis transformation approach consists transformations building costbound functions presence partially known input structures symbolic evaluation costbound function based input size parameters optimizations make overall analysis ecient well accurate sourcelanguage level describe analysis transformation algorithms explain work calculated cost bounds expressed terms primitive cost parameters parameters obtained based language implementation measured conservatively approximately yielding accurate conservative approximate time space bounds cost analysis currently include cache analysis implemented approach performed number experiments analyzing scheme programs results helped conrm accuracy analysis describe prototype system alpa well analysis measurement results approach general sense works multiple kinds cost analysis main analysis sums cost terms dierent operations performed gives upper bounds kinds operations arithmetic operations data eld selections constructor allocations variations analyze stack space live heap space output size etc analyze lower bounds well upper bounds basic ideas also apply programming languages rest paper organized follows section 2 outlines languagebased ap proach sections 3 4 5 present analysis transformation methods techniques section 6 describes implementation experimental results section 7 compares related work concludes languagebased approach 21 cost cost bound languagebased costbound analysis starts given program written highlevel language c lisp rst step build cost function takes input original program returns cost place addition original return value done easily associating parameter program construct representing cost summing parameters based semantics constructs 50 10 46 call parameters describe costs program constructs primitive cost parameters calculate actual cost bounds based cost function three dicult problems must solved first since goal calculate cost without given particular inputs calculation must based certain assumptions inputs thus rst problem characterize input data ect cost function general due imperfect knowledge input cost function transformed costbound function algorithm analysis inputs characterized size accommodating requires manual semiautomatic transformation cost time space function 50 26 53 analysis mainly asymptotic primitive cost parameters considered independent input size ie constants computation iterates recurses whatever values primitive cost parameters assumed second problem arises theoretically challenging optimizing costbound function closed form terms input size 50 10 26 41 17 7 although much progress made area closed forms known subclasses functions thus optimization automatically done analyzing general programs systems inputs characterized indirectly using loop bounds execution paths programs information must general provided user 46 37 36 28 even though program analyses help cases 3 13 19 21 closed forms terms parameters bounds obtained easily cost function isolates third problem interesting systems research obtaining values primitive cost parameters depend compilers runtime systems operating systems machine hardwares recent year much progress made analyzing lowlevel dynamic factors clock interrupt memory refresh cache usage instruction scheduling parallel architectures time analysis 37 4 28 14 nevertheless inability compute loop bounds execution paths automatically accurately led calculated bounds much higher measured worstcase time programminglanguage area rosendahl proposed using partially known input structures 41 example instead replacing input list l length n done algorithm analysis annotating loops numbers related n done systems simply use input list n unknown elements call parameters n describing partially known input structures input size parameters cost function transformed automatically costbound function control points decisions depend unknown values maximum cost possible branches computed otherwise cost chosen branch computed rosendahl concentrated proving correctness transformation assumed constant 1 primitive cost parameters relied optimizations obtain closed forms terms input size parameters closed forms obtained costbound functions 22 languagebased costbound analysis combining results theory systems exploring methods techniques static program analysis transformation studied languagebased approach computing cost bounds automatically eciently accurately approach three main components first use automatic transformation construct costbound function original program based partially known input structures resulting function takes input size parameters primitive cost parameters arguments caveat costbound function might terminate however nontermination occurs recursiveiterative structure original program depends unknown parts given partially known input structures compute worstcase cost bounds eciently without relying closed forms optimize costbound function symbolically respect given values input size parameters based partial evaluation incremental computation symbolic evaluation always terminates provided costbound function terminates resulting function expresses cost bounds counts dierent operations performed cost kind operations denoted primitive cost parameter third component consists transformations enable accurate cost bounds computed lifting conditions simplifying conditionals inlining nonrecursive func tions transformations applied original program costbound function constructed may result larger code size allow subcomputations based control conditions merged leading accurate cost bounds computed eciently well approach general three components developed based general methods techniques particular component meant new analysis transformation combination application automatic accurate costbound analysis highlevel languages new resulting cost bounds primitive cost parameters obtained based language implementation measured conservatively approximately give accurate conservative approximate time space bounds implemented analyses transformations subset scheme 2 11 1 dialect lisp transformations done automatically cost bounds expressed operation counts computed eciently accurately example programs analyzed include number classical sorting programs matrix computation programs various list processing programs also estimated approximate bounds actual running times measuring primitive cost parameters running times using control loops calculated accurate bounds heap space allocated constructors programs based number bytes allocated constructor compiler used functional subset scheme three reasons functional programming languages together features like automatic garbage col lection become increasingly widely used yet work calculating actual running time space functional programs lacking much work done analyzing transforming functional programs including complexity analysis used estimating actual running time space eciently accurately well analyses transformations developed functional language applied improve analyses imperative languages well 52 analyses transformations performed source level allows implementations independent compilers underlying systems allows analysis results understood source level 23 language use rstorder callbyvalue functional language structured data primitive arithmetic boolean comparison operations conditionals bindings mutually recursive function calls program set mutually recursive function denitions expression e given grammar 1 e v variable reference primitive operation binding expression application binary primitive operations changing inx prex notations depending whichever easier presentation following lisp scheme use 1 keywords taken ml 35 implementation supports syntax scheme syntax consh construct list head h tail use carl cdrl select head tail respectively list l use nil denote empty list use nulll test whether l empty list example program selects least element nonempty list else let carx carx else end use least small running example present various analysis results also use several examples insertion sort selection sort merge sort set union list reversal standard lineartime version reversal append standard quadratictime version even though language small suciently powerful convenient write sophisticated programs structured data essentially records pascal structs c constructor applications ml conditionals bindings easily simulate conditional statements assignments recursions simulate loops also see cost analysis presence arrays pointers fundamentally harder 37 costs program constructs counted similar way costs con structs example accessing array element ai cost accessing osetting element address nally getting value address note side eects caused features often cause analysis dicult 9 22 pure functional languages higherorder functions lazy evaluations important cost functions accommodate features studied 49 44 symbolic evaluation optimizations describe apply well constructing costbound functions 31 constructing cost functions rst transform original program construct cost function takes original input primitive cost parameters arguments returns cost straightforward based semantics program constructs given original program add set cost functions one original function simply count cost original program executes algorithm given presented transformation c original program calls transformation c e recursively transform subexpressions example variable reference transformed symbol c varref representing cost variable reference conditional statement transformed cost test plus condition true cost true branch otherwise cost false branch plus cost transfers control use cf denote cost function f program c44 variable reference data construction c e primitive operation c e else binding function call c e applying transformation program least obtain function least originally given cost function cleast inx notation used additions unnecessary parentheses omitted note various cs indeed arguments cost function cleast omit argument positions ease reading else c transformation similar local cost assignment 50 stepcounting function 41 cost function 44 etc work transformation extends methods bindings makes primitive cost parameters explicit sourcelanguage level example primitive operation p given dierent symbol c p constructor c given dierent symbol c c note cost function terminates appropriate sum primitive cost parameters original program terminates runs forever sum innity original program terminate desired meaning cost function 32 constructing costbound functions characterizing program inputs capturing cost function dicult automate 50 26 46 however partially known input structures provide natural means 41 special value unknown represents unknown values example capture input lists length n following partially known input structure used listn else consunknown listn 1 similar structures used describe array n elements matrix mbyn elements complete binary tree height h etc since partially known input structures give incomplete knowledge inputs original functions need transformed handle special value unknown particular primitive function p dene new function f p f p v returns unknown v unknown returns pv usual otherwise example unknown unknown else v 1 v 2 also dene new function lub denoting least upper bound takes two values returns precise partially known structure values conform example unknown else else unknown also cost functions need transformed compute upper bound cost truth value conditional test known cost chosen branch computed normally otherwise maximum costs branches computed transformation b given embodies algorithms b e transforms expression original functions b c transforms expression cost functions use uf denote function f extended value unknown use cbf denote costbound function f program b44 variable reference data construction primitive operation else v e 0 function call primitive cost parameter else v e 0 applying transformation functions least cleast yields functions uleast cbleast function f p primitive operator p function lub given shared code presented whereclauses makes code smaller else v e 1 else e 2 end let else v f car x else end end else v e 1 else e 2 end c else v c car resulting costbound function takes arguments partially known input structures listn take arguments input size parameters n therefore obtain resulting function takes arguments input size parameters primitive cost parameters computes accurate cost bound possible transformations c b take linear time terms size program extremely ecient also seen prototype system alpa note resulting costbound function might terminate occurs recursive structure original program depends unknown parts partially known input structure trivial example partially known input structure given unknown corresponding costbound function recursive function terminate since original program cost innite resource worst case modify analysis detect nontermination many cases example 27 example giving unknown recursive costbound function nontermination trivial detect since arguments recursive calls would remain unknown optimizing costbound functions section describes symbolic evaluation optimizations make computation cost bounds ecient transformations consist partial evaluation realized global inlining incremental computation realized local optimization rst point costbound functions might extremely inecient evaluate given values parameters fact worst case evaluation takes exponential time terms input size parameters since essentially searches worstcase execution path inputs satisfying partially known input structures 41 partial evaluation costbound functions practice values input size parameters given almost applications timeanalysis techniques used systems require loop bounds user time bounds computed general possible obtain explicit loop bounds automatically accurately implicitly achieve desired eect evaluating costbound function symbolically terms primitive cost parameters given specic values input size parameters evaluation simply follows structures costbound functions specically control structures determine conditional branches make recursive function calls usual primitive operations sums primitive cost parameters maximums among alternative sums easily done symbolically thus transformation inlines function calls sums primitive cost parameters symbolically determines conditional branches takes maximum sums among possible branches symbolic evaluation e dened performs transformations takes arguments expression e environment variable bindings variable mapped value returns result symbolic value contains primitive cost parameters evaluation starts application costbound function partially unknown input structure eg cbleastlist100 starts empty environment assume add function symbolically sums arguments function symbolically takes maximum arguments variable reference look binding v environment primitive cost parameter e data primitive bind v value e 1 environment function calls e f dened example applying symbolic evaluation cbleast list size 100 obtain following result symbolic evaluation exactly specialized partial evaluation fully automatic computes accurate cost bound possible respect given program structure always terminates long costbound function terminates symbolic evaluation given values input size parameters inecient compared direct evaluation given values input size parameters particular primitive cost parameters even though resulting function takes virtually constant time given values primitive cost parameters example directly evaluating quadratictime reverse function uses append operation input size 20 takes 096 milliseconds whereas symbolic evaluation takes 670 milliseconds hundreds times slower propose optimizations greatly speed symbolic evaluation 42 avoiding repeated summations recursions symbolic evaluation global optimization costbound functions volved evaluation summations symbolic primitive cost parameters within function denition performed repeatedly computation recurses thus speed symbolic evaluation rst performing summations preprocessing step specically create vector let element correspond primitive cost parameter transformation given performs optimization use vcbf denote transformed costbound function f operates vectors use function add v compute componentwise sum argument vectors use function compute componentwise maximum argument vectors program s44 primitive cost parameter c create vector 0s except component corresponding c set 1 others c let v following vector primitive cost parameters applying transformation function cbleast yields function vcbleast components vectors correspond components v inx notation v used vector addition else v e 1 else e 2 end 2 0 0 0 else v else costbound function cbleastx simply dot product vcbleastx v transformation incrementalizes computation recursions avoid repeated summation fully automatic takes time linear terms size costbound function result optimization drastic speedup evaluation example optimized symbolic evaluation quadratictime reverse input size 20 takes 255 milliseconds direct evaluation takes 096 milliseconds resulting less 3 times slowdown 260 times faster symbolic evaluation without optimization making costbound functions accurate loops recursions aect cost bounds accuracy cost bounds calculated also depends handling conditionals original program ected costbound function conditionals whose test results known true false symbolicevaluation time appropriate branch chosen branches may even take longer considered worstcase cost major source accuracy worstcase bound conditionals whose test results known symbolicevaluation cost need take maximum cost among alternatives case would produce inaccurate cost bound test conditional one subcomputation implies test conditional another subcomputation example consider variable v whose value unknown compute cost bound e 1 directly result least cf cf ibonacci2000 however consider two realizable execution paths know worst case cf ibonacci2000 plus small constants known falsepath elimination problem 3 two transformations lifting conditions simplifying conditionals applied source program constructing costbound function allow us achieve accurate analysis results function denition former lifts conditions outermost scope test depend latter simplies conditionals according lifted condition example lifting condition e 1 obtain simplifying conditionals two occurrences e 2 f ibonaccis2000 2 respec tively obtain 2 facilitate transformations inline function calls function dened recursively power transformations depends reasonings used simplifying condi tionals studied many program transformation methods 51 45 47 18 32 least syntactic equality used identies obvious source inac curacy optimizations also speed symbolic evaluation since obviously infeasible execution paths searched transformations implemented applied many test programs even though resulting programs analyzed accurately eciently performed separate measurements major reason example programs contain conditional tests implied conditional tests simple transformations examples many powerful program optimization techniques especially functional programs used make costbound function accurate well ecient plan explore optimizations measure eects experiment programs note transformations source program aimed making cost bound function accurate ecient optimizing source program even though making source program faster also makes corresponding costbound function faster two goals dierent optimizing source program meant produce dierent program smaller cost cost analysis meant analyze accurately cost given program make use techniques making costbound analysis ecient accurate perform overall costbound analysis applying following transformations order source program lifting conditions simplifying conditionals section 5 constructing cost functions costbound functions section 3 precomputing repeated local summations performing global symbolic evaluation section 4 6 implementation experimentation implemented analysis approach prototype system alpa automatic languagebased performance analyzer performed large number experiments obtained encouraging good results 61 implementation experimental results implementation subset scheme 2 11 1 editor source programs implemented using synthesizer generator 40 thus easily change syntax source programs example current implementation supports syntax used paper scheme syntax construction costbound functions written ssl simple functional language used synthesizer generator lifting conditions simplifying conditionals inlining nonrecursive calls also implemented ssl symbolic evaluation optimizations written scheme figure 1 gives results symbolic evaluation costbound functions six example programs inputs sizes 10 2000 example second row gure means insertion sort inputs size 10 costbound function last column lists sums every rows set union example used inputs arguments given sizes numbers gure characterize various aspects examples contribute actual time space bounds discussed veried numbers also exact worstcase counts example insertion sort inputs size 10 indeed function calls made worstcase execution worstcase counts veried using modied evaluator experiments show costbound functions give accurate cost bounds terms counts dierent operations performed figure 2 compares times direct evaluation costbound functions primitive cost parameter set 1 times optimized symbolic evaluation obtaining exact symbolic counts figure 1 measurements taken sun ultra 1 167mhz cpu 64mb main memory include garbagecollection time times without garbagecollection times 1 faster shown experiments show optimizations costbound functions allow symbolic evaluation times slower direct evaluation rather hundreds times slower merge sort costbound function constructed using algorithms paper takes several days evaluate inputs size 50 larger special simple optimizations done obtain numbers figure 1 namely letting costbound function merge avoid base cases long possible using sizes lists place lists unknowns resulting symbolic evaluation takes seconds optimizations yet implemented performed automatically examples takes 27 hours evaluate costbound functions note small inputs symbolic evaluation takes relatively much time direct evaluation due relatively large overhead vector setup inputs get larger symbolic evaluation almost fast direct evaluation examples example size varref nil cons null car cdr let call total insertion 200 120401 201 20100 20301 40000 20100 19900 40201 0 20300 301504 1000 3002001 1001 500500 501501 1000000 500500 499500 1001001 0 501500 7507504 2000 12004001 2001 2001000 2003001 4000000 2001000 1999000 4002001 0 2003000 30015004 selection 200 220501 201 20100 40401 79800 80000 39800 80201 20100 40400 621504 500 1376251 501 125250 251001 499500 500000 249500 500501 125250 251000 3878754 1000 5502501 1001 500500 1002001 1999000 2000000 999000 2001001 500500 1002000 15507504 2000 22005001 2001 2001000 4004001 7998000 8000000 3998000 8002001 2001000 4004000 62015004 200 19526 598 3089 7372 5779 4832 1345 8717 0 5428 56686 1000 124710 2998 19953 45900 37907 30928 8977 54877 0 33924 360174 2000 273422 5998 43905 99804 83811 67856 19953 119757 0 73852 788358 set union 20 2162 20 20 441 440 420 400 861 20 440 5224 50 12902 50 50 2601 2600 2550 2500 5151 50 2600 31054 100 50802 100 100 10201 10200 10100 10000 20301 100 10200 122104 200 201602 200 200 40401 40400 40200 40000 80601 200 40400 484204 300 452402 300 300 90601 90600 90300 90000 180901 300 90600 1086304 500 1254002 500 500 251001 251000 250500 250000 501501 500 251000 3010504 1000 5008002 1000 1000 1002001 1002000 1001000 1000000 2003001 1000 1002000 12021004 2000 20016002 2000 2000 4004001 4004000 4002000 4000000 8006001 2000 4004000 48042004 list 2000 8003 1 2000 2001 2000 2000 0 2001 0 2001 20007 1000 2003001 1001 500500 501501 500500 500500 0 501501 0 501500 5010004 2000 8006001 2001 2001000 2003001 2001000 2001000 0 2003001 0 2003000 20020004 figure 1 results symbolic evaluation costbound functions symbolic evaluation cost bounds computed virtually time given values primitive cost parameters insertion sort selection sort merge sort set union list reversal reversal wapp size direct symbolic direct symbolic direct symbolic direct symbolic direct symbolic direct symbolic 500 582400 580800 394800 460500 xxxxxx xxxxxx 125910 117240 050305 624266 215400 221800 2000 figure 2 times direct evaluation vs optimized symbolic evaluation milliseconds among twenty programs analyzed using alpa two termi nate one quicksort contrived variation sorting diverge recursive structure splitting list depends values unknown list elements similar nontermination caused merging paths methods 33 34 nontermination happens much less often method since essentially avoid merging paths much possible found dierent symbolicevaluation strategy uses kind incremental path selection evaluation would terminate examples well examples giving accurate worstcase bounds evaluation algorithm yet implemented future work exploit results static analysis identifying sources nontermination 27 make costbound analysis terminate often practical use costbound analyzer might terminate certain inputs modify evaluator stopped time outputs cost bound calculated till point means longerrunning analysis might yield higher bound 62 experiments also estimated approximate bounds actual running times measuring primitive cost parameters running times using control loops calculated accurate bounds heap space allocated constructors programs based number bytes allocated constructor compiler timebound analysis performed two sets experiments rst machine cache enabled second machine cache disabled rst gives tight bounds cases underestimations inputs small large attribute cache eects second gives conservative tight bounds inputs rst describe experiments timebound analysis cache enabled analysis heap space allocation bound analyze cache eects show results timebound analysis cache disabled measurements analyses timebounds performed source programs compiled chez scheme compiler 8 source program use library partic ular numbers large enough trigger bignum implementation chez scheme tried avoid compiler optimizations setting optimization level 0 view necessary optimizations already applied program handle garbagecollection time performed separate sets experiments exclude garbagecollection times calculations measurements include garbagecollection time 2 current analysis handle eects cache memory instruction pipelining approximated cache eects taking operands circularly cycle 2000 elements measuring primitive cost parameters discussed timebound analysis cache enabled particular numbers reported taken sun ultra 1 167mhz cpu 64mb main memory also performed analysis several kinds sparc stations results similar since minimum running time program construct 01 microseconds precision timing function 10 milliseconds use controltest loops iterate 10000000 times keeping measurement error 0001 microseconds ie 1 loop repeated 100 times average value taken compute primitive cost parameter tested construct variance less 10 cases calculation time bound done plugging measured parameters optimized timebound function run example program appropriate number times measure running time less 1 error figure 3 shows estimated measured worstcase times six example programs inputs sizes 10 2000 times include garbagecollection times item meca measured time expressed percentage calculated time general measured times closely bounded calculated times 9095 accuracy except inputs small 20 1 case large 2000 3 cases analyzed addressed measurements including garbagecollection times similar except cases underestimation figure 4 depicts numbers originally tried avoid garbage collection writing loops instead recursions much possible tried exclude garbagecollection times completely idea including garbagecollection times comes earlier experiment mistakenly used timing function chez scheme included garbagecollection time insertion sort selection sort merge sort size calculated measured meca calculated measured meca calculated measured meca 50 155379 148250 954 326815 301125 921 092702 085700 924 100 614990 586500 954 130187 119650 919 215224 198812 924 200 244696 243187 994 519678 474750 914 490017 457200 933 300 549593 538714 980 116847 107250 918 786231 755600 961 500 152448 147562 968 324398 304250 938 141198 129800 919 1000 609146 606000 995 129706 117750 908 312153 285781 916 2000 243529 308125 1265 518717 548275 1057 683816 653750 956 set union list reversal reversal wappend size calculated measured meca calculated measured meca calculated measured meca 50 227555 211500 929 004436 004193 945 114035 101050 886 100 895400 833250 931 008834 008106 918 447924 393600 879 300 796987 751000 942 026424 024437 925 398220 356328 895 500 220892 208305 943 044013 040720 925 110344 102775 931 1000 882094 839780 952 087988 082280 935 440561 399700 907 2000 352542 338531 960 175937 165700 942 176061 223575 1270 figure 3 calculated measured worstcase times milliseconds cache enabled figure 3 inputs sizes 1000 examples sorting classied complex examples previous study 37 28 calculated time much 67 higher measured time result one sorting program single input size reported experiment using cost bounds computed also calculate accurately instead approx imately bounds heap space dynamically allocated constructors source programs number bytes allocated constructor obtained precisely based language implementation example chez scheme allocates 8 bytes conscell heap information also obtained easily using statistics utili ties based results figure 1 setting c cons 8 primitive cost parameters 0 obtain exact bounds heap space dynamically allocated constructors programs shown figure 5 consider accuracy timebound analysis cache enabled found inputs small 20 measured time occasionally calculated time examples also inputs large 1000 measurements including time milliseconds input size insertion sort calculated time milliseconds input size selection sort calculated time milliseconds input size merge sort calculated time milliseconds input size set union calculated time milliseconds input size list reversal calculated time milliseconds input size reversal wappend calculated figure 4 comparison calculated measured worstcase times cache enabled size insertion sort selection sort merge sort set union list reversal reversal wapp 50 10200 10200 4584 400 400 10200 100 40400 40400 10760 800 800 40400 200 160800 160800 24712 1600 1600 160800 500 1002000 1002000 71816 4000 4000 1002000 1000 4004000 4004000 159624 8000 8000 4004000 2000 16008000 16008000 351240 16000 16000 16008000 figure 5 bounds heap space allocated constructors bytes garbagecollection time 2000 excluding garbagecollection time measured times examples calculated time attribute cache memory eects following reasons first initial cache misses likely show small inputs second underestimation inputs size 2000 figure 3 happens exactly 3 examples whose allocated heap space large figure 5 recall used cycled data structure size 2000 measuring primitive cost parameters furthermore programs use less space calculated bounds accuracy even larger input sizes programs use extremely large amount space even small inputs much worse underestimation example cartesian product underestimation occurs small input sizes 50 200 example input size 200 measured time 65 higher calculated time performed second set experiments timebound analysis machine cache disabled machine used sun ultra 10 333mhz cpu 256mb main memory figure 6 shows estimated measured worstcase times six programs inputs sizes 10 2000 times include garbagecollection times see measured times closely bounded calculated times underestimation figure 7 depicts numbers figure 6 accommodate cache eect timebound analysis cache enabled could adjust measurements primitive cost parameters data structures appropriate size appropriate size determined based precise space usage analysis heapspace allocation one less direct aspect directly incorporate precise knowledge compilergenerated machine instructions analysis method leave future work current method used approximate timebound estimation insertion sort selection sort merge sort size calculated measured meca calculated measured meca calculated measured meca 50 352196 322160 915 715578 622520 870 200717 191025 952 200 555253 505195 910 113871 975660 857 106383 994885 935 300 124726 113551 910 256057 219080 856 170790 159820 936 500 346007 315220 911 710928 610595 859 306905 285640 931 1000 138266 125581 908 284268 243877 858 678999 633030 932 2000 552791 505300 914 113687 979400 861 148836 138786 932 set union list reversal reversal wappend size calculated measured meca calculated measured meca calculated measured meca 50 473684 460915 973 010007 009114 911 256979 224415 873 200 737997 717215 972 039786 035615 895 400575 346355 865 300 165552 161145 973 059639 053297 894 898657 778655 866 500 458766 446670 974 099345 088594 892 249041 216280 868 1000 183175 178491 974 198611 176579 889 994409 859320 864 2000 732041 713300 974 397142 352055 886 397412 346958 873 figure calculated measured worstcase times milliseconds cache disabled presence lowlevel eects precise analysis absence used accurate spacebound analysis helps addressing memory issues 7 related work conclusion preliminary version work appeared 30 overview comparison related work cost analysis appears section 2 certain detailed comparisons also discussed presenting method section summarizes compares analyses loop bounds execution paths detail concludes compared work algorithm analysis program complexity analysis 26 44 53 7 work consistently pushes symbolic primitive cost parameters allows us calculate actual cost bounds validate results experimental measurements also work analyzing averagecase complexity 17 dierent goal worstcase bounds compared work systems 46 37 36 28 work explores program analysis transformation techniques make analysis automatic ecient accurate overcoming diculties caused inability obtain loop bounds time milliseconds input size insertion sort calculated time milliseconds input size selection sort calculated time milliseconds input size merge sort calculated time milliseconds input size set union calculated time milliseconds input size list reversal calculated time milliseconds input size reversal wappend calculated figure 7 comparison calculated measured worstcase times cache disabled recursion depths execution paths automatically precisely also work measuring primitive cost parameters purpose general performance prediction 43 42 work information execution paths obtained running programs number inputs programs insertion sort whose bestcase worstcase execution times dier greatly predicted time using method could inaccurate number techniques studied obtaining loop bounds execution paths time analysis 36 3 13 19 21 manual annotations 36 28 inconvenient errorprone 3 automatic analysis information two main problems first even precise loop bound obtained symbolic evaluation program 13 separating loop path information rest analysis general less accurate integrated analysis 34 second approximations merging paths loops recursions often lead nontermination time analysis looser bounds 13 19 34 newer methods powerful apply certain classes programs 21 contrast method allows recursions loops considered naturally overall cost analysis based partially known input structures addition method merge paths recursions loops may cause exponential time complexity analysis worst case experiments test programs show analysis still feasible inputs sizes thousands also studied simple powerful optimizations speed analysis dramatically analysis cache behavior 14 15 loops transformed recursive calls predened callstring level determines many times xedpoint analysis iterates thus analysis results approximated method allows analysis perform exact number recursions iterations given partially known input data structures work lundqvist stenstrom 33 34 based similar ideas apply ideas machine instruction level accurately take account eects instruction pipelining data caching handle dynamically allocated data structures method merging paths loops would lead nonterminating analysis many programs method apply ideas source level experiments show calculate accurate cost bound many programs merging paths calculation still ecient also methods time analysis based program ow graphs 39 6 unlike method methods exploit given input sizes require programmers give precise path information idea using partially known input structures originates rosendahl 41 extended manipulate primitive cost parameters also handle binding constructs simple necessary ecient computation innovation method optimize costbound function using partial evaluation incremental computation transformations conditionals make analysis ecient accurate partial evaluation 5 24 23 incremental computation 32 31 29 transformations studied intensively programming languages applications costbound analysis particularly simple clean resulting transformations fully automatic ecient started explore suite new languagebased techniques cost analysis particular analyses optimizations speeding evaluation cost bound function also applied general approach analyze stack space live heap space 48 help predict garbagecollection caching behavior also analyze lower bounds using symmetric method namely replacing maximum minimum conditional points future work accommodate lowerlevel dynamic factors timing sourcelanguage level 28 14 examining corresponding compiler generated code cache pipelining eects explicit conclusion approach propose based entirely highlevel programming languages methods techniques intuitive together produce automatic tools analyzing cost bounds eciently accurately used accurately approximately analyze time space bounds acknowledgment thank anonymous referees careful reviews many helpful comments r revised report algorithmic language scheme structure interpretation computer programs false path problem hard realtime programs bounding worstcase instruction cache performance cadence research systems analysis pointers structures scheme programming language facilitating worstcase execution time analysis optimized code deriving annotations tight calculation execution time applying compiler techniques cache behavior prediction automatic averagecase analysis algorithms generalized partial evaluation automatic derivation path loop annotations objectoriented realtime programs retargetable technique predicting execution time abstractions recursive pointer data structures improving analysis transformation imperative programs introduction partial evaluation partial evaluation automatic program generation art computer programming sizechange principle program termination accurate worst case timing analysis risc processors static caching incremental computation systematic derivation incremental programs predicting program execution times analyzing static dynamic program paths experiments program timing tool based sourcelevel timing schema live memory analysis garbage collection embedded systems computing maximum task execution times synthesizer generator system constructing languagebased editors automatic complexity analysis analysis benchmark characterization benchmark performance prediction machine characterization based abstract highlevel language machine complexity analysis lazy higherorder language program improvement internal specialization reasoning time higher level language software concept supercompiler automatic accurate live memory analysis garbagecollected languages strictness analysis aids time analysis mechanical program analysis value dependence graphs representation without taxation automatic complexity analysis divideandconquer algo rithms tr ctr yanhong liu scott stoller optimizing ackermanns function incrementalization acm sigplan notices v38 n10 p8591 october yanhong liu scott stoller dynamic programming via static incrementalization higherorder symbolic computation v16 n12 p3762 marchjune
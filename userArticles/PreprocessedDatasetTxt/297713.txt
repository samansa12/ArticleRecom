analysis temporalbased program behavior improved instruction cache performance abstractin paper examine temporalbased program interaction order improve layout reducing probability program units conflict instruction cache context present two profileguided procedure reordering algorithms techniques use cache line coloring arrive final program layout target elimination first generation cache conflicts ie conflicts callercallee pairs first algorithm builds call graph records local temporal interaction procedures describe call graph used guide placement step present methods accelerate cache line coloring exploring aggressive graph pruning techniques second approach capture global temporal program interaction constructing conflict miss graph cmg cmg estimates worstcase number misses two competing procedures inflict upon one another reducing higher generation cache conflicts use pruned cmg graph guide cache line coloring using several c c benchmarks show benefits letting types graphs guide procedure reordering improve instruction cache hit rates contrast differences two forms temporal interaction also develop new characterization streams based interreference gap irg model b introduction c ache memories found microprocessors designed today caching instruction stream beneficial since instruction references exhibit high degree spatial temporal locality still cache misses occur one three reasons 1 1 first time reference 2 finite cache capacity 3 memory address conflict work focused reducing memory address conflicts rearranging program available memory space analysis program interaction performed range granularities coarsest individual procedure 2 begin considering procedure call graph ordering cgo associated program cgo captures local temporal interaction weighting edges number times one procedure follows another program execution also consider interaction basic blocks contained within procedures identifying number cache lines touched basic block conflict miss graph cmg attempt move basic blocks split procedures 3 though weight cmg edges measuring global temporal interaction procedures occurring finite window containing many entries cache lines program interaction outside window interest finite cache effect use graphs input coloring algorithm produce improved code layout instruction caches characterize temporal behavior captured graphs extend interreference gap irg model 4 define three new irgbased streams describe different levels procedurebased temporal interaction show use compare temporal content cgo cmg temporal relationship graph trg described gloy et al 5 considerable amount work done code repositioning improved instruction cache performance 3 5 6 7 8 9 10 following section discuss work relates work related work pettis hansen 3 employ procedure basic block reordering well procedure splitting based frequency counts minimize instruction cache conflicts layout program directed traversing call graph edges decreasing edge weight order using closestisbest placement strategy chains formed merging nodes laying next entire graph processed number related techniques proposed focusing mapping loops 6 operating system code 10 traces 9 activity sets 7 two approaches discussed 8 11 reorganize code based compiletime information profileguided algorithms described use calling frequencies weight graph guide placement 3 6 9 10 first approach also uses calling frequencies improves performance intelligently placing procedures cache coloring cache lines second algorithm described paper captures global temporal information attempts minimize conflicts present procedures immediately follow execution similar spirit approach described 5 differences highlighted section v also graph coloring algorithm works finer level granularity cache line size instead cache size 6 11 avoid conflicts encountered either forming chains closestisbest heuristic 3 dealing subgraphs size larger cache paper organized follows sections ii iii describe graph construction algorithms section ii describes improved graph pruning technique section iv report simulation results section v reviews irg temporal analysis model presents new methods characterizing program interaction ii call graph ordering program layout may involve two steps 1 constructing graphbased representation program 2 using graph perform layout program available memory space call graph procedure graph edges procedures call edges weighted callreturn frequency captured program profile procedure mapped single vertex call paths two procedures condensed single edge two vertices graph edge weights derived profiling information estimated program control flow 8 12 paper concentrate profilebased edge weights constructing call graph lay program using cache line coloring start dividing cache set colors one color cache line procedure count number cache lines needed hold procedure record cache colors used map procedure keep track unavailableset colors ie cache lines procedure mapped define popular procedure set procedures frequently visited popular edge set contains frequently traversed edges rest procedures edges called unpopular unpopular procedures pruned graph pruning reduces amount work placement allows us focus procedures likely encounter misses discussion base pruning algorithm used found 2 note difference popular procedures procedures consume noticeable portion pro grams overall execution time time consuming procedure may labeled unpopular rarely switches control flow another procedure procedure rarely switches control flow causes small number conflicts misses rest procedures algorithm sorts popular edges descending edge weight order traverse sorted popular edge list inspect state ie mapped unmapped two procedures forming edge map procedures using heuristics figure 1 provides pseudo code description color mapping complete description found 2 process repeated edges popular set processed unpopular procedures fill holes left coloring using simple input graph gpe descending order based weight eliminate threshold foreach remaining edge procedures pi pj selectstate pi state pj case pi unmapped pj unmapped arbitrarily map pi pj forming compound node pij case ii pi pj mapped reside two different compound nodes ci cj concatenate two compound nodes ci cj minimizing distance pi pj color conflict shift ci color space conflict conflict avoided return ci original position case iii either pi pj mapped case ii case iv pi pj mapped belong compound node ck conflict return position else move procedure closest end compound node ck pi end ck outside compound node still conflict shift pi color space conflict occurs pj conflict avoided leave pi original position update unavailable set colors fill holes created cases ii iii iv fig 1 pseudo code cache line coloring algorithm depthfirst traversal unpopular edges joining algorithm fig1 assumes directmapped cache organization associative caches algorithm breaks address space chunks equal size number cache sets cache line size therefore number sets represents number available colors mapping modified color mapping algorithm keeps track number times color set appears procedures unavailableset colors mapping procedure color set cause conflicts long number times color set appears unavailable set colors less degree associativity cache next look efficiently eliminate majority work spent coloring using aggressive graph pruning algorithm pruning rules procedure call graphs pruning call graph done using fixed threshold value selected edge weight 2 section present pruning rules reduce size graph used cache coloring specifically designed reduce number lines cache number procedures p nodes graph g sum incident edges procedure pi graph g sort procedures based increasing nodeweight dowhile least one procedure pruned foreach unpruned procedure pi number neighbors pi number cache lines comprising pi sum sizes numi neighbors pi prune procedure pi edges incident pi fig 2 pseudo code c pruning rule number firstgeneration cache conflicts assume using directmapped cache containing c cache lines program represented undirected graph pe nodes edge represents procedure call program number cache lines spanned procedure size edge j weighti j number times procedures j follow one another control flow either order procedure mapping assignment procedure sizei adjacent cache lines within cache wraparound cost procedure mapping sum weighti j procedures j overlap cache optimal mapping one less costly mapping note cost mapping depends number immediately adjacent procedures whose mappings cache conflict conflicts procedures call one another considered cost assigning two adjacent procedures j conflicting cache lines constant equal number conflicts even though actual number replaced cache lines may smaller b c pruning rule consider cache mapping problem p possible determine cases particular node able mapped cache without causing con flicts regardless cache adjacent nodes eventually mapped case edges connected deleted graph creating new cache mapping problem p 0 one less node figure 2 provides pseudo code pruning algorithm pruning rule generalization rules described 13 perform graph coloring graph coloring problem assign one k colors nodes graph adjacent nodes assigned color node neighbors deleted regardless neighbors eventually col ored definitely least one color left assigned deleted nodes colored reverse order deletion remaining nonprunable graph passed coloring algorithm coloring performed pruned node must mapped nodes laid opposite order deletion iii conflict miss graphs next consider cache misses occur procedures many procedures away call graph well different call chains 14 capture temporal information weighting edges procedure graph estimation worst case number conflict misses occur two procedures use graph apply cache line coloring place procedures cache address space call graph conflict miss graph cmg complete algorithm described 14 summarize contrast cgo section v using interreference gap analysis conflict miss graph construction cmg built using profile data assume worstcase scenario procedures completely overlap cache address space every time interact given cache configuration determine size procedure p cache lines also compute number unique cache lines spanned every basic block executed procedure l identify first time basic block executed label references globally unique accesses gl cmg undirected procedure graph edges weighted according worst case miss model 14 edge weights updated based contents nentry table n number cache lines table fullyassociative uses lru replacement pol icy every entry ie cache line table called live procedure least one live cache line also called live p activated update edge weights p procedures least one live cache line activated since last activation last activation captured lru table lru table allows us estimate finite cache effect increment cmg edge weight p live procedure p j minimum accumulated number unique live cache lines p last oc currence ii number unique cache lines p current activation excluding coldstart misses detailed example updating cmg edge weights found 14 cmg edge weights accurate cgo edge weights cgo edge weights record number cache lines may conflict per call ii interaction procedures directly call captured iv experimental results use tracedriven simulation quantify instruction cache performance resulting layouts traces generated using atom 15 dec 3000 axp workstation running digital unix v40 applications compiled dec c v52 dec c v55 com pilers input used train algorithm gather performance results simulated 8kb directmapped instruction cache 32byte line size similar design dec alpha 21064 21164 instruction caches benchmark suite includes perl specint95 flex generator lexical analyzers gs ghostscript postscript viewer bison c parser gen erator also includes pc2dep c frontend written cc f2dep fortran frontend written cc dep2c cc program translating sage internal representation c code ixx idl parser written c table presents static dynamic characteristics benchmarks column 2 shows input used test train algorithms columns 35 list total number instructions executed static size application kilobytes number static procedures program column 6 presents percentage program contains popular procedures cmg column 7 contains percentage procedures found popular cmg last column presents percentage unactivated procedures used fill gaps left color mapping prune cmg graph form popular set procedures connected edges contribute 80 total sum edge weights cmg 14 notice pruning algorithm reduces size cmg 8097 reduces size executable 777945 executable allows us concentrate important procedures program simulation results compare simulation results ordering produced dec compiler static dfs ordering proce dures cgo using fixed threshold value pruning aggressive pruning employed table ii shows instruction cache miss rates cases inputs used training testing first column denotes application columns 24 79 shows instruction cache miss rates number cache misses dfs cgo cmg respec tively columns 5 6 show relative improvement cmg dfs cgo respectively see table ii average instruction cache miss rate cmg reduced 30 average dfs ordering 21 average cgo ordering cmg improves performance static dfs cgo benchmarks except bison flex gs bison flex already low miss rate improvement achieved gs large number popular procedures mapped cache significant reduction miss rate next apply pruning c pruning rule cgo four benchmarks bison flex gs perl also tried apply approach cmg found unable significantly reduce size graph shown tables iii iv pruning rule deletes 125 nodes bison completely eliminates firstgeneration conflict misses similarly nodes pruned benchmarks accompanied significant drop number firstgeneration conflict misses however drop times followed increase total number misses deleting nodes edges contribute firstgeneration conflict misses coloring algorithm deprived information used prevent higher order misses case bison benchmark nodes inserted mapping complete disregard higher order conflicts results suggest node pruning rules c useful part cache conflict reduction strategy paired techniques prevent higher order cache conflicts canceling benefits reducing firstorder conflicts b input training sensitivity since procedure reordering algorithm profile driven tried different training test input files shown table v column 2 3 training test input column 4 shows size traces millions instructions test training inputs last one parentheses last three columns present miss ratios algorithms simulated see table v although performance cgo cmg approach drops compared simulations using inputs relative advantage cmg cgo static dfs still remains fact performance gain order benchmarks ie cgo cmg achieve similar performance bison gs cmg improves significantly miss ratio ixx v temporal locality procedurebased irg next characterize temporal interaction exposed cgo cmg temporal relationship graph using extended version interreference gap irg model 4 procedurebased irg 4 phalke gopinath define irg address number memory references successive references address irg stream address trace sequence successive irg values address used characterize temporal locality similarly measure temporal locality larger program granules basic blocks cache lines procedures accuracy newly generated irg stream depends interval granularity work set program unit study procedure vary interval definition program input instr exe size static pop procs unpop procs million kb procs exe size procs exe size perl primes 12 512 671 49 251k 52 35 181k flex fixit 19 112 170 148 166k 176 65 73k bison objparse 56 112 158 224 251k 221 61 69k pc2dep sample 19 480 665 95 457k 163 103 495k dep2c sample 31 560 1338 48 271k 17 17 95k gs tiger 34 496 1410 129 640k 112 93 463k ixx layout 48 472 1581 57 272k 51 24 117k attributes traced applications attributes include number executed instructions application executable size number static procedures percentage programs size occupied popular procedures percentage procedures found popular percentage unactivated procedures used fill memory gaps left applying coloring icache miss rate reduction icache misses program dfs cgo cmg dfs cgo dfs cgo cmg perl 472 460 377 95 83 588123 572650 469329 flex 053 045 045 08 00 100488 85538 85478 bison 004 004 005 01 01 21798 21379 26792 pc2dep 472 546 368 104 178 895261 1035639 698003 dep2c 392 346 311 81 35 1205076 1063682 957102 gs 345 209 208 137 01 1176335 712230 709643 ixx 583 442 257 326 185 2843330 2154747 1251022 avg 352 315 248 ii instruction cache performance static dfs cgo cmgbased reordering column 1 lists application columns 24 show instruction miss rates next two show percent improvement algorithm last three columns show number instruction cache misses program input visited pruned pruned pruned procs 1st pass 2nd pass 3rd pass bison objparse 125 125 0 0 flex fixit 97 61 5 2 gs tiger 532 524 5 0 perl primes 209 113 4 0 iii results applying c pruning rules call graphs four applications passes refer pruning iterations graph algorithm finished nodes pruned graph program cgo first higher c first higher miss rate order order miss rate order order bison 04 1316 19812 14 0 79888 flex 45 55004 30280 51 42467 55233 gs 209 530908 658066 239 25663 791567 perl 460 99327 473070 445 92914 462056 iv results applying c pruning rules call graphs four applications cache parameters used program training test trace static dfs cgo cmg input input instr miss rate miss rate miss rate bison objparse cparse 356m 561 005 004 006 flex fixit scan 232m 191 049 043 038 gs tiger golfer 155m 341 339 249 251 ixx layout widget 527m 487 589 445 254 perl primes jumble 719m 124 436 461 416 miss ratios using different test training inputs inputs described columns 23 sizes corresponding traces presented column 4 columns 57 include instruction cache miss ratios original irg model exploits temporal locality single procedure temporal interaction procedures therefore redefine irg value procedure pair b number unique activated procedures invocations b refer value interreference procedure gap irpg cgo edge weights record part irpg stream since capture irpg values length 1 trg every node represents procedure every edge weighted number times procedure vice versa found inside moving time window window includes previously invoked procedures size proportional size cache windows contents managed lru queue temporal interaction recorded trg characterized interreference intermediate line gap irilg whose elements equal number unique cache lines activated successive b invocations decision update trg edge depends size window equivalently values present irilg stream edge weight simply count irilg elements value less predefined window size trg captures temporal interaction detailed level cgo irilg stream richer content irpg stream cmg edge weight procedures b updated b follow one another inside moving time window proportional size cache size cmg edge weight updated whenever irilg value less window size trg cmg procedures interact long found inside time window cmg however replaces procedures time window based age individual lines procedure 14 trg manages replacement entire procedure basis 5 addition cmg edge weight b incremented minimum unique live cache lines successive invocations b trg simply counts number times b follow define interreference active line set irals procedure pair sequence number unique live cache lines referenced successive occurrences b irals element value computed according worst case miss analysis presented section iii cmg edge weight equal sum irals values whose corresponding irilg values less window size table vi shows irpg irilg irals element frequency distribution two edges ixx benchmark selected edges 4th 12th highest calling frequency cgo popular edge list labeled e 4 e 12 respectively classify stream values ranges shown columns 14 7 present per stream frequency distributions columns 23 56 8 9 numbers parentheses indicate closely cgo approximates temporal information captured stream consideration example 661 irilg elements e 12 lie range 2 10 unique cache lines 624 recorded cgo 3 different approaches edge weighting significant impact global edge ordering final procedure placement ixx cmg cgo popular edge set intersection edge index cgo ordering edge index ordering fig 3 relative edge ordering intersection cmg cgo popular edge orderings ixx fig 3 compares ordering common popular edges cgo cmg ixx point location 34 means popular edge consideration found 3rd cgo 4th cmg ordering points straight line correspond edges relative position edge lists points lying straight line indicate edges higher priority cgo cmg edge list notice edges fall straight line due artificially inflated edge index cmg edge list much larger irpg 4th 12th irilg 4th 12th irals 4th 12th value vi frequency distribution irpg irilg irals sequences two procedure pairs 4th 12th calling frequency ixx benchmark program cgo pop cmg pop cgo cmg cgo pop cmg pop cgo cmg procs procs procs edges edges edges bison 43 flex 28 28 26 94 23 gs 94 158 94 105 1478 105 perl 20 vii intersections cmg cgo popular procedure edge sets cgo one different pruning algorithms used although lot highly weighted edges maintained relative positions significant performance improvement cmg came edges promoted higher edge list ordering table vii shows intersection cmg cgo popular procedure edge sets columns 24 5 list cgo cmg popular procedure edge sets along intersection numbers shown table vii sensitive pruning algorithm compared better illustrate differences cmg cgo approach although one procedure set always superset cmg edge list always larger cgo edge list vi acknowledgments would like acknowledge contributions h hashemi b calder work research supported national science foundation career award program ibm research microsoft research vii conclusions performance cachebased memory systems critical todays processors research shown compiler optimizations significantly reduce memory la tency every opportunity taken compiler paper presented two profileguided algorithms procedure reordering take consideration procedure size cache organization well cgo attempts minimize firstgeneration conflicts cmg targets higher generation misses approaches use pruned graph models guide procedure placement via cache line coloring cmg algorithm improved instruction cache miss rates average 30 static depth first search procedures 21 cgo also introduced three new sequences irpg irilg irals based irg model better characterize contents graph model r evaluating associativity cpu caches efficient procedure mapping using cache line coloring profileguided code positioning interreference gap model temporal locality program behavior procedure placement using temporal ordering information program optimization instruction caches code reorganization instruction caches procedure mapping using static call graph estimation achieving high instruction cache performance optimizing compiler optimizing instruction cache performance operating system intensive workloads compiletime instruction cache optimizations predicting program behavior using real estimated profiles register allocation spilling via graph coloring temporalbased procedure reordering improved instruction cache performance tr ctr altman david kaeli yaron sheffer guest editors introduction welcome opportunities binary translation computer v33 n3 p4045 march 2000 bartolini c prete optimizing instruction cache performance embedded systems acm transactions embedded computing systems tecs v4 n4 p934965 november 2005 bartolini c prete proposal inputsensitivity analysis profiledriven optimizations embedded applications acm sigarch computer architecture news v32 n3 p7077 june 2004 mohsen sharifi behrouz zolfaghari yaarc yet another approach reducing rate conflict misses journal supercomputing v44 n1 p2440 april 2008
java specification language hardwaresoftware systems specification language critical component hardwaresoftware codesign process since used functional validation starting point hardware software partitioning cosynthesis paper pro poses java programming language specification language hardwaresoftware systems java several characteristics make suitable system specification however static control dataflow analysis java programs problematic java classes dynamically linked paper provides general solution problem statically analyzing java programs using technique preallocates class instances aggressively resolve memory aliasing using global analysis output analysis control dataflow graph input specification results sample designs show analysis extract fine coarsegrained concurrency subsequent hardwaresoftware partitioning cosynthesis steps hardwaresoftware co design process exploit b introduction hardwaresoftware system solutions increased popularity variety design domains 1 systems provide high performance flexibility mixed hardwaresoftware implementations number benefits hardware components provide higher performance achieved software certain timecritical subsystems hardware also provides interfaces sensors actuators interact physical envi ronment hand software allows designer specify system high levels abstraction flexible environment errors even late stages design rapidly corrected 2 software therefore contributes decreased timetomarket decreased system cost hardwaresoftware system design broken following main steps system specification parti tioning cosynthesis first step automatic hardwaresoftware codesign process establish complete system specification specification used validate desired behavior without considering implementation details functional validation system specification critical keep system development time short functional errors easier fix less costly handle earlier development process given validated system specification hardwaresoftware partitioner step divides system hardware software subsystems necessary interfaces analyzing concurrency available specification partitioner maps concurrent blocks communicating hardware software components order satisfy performance cost constraints design final cosynthesis step generates implementations different subsystems generating machine code software subsytems hardware configuration data hardware subsystems system specification critical step codesign methodology drives functional validation step hardwaresoftware partitioning process thus choice specification language important functional validation entails exploration design space using simulation hence specification must allow efficient execution requires compile runtime environment efficiently maps specification onto generalpurpose processor platforms hand partitioning process requires precise input specification whose concurrency clearly identified generating precise specification requires language constructs abstractions directly correspond characteristics hardware software traditionally designers able reconcile two objectives one specification language instead forced maintain multiple specifications obviously maintaining multiple specifications design best tedious due need keep specifications synchronized also errorprone different specification languages tend different programming models semantics need multiple specifications due shortcomings current specification languages used hardwaresoftware codesign hardwaresoftware specification languages currently used system designers divided software programming languages hardware description languages software languages c c generate highperformance executable specifications system behavior functional validation software languages traditionally based sequential execution model derived execution semantics general purpose processors however software languages generally support modeling concurrency dealing hardware issues timing events deficiencies overcome providing designer library packages emulate missing features 15 serious problem software languages allow use indirect memory referencing difficult analyze statically makes difficult static analysis extract implicit concurrency within specification hardware description languages verilog 5 vhdl 6 optimized specifying hardware support variety hardware characteristics hierarchy finegrained con currency elaborate timing constructs esterel another specification language similar verilog constructs handling exceptions 7 speccharts builds graphical structural hierarchy using vhdl specify implementations various structures hierarchy 4 languages highlevel programming constructs limits expressiveness makes difficult specify software fur thermore languages based execution models require great deal runtime interpretation eventdriven semantics results lowperformance execution compared software languages paper advocates use java single specification language hardwaresoftware systems identifying language characteristics enable efficient functional validation concurrency exploration hardwaresoftware partitioner java generalpur pose concurrent objectoriented platformindependent programming language 10 java implementationindependent runtime environment abstract machine called java virtual machine jvm instruction set called bytecodes 11 virtual machine uses stackbased architecture therefore java bytecodes use operand stack store temporary results used later bytecodes java programs set objectoriented framework consist multiple classes compiled binary representation called classfile format representation lays class information including classs data fields methods whose code segments compiled bytecodes fields methods optionally declared static static fields methods class shared instances class nonstatic fields methods duplicated new instance data types java either primitive types integers floats characters references pointers class instances arrays 10 since java classes predominantly linked runtime references class instances cannot resolved compile time presents challenge static analyzers determining data flow data field accesses control flow method calls paper also outlines controldataflow analysis technique used framework detecting concurrency design analysis technique provides general solution problem dynamic class allocation aggressively preallocating class instances compiletime performing global reference analysis rest paper organized follows section 2 explain java wellsuited hardwaresoftware system specification section 3 identify problems arise analyzing java programs present general solution building control flow dataflow dependence information apply technique three sample designs analyze explicit implicit concurrency designs section 4 conclude briefly discuss future directions section 5 hardwaresoftware specification java desirable hardwaresoftware codesign process use single specification language design entry specifications using different languages software hardware combine different execution mod els makes specifications difficult simulate analyze researchers begin software programming language usually c extend language constructs support concurrency timing events providing library packages adding new language constructs examples approach scenic 15 v 17 take slightly different approach instead requiring designer specify hardware implementation details specification approach designer models complete system algorithmic behavioral fashion software languages wellsuited type modeling specification com plete automatic compilation process used analyze specification identify coarsegrained concurrency described designer uncover finergrained concurrency implicit specification partitioning synthesis steps hardwaresoftware codesign process use concurrency uncovered analysis create optimized hardwaresoftware system specification language used approach must ability specify explicit concurrency make easy uncover implicit concurrency coarsegrained concurrency intuitive designer specify hardwaresoftware systems often conceptualized sets concurrent behaviors 2 java multithreaded language readily express sort concurrency concurrent behaviors modeled subclassing thread class overriding run method encode thread behavior shown figure 1 thread class provides methods suspend resume yield sleep manipulate thread syn chronization however supported lower level using monitors implemented two bytecode operations pro read data loop generate xarray proc xarray process xarray class system static thread proca procb public static void mainstring argv new procaclass new procbclassproca launch threads systemclass procaclassclass class procaclass extends thread boolean synchronized void setxarray write xarray data synchronized arrt getxarray return xarray data public void run done thisxready true int class procbclass extends thread procaclass proca procbclassthread procain public void run done thisxready false process data procbclassclass figure 1 concurrency java vide entry exit monitor sample design shown figure 1 maintains synchronization reading writing xarray methods getxarray setxar ray tagged synchronized finegrained concurrency usually either nonintuitive cumbersome designer express spec ification implies automated codesign tool must able uncover finegrained concurrency analyzing specification primary form concurrency look looplevel concurrency multiple iterations loop executed simultaneously form concurrency important detect algorithms generally spend time within core loops identifying exploiting parallel core loops thus provide significant performance enhancements determining whether loop iterations parallel requires analysis statically determine data dependencies exist across loop iterations run method proca class shown figure 1 computexarray call depend values generated previous iterations forloop iterations loop may executed simultaneously major hurdle data dependence analysis must overcome dealing memory references references introduce level indirection reading writing physical memory locations compiletime analysis conservative handling refer ences conservatism necessary guarantee correct system behavior across transformations introduced partitioning step based results analysis ever conservatism causes analysis generate false data dependences nonexistent system lev el dependences reduce data parallelism analysis detects simple design shown figure 1 without ability analyze dependences within forloop across associated method call conservative analysis would determine loop iterations interdependent hence performed sequentially reducing degree data parallelism section specification 100fold advantage java language like c java restricts programmers use memory references java memory references strongly typed also references strictly treated object handles memory addresses consequently pointer arithmetic disallowed restrictive use references enables aggressive analysis reduce false data dependences codesign specification language provide highperformance execution enable rapid functional val idation javas execution environment uses virtual chine jvm provides platformindependence however independence requires java code executed interpreter reduces execution performance compared identical specification modeled c although performance degradation least order magnitude suns jdk 10 runtime environ ment techniques justintime compilation closing performance gap less twotimes c1216 evolution java tools technology driven javas success mains especially networkbased applications moreover java runtime environment makes easy instrument gather profiling information used guide hardwaresoftware partitioning analyzing java programs control dataflow analysis java specification required partitioning cosynthesis steps codesign process analysis examines bytecodes invoked methods determine relative ordering data dependencies bytecodes operand result types either primitive types classes ar rays primitive types always handled value class array variables handled reference object class instance references pointers however wellbehaved compared cc counterparts references strongly typed cannot manipulated object references point class instances linked dynamically runtime prior executing java program allocate static fields methods programs classes makes difficult statically analyze java programs object references cannot resolved calls methods dynamically linked objects cannot resolved either makes impossible determine control flow way deal problem conservatively assign method invocation software software runtime system handle dynamic resolution however reduces opportunities extracting parallelism hardware thus leads inferior hardwaresoftware design order avoid problem dynamically linked objects specification could restricted use static fields methods forced allocate necessary objects linearly beginning program ever would significantly restrict use language solution attempt preallocate objects static analysis noted approach handle class instantiations within loops recursive method invocations preallocation partially solves problem dynamically allocated class instances class reference point instance compatible class type fore two references compatible class types alias conservative handling reference aliasing reduces apparent concurrency specification aggressive reference aliasing analysis requires global dataflow analysis determine class instance set instances reference may point outline analysis technique shown figure 2 analysis starts static main method method processed local analysis performed determine local control dataflow next methods invoked current method recursively analyzed fi nally reference pointto values resolved order determine global data dependence information elaborating techniques used perform local global analyses describe target representation cdfg cdfg representation shown figure 3 involves two main structures first structure table static preallocated class instances aside object accounting information table maintains list entries per object entry represents either method non figure 2 analysis technique outline processmethod currentmethod perform local analysis currentmethod build local control flow information resolve local dependencies preallocate new instantiations inside loops recursion method invoked processmethod invokedmethod resolve reference global analysis impacted invokedmethod resolve global dependencies given complete reference analysis processmethod main figure 3 target representation method call graph basic block control flow preallocated entities static entities graph primitive type data field data field entry necessary global analysis data fields global scope life instances arrays treated exactly class instances fact arrays modeled classes methods method entries point portions second main structure representation second structure control dataflow information nodes bytecode basic blocks edges represent local control flow basic blocks within methods well global control flow across method invocations returns cdfg representation models multithreading exceptions using special control flow edges annotate information thread operation performed exception trapped thread operations java implemented methods thread class cdfg abstracts invocations methods encoding associated operation control flow edge corresponding method call example java threads initiated invoking thread class start method cdfg encounters invocation start method new control flow edge inserted invocation start threads run method edge also indicates new thread forked hand exceptions java use trycatch blocks code may cause exception placed inside try clause followed one subsequent catch clauses catch blocks trap specified thrown exception execute corresponding handler code cdfg inserts special control flow edges block may cause exception handler block edges annotated type exception handler trap ping example exceptions handled shown figure 4 31 step targets particular method identifying sequencing basic blocks capture local control flow also resolves local dependencies two distinct lev els first since java bytecodes rely operand stack arithmetic handler code exception figure 4 exception edges cdfg try int catch arithmeticexception e handler code intermediate results extra level dependency indirection stack needs factored achieved using bytecode numbering second dependencies local method variables identified using reaching definition dataflow analysis flow represented methods basic blocks corresponding sequenc ing basic blocks sequences bytecodes first bytecode directly reached outside block first bytecode executed bytecodes sequentially executed control flow edges simply represent predecessorsuccessor ordering basic blocks analysis dependencies exist bytecodes extra level indirection operand stack resolve indirection using bytecode numbering bytecode numbering simply denotes replacement stack semantics bytecode analyzed physical operands point bytecode generated required result simply achieved traversing methods bytecodes program order instead executing bytecode stack behavior simulated using compiletime operand stack opstack bytecode reads data stack entries popped opstack new operands created values retrieved stack bytecode writes result stack pointer pushed onto opstack process account data requires one stack entry double precision floating point long integer results also stackmanipulating bytecodes dup duplicate top entry swap swap top two entries interpreted manipulating opstack accordingly bytecodes discarded since longer needed purposes code functionality outline example bytecode numbering shown figure 5 data dependencies across local variables resolved computing reaching definitions particular method definition variable bytecode may assign value variable definition reaches point p exists path position p definition overwrites encountered reaching definitions computed would clear exists data dependency bytecode bytecode n defines local variable used n ms definition reaches point immediately following n computing reaching definitions uses iterative dataflow worklist algorithm 8 algorithm iterates basic blocks particular basic block propagates definitions overwrite join point multiple control branches set reaching definitions union individual sets algorithm iterates set successors basic blocks whose output set reaching definitions changes converges changes sets reaching definitions materialize 32 global analysis handle data dependencies references global analysis generates reference set object instances may point set preallocated instances pointsto relation determined simple dataflow analysis techniques global reaching definition compute dataflow dependencies references straightforward solution examine entire control flow graph treating method invocations regular control flow edges iterative dataflow analysis generate pointsto information every refer ence however approach suffers problem unrealizable paths cause global aliasing information propagate one invocation site noncorresponding return site 9 figure 5 bytecode numbering example179iload1 ldcw 4 ireturn ireturn initialize symbolic operand stack opstack empty traverse basic blocks reverse postorder current bytecode reads data stack pop opstack appropriate bytecode operand slot current bytecode writes data stack push bytecodes pc unto opstack push local variable onto operand stack push constant onto operand stack pop two entries first second jump pc 9 pop entry return method entry return value pop entry return method entry return value opstack status current bytecode 9 iconstm1 8 ireturn contextsensitive solution motivated 9 generate transfer function method summarize impact invoking method globally accessible data references variables transfer function maps formal method parameters references addition set variables extended include global references used inside method 1 creating new instances 2 invoking methods return object references 3 accessing class instance fields references input transfer function initial pointsto values extended parameters set output generated transfer function final pointsto values extended parameters due method invocation transfer function summary accesses reads writes methods extended parameters generated using interval analysis 8 accesses ordered according methods local control flow infor mation accesses one following five primitive operations read assign new meet invoke read primitive requires one operand reference result set potential class instances reference points assign primitive used summarize assignment whose lefthand side extended parameter requires two operands first target ref erence second set potential pointto instances new primitive indicates creation new class stance primitive returns set composed single stance preallocation possible within loop recursion otherwise conservatively pointsto set compatible class instances meet primitive necessary handle joining branches control flow meet point alias set reference assigned one meeting branches union alias sets reference meeting control flow edges finally invoke primitive used resolve change reference alias sets due invoking meth od effectively primitive causes transfer function invoked method executed somemethod obj obj b new obj test1 figure 6 transfer functions global reference analysis tfsomemethod assign new obj 4 experimental results hardwaresoftware systems multiprocess sys tems partitioning cosynthesis tools map behavioral specifications systems need make hardwaresoftware tradeoffs 13 make tradeoffs objective maximizing costperformance mixed implementation necessary able identify concurrency input specification implemented java frontend analysis step standalone compilation pass reads designs class files generates corresponding cdfg representation tested technique using designs listed table 1 first design raytracer simple graphical appli cation renders two spheres top plane shadows reflections due single specular light source second application robotarm robot arm control ler third design decoder digital signal processing application featuring video decoder h263encoded bitstreams 14 resulting controldataflow graphs analyzed identify concurrency specification analysis examined concurrency three levels threadlevel loop level bytecodelevel threadlevel concurrency exhibited communicating concurrent processes span control flow several methods looplevel concurrency exhibited core loops usually confined single method bytecodelevel concurrency exhibited bytecode operations proceed provided data dependencies satisfied irrespective control flow dering form concurrency exists within basic blocks threadlevel concurrency explicitly expressed designer java threads since threads uniquely identified cdfg work required uncover form parallelism looplevel concurrency requires analysis control dataflow information associated inner loops identify data dependencies spanning different loop iterations determine true dependencies dependencies write iteration loop read subsequent itera tion loops independent iterations execute iterations concurrently minithreads coarsegrained concurrency expressed thread loop level lines java classes instances basic blocks raytracer 698 6 37 358 table 1 design characteristics exploited allocating threads different subsystems target architecture hand bytecodelevel concurrency cdfg span multiple basic blocks exists bytecode level within basic block degree depends basic blocks interbytecode data dependencies finegrained concurrency impacts performance improvement hardware implementation basic block hardware inherently parallel therefore parallelism design implemented without cost overhead given enough structural resources support parallelism limitation degree parallelism synchronization due data dependencies hence execution time block hardware decreases increased data parallelism table 2 presents results analyzing three different forms parallelism sample designs first column indicates number designerspecified threads second column shows number parallelizable loops third column indicates average number bytecodes per loop fourth column shows average number bytecodes per basic block fifth column assesses average data parallelism basic blocks bytecodelevel concurrency measured average number bytecodes execute simultaneously cycle jvm results show possible extract parallelism various levels granularity java programs 5 conclusions future work specification language starting point hardwaresoftware codesign process described key requirements language specification language expressive design concepts easily modeled provide representation relatively easy analyze optimize performance language also provide highperformance exe cution shown java programming language satisfies requirements threadlevel concurrency looplevel concurrency bytecodelevel concurrency number threads number loops avg bytecodes per loop avg basic block avg bytecode parallelism decoder 3 28 27 71 25 table 2 parallelism assessment results able partition eventually cosynthesize input java specifications must able analyze specification however major problem facing analysis step java dynamic links class instances make static analysis possible proposed technique relies aggressive reference analysis resolve ambiguity global control dataflow technique generates control dataflow graph representation specification results show using technique possible extract concurrency exploited java specification future analysis technique serve frontend codesign tool maps java system specification target architecture composed one microprocessors tightly coupled programmable hardware resources acknowledgments work sponsored arpa grant mip dabt 6395c0049 r hardwaresoftware co design specification design embedded hardwaresoftware systems specification design embedded systems verilog hardware description language ieee inc esterel synchronous programming language design semantics implementation compilers principles efficient contextsensitive pointer analysis c programs java language specification java virtual machine specification java performance advancing rapidly multipleprocess behavioral synthesis mixed hardwaresoftware systems enhanced h efficient implementation reactivity modeling hardware scenic design environment compiling java time v systems design language tr compilers principles techniques tools esterel synchronous programming language specification design embedded systems efficient contextsensitive pointer analysis c programs multipleprocess behavioral synthesis mixed hardwaresoftware systems efficient implementation reactivity modeling hardware scenic design environment verilog hardware description language 4th ed java virtual machine specification java language specification specification design embedded hardwaresoftware systems compiling java time ctr tommy kuhn wolfgang rosenstiel udo kebschull description simulation hardwaresoftware systems java proceedings 36th acmieee conference design automation p790793 june 2125 1999 new orleans louisiana united states tommy kuhn wolfgang rosenstiel java based object oriented hardware specification synthesis proceedings 2000 conference asia south pacific design automation p579582 january 2000 yokohama japan kuhn oppold c schulzkey winterholer w rosenstiel edwards kashai object oriented hardware synthesis verification proceedings 14th international symposium systems synthesis september 30october 03 2001 montral pq canada josef fleischmann klaus buchenrieder rainer kress java driven codesign prototyping networked embedded systems proceedings 36th acmieee conference design automation p794797 june 2125 1999 new orleans louisiana united states peter l flake simon j davidmann superlog unified design language systemonchip proceedings 2000 conference asia south pacific design automation p583586 january 2000 yokohama japan josef fleischmann klaus buchenrieder rainer kress hardwaresoftware prototyping environment dynamically reconfigurable embedded systems proceedings 6th international workshop hardwaresoftware codesign p105109 march 1518 1998 seattle washington united states fin f fummi protected ipcore test generation proceedings 12th acm great lakes symposium vlsi april 1819 2002 new york new york usa kuhn oppold winterholer w rosenstiel marc edwards yaron kashai framework object oriented hardware specification verification synthesis proceedings 38th conference design automation p413418 june 2001 las vegas nevada united states martin radetzki ansgar stammermann wolfram putzkerming wolfgang nebel data type analysis hardware synthesis objectoriented models proceedings conference design automation test europe p101es january 1999 munich germany alessandro fin franco fummi webcad methodology ipcore analysis simulation proceedings 37th conference design automation p597600 june 0509 2000 los angeles california united states j zhu static memory allocation pointer analysis coloring proceedings conference design automation test europe p785790 march 2001 munich germany rachid helaihel kunle olukotun jmtp architecture exploiting concurrency embedded java applications realtime considerations proceedings 1999 ieeeacm international conference computeraided design p551557 november 0711 1999 san jose california united states cindy eisner irit shitsevalov russ hoover wayne nation kyle nelson ken valk methodology formal design hardware control application cache coherence protocols proceedings 37th conference design automation p724729 june 0509 2000 los angeles california united states jianwen zhu daniel gajski openj extensible system level design language proceedings conference design automation test europe p99es january 1999 munich germany james shin young josh macdonald michael shilman abdallah tabbara paul hilfinger richard newton design specification embedded systems java using successive formal refinement proceedings 35th annual conference design automation p7075 june 1519 1998 san francisco california united states c schulzkey winterholer schweizer kuhn w rosenstiel objectoriented modeling synthesis systemc specifications proceedings 2004 conference asia south pacific design automation electronic design solution fair p238243 january 2730 2004 yokohama japan srgio akira ito luigi carro ricardo pezzuol jacobi system design based single language singlechip java asip microcontroller proceedings conference design automation test europe p703709 march 2730 2000 paris france marcello dalpasso alessandro bogliolo luca benini virtual simulation distributed ipbased designs ieee design test v19 n5 p92104 september 2002 verkest joachim kunkel frank schirrmeister system level design using c proceedings conference design automation test europe p7483 march 2730 2000 paris france marcello dalpasso alessandro bogliolo luca benini specification validation disstributed ipbased designs javacad proceedings conference design automation test europe p132es january 1999 munich germany axel jantsch per bjurus composite signal flow computational model combining events sampled streams vectors proceedings conference design automation test europe p154160 march 2730 2000 paris france brian grattan greg stitt frank vahid codesignextended applications proceedings tenth international symposium hardwaresoftware codesign may 0608 2002 estes park colorado marcello dalpasso alessandro bogliolo luca benini virtual simulation distributed ipbased designs proceedings 36th acmieee conference design automation p5055 june 2125 1999 new orleans louisiana united states malay haldar anshuman nayak alok choudhary prith banerjee system synthesizing optimized fpga hardware matlab proceedings 2001 ieeeacm international conference computeraided design november 0408 2001 san jose california nayak haldar choudhary p banerjee precision error analysis matlab applications automated hardware synthesis fpgas proceedings conference design automation test europe p722728 march 2001 munich germany annette bunker ganesh gopalakrishnan sally mckee formal hardware specification languages protocol compliance verification acm transactions design automation electronic systems todaes v9 n1 p132 january 2004
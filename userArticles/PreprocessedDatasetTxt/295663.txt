new simpler lineartime dominators algorithm present new lineartime algorithm find immediate dominators vertices flowgraph algorithm simpler previous lineartime algorithms rather employ complicated data structures combine use microtrees memoization new observations restricted class path compressions implemented algorithm report experimental results show constant factors low compared standard slightly superlinear algorithm lengauer tarjan much less overhead algorithm runs 1020 slower real flowgraphs reasonable size percent slower large flowgraphs b introduction consider problem nding immediate dominators vertices graph owgraph directed graph r distinguished start vertex path r vertex v vertex w dominates vertex v every path r v includes w w immediate dominator idom v denoted dominates v 2 every vertex x dominates v also dominates w every vertex owgraph unique immediate dominator aho ullman 1972 lorry medlock 1969 finding immediate dominators owgraph elegant problem graph ory applications global ow analysis program optimization aho ullman 1972 cytron et al 1991 ferrante et al 1987 lorry medlock 1969 lorry medlock 1969 introduced 4 time algorithm nd immediate dominators owgraph successive improve material presented thirtieth acm symposium theory com puting 1998 authors address att labs shannon laboratory 180 park ave florham park nj 07932 permission make digitalhard copy part material without fee granted provided copies made distributed prot commercial advantage acm copyrightserver notice title publication date appear notice given copying permission association computing machinery inc acm copy otherwise republish post servers redistribute lists requires prior specic permission andor fee c 2 adam l buchsbaum et al ments time bound achieved aho ullman 1972 purdom moore 1972 tarjan 1974 culminating lengauer tarjans 1979 ommntime algorithm standard functional inverse ackermann function grows extremely slowly n tarjan van leeuwen 1984 lengauer tarjan 1979 report experimental results showing algorithm outperforms previous dominators algorithms owgraph sizes appear practice reducing asymptotic time complexity nding dominators interesting theoretical exercise furthermore various results compiler theory rely existence lineartime dominators algorithm pingali bilardi 1997 give example references harel 1985 claimed lineartime dominators algorithm careful examination abstract reveals problems arguments alstrup et al 1997 detail problems harels approach oer lineartime algorithm employs powerful data structures based bit manipulation resolve problems achieve lineartime dominators algorithm reliance sophisticated data structures adds sucient overhead make implementation impractical present new lineartime dominators algorithm simpler alstrup et al 1997 algorithm requires complicated data structures use depthrst search fast unionnd data structure tarjan van leeuwen 1984 topological sort memoization implemented al gorithm report experimental results show even extra overhead needed achieve linear time constant factors low rst implementation lineartime dominators algorithm rest article organized follows section 2 outlines lengauer tarjans approach section 3 gives broad overview algorithm dieren tiates previous work section 4 presents algorithm detail section 5 analyzes running time section 6 presents new pathcompression result analysis relies section 7 describes implementation section 8 reports experimental results conclude section 9 2 lengauertarjan algorithm outline lengauer tarjan lt approach lengauer tarjan 1979 high level provide details needed algorithm appel 1998 provides thorough description lt algorithm r input owgraph n vertices arcs let depthrst search dfs tree g rooted r sometimes refer vertex x dfs number particular x means xs dfs number less ys let w w ancestor necessarily proper v also denote actual tree path similarly w w proper ancestor v represent corresponding path tree v parent v let nca u v nearest common ancestor u v drop subscripts write pv ncau v context resolves ambiguity v path g lengauer tarjan dene p semidominator path abbreviated sdom path x v 1 1 sdom path u v thus avoids tree vertices u new simpler lineartime dominators algorithm 3 a13 d14 a13 d14 b fig 1 owgraph g root r vertex labels augmented dfs numbers b dfs tree g solid arcs tree arcs dotted arcs nontree arcs breaking microtrees size 3 results four nontrivial microtrees rooted k j g vertices nontrivial microtree encircled v semidominator semi vertex v sdom path u vg example consider vertex g dfs tree figure 1a dfs number g 10 paths e g f g f g f g b f g b f g sdom paths g since b least dfs number initial vertices paths compute semidominators lengauer tarjan use auxiliary linkeval data structure operates follows let tree real value associated vertex wish maintain forest f contained tree subject following operations initially f contains arcs f let r root tree containing u f return r otherwise return vertex x 6 r minimum value path r u tarjan 1979a shows implement link eval using standard disjoint set union data structure tarjan van leeuwen 1984 using linking size path compression n 1 links evals nvertex tree performed ommn n time lt algorithm traverses reverse dfs order computing semidominators follows initially semiv v reverse dfs order w v 2 4 adam l buchsbaum et al done linkv done computes immediate dominator vertex using semidominators following facts also use design algorithm lemma 21 lt lem 1 v w path v w g must contain common ancestor v w lemma 22 lt lem 4 vertex v 6 r idomv semiv lemma 23 lt lem 5 let vertices w v satisfy w v w idomv idomw lemma 24 lt thm 2 let w 6 r suppose every u semiw lemma 25 lt thm 3 let w 6 r let u vertex semiu minimum among vertices u satisfying semiw 3 outline lineartime algorithm links evals used lt algorithm make run ommn time eliminate n term exploiting sensitivity relative dierences n particular slightly superlinear n eg mn becomes constant tarjan van leeuwen 1984 1 dominators algorithm proceeds roughly follows 1 compute dfs tree g partition regions discuss partitioning detail section 32 suces consider partitioned collection small vertexdisjoint regions called microtrees consider separately microtrees bottom dthose contain leaves dfrom microtrees comprising interior 0 2 vertex determine whether idom microtree determine actual idom 3 vertex v idomv vs microtree compute idomv applying lt algorithm vertices 0 b nd ancestor u v idomu computed applying lt algorithm vertices 0 partitioning microtrees serves two purposes first subgraph induced microtree roots achieve ratio mn necessary reduce n constant second microtrees small enough number distinct microtrees small compared n thus perform simple computations microtree using precomputed tables memoization eliminate redundant computations log n iterated log function log 0 new simpler lineartime dominators algorithm 5 31 comparison previous approaches contrast use facts previous approaches harel 1985 alstrup et al 1997 apply lt algorithm using microtree partitioning speed links evals harel 1985 divides entire tree microtrees contain one vertex performs links evals described lengauer tarjan 1979 tree 0 induced microtree roots alstrup et al 1997 simplify harels approach harel 1985 restricting nonsin gleton microtrees bottom leaving upper subtree 0 singleton microtrees perform links evals 0 using two novel data structures well gabowtarjan lineartime disjoint set union result gabow tarjan 1985 transformations 0 algorithms use precomputed tables process evals internal microtree vertices approach requires information regarding vertices outside microtrees might dominate vertices inside microtrees derive ecient encodings needed table lookup technique harel 1985 presents method restrict set outside dominator candidates alstrup et al 1997 demonstrate deciencies harels arguments correct problems using fredman willards qheaps fredman willard 1994 manage microtrees apply lt algorithm upper portion 0 combine partitioning scheme new path compression result show lt algorithm runs linear time 0 instead processing links evals internal microtree vertices determine using simple dominators algorithm whether dominators vertices internal microtrees compute directly using memoization eliminate redundant computation process vertices dominators outside microtrees without performing evals internal microtree vertices approach obviates need determine outside dominator candidates internal microtree vertices eliminating additional complexity alstrup et al require manage information thus summarize key dierences various approaches follows harel 1985 alstrup et al 1997 partition microtrees apply standard lt algorithm using precomputed tables speed computation linkeval data structure microtrees also partition microtrees apply lt algorithm linkeval data structure unchanged one big region use memoization speed computation dominators microtrees words harel 1985 alstrup et al 1997 take purely data structures approach leaving lt algorithm unchanged employing sophisticated new data structures improve running time modify lt algorithm although becomes slightly complicated simple standard data structures suce implement minor dierence two approaches regards use tables harel 1985 alstrup et al 1997 precompute answers possible queries mi crotrees use table lookup answer queries actual dominators computation build corresponding table incrementally using memo ization computing entries actually needed given instance two approaches identical asymptotic time complexities memoization tends outperform priori tabulation practice former compute 6 adam l buchsbaum et al answers queries never needed 32 microtrees consider following procedure marks certain vertices parameter g given initially vertices unmarked x reverse dfs order child x sy sx g mark children x endif done mark rootd vertex v let nmav nearest marked ancestor necessarily proper v nma function partitions vertices microtrees follows let v marked vertex vg microtree containing vertices x v nearest marked ancestor x say root microtree v vertex x microx microtree containing x see figure 1 v v g descendents children v marked fore microtree size g call microtree nontrivial contains leaf nontrivial microtrees contain one vertex subtrees process using memoization remaining microtrees call trivial composed singleton internal vertices vertices comprise upper subtree 0 additionally children vertex forms trivial microtree microtree roots call vertex v forms trivial microtree special child v root nontrivial microtree figure 1b c e special vertices remove nontrivial microtrees special vertices would leaves resulting tree since special vertex g descendents descendents two special vertices form disjoint sets ong special vertices note alstrup et al 1997 dene microtrees include leaves nontrivial microtrees whereas denition makes every vertex member microtree could adopt alstrup et al 1997 denition dening microtree vertex allows uniformity discussion particularly statements proofs lemmas theorems gabow tarjan 1985 pioneered use microtrees produce lineartime disjoint set union algorithm special case unions known advance work microtrees combined microsets precomputed tables generated microsets dixon tarjan 1997 introduce idea processing microtrees bottom tree 33 path denitions v path g dene p external dominator path abbreviated xdom path p sdom path dominator path simply semidominator new simpler lineartime dominators algorithm 7 path resides wholly outside microtree target vertex hits target vertex external dominator vertex v xdom path u vgg particular vertex v forms singleton microtree dene p pushed external dominator path abbreviated pxdom path nontrivial microtrees occur bottom pxdom path v cannot exit reenter microv would require traversing back arc proper ancestor rootmicrov therefore pxdom path v xdom path vertex x 2 microv catenated b xtov path inside microv either b may null path pushed external dominator vertex v pxdom path u vg note pxdomv 62 microv since arc p rootmicrov rootmicrov catenated tree path rootmicrov pxdom path v pxdomv pd rootmicrov example consider vertices l h dfs tree figure 1b dfs number l 4 path sdom path r l xdom path path c j l xdom path c l xdom path exists r l 2 p pxdom path however r b e n xdom path r n 2 microl n l path internal microl thus semil continuing dfs number h 12 sdom path h g h path b f g h pxdom path h however general vertex semi xdom pxdom values need match use following lemmas note similarity lemma 32 lemma 22 lemma 31 vertex v forms singleton microtree semiv proof let v pxdom path u v v forms singleton microtree denition pxdom x v 1 k without loss generality however since u minimum vertex pxdom path v assume x 6 v 1 k therefore p semidominator path semiv u semidominator path however pxdom path fact lemma 32 idomv 62 microv idomv pxdomv proof let observed u 62 microv denition pxdom path u v avoids vertices u tree path u therefore idomv 62 microv idomv cannot lie tree path next section give details algorithm 4 details lineartime algorithm high level abstract algorithm follows 8 adam l buchsbaum et al f f b fig 2 microtree consisting vertices f figure 1b well incident arcs external b induced graph augt 1 using memoization reduce running time determine vertex v actual value idomv 2 use lt algorithm compute idoms v idomv 62 microv remainder section provides details behind approach clarity describe separate phases resolution idomv 2 microv question computation pxdomv overall algorithm compute idomv discuss section 7 unite phases one traversal 41 computing internal dominators begin showing determine whether idomv 2 microv nd actual value idomv vertex v comprises singleton microtree decision trivial idomv 62 microv nonsingleton microtree dene following augmented graph let gt subgraph g induced vertices let augt graph gt plus following 1 vertex call root augt rootaugt 2 arc v v 2 exists arc u v 2 call blue arcs note blue arc roott vertex represents contraction ignoring arcs exit see figure 2 use augmented graphs capture intuition removing arcs exit microtree 2 change dominator relationship dene internal immediate dominator iidom vertex x iidomx immediate dominator x augmicrox show iidomx 2 conversely computing iidoms using memoization augmicrov thus yields fast procedure deter exits microu v 62 microu new simpler lineartime dominators algorithm 9 x z x b fig 3 augmicrox plus incident external arcspaths g solid lines arcs dotted lines paths case z z 62 microx eg gure path x augt using blue arc v avoids gure path internal microt z x avoids either case contradicts assumption iidomx b similar case z path p augt x avoiding z p contains blue arcs path g contradicting z idomx mine whether idomv 2 microv v give details memoization procedure lemma 41 iidomx 6 rootaugmicrox proof let idomx 6 6 z z full graph g exists path p z x avoids use p demonstrate path p 0 augt z 0 2 ft zg x avoids contradicting assumption v last arc p u 62 augt arc p yields immediate contradiction otherwise arc u v induces blue arc v 2 augt arc together subpath p v x provides path p 0 see figure 3a hand z path p augt x avoids z hypothesis 6 p contains blue arcs arcs 62 p therefore p also path g contradicting z idomx figure 3b lemma 42 proof let path p augt x avoids z p contains blue arcs path original graph contradicting claim z idomx p contains blue arc v v g arc u v u 62 tree path rootg catenated arc u v subpath p v x gives path g x avoids z x fig 4 augmicrox plus incident external arcspaths g solid lines arcs dotted lines paths case path p augt x avoiding z p contains blue arcs follows path b around z contradicts z idomx p exists g p contains blue arc v path g x using arc u v u 62 p avoids z contradicting z giving contradiction see figure 4 memoize computation iidomv follows rst time compute internal immediate dominators augmented graph augt store results table indexed graph augt vertex v encode augt bit string corresponding adjacency matrix represented rowmajor order compute bit string traverse augt dfs order assigning dfs value one root augt using dfs values vertex identiers refer canonical encoding augt subsequent microtree 0 augmented graph isomorphic encodings identical simply look iidom values augt 0 table obviates recompute iidoms augt 0 simply map iidom values stored table relative canonical encoding augt 0 current instantiation augt 0 vertex x augt 0 corresponds vertex x rootaugt canonical encoding augt 0 42 computing pushed external dominators prove following procedure labels vertices pxdoms show process allows us avoid performing links evals within nontrivial microtrees initially use linkeval data structure labelv value vertex v see theorem 44 pxdomv v becomes linked linkeval values thus pxdoms microvg external neighbors v vertices outside microv arcs v procedure processes microtrees new simpler lineartime dominators algorithm 11 reverse dfs order 1 6 c labelv minfvg lemma 43 proves labels v xdomv 2 v set vertices path consisting arcs gt set labelv min y2y v flabelyg call pushing v pushing done computing strongly connected components gt processing topological order theorem 44 proves pushing labels v pxdomv trivial microtree linkv due pushing step 2 pxdom values nonincreasing along paths microtree root allows us perform evals parents microtree roots pxdom pushing eectively substitutes evals vertices inside microtrees prove procedure correctly labels vertices microtree assume induction procedure already labeled pxdoms vertices trees preceding reverse dfs order base case vacuously true lemma 43 step 1 proof let show 1 labelx w 2 labelx w 1 consider xdom path p w x let 62 microx last vertex p x let z least vertex excluding w p touches tree path w else p xdom path prex p 0 p w z semidominator path otherwise exists u 6 w p 0 u z lemma 21 p 0 contains common ancestor u z contradicting assertion z least vertex p tree path therefore pxdomz semiz w induction labelz w z 2 microy labelz got pushed thus labely w note step 1 z 62 microy c step 1 contains value greater labelz due previous links via step 3 either case label considered x via x arc greater labelz w figure 5 2 consider arc x 62 microx let pxdom path p w 0 p catenated arc x xdom path similarly pxdom path p w labelz z p catenated tree path z arc x forms xdom path w 0 x either case figure 5 demonstrates potential paths theorem 44 step 2 12 adam l buchsbaum et al x fig 5 microtrees containing x incident external paths solid lines arcs dotted lines paths sdom path w z ncay x thus gure labely w z 62 microy gure labelevalrootmicroy w proof argue analogously proof lemma 43 let show 1 w considered label x via internal pushing path 2 w 0 considered valid pxdom path w 0 x 1 consider pxdom path p w x let v rst vertex p inside step 2 w pushed x via path v x 2 consider w 0 pushed x w 0 xdom pxdom vertex 2 valid pxdom path w 0 x 43 computing dominators using information computed sections 41 42 give algorithm compute immediate dominators algorithm proceeds like lt algorithm fact subtree induced trivial microtrees exactly lt algorithm algorithm relies following two lemmas lemma 45 v exists w 2 microv 3 4 proof proof proceeds follows rst nd appropriate vertex w tree path rootmicrov v show new simpler lineartime dominators algorithm 13 x x b fig 6 graph induced microv plus incident external arcspaths g solid lines arcs dotted lines paths pxdom path x v w least vertex p path rootmicrov v prex p 0 p x w includes vertices greater v except w b p 0 includes descendents w less v must take back arc w either case p 0 sdom path x w since w least vertex p path rootmicrov v argue resolves postulates 13 finally prove idomw 62 microx implies postulate 4 consider pxdom path p x v let w least vertex p tree path rootmicrov v argue prex p 0 p x w semidominator path vertex 6 x p 0 w since w v must 2 microv otherwise violates pxdom path denition since allow v p 2 microv lemma 21 subpath p 0 w contains common ancestor z w since w must z w must also z 2 microv else z violates pxdom path denition implies z tree path rootmicrov v contradicting assertion w least vertex p therefore semiw x see figure 6 argue semiw x semidominator path p x w p catenated tree path w v however forms pxdom path v contradicting assumption similarly argue semidominator path also pxdom path pxdomw x pxdom path p x however p catenated tree path w v pxdom path contradicts assumption x thus shown denition pxdom pxdomw rootmicrow therefore semiw implies semiw 62 microw lemma 22 therefore idomw 62 microw thus lemma 41 lemma 46 let w v vertices microtree 14 adam l buchsbaum et al fig 7 graph induced microv plus incident external arcspaths g dotted lines paths idomv idomw sdom path idomw x idomw tree path x v x lies tree path idomw w gure however contradicts denition idomw x lies tree path w v gure contradicts 3 proof condition 3 lemma 42 imply idomv idomw 62 particular idomv w lemma 23 implies idomv idomw idomv idomw path p idomv v avoids idomw must contain semidominator subpath p 0 idomw x idomw x v x cannot lie tree path idomw would contradict denition idomw x cannot lie tree path w v would imply pxdomv pxdomw lemma 32 idomw pxdomw p 0 exist see figure 7 lemmas 45 46 imply following formalized proof theorem 47 consider path microtree root leaf vertices path partitioned pxdom pxdom values monotonically nonincreasing vertex w top partition thermore idomw 62 microw another vertex v partition w either idomv actually partition else outside microtree see figure 8 implies algorithm devolves lt algorithm upper subtree 0 consisting trivial microtrees compute immediate dominators algorithm idom given figure 9 v 2 idom either computes idomv determines proper ancestor new simpler lineartime dominators algorithm 15 x z c fig 8 microtree incident external paths dotted lines paths vertices tree path w pv pxdom path x b prex xdom path aect pxdom values wpv part partition vertices partition need share idoms however picture u v description straightforward postprocessing phase resolves latter identities idom uses second linkeval data structure pxdomv value vertex v beginning idom links done theorem 47 algorithm idom correctly assigns immediate dominators proof lemma 41 shows assigning idomv iidomv iidomv 2 microv correct assume iidomv 62 microv thus idomv 62 microv lemma 42 consider processing vertex v bucketu assume rst child u tree path u v claim z vertex tree path u 0 v minimum semi assuming claim true observe w 2 microv w pxdomw semiw thus v claim holds hand vertex tree path pd rootmicrov minimum pxdom claim holds since 1 pxdomu 0 consider remaining case pxdomv 6 semiv lemma 45 shows exists w 2 microv w rootaugmicrov pxdomw w placed bucket algorithm idom reverse dfs order processv done fug trivial microtree reverse dfs order linku done processv iidomv 2 microv else add v bucketpxdomv endif z v else z evalp rootmicrov endif idomv u else endif done fig 9 algorithm idom idom therefore idom compute value idomv idomw previous argument computes correct value idomw 5 analysis analyze running time algorithm clear generation initial dfs tree division microtrees performed linear time discussion section 32 51 computation iidoms recall memoized computation iidoms described section 41 iidom computations run linear time overall augmented graphs must small enough 1 unique description possible graph augt computed ojaugt j time 2 immediate dominators possible augmented graphs computable linear time computing immediate dominators augmented graph future table lookups take constant time require description augt one computer word assume holds log n bits recall microtree g vertices parameter g thus augmented graph g1 vertices without aecting time bounds use g 1 place g assume augt g vertices therefore augt g 2 arcs new simpler lineartime dominators algorithm 17 uniquely described string g 2 bits one computer word traverse augt compute bitstring identier ojaugt j time assuming 1 initialize computer word 0 2 set bit computer word o1 time assumes vertices numbered 1 jt j jt j number vertices part dfs g assign secondary dfs numbers v relative rootmicrov satisfying labeling constraint total time generate bitstring identiers thus microtree since vertex respectively arc g attributed one vertex respec tively arc exactly one augmented graph one extra root vertex augmented graph expression rst encountering particular augt use naive dominators algorithm compute immediate dominators polyg time store values iidomv v 2 augt table time ojaugt j worst case would memoize iidom values possible distinct graphs g fewer vertices 2 g 2 graphs total time o2 polyg inducing constraint polyg n simple analysis shows using memoization compute needed iidom values time 52 computation pxdoms step 1 computation initial labeling vertex v processes vertex arc g throughout labelings vertices v additionally step 1 performs one eval operation trivial microtree root per arc g step 2 implemented computing strongly connected components sccs subgraph g induced microtree initially assigning vertex scc minimum label among vertices scc pushing labels sccs topological order computing sccs done linear time tarjan 1972 topological processing sccs step 3 links roott trivial microtree thus time compute pxdoms summed microtrees n plus time perform n 1 link eval operations analyze linkeval time section 6 53 computation idoms implement bucket associated vertex linked list takes constant time look iidomv either assign idomv place v bucketpxdomv process vertex v bucketpxdomv requires constant time plus time perform eval pd rootmicrov vertex appears one bucket processing buckets takes time plus time n evals trivial microtree roots since pxdomv 62 microv trivial microtree roots buckets perform linkv trivial microtree roots total time taken idom om n plus linkeval time 54 summary analysis total time required compute immediate dominators owgraph g n vertices arcs omn plus time perform links evals next prove since links evals trivial microtree roots total linkeval time om n appropriate choice parameter g 6 disjoint set union bottomup linking recall link eval based disjoint set union yielding n term lt time bound show restricting tree apply links evals leaves results corresponding set union operations requiring linear time let u set n vertices initially partitioned singleton sets sets subject standard disjoint set union operations c names sets operation unites sets b names result c ndu returns name set containing u well known tarjan van leeuwen 1984 n 1 unions intermixed nds performed ommn n time sets represented trees forest union operation links root one tree root another operation ndu traces path u root tree containing u linking smaller tree child root larger tree union compressing path u root tree containing u ndu time bound achieved show given sucient restrictions order unions improve time bound know previous result based type restriction previously gabow tarjan 1985 used priori knowledge unordered set unions implement union nd operations om time require advance knowledge unions order constrained results improved bounds path compression buchsbaum et al 1995 loebl nesetril 1997 lucas 1990 generally restrict order nds unions performed n vertices designate l special remainder n l ordinary following theorem shows requiring unions favor small set vertices time bound becomes linear theorem 61 consider n vertices l special remaining n l ordinary let sequence n 1 unions nds new simpler lineartime dominators algorithm 19 union involves least one set contains least one special vertex operations performed omm l proof restriction unions ensures times sequence processed set either contains least one special vertex singleton set containing ordinary vertex observation proved induction number unions following algorithm used maintain sets standard unionnd data structure created containing special vertices singleton sets recall data structure consists forest rooted trees built vertices one tree per set root tree contains name set also array indexed name maps set name root corresponding tree call smaller data structure u 0 denote unions nds union 0 nd 0 ordinary vertices kept separate ordinary vertex contains pointer initially null operations performed follows x names set contains least one special vertex perform union 0 x suppose one x say singleton set containing ordinary vertex set pointer ordinary vertex point root set x relabel root z ndx x special vertex execute nd 0 x x ordinary null pointer return x singleton set x ordinary nonnull pointer special vertex return nd 0 intuition simple unless ordinary vertex x forms singleton set equated special vertex operation involves o1 steps plus possibly operation unionnd data structure u 0 containing l vertices let k total number operations done u 0 total running time okk lmn omm ln convenient implement algorithm completely within framework single standard unionnd forest data structure using path compression union size follows initially special vertices given weight one ordinary vertices given weight zero recall size vertex sum weights descendents including see implementation essentially equivalent described theorem 61 observe following points first induction number operations ordinary vertex always leaf unionnd forest union bysize rule ensures whenever singleton ordinary set united set containing special elements ordinary vertex made child root set standard nd operation done following parent pointers root resetting vertices path point root hence leaf vertex particular ordinary vertex remains leaf forest ordinary vertex thus either singleton root contains pointer special vertex proof theorem 61 furthermore since ordinary vertices weight zero aect size decisions made uniting sets containing special vertices nd ordinary vertex equivalent 20 adam l buchsbaum et al nd parent special vertex proof theorem 61 dierence pointer ordinary vertex possibly changed point dierent special vertex root adds o1 running time 61 bottomup linking let sequence unions u described rooted undirected union tree vertex corresponds element u edges labeled zero one initially labeled zero vertices connected path edges labeled one set labeling edge fv pvg one corresponds uniting sets containing v pv union sequence bottomup linking property edge fv pvg labeled one edges subtree rooted v labeled one corollary 62 let union tree l leaves bottomup linking property n 1 unions nds performed omm l time proof let leaves classed special internal vertices classed ordinary union indicated edge fx pxg occurs descendants x particular least one leaf set x therefore union sequence property hypothesis theorem 61 alstrup et al 1997 prove variant corollary 62 mm l term replaced l log l suces purposes derive weaker result processing long paths unary vertices outside standard set union data structure apply standard set union data structure directly need weight leaves one internal vertices zero 62 application dominators recall denition special vertices section 32 vertex special children roots nontrivial microtrees theorem 63 n links evals performed computation pxdoms algorithm idom require time proof consider subtree induced trivial microtree roots links evals performed vertices special vertices precisely leaves view union tree induced links links performed bottomup due reverse dfs processing order shown section 32 ong special vertices thus ong leaves choose log 13 n suces compute iidoms linear time corollary 62 linkeval time thus omm n log 13 n n theorem follows since n algorithm completely general runs linear time input owgraph g corollary 62 however implies implementing unionnd described standard lt algorithm lengauer tarjan 1979 actually runs linear time classes graphs corresponding dfs trees following property number l leaves suciently sublinear new simpler lineartime dominators algorithm 21 7 implementation section describes implementation diers somewhat earlier description algorithm eciency reasons input owgraph adjacency list format ie vertex v associated list successors figure presents toplevel routines initialize computation perform depthrst search partition dfs tree microtrees compute dominators initialization code creates initializes memoization tables partitioning code assigns dfs numbers initializes vertices stores array vertices dfs order computes size subtree rooted vertex identies microtrees using subtree sizes vertex marked plain mtroot trivmtroot depending whether nonroot vertex microtree root nontrivial microtree root trivial microtree also vertex assigned weight used linkeval computation special vertices recall vertex special children roots nontrivial microtrees weight one ordinary vertices weight zero see lengauer tarjan 1979 implementation link eval finally initialize array pmtroot contain parentv v array eventually store parentrootmicrov v initializing vertex parent update vertices nontrivial microtrees processmt code compute dominators given partitioned dfs tree diers earlier presentation two ways first combine processing vertices buckets single pass eliminate pass vertex set lengauer tarjan 1979 second separate code processing trivial microtrees code processing nontrivial microtrees allows us specialize algorithm situation resulting simpler ecient code changes simple rearrangements code alter time complexity algorithm computedom calls processv handle trivial microtrees processmt handle nontrivial microtrees processv shown figure 11 computes xdom pxdom v stores v appropriate bucket links v parent processes bucket vs parent code exhibits changes first follow lt approach combining processing vertices buckets link v p parent process ps bucket immediately following processing v vertices subtree rooted v ps bucket adding link v p completes path vertex p allows us process bucket second exploit idomv guaranteed outside vs microtree thereby eliminating conditional expression processmt figure 12 performs similar steps complex processes entire microtree rst step nd microtrees root since vertices microtree contiguous dfs numbers nd root searching backward v vertices array rst vertex marked nontrivial microtree root microtree root update pmtrootv appropriately v microtree 1 compute xdom vertex microtree encoding augmented graph corresponds microtree 2 compute iidoms 3 compute pxdoms 22 adam l buchsbaum et al initialize computation partitionroot statusroot trivmtroot computedomroot partitionvertex v assign dfs number v mark v visited bucketv null linkv null labelv dfsnumv statusv plain 2 successorsv visited endif add v predecessorss done sizev g vs children plain mark plain children v dfs tree mtroot statusv trivmtroot endif computedomvertex root reverse dfs order processvv elseif v processed processmtv endif done dfs order samedomv 6 null endif done fig 10 pseudocode computing dominators new simpler lineartime dominators algorithm 23 processvvertex v labelv dfsnumv labelp labelv labelv labelp endif dfsnump dfsnumv evalnode labelevalnode labelv labelv labelevalnode endif endif done add v bucketverticeslabelv z else samedomw z endif delete w bucketparentv done fig 11 pseudocode processing trivial microtrees 4 process bucket parent microtree root compute xdoms microtree encoding together computations examine predecessor arcs microtree encoding simple two bits pair microtree vertices plus one bit blue arc computa tion also identify special class microtrees microtree isolated target blue arc microtree root use information speed computation pxdoms iidom computation uses memoization maintain linear time bound increase eectiveness remove unnecessary bits eliminate unnecessary information microtree encoding used index memoization tables first remove bits selfloops second exploit blue arc v implies iidomv 62 microv none information vs internal arcs useful particular since know root microtree always target blue arc eliminate encoding bits arcs root changes reduce size iidom encoding g 2 g bits 12 bits six addition reducing size encoding reduce number populated slots memoization table using observation blue arc nonroot vertex w zero remaining bits arcs irrelevant processmtvertex v find mtroot vertices starting v initialize encoding isolated true labelv dfsnumv include p v encoding else include blue arc v encoding v 6 mtroot isolated false endif labelp labelv labelv labelp endif dfsnump dfsnumv evalnode labelevalnode labelv labelv labelevalnode endif endif endif done done iidomencoding reduced encoding iidommemoiidomencoding dened iidommemoiidomencoding computeiidomencoding endif iidoms iidommemoiidomencoding isolated else endif delete w bucketparentmtroot done fig 12 pseudocode processing nontrivial microtrees new simpler lineartime dominators algorithm 25 isolatedpushmicrotree mt int iidoms mtroot mt 0 labelv labelmtroot done add mtroot bucketlabelmtroot fig 13 pseudocode pushing isolated microtrees remove bits want xedlength encoding bits extra blue arc w compute reduced encoding look memoization table determine futher computation necessary determine iidoms use 2 time bitvector algorithm aho et al 1986 augmented exploit blue arcs necessary iidoms expressed terms dfs numbering augmented graph translate augmented graph vertex corresponding vertex current microtree adding secondary dfs number primary dfs number root microtree implemented two forms push rst shown figure 13 simplied form used isolated microtrees absence blue arcs nonroot vertices implies 1 xdom microtrees root pxdom vertices microtree 2 immediate dominators nonroot vertices local microtree rootmicrov root vertex nonlocal idom simply add bucket pxdom second shown figure 14 handles general case first compute strongly connected components sccs using memoization case memoization used eciency iidom calculation use reduced encoding sccs scc encoding uses g 2 g bits include selfloops blue arcs since neither aects computation compute sccs using lineartime twopass algorithm cormen et al 1991 given sccs either memoization table computing process topological order nd minimum xdoms vertices within scc incoming pxdoms assign value vertex pxdom given vs pxdom iidom either assign idomv directly put v appropriate bucket pushing nish processing bucket pmt parent mi crotrees root vertex bucket must pmt immediate dominator denition pxdom vertex v microtree minimum pxdom along path pmt v result skip eval vertex pmts bucket assign pmt immediate dominator directly 8 results section describes experimental results would interesting compare algorithm bkrw alstrup et al ahlt 1997 judge relative constant factors ahlt relies atomic heaps fredman willard 26 adam l buchsbaum et al mtroot mt 0 sccencoding reduced encoding sccmemosccencoding dened sccmemosccencoding computesccmtroot encoding endif topological order iidomssecdfsnumv 62 mt add v bucketlabelv else endif done done fig 14 pseudocode pushing general case atomic heaps turn composed qheaps store log 14 n elements given preprocessing time atomic heap construction requires qheaps store 12 log 15 n elements atomic heaps thus ahlt algorithm run linear time therefore n must exceed 2 12 20 fredman alternatively one consider ahlt run linear time impractically high additive constant term alstrup et al 1997 provide variants algorithm use atomic heaps none runs linear time thus implementable lineartime algorithm therefore compare implementation bkrw implementation lt algorithm derived paper lengauer tarjan 1979 performed two sets experiments rst set used owgraphs collected spec 95 benchmark suite spec 1995 using cfg library machine suif compiler holloway young 1997 harvard 3 six les integer suite could compiled machine suif v 112 omitted data second set used large graphs collected lab performed experiments one processor eightprocessor sgi origin 2000 2048mb memory processing node r10000 processor 32kb data instruction caches 4mb unied secondary cache implementations compiled mongoose c compiler version 70 report aggregate numbers spec test set contains large number owgraphs table reports sizes owgraphs averaged benchmark table ii contains average running times lt bkrw microtree sizes two three figure 15 displays scatter plot 3 machine suif extension suif compiler amarasinghe et al 1995 stanford used machine suif version 112 new simpler lineartime dominators algorithm 27 table graph sizes averaged flowgraphs benchmark spec 95 flowgraphs benchmark number average average flowgraphs vertices arcs cint95 suite 129compress 132ijpeg 524 14 20 147vortex 923 23 34 134perl 215 cfp95 suite 145fpppp 37 19 26 103su2cor 37 104hydro2d 43 35 46 125turb3d 24 52 71 table ii running times spec 95 flowgraphs averaged flow graphs benchmark numbers parentheses measure dier ence two algorithms computed following formula lt 1000 positive numbers indicate lt better negative numbers indicate bkrw better benchmark lt bkrw cint95 suite 130li 2001 us 3391 us 6949 3699 us 8490 129compress 2261 us 3762 us 6642 4384 us 9392 132ijpeg 2546 us 4043 us 5878 4586 us 8011 147vortex 3670 us 5359 us 4602 6129 us 6700 us 5661 us 4393 6373 us 6204 099go 5039 us 6987 us 3866 7937 us 5751 126gcc 6656 us 8787 us 3201 9561 us 4363 134perl 8954 us 11223 us 2534 12113 us 3528 cfp95 suite 145fpppp 3275 us 4663 us 4237 4933 us 5061 us 5314 us 3793 5990 us 5547 107mgrid 3836 us 5372 us 4002 6032 us 5723 103su2cor 4674 us 6206 us 3278 6728 us 4395 104hydro2d 4999 us 6671 us 3345 7282 us 4568 146wave5 5171 us 6845 us 3238 7446 us 4400 125turb3d 7366 us 10356 us 4060 11036 us 4982 us 9901 us 2660 10672 us 3646 101tomcatv 17460 us 21020 us 2039 21520 us 2325 28 adam l buchsbaum et al number vertices1525 number vertices101000 number flowgraphs fig 15 relative dierences running times bkrw lt 3 point top plot owgraph generated spec 95 benchmarks bottom plot displays number owgraphs respective number vertices note yaxis bottom plot represents logarithmic scale point represents running time bkrw microtrees size two three relative lt single owgraph plot shows overhead bkrw larger lt small graphs dierence tails 10 quickly gure combined data integer oatingpoint suites separating two table ii would yield two similar plots table iii lists large test graphs come variety sources along new simpler lineartime dominators algorithm 29 table iii graph sizes large test graphs graph vertices arcs atis 4950 515080 phone 2048 4095 7166 sizes atis nab pw graphs derived weighted nitestate automata used automatic speech recognition pereira riley 1997 pereira et al 1994 removing weights labels multiple arcs phone graph represents telephone calling patterns augmented binary graphs ab1 ab2 generated synthetically building binary tree given size shown table graphs label replacing leaf sub graph see figure 16 ab1 graphs use subgraph shown figure 16b ab2 graphs use subgraph shown figure 16c graphs designed distinguish bkrw lt subgraphs treated isolated microtrees bkrw means nonroot vertices microtree dominators within microtree back cross arcs handled cheaply without evals bkrw particular calls eval related arcs avoided bkrw result links linkeval forest compressed bkrw observed expected bkrw performs fewer links evals lt running time telling metric however present running times experiments table iv speech phone graphs overhead processing microtrees includes initializing memoization tables computing iidoms computing microtree encodings pushing outweighs savings calls link eval bkrw outperform lt larger augmented binary graphs expected since bkrw substantially fewer calls eval compresses zero links graphs addition overhead processing microtrees low isolated note improvement bkrw lt decreases graphs get larger benet gained algorithm small relative cost due paging increases graphs get larger a1b13 c fig 16 k kdepth binary tree augmented binary graph ab1 respectively ab2 generated replacing leaf subgraph shown b respectively c table iv running times large test graphs numbers parentheses measure dierence two algorithms computed following lt 1000 positive numbers indicate lt better negative numbers indicate bkrw better graph lt bkrw atis 38450 ms 42338 ms 1011 42725 ms 1112 ms 283625 ms 355 284475 ms 386 ms 319598 ms 220 318915 ms 199 phone 831362 ms 859475 ms 338 861638 ms 364 1024 200 ms 200 ms 000 250 ms 2500 2048 500 ms 500 ms 000 500 ms 000 ms 1000 ms 909 1200 ms 909 ms 2200 ms 974 2300 ms 564 ms 4838 ms 808 4838 ms 808 ms 11750 ms 775 11788 ms 746 2097152 2018800 ms 1949900 ms 341 1949838 ms 342 1024 400 ms 312 ms 2188 400 ms 000 2048 800 ms 700 ms 1250 700 ms 1250 ms 1562 ms 234 1600 ms 000 ms 3425 ms 486 3275 ms 903 ms 7425 ms 511 7038 ms 1006 ms 18212 ms 414 17538 ms 770 2097152 5192062 ms 5146125 ms 088 5102988 ms 172 new simpler lineartime dominators algorithm 31 given overhead bkrw pays computing microtree encodings pushing small bkrw surprisingly competitive even small owgraphs experiments suggest lt algorithm choice current practical applications lt simpler bkrw performs better graphs bkrw performs better graphs high percentage isolated microtrees 9 conclusion presented new lineartime dominators algorithm simpler previous algorithms implemented algorithm experimental results show constant factors low rather decompose entire graph microtrees harels approach dominators pathcompression result allows microtree processing restricted bottom tree traversal graph applied technique buchsbaum et al 1998 simplify previous lineartime algorithms least common ancestors minimum spanning tree mst verication randomized mst construction also show buchsbaum et al 1998 apply techniques pointer machines tarjan 1979b allows implemented pure functional languages acknowledgments thank bob tarjan mikkel thorup phong vo helpful discussions glenn holloway help machine suif james abello providing phone graph r compilers principles theory parsing dominators linear time manuscript available ftpftp suif compiler scalable parallel machines modern compiler implementation c introduction algorithms optimal parallel veri program dependency graph uses optimization lineartime algorithm special case disjoint set union linear time algorithm ow analysis transformation libraries machine suif fast algorithm linearity strong postorder object code optimization postorder disjoint set union linear speech recognition composition weighted finitestate language processing weighted rational transductions application human language processing optimal control dependence computation roman chariots problem algorithm 430 immediate predominators directed graph finding dominators directed graphs applications path compression balanced trees class algorithms require nonlinear time maintain disjoint sets accepted june tr worstcase analysis set union algorithms compilers principles techniques tools linear algorithm finding dominators flow graphs related problems program dependence graph use optimization introduction algorithms postorder disjoint set union linear efficiently computing static single assignment form control dependence graph transdichotomous algorithms minimum spanning trees shortest paths datastructural bootstrapping linear path compression catenable heapordered doubleended queues linearity unprovability set union problem strategies optimal control dependence computation roman chariots problem modern compiler implementation java lineartime pointermachine algorithms least common ancestors mst verification dominators applications path compression balanced trees fast algorithm finding dominators flowgraph immediate predominators directed graph h object code optimization theory parsing translation compiling ctr adam l buchsbaum haim kaplan anne rogers jeffery r westbrook corrigendum new simpler lineartime dominators algorithm acm transactions programming languages systems toplas v27 n3 p383387 may 2005 g ramalingam loops dominators dominance frontier acm sigplan notices v35 n5 p233241 may 2000 loops dominators dominance frontiers acm transactions programming languages systems toplas v24 n5 p455490 september 2002 andrzej murawski ch luke ong fast verification mll proof nets via imll acm transactions computational logic tocl v7 n3 p473498 july 2006 loukas georgiadis robert e tarjan finding dominators revisited extended abstract proceedings fifteenth annual acmsiam symposium discrete algorithms january 1114 2004 new orleans louisiana loukas georgiadis robert e tarjan dominator tree verification vertexdisjoint paths proceedings sixteenth annual acmsiam symposium discrete algorithms january 2325 2005 vancouver british columbia efficient algorithm finding doublevertex dominators circuit graphs proceedings conference design automation test europe p406411 march 0711 2005 adam buchsbaum yihfarn chen huale huang eleftherios koutsofios john mocenigo anne rogers michael jankowsky spiros mancoridis visualizing analyzing software infrastructures ieee software v18 n5 p6270 september 2001 ren krenz elena dubrova fast algorithm finding common multiplevertex dominators circuit graphs proceedings 2005 conference asia south pacific design automation january 1821 2005 shanghai china elena dubrova structural testing based minimum kernels proceedings conference design automation test europe p11681173 march 0711 2005
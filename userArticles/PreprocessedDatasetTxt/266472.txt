sequential optimisation without state space exploration propose algorithm area optimization sequential circuits redundancy removal algorithm finds compatible redundancies implying values nets circuit potentially exponential cost state space traversal avoided redundancies found removed optimized circuit safe delayed replacement original circuit algorithm computes set compatible sequential redundancies simplifies circuit propagating circuit demonstrate efficacy algorithm even large circuits experimental results benchmark circuits b introduction sequential optimisation seeks replace given sequential circuit another one optimised respect criterion area performance power way environment circuit cannot detect replacement work deal problem optimising sequential circuits area present algorithm computes sequential redundancies circuit propagating implications nets redundancies compute compatible sense form set removed simultaneously algorithm works large circuits scales better algorithms depend state space exploration starting point work 1 method described identify sequential redundancies without exploring state space basic algorithm net two cases considered net value 0 net value 1 case constants well unobservability conditions learnt nets net either set constant cases constant one case unobservable identified redundant example consider trivial circuit shown figure 1 value net n2 unobservable value net n2 1 thus net n2 stuckat1 redundant however redundancies found method 1 compatible sense remain redundant even university california berkeley berkeley ca 94720 cadence berkeley labs berkeley ca 94704 university texas austin austin figure 1 example incompatible redundancies presence instance redundancy identification algorithm declare inputs n 1 n 2 stuckat1 redundant however logic optimisation incorrect replace nets constant 1 straightforward application iyers method redundancy removal identify one redundancy implication procedure remove redundancy iterate con vergence goal learn compatible implications circuit one step use compatibility implications remove redundancies simultaneously sense method finding compatible unobservabilities related work 2 3 computing compatible odcs observability dont cares first contribution sec ondly generalise implication procedure combining recursive learning 4 enhance capability redundancy identification procedure recursive learning lets us perform case split unjustified gates possible learn implications expense computation time consider circuit figure 2 setting net 0 implies net f 0 set 1 a1 becomes 1 andgate connected remains unjustified perform recursive learning two justifications former case net f becomes 0 latter case f becomes unobservable e 1 thus possible cases either f 0 unobservable hence f declared stuckat0 redundant recursive learning helps identify kinds new redundancies present data shows able gain significant optimisations large benchmark circuits using two new improvements fact circuits find recursive learning gives us optimisation even faster since previous recursive learning step makes circuit simpler later stage assume designated initial states circuits sequential optimisation use notion cdelay replacement 1 5 notion guarantees every possible inputoutput behaviour observed new circuit clocked c cycles powerup must present old circuit contrast work 5 6 synthesis method presented require state space e c f figure 2 example recursive learning c o1 c figure 3 circuit graph traversal therefore applied large sequential cir cuits recursive learning used earlier optimi sation described 7 method applied combinational circuits use unobservability conditions another procedure redundancy removal described 8 9 shows notion replacement compositional may also identify redundancies destroy initialisability circuit therefore chosen use notion safe delayed replacement preserves responses initializing sequences interested compositionality would like notion replacement valid without making assumptions environment circuit replacement notion safer used 10 identifies sequential redundancies preserving weak synchronizing se quences work implicitly assumes environment circuit total control supply arbitrary sequence redundancy identification tool mind approach pose restrictions rest paper organised follows section 2 present algorithm compute compatible redundancies combinational sequential circuits section 3 present experimental results large circuits iscas benchmark set section 4 conclude directions future work redundancy removal present algorithm sequential circuits mapped using edgetriggered latches inverters 2input gates note combinational implementation mapped circuit containing inverters 2input gates use notion circuit graph explaining algorithm circuit graph labelled directed graph whose vertices correspond primary inputs primary outputs logic gates latches edges correspond wires elements circuit label vertex identifies type ele figure 4 rules implying constants ment represents eg twoinput gates inverters latches refer edge circuit graph net figure 3 shows example circuit graph 21 combinational redundancies explain algorithm prove correctness combinational circuits later extend sequential circuits consider circuit graph circuit v set vertices e set nets assumption subset p e labelling nets p values set f01g let n 2 p net labels net n value v assumption denoted ordered tuple set possible assumptions set p nets denoted p consider set assumption labeling 0 n 1 denoted hm 7 0n 7 1i 1ihm 7 1n 7 0ihm 7 1n 7 1ig assumption 2 p inconsistent satisfiable assignments primary inputs circuits instance assumption 0 input 1 output gate inconsistent algorithm values implied nets e np assumption p imply either constants unobservability indicators nets indicate unobservability net implying symbolic valueomega let set possible value implied net implication label n net r 2 r figure 4 illustrates rules implying constants rules c1 c2 c3 c5 selfexplanatory rule c4 states gate 0 output 1 input implies 0 input rule c6 states constant fanout net gate implies constant fanout nets figure 5 illustrates rules implyingomega rule o1 states 0 input gate implies aomega input rule o2 states aomega every fanout net gate implies aomega every fanin net gate note constants implied directions across gate whileomega propagates backwards shown rules inverters gates similar rules easily formulated gates well use rules label edges circuit graph constant 0 1 label net indicates omega omega omega omega omega omega figure 5 rules implying unobservability0a e1 c b omega omega omega figure overwriting constants unobservability indicator net assumes respective constant value current assumption aomega label indicates net observable primary output hence freely assigned either 1 current assumption suppose every assumption p net n labelled either constant v withomega safely replace n constant v shown every possible assump tion either net takes value v value affect output therefore conclude net n stuckatv redundant concerned compatibility labellings otherwise run danger marking nets labels labels consistent example consider circuit figure 1 purpose identifying redundancies 1 would infer implications assumption hn 7 1i additionally assumption hn 7 0i implies hn 7 0i implies notice use symbolomega denote compatible observability opposed simply denotes observability 1 would rightly claim n1 stuckat1 redundant isola tion however redundancy removal easy see cannot want make labelings compatible sufficient condition redundancies compatible ensure procedure computing implications assumption returns compatible implications ie every implication valid presence implications easy see labelling edges circuit graph done invoking rules described label ever overwritten set learnt implications compat ible instance circuit figure 1 n1 labelled aomega cannot inferred n1 overwritten 0 approach conservative miss redundancies figure 6 show example overwriting constant aomega yields redundancy could found otherwise propagate implications assumptions net redundancy remove find remove redundancies circuit graph unvisited net n circuit graph f learn implications g hn 7 1i learn implications g hn 7 0i r every implication set net n constant v propagate constants simplify learn implications propagate implications circuit graph given assignment f forall n n 7 v f label n v rule invoked f b new implication b label n b conflicts current label return else label n b return set current labels figure 7 combinational redundancy removal algorithm implications ha 7 0i written ha 7 1i written wires note propagating implications ha 7 1i a2 initially labeled 1 labelling c 0 labels a2 successively overwritten hence a2 found stuckat0 redundant result gate moved prove later section overwriting make previously learnt implications invalid ie compatibility implications maintained overwriting allowed constants unobservability indicators algorithm removing combinational redundancies given figure 7 function learn implications takes input assumption arbitrary subset nets labels nets values f01 learnt implications initially nets n n 7 v assumption la belled derive new labels invoking rules c1c6 o1o2 similar rules kinds two input gates note times net unique label constants overwritten withomega viceversa returns set final labels function redundancy remove takes input circuit graph g calls learn implications successively assumptions hn 7 0i hn 7 1i singleton subset fn g two sets labels used compute pairs n v n stuckatv redundant later show labelling procedure learning implications guarantees redundancies removed f c e f c e figure 8 implication graph simultaneously redundancies used simplify network process repeated nets con sidered note function redundancy remove considers assumptions single net general number nets could used generate assumptions later show results case considered assumptions two nets second one corresponding unjustified node closest instance recursive learning formalise notion valid label one implication graph exists use notion implication graph proving compatibility set labels generated algorithm let assumption set p nets implication graph label assumption directed acyclic graph g v l set labels form net 2 f01 labelling every vertex v 2v ffl every root 1 vertex labelled 7 ffl exactly one leaf 2 vertex v 2v labelled ffl vertex v 2 v v root node implication labelling obtained implications labelling parents invoking inference rule example implication graph label assumption hn8 7 1i shown figure 8 set labels c derived assumption compatible every label c2c exists implication graph c lc c prove compatibility implications returned labelling procedure step labelling procedure either labels node first time overwrites constant aomega prove invariant time current set implications c compatible must prove label overwritten new label every label must implication graph depend overwritten label claim proved following lemma needed current labels simultaneously valid 1 vertex incoming edges vertex outgoing edges note overwriting 0 1 viceversa implies inconsistent assumption procedure exits lemma 21 let consistent assumption label overwritten label omega current set labels labels n implication graph label vertex graph proof call net parent net n node v circuit graph incoming arc n outgoing arc v also say n child say sibling n node v n outgoing edges v prove claim contradiction suppose false let replacement omega first instance makes false therefore implication graph current implication happened let implication valid implication graph consider path old implication graph net n j n ith implication path consider case b j constant hence b k path constants since aomega net imply aomega another case omega considered later show assumption consistent possible replace n implication graph n j three cases relation case 1 circuit edge n igamma1 child n omega inferred n either n omega current implication current implication n 0 n inputs gate first case fact implication graph existed n igamma1 labelled constant contradicted second case n igamma1 output gate whose two inputs n n 0 since n either case case 2 n igamma1 n siblings n application rule c6 n i1 either parent sibling n removed implication graph implication n i1 child n thenomega inferred omega current implication n current implication n n inputs gate first case fact implication graph existed n i1 labelled constant contradicted second case clearly n i1 labelled 0 ie b otherwise assumption inconsistent path n replaced path n note get new implication graph need implication graph n exists affected overwriting previous label withomega e g x c f figure 9 sequential circuit c case 3 n igamma1 parent n reasoning case 2 thus shown assumption consistent vertex labelled n implication graph current implication n replaced current implication shows replacement n omega falsify claim contradiction consider case b j omega greatest k b k constant b l constant omega k l j proof know exists implication graph n k used yields implication graph n used lemma 22 let consistent assumption set labels returned algorithm compatible proof step algorithm either value implied net first time constant overwritten aomega proof lemma follows induction number steps algorithm using lemma 21 prove induction step theorem 21 let n stuckatv redundant 1 set redundant faults reported algorithm circuit obtained setting combinationally equivalent original 22 sequential redundancies extend algorithm combinational circuits described previous section find sequential redundancies propagating implications across latches implications may valid first clock cycle since latches powerup nondeterministically random boolean value initially nevertheless use notion k delayed replacement requires modified circuit produce behaviour original k clock cycles elapsed thus example implying constant v latch output constant v input yields redun dancy 1delay replacement 3 guaranteed removal redundancy 3 latches reset value guaranteed first cycle operation sufficient ensure constant v equal reset value case replacement 0delay replacement figure 10 sequential implication graph assumption circuit c figure 11 incorrect sequential implication graph assumption circuit c notion label implication graph modified also contains integer time offset respect global symbolic time step rules learning implications exactly addition new rule allows us propagate implications across latches go across latch modify time offset accord ingly eg output latch labelled 1 offset 2 input latch labelled 1 offset 3 example implication graph circuit c figure 9 shown figure 10 example also shows potential problem learning sequential implications consider circuit c figure 9 two assumptions ha 7 0i 0 denotes global symbolic time ha 7 1i get two implication graphs figures 10 11 imply c might lead us believe dundancy however new circuit obtained replacing c 0 powers state 11 latch 1 remains forever 11 circuit output x 1 however original circuit produces matter state powers thus kdelay replacement k reason incorrect redundancy identification order infer c assumption needed c 0 ie times c could 1 1 one way solving problem ensure net labelled different labels different times label net one label net labelled associate list integers label denotes time offset label valid thus example implication propagation phase assumption never infer get second implication graph figure 10 labeling one net one label also obviates need validation step described 1 algorithm replaces net n constant v time offset 0 either labelled v unobservable assumptions replacement associate time k follows 1 validate redundancy n stuckatv time 0 set implication graphs one assumption imply either n 0 omega let 00 least time offset label implication graphs net 00 labelled constant say n kcycle stuckatv redundant use following theorem claim circuit obtained replacing net n constant v kdelayed safe replacement lemma 23 1 let net n kcycle stuckatv redundant circuit obtained setting net results k delayed safe replacement original circuit combinational case allow overwriting constants unobservability indicators make sure label net n time overwritten new label isomega net n labelled time offset prevent problem shown figure 11 may make algorithm dependent order application rules explored various options proof following two lemmas follows easy extensions lemmas 21 22 lemma 24 let consistent assumption label replaced omega current set labels labels implication graph label graph lemma 25 let consistent assumption set labels returned algorithm compatible hence redundancies reported algorithm compatible redundancies removed simultaneously get delayed safe replacement theorem 22 let n k cycle stuckatv redundant 1 set redundant faults reported algorithm circuit obtained setting net kdelay safe replacement original proof lemma 25 know 1 redundant circuit obtained setting shown 5 circuits c e c adelay replacement bdelay replacement e c delay replacement e desired result follows easily induction n property delay replacements 3 experimental results present experimental results algorithm demonstrate approach identifying sequential redundancies yields significant reduction area better circuit redundancy removal recursive learning name red lr a1 red lr a2 cordic legend see table 2 table 1 experimental results combinational redundancies approach removes combinational redundancies also show examples recursive learning gives better results simple implication propagation scheme fact many circuits recursive learning could identify redundancies simple implication propagation scheme unable find algorithm implemented sis 11 circuit first optimised using scriptrugged performs combinational optimisation network optimised circuit mapped library consisting 2input gates inverters sequential redundancy removal algorithm run mapped circuit propagation implications allowed propagate 15 time steps forward 15 timesteps backward global symbolic time table 2 shows mapped mcnc91 library area circuits obtained running scriptruggedand obtained starting result applying redundancy removal algorithm large circuits s15850 larger bdd operations full simplify step scriptruggedwere per formed report results circuits algorithm able find redundancies mentioned earlier algorithm starts assumption nets implies values nets circuit implemented two flavors selection assumptions first case conflicting assignment assumed one net values implied nets second case similar first except implications could propagate assumption net performed nave circuit attributes redundancy removal recursive learning name pi po l red c lr a1 time red c lr a2 time s953 43 26 183 3775 28 7035 84 669 92 733 70 6317 178 321 43 9380 100 4937 s38417 28 106 1464 33055 591 887 42 31943 34 11394 1129 9245 97 29718 101 17637 full simplify run times reported alpha 21164 300mhz dual processor 2g memory pi number primary inputs po number primary outputs l number latches mapped area scriptrugged a1 mapped area redundancy removal a2 mapped area redundancy removal recursive learning red number redundancies removed lr number latches removed c upper bound c new circuit cdelay replacement time cpu time percentage area reduction table 2 experimental results sequential redundancies version case splitting net closest original net implications propagated implications common two cases also added set implications learnt original net 4 enabled us propagate implications larger set nets network hence discover redundancies expense cpu time table 2 indicates area reduction obtained simple propagation performing recursive learning find even nave recursive learning get reduction area circuits obtained without case split instance s5378 able obtain 375 area reduction recursive learning 196 without medium sized circuits able obtain reduction area without recursive learning large circuits also able obtain approximately 510 area reduction s35952 exception obtain reduction area except circuit cpu time recursive learning less twice cpu time redundancy removal without suggests sophisticated recursive learning 4 node unjustified forward propagation implications casesplit performed setting output net 0 1 node unjustified backward propagation case split achieved setting one two inputs input controlling value 0 nand gate 1 gate time propagating implications backward based techniques could yield larger area reduction without prohibitive overhead terms cpu time since algorithm also identified combinational redundan cies wanted quantify many redundancies purely combinational verify ran algorithm circuits combinational redundancy removal table 1 shows area reduction due combinational redundancies without recursive learning cases number redundancies identified table 2 significantly larger set combinational redundancies identified algorithm s35952 s953 combinational redundancy removal result approximately area reduction sequential redundancy case example circuits presented able achieve 037 area reduction number cases algorithm able remove significant number latches cases new circuit cdelay safe replacement original circuit c reported table 2 actually upper bound delay replaced circuits c 10000 however practical circuits operate speeds exceeding 100 mhz present technology c 10000 circuit would require user wait 100 useful operation begin severe restriction unable compare sequential redundancy removal results previous work entrena cheng 8 noted earlier notion sequential replace ment based conservative 01xvalued simula tion compositional unlike notion delay replacement use 4 future work redundancy removal algorithm find complete set redundancies extend scheme several ways identify larger sets instance instead analyzing two assumptions due case split single net could case split multiple nets intersect implications learnt larger set assumptions one method incrementally select frontier first phase implications died additionally split multiple nets possible detect pairs nets one replaced another circuit functionality change current approach split single net one nets pair always 1 0 means identifying stuckatconstant redundancies algorithm map given circuit using library two input gates inverters different approach would use original circuit propagate implications forward backward building bdds node function terms immediate fanins intend compare running times area reduction numbers approach bdd based approach addition bdd based approaches may allow us redundancy removal multivalued logic circuits well relatively inexpensive way extend notion redundancy multivalued circuits identify cases net take subset allowed values latches kind encoded using fewer bits acknowledgements useful discussions mahesh iyer miron abramovici course work comments referees also helped improved paper r identifying sequential redundancies without search transduction method design logic networks based permissible functions dont cares multilevel network optimiza tion recursive learning new implication technique efficient solution cad problems test verification optimization ex ploiting powerup delay sequential optimization latch redundancy removal without global reset lot logic optimization testability new transformations using recursive learning sequential logic optimization redundancy addition removal redundancy untestability sequential circuits removing redundancies synchronous sequential circuits synchronizing sequences sis system sequential circuit synthesis tr transduction methoddesign logic networks based permissible functions dont cares multilevel network optimization exploiting powerup delay sequential optimization removing redundancies synchronous sequential circuits synchronizing sequences redundancy untestability sequential circuits sequential redundancies without search sequential logic optimization redundancy addition removal latch redundancy removal without global reset ctr vigyan singhal carl pixley adnan aziz shaz qadeer robert brayton sequential optimization absence global reset acm transactions design automation electronic systems todaes v8 n2 p222251 april
path analysis renaming predicated instruction scheduling increases instruction level parallelism needed exploit potential parallelism available future wide issue architectures predicated execution architectural mechanism increases instruction level parallelism removing branches allowing simultaneous execution multiple paths control committing instructions correct path order compiler expose use parallelism traditional compiler dataflow path analysis needs extended predicated code paper motivate need renaming predicates reflect path information present predicated static single assignment pssa uses renaming introduces full path predicates remove false dependences enable aggressive predicated optimization instruction scheduling demonstrate usefulness pssa predicated speculation control height reduction two predicated code optimizations used instruction scheduling reduce dependence length critical paths predicated region results show using pssa enable speculation control height reduction reduces execution time 12 68 b introduction explicitly parallel instruction computing epic architecture put forth viable architecture achieving instruction level parallelism ilp needed keep increasing future processor performance 8 17 intels application epic architecture technology found ia64 architecture whose first instantiation itanium processor 1 epic architecture issues wide instructions similar vliw architecture instruction contains many operations one new features epic architecture support predicated execution 24 operation guarded one predicate registers available architecture operation committed value guarding predicate true one advantage predicated execution eliminate hardtopredict branches combining paths branch single path another advantage comes using predication combine several smaller basic blocks one larger hyperblock 22 provides larger pool draw ilp epic architectures significant limitation ilp presence controlflow dataflow dependences static single assignment ssa important compiler transformation used remove false data dependences across basic block boundaries control flow graph 12 removing false dependences reveals ilp allowing better performance optimizations like instruction scheduling without performing ssa benefit many optimizations traditional code limited eliminating false dependences equally important complex task predicated code since multiple control paths merged single predicated region however controlflow dataflow analysis needed support predicated compilation different traditional analysis used compilers superscalar architectures sequential region predicated code contains data dependences also predicate dependences predicate dependence exists every operation definitions guarding predicate technique introduces chain predicate dependences represents unique control path original code describe predicatesensitive implementation ssa called predicated static single assignment pssa pssa introduces fullpath predicates extend ssa handle predicate dependences multiple control paths merged together single predicated region demonstrate pssa allows effective predicated scheduling 1 eliminating false dependences along paths via renaming 2 creating fullpath predicates 3 providing pathsensitive dataflow analysis show benefit using pssa perform predicated speculation control height reduction instruction schedul ba brand true brandom number p2p3 cmppunuc ba true ba p2truep3false else p2false p3true bq p2 p2 true bq else nullify db3 p3 p3 true db3 else nullify statement fb2 true fb2 original control flow graph b predicated hyperblock figure 1 short code example showing transformation nonpredicated code predicated hyperblock ing using pssa allows two optimizations applied together schedule operations earliest schedulable cycle implementation earliest schedulable cycle takes consideration true data dependences loadstore constraints paper expand upon work presented 11 including additional benchmarks motivating need renaming predicates reflect path information beyond available traditional ifconverted code paper organized follows section 2 describes predicated execution section 3 motivates need predicatesensitive analysis fullpath predicates section 4 presents predicated static single assignment section 5 shows pssa enable aggressive predicated speculation control height reduction section 6 reports increased ilp reduced execution times achieved applying algorithms predicated code section 7 summarizes related work section 8 discusses using pssa within ia64 framework section 9 describes future work finally section 10 summarizes contributions paper predicated execution predicated execution feature designed increase ilp remove hardtopredict branches also used support software pipelining14 25 machines hardware support predicated code include additional set registers called predicate registers process predication replaces branches compare operations set predicate registers either true false based comparison original branch operation associated one predicate registers hold value operations guarding predicate operation committed guarding predicate true 1 process replacing branches compare operations associating operations predicate defined compare called ifconversion 5 24 work uses notion hyperblock 22 hyperblock predicated region code consisting straightline sequence instructions single entry point possibly multiple exit points branches targets hyperblock eliminated converted predicate definitions using ifconversion remaining branches targets outside hyperblock consequently cyclic controlflow dataflow dependences within hyperblock selection instructions included hyperblock based program profiling original basic blocks includes information execution frequency basic block size operation latencies characteristics 22 typical code section include hyperblock one contains hardtopredict unbiased branch 21 shown figure 1 ifconversion control flow graph cfg figure 1a comprised four basic blocks results predicated hyperblock shown figure 1b operations hyperblock guarded either predicate register set constant value true register defined either true false cmpp compare put result predicate operation operations guarded constant true operation fb2 figure 1 executed committed regardless path taken operations guarded predicate register operation bq put pipeline committed value operations guarding predicate p2 operation determined true follows describe three types operations included hyperblock cmpp operations predicate operation normal nonpredicatedefining operations defined trimaran system 2 supports epic computing via playdoh isa 19 guarding predicates assigned values via cmpp operations 8 consider operation bc cmppunac ac example cmpp operation define one two predicates operation define predicates b c first tag un applies definition first predicate b second tag ac c first character tag defines predicate defined character u means predicate unconditionally get value whether guarding predicate case true false false b set false otherwise true value b depends upon evaluation ac character second tag ac indicates full definition related predicate c contingent value evaluation ac prior value c false value predicate c change true c previously set false c remains false one exception unconditional definition predicate discussed later section additionally second character tag defines whether normal n result condition ac complement c condition must true make related predicate true true c true ac true new value c true 2 complete definition cmpp statements see playdoh architecture specification 19 implementation pssa introduce new operation currently defined trimaran predicate operation defines block predicates taking logical multiple predicates example consider operation g ora b c true b c predicates defining unique path g one value true g receive value true otherwise g assigned false scheduling make reasonable assumption definition predicate available use source another operation guard subsequent cmpp operation cycle following definition used guard operations predicate definition available use cycle defined refer operations define predicates normal operations normal operations include assignments arithmetic operations branches memory operations 3 motivation predicatesensitive analysis major task scheduler multiissue machine find independent instructions unfortu nately predication introduces additional dependences traditional code doesnt consider figure 1b dependence definition guarding predicate p2 use statement bq p2 since predication combines multiple basic blocks introduces false dependences disjoint paths example figure 1b absence predicate dependence information would infer dependence definition b bq p2 use b db3 p3 however two statements guarded disjoint predicates therefore one predicates p2 p3 possibly true one statements actually committed dependence fact exist johnson et al 18 devised scheme determine disjointness predicates using predicate partition graph analysis allowed effective register allocation live ranges across predicated code could accurately determined 15 approach limited describing disjointness restricted path information path information extended across join points collected conversely true c true ac false new value c false figure 2 predicate partition graph would determine following pairs predicates disjoint g h b c however information regarding relationship g h would available crossjoin information needed provide scheduler full flexibility scheduling statements ytr path information available ytr guarded true scheduler correctly assumes statement dependent trand tts r5x rx8 however since two possible definitions operand 4 combinations operands could fact cause definition executable via one paths execution region 4 versions statement could made one combination operands could scheduled minimum dependence length version disjointness information maintain information regarding paths since recent join need combine path information across joins remove unnecessarily conservative scheduling dependences figure 2b shows crossjoin path information would needed guard assignment scheduler know precise dependences copy allow flexibility scheduling statement although precise dependence information determined guarding predicate relations also show renaming techniques additional use achieve greater scheduling flexibility renaming variables one definition region maintain path information even optimizations change guarding predicate statement applied 4 predicated static single assignment pssa techniques renaming 4 static single assignment ssa 13 12 proved useful eliminating false dependences traditional code 31 removing false dependences allows flexibility scheduling since data independent operations move past instruction scheduling nonpredicated code ssa assigns target assignment operation unique variable join nodes oefunction may need inserted multiple definitions variable reach join oefunctions determine version variable use assign additional renamed version new variable used represent merging different variable names figure 3 shows simple example figure 1 ssa form assignment b3oeb1b2 variable b3 represents reaching definition b used join definition b1 b2 discussed section 3 eliminating false dependences equally important complex task predicated code since multiple control paths merged address problem developed tr tts zw5 true r5x g bc tr g bc tr h l w2 b tts br l ytr dg ytr dh ytr dg ytr dh vy5 true original control flow graph b predicated hyperblock paths first join block second join block third join block br figure 2 code duplicated one definition reaches use maintain maximum flexibility scheduler b statement ytr duplicated pair definitions may reach statement copy guarded predicates defined path along definitions would occur predicatesensitive implementation ssa called predicated static single assignment pssa pssa seeks accomplish objectives ssa predicated hyperblock first must assign target assignment operation hyperblock unique variable second points hyperblock multiple paths come together must summarize conditions multiple definitions variable reaches join second objective accomplished creation fullpath predicates pathsensitive analysis consider sample predicated code shown figure 4 using traditional hyperblock predication 22 ba control flow graph b code ssa form b1a else d1b13 figure 3 static single assignment br zw5 true r5x g bc tr true l w2 b tts br l ytr true vy5 true original control flow graph b predicated hyperblock tr tts figure 4 extended example transformation nonpredicated cfg predicated hyperblock t2t1s ftrue true 1 agfahf cmppunuc z17 f 3 r15x agf 3 bagfcagf cmppunuc t1r1 agf 5 bahfcahf cmppunuc t1r2 ahf 5 lbagfebagf cmppunuc w12 bagf 6 lbahfebahf cmppunuc w12 bahf 6 ecagf edcagf cmppunuc t17 cagf 6 ecahf edcahf cmppunuc t17 cahf 6 t2t1s 7 br l 7 agf ahf t1 rand br bagf cagf bahf cahf agf ahf pssa dependence graph b pssatransformed code figure 5 pssa dependence graph shows flow data control pssatransformed code blocks labeled fullpath predicates indicated multiple letters contain statements executed along path blocks labeled block predicates single letters contain statements executed along several paths predicated example branches replaced except one leaving hyperblock predicatedefining operations using ifconversion predicates defined example correspond two edges exiting conditional branch cfg figure 4 figure 5 shows example pssa applied displays graph showing postpssa dependence relationships pssa transformation 2 phases pre postoptimization hyperblocks converted pssa form optimization optimization pssa inserts cleanup code edges leaving hyperblock copying renamed variables back original names removes unused predicate definitions 41 converting pssa form converting pssa form operation processed turn beginning top hyperblock proceeding end control pssa applied predicatedefining operations normal pssa applied operations first describe normal pssa operation assignment variable defined renamed third operation figure 5b z1w15 example operands adjusted reflect previously renamed variables eg w becomes w1 operation part join block multiple versions operands may live first operation ytr third join block figure 2a provides example operation duplicated path leading join correct operand versions path used duplicate statement seen figure 5 multiple definitions y1 duplicates guarded fullpath predicate described associated path along operands defined though 6 definitions y1 4 unique one definition y1 given path definitions predicated disjoint predicates one possibly true one committed next describe control pssa single cmpp operation defined one two block predicates definitions b c figure 4 replaced one cmpp operations associated particular path leading block seen figure 5b two cmpp operations one defining bagf cagf one defining bahf cahf new predicates called fullpath predicates fpps fpp definition appropriate operand versions path guarded fpp defined path prior reaching new block example cmpp defining bagf cagf predicated agf fpp specifies unique path along operation valid execution enabling pssa provide correct guarding predicates duplicate statements previously described example figure 2 pointed definitions y1 needed guarding predicates captured information paths execution first definition y1 needed guarded predicate representing path execution block g block addition predicate needs reflect execution actually reached block statement question e case register y1 would incorrectly modified example branch hyperblock taken block e never reached new fpp ebagf represents precise conditions correct execution addition cmpp statements added define fpps cmpp statements included rename join blocks whose statements originally predicated true e associated fpps examples operations figure 4b predicated true predicated f e pssa version code shown figure 5 necessary maintain exact path information clearly potential cause exponential amount code duplication might seem reasonable follow example ssa insert oefunctions join points resolve multiple definitions example implementation oefunctions resolving r definition y1 could 1 rr1 g 3 tt1 true would advantage decreasing duplication eliminate need predicatesensitive analysis predicate relationship information still needed determine reaching definitions associated predicates determine order copy operations example statements 3 4 defining previous sequence could committed literal predicate true always true predicate could true well use 5 get correct definition statement 4 cannot executed statement 3 moreover side effects degrade performance introduced important insertion oefunctions adds data dependences example true dependence introduced definition t1 use 3 addition false dependences reintroduced example output dependence two definitions thus ssa usual oefunction implementation give desired scheduling flexibility block predicates also important pssa transformation pssa uses predicate statements redefine block predicates union fpps associated paths reach block pssa simply duplicate every path hyperblock duplication occurs necessary remove false dependences one version operands reaching statement one version statement required case v1y15 figure 5 variable y1 version live node e statement guarded e block predicate created taking logical ebagf ebahf ecagf ecahf edcagf edcahf long control reaches node e regardless path taken execute commit statement v1y15 42 postoptimization cleanup optimization applied code pssa form cleanup phase run remove unnecessary code assure consistent code outside hyperblock pssa implementation described paper generates cmpp statements every path block entered pssa data structure maintains information relationships predicates define provides maximum flexibility optimization however fpp definitions may used corresponding cmpp operations discarded reducing code size significantly finally assure correct execution following hyperblock pssa inserts copy operations assigning original variable names renamed definitions live hyperblock placed appropriate exit hyperblock example exit branch guarded l figure 4 would include live hyperblock exit 5 hyperblock scheduling optimizations section describe pssa enables predicated speculation pspec control height reduction chr aggressive instruction scheduling pspec allows operations executed guarding predicates determined chr allows guarding predicates determined soon possible reducing number operations need speculated used together pssa demonstrate schedule code earliest schedulable cycle assuming machine unlimited resources ftrue true 1 agfahf cmppunuc z17 f 3 bagfcagf cmppunuc t1r1 agf 4 bahfcahf cmppunuc t1r2 ahf 4 lbagfebagf cmppunuc w12 bagf 5 lbahfebahf cmppunuc w12 bahf 5 ecagf edcagf cmppunuc t17 cagf 5 ecahf edcahf cmppunuc t17 cahf 5 t2t1s true 2 br lbagf 5 br lbahf 5 figure extended code example pspec optimization applied statements first statement predicated true speculated 51 predicated speculation section describes perform speculation pssatransformed code general speculation used relieve constraints control dependences place scheduling one speculatively execute operations likelytaken path highlypredictable branch scheduling operations controlling branch 20 similarly predicated speculation pspec schedule normal operation cmpp operation dependent upon optimizing hyperblocks execution time pspec handles placement speculated predicated operation uniform manner pspec schedules normal operation earliest schedulable cycle speculating operation operation scheduled earlier operation control dependent predicated true assume exceptions raised speculated operations taken care using architecture features poison bits 7 pspecnormal op f normal opguarding predicate defined normal opearliest schedulable cycle f multiple defs normal optarget exist f renamenormal optarget update usesnormal optarget normal opscheduleearliest schedulable cycle normal opset predicatetrue else f normal opscheduleearliest schedulable cycle figure 7 basic pspec algorithm 511 instruction scheduling speculation demonstrate usefulness pssa enabling pspec figure 6 shows code figure 5 pspec optimization applied assignments r1 r2 examples speculated operations notice based dependences could scheduled cycle one would impossible without renaming predicated speculation operation considered sequentially beginning first instruction hyperblock normal nonstore operation pspec compares earliest schedulable cycle cycle guarding predicate currently defined operation scheduled earlier guarding predicate operation predicated true scheduled earliest schedulable cycle recall pssa performed full renaming renaming may required pspec example definition y1 figure 5 speculate definitions y1 predicating true without renaming incorrect code result consequently must rename operations speculated results applying 6 definitions y1 y1 y2 y3 y4 y5and y6 appear figure 6 speculation renaming may require duplication operations using definition speculated since may multiple reaching definitions speculating y1 operation v1y15 duplicated guarded appropriate fpp though figure 6 statements shown speculated possible pssa previously created necessary fpps path information guarding predicate defined operations earliest schedulable cycle apply pspec scheduled earliest schedulable cycle guarded guarding predicate assigned pssa instruction z1w15 example algorithm pspec instruction scheduling shown figure 7 using pspec hyperblock scheduled 6 cycles compared 9 cycles figure 5 since pspec applied whenever definition operations guarding predicate occurs later earliest schedulable cycle operation could reduce number operations need speculated moving definition guarding predicates earlier goal next optimization control height reduction allow predicates defined early possible 512 branches speculation chose pspec branches therefore branch statements earliest schedulable cycle one guarding predicate known however branch predicated block predicate pssa multiple operand versions reaching may unnecessarily delayed scheduling waiting block predicate computed shown figure 6 may choose duplicate statement much normal pspec guard execution duplicates respective fpps instead predicating single instruction block predicate 52 control height reduction control height reduction chr eases control constraints multiple control statements chr allows successive control operations control path scheduled cycle effectively reducing control dependence height example code figure 6 control comparisons z17 t1r1 scheduled cycles 3 4 respectively however second comparison waiting definition guarding predicate agf schedule earlier consider pssa dependence graph figure 5 definition bagf defined condition t1r1 control dependent definition agf defined condition z17 could define bagf directly logical conditions z17 t1r1 removing dependence definition agf expression could scheduled cycle 3 control height reduction proposed 27 successfully used reduce height control recurrences found loops applied superblocks superblock selected trace basic blocks control flow graph containing one path control 26 pathdefining aspects pssa ftrue true 1 agfa hf cmppunuc z17 f 3 bagf cagf cmppanan z17 true 3 bagf cagf cmppanac t1r1 true 3 bahf cahf cmppacac z17 true 3 bahf cahf cmppanac t1r2 true 3 lbagfebagf cmppanan z17 true 3 lbagfebagf cmppanan t1r1 true 3 lbagfebagf cmppanac w12 true 3 lbahfebahf cmppacac z17 true 3 lbahfebahf cmppanan t1r2 true 3 lbahfebahf cmppanac w12 true 3 ecagfedcagf cmppanan z17 true 3 ecagfedcagf cmppacac t1r1 true 3 ecagf edcagf cmppanac t17 true 3 ecahfedcahf cmppacac z17 true 3 ecahfedcahf cmppacac t1r2 true 3 ecahf edcahf cmppanac t17 true 3 t2t1s true 2 br lbagf 3 br lbahf 3 figure 8 extended example pspec chr optimizations applied cmpp instructions displayed italics define predicates used optimization therefore statements removed final code allow algorithm effectively apply chr predicated hyperblocks since fullpath predicates expose original separate paths throughout hyperblock schlansker et al 28 recently expanded previous research applying speculation prior attempting height reduction speculation needed remove dependences branch conditions need combined accomplish reduction however work speculation limited operations would overwrite live register memory value speculated since use renaming figure 5 cmpp operation defining bagf cagf shown scheduled cycle 5 due dependences t1 r1 pssa allows us apply pspec schedule definitions cycle 1 making cmpp available chr shown figure 8 521 instruction scheduling pspec chr instruction scheduling pspec performed described section 511 sequential pass instructions control operation cmpp chr performed possible recall operations figure 5 scheduled order given pssa hyperblock like pspec chr compares operations earliest schedulable cycle must scheduled waited guarding predicate defined need wait definition guarding predicate simply scheduled earliest schedulable cycle without pspec definition bagf waiting definition t1 r1 pspec waiting definition guarding predicate therefore beneficial control height reduce anding condition current definition condition defined guarding predicate schedule definition earlier definition guarding predicate involved conditions anded well conditions must included number cmpp statements needed define current operation increases tag cmpp statements indicates required final definition consider operations z17 t1r1 t17 figure 5 control height reduce operations figure 8 since schedulable cycle 3 based scheduling constraints definition ecagf describes combination z17 true t1r1 value false t17 value true implement logical using ac qualifiers definition ecagf requires conditions z17 t17 condition t1r1 evaluate true fpp get value true one requirements met fpp set false compares performed cycle 19 allowing multiple links control path defined simultaneously algorithm chr found figure 9 f cmpp opguarding pred defined cmpp opearliest schedulable cycle f cmpp opschedulecmpp opearliest schedulable cycle f apply control height reduction else f stmts definingcmpp opguarding pred f next defnext defining stmtcmpp opguarding pred copyduplicatenext def copyschedulenext defget scheduling time copypredicate onnext defget guarding pred copyset definecmpp opget pred defined copyset tag toa cmpp opschedulenext defget scheduling time cmpp oppredicate onnext defget guarding pred cmpp opset tag toa figure 9 basic control height reduction algorithm using pspec chr pssatransformed code results 4 cycle schedule shown figure 8 note operations shown italics removed postpass operations define predicates never used using predicated speculation control height reduction together pssatransformed code allows every operation scheduled earliest schedulable cycle 6 results implemented algorithms perform pssa chr pspec hyperblocks trimaran system version 200 collect profilebased execution weights operations codes schedule operations assumed onecycle latency order calculate execution time additionally conservatively assume load dependent prior stores along given path store dependent prior stores well also ensure instructions along path leading branch hyperblock executed prior exiting hyperblock figure shows normalized execution time applying optimizations several trimaran benchmarks fib mm wc fir wave nbradar trimaran media benchmark qsort alvinn percent execution time original 16way original 16way original infinite optimized 16way optimized infinite figure 10 executed cycles normalized number cycles execute original code produced trimaran 16 issue machine specfp92 compress specint95 li specint95 codes described trimaran benchmark certification 2 original execution times created default trimaran settings exception architecture issue rate set 16 execution time estimated summing together frequency execution hyperblock multiplied number cycles takes execute hyperblock assuming perfect memory system infinite results restrict number operations issued per cycle 16way results obtained dividing cycle scheduled 16 operations ceilingtotal operations scheduled cycle 16 cycles results normalized original schedule generated trimaran 16issue machine scheduled 16way optimized results show performance applying pssa pspec chr results show using pssa pspec chr results significant reduction executed cycles figure 11 shows average number operations executed per cycle configurations examined figure 10 comparing two graphs 16way results 34 times many instructions issued per cycle applying pssa pspec chr resulted reduction execution time ranging 12 68 since pspec chr applied pssa code effect removing restrictions control dependence optimized infinite results provide picture best case instruction level parallelism inspection optimized infinite results alvinn compress li show given current hyperblock formation peak ipc somewhat limited renaming required pssa pspec also significantly increases register pressure trimarans isa playdoh supports 4 register files general purpose floating point branch predicate 2 19 average instructions per cycle original 16way original infinite optimized 16way optimized infinite figure weighted average number operations scheduled per cycle hyperblocks using pssa predicated speculation control height reduction note several optimized infinite results greater 16 issue width simulated experiments10305070 average live registers original optimized fib mm wc fir wave nbradar qsort compress alvinn li figure 12 weighted average register pressure hyperblocks using pssa predicated speculation control height reduction shown left right benchmark general purpose file predicate file branch file floating point file zero utilization benchmarks percent code expansion static dynamic figure 13 static dynamic code expansion normalized original code size dynamic code expansion indicates increase working set size supported instruction cache figure 12 shows average number live registers original code optimized code using pssa pspec chr average live register results weighted frequency hyperblock execution example matrix multiply average 17 live general purpose registers original code 54 live general purpose registers optimization though increase utilization register files notable weighted average utilization mostly still remains within reported register file sizes 128 general purpose 128 floating point 8 branch 64 predicate 3 additionally pssa combined aggressive pspec chr significantly increases code size static dynamic aggressive resource insensitive application chr pspec aims reduce cycles required schedule cost duplicated code specialized particular paths case pspec duplicated code faster computation predicates case chr figure 13 shows static dynamic code expansion pssa pspec chr optimized code original code calculate static code expansion comparing number static operations optimized code number static operations original code dynamic code expansion measured similarly exception static operation weighted number times executed calculated trimarans profilebased region weights dynamic code expansion intended capture runtime effect introduced duplicated code memory system dynamic code expansion indicates increase working set size supported instruction cache 7 related work predicated execution presents challenges prospects researchers addressed variety ways mahlke et al 21 showed predicated execution used remove average 27 executed branches 56 branch mispredictions tyson also found similar results correlated relationship predication branch prediction 29 effort relieve difficulties related applying compiler techniques predicated code mahlke et al 22 defined hyperblock singleentry multipleexit structure help support effective predicated compilation hyperblocks formed via selective ifconversion 5 24 technique replaces branches predicate define instructions success predicated execution depend greatly region code selected included predicated hyperblock august et al 9 relates pitfalls potentials hyperblock formation heuristics used guide inclusion exclusion paths hyperblock warter et al 30 explore use reverse ifconversion exposing scheduling opportunities architectures lacking support predicated execution well reforming hyperblocks increase efficiency predicated code 9 30 challenges dataflow controlflow analysis hyperblocks also addressed since hyperblocks include multiple paths control one block traditional compiler techniques often conservative inefficient applied methods predicatesensitive analysis devised make traditional optimization techniques effective predicated code 15 18 work presented 11 expanded upon work extended localized predicatesensitive analysis presented 15 18 complete path analysis hyperblock pathsensitive analysis previously found useful traditional dataflow analysis 6 10 16 use specialized path information accomplish pssa predicatesensitive form ssa 13 12 enables predicated speculation control height reduction hyperblocks previously examined presence single path control found superblocks 26 27 28 moon ebcioglu 23 implemented selective scheduling algorithms schedule operations earliest possible cycle nonpredicated code work extends predicated code allowing earliest possible cycle scheduling using predicated renaming fullpath predicates implementing pssa ia64 implementing pssa using ia64 isa 3 would straightforward exception predicate statement introduced found statement useful efficiently combining path information order eliminate unnecessary code expansion instruction explicitly added ia64 could implemented transferring predicate register file general register using move predicate instruction ia64 general purpose masking instruction would used mask bits corresponding sources predicate instruction result zero evaluates false anything else evaluates true ia64 unlike playdoh isa places limits compare instructions example conditions included logical compare statements compare variable zero specifically statement lbagfebagf cmppanan t1r1 true figure 8 would permitted implementing chr would transform prior expression following 2 statements expressed ia64 9 future work constructing hyperblock schedule specific processor implementation resource limits mandate many operations performed cycle architectural characteristics issue width resource utilization number available predicate registers number available rename registers need considered creating architecturespecific schedule goal hyperblock scheduler reduce executionheight taking architectural features consideration paper goal show pssa provided efficient form renaming precise path information allow operations scheduled earliest schedulable cycle currently examining different pssa representations reduce code duplication number fullpath predicates created since various control paths hyperblock may different true data dependence heights may provide advantage speculate operations critical path hyperblock pssa could concentrate critical paths hyperblock reducing code duplication noncritical paths may advantageous pssa implement oefunctions combining different variable names instead maintaining renamed variables fullpath hyperblock point hyperblock paths join copy operations could used return renamed definitions original names path definitions could restarted point would reduce amount duplication required given operation use correctly renamed variables future research concentrates issues creating efficient implementation pssa conclusions paper extended 11 predicated static single assignment first introduced motivated need renaming predicate analysis extends across paths hyperblock demonstrated predicated static single assignment pssa predicatesensitive implementation ssa implements renaming using fullpath predicates used eliminate false dependences predicated code showed benefit using pssa enable predicated speculation pspec control height reduction chr scheduling predicated speculation allows operations executed earliest schedulable cycle even guarding predicates determined control height reduction allows guarding predicates defined soon possible reducing amount speculation needed maintaining information original control paths hyperblock pssa provide information allows precise placement renamed speculated code allows correct renamed values propagated subsequent operations renaming used pssa allows aggressive speculation overwriting live values longer concern addition pssa supports control height reduction along every control path using fullpath predicates reducing control dependence depth throughout hyperblock experiments show pssa effective tool optimizing predicated code gave extended experiments show using pssa pspec chr results reduction executed cycles ranging 12 68 16 issue machine acknowledgments would like thank compiler architecture research group hewlett packard university illinois impact group new york universitys reactilp group providing trimaran specifically appreciate time patience rodric rabbah scott mahlke vinod kathail richard johnson answering many questions regarding trimaran system addition would like thank scott mahlke providing useful comments paper work supported part nsf career grant ccr9733278 national defense science engineering graduate fellowship research grant intel corporation equipment support hewlett packard intel corporation r merced processor ia64 architecture conversion control dependence data dependence improving dataflow analysis path profiles integrated predicated speculative execution impact epic architecture impact epic 10 architecture instruction set reference manual framework balancing control flow predication efficient path profiling predicated static single assignment efficient method computing static single assignment form efficiently computing static single assignment form control dependence graph compiling cydra 5 global predicate analysis application register allocation path profile guided partial dead code elimation using predication hp make epic disclosure analysis techniques predicated code hpl playdoh architecture specification version 10 multiflow trace scheduling compiler characterizing impact predicated execution branch prediction effective compiler support predicated execution using hyperblock parallelizing nonnumerical code selective scheduling software pipelining predicated execution cydra 5 departmental supercomputer critical path reduction scalar programs height reduction control recurrences ilp processors control cpr branch height reduction optimization epic architectures effects predicated execution branch prediction reverse ifconversion high performance compilers parallel computing tr ctr fubo zhang erik h dhollander using hammock graphs structure programs ieee transactions software engineering v30 n4 p231245 april 2004 mihai budiu girish venkataramani tiberiu chelcea seth copen goldstein spatial computation acm sigarch computer architecture news v32 n5 december 2004
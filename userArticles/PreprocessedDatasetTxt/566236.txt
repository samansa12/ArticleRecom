deterministic parallel backtrack search backtrack search problem involves visiting nodes arbitrary binary tree given pointer root subject constraint children node revealed parent visited present fast deterministic backtrack search algorithm pprocessor common crcwpram visits nnode tree height h time onphlogloglogp22 upper bound compares favourably natural ohgrnph lower bound problem approach embodies novel efficient techniques dynamically assigning treenodes processors ensure work shared equitably among b introduction several algorithmic techniques employed solving many optimization problems based systematic exploration tree whose internal nodes correspond partial solutions growing progressively rened increasing depth whose leaves correspond feasible solutions paper concerned implementation tree explorations research supported part ec esprit iii basic research project 9072geppcom cnr italy grant cnr9602538ct07 murst italy project mosaico results paper appeared preliminary form proceedings 23rd international colloquium automata languages programming paderborn germany july 1996 preprint submitted elsevier preprint january 2001 sharedmemory parallel machines specically consider backtrack search problem involves visiting nodes tree subject constraints 1 initially root known processors 2 children node made known node visited moreover structure size n height h unknown processors assume node visited children revealed constant time since n work needed visit n nodes since tree height h contains path h nodes whose visit times must form strictly increasing sequence follows algorithm backtrack search problem requires time pprocessor machine number works parallel backtrack search appeared litera ture randomized algorithms developed completelyconnected network processors kz93lab93 butter network ran94 run optimally onph steps high probability noted however butter algorithm focuses number nodevisiting steps fully account overhead due manipulations local data structures deterministic algorithm given kp94 runs ph time p p op clear whether latter algorithm extended work larger tree sizes relationship computation communication exploration trees arising irregular divideandconquer computations studied wk91 number related problems also addressed liter ature branchandbound ran90kz93lab93kp94hpp99ahpp99b dynamic tree embeddings al91bgll91lnrs92 paper present deterministic pram algorithm backtrack search whose running time within triplylogarithmic factor natural lower bound discussed main result summarized following theorem theorem 1 deterministic algorithm running pprocessor common crcwpram performs backtrack search nnode boundeddegree tree height h np hlog log log p 2 time worst case rst ecient deterministic pram algorithm places restrictions structure size height boundeddegree tree applied whose running time faithfully accounts costs algorithm performs optimal number onp steps olog log log p 2 multiplicative factor running time captures average overhead per step required ensure workload equitably distributed among processors consequence algorithm would become optimal cost node visit e likely case typical applications backtrack search every node represents complex subproblem solved rest paper organized follows section 2 provides number basic denitions discusses simple direct approach backtrack search algorithm uses combination sophisticated strategy attain eciency highlevel structure algorithm described section 3 section 4 provides detailed description key routine performs node visits load balancing section 5 argue generality approach discussing adapted schedule straightline computations represented boundeddegree dags section 6 closes paper nal remarks preliminaries algorithm designed common crcw pram model com putation consists p processors shared memory unbounded size single step processor either performs constant amount local computation accesses arbitrary cell shared memory common crcw variant pram concurrent reads permitted concurrent writes provided competing processors write value jaj92 let tree visited simplicity assume tree binary although results immediately extended general class boundeddegree trees concreteness suppose node represented memory means descriptor initially descriptor root available shared memory pram designated location descriptor node generated accessing descriptor nodes father visit node involves accessing descriptor generating storing descriptors children mentioned node visit assumed take constant time straightforward strategy solve backtrack search problem visit tree breadthrst levelbylevel fashion algorithm based strategy would proceed phases phase visits nodes certain level evenly redistributes children among processors guarantee overall number parallel visiting steps nph term parallel visiting step refers ktuple k p simultaneous visits distinct tree nodes performed distinct pram processors perfectly balanced redistribution tree nodes among processors successive parallel visiting steps accomplished deterministically using simple parallel prex sums jaj92 yielding onph log p overall running time backtrack search note strategy also works weaker erew pram variant concurrent readwrite accesses allowed fact asymptotically optimal number np visiting steps still achieved without perfect balancing requiring nodes level tree approximately redistributed among processors nodes processor given must constant factor would receive perfect balancing approximate redistribution attained using following result goldberg zwick fact 2 gz95 arbitrary sequence p integer values 0 approximate prex sums b determined olog log p worstcase time pprocessor common crcwpram employing approximate prex sums implement node redistribution visiting level tree get deterministic onph log log p time algorithm backtrack search problem pprocessor common crcwpram values n h p next sections devise sophisticated strategy outperforms simple one trees log log plog log log p 2 asymptotic improvement results near optimal performance careful loadbalancing techniques without excessive global communication 3 highlevel view algorithm algorithm proceeds quasibreadthrst fashion let tree nodes partitioned h levels nodes one level distance root exploration process split stages visits stratum tree consisting consecutive levels beginning stage nodes top level stratum approximately distributed among processors note previously mentioned straightforward strategy based approximate prex sums visits stratum size therefore focus techniques cope eciently smaller strata consider stage visiting stratum nodes convenience number levels stratum 0 1 top bottom stage explores nodes levels point exploration set nodes whose descriptors generated yet visited called frontier initial frontier contains nodes top level stratum let f j denote frontier nodes level j denote entire frontier order evaluate progress algorithm making dene weight function frontier f follows ie nodes level j weight 3 j note contribution frontier node wf exponentially decreasing level within stratum also visiting frontier node level j involves replacing node frontier children whose combined weight 2 3 constant factor less parent hence node visit decreases frontier weight visiting nodes lower numbered levels rather nodes stratum results substantial decrease weight function order avoid frequent expensive balancing steps exploration strategy necessarily proceed regular breadthrst man ner nonetheless make use certain cheaper weightdriven loadbalancing techniques ensure frontier weight decreases predictable rate pictorial representation exploration process shown fig 1 stage consists two parts rst part sequence parallel visiting steps performed explore nodes stratum frontier weight less equal p order detect end rst part visiting stratum h fig 1 weightdriven exploration process tree height h portion within thin solid lines encloses visited nodes belonging previous strata thick solid lines enclose visitedgenerated nodes within current stratum levels frontier nodes lie along thick spline dashed lines enclose nodes still generated b frontier weight reduction induced visit node level j stratum 0 j steps executed batches weight estimate computed execution batch using approximate prex sums algorithm whose olog log p complexity dominated visiting steps second part stage completes exploration stratum follows first every 0 j cluster 2 j distinct processors assigned node f j means approximate prex sums olog log p time since assignment feasible next descendants node f visited corresponding cluster processors time specically consider frontier node x level j let fp cluster processors assigned exploration proceeds 1 j rounds round k 0 k 1 j descendants x distance k visited round zero p 0 visits x gives children p 0 p 1 thereafter round p takes node given previous round visits gives children processors p 2i p 2i1 end stage children nodes last level stratum make initial frontier next stage evenly distributed among processors employing approximate prex sums algorithm highlevel procedural description new strategy visiting small strata op 2 nodes given fig 2 summary stratum visited stage procedure stage visit rst alternating parallel visiting steps procedure visiting step approximate count frontier weight procedure approximate count latter goes p visit stratum completed rst allocating processor clusters residual unexplored nodes procedure allocate clusters visiting subtrees within stratum using simple technique illustrated procedure complete visit nally redistributing initial frontier next stage p processors procedure redistribute nodes note three proce procedure stage visit wf p repeat times repeat fig 2 overall structure algorithm visiting small strata dures nodes implemented means simple variations approximate prex sums algorithm gz95 order determine total running time stage need give bound number visiting steps performed let f frontier beginning tth visiting step step called full visits p nodes f called reducing visits least half nodes range 0 section 4 show perform visiting step time olog log log p 2 ensuring always either full reducing see theorem 10 clearly stratum nodes omp full visiting steps stage whereas number reducing steps bounded following lemma lemma reducing visiting steps sucient reduce frontier weight p proof proof based following property claim let x two sequences nonnegative integers proof claim proof induction n case suppose property holds n 1 consider sequences assume x n n since otherwise inductive step immediate easy see note therefore applying induction hypothesis combined previous inequality proves claim consider reducing visiting step let f frontier prior execution step let n j number nodes f j visited step visiting step reducing 0 claim shows jf jj thus visited nodes account least half total frontier weight since combined weight children node two thirds weight parent follows weight reduction must least one third total weight visited nodes ie least one sixth frontier weight wf prior execution visiting step thus new frontier weight following completion step 56wf since frontier beginning stage contains op 2 nodes level 0 initial frontier weight op 2 3 implies frontier weight less equal p reducing steps proves lemma discussion conclude new strategy employed visit stratum size visiting steps strata size visited omp time using straightforward breadthrst strategy outlined section 2 suitably interleave two strategies obtain algorithm visits stratum time omp value immediately yields backtrack search algorithm running time stipulated theorem 1 note number visiting steps required onp h 4 implementation visiting step section describe implementation visiting step enforces property step always either full reducing key idea heaplike data structure holds frontier nodes nodes extracted prior beginning visiting step children inserted end step conceptually composed p array tree rings also regard p pram processors conceptually arranged rows beginning visiting step tree rings ith row contain current frontier nodes level 0 tree ring structured forest complete binary trees dierent sizes 1 leaf vertices tree ring nodes tree visited internal vertex contains pointers children roots trees tree ring organized doublylinked list ordered tree size data structure broadly similar one used cv88 previous section assume stratum visited size op 2 use k denote upper bound size ie number node descriptors stored tree ring execution stage later show hence height tree tree ring always olog noted tree ring notionally associated particular processor since stored shared pram memory accessible visiting step consists two substeps visit balance described following paragraphs visit substep executed parallel column processors let total number nodes held tree rings column let c 1 constant specied later processors column select minfs 4cg topmost nodes union tree rings distribute nodes evenly among processor visits nodes receives finally children justvisited nodes inserted appropriate tree rings within column balance substep executed parallel row processors aims partially balancing nodes stored tree rings row dene degree processor number tree nodes contained tree ring let f sum degrees processors row ie number frontier nodes level stratum balance redistributes nodes among tree rings way upon completion minff processors degree larger cdf qe row 0 moreover balance never increases maximum processor degree row actual implementation balance substep rather involved discussed separately subsection 41 avoid confusion discussing elements tree visited trees employed tree rings use term node exclusively connection former reserve term vertex latter lemma 4 visiting step always either full reducing proof let f frontier beginning visiting step minfjf jj qg2k processors row j degree larger cdjf jjqe j 0 j ensured either balance substep executed end preceding visiting step visiting step consideration rst stage approximately even distribution frontier nodes guaranteed start stage call tree nodes maintained overloaded processors bad nodes others good nodes since k upper bound degree processor total number bad nodes rst levels frontier minfjf jj qg 0 thus bad nodes level lower account half total number frontier nodes levels suppose jf j 3p let r q number columns holding fewer nodes since column holds nodes number good nodes bounded follows following tedious simple arithmetic manipulations implies r q1 18c since c constant greater one conclude columns hold least nodes thus visiting step visit nodes hence step full consider case jf j 3p since number good nodes column cjf jq 4c follows total number nodes visited step least equal total number good nodes observation made know visited good nodes 0 would visit least half frontier nodes level lower hence step would reducing since column select topmost nodes available good nodes visited least number nodes higher levels visited place maintains reducing property order implement visiting step described need ecient primitives operate tree rings consider stage visiting stratum note beginning stage degree processor 2 visit substep degree increases additive term nodes visited processors column generate two children single visit step since balance substep increase maximum degree processor omp visiting steps executed overall conclude maximum processor degree always 3 consequence throughout stage tree ring contains olog trees 3 size olog height shown cv88 given k nodes evenly distributed among k processors tree ring whose trees contain nodes leaves constructed processors olog 2 two tree rings size ok merged one tree ring olog time single processor 3 number k leaves extracted ok processors tree ring time proportional maximum height tree tree ring extraction tree ring structure restored within time bound easily argued visit substep implemented straightforward fashion within column using standard techniques prex aforementioned primitives manipulate tree rings discussion conclude lemma 5 strata size op 2 visit executed olog olog log log p time 41 implementation balance mentioned use denote upper bound degree processor stratum size op 2 explored exact value k derived analysis assume k known processors prior beginning entire algorithm since balance executed parallel independently rows concentrate operations performed arbitrary row say row k let f k denote total number tree nodes maintained processors row beginning balance substep purpose substep redistribute nodes among processors way redistribution number processors degree greater cdf k qe minff k qg2k noted value f k known processors substep also ensures maximum processor degree increased crucial feature implementation balance nodes physically exchanged processors would costly purposes instead moved manipulating corresponding tree rings cost logarithmic number nodes moved balance based balancing strategy introduced broder et al bfsu92 makes use special kind expander dened denition 6 bfsu92 undirected graph e b extrovert graph b 0 b 1 set v jsj ajv j least bjsj vertices strictly neighbours v existence regular extrovert graphs constant degree proved probabilistic method bfsu92 row identify q processors vertices regular b extrovert graph e odd degree b constants let consists phases numbered 0 1 phase tree nodes maintained row processors marked dormant participate subsequent phases remaining nodes said active beginning phase 0 frontier nodes active 0 phase performs following actions 1 processor k active nodes tree ring declares congested built directed version subgraph g construction proceeds performing steps following type bfsu92 initially empty step every congested processor yet checks whether least neighbours either noncongested already enters acquiring edges 12 neighbours also enter comment construction fact odd guarantee dag congested processor outdegree greater indegree non congested processor dag outdegree 0 moreover depth 3 subdag 0 identied comprising congested processors k active nodes descendants congested processor k active nodes marks k active nodes dormant 2 j k note k j processor 0 extracts direct successors 0 tree containing 2 j distinct active nodes tree ring sends pointer tree successor question processor merges trees receives tree ring pictorial representation construction dags 0 performed phase balance given fig 3 r r c r r b fig 3 dag construction process performed balance extrovert graph g connecting processors row white nodes represent uncongested processors black shaded nodes represent respectively heavily congested processors k active nodes lightly congested processors k 2 k active nodes bc twostep construction dag nal subdag 0 containing heavily congested nodes descendants follows show end phases number processors degree cdf k qe minff k qg2k maximum processor degree increased lemma 7 0 beginning phase processor holds k active nodes k1 nodes moreover phase increases maximum processor degree proof proceed induction case suppose property holds index induction processor starts phase k active nodes k nodes overall congested processor make dag involved movement nodes phase processor begins k nodes k active k1 dormant end phase k nodes remain active rest become remain dormant moreover processors degree change subdag 0 empty congested processors k active nodes k k nodes since case exchange pointers takes place property index instead 0 empty least one congested processor k active nodes note case maximum processor degree greater k congested processor 0 transmits active nodes successors since outdegree congested processor 0 greater indegree represents net loss least nodes therefore processor number active nodes end phase overall degree decreased moreover number dormant nodes processor stays unchanged namely k1 finally noncongested processor begins phase k active nodes receives d2 j dk new active nodes adds less maximum processor degree previous case number dormant nodes processor stays unchanged less k1 refer processors maintaining dormant nodes rogues let rj denote set rogues beginning phase j cj set processors declare congested phase dene r c log 1 ka lemma 8 proof proceed induction j case clearly true since suppose property holds index j 1 consider index j note rogues beginning phase j given set plus set c 0 cj 1 containing congested processors make dag phase j 1 let us give upper bound j note c j 1 minff k qg aq since otherwise congested processors would account active nodes impossible extrovertness graph g rst steps dag construction number congested processors c j 1 implies jc 0 j c j 1 1 b hence number rogues beginning phase j lemma 9 end balance procedure number processors degree cdf k qe minff k qg2k suitable choice constant c moreover procedure executed time olog log log p 2 common crcwpram proof let us rst consider case 0 beginning phase 0 processor maintains k active nodes lemma 7 number rogues 1 lemma 8 choice moreover lemma 7 shows maximum degree processors rogues end phase 0 increase cdf k qe threshold subsequent 0 1 phases consider case 0 case c 2d moreover since r j increasing j total number rogues indicated equation 1 evaluate running time consider phase balance step 1 clearly takes o1 time every dag construction step accomplished constant time hence construction step 2 takes time since depth easy see step 3 accomplished time well cost remaining steps dominated cost extraction merging operations performed tree rings take olog noting number phases conclude overall running time log following theorem combines contributions section establishes result announced section 3 upon analysis backtrack strategy based theorem visiting step within stratum size op 2 implemented olog log log p 2 time pprocessor common crcwpram ensuring step either full reducing 5 evaluation boundeddegree dags section show ideas involved backtrack search algorithm may used solve dag evaluation problem computation dag nodes zero indegree regarded inputs nodes represent operators whose operands values computed predecessors ie nodes adjacent respect incoming edges nodes zero outdegree regarded outputs node evaluated operands evaluated dag evaluation problem consists evaluating output nodes dene layers dag obvious way inputs layer zero layer every node one plus maximum layer among predecessors parallel setting assume dag constant degree stored shared memory pprocessor commoncrcw pram dag node represented descriptor containing following information eld species type operation associated node eld store value two elds operand ie incoming edge processors write value operand timestamp record time pointers nodes successors initially pointers descriptors dag inputs known evenly distributed among processors notice similarity dag evaluation backtrack search problems computational dag necessarily tree nevertheless still visit ie evaluate proceeding quasi breadthrst stratumbystratum fashion backtrack search algorithm precisely recall backtrack search problem node revealed processor visits unique parent dag evaluation prob lem visiting node entails computing nodes value writing value nodes descriptor together timestamp appropriate elds successors descriptors node revealed hence ready evaluatedvisited last predecessors evaluated node regarded child predecessor ties broken arbitrarily fashion spanning forest dag implicitly identied dag evaluation regarded visit forest noting backtrack search algorithm employed visit forest boundeddegree trees onp total number nodes h maximum treeheight forest conclude dag evaluation problem solved within time bound 6 conclusions work devised ecient deterministic strategy performing parallel backtrack search shared memory machine specically strategy attains running time triply logarithmic factor away natural lower bound problem previous studies investigation mainly focused running time hand overall space required algorithm grow large tree size n whereas space required randomized schemes proposed kz93lab93ran94 bounded minfn phg latter quantity however close n large values p andor highly unbalanced trees remains challenging open problem devise fast space ecient backtrack search algorithms generally study timespace tradeos parallel backtrack search r coding theory tight bounds online tree embeddings approximate parallel scheduling optimal deterministic approximate parallel pre fast deterministic parallel branch bound deterministic branch bound distributedmemory machines parallel algorithms backtrack search branch bound computation atomic model messagepassing dynamic tree embeddings butter ies hypercubes simpler analysis karpzhang parallel branchand bound method optimal speedup backtrack search butter network communication complexity parallel divide andconquer tr approximate parallel scheduling part basic technique applications optimal parallel list ranking logarithmic time coding theory hypercube embeddings fault tolerance communication complexity parallel divideandconquer tight bounds online tree embeddings introduction parallel algorithms dynamic tree embeddings butterflies hypercubes atomic model messagepassing randomized parallel algorithms backtrack search branchandbound computation branchandbound backtrack search meshconnected arrays processors optimal speedup backtrack search butterfly network nearperfect token distribution optimal deterministic approximate parallel prefix sums applications simpler analysis karpzhang parallel branchandbound method
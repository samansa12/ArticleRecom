race conditions sharedmemory parallel programs use explicit synchronization race conditions result accesses shared memory properly synchronized race conditions often considered manifestations bugs since presence cause program behave unexpectedly unfortunately little agreement literature precisely constitutes race condition two different notions implicitly considered one pertaining programs intended deterministic call general races nondeterministic programs containing critical sections call data races however differences general races data races yet recognized paper examines differences characterizing races using formal model exploring properties show two variations type race exist feasible general races data races capture intuitive notions desired debugging apparent races capture less accurate notions implicitly assumed dynamic race detection methods also show locating feasible races nphard problem implying apparent races approximations feasible races detected practice complexity dynamically locating apparent races depends type synchronization used program apparent races exhaustively located efficiently weak types synchronization incapable implementing mutual exclusion result important implications since argue debugging general races requires exhaustive race detection inherently harder debugging data races requires partial race detection programs containing data races therefore efficiently debugged locating certain easily identifiable races contrast programs containing general races require complex debugging techniques b introduction sharedmemory parallel programs accesses shared memory properly synchronized timedependent failures called race conditions result race conditions occur different processes access shared data without explicit synchronization races cause program behave ways unexpected programmer detecting important aspect debugging however literature seems little agreement precisely constitutes race condition indeed two different notions used distinction previously recognized consistent terminology appeared several terms used different intended meanings access anomaly68 12 18 data race1 4 5 11 16 20 22 critical race13 harmful sharedmemory access24 race condition10 26 race2 9 17 paper explores nature race conditions uncovers previously hidden issues regarding accuracy complexity dynamic race detection present following results 1 two fundamentally different types races capture different kinds bugs different classes parallel programs occur general races cause nondeterministic execution failures programs intended deterministic data races cause nonatomic execution critical sections failures nondeterministic programs access update shared data critical sections represent sources race conditions precisely formally characterize intuitive notion race wish detect debugging call feasible race contrast show simpler detect less accurate notion race previously proposed race detection methods locate call apparent race feasible races based possible behavior program apparent races approximations feasible races based behavior programs explicit synchronization semantics programs computation 3 exactly locating feasible general races data races nphard problem result implies apparent races simpler locate must detected debugging practice apparent races exhaustively located efficiently programs use synchronization incapable implementing mutual exclusion forkjoin postwait synchronization without clear opera tions detection nphard powerful types synchronization semaphores debugging race conditions programs intended deterministic inherently difficult nondeterministic programs races cause nonatomic execution critical sections data races local properties execution detected directly execution trace contrast races cause nondeterministic execution general races global properties program whose detection requires analyzing entire execution compute alternative event orderings possibly exhibited program results provide understanding race conditions important dynamic race detection previous work provided unambiguous characterizations different types race conditions related races program bugs example race conditions defined occurring two sharedmemory consistent fault tolerant research community25 failure occurs programs external behavior differs specification fault algorithmic cause although use term bug controversy terminology descriptive place data race general race atomicity race determinacy race also suggested references potentially execute concurrently6 guaranteed runtime ordering10 work novel since explicitly characterize two different types race conditions using formal model explore properties distinction general races data races necessary manifestations different types program bugs require different detection techniques using model advantage issues regarding accuracy complexity dynamic race detection become clear accuracy issues implications debugging accurate race detection means races direct manifestations program bugs pinpointed less accurate detection report spurious races mislead programmer complexity issues show types races allow exact efficient detection approximately located results show locating exactly desired races feasible races computationally intractable indeed previously proposed race detection methods take easier approach locate subset apparent races however argue apparent races often spurious effective debugging requires sophisticated techniques race conditions debugged attempting determine located apparent races interest debugging ie feasible results show also fundamental disparity debugging race conditions deterministic nondeterministic programs nondeterministic programs use critical sections safely debugged find data races easily determine execution datarace free data races occur feasible races approximately located however debugging programs intended deterministic find general races inherently harder confident execution deterministic exhaustive race detection shows absence general races efficient programs using synchronization incapable implementing mutual exclusion 2 examples explicit synchronization often added sharedmemory parallel programs coordinate accesses shared data without proper coordination different types race conditions result motivate different types races present example subsequent sections characterize terms formal model investigate properties one purpose adding explicit synchronization sharedmemory parallel programs implement critical sections blocks code intended execute atomic atomic execution means final state variables read written section depends upon initial state start section upon operations performed code operations performed another process bernsteins conditions state atomic execution guaranteed shared variables read modified critical section modified concurrently executing section code3 violation conditions typically called data race1 4 5 11 16 17 20 22 access anomaly68 18 prefer term data race figure 1 shows example program data race considered failure program processes commands bank tellers make deposits withdrawals given bank account figure 1a shows correct version program since variables balance interest shared operations manipulate enclosed critical sections critical sections never execute concurrently version exhibit data races figure 1b shows erroneous version exhibit data races p v operations enforced mutual exclusion missing deposit withdraw code therefore execute con currently causing individual statements effectively interleave possibly violating atomicity one process 1 process 2 balance amount else nodatarace version process 1 process 2 balance amount else datarace version figure 1 c program fragment manipulating bank account b erroneous version exhibiting data races intended critical sections data races program considered failures intent deposit withdrawal code execute atomically without interference processes even though programs like one figure 1 may contain critical sections often intended nondeterministic eg order deposits withdrawals may occur unpredictably depending fast tellers type however classes programs intended completely deterministic different type race condition pertains programs programs synchronization provides determinism forcing accesses shared resource always execute given input specific order given input executions programs always produce result regardless random timing variations among processes program eg due unpredictable interrupts programs may executing processors nondeterminism generally introduced order two accesses resource enforced programs synchronization existence two unordered accesses called race condition9 10 26 access anomaly12 critical race13 harmful sharedmemory access24 consistent terminology propose term general race since race general data race example programs general races manifestations bugs consider parallel programs constructed sequential programs parallelizing loops sequential version program behaves deterministically producing particular result given input typically parallelized version intended semantics preserving semantics accomplished adding synchronization program ensures data dependences ever exhibited sequential version also exhibited parallel version programs exhibit general races since preserving dependences requires operations specific location performed specific order independent external timing variations general races data races notions necessary debugging although occur sharedmemory accesses occur incorrect unexpected order manifestations different types bugs occur different classes parallel programs notion data race needed discover critical sections implemented properly ie whose atomicity may failed notion general race needed discover potential nondeterminism anywhere program execution data races alone suffice purposes since program exhibit data races still nondeterministic general races alone suffice since general races data races always failures preceding examples illustrate cases example nodatarace version figure 1 executes nondeterministically depending commands entered tellers version correctly exhibits data races critical sections execute atomically even though nondeterministic however even though general races occur considered manifestations bugs general races data races also pertain different classes parallel programs general races typically interest programs determinism implemented forcing sharedmemory accesses location occur specific order many scientific programs fall category eg constructed many automatic parallelization techniques contrast data races typically interest asynchronous pro grams programs using shared workpools fall category intended deterministic critical sections access shared data still expected behave atomically emrath padua also characterized different types race conditions addressed programs intended deterministic9 considered four levels nondeterminism program given input internally deterministic programs whose executions given input exhibit general races externally deterministic programs exhibit general races cause final result program change run run associatively nondeterministic programs exhibit general races associative arithmetic operations externally nondeterministic roundoff errors different runs produce different roundoff errors finally completely nondeterministic programs exhibiting general races fall one categories work complements characterizations also considering nondeterministic programs data races using formal framework 3 formal model reasoning race conditions given examples illustrating different types race conditions next discuss characterized using formal model provides unambiguous characterizations also provides mechanism reason properties section briefly overview model reasoning race conditions first presented earlier paper22 based lamports theory concurrent systems15 model consists two parts one represent actual behavior exhibited program represent potential behaviors possibly exhibited program 31 actual program executions first part model simply notation representing execution sharedmemory parallel program sequentially consistent14 processor program execution p triple e e finite set events temporal ordering relation shareddata dependence relation relations events intuitively e represents actions performed execution represents order performed shows events affect one another accesses shared memory refer p actual program execution p represents execution program hand actually performed event e e represents execution instance set program statements sets shared memory locations read write synchronization event represents instance synchronization operation computation event represents execution instance group statements belonging process executed consecutively none synchronization operations data conflict exists two events one writes shared memory location reads writes two events b b means completes b begins sense last action affect first action b means b execute concurrently ie neither completes begins emphasize defined describe actual execution order events particular execution eg means b actually execute concurrently mean could executed order shareddata dependence b exists accesses shared variable b later accesses least one access modifies variable precedes b process since data general flow nonshared variables local process dependence also exists chain dependences b eg accesses shared variable another event c later accesses c references variable b later references 32 feasible program executions actual program execution convenient notation describing behavior particular execution however characterize race conditions necessary also describe behavior program could exhi bited previous work explicitly considered issue race conditions typically defined dataconflicting accesses execute parallel6 whose execution order guaranteed10 definitions implicitly refer set alternative orderings potential occurring work novel explicitly define sets orderings second part model characterizes sets feasible program executions represent executions potential occurring next discuss several possible ways sets defined instead simply intuitively reasoning alternative order ings formally defining sets uncovers issues important debugging sequential consistency ensures sharedmemory accesses behave performed atomically linear order model also contains axioms describing properties program execution must possess22 omit axioms unnecessary simply characterizing race conditions superscripted arrows denote relations b shorthand b b characterize race condition exists two events b actual program execution must consider program executions also perform b characterizing executions allows us determine b potentially execute order different p focus program executions pe prefixes p implicitly consider executions input p p prefix p process p performs events initial part corresponding process p focusing prefixes allows us pinpoint nondeterminacy introduced p required prefix p could general determine b occur p p contains different number execution instances statement draw correspondence events p events p events defined represent execution instance one statements define three sets program execution prefixes considering successively fewer restrictions different ways ps events could performed see different sets characterize races varying accuracy complexity first two sets restricted contain program executions feasible ie could actually occurred sets characterize races accurately first set denoted f contains feasible executions exhibit shareddata dependences second set denoted f diff contains feasible executions restrictions shareddata dependences f diff includes executions perform prefix events performed p regardless shareddata dependences may result f includes executions perform exactly events exhibit shareddata dependences p definition 31 f set program executions pe represents execution program could actually perform definition 32 f diff set program executions pe represents execution program could actually perform 2 p prefix p 3 represents shareddata dependences satisfy 1 2 last set denoted f sync also contains executions arbitrary shareddata dependences longer required feasible required obey semantics programs explicit synchroniza tion simpler set characterizes races less accurately useful approximation f diff involves semantics explicit synchronization program moreover since previous race detection methods analyze explicit synchronization f sync set alternative executions implicitly assume structure set depends details definition shareddata dependence although different definitions possible eg characterize flow dependences would alter structure significant way f sync set program executions pe obeys semantics programs explicit synchronization 2 p prefix p 3 represents shareddata dependences satisfy 1 2 f sync includes executions would possible p exhibited shareddata dependences dependences affect control flow since programs general access sharedmemory f sync may include executions program could never exhibit example assume one process p assigns shared variable value 1 another process conditionally executes procedure equals 1 explicit synchronization forces assignment occur procedure call f sync contain execution procedure called assigned 1 however since procedure called equals 1 execution feasible assuming initialized 1 general another execution perform events p must also exhibit shareddata dependences general races occur whether considered failures f sync may contain infeasible executions19 22 discussed later existence infeasible executions impacts accuracy races reported methods analyze explicit synchron ization nevertheless see notion useful allows simple characterization race conditions easy detect 4 issues characterizing race conditions characterize general races data races terms model explore issues arise show two different types race exist one type feasible race captures intuitive notion wish express nphard locate exactly type apparent race captures less accurate notion assumed race detection methods easily detected moreover argue debugging programs intended deterministic find general races requires exhaustive race detection inherently harder debugging nondeterministic programs use critical sections find data races requires partial race detection 41 general races data races intuitively general race potentially introduces nondeterminism exists program execution p two events b data conflicts access order guaranteed executions synchronization data race potentially causes atomicity critical sections fail exists b either execute concurrently potential explore nature races first formalize means potentially execute concurrently different order using different sets program executions discussed example general race exists b occur feasible program execution order different p similarly data race exists feasible program execution exists b execute concurrently first define notion general race data race b denoted ab given set program executions f consider implications different choices set f general race ab f exists iff 1 data conflict exists p b 2 exists program execution pe f ab e b b b b b c condition 2 true b occur order opposite p concurrently cases capture notion execution order among b guaranteed definition 42 data race ab f exists iff 1 data conflict exists p b 2 exists program execution pe f ab e 42 feasible races natural way characterize race ab consider races f diff since f diff precisely captures set possible executions also perform b general races choice smaller set f inadequate since definition general race exists two accesses execute order different p therefore shareddata dependence also different contrast data races could reasonably viewed occurring either f diff f definition 43 feasible general race ab exists iff general race ab f diff exists feasible data race ab exists iff data race ab f diff exists feasible race locates precisely portions execution allowed race thus represents intuitive notion race illustrated section 2 however checking presence feasible general race data race ab requires determining whether feasible program execution b b member f diff proven deciding membership problems nphard matter type synchronization program uses locating feasible races also nphard19 21 therefore intractable problem locate precisely race conditions exhibited execution program result suggests practice must settle approximation discussed next indeed previously proposed race detection methods compute approximation 43 apparent races practice locating intuitive notion race feasible race would require analyzing programs semantics determine execution could allowed b precede b execute concurrently previously proposed methods take simpler approach analyze explicit synchronization performed execution example b said potentially executed concurrently order explicit synchronization prevented characterize races detected approach using f sync based orderings programs explicit synchronization might allow program may able exhibit orderings races capture less accurate notion feasible races definition 44 apparent general race ab exists iff general race ab f sync exists apparent data race ab exists iff data race ab f sync exists program executions f sync feasible apparent races may spurious spurious races occur whenever values shared variables used directly indirectly conditional expressions sharedarray subscripts20 22 cases existence one event may depend another event occurring first example consider one process p adds data shared buffer sets flag bufempty false another process first tests bufempty removes data buffer bufempty equals false execution two apparent general races accesses bufempty accesses buffer however race involving buffer spurious feasible execution exists data removed buffer buffer filled since bufempty first tested data removed operations shared buffer instead complex involved many sharedmemory references large number spurious races could reported spurious races pose problem since direct manifestations program bug20 22 programmer overwhelmed large amounts misleading information irrelevant debugging masks location actual failures nonetheless apparent race detection provides valuable information since apparent races exist least one feasible race exists somewhere exe cution22 moreover proven results showing reason potential feasibility apparent races postmortem race detector extended conservatively determine apparent races feasible interest debugging2022 also proven program executions using synchronization powerful enough implement twoprocess mutual exclusion determining membership f sync locating apparent races nphard19 membership f sync efficiently computable weaker synchronization incapable implementing mutual exclusion postwait style synchronization without clear operations apparent races thus efficiently detected executions programs23 important note data races interest programs since weaker synchronization cannot implement critical sections exhaustively locating apparent data races therefore always nphard contrast complexity apparent general race detection depends type synchronization used however discuss next sufficient debugging data races detect certain subset apparent races debugging general races requires exhaustive detection 44 debugging race condition detection important aspect debugging involves determining whether portions execution racefree sense unaffected incorrect inconsistent data produced race5 20 example programmer browsing execution trace might focus portions trace recorded races occurred portions trace contain events guaranteed unaffected outcome race locating events important program may exhibit meaningless behavior race figure 1b ex ample data race results negative balance might cause subsequent withdrawals fail insufficient funds fact money deposited withdrawn locate events unaffected race necessary determine portions execution race free however argue making determination inherently harder general races introduce nondeterminism data races cause critical sections fail executions containing data races suffices detect presence ab sence certain subset apparent races contrast debug executions containing general races necessary perform exhaustive apparent general race detection data races viewed local property execution determined directly actual program execution p intended critical section execute nonatomically data conflicting events concurrently executing actual data race detected directly p definition 45 actual data race ab exists iff data race ab p exists actual data race indicates possibility atomicity critical section may actually failed con trast general races global property program determined computing alternative event orderings general determining two events could occurred different order requires analyzing synchronization entire execution notion actual general race thus unlike general races actual data races easily located temporal ordering known computing alternative orderings unnecessary difference important implications debugging apparent data races actual data races cannot produce inconsistent data critical sections fail apparent general race indicates possibility two sharedmemory accesses could executed incorrect order absence actual data race therefore indicates intended critical sections p executed atomically location actual race pinpoints places execution inconsistent data expected even though apparent data races efficiently located efficiently determine whether actual data races occurred thus easily determine whether observed execution contains inconsistent data cannot relied upon debugging however notion actual general race must exhaustively locate apparent general races make determination apparent races exist sure sharedmemory references occurred expected order order possible results suggest efficiently debug programs containing data races locating actual apparent data races however apply approach programs containing general races apparent races efficiently located discussed exhaustive apparent general race detection efficient programs use synchronization incapable implementing mutual exclusion however powerful types synchronization semaphores conservative approximations locate superset apparent general races proposed10 11 methods provide means debugging general races programs using synchronization potential misleading programmer potentially large numbers spurious race reports data race p exists iff data race exists p set containing p 5 conclusion paper explores nature race conditions arise sharedmemory parallel programs employing formal model uncover previously hidden issues regarding accuracy complexity dynamic race detection show two fundamentally different types races occur general races pertaining deterministic programs data races pertaining nondeterministic programs use critical sections formally characterize types races previously races defined intuitively occurring dataconflicting blocks code potentially execute concurrently whose execution order guaranteed work novel explicitly characterize sets alternative orderings potential occurring important properties defined races accuracy complexity detecting depend upon sets considered uncover two variations type race one describes intuitive notion race feasible race describes less accurate notion apparent race assumed race detection methods since locating feasible races nphard less accurate apparent races must relied upon debugging practice moreover uncover fundamental differences complexity debugging general races data races debugging general races requires exhaustively computing alternative orderings determine whether execution nondeterministic nphard programs using synchronization powerful enough implement mutual exclusion debugging data races requires simpler analyses determine critical sections fail efficiently performed r debugging fortran shared memory machine compiletime detection race conditions parallel pro gram analysis programs parallel processing techniques debugging parallel programs flowback analysis race frontier reproducing data races parallel program debug ging task recycling technique detecting access anomalies thefly empirical comparison monitoring algorithms access anomaly detection detecting access anomalies programs critical sections automatic detection nondeterminacy parallel programs event synchronization analysis debugging parallel programs analyzing traces anonymous synchronization parallel program debugging onthefly anomaly detection critical races ada programs make multiprocessor computer correctly executes multiprocess pro grams mutual exclusion problem part theory interprocess communication onthefly detection data races programs nested forkjoin parallelism mechanism efficient debugging parallel programs efficient cachebased access anomaly detection scheme complexity event ordering sharedmemory parallel program executions improving accuracy data race detection race condition detection debugging sharedmemory parallel programs detecting data races parallel program executions efficient race condition detection sharedmemory programs postwait synchronization tools efficient development efficient parallel programs reliability issues computing system design making asynchronous parallelism safe world tr mutual exclusion problem mechanism efficient debugging parallel programs automatic detection nondeterminacy parallel programs critical races ada programs event synchronization analysis debugging parallel programs making asynchronous parallelism safe world empirical comparison monitoring algorithms access anomaly detection efficient cachebased access anomaly detection scheme improving accuracy data race detection race frontier parallel program debugging onthefly anomaly detection techniques debugging parallel programs flowback analysis detecting access anomalies programs critical sections onthefly detection data races programs nested forkjoin parallelism pace condition detection debugging sharedmemory parallel programs compiletime detection race conditions parallel program reliability issues computing system design ctr erkan keremoglu serdar tasiran tayfun elmas classification concurrency bugs java benchmarks developer intent proceeding 2006 workshop parallel distributed systems testing debugging july 1717 2006 portland maine usa michal young statespace analysis aid testing proceedings 1994 acm sigsoft international symposium software testing analysis p203 august 1719 1994 seattle washington united states utpal banerjee brian bliss zhiqiang paul petersen theory data race detection proceeding 2006 workshop parallel distributed systems testing debugging july 1717 2006 portland maine usa michiel ronsse koen de bosschere mark christiaens jacques chassin de kergommeaux dieter kranzlmller recordreplay nondeterministic program executions communications acm v46 n9 p6267 september arndt mhlenfeld franz wotawa fault detection multithreaded c server applications electronic notes theoretical computer science entcs v174 n9 p522 june 2007 bartosz bali marian bubak wodzimierz funika roland wismller monitoring system multithreaded applications future generation computer systems v19 n5 p641650 july brad richards james r larus protocolbased datarace detection proceedings sigmetrics symposium parallel distributed tools p4047 august 0304 1998 welches oregon united states efficient onthefly data race detection multithreaded c programs acm sigplan notices v38 n10 october mingdong feng charles e leiserson efficient detection determinacy races cilk programs proceedings ninth annual acm symposium parallel algorithms architectures p111 june 2325 1997 newport rhode island united states roberto barbuti stefano cataudella luca tesei abstract interpretation races fundamenta informaticae v60 n14 p6779 january 2004 peter buhr martin karsten jun shih kdb multithreaded debugger multithreaded applications proceedings sigmetrics symposium parallel distributed tools p8087 may 2223 1996 philadelphia pennsylvania united states jrgen vollmer data flow analysis parallel programs proceedings ifip wg103 working conference parallel architectures compilation techniques p168177 june 2729 1995 limassol cyprus min xu rastislav bodik mark hill flight data recorder enabling fullsystem multiprocessor deterministic replay acm sigarch computer architecture news v31 n2 may christoph von praun luis ceze calin cacaval implicit parallelism ordered transactions proceedings 12th acm sigplan symposium principles practice parallel programming march 1417 2007 san jose california usa prem uppuluri uday joshi arnab ray preventing race condition attacks filesystems proceedings 2005 acm symposium applied computing march 1317 2005 santa fe new mexico greg hoover forrest brewer timothy sherwood case study multithreading embedded space proceedings 2006 international conference compilers architecture synthesis embedded systems october 2225 2006 seoul korea dejan perkovic peter j keleher protocolcentric approach onthefly race detection ieee transactions parallel distributed systems v11 n10 p10581072 october 2000 robert ocallahan jongdeok choi hybrid dynamic data race detection acm sigplan notices v38 n10 october jongdeok choi keunwoo lee alexey loginov robert ocallahan vivek sarkar manu sridharan efficient precise datarace detection multithreaded objectoriented programs acm sigplan notices v37 n5 may 2002 michiel ronsse koen de bosschere recplay fully integrated practical recordreplay system acm transactions computer systems tocs v17 n2 p133152 may 1999 jeffrey k hollingsworth critical path profiling message passing sharedmemory programs ieee transactions parallel distributed systems v9 n10 p10291040 october 1998 hiroyasu nishiyama detecting data races using dynamic escape analysis based read barrier proceedings 3rd conference virtual machine research technology symposium p1010 may 0607 2004 san jose california christoph von praun thomas r gross object race detection acm sigplan notices v36 n11 p7082 11012001 amir kamil jimmy su katherine yelick making sequential consistency practical titanium proceedings 2005 acmieee conference supercomputing p15 november 1218 2005 min xu rastislav bodk mark hill serializability violation detector sharedmemory server programs acm sigplan notices v40 n6 june 2005 hagit attiya roy friedman programming decalpha based multiprocessors easy way extended abstract proceedings sixth annual acm symposium parallel algorithms architectures p157166 june 2729 1994 cape may new jersey united states michiel ronsse koen de bosschere nonintrusive detection synchronization errors using execution replay automated software engineering v9 n1 p95121 january 2002 nonblocking communication partitioned global address space programs proceedings 21st annual international conference supercomputing june 1721 2007 seattle washington guangien cheng mingdong feng charles e leiserson keith h randall andrew f stark detecting data races cilk programs use locks proceedings tenth annual acm symposium parallel algorithms architectures p298309 june 28july 02 1998 puerto vallarta mexico arun kejariwal hideki saito xinmin tian milind girkar wel li utpal banerjee alexandru nicolau constantine polychronopoulos lightweight lockfree synchronization methods multithreading proceedings 20th annual international conference supercomputing june 28july 01 2006 cairns queensland australia bohuslav krena zdenek letko rachel tzoref shmuel ur tom vojnar healing data races onthefly proceedings 2007 acm workshop parallel distributed systems testing debugging july 0909 2007 london united kingdom eran yahav verifying safety properties concurrent java programs using 3valued logic acm sigplan notices v36 n3 p2740 march 2001 john danaher iting angelina lee charles e leiserson programming exceptions jcilk science computer programming v63 n2 p147171 1 december 2006 hagit attiya soma chaudhuri roy friedman jennifer l welch shared memory consistency conditions nonsequential execution definitions programming strategies proceedings fifth annual acm symposium parallel algorithms architectures p241250 june 30july 02 1993 velen germany cherri pancake robert h b netzer bibliography parallel debuggers 1993 edition acm sigplan notices v28 n12 p169186 dec 1993
optimal rewardbased scheduling periodic realtime tasks abstractrewardbased scheduling refers problem reward associated execution task framework realtime task comprises mandatory optional part mandatory part must complete tasks deadline nondecreasing reward function associated execution optional part interrupted time imprecise computation increasedrewardwithincreasedservice models fall within scope framework paper address rewardbased scheduling problem periodic tasks optimal schedule one mandatory parts complete timely manner weighted average reward maximized linear concave reward functions common 1 show existence optimal schedule optional service time task constant every instance 2 show efficiently compute service time also prove optimality rate monotonic scheduling harmonic periods earliest deadline first least laxity first policies case uniprocessors used optimal service times computed moreover extend result showing policy fully utilize processors also optimal multiprocessor periodic rewardbased scheduling show optimal solution pushing limits rewardbased scheduling prove reward functions convex problem becomes nphard static optimal solution besides providing considerable reward improvements previous suboptimal strategies also major practical benefit runtime overhead eliminated existing scheduling disciplines may used without modification computed optimal service times b introduction realtime system task must complete produce correct output specified deadline however system overloaded possible meet deadline past several techniques introduced research community regarding appropriate strategy use overloaded systems periodic realtime tasks one class approaches focuses providing somewhat less stringent guarantees temporal con straints 16 instances task allowed skipped entirely skip factor determines often instances given task may left unexecuted best effort strategy introduced 11 aiming meeting k deadlines n instances given task framework also known nkfirm deadlines scheme bernat burns present 3 hybrid improved approach provide hard realtime guarantees k n consecutive instances task techniques mentioned tacitly assume tasks output value executed completely however many application areas multimedia applications 26 image speech processing 5 6 9 28 timedependent planning 4 robot controlnavigation systems 12 30 medical decision making 13 information gathering 10 realtime heuristic search 17 database query processing 29 partial approximate timely result usually acceptable imprecise computation 7 19 21 iris increased reward increased service 14 15 18 models proposed enhance resource utilization graceful degradation realtime systems compared hard realtime environments worstcase guarantees must provided models every realtime task composed mandatory part optional part former completed tasks deadline provide output acceptable minimal quality optional part executed mandatory part still deadline enough resources system committed running mandatory parts task longer optional part executes better quality result higher reward algorithms proposed imprecise computation applications concentrate model upper bound execution time could assigned optional part 7 21 27 aim usually minimize weighted sum errors several efficient algorithms proposed solve optimally scheduling problem aperiodic imprecise computation tasks 21 27 common assumption studies quality results produced linear function precision consequently possibility general error functions usually addressed alternative model allows tasks get increasing reward increasing service iris model 14 15 18 without upper bound execution times tasks though deadline task implicit upper bound without separation mandatory optional parts 14 task executes long scheduler allows deadline typically nondecreasing concave reward function associated tasks execution time 14 15 problem maximizing total reward system aperiodic independent tasks addressed optimal solution static task sets presented well two extensions include mandatory parts policies dynamic task arrivals note imprecise computation iris models closely related since performance metrics defined duals maximizing total reward vs minimizing total error similarly concave reward function corresponds convex error function vice versa use term rewardbased scheduling encompass scheduling frameworks including imprecise computation iris models task logically decomposed mandatory optional subtask nondecreasing reward function associated execution optional part interesting question concerns types reward functions represent realistic application areas linear reward function 19 21 models case benefit overall system increases uniformly optional execution similarly concave reward function 14 15 18 26 addresses case greatest increaserefinement output quality obtained first portions optional executions linear general concave functions considered realistic typical literature since adequately capture behavior many application areas like image speech processing 5 6 9 28 multimedia applications 26 timedependent planning 4 robot controlnavigation systems 30 realtime heuristic search 17 information gathering 10 database query processing 29 paper show case convex reward functions nphard problem thus focus linear concave reward functions reward functions 01 constraints reward accrued unless entire optional part executed step functions also received interest literature unfortunately problem shown npcomplete 27 periodic rewardbased scheduling remains relatively unexplored since important work chung liu lin 7 paper authors classified possible application areas error non cumulative error cumulative former errors optional parts left unexecuted effect future instances task wellknown examples category tasks receive process transmit periodically audio video compressed images 5 6 9 26 28 information retrieval tasks 10 29 error cumulative applications radar tracking optional instance must executed completely every predetermined k invocations authors proved case errorcumulative jobs npcomplete problem paper restrict error noncumulative applications recently qosbased resource allocation model qram proposed periodic applications 26 study problem optimally allocate several resources various applications simultaneously meet minimum requirements along multiple qos dimensions total system utility maximized one aspect viewed generalization optimal cpu allocation problem multiple resources quality dimensions dependent independent quality dimensions separately addressed first time work however fundamental assumption model reward functions resource allocations terms utilization resources work falls rather along lines imprecise computation model reward accrued computed separately task instances problem find optimal service times instance optimal schedule assignments aspects periodic rewardbased scheduling problem difficulty finding optimal schedule periodic rewardbased task set origin two objectives must simultaneously achieved namely meeting deadlines mandatory parts every periodic task invocation ii scheduling optional parts maximize total average reward two objectives important yet often incompatible words hard deadlines mandatory parts may require sacrificing optional parts greatest value system analytical treatment problem complicated fact optimal schedule optional service times given task may vary instance instance makes framework classical periodic scheduling theory inapplicable furthermore fact introduces large number variables analytical approach finally allowing nonlinear reward functions better characterize optional tasks contribution overall system optimization problem becomes computationally harder 7 chung liu lin proposed strategy assigning statically higher priorities mandatory parts decision proven paper effectively achieves first objective mentioned securing mandatory parts potential interference optional parts optional parts scheduled whenever mandatory part ready system 7 simulation results regarding performance several policies assign static dynamic priorities among optional parts reported call class algorithms statically assign higher priorities mandatory parts mandatoryfirst algorithms solution decouple objectives meeting deadlines mandatory parts maximizing total average reward formulate periodic rewardbased scheduling problem optimization problem derive important surprising property solution common ie linear concave reward functions namely prove always optimal schedule optional service times given task vary instance instance important result immediately implies optimality terms achievable utilization policy fully use processor case hardreal time periodic tasks also holds context rewardbased scheduling terms total reward used optimal service times examples policies rmsh rate monotonic scheduling harmonic periods 20 edf earliest deadline first 20 llf least laxity first 24 also extend framework homogeneous multiprocessor settings prove policy fully utilize processors also optimal scheduling periodic rewardbased tasks terms total reward multiprocessors environments following existence proofs address problem efficiently computing optimal service times provide polynomialtime algorithms linear andor general concave reward functions note using optimal constant optimal service times also important practical advantages runtime overhead due existence mandatoryoptional dichotomy reward functions removed b existing rms harmonic periods edf llf schedulers may used without modification optimal assignments remainder paper organized follows section 2 system model basic definitions given main result optimality periodic policy fully utilize processors obtained section 3 section 4 first analyze worstcase performance mandatoryfirst approaches also provide results experiments synthetic task set compare performance policies proposed 7 optimal algorithm section 6 show concavity assumption also necessary computational efficiency proving allowing convex reward functions results nphard problem examine whether optimality identical service times still holds model modified dropping fundamental assumptions section 5 present details specific optimization problem use section 7 conclude summarizing contribution discussing future work system model first develop present solution uniprocessor systems show extend case homogeneous multiprocessor systems consider set n periodic realtime tasks period denoted p also equal deadline current invocation refer j th invocation task tasks assumed independent ready task consists mandatory part optional part length mandatory part denoted task must receive least units service time deadline order provide output acceptable quality optional part becomes ready execution mandatory part completes execute long scheduler allows deadline associated optional part task reward function r indicates reward accrued task ij receives ij units service beyond mandatory portion r 1 f nondecreasing concave continuously differentiable function nonnegative real numbers length entire optional part underline f benefit task ij decrease allowing run longer notice reward function r necessarily differentiable note also formulation time tasks optional execution time reaches threshold value reward accrued ceases increase clearly reward executing optional part amount time reward executing therefore beneficial execute time units function fx concave x 0 ff fffy geometrically condition means line joining two points concave curve may curve examples concave functions linear functions kx functions lnkx decay functions c th root functions x 1k note first derivative nondecreasing concave function nonincreasing nondecreasing concave reward functions means task receives service beyond mandatory portion reward monotonically increases however rate increase decreases remains constant time concavity assumption implies early portions optional execution less important later ones adequately captures many application areas mentioned introduction mostly concentrate linear general concave reward functions schedule periodic tasks feasible mandatory parts meet deadlines every invocation given feasible schedule task set average reward task defined p hyperperiod least common multiple p service time assigned j th instance optional part task average reward computed number invocations hyperperiod p analogous way definition average error 7 1 average weighted reward feasible schedule given note results prove easily extend case one interested maximizing total reward w constant interval 01 indicating relative importance optional part although general formulation easy see weight w always incorporated reward function f replacing w thus assume weight importance information already expressed reward function formulation reww simply equal finally schedule optimal feasible maximizes average weighted reward motivating example describing solution problem present simple example shows performance limitations mandatoryfirst algorithm consider two tasks 5 assume reward functions associated optional parts linear furthermore suppose k 2 associated reward accrued 2 negligible compared k 1 ie k 1 ae k 2 case best algorithm among mandatoryfirst approaches produce schedule shown figure 100000000000011111111111100000000000000000000001111111111111111111111 figure 1 schedule produced mandatoryfirst algorithm assumed rate monotonic priority assignment used whenever one mandatory task simultaneously ready 7 yet following dynamic static priority schemes would change fact processor busy executing solely mandatory parts mandatoryfirst approach remaining idle interval 58 best algorithm would chosen schedule 1 completely brings benefit system 1 time unit 2 2 time units however optimal algorithm would produce schedule depicted figure 2 seen optimal strategy case consisted delaying execution 2 order able execute valuable 1 would still meet deadlines mandatory parts would succeed executing two instances 1 contrast mandatoryfirst scheme execute one instance 1 remembering k 1 ae k 2 one conclude reward accrued best mandatoryfirst scheme may around half accrued optimal one example also observe optimal schedule optional execution times given task vary instance instance next section prove pattern 2 figure 2 optimal schedule mere coincidence perform analytical worstcase analysis mandatoryfirst algorithms section 4 3 optimality fullutilization policies periodic rewardbased scheduling first formalize periodic rewardbased scheduling problem objective clearly finding values maximize average reward substituting average reward expression given 2 3 obtain objective function maximize first constraint must enforce total processor demand mandatory optional parts hyperperiod p may exceed available computing capacity note constraint necessary means sufficient feasibility task set values next observe optimal ij values may less zero since negative service times physical interpretation addition service time optional instance need exceed upperbound reward function r since reward accrued ceases increase hence obtain second constraint set constraint allows us readily substitute f r objective function finally need express full feasibility constraint including requirement mandatory parts complete timely manner every invocation note sufficient one feasible schedule involved fm g optimal values exists feasible schedule fm g ft ij g values express constraint english formulas since policy algorithm producing schedule including optimal ij assignments need specified point recapture constraints periodic rewardbased scheduling problem denote rewper find values maximize subject exists feasible schedule fm g ft ij g values 7 stating main result underline possible schedule mandatory parts timely manner optimization problem solution note condition equivalent 1 indicates task set would unschedulable even consisted mandatory parts hence thereafter suppose exists least one feasible schedule theorem 1 given instance problem rewper exists optimal solution optional parts task receive service time every instance ie furthermore periodic hardreal time scheduling policy fully utilize processor edf llf rmsh used obtain feasible schedule assignments proof strategy prove theorem follows drop feasibility condition 7 obtain new optimization problem whose feasible region strictly contains rewper specifically consider new optimization problem denoted maxrew objective function given 4 constraint sets 5 6 satisfied note new problem maxrew priori correspond scheduling problem since feasibility issue addressed show exists optimal solution maxrew return rewper demonstrate existence feasible schedule ie satisfiability 7 assignments reward associated maxrews optimal solution always greater equal rewpers optimal solution maxrew consider one rewpers constraints imply specific optimal solution new problem maxrew also optimal solution rewper show exists optimal solution maxrew optimal solution also optimal solution maxrew ffl first show ft 0 values satisfy constraints 5 6 already satisfy since constraint 5 violated transformation also assumption arithmetic mean necessarily less equal max j constraint set 6 violated either transformation ffl furthermore total reward decrease transformation since proof statement presented appendix using claim 1 commit finding optimal solution maxrew setting n case hence version maxrew rewritten maximize subject finally prove optimal solution automatically satisfies feasibility constraint 7 original problem rewper equal optional service times given task greatly simplifies verification constraint since satisfy 9 write equivalently 1 implies policy achieve 100 processor utilization classical periodic scheduling theory edf llf rmsh used obtain feasible schedule tasks identical execution times every instance hence full feasibility constraint 7 rewper satisfied furthermore schedule clearly maximizes average reward since ft g values maximize maxrew whose feasible region encompasses rewper corollary 1 optimal values problem rewper found solving optimization problem given 8 9 10 details solution concave optimization problem presented section 7 31 extension multiprocessors existence proof identical service times easily extended homogeneous multiprocessors original formulation rewper needs modified order reflect multiprocessor environment note objective function 4 lower upper bound constraints 6 optional service times full feasibility constraint 7 kept however k processors system potentially task set whose total utilization k instead 1 hence need change first constraint accordingly obtain formulation periodic imprecise computation problem k processors denoted multirew maximize subject exists feasible schedule k processors fm g ft ij g values 14 following exactly line reasoning depicted theorem 1 infer following theorem 2 given instance problem multirew exists optimal solution optional parts task receive service time every instance ie furthermore scheduling policy achieve full utilization k processors used obtain feasible schedule assignments example fullutilization policies multiprocessors provided mancini et al 23 note pfair scheduling policy 2 also achieve fullutilization assumes periods multiples slot length hence used context corollary 2 optimal values problem multirew found solving following optimization problem maximize subject details solution concave optimization problem given section 7 4 evaluation comparison approaches showed example section 2 reward accrued mandatoryfirst scheme may approximately half optimal algorithm prove worstcase scenario ratio reward accrued mandatoryfirst approach reward optimal algorithm approaches zero theorem 3 instance periodic rewardbased scheduling problem ratio reward best mandatorygammafirst scheme reward optimal scheme r integer r 2 proof consider two tasks 1 2 p 2 r implies r rgamma1 setting suggests period 1 scheduler choice executing parts addition 1 note mandatoryfirst policy processor continuously busy executing mandatory parts furthermore best algorithm among mandatoryfirst policies use remaining idle times scheduling 1 entirely since 2units 2 resulting schedule shown figure 3m 1 figure 3 schedule produced mandatoryfirst algorithm average reward best mandatoryfirst algorithm mfa accrue therefore r however optimal algorithm shown figure 4 would choose delaying execution 2 units time every period 1 would opportunity accruing reward 1 every instancem 1 om r r r r r figure 4 optimal schedule total reward schedule r ratio rewards two policies turns r 2 rmfa ropt r r r made close possible 0 appropriately choosing rtheorem 3 gives worstcase performance ratio mandatoryfirst schemes also performed experiments synthetic task set investigate relative performance mandatoryfirst schemes proposed 7 different types reward functions different mandatoryoptional workload ratios mandatoryfirst schemes differ policy according optional parts scheduled mandatory part ready execute ratemonotonic rmso leastutilization lu schemes assign statically higher priorities optional parts smaller periods least utilizations respectively among dynamic priority schemes earliestdeadlinefirst edfo leastlaxity first llfo consider deadline laxity optional parts assigning priorities least attained time lat aims balancing execution times optional parts ready dispatching one executed least far finally best incremental return bir online policy chooses optional task contributing total reward given slot words every slot bir selects optional part ij difference f largest ij optional service time ij already received delta minimum time slot scheduler assigns optional task however still suboptimal policy since consider laxity information authors indicate 7 bir computationally complex actually implemented however since total reward accrued bir usually much higher five policies bir used yardstick measuring performance algorithms used synthetic task set comprising 11 tasks whose total mandatory 23 individual task utilizations vary 003 06 considering exponential logarithmic linear reward functions separate cases measured reward ratio six mandatoryfirst schemes respect optimal algorithm tasks characteristics including reward functions given table experiments first set mandatory utilization 0 corresponds case alloptional workload increased 025 04 06 08 091 subsequently 7 90 9 figures 5 6 show reward ratio six mandatoryfirst schemes respect optimal algorithm function mandatory utilization different types reward functions common pattern appears optimal algorithm improves dramatically increase mandatory utilization schemes miss opportunities executing valuable optional parts constantly favoring mandatory parts reward loss becomes striking mandatory workload increases figures 5a 5b show reward ratio case exponential logarithmic reward functions respectively curves strictly concave reward functions fairly similar bir performs best among mandatoryfirst schemes performance decreases mandatory utilization increases instance ratio falls 073 mandatory utilization 06 algorithms amenable practical implementations terms runtime overhead bir perform even worse however worth noting performance lat close bir expected since task sets strictly concave reward functions usually benefit balanced optional service times utilization opt reward ratio respect optimal rmso llfo edfo llfo rmso edfo lu reward ratio respect optimal opt mandatory figure 5 reward ratio mandatoryfirst schemes strictly concave reward functions exponential b logarithmic functions reward ratio respect optimal utilization opt080060050020100 llfo rmso edfo lu figure reward ratio mandatoryfirst schemes linear reward functions figure 6 shows reward ratio linear reward functions although reward ratio mandatory first schemes decreases mandatory utilization decrease less dramatic case concave functions see however note ratio typically less 05 five practical schemes interesting observe impractical birs reward remains comparable optimal even higher mandatory utilizations difference less 15 opinion main reason behavior change lies fact given task reward optional execution slots different instances make difference linear case contrast executing valuable first slots given instance creates tremendous effect nonlinear concave functions improvement optimal algorithm would larger larger range k values k coefficient linear reward function note even worstcase performance bir may arbitrarily bad respect optimal one linear functions theorem 3 suggests considerations optimality identical service times underline theorem 1 key eliminate potentially exponential number unknowns thereby obtain optimization problem n variables one naturally tempted ask whether optimality identical service times still preserved fundamental assumptions model relaxed unfortunately attempts reach optimality results extended different models remain inconclusive following propositions suggest proposition 1 optimality identical service times longer holds deadline period assumption relaxed proof prove statement providing counterexample assume allow deadline task less period consider following two tasks assume deadline 2 deadline 1 coincides period ie 8 note tight deadline 2 makes impossible schedule optional able schedule 1 3 units optimal schedule shown figure 7 hand one commits identical service times per instance clear may schedule optional part since could execute 1 first instance 1 figure 8next suppose deadlines equal periods adopt static priority scheduling policy already mentioned section 3 periods harmonic use rms without compromising optimality general case periods necessarily harmonic true even investigating best schedule within context given static priority assignment proposition 2 general case optimality identical service times longer holds commit static priority assignment 110 figure 7 optimal schedule0 figure 8 best schedule identical service times proof consider following task set two tasks consider cases 1 2 higher priority show every case reward optimal schedule differs one obtained identical service times per instance assumption case higher priority easy see construct schedule fully utilizes timeline interval 0 lcm6 schedule also immediately optimal since reward function linear observe hence receive reward executing 2 remark execute 1 1 unit first instance feasible schedule without violating deadline 2 therefore would ended lower reward executing 1 unit 1 instance committed identical service times figure 9b case 2 2 higher priority optimality still compromised 2 higher priority optimal schedule figure 10a fully utilizes timeline best schedule figure remains suboptimal remark proposition 2 also implications qram model 26 since points impossibility achieving optimality identical service times using static priority assignment0000000000001111111111110000000000001111111111110000000000001111111111110000000000001111111111110163 242 6 6 81 1 1 1 1 1a b figure higher priority optimal schedule b best schedule identical service times mo 15omm 1 mo 15omm 1 m5omm 19 2118o 111 b figure higher priority optimal schedule b best schedule identical service times final proposition section illustrates optimality identical service times also sensitive concavity reward functions proposition 3 optimality identical service times longer holds concavity assumption reward functions relaxed proof consider two harmonic tasks without mandatory parts whose parameters given following table note 2 assigned maximum possible value ie upper bound 6 since marginal return f 2 larger f 1 everywhere optimal schedule maximizing average reward two tasks depicted figure 1100000000000000000011111111111111111111111100000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111o 2 12 8 figure 11 optimal schedule sum average rewards optimal schedule 26 however commit equal service times per instances find better schedule one shown figure 12 whose reward difficult construct similar example tasks 01 constraints well implies even number variables deal ij may prohibitively large problems 1 1o513 2 figure service times 6 periodic rewardbased scheduling problem convex reward functions nphard mentioned maximizing total average reward 01 constraints case already proven npcomplete 21 similarly section 5 showed reward functions convex optimality identical service times preserved section show fact convex reward functions result nphard problem even identical periods show transform subsetsum problem known npcomplete rewper convex reward functions subsetsum given set positive integers integer set sa construct corresponding rewper instance follows let consider set n periodic tasks period mandatory parts 8i reward function associated given strictly convex increasing function nonnegative real numbers notice f rewritten also underline periods tasks implies rewper formulated maximize subject let us denote maxrew total reward optimal schedule observe quantity otherwise either boundary values 0 maxrew wm consider question maxrew equal wm clearly question answered quickly polynomialtime algorithm rewper reward functions allowed convex furthermore answer positive equal either 0 therefore maxrew equal wm set sa implies rewper convex reward functions nphard 7 solution periodic rewardbased scheduling problem concave reward functions corollaries 1 2 reveal two optimization problems whose solutions provide optimal service times uniprocessor multiprocessor systems share common form maximize subject slack available optional executions b 1 positive rational numbers section present polynomialtime solutions problem f nondecreasing concave differentiable 2 function first note available slack large enough accommodate every optional part entirely ie choice clearly maximizes objective function due nondecreasing nature reward functions otherwise slack used entirety since total reward never decreases due nondecreasing nature reward functions case obtain concave optimization problem lower upper bounds denoted optlu instance optlu specified set nondecreasing concave functions g set upper bounds available slack aim maximize subject 2 auxiliary optimization problems introduced shortly differentiability assumption holds well special case linear functions address separately case f comprises solely linear functions since time complexity considerably reduced using information note function f increase delta total reward increases k delta however make use b delta units slack reduced b delta due 22 hence marginal return task per slack unit w consider another function f always favored respect since marginal return f j strictly greater f everywhere repeating argument every pair tasks obtain following optimal strategy first order functions according marginal returns w function largest marginal return f 2 second ties broken arbitrarily set done using entire slack 1 since transferring service time task would increase total reward b 1 set reduced accordingly next repeat next valuable n iterations slack completely consumed note solution analogous one presented 26 dominant factor time complexity comes initial sorting procedure hence special case alllinear functions optlu solved time log n f contains nonlinear functions procedure becomes involved next two subsections introduce two auxiliary optimization problems namely problem opt considers equality constraint problem optl considers equality lower bound constraints used solve optlu 71 problem opt case equality constraint instance problem opt characterized set nondecreasing concave functions slack maximize subject seen opt take account lower upper bound constraints problem optlu algorithm returns solution problem opt denoted algorithm opt f composed solely nonlinear reward functions application lagrange multipliers technique 22 problem opt yieldsb common lagrange multiplier f 0 derivative reward function f quantity 1 actually represents marginal return contributed total reward denote w observe since f nondecreasing concave assumption nonincreasing positive valued equation 25 implies marginal returns equal reward functions optimal solution g considering equality also hold one obtain closed formulas cases occur practice closed formulas presented obtained method ffl logarithmic reward functions form f ffl exponential reward functions form f ffl k th root reward functions form f possible find closed formula following exactly approach presented 14 15 18 solve equation inverse function 1 assume existence derivatives inverse function whenever f nonlinear complying 14 15 18 determined optimal solution examine case f mix linear nonlinear functions consider two linear functions f marginal return f f j w service time definitely zero since marginal return f strictly less f j everywhere elimination process linear functions largest marginal return w max consider single linear function procedure evenly divide returned service time max among values corresponding p functions hence without loss generality assume f n linear function f marginal return w first compute optimal distribution slack among tasks nonlinear reward functions f lagrange multipliers technique w thus w 1 optimal solution distinguish two cases case optimal solution opt see first remember reward functions concave nondecreasing hence w implies transferring service time another task n would mean favoring task smaller marginal reward rate would optimal case reserving slack solely tasks nonlinear reward functions means violating best marginal rate principle hence optimal therefore increase drops level w beyond solving assigning remaining slack dgamma bn n service time unique task linear reward function clearly satisfies best marginal rate principle achieves optimality 72 problem optl case lower bounds section present solution problem optl improve solution section 721 instance problem optl characterized set fff 1 nondecreasing concave reward functions available slack maximize subject solve optl first evaluate solution set sopt corresponding problem opt check whether inequality constraints automatically satisfied case solution set sopt gammal problem optl clearly solution sopt otherwise construct sopt gammal iteratively described wellknown result nonlinear optimization theory states solution sopt gammal problem optl satisfy socalled kuhntucker conditions 22 25 furthermore kuhntucker conditions also sufficient case concave reward functions 22 25 problem optl kuhntucker conditions comprise equations 27 28 lagrange multipliers necessary sufficient character kuhntucker conditions indicates 2n 1 tuple satisfies conditions 27 31 provides optimal values optl one method solving optimization problem optl find solution 2n1 equations 27 29 30 satisfies constraint sets 28 31 iteratively solving 2n 1 nonlinear equations complex process guaranteed converge paper follow different approach namely use kuhntucker conditions 29 30 31 prove useful properties optimal solution method based carefully using properties derive order refine solution optimization problem opt violates inequality constraints given 28 9i proof assume contrary 8i case kuhntucker conditions reduce equality constraint 27 set inequality constraints 28 plus lagrangian condition given 25 hand sopt solution opt satisfy 27 lagrangian condition 25 words solving opt always equivalent solving set nonlinear equations identical kuhntucker conditions optl except inequality constraints setting 8i hence solution optl 8i solution would returned algorithm solving opt would violate inequality constraints however given solution sopt failed satisfy inequality constraints reach contradiction therefore exists least one lagrange multiplier strictly greater 0claim 3 9j proof sake contradiction assume 8j j 0 case equation 30 enforces 8i true equal 0 leaving slack totally unutilized case clearly would optimal solution due nondecreasing nature reward functionsin rest paper use expression set functions instead set indices functions unless confusion arises let remember 1 marginal return associated f x x denoted w x x formally pi contains functions f x 2 f smallest marginal returns lower bound 0 lemma 1 sopt violates inequality constraints sopt gammal proof assume 9m 2 pi 0 case equation 30 implies corresponding know 9j j 0 equation 30 using equation 29 writeb concavity property f suggests 1 0 case contradicting assumption 2 pi hence 0 equation 0in view lemma 1 present algorithm solves problem optl figure 13 algorithm optlfd 1 evaluate solution sopt optimization problem without inequality constraints 2 inequality constraints satisfied sopt gammal sopt exit 3 compute pi equation 6 goto step 1 figure 13 algorithm solve problem optl complexity time complexity copt n algorithm opt mentioned closed apply complexity clearly linear otherwise unique unknown solved linear time concavity assumptions indicated 14 15 18 lemma 1 immediately implies existence algorithm sets reinvokes algorithm opt remaining tasks slack case inequality constraints violated sopt since number invocations bounded n complexity algorithm solves optlu 2 721 faster solution problem optl section present faster algorithm time complexity delta log n solve optl make use new faster algorithm final solution optlu consider algorithm optl depicted fig 13 let f k set functions passed opt k th iteration algorithm optl pi k set functions minimum marginal returns lower bounds minimum w 0 values k th iteration formally pi f 0 number distinct w 0 values among functions f n iteration number algorithm opt returns solution set satisfies constraint set given 28 remaining values note elements pi produced delta log n time preprocessing phase clearly algorithm optl sequentially sets returns solution violate constraint set remaining unknowns th iteration tempting idea use binary search range 1 n locate critical index faster way however justify correctness procedure one needs prove one set invoked subsequently algorithm opt sopt obtained way would still satisfied constraint set given 28 notice property hold possible determine direction search simply testing sopt given index since must assured exists unique index setting invoking opt provide solution sopt satisfies inequality constraints whenever 1 setting invoking opt provide solurion sopt satisfies inequality constraints whenever first properties follows directly correctness algorithm optl turns second property also holds concave objective functions proven hence time complexity copt gammal n may reduced delta log n using binary search like technique algorithm fastl solves problem optl time delta log n shown figure 14 722 correctness proof fast algorithm begin introducing following additional notation regarding k th iteration algorithm optl assigned optional part task opt k th iteration algorithm optl solution produced opt k th iteration algorithm optl 0g set indices solution soptk violates inequality constraints clearly algorithm optl successively sets returns solution violate constraints functions fm th iteration algorithm fastl uses binary search determine critical index efficiently correctness algprithm optl assures 8 invoking opt algorithm fastlfd evaluate sopt corresponding problem opt 2 constraints satisfied sopt gammal sopt exit 3 enumerate functions f according nondecreasing order w j 0 values construct sets pi 6 evaluate sopt invoking optpi m1 7 constraint violated 9 else f evaluate sopt invoking 12 constraint violated 14 else f figure 14 fast algorithm problem optl would yield nonempty violating set v remaining tasks finally proposition 4 establishes 8 gamma 1 v always remain empty setting invoking opt since would leave even slack remaining tasks algorithm fastl specific index tested iteration check whether satisfies property case since one index satisfying property however case vm 6 infer next probe determined range n finally restrict search range 0 proposition 4 suppose execution algorithm optl soptk violate inequality constraints ie th invocation algorithm opt remaining tasks yields soptk1 ik1 ik implies v k1 still empty proof note ik 0 8 assumption based optimality property subproblems k th invocation algorithm opt yields optimal solution also generate optimal distribution gamma among functions f k gamma pi k however th invocation provides optimal distribution among functions f k gamma pi k well setting thus two successive invocations algorithm opt written maximize subject maximize subject hence proof complete show 8i 2 f solution soptk satisfy firstorder necessary conditions lagrangian 22 necessary conditions 34 giveb c b sake contradiction assume 9w 2 f must 2 f k gamma pi k yk1 yk distinguish two cases 1 f w nonlinear derivative strictly decreasing since f also concave f 0 f 0 clearly inconsistent equations 35 36 easily seen substituting w c equations 35 36 respectively 2 f w linear implies f 0 j case satisfy equations 35 also linear form f bw hence two functions marginal return remembering assumption section 71 algorithm opt treats linear functions marginal return fairly assigns amount service time reach contradiction since wk supposed greater yk complexity olog n probes made binary search probe algorithm opt called twice recall algorithm opt time complexity initial cost sorting derivative values log n hence total complexity copt gammal log log n delta log n 73 combining constraints solution problem optlu instance problem optlu characterized set f ff nondecreasing differentiable concave reward functions set upper bounds length optional execution parts available slack maximize subject recall specification optlu first observe close relationship problems optlu optl indeed optlu additional set upper bound constraints difficult see sopt gammal satisfies constraints given equation 39 solution sopt gammalu problem optlu sopt gammal however upper bound constraint violated construct solution iteratively way analogous described solution problem optl contains functions f x 2 f largest marginal returns upper bounds w x x algorithm algoptlu see figure 15 solves problem optlu based successive invocations fastl first find solution sopt gammal corresponding problem optl know solution optimal simpler problem take account upper bounds upper bound constraints automatically satisfied done however case set gamma finally update sets f slack going next iteration correctness algorithm selfexplanatory view results obtained previous sections however line 5 algoptlu requires elaboration addition constraints 38 39 40 necessary sufficient kuhntucker conditions problem optlu expressed algorithm optlufod 3 evaluate sopt gammal invoking algorithm fastl 4 upper bound constraints satisfied set ffgammagamma 9 set oogammafo x jx 2 gammag figure 15 algorithm solve problem optlu lagrange multipliers violates upper bound constraints given equation 39 9i proof assume 8i case kuhntucker conditions 42 44 vanish also conditions 38 40 41 43 45 become exactly identical kuhntucker conditions problem optl thus sopt gammal returned algorithm fastl also equal sopt gammalu satisfies extra constraint set given 39claim 5 8i proof assume 9i case 42 43 force us choose implies contrary assumption specification problem ready justify line 5 algorithm violates upper bound constraints given 39 sopt gammalu gamma proof prove lagrange multipliers nonzero imply 42 know 9j 5 using 41 gives since necessarily less equal deduce 1 contradicts assumption 2 gammacomplexity notice worst case time complexity iteration equal algorithm fastl delta log n observe cardinality f decreases least 1 iteration hence number iterations bounded n follows total time complexity copt gammalu n 2 delta log n 8 conclusion paper addressed periodic rewardbased scheduling problem proved reward functions convex problem nphard thus focus linear concave reward functions adequately represent realistic applications image speech processing timedependent planning multimedia presentations shown class reward exists always schedule optional execution times given task change instance instance result turn implied optimality periodic realtime policy schedule task set utilization k k processors existence policies wellknown realtime systems community rms harmonic periods edf llf uniprocessor systems general scheduling policy fully utilize multiprocessor system also presented polynomialtime algorithms computing optimal service times believe efficient algorithms also used concave resource allocationqos problems one addressed 26 underline besides clear observable reward improvement previously proposed suboptimal policies approach advantage requiring runtime overhead maximizing reward system constantly monitoring timeliness mandatory parts optimal optional service times determined statically algorithm existing eg edf scheduler need modified aware mandatoryoptional semantic distinction opinion another major benefit precomputed optimal equal service times given tasks invocations rewardbased scheduling addition theorem 1 implies long concerned linear concave reward functions resource allocation also made terms utilization tasks without sacrificing optimality opinion fact points interesting convergence instancebased 7 21 utilizationbased 26 models common reward functions tractability issues regarding nature reward functions case step functions already proven npcomplete 21 efficiently solving case concave linear reward functions proving case convex reward functions nphard efficient solvability boundaries periodic aperiodic rewardbased scheduling reached work assuming finally provided examples show theorem optimality identical service times per instance longer holds relax fundamental assumptions deadlineperiod equality availability dynamic priority scheduling policies considering dynamic aperiodic task arrivals investigating good approximation algorithms intractable cases step functions error cumulative jobs major avenues rewardbased scheduling r polynomialtime algorithm solve rewardbased scheduling prob lem fairness periodic realtime scheduling solving timedependent planning problems scalable video coding using 3d subband velocity coding multirate quan tization scalable video data placement parallel disk data arrays scheduling periodic jobs allow imprecise results algorithms scheduling realtime tasks input error endtoend deadlines extended imprecise computation model timeconstrained speech processing generation dynamic priority assignment technique streams architectural foundations realtime performance intelligent agents reasoning varying uncertain resource constraints efficient online processor scheduling class iris increasing reward increasing service realtime tasks algorithms complexity overloaded systems allow skips imprecise results utilizing partial computations realtime systems scheduling algorithms multiprogramming hard realtime environment algorithms scheduling imprecise computations linear nonlinear programming scheduling algorithms faulttolerance hardrealtime systems fundamental design problems distributed systems hard realtime environment classical optimization foundations extensions resource allocation model qos management algorithms scheduling imprecise computations minimize total error image transfer endtoend design producing monotonically improving approximate answers relational algebra queries anytime sensing tr ctr r santos j urriza j santos j orozco new methods redistributing slack time realtime systems applications comparative evaluations journal systems software v69 n12 p115128 01 january 2004 hakan aydin rami melhem daniel moss pedro mejaalvarez poweraware scheduling periodic realtime tasks ieee transactions computers v53 n5 p584600 may 2004 shaoxiong hua gang qu shuvra bhattacharyya energy reduction techniques multimedia applications tolerance deadline misses proceedings 40th conference design automation june 0206 2003 anaheim ca usa xiliang zhong chengzhong xu frequencyaware energy optimization realtime periodic aperiodic tasks acm sigplan notices v42 n7 july 2007 melhem nevine aboughazaleh hakan aydin daniel moss power management points poweraware realtime systems power aware computing kluwer academic publishers norwell 2002 melhem daniel moss maximizing rewards realtime applications energy constraints acm transactions embedded computing systems tecs v2 n4 p537559 november jeffrey barnett dynamic tasklevel voltage scheduling optimizations ieee transactions computers v54 n5 p508520 may 2005 lui sha tarek abdelzaher karlerik rzn anton cervin theodore baker alan burns giorgio buttazzo marco caccamo john lehoczky aloysius k mok real time scheduling theory historical perspective realtime systems v28 n23 p101155 novemberdecember 2004
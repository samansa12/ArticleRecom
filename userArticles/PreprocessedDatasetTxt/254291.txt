optimal algorithm scanning spanning trees undirected graphs let g undirected graph v vertices e edges many algorithms developed enumerating spanning trees g early algorithms use technique called backtracking recently several algorithms using different technique proposed kapoor ramesh 1992 matsui 1993 shioura tamura 1993 find new spanning tree exchanging one edge current one technique merit enabling us compress whole output spanning trees outputting relative changes edges kapoor ramesh first proposed etime algorithm adopting compact output n number spanning trees another algorithm time complexity constructed shioura tamura optimal sense time complexity terms space complexity take ove space refine shioura tamuras algorithm decrease space complexity ove ov e preserving time complexity therefore algorithm optimal sense time space complexities b introduction let g undirected graph v vertices e edges spanning tree g defined connected subgraph g contains vertices cycle paper consider enumeration spanning trees undirected graph many algorithms solving problem developed eg 7 8 4 5 6 9 may divided several types 3 department information sciences tokyo institute technology 2121 ohokayama meguroku tokyo 152 japan shiouraistitechacjp department computer science information mathematics university electro communications 151 chofugaoka chofushi tokyo 182 japan tamuraimuecacjp z department information sciences tokyo institute technology 2121 ohokayama meguroku tokyo 152 japan unoistitechacjp first type 7 8 4 belong many early algorithms use technique called backtracking useful technique listing kinds subgraphs eg cycles paths gabow myers 4 refined mintys algorithm 7 read tarjans 8 algorithm uses onv v e time ov e space n number spanning trees enumerate spanning trees outputting edges spanning tree algorithm optimal terms time space complexities recently several algorithms 5 6 9 use another technique developed algorithms find new spanning tree exchanging one pair edges instead backtracking furthermore enumerate spanning trees outputting relative changes edges spanning trees compress size output 2nv hence total time complexity may reduced fact kapoor ramesh 5 proposed onv e time ov e space algorithm adopting compact output optimal sense time complexity hand matsui 6 developed onv v e time ov e space algorithm enumerating spanning trees explicitly applying reverse search scheme 3 reverse search scheme general enumeration problems see 1 2 shioura tamura 9 also developed algorithm generating compact output time space complexities kapoor ramesh algorithm using reverse search technique kapoorramesh algorithm shiouratamura algorithm however efficient terms space complexity take ov e space main aim paper obtain algorithm generates compact output optimal sense time space complexities refining shioura tamura algorithm process goes lower level node computation tree original algorithm edge set efficiently divided without requiring extra information however order efficiently restore edge set process goes back higher level node algorithm requires extra oe information since depth computation tree v 01 takes ov e space propose useful property efficiently restoring edge set technique restoring uses extra ov space time complexity remains onv e section 2 explain technique enumeration spanning trees compact outputs section 3 define nice childparent relation spanning trees propose naive algorithm section 4 show properties useful efficient manipulation data structures implementation implementation g figure 1 graph g 1 graph presented section 5 time space complexities analyzed compact output let g undirected graph necessary simple v vertices define two types edgesets necessary algorithm socalled fundamental cuts fundamental cycles let spanning tree g throughout paper represent spanning tree edgeset size v 01 edge deletion f yields two connected components fundamental cut associated f defined set edges connecting components denoted cuttnf likewise define fundamental cycle associated set edges contained unique cycle g denote cyctg definition tnfg spanning tree f 2 similarly g 62 f 2 cyctg tgnf also spanning tree properties useful enumerating spanning trees using fundamental cuts cycles construct different spanning tree given one exchanging exactly one edge given graph g let sgt graph whose vertexset set spanning trees g whose edgeset consists pairs spanning trees obtained exchanging exactly one edge using fundamental cut cycle example graph sg 1 left one g 1 shown figure 1 algorithm finds spanning trees g implicitly traversing spanning tree sg order output v 01 edges spanning tree 2jt j1v time required however output edges first spanning tree sequence exchanged edgepairs g obtained traversing need exactly two edges g exchanged edge furthermore scanning compact output one construct spanning trees since adopt compact output becomes desirable find next spanning tree current one efficiently constant time 3 basic ideas naive algorithm section explain basic ideas naive algorithm define total orders vertexset fv edgeset g indices especially call smallest vertex v 1 root edge e call smaller incident vertex tail denoted call larger one head denoted 0 e relative spanning tree g unique path vertex v root v 1 contains vertex u u called ancestor v v descendant u similarly two edges e f call e ancestor f f descendant e unique path f root v 1 contains e depthfirst spanning tree g spanning tree found depthfirst search g known depthfirst spanning tree defined spanning tree edge g one incidence vertex ancestor algorithm make several assumptions vertexset edgeset g assumption 1 0 depthfirst spanning tree g assumption 2 0 fe assumption 3 edge 0 smaller proper descendants assumption 4 vertex v smaller proper descendants relative assumption 5 two edges e 6 figure 2 graph g 2 vertices edges graph g 2 figure 2 satisfy assumptions fact one find 0 sort vertices edges g ov e time g satisfies assumptions applying tarjans depthfirst search 10 note assumptions 1 2 3 sufficient correctness algorithm however need assumptions 4 5 efficient implementation nonempty subset denotes smallest edge convenience assume lemma 31 9 assumptions 1 3 spanning tree c 6 contains exactly one edge proof set 0 n f exactly two components one containing 0 f therefore unique path cyct c f n f 0 f contains least one edge cutt 0 nf since 0 depthfirst spanning tree may assume head edge descendant tail relative 0 without loss generality let e first edge 0 f path e 2 cutt 0 nf head 0 e descendant tail e ancestor assumption 3 minimality f connected c edge contained cutt 0 nf path cyct c f n f hence e edge cyct c f n f cutt 0 nf consider graph g 2 figure 2 let figure 3 childparent relations graph g 2 therefore cyct c f cutt 0 nf given spanning tree c 6 0 edge unique edge cyct c f cutt 0 nf n f clearly fng spanning tree call p parent c c child 31 guarantees spanning tree 0 unique parent since jt ancestor spanning trees graph g 1 figure 1 childparent pairs shown arrows figure 3 arrow goes child parent see arrows construct spanning tree sg 1 rooted let spanning tree sg consisting childparent pairs spanning trees algorithm implicitly traverses 0 recursively scanning children current spanning tree thus must find children given spanning tree exist next lemma gives useful idea lemma 32 9 let p arbitrary spanning tree g let f g two distinct edges assumptions 1 2 3 nfg child p f g satisfy following conditions proof assumptions 1 3 c child p following conditions hold c spanning tree different ng first show different spanning trees assume contrary f 62 c spanning tree f 6 g contradiction thus f 2 p g 62 ng must hold conditions 32 33 34 imply hand assumption 2 31 implies 35 moreover 31 35 imply 32 34 show 31 33 equivalent conditions 32 34 35 definition c 35 hence implies distinct g 2 cyct c f equivalent g 2 cutt p nf therefore second condition 31 equivalent second condition 33 let e k largest edge less mint lemma find children p know edgesets cutt p ne ne consider graph defined figure 1 case e 1 e 2 edges smaller mint therefore 1 two children 1 ne 2 e 4 1 ne 1 rest paper shortly write cutt p ne ne grounds edge cutt p ne ne entered p place consideration construct algorithm algorithm input graph g vertexset fv edgeset begin using depthfirst search 1 find depthfirst spanning tree 0 g vertices edges satisfy assumptions 2 3 4 5 end procedure findchildrent p input spanning tree p integer k e begin g 2 entrt begin foutput children p containing e k g ne k g ffind children c g ffind children p containing e k01 g end algorithm procedure findchildren finds children spanning tree called two arguments p k finds children p containing edge finds child c recursively calls finding children c stage arguments set c k01 k 1 e k01 becomes largest edge less mint children p figure 4 enumeration tree spanning trees g 1 containing e k found recursively calls finding children p containing e k01 case arguments p k01 initially algorithm allspanningtreesg calls findchildren arguments 0 v 01 spanning trees g found figure 4 shows enumeration tree spanning trees graph theorem 33 9 algorithm allspanningtrees outputs spanning tree exactly proof lemma 32 every spanning tree different 0 output time parent output lemma 31 spanning tree c parent always exists uniquely determined since 0 ancestor spanning trees algorithm outputs spanning tree exactly manipulating data structures algorithm define state find children p containing e k pair p k call procedure findchildrent p k current state becomes find child c p containing e k state moves c k01 children p containing e k found state moves p k01 state p k entering edgeset entrt required output children p containing e k state moves c k01 p k01 necessity entering edgeset entrt c e k01 occurs first time key point finding entering edgeset entrt c e k01 efficiently constructing entering edgeset efficiently implementation maintains edgesets defined let p spanning tree e e e2e e e e e figure 5 movement state can3 3 k positive integer e edge e j j use notation sense cane set candidates entering edges leaving edge e j state p k find easily maintaining cane definition 41 find child c p update hand found children p containing e k01 construct efficiency implementation depends maintain can3 3 efficiently figure 5 shows states edgesets can3 3 enumerating spanning trees g 1 figure 1 example initial state 0 3 succeeding states consider maintain edgesets first show initial edgesets found easily lemma 41 9 assumptions 1 2 3 4 proof since ne written ne ne h assumptions 1 4 edge e 62 0 belongs cutt 0 ne j 0 e descendant 0 e j e ancestor 0 e 0 e j addition assumption 3 e 62 largest edge e 2 cutt 0 ne j lemma find cane applying depthfirst search lemma 42 spanning tree p positive integer k e k arbitrary edge entrt assumptions 1 2 3 4 following relation holds spanning tree ne k g set ancestors edge e 0 0 e proof note g 2 entrt child p descendant 0 e k relative p descendant 0 g relative vice versa therefore e j 2 entrt e ancestor e k entrt e j precisely edge 0 e descendant 0 e k relative p e belong entrt e j edges obviously belong entrt e j ancestor e lemma 43 9 let p spanning tree let k positive integer e k assumptions 1 2 3 4 edge g 2 cane spanning tree ne k g following relation holds proof assumptions two edges e f ancestor f relative 0 e ancestor f relative p omit phrase relative 0 p edges let e edge exists let set edges 0 ancestors e prove 44 using relation 43 case case edge e h therefore e j proper ancestor e entrt lemma 43 guarantees one sets can3 updated want find children c children p containing figure 5 state moves 0 edge 0 e following equations hold hand state moves 0 3 1 2 candidate edgeset updated edge implementation use global variables candi3 leave state represents edgeset cane variable leave represents edgeset fe check constant time whether current spanning tree children checking see leave 6 suppose edgeset represented ascending ordered list realized doubly linked list also use data structure given graph g two incidence vertices edge found constant time data structure initial spanning tree 0 vertex v root unique edge e found constant time recall graph g satisfies assumption 5 two edges assumption one find edgeset cane searching ordered list candie k beginning thus complete time proportional size edgeset merging two edgesets executed time proportional sum size two edgesets therefore takes ojcane updating edgesets candi3 current state goes succeeding state k01 candie changes empty nonempty must insert edge e leave since leave ascending ordered list complete ojfe2leavejee time hand state goes back k01 p k must reconstruct can3 must restore edges gg candie candie k shiouratamura algorithm 9 restoration efficiently executed recording cane state p goes k01 idea however requires ov e extra space since depth recursive calls algorithm ov rest section discuss idea reducing extra space denote headset edges contained cane lemma 44 assumptions 1 2 3 4 headsets heade mutually disjoint state p k proof lemma 41 heade initial state 0 nonempty thus assertion true initial state assume lemma holds state p prove holds next state p ne k g k01 lemma 43 following relation holds hs headset edges cane heade intersect hs headsets mutually disjoint lemma 44 headset hs edges cang head set heade hence find hs restoring candi3 easy pick edges figure 5 state goes back 0 1 0 2 edges cane must restored candie 1 headset cane equal fv 3 g case reconstruct cane implementation uses global variables head3 representing heade k state p k suppose headset represented necessarily ascending doubly linked list lemma 44 require ov space manipulating headsets describe two procedures manipulating data structures candi3 leave head3 current state p goes succeeding state k01 goes back p k respectively procedure first case shown procedure updatedatastructuree k g f current state p goes succeeding state ne k g k01 g begin e edge 0 0 e move candie changes empty nonempty insert e leave hs head set edges fe2candie k j maximal sublist consecutive elements hs heade k begin record first element sublist position heade k stack delete sublist heade k add end heade record position first element hs heade stack end state changes p k01 must move headset hs edges cane gg heade k heade time move element hs one one move maximal sublist consecutive elements hs heade k heade figure 6 extra space recording positions maximal sublists ov number maximal sublists jheade k unchanged state comes back p k easy manipulate head3 time candi3 jhsj jcane omit details thus time maximal sublists first element maximal sublists stack v1 figure update head3 complexity procedure ojcane cane second procedure restores data structures following way procedure restoredatastructuree k g f state p ne k g k01 goes back p begin e edge 0 0 e find hs record position first element heade delete hs heade move fe2candie j 0 e 2 hsg candie beginning candie k candie changes nonempty empty delete e leave move sublist hs correct place heade k using records stack end since recorded first element head vertices added heade find hs constant time edge candie check constant time whether hs marking elements hs advance hence restore ojcane time deletion edge leave completed constant time headset hs returned heade heade k time proportional number maximal sublists information places heade k therefore procedure restoredatastructure takes ojcane 5 optimal implementation analysis finally describe efficient implementation analyze time space complex ities implementation written algorithm input graph g vertexset fv edgeset begin using depthfirst search simultaneously execute 1 find depthfirst spanning tree 0 g vertices edges satisfy assumptions 2 3 4 5 1 e j 1 e j end procedure findchildren current spanning treeg begin e k last entry leave delete e k leave begin last entry candie k delete g candie k add g beginning q ne k gg restoredatastructuree move entries q candie k restoredatastructuree k e k add e k end leave end discuss time complexity implementation next lemma useful analyzing time complexity lemma 51 9 suppose spanning tree k positive integer assumptions 1 2 3 4 edge g j 2 spanning tree proof let spanning tree suppose j spanning tree j 2 lemma 43 ne j01 g j01 spanning tree algorithm allspanningtree time required calling findchildren ov e state p k children p containing e k time taken execute procedure findchildren maintenance data structures consider time complexities maintenance data structures discussion section 4 takes ojcane cane maintain data structures state changes ne k g k01 e edge consider next two cases case maintenance finding children c ie g 2 cane case b maintenance finding children p containing e k ie note case occurs exactly one time spanning tree c 0 case b occurs one time spanning tree p edge e k 2 feje 1 case number children c containing e moreover edge e j cane child c containing e therefore time complexity case children c case b bounded number children p containing e least jfe2cane neither e k e similarly jfe bounded number grandchildren p containing e k thus time complexity case b children p containing e k grandchildren p containing e k recall procedure findchildren checks constant time whether p children discussion total required time findchildren state p children grandchildren p containing e k thus total time complexity implementation onv e finally consider space complexity state edgesets candie j intersection neither headsets heade j thus need ov e space candi ov space head obviously cardinality leave v 01 described section 4 size stack recording positions maximal sublists hs ov total size local variables q findchildren oe edge stored one global variables candi3 local variables q hence space complexity implementation ov e theorem 52 time space complexities implementation onv e ov e respectively paper proposed efficient algorithm enumerating spanning trees optimal sense time space complexities acknowledgements greatly indebted dr yoshiko ikebe tokyo institute technology kind valuable comments manuscript r basis enumeration algorithm linear systems geometric applications pivoting algorithm convex hulls vertex enumeration arrangments polyhedra reverse search enumeration finding spanning trees directed undirected graphs algorithms generating spanning trees undirected directed weighted graphs algorithm finding spanning trees undirected graphs simple algorithm listing trees graph bounds backtrack algorithms listing cycles paths spanning trees efficiently scanning spanning trees undirected graph depthfirst search linear graph algorithms tr
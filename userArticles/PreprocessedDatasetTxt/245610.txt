detection strong unstable predicates distributed programs abstractthis paper discusses detection global predicates distributed program run distributed program results set sequential traces one process traces may combined form many global sequences consistent single run program strong global predicate true run true global sequences consistent run present algorithms detect given strong global predicate became true run distributed program algorithms executed line well line moreover algorithms assume underlying channels satisfy fifo ordering b introduction detection global predicates fundamental problem distributed computing arises designing debugging testing distributed programs global predicates classified two types stable unstable stable predicate one never turns false becomes true unstable predicate one without property value may alternate true false detection stable predicates addressed literature means global snapshots distributed computation chalam85 spekea86 bouge87 stable property detected taking global snapshots periodically approach work unstable predicate may turn true two snapshots time snapshot taken entirely different approach required predicates walgar91 coomar91 garwal92 schmat92 garwal94 babmar93 tomgar93 hpr93 earlier presented approach detect class unstable predicates called predicates garwal94 paper continue investigation detection different class unstable predicates reader referred garwal94 discussion related work background two types predicates discussed paper first type called strong linked predicates refers causal sequence local predicates second type called strong conjunctive predicates correspond existence global state local predicates true simultaneously introduce notion overlapping intervals used detect predicates type cooper marzullo coomar91 also describe strong predicate detection call predicates definitely however deal general predicates ie propose detection definitely p p predicate defined global state paper restricted p conjunction local predicates detection general predicates intractable since involves combinatorial work supported part nsf grant ccr 9110605 navy grant n0003991c0082 trw faculty assistantship award ibm agreement 153 explosion state space example algorithm proposed cooper marzullo coomar91 complexity ok n k maximum number events monitored process executed n number processes fundamental difference algorithm algorithm algorithm explicitly checks possible global states whereas algorithm spezialetti kearns spekea89 also discuss notion simultaneity however different one discussed paper use simultaneity sense possible consistent global state notion closer weak predicates discussed garwal94 paper organized follows section 2 presents logic specification global predicates distributed program describes notion distributed run global clock global sequence logic section 3 discusses detection linked predicates section 4 discusses strong conjunctive predicates gives necessary sufficient conditions strong conjunctive predicates hold also describes algorithms detecting strong conjunctive predicates section 5 presents techniques decentralize algorithms model assume looselycoupled messagepassing system without shared memory global clock distributed program consists set n processes denoted fp communicating solely via asynchronous messages make assumptions ordering reliability messages run concerned single run r distributed program process p run generates execution trace i0 finite sequence local states process p run r vector traces ri trace process p define relation locally precedes denoted oe im states trace single process p follows oe im immediately precedes trace ri also say use oe irreflexive transitive closure reflexive transitive closure oe im states traces ri rj respectively defined related message sent p resulting state received p j resulting state figure 1 illustrates run also define causally precedes relation transitive closure union oe im 1 2 similar lamports happenedbefore relation lamp78 except causally precedes defined states rather events say concurrent denoted sjjt pcx 13 23 pcy y3 receivey y2y figure 1 example run extend run r r 0 adding artificial states beginning end trace ri respectively event corresponds beginning termination execution p addition artificial states model fact processes begin execution asynchronously thus absence synchronization external events may possible one process may terminated one yet begin execution let set states sequence ri g definitions imply 8s 2 define also use sp denote process whose trace occurs b global clock global clock c map 0 n set natural numbers following constraint use c denote set global clocks satisfy constraint interpretation cs 2 process sp enters state clock value cs thus stays state time cs csnext gamma 1 constraint models sequential nature execution process physical requirement message transmission requires nonzero amount time definition equivalent condition cc widely used definition logical clock since proposal lamportlamp78 shown set c also satisfies converse cc ie reader referred garwal94b proof leads following pleasant characterization intuitively formula says causally precedes run r possible observers run agree happened c global sequence global state vector local states definition global state different chandy lamport includes states channels model channel set messages sent received yet since set deduced local states require state channels explicitly included global state given run r global clock c seqr c defines sequence global states called global sequence note g k well defined argument max nonempty totally ordered oe finite set may evaluate would mean process p begun execution similarly evaluates process p already terminated execution kth prefix g ie g 0 denoted g k define findexg ie first index g u global state define set global sequences consistent run r linearr ie following theorem gives alternative characterization set linearr given g 2 linearr observer restricts attention single process p would observe ri stutter ri stutter ri finite sequence state ri may repeated finite number times lemma 1 run r g 2 linearr following constraints hold restricted p stutter ri proof linearr implies 9c c since cs greater 0 6 get g 0 definition c finally g c holds see s2 let cc get cs ct implies findexg findexg define c follows c satisfies cc due s2 earlier papergarwal94 directly defined notion global sequences paper chosen condition cc based global clocks intuitively easier justify two properties global sequences also deduce s3 says set x concurrent states exists global sequence g goes global state g k local states x occur g k none occur logic global predicates describe logic specification global predicates three syntactic categories logic bool lin form syntax logic follows form lin j e lin lin 3 lin j lin lin bool predicate global state bool boolean expression defined single global state system value determined global state known example global state bool x true x could part different processes lin temporal formula defined global sequence bool true global sequence true last state g 3 lin means exists prefix global sequence lin true prefix also use 2 duals 3 introduced binary operator capture sequencing directly p q means exist prefixes g j global sequence p true prefix g q true prefix g j form defined run simply lin qualified e quantify set global sequences run may exhibit given traces process ap means predicate p holds global sequences ep means predicate p holds global sequence call formulas starting strong formulas formulas starting e weak formulas intuition behind term strong strong predicate true matter fast slow individual processes system execute long execution consistent run holds execution speeds generate trace individual process weak predicate true exists least one global sequence true words predicate made true choosing appropriate execution speeds various processors semantics defined paper slightly different garwal94 garwal94 bool defined true global sequence true first global state sequence paper bool required true last global state current version useful easier understand intuitively logic garwal94 based future logic paper based past since past known point execution easier evaluate formula current state following examples strong formulas detectable algorithms 1 suppose developed algorithm works phases assume system three nodes three phases algorithm let predicate phase ij denote process p phase j following formula ensures process p 2 phase 3 processes phase 2 phase 12 phase 23 phase 22 phase 23 phase 32 phase 23 2 suppose testing commit protocol let ready denote local predicate process p ready commit following formula would check certain point execution processes ready commit 3 suppose wanted test distributed minimum spanning tree algorithm let local predicate process p knows parent following formula would indicate system reached state nodes network know parents 3 linked predicates class predicates useful detecting sequence events distributed program use lp denote local predicate process lp denote predicate lp true state assume local predicate lp constructed local variables process means truthness lp change internal event words external events cannot make local predicate change true false viceversa thus predicate message sent p q considered valid lp although appears limitation predicate easily modeled framework assuming internal event records send message boolean variable msg sent condition msg sent valid local predicate assumption equivalent following 1 2 different snext a1 says snext differ evaluation lp causal relationships states identical also use following assumption evaluate false artificial states assumption also restriction captures intent defining states predicate form alp lp j means global sequences exists instance lp true lp j alp means global sequences exists instance lp true lp j true lp k treat left associative operator leave parentheses call formula form lp 1 lp 2 delta delta delta lpm strong linked predicate following theorem used designing algorithm detection predicates note one side proof obvious converse difficult addressed literature one main results section theorem 2 let lp 1 lp 2 local predicates processes j respectively run r exist states ri j rj proof s1 conclude global sequence 2 linearr states g k g l g k s2 know findexg show states exist formula lp 1 lp 2 false lhs rhs lp 1 lp 2 true state ri rj respectively formula trivially false consider first state ri lp 1 true call state similarly j defined using last state rj lp 2 true negation left hand side implies 6 j consider state j next state exists a2 may j let defined fsks j nextg note could possibly see fig 2 global state figure 2 linked predicates case analysis case 1 means concurrent j next definition since 6 j get 6 j next a1 implies j next turn implies contradiction case 2 since concurrent j next lemma s3 exists global sequence g j next occur global state first time predicate lp 1 true preceding global states lp 2 false following global states thus two global states x lp 1 x lp 2 x occurs g result generalized sequence two local predicates garwal94b intuition behind algorithm detect strong linked predicate fig follows alp 1 lp 2 true state lp 1 occurred happened state lp 2 occurs predicates process occurrence lp 1 would known lp 2 occurs lp 2 different process definition know must message path second process use message path inform second process occurrence lp 1 var detectflag boolean always true iff curpred 1 pred list list findex1m predlocal predicate g predicates local process curpred integer initially begin update predicate next one process detect curpred pred list tail pred list curpredmaxcurpred hiscurpred send include curpred message figure 3 algorithm strong linked predicates implementation algorithm follows variable pred list process keeps list logical predicates local process increasing order indices appear strong linked predicate variable curpred keeps index next local predicate strong linked predicate needs detected currently known process curpred becomes process strong linked predicate detected show correctness algorithm let links 1 predicate links 1 defined true also use sx refer value variable x state following lemma describes assertion variable curpred lemma 3 local states proof show assertion true initial state maintained program since curpred initially 1 assertion trivially true initial state process induction case let oe im assume assertion holds show true consider two cases case 1 event executed receive since assertion holds links scurpred holds lp scurpred true linkt scurpred holds oe im also easy see scurpred maximum j linkt holds incrementing scurpred assertion maintained case 2 message received sent state u part proof follows observation links implies linkt j assertion holds u maintained taking max scurpred ucurpred theorem 4 termination algorithm exists process detectflag true lp 1 lp 2 delta delta delta lpm true proof first show strong linked predicate true detected algorithm let strong linked predicate true means termination exists state links 1 true lemma 3 scurpred follows process state detectflag set conversely assume sdetectf lag true ie scurpred 1 lemma 3 means links m1 holds theorem 2 happen lp 1 algorithm requires extra messages require message contain value curpred hence message grows size olog bits number local predicates linked predicate algorithm also used detect dp disjunction local predicates difference detection predicate strong linked predicate index may occur pred list one process miller choi mill88 also proposed similar algorithm linked predicates algorithm process p sends predicate marker along channel directed away p detecting local predicate thus algorithm assumes underlying communication channels fifo note assumption also exploited stopping program consistent state using algorithm similar chandy lamport chalam85 4 strong conjunctive predicates conjunctive predicates form interesting class predicates logic strong conjunctive predicate true system always reach global state given local predicates true state formally strong conjunctive predicate local predicates practically speaking strong conjunctive predicates useful good desirable predicates ie predicates programmer would like true point program example case distributed twophase commit protocol master decides commit transaction must true program global state slaves ready commit program executed commits global state slave processes ready occur program error section present conditions necessary sufficient strong conjunctive predicate hold one main results paper conditions use notion intervals interval defined sequence consecutive states trace beginning state designated ilo ending state designated ihi convenient assume ilo ihi distinct ilo oe ihi restriction model interval single state sufficient stutter state set intervals belonging different process trace said overlap represented overlapi following holds intuitively notion overlapping intervals means interval los ordered interval assume n lp local predicates different processes lp 1 lp 2 another local predicate lp 1 lp 2 belong process use lp denote local predicate lp true entire interval following lemma shows existence overlapping intervals sufficient ensure global sequences go global state lp proof using definition overlapping intervals know means lo 0 must appear hi 0 global sequence therefore every possible global sequence state greater equal lo 0 less equal hi 0 state boolean expression lp true hence strong conjunctive predicate show conditions also necessary obligation show conditions violated exists global sequence strong conjunctive predicate false proof existence global sequence constructive global sequence construct property go global state lp true call global sequence pure formally definition 6 global sequence construct pure global sequence concatenating together multiple pure global subsequences let g global sequence run consistent global state x consistent global state ie x first global state g last global state g h global sequence global state global state z easy see g concatenated h also global sequence x z constructing pure global sequence use intermediate states satisfy certain properties let x global state denote firstx mtuple intervals k x first interval rk ends state xk lp k true firstx may exist process p k lp k never becomes true xk global state called consistent use consistent global states description intermediate consistent global states use construct pure global sequence satisfy admissibility property definition 7 x admissible intermediate global state either firstx exist exist k l k xlo 6 l xhi lp k xk words exists two intervals k l overlap k xlo 6 l xhi lp k true state xk ready show lemma 8 proof global state x b c acd bcd ace bce figure 4 ix firstx let ix global state x set mtuple intervals lp true th trace see fig 4 local state xi show none mtuple intervals satisfy overlapping condition exists global sequence distributed program never mtuple x aim construct pure global sequence g start x global state built pure global sequence start x remaining task build pure global sequence x stop initially choose start show pure global sequence x jixj thus continuing manner reach global state z point global sequences pure start state admissible assumption either firststart exist exist k l k startlo 6 l starthi moreover lp k false k a2 suppose given admissible global state x jixj 0 first interval rj lp j true ends state xj x admissible firstx exists jixj 0 exist k l k xlo 6 l xhi lp k xk define local state l xhinext state exists a2 may l construct global sequence x another admissible global state defined minimum consistent global state global state exists set consistent cuts ideals lattice matt89 ideals grow adding one element time djr93 first show lp k never true xk yk sufficient show know k xlo 6 l xhi applying a1 twice follows k xloprev 6 l xhinext thus exists consistent global state z containing zk k xloprev minimum consistent global state get yk k xloprev implies lp k never true xk yk thus global sequences x pure see figure 5 x ik il ik il figure 5 illustration proof strong conjunctive predicates still need show admissible firsty exist done otherwise know exist k 0 l 0 k 0 ylo 6 l 0 yhi see fig 5 admissible state done otherwise yk 0 inside interval k 0 k 0 yloprev 6 find consistent global state z yloprev minimum state k 0 ylo yk 0 z cannot exist thus k 0 a1 equivalent k 0 show admissible l ylo 6 l 0 yl second conjunct clearly true definition show first conjunct k 0 l xhi l xhi oe l ylo follows k 0 l ylo therefore l ylo l 0 yhi inconsistent k 0 ylo 6 l 0 yhi thus first conjunct l ylo 6 l 0 yhi also holds see necessary sufficient conditions strong conjunctive predicate hold intervals delimited lo 0 local predicate transitioning false true transitions true false must overlap point discuss role a2 consider scenario two processes lp 1 lp 2 true throughout execution p 1 p 2 respectively p 1 p 2 never communicate exist overlapping intervals lp 1 lp 2 however may seem reader global sequence global state lp 1 lp 2 true global sequence exist global state satisfying strong conjunctive predicate obtained running one process completion starts clearly unless execution processes synchronized manner sequence proper global sequence a2 lp 1 lp 2 false initial state process begun execution final state process finished execution 41 algorithms detecting strong conjunctive predicate describe algorithms check whether intervals local predicates hold overlap algorithms executed two kinds processes nonchecker processes checker processes based slight modification timestamp vectors proposed fidgefidge88 mattern matt89 process detects local predicate records timestamp interval associated predicate intervals sent checker process uses decide strong conjunctive predicate became true nonchecker process local lcmvector timestamps process message id last message p anybody causal relationship p j lcmvectorj process p j next message id p j use time local predicate process changes false true current value lcmvector remembered interval lo next truetofalse transition denoted fig 6 process sends stored lcmvector interval lo current lcmvector interval hi checker process debug message next observe process required send interval every time local predicate detected interval need sent message activity since last time interval sent lcmvector change value message sent received show sufficient send lcmvector message received irrespective number messages sent let predicate firstlmri true iff local predicate true first time since last message received beginning trace say scpi true 1 intervals different processes making strong conjunctive predicate true theorem 5 theorem 9 9i proof symmetry sufficient prove existence j 1 scpj 1 first interval trace p 1 lp j 1 true since proof obligation show scpj 1 sufficient show overlapj 1 k 1 lo k hi j 1 therefore moreover message received j 1 hi 1 hi last causal message made k lo 1 hi true must arrived j 1 hi therefore also true k lo j 1 hi hence conclude overlapj 1 k process p id var lcmvector array 1n 0maxmid init 8ii 6id last causal msg rcvd process 1 n respec current interval record lo hi 0maxmidend firstflag boolean init true local pred boolean expression local pred tested process 2 sending send prog midgen upon receive prog mid msg firstflag true upon local pred firstflag current intervallo lcmvector upon local pred firstflag current intervalhi lcmvector send dbg current interval checkerproc firstflag false figure algorithm strong conjunctive processes nonchecker process p id dominant space complexity algorithm due array lcmvector main time complexity involves detecting local predicates sequential debugger worst case one debug message generated program message received worst case message complexity om r number program messages received give algorithm checker process detects strong conjunctive predicate using debug messages sent processes checker process separate queue process involved strong conjunctive predicate incoming debug messages processes enqueued appropriate queue ensure checker process gets message process fifo order required computation var queue record lo hi timevectorend changed newchanged set f12mg upon recvelem p k changed changed 6 oe begin newchanged fg changed j 12m begin newchangednewchanged fig newchangednewchanged fjg end changed newchanged changed deleteheadq end figure 7 algorithm strong conjunctive checker process check lcmvector u less vector v different process j intervals processes p p j vector pairs x respectively overlapi j iff xlo proof proof follows fact states time vectors u v thus task checker process reduced checking ordering lcmvectors determine intervals overlap lemma use terms intervals vectorpairs interchangeably following lemma shows checker process avoid checking possible combinations intervals lemma 11 let x two vector pairs head respective queues overlap least one eliminated consideration checking see strong conjunctive predicate satisfied proof order strong conjunctive predicate true must exist set intervals one queue overlaps others set let two intervals x head queues overlap means either xlo 6 yhi ylo 6 xhi assume former without loss generality show eliminated case let x 0 another interval queue x overlaps implies x xlo yhi contradiction checker process receives debug messages containing timestamp pairs processes executes algorithm fig 7 element queue interval comparisons done hi 0 lo 0 intervals checker process reduces number comparisons deleting vectorpair head queue whose hi lcmvector greater lo lcmvector vectorpairs head queues checker process detected strong conjunctive predicate true finds set intervals head queues pairwise overlapping algorithm requires om 2 p comparisons number queues length p 5 decentralization algorithm show techniques decentralizing algorithm set intervals pairs intervals overlap following holds denote predicate overlaps aim show condition checked decentralized manner need concept greatest lower bound set intervals let x set intervals interval x defined pair vectors xlo xhi xlo xhi define order v elements set follows easily checked x v partial order partial order x u x following theorem shows process finding overlapx decomposed smaller sets theorem 12 let xy z sets intervals clearly true z x need show let zg since overlapy overlapz z belong x prove overlapy z need show lo z show first conjunct overlapx get particular definition z conclude lo z hi show p 1 holds x ie z belong either z true overlapy overlapz let us assume without loss generality 2 z 2 z need show ylo zhi true ylo lo z hi zhi first last inequality follow definition z middle inequality follows overlapy z using theorem notions hierarchy algorithm checking strong conjunctive predicate decentralized follows may divide set processes two groups group checker process checks strong conjunctive predicate within group finding one sends greatest lower bound intervals higher process hierarchy process checks last conjunct theorem clearly argument generalized hierarchy depth 6 applications main application results debugging testing distributed programs incorporated algorithms distributed debugger hoagla92 online debugger able detect global states sequences global states distributed computation architecture distributed debugger shown figure 8 application process attach two processes gdb process monitor process gdb sequential debugger use detecting local predicates monitor processes responsible attaching vector time information messages also report centralized coordinator process whenever interval detected monitor processes also detect strong linked predicates using algorithm outlined earlier one coordinator process system receives information monitor processes checks strong weak conjunctive predicates coordinator also provides single userinterface programmer distributed debugger runs cluster sun workstations running sunos application process gdb application process gdb coordinator userinterface checker algorithm scp monitor monitor vector clocks slp algorithm figure 8 architecture distributed debugger also used algorithms implement trace analyzer distributed programs chin91 analyzer monitors distributed program gathers enough information form distributed run user ask whether global predicate became true conclusions discussed detection global predicates distributed program earlier algorithms detection global predicates proposed chandy lamport work stable predicates algorithms detect even unstable predicates reasonable time space message complexity paper emphasized conjunctive predicates disjunctive predicates reason disjunctive predicates quite simple detect disjunctive predicates form alp 1 lp form elp 1 lp turns simple case considered expressions equivalent detect disjunctive predicate alp 1 lp sufficient process p monitor lp process finds local predicate true disjunctive predicate true also discussed predicates form 2bool predicates duals discussed garwal94 algorithms given paper detect predicates form a3bool bool conjunction local predicates would great interest algorithms generalized detect predicates bool boolean expression local predicates acknowledgements would like thank bryan chin mohamed gouda greg hoagland jay misra michel raynal alex tomlinson comments earlier versions work would also like thank bryan chin implementing offline versions algorithms greg hoagland incorporating algorithms distributed debugger also thank anonymous referees meticulous review earlier version paper r consistent global states distributed systems fundamental concepts mechanisms distributed debugging tools heterogeneous distributed sys tems repeated snapshots distributed systems synchronous communication implementation csp distributed snapshots determining global states distributed systems offline debugger distributed programs consistent detection global predicates reachability analysis distributed executions partial orders parallel debugging detection unstable predicate distributed programs using induction prove properties distributed programs detection weak unstable predicates distributed programs detection strong unstable predicates distributed programs global events global breakpoints distributed systems debugger distributed programs detecting atomic sequences predicates distributed computations time clocks ordering events distributed system virtual time global states distributed systems debugging concurrent programs breakpoints halting distributed programs detecting causal relationships distributed computations search holy grail efficient distributed snapshots simultaneous regions framework consistent monitoring distributed systems detecting relational global predicates distributed systems unstable predicate detection distributed programs tr ctr sridhar alagar subbarayan venkatesan techniques tackle state explosion global predicate detection ieee transactions software engineering v27 n8 p704714 august 2001 hsienkuang chiou willard korfhage enf event predicate detection distributed systems proceedings thirteenth annual acm symposium principles distributed computing p91100 august 1417 1994 los angeles california united states punit chandra ajay kshemkalyani distributed algorithm detect strong conjunctive predicates information processing letters v87 n5 p243249 15 september loonbeen chen ichen wu efficient distributed online algorithm detect strong conjunctive predicates ieee transactions software engineering v28 n11 p10771084 november 2002 ajay kshemkalyani finegrained modality classification global predicates ieee transactions parallel distributed systems v14 n8 p807816 august alexander tomlinson vijay k garg detecting relational global predicates distributed systems acm sigplan notices v28 n12 p2131 dec 1993 jeanmichel hlary achour mostefaoui michel raynal communicationinduced determination consistent snapshots ieee transactions parallel distributed systems v10 n9 p865877 september 1999 guy dumais hon f li distributed predicate detection seriesparallel systems ieee transactions parallel distributed systems v13 n4 p373387 april 2002 craig chase vijay k garg detection global predicates techniques limitations distributed computing v11 n4 p191201 october 1998 vijay k garg methods observing global properties distributed systems ieee parallel distributed technology systems technology v5 n4 p6977 october 1997 jm hlary mostefaoui r h b netzer raynal communicationbased prevention useless checkpoints distributed computations distributed computing v13 n1 p2943 january 2000 ashis tarafdar vijay k garg predicate control synchronization distributed computations lookahead journal parallel distributed computing v64 n2 p219237 february 2004 scott stoller detecting global predicates distributed systems clocks distributed computing v13 n2 p8598 april 2000 punit chandra ajay kshemkalyani causalitybased predicate detection across space time ieee transactions computers v54 n11 p14381453 november 2005 felix c grtner fundamentals faulttolerant distributed computing asynchronous environments acm computing surveys csur v31 n1 p126 march 1999
least greatest fixed points intuitionistic natural deduction paper comparative study number intensionalsemantically distinct least greatest fixed point operators naturaldeduction proof systems intuitionistic logics extended prooftheoretically defendable way eight pairs operators analysed exposition centred around cubeshaped classification node stands axiomatization one pair operators logical constants intended proof reduction rules arc proof reductionpreserving encoding one pair terms another three dimensions cube reflect three orthogonal binary options conventionalstyle vs mendlerstyle basic coiterative vs enhanced primitivecorecursive simple vs courseofvalue coinduction axiomatizations encodings well known others however novel classification cube also new differences least fixed point operators considered illustrated example corresponding natural number types b introduction paper comparative study number least greatest xed point operators inductive coinductive denition operators natural deduction nd proof systems intuitionistic logics typed lambda calculi product sum types extended logical constants typelanguage constants either axiomatization intended proof reduction rules implicit denition proof reductionpreserving encoding terms logical constants already present explicit deni tion one reasons logical typelanguage constants interesting lies useful programming interpretation inductive types behave data types introductions data constructors eliminations recursors coinductive types may viewed codata types introductions corecursors eliminations codata destructors literature fairly large number axiomatizations encodings particular coinductively dened types general coinductive denition operators found see eg 11419202425157 paper grew wish better understand individual properties relations contribution paper consists coordinated analysis eight intensionalsemantically distinct pairs coinductive denition operators arranged cubeshaped taxonomy resulted attempt various known axiomatizations encodings single picture nd llers holes node cube stands axiomatization proof reduction rules one pair logical constants arc proof reductionpreserving encoding one pair terms another axiomatizations encodings rely presence system certain logical constants standard propositional connectives 2ndorder quantiers retractive recursive denition operator three dimensions cube ect three orthogonal binary choices conventionalstyle vs mendlerstyle basic coiterative vs enhanced primitivecorecursive simple vs courseofvalue coinduction cube looks follows q optional superscripts conventionalstyle inductive coinductive denition operators n optional superscripts mendler style operators superscript q marks enhanced feature superscript indicates courseofvalue feature distinctions basic enhanced simple courseofvalue coin duction distinctions essentially dierent forms coinduction dierent associating schemes total corecursion basic coinduction gives coiteration enhanced coinduction gives full primitive corecursion axiomatizations encodings found literature deal simple forms coinduction axiomatizations encodings course ofvalue coinduction paper think dierence conventional mendlerstyle coinduction named mendler 1920 technical harder spell informally shallow conventionalstyle coinductive denition operator applies propositionfunction positive associating reduction rule refers proof monotonicity positive propositionfunctions monotonic wrt preorder inclusion mendlerstyle operators apply propositionfunctions axiomatizations enhanced courseof value conventionalstyle operators rely presence system logical constants mendlerstyle operators thus one sense mendlerstyle operators uniform conventionalstyle operators resorting programming jargon one might instance want say mendlerstyle operators generic whereas conventional style ones polytypic uniformity features price proof rules mendlerstyle operators involve implicit external 2ndorder quantication level premisses throughout paper semantics keep mind intensional consider reduction conversion remarks order regarding technical machinery use natural deduction mean proof system style instead axioms involving implications universal quantications systematically prefer proof rules involving hypothetical schematic judgements exter nalized implications universal quantications sharp contrast hilbert style proof systems us therefore natural deduction really extended natural deduction schroederheister 3031 allow proof rules order higher two may conclusions premisses premisses turn even latter may hypo thetical choice makes axiomatizations dierent logical constants compact expense certain added complexity encodings terms logical constants order compactify notation get around technicalities related conversion substitution use simple metasyntax higheroder abstract syntax derived logical frameworks de bruijns autpi autqe 5 martinlofs system arities 22 chapter 3 harper honsell plotkins lf 12 denotes schematization wrt x denotes instantiation schematization instantiation stipulated satisfy following rules free made eort make paper selfcontained omitted details refer uustalu 35 preliminary report present work appeared 37 also refer matthes 17 indepth study extensions system f constructors basic enhanced conventional mendlerstyle inductive types regard clarication relationship conventional mendlerstyle induction builds partly upon work paper organized follows section 2 lay starting point given systems denote ni ni 2 nd proof systems 1st 2ndorder intuitionistic propositional logics optionally extended retractive recursive denition operator section 3 rst present basic coinduction operators conventional mendler style continue encodings terms 2ndorder quan tiers sections 4 5 describe enhanced coinduction courseofvalue coinduction operators respectively encodings via operators basic kind section 6 give survey related work inductive coinductive types finally section 7 conclude mention directions future work preliminaries principle coinductive denition operators described added nd proof system intuitionistic propositional logic also admit straightforward generalization predicate logics natural base system extensions however ni standard nd proof system full 1storder intuitionistic propositional logic logical constants ni conjuction disjunction verum falsum implication propositional connectives axiomatized proof reduction rules listed figure 1 save space reduction rules given proofs untyped term codes proofs reduction rules proofs easy recover reduction relation terms satises subject reduction l e c e ce figure 1 proof reduction rules standard propositional connectives another important base system ni 2 nd proof system 2ndorder intuitionistic propositional logic system extends ni 8 2 9 2 standard 2ndorder quantiers proof rules 8 2 9 2 presented figure 2 encodings enhanced coinduction terms basic coinduction shall need logical constant retractive recursive denition oper ator propositionvalued operator propositionfunctions positive proof reduction rules appear figure 3 introduction elimination rules behave embeddingretraction pair c c ec ec figure 2 proof reduction rules 8 2 9 2 extensions ni ni 2 denoted ni ni 2 importance us fact ni 2 strongly normalizing ie every proof ni 2 strongly normalizing consult mendler 1920 urzyczyn 34 figure 3 proof reduction rules syntactic concepts positivity negativity propositionfunctions systemdependent particular system concepts dened mutual structural induction propositionfunctions denable sys tem ni extensions considered paper propositionfunction xf dened positive negative every occurrence x f appears within even odd number antecedents implications also particular system similar induction explicit denitions given derivable proof rules establishing positive neg ative propositionfunctions monotonic antimonotonic wrt preorder proposition inclusion proof rules appear figure 4 f f positive f negative figure 4 derivable proof rules example shall consider propositionfunction n dened setting n obviously positive corresponding monotonicity witness map n dened follows 3 basic coinduction logical constants two lower front nodes cube provide fundamental forms coinductive denition propositions viz basic words coiterative forms conventional mendlerstyle coinductive denition operators conventionalstyle induction coinduction apply positive propositionfunctions mendlerstyle counterparts applicable without restrictions propositionfunctions proof reduction rules given figures 5 6 proof rules n complex reduction rules compensation simpler uniform righthand sides refer proof rule e cata f cata f wrap f c e emap f cata f e e open open f ana f c e map f figure 5 proof reduction rules e e figure proof reduction rules n algebraic semantics point view f least prexed point f wrt inclusion preorder propositions prexed point f irule lower bound set prexed points f erule recall r said prexed point f f r less r f dually greatest postxed point f 3 since least prexed postxed point monotonic function also least xed point f f also least greatest xed points f similar fashion mf thought least robustly prexed point f robustly prexed point f lower bound robustly prexed points f r considered robustly prexed point f f r less r f less r less r mf also least ordinary prexed point function sending r supremum set f less r f e always positive appears least monotonic majorant f wrt pointwise lifting inclusion preorder propositions preorder propositionfunctions f monotonic f f e equivalent pointwise dualization obvious nf greatest robustly postxed point f greatest ordinary postxed point function f f r 8 2 ry f sending r inmum set f greater r programming interpretation f data type wrap f data constructor cata f iterator f codata type ana f coiterator open f codata destructor standard sense mf mapwrap iter nf coit mapopen mendlerstyle versions things best explained example type standard natural numbers nat zero succ constant zero successor function natcata iterator normally axiomatized follows typing reduction rules essentially nothing else 3 note preorder also heyting algebra may turn monotonic functions least greatest prexed postxed points hence allowing apply positive f lead inconsistencies encodability terms 8 2 9 2 demonstrates case indeed conventional basic induction n underlying propositionfunction indeed making following denitions ensures required typing reduction properties nat n zero wrap n inlhi succc wrap n inrc suggests similar specialization mendlerstyle basic induction n following denitions nat mn mapzerod mapwrapinlhi mapwrapinrc type nat mendlerstyle natural numbers mapzero mapsucc natiter mendlerstyle constant zero successor function iterator obeys following typing reduction rules may helpful think q chosen type representations naturals method converting representations type naturals natural hence constructed nothing representation predecessor together method converting representations naturals using nat q standard constructors naturals denable follows zero mapzero succc mapsuccc natcata natiter iterators iteration simple form total cursion result iteration given natural dependent result predecessor straightforward denition function follows complex form recursion denitions iteration get clumsy factorial given natural instance depends factorial predecessor also predecessor iterative denition factorial dene factorial identity function parallel project factorial component zero zero exactly trick tupling also needed program fibonacci function fibonacci given natural number depends fibonacci predecessor also fibonacci prepredecessor iterative denition fibonacci dene fibonacci one stepbehind fibonacci parallel boc fstnatcatac zero case snd boc fstnatiterc zero case snd examples show forms recursion captured iteration using tupling modelling without drawbacks however first transparent dene function using native form cursion second intensional behavior iterative denitions always satisfactory well known instance predecessor function programmed using iteration programs take linear time compute work desirable numerals ie closed natural number terms predc cata n c predc iterc complex forms induction considered following sections remedy problems oering advanced forms recursion basic coinduction vs 2ndorder quantiers n encoded terms 8 2 9 2 proof reduction preserving manner proposition 1 following proof reductionpreserving encoding terms 8 f c map cata f ana f open f c map f fstc sndc hfstc encoding proof theory recapitulation knastertarski xed point theorem 33 stating inmum supremum set prexed postxed points monotonic function least greatest prexed postxed point general form encoding seems piece folk lore special case polynomial propositionfunctions n essentially encoding rst given bohm berarducci 1 leivant 14 naturals encoding specializes following nat zero natcata bohm berarduccis encoding nat zero c e z e proposition 2 following proof reductionpreserving encoding n terms 8 iter coit mapopen encoding builds following robust analog knastertarski xed point theorem inmum supremum set robustly prexed postxed points function monotonic least greatest robustly prexed postxed point corollary 3 ni 2 also fragment including ni extended operators n strongly normalizing con uent mendlerstyle vs conventional coinduction also possible encode terms n vice versa encoding latter direction 8 2 9 2 available proposition 4 following proof reductionpreserving encoding terms n f c mapwrapc cata ana f e open f c mapopenc proposition 5 following proof reductionpreserving encoding n terms presence 9 2 iter f r 8 2 ry f coit mapopen open f ac encoding n terms prooftheoretic version observation least greatest prexed postxed point f e f least greatest robustly prexed postxed point f enhanced coinduction logical constants two upper front nodes cube capture enhanced words primitivecorecursive forms conventional mendlerstyle coinductive denition q q operators enhanced induction coinduction q n q mendlerstyle counterparts proof reduction rules given figures 7 8 adding q q proof system presupposes presence corresponding restriction governing addition q n q q e para f wrap q para f fst e e r q open q open q figure 7 proof reduction rules q q algebraic semantics pointofview q f least recursive prexed point given necessarily monotonic f ie least element set rs f r q f less r note recurrent occurrence q f q f greatest recursive postxed point f least recursive robustly prexed point given f ie least element set rs f less r less r also q f note circularity n q f dually greatest recursive robustly postxed point f programming q f recursive data type wrap q f recursive data constructor para f primitive recursor q f recursive codata type apo f primitive corecursor open q f recursive codata e recmapwrap q c e ec recd e e mapopen q c mapopen q corc e ec dcor e figure 8 proof reduction rules q n q destructor q f mapwrap q rec n q f cor mapopen q mendlerstyle equivalents returning running example naturals specializing enhanced induction n yields type nat q recursive natural numbers zero q succ q natpara recursive constant zero recursive successor function primitive recursor nat q q n zero q wrap q succ q c wrap q typing reduction rules nat q following note nonzero recursive natural constructed pair naturals reduction rule rst used argument recurrent applications function dened second one used directly principle two naturals unrelated normal usage construction second natural equal rst predecessor standard successor function recovered duplicating argument zero zero q succc succ q hc ci type nat q recursive mendlerstyle naturals dened follows nat mapzero q mapwrap q inlhi nat q obeys following typing reduction rules mapzero q e z natrecmapzero q e z nonzero recursive mendlerstyle natural constructed representation predecessor method converting representations naturals another function representations naturals normal usage construction second method also conversion method choosing nat q type representations standard constructors obtained follows zero mapzero q succc mapsucc q c recursive naturals constructed using standard constructors natpara natrec capture standard primitive recursion factorial function instance programmed follows degenerate application primitive recursion uses direct access predecessors nonzero naturals gives fast constant time program predecessor function predc natparac inlhi predc natrecc inlhi enhanced vs basic coinduction n encoded terms q q q n q converse also true retractive recursive denition operator available proposition 6 following proof reductionpreserving encoding terms q f c wrap q f f cata f f ana f f open f c map f open q proposition 7 following proof reductionpreserving encoding n terms q mapwrap q c iter coit mapopen mapopen q c proposition 8 following proof reductionpreserving encoding q q terms presence q f q r f r q f c iwrap f q f q para f cata f q q f q r f r q apo f open q f q open f q oc proposition 9 following proof reductionpreserving encoding q n q terms n presence f q r rm q mapwrap q rec f q r n q cor last two encodings would really like dene q cannot circularity resorting way overcome obstacle result 32 follows using necessity one cannot possibly without rst encodings implicit 25 15 also appears 7 second seems new also fragment including ni extended operators q q q n q strongly normalizing con uent 5 courseofvalue coinduction logical constants two lower rear nodes cube capture courseofvalue forms conventional mendlerstyle coinductive deni tion operators courseofvalue induction coinduction n mendlerstyle counterparts proof reduction rules given figures 9 10 adding proof system presupposes presence corresponding restriction governing addition r 4 f p f e cvcata f cvcata f wrap cvcata f fstopen 4f sndopen 4f r e open open f cvana f c e f cata 5f wrap 5f case figure 9 proof reduction rules e e mapopen c mapopen cvcoitc e figure 10 proof reduction rules n algebraic semantics pointofview f least courseofvalue prexed point given necessarily monotonic f ie least element set rs f zr f z less r f greatest courseofvalue postxed point f least courseofvalue robustly prexed point given f ie least element set rs f less r less r also f dually greatest courseofvalue robustly postxed point f programming f courseofvalue data type wrap f course ofvalue data constructor cvcata f courseofvalue iterator f courseofvalue codata type cvana f courseofvalue iterator open f courseofvalue codata destructor f mapwrap cviter n f cvcoit mapopen mendlerstyle equivalents specializing courseofvalue induction n yields type nat courseof value natural numbers zero succ natcviter courseofvalue versions constant zero successor function iterator respectively nat n zero wrap specialized typing reduction rules constants following similarly recursive case nonzero courseofvalue naturals constructed single preceding natural argument courseof value successor function colistlike structure naturals coiteration reduction rule applies function dened recurrently every element colist principle naturals colist unrelated normal usage however tail colist ancestral head predecessor natural constructed ancestral natural mean colist lesser naturals descending order standard successor function naturals therefore easily recovered courseofvalue successor function rst coiteratively applying predecessor function argument zero zero h pred predecessor function however admit straightforward definition problem vanishes case courseofvalue primitive recursion denable terms ancestral function denable courseofvalue iteration way predecessor function denable simple iteration predc pred c fstopen pred c cvcata n c specialization courseofvalue mendlerstyle induction n yields nat courseofvalue mendlerstyle naturals nat mapzero derived typing reduction rules abovedened constants following e z nonzero courseofvalue mendlerstyle natural constructed three components rst two case simple mendler style naturals representation natural predecessor method convert representations naturals additional third component gives method converting representation natural nothing another representation normally predecessor natural using nat type representations obtain standard constructors naturals follows zero mapzero pred succc mapsucc c pred dene predecessor function need also ancestral function predc pred c fstopen pred c cviterc courseofvalue naturals constructed using standard constructors natcvcata natcviter capture standard courseofvalue iteration fibonacci function instance programmed using natcvcata follows boc natcvcatac zero case sndopen using natcviter denition fibonacci function becomes even straightforward instead manipulate intermediate colist values fibonacci returns roll back inputs boc natcviterc zero courseofvalue vs basic coinduction encoding n terms n similar encoding constants terms q q q n q also encoding opposite direction analogous fact even simpler needed proposition 11 following proof reductionpreserving encoding terms f c wrap f cata case fstopen 4f ana f f open f c map proposition 12 following proof reductionpreserving encoding n terms iter coit mapopen proposition 13 following proof reductionpreserving encoding terms f wrap f c cvcata f c e cata f c e cvana f f open f c proposition 14 following proof reductionpreserving encoding n terms n mapwrap c cviter cvcoit mapopen c corollary 15 ni 2 also fragment including ni extended operators strongly normalizing con uent 6 related work rst author extend intuitionistic nd system basic conventional style inductively dened predicates uniformly axiomatization martin lof theory iterated inductive denitions 21 bohm berarducci 1 leivant 14 rst authors describe encode polynomial basic conventionalstyle inductive types 2nd order simply typed lambda calculus girard reynolds system f nd proof system 8 2 fragment 2ndorder intuitionistic propositional logic method often referred impredicative encoding inductive types keeping mind basic conventionalstyle induction mendler 19 described extension axiomatization 2ndorder simply typed lambda calculus enhanced inductive coinductive types style mendler 20 discussed similar system basic mendlerstyle inductive coinductive types extensions nd proof systems 2ndorder intuitionistic predicate logic constructors basic conventional mendlerstyle inductive predicates described leivants 15 paper extracting programs extensions 2storder simply typed lambda calculus proofs extensions nd proof system 2ndorder intuitionistic predicate logic parigots work 2425 realizabilitybased programming proofs bears connection leivants mendlers works greiner 10 howard 13 chapter 3 considered programming extension 1storder simply typed lambda calculus axiomatized constructors conventionalstyle coinductive types coiteration data destruction codata construction motivation haginos categorytheoretic work cited studied thus barely reduction even conversion driven denite semantic considerations howard implemented system programming language lemon geuvers 7 carried comparative study basic vs enhanced conventional vs mendler style inductive coinductive types extensions 2ndorder simply typed lambda calculus spirit leivant paulinmohring 26 extracted programs girards f proofs coquand huets cc calculus constructions milestone papers inductive type families extensions cc luos ecc extended calculus constructions combination cc martinlofs type theory pfenning paulinmohring 28 coquand paulinmohring 4 ore 23 paulinmohring 27 formulated calculus inductive constructions extends cc inductive type families primitive recursion axiomatization coq proof development system developed inriarocqencourt enslyon implementation last system category theory basic conventionalstyle inductive coinductive types modelled initial algebras terminal coalgebras covariant functors hagino 11 designed typed functional language cpl based distributive categories initial algebras terminal coalgebras strong covariant functors implemented charity language cockett et al 3 similar programming language program calculation community rooted birdmeertens formalism squiggol 2 originally equational theory programming parametric data type lists malcolm 16 made community aware haginos work studied program calculation based bicartesian closed categories initial algebras terminal coalgebras cocontinuous resp continuous covariant functors meertens 18 rst author give treatment primitiverecursion setting classic references area fokkingas 6 sheard fegaras 29 7 conclusion future work paper studied least greatest xed point operators intuitionistic nd systems extended described eight pairs operators whose eliminations introductions behave recursors corecursors meaningful kinds intend continue research study perspectives utility intuitionistic nd systems least greatest xed point operators program construction specications concerns specication methodology computer assistance synthesis also started study relating categorical deduction systems typed combinatory logics la curien utility program calculation relevant categorical theory 38363940 also intend nd details apparent close relationship enhanced courseofvalue mendlerstyle corecursion gimenez new formulation guarded corecursion 9 systems sub supertyping quantication upper lower bounds radically dierent older syntactical formulation 8 acknowledgements thankful anonymous referees number helpful comments suggestions especially regards matters presentation proof gures diagrams appearing paper typeset using proofsty makoto tatsuta xypic generic kristoer c rose respectively r introduction theory lists yellow series report 9248018 inductively de survey project automath law order algorithmics inductive coinductive types iteration recursion categorical programming language framework de fixed points extensionality typed functional programming languages reasoning functional programs complexity classes associated type disciplines contracting proofs programs data structures program transformation extensions system f iteration primitive recursion monotone inductive types recursive types type constraints secondorder lambda calculus inductive types type constraints secondorder lambda calculus extended calculus constructions ecc inductive types second order type theory recursive programming proofs mohring extracting f mohring inductive de mohring inductively de fold seasons natural extension natural deduction generalized rules quanti latticetheoretical xpoint theorem applications positive recursive type assignment natural deduction intuitionistic least greatest cube proof systems intuitionistic predicate primitive corecursion courseofvalue coiteration coding recursion tr introduction theory lists extracting myampersandohgrs programs proofs calculus constructions inductively defined types programming martinlomyampersandumlfs type theory introduction data structures program transformation inductively defined types calculus constructions recursive programming proofs framework defining logics extended calculus constructions ecc inductive types fold seasons fixed points extensionality typed functional programming languages type fixpoints programming proofs positive recursive type assignment inductive definitions system coq rules properties structural recursive definitions type theory codifying guarded definitions recursive schemes mendlerstyle inductive types categorically programming inductive coinductive types categorical programming language ctr gilles barthe tarmo uustalu cps translating inductive coinductive types acm sigplan notices v37 n3 p131142 march 2002 g barthe j frade e gimnez l pinto uustalu typebased termination recursive definitions mathematical structures computer science v14 n1 p97141 february 2004
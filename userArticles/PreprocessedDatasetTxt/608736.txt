unified interprocedural parallelism detection paper outline new way detecting parallelism interprocedurally within program method goes beyond mere dependence testing embrace methods removing dependences well namely privatization induction recognition reduction recognition method based combination techniques universal form representing memory accesses within section code linear memory access descriptor technique classifying memory locations based accesses made code memory classification analysis dependence test access region test analysis done linear memory access descriptors based intersection operation present algorithm linear memory access descriptors independent declarations may exist program subroutine languageindependent makes ideal use interprocedural analysis experiments indicate test highly effective parallelizing loops containing complex subscript expressions b introduction modern computer architectures everfaster processors make increasingly important parallelizing compilers analysis interprocedurally compiler parallelizes intraprocedurally conned parallelizing loops leaf nodes call graph quite often enough operations leaf nodes make parallelization pay loop parallelization within shared memory model compiler parallelize highest level call graph parallelization possible overcome parallel loop overhead costs addition interprocedural dependence analysis essential producing spmd message passing code serial program work supported part army contract dabt6395c0097 army contract n6600197c8532 nsf contract mip9619351 partnership award ibm kaist seed grant program work necessarily representative positions army government c 2000 kluwer academic publishers printed netherlands traditional dependence testing developed without regard applicability across procedure boundaries pairs memory references may access memory location within loop compared memory references occur discrete points within loop thus say methods pointtopoint dependence tests pointtopoint tests require 2 comparisons n number memory references particular array within loop obviously position within call graph gets leaves number n grow growth cause interprocedural pointtopoint dependence testing get unwieldy considerations motivated us take dierent approach dependence testing memory accesses within program section summarized summaries intersected determine dependence sections series experiments found approach reduces number comparisons dependence testing also allows us handle complex array subscript expressions paper organized follows discussing previous related work section 2 continue discussion section 3 showing summarize memory access activity arbitrary program section section 4 describe novel notation practical summarizing various complex array accesses encountered many scientic programs section 5 show use access summaries stored notation perform multiplesubscript interprocedural summarybased dependence testing evaluate eectiveness dependence test implemented polaris 4 compiler experimented actual codes perfect spec nasa benchmark suites experimental results presented section 6 show test holds promise better detection parallelism actual codes tests 2 previous work 21 intraprocedural dependence testing pointtopoint dependence testing methods rely equation solving paradigm pair subscript expressions two array reference sites checked dependence equated attempt made determine whether equation solution subject constraints values variables program loop indices general case system linear relations built solution attempted linear system solver determine memory location accessed dierent loop iterations two earliest pointtopoint dependence tests gcd test banerjee test 2 practice simple ecient successful determining dependence since subscript expressions occurring real scientic programs simple however simplicity tests results limitations instance eective determining dependence multidimensional arrays coupled subscripts stated 9 several multiplesubscript tests developed overcome limitation multidimensional gcd test 2 test 12 power test 21 delta test tests exact commonly occurring special cases cases still conservative omega test 16 provides general method based sets linear constraints capable handling dependence problems integer programming problems justmentioned tests common problem cannot handle subscript expressions nonane nonane subscript expressions occur irregular codes subscriptedsubscript access fft codes subscripts frequently involving 2 result compiler transformations induction variable closed forms inline expansion subroutines solve problem pugh et al17 enhanced omega test techniques replacing nonane terms array subscripts symbolic variables technique work situations however range test 3 4 built provide better solution problem handles nonane subscript expressions without losing accuracy overall range test almost eective omega test sometimes outperforms due mainly accuracy nonane expressions 3 one critical drawback range test multiplesubscript test eective handling coupledsubscripts 22 interprocedural summarization techniques interprocedural dependence testing demands new capabilities dependence tests pointtopoint testing becomes unwieldy across procedure boundaries given way dependence testing using summaries accesses made subroutines idea using access summaries dependence analysis previously proposed several researchers balasundaram et al1 tang 18 also range test though pointtopoint test uses summarized range information variables obtained abstract interpretation program perform accurate dependence analysis access summaries compiler needs standard notation information array accesses summarized stored dependence analyzer several notations developed used dependence analysis techniques notable triplet notation 3 10 19 sets linear constraints 1 7 18 however indicated 11 existing dependence analysis techniques deciencies directly traceable notations used access summarization triplet notation simple work rich enough store possible access patterns linear constraints general precisely represent access patterns due nonane subscript expressions require much complex operations clearly room new dependence test new memory access representation overcome limitations existing techniques 23 parallelism detection dependence testing studied exhaustively topic adequately addressed unied method parallelism detection nds dependences categorizes easy removal important compiler transformations eigenmann et al 8 studied set benchmark programs determined important compiler analyses needed parallelize array privatization reduction induction idiom analysis dependence analysis nonane subscript expressions must done presence strong symbolic interprocedural analysis need improved analysis representational techniques prompts us go back rst principles rethink data dependence means ask whether dependence analysis done compiler transformations mind key contribution paper description general interprocedural parallelism detection technique includes general dependence analysis technique described section 5 called access region test art art multiplesubscript interprocedural summarybased dependence test combining privatization idiom recognition represents memory locations novel form called access region descriptor ard11 described section 4 based linear memory access descriptor 14 3 memory classication analysis section formulate data dependence analysis terms scheme classifying memory locations called memory classication analysis mca based order type accesses within section code method classifying memory locations general one based abstract interpretation5 6 program may used purposes dependence analysis traditional notion data dependence based classifying relationship two accesses single memory location operation done read write order accesses determines type dependence data dependence arc directed arc earlier instruction source later instruction sink access single memory location program four types arcs determined shown table table traditional data dependence denition dependence type input flow anti output earlier access read write read write later access read read write write input dependences safely ignored parallelization anti output dependences also called memoryrelated dependences removed using memory usually privatizing memory location involved flow dependences also called true depen dences sometimes removed transforming original code techniques induction variable analysis reduction analysis 20 generalized notion data dependence arbitrary sections code built returning rst principles instead considering single instruction memory reference point consider arbitrary sequence instructions indivisible memory referencing unit thing require memory referencing unit executed entirely single processor refer memory referencing unit dependence grain definition 1 section code representing indivisible sequentially executed unit serving source sink dependence arc program called dependence grain denition dependence grain corresponds terms coarse negrained analysis refer using large small dependence grains respectively want know whether two dependence grains may executed parallel must dependence analysis grains since single grain may access memory address many times must summarize accesses useful way relate type order summaries produce representative dependence arc two grains definition 2 representative dependence arc single dependence arc showing order two dependence grains must executed preserve sequential semantics program single representative dependence arc summarizes information would contained multiple traditional dependence arcs single instructions medium coarsegrain parallelization many accesses single memory location within dependence grain instead keeping track dependences possible pairs references reference site grain point topoint testing desired represent dependence relationship two grains individual memory location single representative dependence arc many possible ways summarize memory accesses needs analysis desired precision determine way best illustrate idea next two sections show two ways summarizing accesses simple lowprecision readonly summary scheme useful writeorder summary scheme 31 readonly summary scheme possible dene representative dependence carries dependence information needed potential parallelization two grains dependence exists pair memory references two grains neither representative dependence exist two accesses memory location exist grain must simply nd way assign aggregate access type group determine representative dependence way retains information need making parallelization decisions consider two grains execute serial form program one one consistent way summarize dependence single memory location two grains determine whether accesses readonly grain dene dependence table ii call readonly summary scheme table ii one possible representative dependence deni tion readonly summary scheme dependence type input flow anti output later readonly figure dependence summarization readonly summary scheme input dependence exists two grains ignored ow dependence exists grains general grains must serialized earlier grain later grain flow dependence input dependence earlier grain later grain flow dependence input dependence output dependence anti dependence output dependence grains flow dependence grains figure 1 dependence grains depends whether two grains readonly situation right shows case privatized later grain eliminating output dependence anti dependence exists grains means reads happen one grain followed least one write output dependence means least one write occurs grains anti output dependence situations write location rst access later dependence grain would possible run grains parallel privatizing variable later grain however readonly summary scheme dont keep enough information summary determine whether write happened rst later grain would miss opportunity parallelize privatization shows readonly summarizing detect dependences classify dependences clearly enough allow us eliminate dependence compiler transformations derive better scheme next section 32 writeorder summary scheme dependence grains loop iterations exists special case general problem single section code represents dependence grains fact used simplify dependence analysis task still using readonly summarization loopbased dependence testing would longer four cases two iteration either readonly however able dierentiate anti output dependences removed privatization cannot case readonly also divided two cases one write rst access location writefirst one read rst access readwrite gives three overall classes shown table iii table iii loopbased representative dependence table access readonly readwrite writefirst dependence type input flow antioutput iteration reads location dependence characterized input dependence ignored iteration reads location writes variable cannot privatized results dependence cannot ignored cannot removed privatization called flow dependence iteration writes location rst value location iteration starts immediately overwritten variable privatized since dependences removed privatization called memoryrelated dependences since privatization done memoryrelated dependence case case signaled write rst access need identify cases keep track case location written rst input ow dependence cases characterized read happening rst dierentiated whether occurs later call writeorder summary scheme makes sense use writeorder summarization scheme general case well loops locations readonly grains would correspond input dependence writerst later grain would correspond memory related dependence since written rst later grain later grain need wait value earlier grain others would correspond ow dependence illustrated table iv table iv eective way classify dependences two arbitrary dependence grains using classes readonly writefirst readwrite writeorder summary scheme later readonly later writefirst later readwrite earlier readonly input antioutput flow earlier writefirst flow antioutput flow earlier readwrite flow antioutput flow readonly summary scheme could serve dependence test writeorder summary scheme detect dependence well provide additional information necessary remove dependences privatization transformation see section 54 simple tests added writeorder summary scheme collect enough information allow dependences removed induction reduction transformations 33 establishing order among accesses knowing order accesses crucial writeorder summarization scheme must establish ordering accesses within program program contained straightline code establishing ordering accesses would trivial one could simply sweep program executionorder keeping track accesses happen branching statements unknown variables make dicult show one particular access happens another example take loop figure 2 write ai happens read ai p q true q true p false read happens without write happened rst p q values unrelated compiler way knowing ordering accesses loop hand compiler show p q related fact q true implies p must also true compiler know write happened rst code involving conditional branches major tool compiler determining ordering accesses logical implication facilitate use logical implication establish execution order representation memory reference must potentially p f figure 2 logical implication compiler determine ordering accesses array iloop execution predicate attached fact access figure 2 could classied readonly condition fpqg writefirst condition fpg readwrite otherwise definition 3 execution predicate booleanvalued ex pression attached representation memory reference species condition reference actually takes place execution predicate p denoted fpg 34 using summary sets store memory locations classify set memory locations according access type adding symbolic representation appropriate summary set definition 4 summary set symbolic description set memory locations chosen use access region descriptors ards described section 4 represent memory accesses within summary set represent memory accesses use writeorder summary scheme according table iii requires three summary sets dependence grain readonly ro readwrite rw writefirst wf 35 classification memory references memory location referred program must entered one summary sets process called classication program assumed series nested elementary contexts procedures programming language force structure program transformed form normalization process readonly readonly readwrite newwritefirst newwritefirst figure 3 intersection earlier readonly accesses later writefirst accesses result readwrite set simple statements statements loops call statements thus every point program enclosing context enclosed context contexts traversed execution order summary sets enclosing context built recursively calculating summary sets enclosed context distributing summary sets enclosing context determine memory locations common summary sets intersection operation illustrated figure 35 classication takes input current state three summary sets enclosing context ro wf rw three new summary sets last enclosed context processed ro n produces updated summary sets enclosing context sets enclosed context absorbed way maintains proper classication memory location example memory location ro enclosing context point wf rw newlycalculated enclosed context becomes rw updated enclosing context steps classication expressed set notation shown figure 4 351 program context classication simple statements classied obvious way according order reads writes memory statements within context classied ordinary way except ifcondition p applied execution predicate statements block p applied statements else block descriptors else blocks intersected execution predicates ored together produce result whole context classifying memory accesses loop twostep process first summary sets single iteration loop must collected scan loop body execution order contain symbolic form accesses possibly parameterized index loop next summary sets must expanded ro ro wf ro ro ron ro ro ro rw ro write first memory references prior code memory references new code result classifying new references000000000000111111111 000000000000 000000000000 000000000000 000000000000 000000000000 000000000000 000000000000 000000000000 000000000000 0000 0000 0000 0000 0000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 read read write figure 4 classication new summary sets ron wfn rwn existing summary sets ro wf rw pictorial example adding new summary sets existing summary sets loop index end process sets represent locations accessed entire execution loop expansion process illustrated following loop single iteration surrounding loop location ai classied writefirst ai expanded loop index representation a1100 results summary sets loops expanded similarly must use basic induction variable loop index represent number iterations unknown expansion process makes possible avoid traversing backedges loops classication classication call statement involves rst calculation access representation text call statement calculation summary sets procedure called matching formal actual parameters nally translating summary sets involved called context calling context described ards section 43 4 access region descriptor manipulate array access summaries dependence analysis needed notation could precisely represent collection memory accesses brie mentioned section 2 previous study 11 gave us clear picture strengths weaknesses existing notations also gave us requirements notation meet support ecient array access summarization complex array subscripts represented accurately particular nonane expressions handled timecritical loops real programs often contain array references nonane subscripts notation simplication operations dened complex accesses could changed simpler form facilitate fast accurate translation access summaries across procedure boundaries nontrivial array reshaping procedure boundary handled eciently accurately notation provide uniform means representing accesses memory regardless declared shape data structures source code meet requirements introduced new notation called access region descriptor detailed previous literature 11 ard derived linear memory access descriptor introduced 13 14 avoid repetition section brie discuss basics ard necessary describe dependence analysis technique section 5 41 representing array accesses loop nest array declared mdimensional array referenced program array name followed list subscripting expressions nested loop figure 5 figure 5 mdimensional array reference dloop nest implicit notation array subscripting function fm translates array reference set osets base address memory refers set loop indices surrounding nested loops refers set constants determined rules programming language nested loop executes loop index k moves set values subscripting function fm generates sequence osets base address call subscripting oset sequence isolated eect single loop index fm sequence osets always precisely represented terms starting value expression representing dierence two successive values total number values sequence example consider even nonane subscript expression real a0 subscripting oset sequence dierence two successive values easily expressed clear dierence dened expression added ith member sequence produce 1th member sequence n members subscripting oset sequence start 2 dierence successive members 2 42 components ard refer subscripting oset sequence generated array reference due single loop index dimension access call dimension ard definition 5 dimension ard representation subscripting oset sequence set memory references contains starting value called base oset dierence expression called stride number values sequence represented dimension index taking integer values 0 dimension index bound value notice access produced array reference nested loop many dimensions loops nest also dimension index dimension may thought normalized form actual loop index occuring program ard originally constructed compiler program text addition three expressions described ard dimension span expression maintained possible dimension span dened dierence osets last rst elements dimension span useful certain operations simplications ard instance detecting internal overlap described section 44 however accurate subscript expressions array access monotonic single base oset stored whole access example array access access pattern memory lmad may seen figure 6 ard array access figure 5 written series commaseparated strides 1 superscripts variable name series commaseparated spans 1 subscripts variable name base oset written right descriptor dimension index included written form lmad needed clarity case index dimensionbound written subscript appropriate stride 43 interprocedural translation ard useful property ard ease may translated across procedure boundaries translation array access information across procedure boundaries dicult declaration formal array parameter diers declaration corresponding actual parameter array access representations depend 3 14 26 ak26i1 j k1 10 3 end end end real a14 figure 6 memory access diagram array nested loop access region descriptor represents declared dimensionality array faced converting representation one dimensionality another array reshaping occurs always possible without introducing complicated mapping functions array reshaping problem table v indicates signicant array reshaping occurs many scientic applications published 11 table v gures entry indicate percentages calls reshaping various benchmark programs perfect spec nasa computed static examination programs mentioned trfd arc2d tfft2 flo52 turb3d ocean mdg bdna tomcatv swim refer memory access representation independent declared dimensionality array universal represen tation becomes procedure independent even language independent universal representation eliminates array reshaping problem need translated new form potentially dierent dimensionality moving dierent execution context ard example universal representation subroutine called reference base address formal array parameter set whatever address passed actual argument list memory accesses occur subroutine would represented calling routine ard form relative base address whenever desired translate ard formal argument callers context simply translate formal arguments variable name actual arguments name add base oset actual parameter ard formal parameter example actual argument fortran code indexed array call oset beginning array actual argument 2i suppose matching formal parameter subroutine x z lmad access z x z 10200 access z subroutine x translated calling routine lmad would represented terms variable follows 10200 results simply adding oset renaming z notice twodimensional access even though declared onedimensional 44 properties ards subsection brie describes several basic properties ards useful dependence analysis based access summary sets definition 6 given ard set stridespan pairs call sum spans rst k dimensions kdimensional width ard dened 4401 internal overlap ard process expanding ard loop cause overlap descriptor example following fortran doloop i110 j15 ai4j ard inner loop 1 1 ard expanded outer loop becomes 14 exhibits overlap due outer loop access due outer loop stride far enough get beyond array elements already touched inner loop property may determined noticing stride nth dimension greater dimensional width ard 441 zerospan dimensions dimension whose span zero adds data elements access pattern implies whenever dimension appears ard possibly manipulation ard may safely eliminated without changing access pattern represented likewise implies time new dimension may introduced desired stride zerospan without changing access pattern simplication operations exist eliminating dimensions within ard eliminating ards found covered ards creating single ard represents accesses several ards since operations needed exposition paper described reader referred 11 14 13 5 access region test section rst describe general dependence analysis method based intersecting ards general method detect data dependence two arbitrary sections code show simplication general method access region test works loop parallelization show multidimensional recursive intersection algorithm ards 51 general dependence testing summary sets given symbolic summary sets ro 1 wf 1 rw 1 discussed section 34 representing memory accesses earlier sequential execution program dependence grain sets ro 2 wf 2 rw 2 later grain discovered whether locations accessed grains nding intersection earlier later sets consulting table iv nonempty intersection represents dependence grains however dependences may removed compiler transformations intersections must done variable intersections empty variables crossiteration dependences exist two dependence grains following nonempty ro 1 ro 1 rw 2 represent dependences removed privatizing intersecting regions rw 1 rw 2 nonempty references involved either induction form reduction form dependence may removed induction reduction transformations discussed detail section 54 intersections wf 1 ro 2 wf 1 rw 2 rw 1 ro 2 nonempty represent nonremovable dependences 52 loop dependence testing art access region test art used within general framework memory classication analysis writeorder summarization means entire program traversed execution order using abstract interpretation summary sets computed nested contexts program stored ards ards used semantic elements abstract interpretion interpretation rules exactly rules described various program contexts section 351 whenever loops encountered art applied ards determine whether loops parallel parallelizable removing dependences compiler transformations stated section 32 dependence testing loop iterations special case general dependence testing described last section loopbased dependence testing considers loop iteration dependence grain meaning dependence grains summary sets expand summary sets loop index section 351 crossiteration dependence noticed three ways within one lmad two lmads one summary set two summary sets 521 overlap within single ard internal overlap due expansion loop index described section 44 overlap occurs indicates crossiteration dependence condition easily checked expansion agged ard operation required detect 522 intersection ards within summary set even though two lmads summary set intersect initially expansion loop index could cause intersect intersection would represent crossiteration dependence intersection within ro would input dependence summary set need checked internal intersections wf rw must done however figure 7 example two writes array rst assigned summary set overlap two writerst ards initially 0 base osets dierent intersection assumed overlap conservative assumption causes separately assigned wf set expansion creation dimension index 0 normalized ards become 1 intersect indicating dependence intersection would found attempting intersect ards within wf figure 7 example illustrating need internal intersection summary sets 523 intersection two summary sets three summary sets consider loop dependence testing instead six one dependence grain three intersections try instead eight required section 51 expansion loop index following intersections must done ro wf ro rw wf rw intersection pair sets ro wf rw involves least one read one write operation implying dependence 53 loopbased access region test algorithm loop l program summary sets ro wf rw art following expand ards summary sets loop index l check internal overlap due loop index l ard wf rw found within wf removed privatization found rw removed references involved either induction reduction form overlap ard noted overlap ag reset check nonempty intersection pair ards wf removed privatization rw possibly removed induction reduction possible pairs summary sets group ro wf rw check nonempty intersection two ards pair containing ards dierent sets intersection found noted dependence moved rw nonremovable dependences found loop may declared parallel wherever uncertainty occurs process demanddriven deeper analysis triggered attempt remove uncertainty runtime tests generated 54 detecting reduction induction patterns stated section 23 idiom recognition important parallelizing programs inductions reductions involve assignment linear recurrence structure forms dier slightly shown following represents integer variable r represents oating point induction oating point expression reduction patterns originally presents dependence compiler transformations 15 4 remove dependence three levels tests done within writeorder summary scheme structure used positively identify reductions inductions 5401 level 1 rst test linear recurrence structure assignment statement pattern found ard statement marked passing level 1 test plus operator type integer constant oating point expression stored ard marked idiom type possible induction integer variable expression integer constant otherwise marked possible reduction 5402 level 2 intersection ards particular variable within readwrite summary set part art described section 522 one marked passed level 1 ard rw variable pass level 1 idiom type operator fails level 2 ards variable either readonly writefirst ard possible reduction fails level 2 ard possible induction ards exist variable writefirst fails level 2 otherwise ard passes level 2 5403 level 3 pass level 3 ard marked passing level 2 must marked internal overlap due expansion loop index outer loop means dependence due access carried outer loop ard marked passed level 3 considered idiom stored type appropriate code generated threelevel process nd inductions reductions interproce durally interprocedural nature art 55 generality art access region test general conservative dependence test design discern three types dependence input ow memoryrelated cannot distinguish anti output depen dence purposes considered unimportant types dependence removed privatization transformations purposes general mca mechanism used formulate mechanism appropriate summary sets produce required information much data ow analysis formulated solve various data ow problems sections 31 32 showed two dierent formulations mca dependence analysis readonly summary scheme simply dependence test writeorder summary scheme provides enough information test dependence also remove dependences compiler transformations 56 loopcarried dependence handled art dependence within inner loop essentially ignored respect outer loop fact expansion loop index intersecting portions two ards represented single ard moved rw summary set intersecting portions counted crossiteration dependences loop reduced single ard longer found intersect outer loops intersections due outer loops solely due expansions outer loop indices process illustrated figure 8 ro j end end wf ro dependence ro wf 100502a 100502 expand expand expand 501 100503 loop intersection indicates independence ro rw wf figure 8 art handles loopcarried dependence 57 multidimensional recursive intersection algorithm intersecting two arbitrary ards complex probably tractable two ards compared strides call strideequivalent strides one subset strides call semistrideequivalent quite often true experiments similar enough make intersection algorithm tractable present algorithm intersect figure 9 input two ards properly nested sorted dimensions 0 k number dimension work 0 k outputlist ards returns ard list 0 ard rlist1 ard scalar add listard list ard rlist1 endif return ard list endif c periodic intersection left remove dimard right k 0 add listard list ard rlist1 r intersection right remove dimard left k add listard list ard rlist2 endif else intersection end remove dimard right k 0 add listard list ard rlist1 endif return ard list intersect remove dimard k new construct return new ard equivalent ard except without access dimension k new new base oset construct return new access dimension stride span add dimard dimnew new construct return new ard equivalent ard except new dimension dimnew new new base oset add listard list ard f add ard list ards ard list figure 9 algorithm nding intersection multidimensional ards clarity removal intersection two input ards use conservative direction ag use execution predicates shown although things added algorithm straightforward way algorithm accepts two strideequivalent ards two ards semistrideequivalent zerospan dimensions safely inserted ard fewer dimensions discussed section 441 make strideequivalent algorithm also passed conservative direction ag ag two possible values underestimation overestimation tells algorithm result imprecise overestimation result enlarged maximum value likewise underestimation causes result reduced minimum value two ards intersected strideequivalent result formed based conservative direction algorithm takes input two ards dimensions precisely sorted ard number dimension work ard left base oset less ard right algorithm compares overall extent dimension ard shown figure 10a extents overlap way safely report intersection empty overlap algorithm calls recursively specifying next inner dimension shown figure 10b intersection intersection figure 10 multidimensional recursive intersection algorithm considering whole extent two access patterns recursing inside consider next inner dimension b process continues either determined overlap occurs innermost dimension reached shown figure 11 make nal determination whether intersection two considering onedimensional accesses resulting ard intersection returned recursion returns dimension added resulting ard figure 11 multidimensional recursive intersection algorithm considering innermost dimension nding intersection simplicity description assumed two ards dimensions fully sorted dimension one ard corresponds dimension 1 1 6 experiments access region test advantage tests discussed section 1 three ways reducing dependence analysis intersection operation restrict art handling certain types subscripting expressions coupled subscripts problem range test nonane expressions problem tests use ard provides precise access summaries array subscripting expressions test implicitly interprocedural since ards may translated precisely across procedure boundaries separate value art value ard instructive consider question whether dependence tests might powerful art represented memory accesses ard notation answer question take example omega test mechanism omega test dened ane expressions user omega test must extract linear coecients loopvariant values loop indices etc plus provide set constraints loopvariants ards partially role constraints nonane expressions used way extract linear coecients nonane parts technique replacing nonane parts expression uninterpreted function symbols developed 17 general enough work situations even using ard omega test could handle nonane subscript expressions mechanism simply welldened expressions likewise range test use ard represent value ranges variables still would change basic mechanism makes singlesubscript test unable handle coupledsubscripts mechanism range test forces consider behavior subscript expression due single subscript time whereas art compares access patterns instead subscript expressions simple example figure 12 shows advantage comparing patterns shows two loop nests display identical access patterns yet dierent subscripting expressions top accesses determined independent range test bottom accesses cannot j1 j1 figure 12 range test determine accesses top loop inde pendent bottom loop art nd independent since deals access patterns instead subscript expressions figure 13 shows another example tfft2 benchmark code neither omega test range test nd independent real u1 x1 y1 i02m21 u1321m2 end real u1 x1 y1 l01 m12 end real u x i02ml1 k02l11 end end figure 13 simplied excerpt benchmark program tt2 art determine free dependences due apparent complexity nonane expressions involved yet art nd independent interprocedurally topmost loop due reliance simple intersection operation ability translate ards across procedure boundaries powerful ard simplication operations expose simple access patterns hidden inside complex subscript expressions continued develop art needed evaluate art real programs therefore implemented preliminary version art polaris 4 parallelizing compiler developed illinois experimented ten benchmark codes experiments observed art highly eective programs complex subscripting expressions ocean bdna tfft2 table vi shows summary experimental results obtained time prepared paper careful analytical study conrms art theoretically subsumes range test implies art parallelize loops range test even though experiment art failed parallelize loops flo52 arc2d due several implementation dependent problems reported 11 numbers loops additionally parallelized art small loops timecritical loops contain complex array subscripting expressions previous experiments reported 13 also showed art applied hand increased parallel speedup tfft2 factor 74 cray t3d 64 processors expected table vi shows neither art omega test range test make dierence performance codes simple array subscripting expressions tomcatv arc2d swim table vi comparison number loops parallelized current version art techniques rst line shows number loops art could parallelize range test could second shows number loops range test could parallelize omega test could third shows number loops omega test could parallelize range test could loops codes parallelized identically tests data second third lines based previous work polaris tfft2 trfd mdg flo52 hydro2d bdna arc2d tomcatv swim ocean previous techniques based access summaries show experimental results real programs papers 1 18 thus possible us determine eective techniques would actual programs 7 conclusion future work paper presents technique unifying interprocedural dependence analysis privatization idiom recognition single frame work technique eliminates limitations encumber loopbased linear systemsolving data dependence paradigm expands notion dependence test include way classifying dependences found compiler eliminate using code transformations framework built general scheme classifying memory locations memory classication analysis based order type accesses framework reformulated used many purposes readonly writeorder summarization schemes presented many schemes possible variety purposes multidimensional recursive intersection algorithm ards introduced allows us calculate precise intersection two strideequivalent ards algorithm forms core dependence analysis calculation heuristics added algorithm handle cases ards strideequivalent precise intersection algorithm becomes precise data dependence analysis becomes believe exibility generality aorded reformulation data dependence make useful many purposes within compiler future intend use mca framework analyses automatically extend interprocedu rally addition intend formalize methods analysis terms abstract semantic elements rules within abstract interpretation framework r technique summarizing data access use parallelism enhancing transformations dependence analysis symbolic analysis techniques e parallel programming polaris semantic foundations program analysis abstract interpretation uni interprocedural array region analyses automatic parallelization perfect benchmarks implementation interprocedural bounded regular section analysis automatic parallelization distributed memory machines based access region analysis induction variable substitution reduction recognition polaris parallelizing compiler practical algorithm exact array dependence analysis nonlinear array dependence analysis exact side e gated ssabased demanddriven symbolic analysis parallelizing compilers high performance compilers parallel computing power test data dependence tr interprocedural dependence analysis parallelization technique summarizing data access use parallelism enhancing transformations practical dependence testing practical algorithm exact array dependence analysis exact side effects interprocedural dependence analysis nonlinear array dependence analysis gated ssabased demanddriven symbolic analysis parallelizing compilers automatic parallelization perfect benchmarksmyampersand174 simplification array access patterns compiler optimizations nonlinear symbolic data dependence testing abstract interpretation dependence analysis parallel programming polaris efficient data dependence analysis parallelizing compilers implementation interprocedural bounded regular section analysis power test data dependence interprocedural array region analyses symbolic analysis techniques effective automatic parallelization interprocedural parallelization using memory classification analysis ctr paek navarro e zapata j hoeflinger padua advanced compiler framework noncachecoherent multiprocessors ieee transactions parallel distributed systems v13 n3 p241259 march 2002 thi viet nga nguyen franois irigoin efficient effective array bound checking acm transactions programming languages systems toplas v27 n3 p527570 may 2005
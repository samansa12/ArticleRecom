eliminating counterevidence applications accountable certificate management paper presents method increase accountability certificate management making intractable certification authority ca create contradictory statements validity certificate core method new primitive undeniable attester allows someone commit set bitstrings publishing short digest give attestations x member attestation verified obtaining authenticated way published digest applying verification algorithm triple bitstring attestation digest important feature primitive intractability creating two contradictory proofs candidate element x digest give efficient construction undeniable attesters based authenticated search trees show construction also applies sets structured elements also show undeniable attesters exist iff collisionresistant hash functions exist b introduction concept publickey cryptography created effort solve cryptographic management problem dh76 giving answer many difficult problems publickey cryptography also raised several surprisingly one main problematic areas solved publickey cryptography successfully applied practice still key management huge preliminary version paper bll00 appeared acm ccs 2000 conference current version final submission journal computer security tallinn technical universityuniversity tartucybernetica akadeemia tee 21 12618 tallinn estonia ahtobuldascyberee z universit des saarlandes fb 14 informatik im stadtwald bau 45 postfach 15 11 50 66041 saarbr ucken germany laudcsunisbde x helsinki university technology laboratory theoretical computer science department computer science engineering fin02015 hut espoo finland helgertcshutfi body research key management methods since koh78 key management involves still considerably trust toward third parties rest cryptography say certificate management system accountable forgeries third parties explicitly proven false accusations explicitly disproven efficient accountable identitybased certificate management necessary par ticular support authenticity digital documents long life time body supporting methods longterm authenticity developed area commonly known digital timestamping hs91 recent work timestamping also shown build efficient yet accountable timestamping systems bllv98 lip99 bls00 minimal trust third parties however one complement techniques accountable timestamping methods areas applied cryptography support longterm authenticity non repudiation one areas accountable efficient certificate management unfor tunately cryptographic literature briefly treated question achieve latter cl96 first present informal motivation definition accountable certificate man agement every validity change certificate accompanied transferable attestation ascertaining act short digest current state database valid certificates periodically published section 2 argue informally certificate management system accountable intractable anybody create pair contradictory attestations certificate would accepted valid depending certificate possession verifier intractability assumption certificate management system several desirable properties important property physical visits certification authority ca audited every subsequent dispute court solved present evidence moreover one verify certificate validity moment based short digest certificate database short certificatespecific attestation certificate rest paper focused assumption section 3 give formal definition new primitive called undeniable attester informally attester triple p dv algorithms proving algorithm p given candidate string x set outputs attestation certifying whether x 2 digest algorithm given set outputs short digest verification algorithm v given candidate element x digest attestation p v accepts rejects input x p depending whether x belongs set digest p contains additional information status x 2 call attester undeniable intractable generate digest element x two attestations p p v x p accepts v x p rejects context certificate management database identity certificate serial numbers section 4 survey attesters whose subsystems considered previously certificate management publickey infrastructure particular review attesters based certificate revocation lists hash trees mer80 certificate revocation trees koc98 nn00 rsa accumulators bdm93 bp97 however since mentioned systems designed accountability mind implicit trust assumptions result conclude previously known undeniable attester trivial one similar efficiency certificate revocation lists attestation lengths jsj log jsj good example attester undeniable sorted hash tree attester defined section 44 sorted hash tree attesters based efficient construction similar certificate revocation trees show section 44 sorted hash tree attesters undeniable therefore sorted hash tree attesterbased certificate management system makes possible ca cheat clients section 5 propose simple efficient authenticated search treebased construction undeniable attesters call authenticated search tree attester key difference sorted hash tree attesters proposed construction authenticated search tree attesters assign every internal node v search tree hash value sv taken labels vs children search key v sorted hash tree attesters sv authenticate search key v moreover authenticated search tree attesters several aspects intuitive sorted hash tree attesters directly based search trees generally understood computer science allow us carry cryptography research done area algorithms data structures knu98 proposed undeniable attester might surprisingly wide applications different security applications certificate management defining new attester prove undeniable new cryptographic primitive good know relates previously known prim itives proof undeniable attesters exist collisionresistant hash functions exist presented section 5 show section 54 methods extended multifield records first think every x 2 composed two parts unique key body searching performed looking key authenticated search tree attester modified enable detecting case key unique extensions possible extensions provide also better answer natural question exactly candidate string x case certificate management purposefully yet specified x could certificate serial number also hash whole certificate whatever relevant practical applications however best solution might let unique key correspond serial number body correspond hash whole certificate section 6 provide efficiency analysis authenticated search tree attester show attestations authenticated search tree compressed ideal conditions factor 2 makes authenticated search tree attester almost space efficient sorted hash tree attester method straight forward authors unaware previous constructions use technique compress search trees moreover unusual apply standard compression methods make cryptographic primitives space efficient attestation compressing method given section 6 might independent interest terminology intentionally chosen use slightly nonstandard selfconsistent terminology particular tried avoid overloading already notoriously overloaded terms certificate proof relatives introducing term attestation use concrete term certificate management instead pki certificate management denotes usually process whereby certificates managed used pki refers entire framework established certificate man agement motivations research motivated observation longterm authenticity nonrepudiation digital documents new methods necessary verifying whether identity certificates bindings person signature key valid moment time since many digitally signed documents eg loan agreements may important legal value decades would desirable ensure validity information certificates cannot forged anybody including authorities aim construction accountable certificate management system forgeries third parties explicitly proven false accusations explicitly disproven bls00 precisely would like part certificate management physical visit person authority clearly cannot mathematically modeled also stage system needs noncryptographic solution ie involving physical presence clientchosen notary trust problems visits correct system need auditing anywhere else partic ular clients able discover ca maliciously issued new invalid certificates removed valid certificates still valid longterm certificate validity partially ensured methods timestamping hs91 bllv98 absence proof certificate issued implicitly counted proof nonexistence however assumption clearly undesirable many situations would like explicit positive attestations stating valid certificates valid also explicit negative attestations stating nonvalid certificates valid way disputes regarding validity certificate could solved based present evidence positive negative attestation given intractable anybody create pair contradictory attestations work setting camaintains dynamic database valid certificates see riv98 ggm00 argumentation database valid certificates better database revoked certificates case database revoked certificates would add unnecessary complexities system presence central authority lessens communication complexity scheme simplifies tracking origins frauds model also includes publication authority bls00 possibly huge number clients assume every client receives positive resp negative attestation certificate x belongs resp belong database valid certifi cates assumption restricting since sort attestationor receiptis returned client ca every certificate management system sys tem clients interest store attestation later explicitly prove disprove validity certificate time additionally everyone make membership queries type x 2 ca returns attes tation clients want later use attestation p x 2 x 62 evidence court obtain ca suitable timeframe similar done timestamping bllv98 lip99 digest database denoted ds published publication authority authenticated widely available medium using accountable publishing protocols bls00 motivations behind timestamping hs91 bllv98 bls00 first without authenticated information database ca easily create contradictory attestations second longterm authenticity depend security private keys hs91 publishing digest natural widely accepted solution digital timestamping achieve longterm authenticity third nobody forced store old versions dynamic database system still accountable verifier anything element short attestation short digest database similar situation timestamping clients verify time stamp given time stamp equivalent attestation round stamp equivalent digest candidate element hs91 bllv98 model accountable certificate management incorporates least three different algorithms motivated define new primitive attester triple algorithms proving algorithm p given candidate string x set outputs attestation digest algorithm given set outputs short digest database finally verification algorithm v takes input candidate element x digest attestation p accepts rejects depending whether x belongs set described model ca cannot cheat client assume denial service attacks ca ca return attestation client prevented example letting clientchosen notary participate handing attestation client positive resp negative attestation certificate belonged resp belong database valid certificates time ca means generate contradictory attestation claiming certificate resp database time assuming ca able break underlying cryptographic primitives formally call attester undeniable intractable generate set element x two attestations p p v x ds p accepts v x ds p rejects longterm authenticity undeniability crucialeg ca issued concrete certificate might gone bankrupt long verification act impossible sue cheating moreover client accidentally deleted attestation least sure nobody else sue based contradictory attestation properties significantly increase trustworthiness cas application court relevance undeniable attestations probably best exemplified next application digital signature law passed country becomes natural expect digital signatures would considered legally valid handwritten ones particular one able solve legal disputes based validity particular signature particular document well known one needs certificate management order determine validity digital signature however one often overlooks real process court person presents judge piece evidence case signed document together certificate judge cannot take action based evidence call attestation alone possible somebody else create counterevidence call contradictory attestation example certificate revocation list seen counterevidence currently almost always possible least ca create counterevi dence therefore courts decisions often base heuristics involve trust authorities eyewitnesses human beings case digital signatures definition eyewitnesses unclear one might want trust authorities possible authorities might corrupted malicious client could also claim honest authority guilty cases judge cannot take action since authority might might guilty intractable create counterevidence even authorities court always authoratively decide case based evidence judge trust anybody everybody also check judges actions correct latter means one cannot question ambiguous actions court related digital signatures hence reason appeal higher court actions lower court provably wrong separation duties functions ca divided least two authorities offline ca online validation authority done also many certificate management systems cl96 however distinction ca validation authority important practice subject paper since methods help prevent forgeries even case one possibly misbehaving party ca control whole system also prevents forgeries several third parties simplicity paper stress separation authorities reason elaborate accountable publication protocols rather refer reader bls00 necessary information 3 formal definitions 31 preliminaries 1g usually k denotes set kbit words denotes string k k denotes security parameter relative security various schemes measured assume nil special encoded differently x 2 let ea class probabilistic algorithms execution time polynomial length first input family negligible 0 exists notation x means x assigned according probability space may output space probabilistic algorithm collisionresistant hash function crhf h index set pair g h 1 g 2 ea generation algorithm g1 k 2 index 2 hi polynomial p pk k 3 algorithms 2 ea probability family crhh negligible k note index necessary one requires h collisionresistant otherwise one assume ji 32 definition attester already given informal definitions attesters next present full malism followed discussion attester index set polynomial f fk k 1 generating algorithm g 2 ea takes input security parameter 1 k outputs index 2 k 2 proving algorithm p 2 ea takes input index element x 2 k set k jsj fk outputs attestation p x 3 digest algorithm 2 ea takes input index set k jsj fk outputs digest 4 verification algorithm v 2 ea takes input index candidate element digest attestation p outputs require 62 k 6 k jsj fk x 62 k p v x practice one set otherwise k jsj fk x 2 k outputs accept x 2 reject x 62 attester let 2 ea let x attester collisionresistant prover resp collisionresistant disprover 8a 2 negligible collisionresistant attester 2 ea crpa crda negligible undeniable 2 ea una negligible 33 discussion note definition attesters role generating function indices definition hash functions namely necessary unless discuss strong security properties like collisionresistance undeniability otherwise assume ji informal treatment one omit however constructions undeniable attesters assume used hash function collisionresistant automatically introduces need index set formal treatment important understand seemingly subtle crucial applications difference collisionresistant attesters undeniable attesters collisionresistant attesters assume verifier access correctly computed value practice means either rely trusted third party provide correct access possibilities undesirable many security applications including accountable certificate management undeniable attesters stay secure even presence adversary forges digest therefore potentially provide much higher level confidence system practice organized certain data structure many cases attester security addon data structure see sections 44 43 attesters based corresponding types trees therefore often use terminology data structures context attesters example one would like attester succinct attestations digests also fast averagecase update time data structure informally say attester dynamic averagecase time per insertion deletion elements corresponding data structure ojij log jsj 2 say attester succinct 2 log jsj note since attester jd 4 known constructions next give short survey attesters based previously proposed ideas table 1 summarizes properties attesters described section together authenticated search tree attesters described later section 5 note hash tree attester rsa attester succinct since negative attestations length jsj log jsj however one easily modify attesters succinct primitive type name digest positive attestation negative attestation length list x41 k n log n n log n hash tree cra sorted hash tree ua authenticated search tree table 1 known succinct attesters ie security given succinct versions see section 33 example list attester undeniable attester succinct attester log n security parameter defining equal fixed constant x 6 modified hash tree attester modified rsa attester succinct collisionresistant provers similar trick also work list attester resulting succinct construct attester without satisfying stronger security requirements emphasized section 2 accountable certificate management interested undeniable attesters following briefly explain already known attesters fail satisfy requirements main result paper provably secure authenticated search tree attester described section 5 list attester trivial attester x set attestation p x ds equal short kbit hash hs h collisionresistant hash function remember k security parameter verification algorithm v accepts resulting construction clearly undeniable unfortunately list attester becomes utterly inefficient number simultaneously valid certificates grows since storage requirements verification time least linear jsj one possibilities decrease verification time assume ca sorted database although clients perform binary search database attester cease undeniable since ca may leave database unsorted method would also reduce storage requirements 42 rsa attester rsa attester natural way built upon rsa accumulator bdm93 bp97 positive attestations form therefore attestation length k k security parameter digest form therefore also length however first pointed nyberg nyb94 nyb96 length attestations reduced introducing builtin trapdoor information known coalition participants therefore trusted best known method san99 making rsa accumulator trapdoorless introduces attestation lengths order log jsj trapdoorless rsa accumulator longer attestations sorted hash tree attester described moreover negative attestations equal 43 hash tree attester hash trees mer80 widely used authenticate element set member full generality hash tree labeled tree leaves labeled different values nodes labeled hash children labels fixed collisionresistant hash function used hash tree attester positive attestation consists minimal amount data necessary verify hash path leaf labeled x root assume hash trees used depth logarithmic number nodes result positive attestations length k log jsj k output length used collisionresistant hash function digest ds length k equal label root hand negative attestations must include every element hence length kjsj 44 sorted hash tree attester similarly case list attester hash tree attester made efficient ca sorts leaves idea recently proposed koc98 nn00 assume values stored leaves sorted left right resulting sorted hash tree attester negative positive attestations length k log jsj therefore succinct however also case sorted list attester proposed solution hides implicit assumption ca dutifully sorts leaves since observed weakness sorted hash trees crucial motivation subsequent work next give detailed definition sorted hash tree attesters together full explanation weak points 441 construction next attester g based fixed crhf h role generating function g attester choose concrete hash function h family according function gh therefore sake simplicity describe attesters fixed 2 k fixed hash function latter practice instantiated sha1 nis94 strong keyed hash function let f priori fixed polynomial depend k next suppose nonempty set kbit integers sj sj 1 1 j n let directed binary tree n leaves figure 1 toy example sorted hash tree attester dashed lines present improved sorted hash tree attester described section 442 values sv given unimproved construction ease illustration chosen vertices elements z although concrete values vs important practice jth leftmost leaf labeled sj figure 1 nonleaf vertex labeled auxiliary hash value v l v r denotes left right child v digest equal label root vertex v error leaves unsorted jsj fk leaf label sv 62 k 0 corresponding left 1 corresponding right direction verification algorithm v x p returns error p form otherwise v computes dm assigning 0 x recursively every j 0 verification returns accept error otherwise x 2 proving algorithm p returns p v x p accepts proving x 62 equivalent finding quadruple correspond two neighboring leaves tree x smaller least element x 1 define p x equal p situation x bigger greatest element dealt analogously looking tree depicted figure 1 p 35 hand figure 2 toy example improperly created sorted hash tree attester 442 efficiency improvements one shorten negative attestations inserting additional arcs underlying tree follows slightly different methods also proposed koc98 parents leaf v 6 1 left neighbor leaf w different add arc w vs parent figure 1 build attester upon resulting graph modifying algorithms p v account new arcs let negative attestation x equal positive attestation smallest x 0 x set x 0 exists x otherwise result negative positive attestations length 443 sorted hash tree attester undeniable sorted hash tree attester succinct dynamic built upon dynamic trees collisionresistant however undeniable show example depicted figure 2 positive attestations 10 40 20 respectively also negative attestation 20 therefore verifier given digest s7 root hash tree accepts rejects 20 depending attestation earlier submitted also true improved sorted hash tree attesters unsorting attack possible since efficient way verifier check whether ca dutifully sorted database obvious possibility prevent attack without involving another trusted third party send entire database total size jsj log jsj verifier verifier would recompute tree verifying database sorted order results digest obtained beforehand reliable source however solution clearly impractical jsj large since verifier jsj 1 hash computations per every verifi cation moreover solution impossible elements database inaccessible lessen storage requirements old versions certificate database stored intuitively need send entire database caused fact candidate string x label leaf therefore negative attestation incorporate positive attestations understand think searching unsorted database showing x belongs accelerated presenting index j attestation xs occurrence followed checking jth element equal x however x belong database one verify j jth element equal x therefore corrupted ca may easily build unsorted hash tree without detected anyone possess copy whole 5 authenticated search tree attester next give construction call authenticated search trees show resulting attester authenticated search tree attester undeniable attester finish section discussions first let us remember directed binary tree search tree knu98 section 622 every node v 2 unique search key kv associated w left resp right child v kw kv resp kw kv 51 construction let f priori fixed polynomial give section 44 construction fixed k fixed 2 k let k nonempty set let binary search tree jsj vertices vertex v labeled pair kv sv elements kv belong set kv 1 moreover tree together keys kv search tree value sv equal equal label vs left resp right child corresponding child exists nil otherwise example v leaf digest ds defined sv v root vertex error proper search tree particular jsj fk leaf v sv 62 k x 2 resp x 62 attestation p x defined least amount data necessary verify v given proper search tree intuitively following attestation x 2 k equivalent searching x search tree usage hash functions vertices guarantees ca work tree query moreover verification algorithm v returns error tree found proper search tree rest subsection gives technical definition authenticated search tree attesters including necessary local verifications search tree necessary perform verifications authenticated search tree attester undeniable therefore avoid fraud let elements k 0 verification algorithm v x p returns error 1 h l 6 nil x k 0 2 h r 6 nil x k 0 naturally v also returns error attestation p specified form otherwise v figure 3 toy example authenticated search tree note vertices enumerated arbitrarily ease illustration chosen vertices elements z although concrete values vs important practice assigns 0 hh v outputs error otherwise v returns accept reject depending whether k x 2 algorithm p x returns list p v x ds p accepts see p easy find x 62 p x finds 1 element x 0 x 0 greatest element x 0 x predecessor x x exists smallest element otherwise 2 element x 00 x 00 smallest element x 00 x successor x x exists greatest element otherwise construction search trees either x v 00 root path starting node sorting key x 0 vice versa otherwise p x returns returns list p v x 0 first case x second case clearly v x ds p accepts x 2 note verification returns error tree fragment reconstructed p cannot part search tree toy example depicted figure 3 attestation contains predecessor successor 41 40 42 resp 42 42 42 resp 43 42 56 resp 52 security theorem 1 authenticated search tree attester undeniable h collisionresistant hash function family reduction security preserving next meaning let 2 ea algorithm st una exists adversary proof adversary defined follows given index security parameter performs query a1 k probability query outputs tuple x p p v x reject therefore analogously overline variables j computed verification p adversary processes p p parallel st1 therefore using st2 get remember also nil 62 k next k 6 k found collision h let us assume without loss generality x k found collision h therefore adversary finds collision h probability note works time log jsj working time ut new cryptographic primitiveand undeniable attester new primitiveit good know relates previously known primitives next results establish relationships collisionresistant attesters undeniable testers crhfs undeniable attester collisionresistant attester proof let machine either crpa next construct efficient machine una returns x p p otherwise queries algorithms g1 k constant time probability k either x 62 k reject therefore una note construction section 44 showed collisionresistant attester undeniable hence opposite lemma true theorem 2 undeniable attesters exist crhfs exist proof let undeniable attester lemma 1 also collisionresistant next show collisionresistant g crhf 2 k ie subsets k let 2 ea adversary let next machine efficiently find element x wlog 1 ns 2 let p p definition attesters thus found tuple x accept contradiction thus crhf sets ie 2 jij alternatively concatenated strings s1s2 sjsj finish proof constructing crhf input domain follows let pk arbitrary string pk sufficient look strings length dividing k log 2 pk due constructions presented dam89 mer89 denotes kbit binary fixed representation 2 n clearly crhf domain 2 k h crhf domain opposite proven theorem 1 ut 53 discussion construction section 51 generalizes case underlying tree multiway search tree knu98 section 624 however wish attestations length ok log jsj restricted trees number children every node upperbounded constant depend k result cannot base construction exponential search trees related data structures lately extensively used sublogarithmic search algorithms bf99 authenticated search trees made dynamic nn00 requiring ca stores whole hash tree database update updates necessary hash values tree including value ds updating done time ok log jsj using appropriate dynamic search trees say avl 23 trees also skip lists since construction slight reformulation usually meant search trees reasonable data structures searching seen search trees one choose data structure convenient concrete application many possible constructions undeniable attesters example one could add number arcs binary tree follows nonleaf node v add arc already exist left childs rightmost descendant leaf v emphasize main difference described constructions collisionresistant undeniable attesters first case choice left right subtree done explicitly given bit b latter case instead explicit search key kv based kv verifier additionally check element returned query correct location tree 54 extensions multifield records definition attesters construction authenticated search trees given case database consists indivisible records x however quite often one works situation x composed several fields example many cases first field keyx acts unique key entire record case need set algorithms allowing database maintainer commit value way clients perform query response either bodyx database contains unique record key keyx undened none intractable database maintainer give different answers queries key keyx thus response ca contain kind proof authenticated search tree used construct necessary primitive database organized authenticated search tree algorithm left un changed exists keyxjjy 2 let x 0 predecessor keyxjjy x 00 successor keyxjjy otherwise let x 0 predecessor x 00 successor keyxjj0 attestation p keyx equal p welldefined presentation given negative attestation verification procedure additionally checks elements x tree returns error case given positive attestation verification algorithm additionally checks elements tree keyxjjy 2 cases nonexistence x efficiently verified positions vertices labeled x 0 keyxjjy x 00 search tree determined attestation generally one could use authenticated kd trees perform multidimensional queries authenticated kd trees natural extensions authenticated search trees bentleys kd trees ben75 ben79 handling databases k fields shown bentley kd trees balanced depth log jsj case takes ojsj 1 tk steps find records fields equal specified values steps find elements tdimensional subspace q elements see knu98 section 65 information context certificate management one could take example keyx equal unique certificate serial number bodyx would hash whole certificate 6 efficiency 61 averagecase attestation length fixed size authenticated search trees result shortest worst case attestation length underlying tree complete binary tree case additionally assume search keys length kin practice store leaves hash values certificates generally longer k bitsthen worst case attestation length k simple calculation shows attestations p x total 1 makes averagecase attestation length equal twice much attestation length complete binary tree based improved sorted hash tree attester also general upon types trees construction average twice longer attestations optimal construction collisionresistant attesters presented section 442 using dynamic avl trees knu98 section 623 worst case certificate length dynamic authenticated search tree attester therefore 288 k log n 62 attestation compression next describe method compressing attestations often compression algorithms seen consisting two standard parts modeling coding bcw90 adaptive modeling algorithm estimates source part data sequence seen far outputting probability distribution new symbol encoder say arithmetic encoder uses distribution encode new symbol using bits possible apply general approach authenticated search trees first let fixed search tree let k security parameter remind elements k bits long modeling assign every node v recursively range previously let min 0 least let maxs greatest element v root vertex let v arbitrary vertex left child v l existing v assign range v l 1 analogously right child v r existing v assign range v r every root path seen data sequence node v sequence adaptive modeling algorithm returns uniform distribution v u v encoder encoder encodes value kv v binary number k c v using dlog 2 u v v e bits compressed attestation p c x equal uncompressed attestation p x search keys kv replaced corresponding compressed keys k c v additionally assume new digest c equal triple ds min verification still needs uncompressed attestation easily computed p c x surprisingly fact intermediate values kv unambiguously reconstructed p c x crucial undeniability guided us choice encoder efficient encoders aware guarantee unambiguous reconstruction intermediate values especially since verifier previous knowledge tree assuming complete binary tree uncompressed attestations length height compressed attestations never longer kn n worst case obtained 2g count short additional data necessary encode lengths kvs one could use example elias codes eli75 latter provable gap worst case length compressed uncompressed attestations achieved thanks implicit structure hidden ordered data however value kn n 2 n unexpected quantification amount structure hand attestations never shorten factor greater two therefore authenticated search tree attester longer attestations sorted hash tree one however factor arbitrarily close 2 k n example let us look figure 3 root path root leaf label nodes search keys kv 1 computing ranges find v 1 therefore previously denote nbit binary encoding hmin k c jp c 42 compression gain 1754 95 unrealistic example due maxs min remember elements collisionresistant hashes certificates hash function modeled random function maxs min holds negligible probability shows compression method result quite big savings already small ns real life situations example database size might typical future certificate management systems middlesized countries depicted table 2 appropriate 63 optimality questions classical predecessor problem requires one maintain set queries form j element element method attestation length bits collisionresistant attesters sorted hash tree kn undeniable attesters table 2 comparison worstcase attestation lengths collisionresistant undeniable attesters bytes sorted order may answered efficiently membership problem requires question j element may answered efficiently exist extremely efficient dynamic attesters one require collisionresistant one hand let arbitrary attester f works worstcase time fjij straightforwardly exists search algorithm working time solves membership problem hand according results dkm 94 search algorithms solving membership problem exists dynamic attester k every x 2 define x 2 fix empty string however sorted hash trees authenticated search trees solve membership also predecessor problem since attestation p x always contains predecessor x exists smallest element interesting open problem whether really necessary conclusions approach certificate management paper straightforward first went back source case legal system precisely court identified certificate management necessary minimize number frauds case achieved making infeasible create coun terevidences gave rigorous definition necessary cryptographic primitives undeniable attesters described analyzed efficient undeniable attester authenticated search tree attester showed latter almost efficient less secure sorted hash tree attesters using simple novel compression technique resulting certificate management system many desirable properties accountable since disputes solved present undeniable evidence means particular forgeries third parties explicitly proven false accusations explicitly disproven efficient since certificate validity verified given certificate short digest certificate database short attestation apart model accountable certificate management system second main result paper construction undeniable attesters undeniable attesters may become useful security primitive since make possible anyone perform securely membership predecessor queries without relying trusted third parties requiring access whole database stress current paper provides model certificate management complete system work needed making certificate management really accountable precisely system guarantees intractable create certificate database x 2 resp x 62 ca create attestation certifying x 62 resp x 2 practice dynamic may remove valid certificates insert invalid certificates malpractice detected example interested parties ask attestations x 2 every time updated one possibility would introduce another trusted party set volunteers would compare changes subsequent versions official documentation provided ca notaries physical visits clients however would desirable find efficient protocols purpose see sar00 preliminary analysis work strict optimality constructions left open question example since easier solve membership problem dkm predecessor problem bf99 would interesting know whether succinct undeniable attesters built upon search algorithms solving membership problem elaboration exact protocols duties different participants accountable certificate management utmost importance finally benefits would gained using authenticated search trees instead sorted hash trees areas data security use example results preliminary version paper bll00 already used build secure key archival service mb02 acknowledgments authors partially supported estonian science foundation grant 3742 first author partially supported estonian science foundation grant 4760 preliminary version paper published bll00 would like thank andris ambainis carl ellison kobbi nissim berry schoenmakers stuart stubblebine anonymous referees useful comments helped improve paper r text compression multidimensional binary search trees used associative searching multidimensional binary search trees database applications optimal bounds predecessor prob lem accountable certificate management using undeniable attestations optimally efficient accountable timestamping niko bari certification scheme electronic commerce design principle hash functions new directions cryptography friedhelm meyer auf der heide universal codeword sets representations inte gers hideki imai yuliang zheng timestamp digital document art computer programming certificate revocation validation toward practical publickey cryptosystem secure efficient timestamping systems enabling archival storage signed documents protocols public key cryptosystems one way hash functions des certificate revocation certificate date commutativity cryptography fast accumulated hashing eliminate revocation lists efficient accumulators without trapdoor analysis application accountable certificate man agement tr text compression design principle hash functions one way hash functions des dynamic perfect hashing oneway accumulators art computer programming volume 3 optimal bounds predecessor problem accountable certificate management using undeniable attestations multidimensional binary search trees used associative searching enabling archival storage signed documents efficient accumulators without trapdoor extended abstracts timestamping binary linking schemes certification scheme electronic commerce eliminate certificate revocations lists certificate revocation validation fast accumulated hashing efficient fresh cerification optimally efficient accountable timestamping ctr glen nuckolls chip martel stuart stubblebine certifying data multiple sources extended abstract proceedings 4th acm conference electronic commerce june 0912 2003 san diego ca usa peeter laud tarmo uustalu varmo vene type systems equivalent dataflow analyses imperative languages theoretical computer science v364 n3 p292310 8 november 2006 petros maniatis mary baker secure history preservation timeline entanglement proceedings 11th usenix security symposium p297312 august 0509 2002
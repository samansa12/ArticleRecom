optimization parallel execution multijoin queries abstractin paper study subject exploiting interoperator parallelism optimize execution multijoin queries specifically focus two major issues 1 scheduling execution sequence multiple joins within query 2 determining number processors allocated execution join operation obtained 1 first issue propose evaluate simulation several methods determine general join sequences bushy trees despite simplicity heuristics proposed lead general join sequences significantly outperform optimal sequential join sequence quality join sequences obtained proposed heuristics shown fairly close optimal one second issue shown processor allocation exploiting interoperator parallelism subject constraintssuch execution dependency system fragmentationthan study intraoperator parallelism single join concept synchronous execution time proposed alleviate constraints several heuristics deal processor allocation categorized bottomup topdown approaches derived evaluated simulation relationship issues 1 2 explored among schemes evaluated twostep approach proposed first applies join sequence heuristic build bushy tree single processor system light concept synchronous execution time allocates processors execute join bushy tree topdown manner emerges best solution minimize query execution time b introduction growing interest applying general purpose parallel machines database applications 7 8 12 19 34 43 50 several research systems developed explore trend including gamma 16 xprs 49 dbs3 4 grace 31 bubba 6 relational databases certain natural affinity parallelism relational operations set oriented provides query optimizer lots flexibility selecting parallelizable access path relational database systems joins expensive operations execute especially increases database size query complexity 11 27 30 39 53 future database manage ment parallelism recognized solution efficient execution multijoin queries 1 17 18 25 36 42 52 54 55 pointed 46 methods exploit parallelism execution database operations multiprocessor system divided three categories first parallelism occur operator within query way several processors work parallel single database operation form parallelism termed intraoperator parallelism studied extensively various solutions exploiting intraoperator parallelism multiprocessor database systems reported literature several algorithms proposed parallel execution twoway joins multiprocessor systems 15 38 44 45 researchers concerned multiprocessors particular architectures rings hypercubes 3 40 effect data skew performance parallel joins also analyzed 14 32 51 second form parallelism termed interoperator parallelism meaning several operators within query executed parallel third parallelism achieved executing several queries simultaneously within multiprocessor system termed interquery parallelism 48 seen exploit third form parallelism one resort results derived interoperator parallelism within query past years light shed issue 13 21 22 37 42 46 effort toward trend objective paper study improve execution multijoin queries devise efficient schemes exploit interoperator parallelism minimize query execution time multiprocessorbased database system 1 note different join execution sequences query result different execution costs 47 also execution time join multiprocessor system strongly depends number 1 execution time query paper similar related work means response time complete query rather total execution time processors r 5 rr 4 rr 2 rrrr b figure 1 illustration different join sequences processors allotted execution join 32 instance 40 second execution time join 4 processors may increase 60 seconds 2 processors used thus subject exploiting interoperator parallelism execution multijoin query comprises two major issues join sequence scheduling query plan generation ie scheduling execution sequence joins query ii processor allocation ie determining number processors join obtained execution time required query minimized clearly join method affects optimization procedure exploit parallelism hash joins opportunity using pipelining improve performance 15 21 whereas opportunity available join method like sortmerge join employed note pipelining causes effects join sequence scheduling processor allocation entangled resulting cost model join criteria processor allocation presence pipelining thus intrinsically different developed without using pipelining result join methods without pipelining dealt separately best optimization results paper shall focus join methods without pipelining sortmerge join fact prevalent join method existing database softwares develop specific solution procedure readers interested optimization pipelining multiple joins calls different procedure due different problem formulation referred 9 26 35 first issue join sequence scheduling develop evaluate simulation several heuristics determine join sequence multijoin query focus minimizing total amount work required 2 specifically investigate two sorts join sequences namely sequential join sequences general join sequences join sequence resulting relation intermediate join used next join termed sequential join sequence example sequential join sequence found figure 1a every nonleaf node internal node represents resulting relation joining child nodes join sequence resulting relation join required used next join termed general join sequence example sequence joins specified join sequence tree figure 1b general join sequence execution tree general join sequence called bushy tree 22 composite inners 41 note bushy tree join sequences attract much attention sequential ones literature matter fact generally deemed sufficient many researchers explore sequential join sequences desired performance last decade part explained reasons past powersize multiprocessor system limited query structure used simple require parallelizing bushy tree noted however two limiting factors phased rapid increase capacity multiprocessors trend queries become complicated nowadays thereby justifying necessity exploiting bushy trees consequently propose evaluate simulation several join sequence heuristics paper efficiently determine general join sequences good efficiency seen results heuristics proposed despite simplicity result general join sequences significantly outperform optimal sequential join sequence especially true complex queries importantly shown quality general join sequences obtained proposed heuristics fairly close optimal general join sequence meaning employing appropriate heuristics avoid excessive search cost obtain join sequences high quality next explore issue processor allocation join operations study intraoperator parallelism objective usually determine processor allocation achieves minimum execution time single join selection referred operational point selection paper however exploiting interoperator parallelism contrast dealing execution complex query multiple joins different joins allowed 2 note minimizing total amount work join sequence join sequence scheduling confused overall objective minimize query execution time executed parallel different clusters processors seen later minimizing execution time multijoin query addition operational point selection study intraoperator parallelism requires factors execution dependency system fragmentation considered execution dependency means joins cannot performed operands generated prior joins available also sequence processor allocation release might processors left idle since form cluster large enough execute remaining join efficiently phenomenon termed system fragmentation 11 clearly execution dependency system fragmentation well operational point selection taken account better processor allocation strategy thus complicating minimization procedure query execution time deal problem propose evaluate several heuristics determine number processors join processor allocation heuristics proposed divided two categories 1 bottom approach number processors allocated internal node join bushy tree determined bushy tree built bottom 2 top approach light concept synchronous execution time determines processor allocation based given bushy tree concept synchronous execution time employed deal processor allocation input relations join made available approximately time shown concept synchronous execution time significantly alleviate execution dependency system fragmentation hence improve query execution time note conduct performance study execution multijoin query schemes join sequence scheduling processor allocation integrated form final scheduler shown simulation results join sequence scheduling general dominating factor query execution time whereas processor allocation becomes significant number processors query complexity increase thus confirmed simulation among schemes investigated twostep approach first applying join sequence heuristics build bushy tree single processor system determining processor allocation light concept synchronous execution time bushy tree built emerges best solution minimize query execution time paper organized follows notation assumptions used given section 2 section 3 study several join sequence heuristics sequential general join sequences addressed sections 31 32 respectively simulation results presented section 33 processor allocation dealt section 4 bottom top approaches respectively developed sections 41 42 followed simulation results section 43 paper concludes section 5 preliminaries study assume query form conjunctions equijoin predicates attributes renamed way two join attributes attribute name join predicate join query graph denoted graph set nodes e set edges node join query graph represents relation two nodes connected edge exists join predicate attribute two corresponding relations edge r r j query graph said shrunken edge removed graph r r j merged together notice join operation two relations r r j given query graph carried obtain resulting query graph shrinking edges r r j merging two relations together represent resulting relation join operation use jr j denote cardinality relation r jaj denote cardinality domain attribute notation r r j used mean join r r j denotes resulting relation r r j notational simplicity denote execution tree figure 1a r 1 r 2 r 3 r 4 r 5 figure 1b r 1 r 2 r 3 r 4 r 5 prior work execution database operations multiprocessor systems assume execution time incurred primary cost measure processing database operations sense shown join expensive operation cost executing join operation mainly expressed terms cardinalities relations involved also focus execution complex queries becomes increasingly important nowadays real databases due use views 53 mentioned earlier different join methods different multiprocessor systems result different execution costs join shall address join methods without utilizing pipelining sortmerge join paper effect pipelining examined 9 35 worth mentioning due stable performance sortmerge join prevalent join method used database products handle equal nonequal join queries 2 24 hashbased join though good average performance suffers problem hash bucket overflow thus avoided many commercial database products architecture assumed study multiprocessorbased database system shared disks memory 5 cost function joining r r j expressed jr general reasonable joining large relations sortmerge join 28 29 51 also processors assumed identical amount memory available execute join assumed proportion number processors involved facilitate discussion performance scheduling scheme assessed average execution time plans generated scheduling scheme efficiency join sequence measured execution single processor system termed join sequence efficiency effectiveness processor allocation determined speedup achieved single processor case termed processor allocation efficiency overall efficiency dealing two issues depends two factors note best assess performance impact certain factors complicated database system generally required fix factors evaluate interesting ones similarly work performance adopt approach paper concentrate investigating effects join sequence scheduling processor allocation hence assumed several shared disks enough disk bandwidth io operations effect resource ie disknetwork bandwidth contention modeled 18 assumed similar effects schemes evaluated thus addressed paper noted even disk bandwidth bottleneck join sequence scheduling schemes generating smaller intermediate relations general tend better performance case however data placement disks become important issue performance improvement beyond scope paper also refer readers interested issues execution single sortmerge join use indices improve one join operation prior work intraoperator parallelism 28 29 51 optimization issues system dependent fact orthogonal relative performance among schemes evaluated paper besides assume values attributes uniformly distributed tuples relation values one attribute independent another cardinalities resulting relations join operations thus estimated according formula 10 given appendix reference note assumption essential simplify presentation also tuples assumed size presence certain database characteristics data skew modify formula estimating cardinalities resulting relations joins accordingly 20 23 applying join sequence scheduling processor allocation schemes results effect data skew found 27 51 3 determining execution sequence joins section shall propose evaluate various join sequence heuristics specifically focus sequential join sequences section 31 general join sequences ie bushy trees section 32 simulation results different heuristics given section 33 objective showing effect join sequence total work incurred section consider execution joins single processor system join sequence efficiencies various join sequences compared one another clearly results section improving join sequence efficiency applicable multiprocessor single processor systems combined effects join sequence scheduling processor allocation discussed section 4 31 schemes sequential join sequences first investigate sequential join sequences resulted following two methods 1 greedy method denoted sgd 2 optimal permutation denoted sopt means sequential join sequence subscripts mean methods used greedy scheme sgd outlined follows first scheme starts join requires minimal execution cost scheme tries join composite relation minimalcost join existing composite step repeated joins finished seen complexity sgd ojv j 2 moreover also investigate optimal sequential join sequence obtained optimal permutation relations joined seen number different sequential join sequences query n relations n half total number permutations n objects since first two relations interchanged evaluate optimal sequential join sequence section 33 different join sequences compared simulation implemented scheme sopt technique branch bound used avoid exhaustive enumeration reduce cost search better readability implementation detail sopt irrelevant quality join sequence resulted included paper show resulting join sequences sgd sopt consider query figure 2a whose profile given table 1 operations sgd formula appendix seen join r 2 r 4 one minimal cost among joins join r 2 r 4 resulting query graph profile given respectively figure 2b table 2 r 2 represents resulting composite verified r 5 relation minimalcost join r 2 execution r 2 r 5 r rrr er r rrr er g b figure 2 two states example query graph original graph b resulting graph joining r 2 r 4 figure 2b performed following procedure resulting join sequence sgd r 2 r 4 r 5 r 6 r 3 r 1 whose total cost 4524643 hand obtained query figure 2a optimal sequential join sequence sopt cost 3613592 less required sgd interesting see first join performed sopt r 1 r 3 rather r 2 r 4 first one chosen sgd cardinality 118 102 106 100 131 120 cardinalities relations attribute b c e f g cardinality 19 15 17 19 b cardinalities attributes table 1 profile query figure 2a cardinality 118 680 106 131 120 cardinalities relations attribute b c e g cardinality 19 15 17 19 b cardinalities attributes table 2 profile query figure 2b 32 schemes general join sequences seen cost function presented section 2 joins whose operands larger sizes usually higher costs observation suggests following heuristic explore general join sequence order reduce total cost incurred first perform minimalcost join resulting query choose minimalcost join perform procedure repeats joins finished note heuristic though efficient greedy nature local optimality considered thus need lead resulting join sequence minimal cost based heuristic scheme gmc g means resulting sequence general join sequence subscript mc stands join minimal cost outlined seen unlike sgd resulting composite join gmc need participate next join scheme execute join minimal cost begin 1 repeat jv 2 begin 3 choose join r 1 r j gve 4 perform r 5 merge r r j r minij update profile accordingly example query figure 2a verified figure 2b table 2 first minimalcost join r 2 r 4 performed next minimalcost join executed gmc r 5 r 6 rather r 2 r 5 sgd resulting sequence r 2 r 4 r 5 r 6 r 1 r 3 whose total cost 1395862 significantly less required sgd sopt execution rrr 5 r 6 rr 2 rrrrrrrrrrr arrrrr 6 r opt b mc g opt g c mr g figure 3 different execution trees resulted different join sequence heuristics trees resulted sopt gmc shown figures 3a 3b respectively seen complexity scheme ojv rather close ojv required sgd 3 note sequence joins cardinalities intermediate relations resulting early joins affect costs joins performed later since objective taken minimize total cost required perform sequence joins one may want execute joins produce smaller resulting relations first view fact develop evaluate following heuristic scheme variation gmc namely minimal resulting relation gmr instead finding minimalcost join gmc scheme gmr searches join results minimal resulting relation 4 clearly heuristic scheme gmr complexity ojv jjej scheme gmc algorithmic form gmr similar one gmc except statement 3 gmc changed 3a 3a gmr choose join r r j gve jr 3 simulation 11 run times required two schemes almost 4 another heuristic choosing join r r j minimal expansion ie jr evaluated 11 found provide mediocre performance results thus reported paper following gmr resulting join sequence query figure 2a r 1 r 3 r 6 r 5 r 2 r 4 whose bushy tree shown figure 3c associated cost 1328838 showing better join sequence efficiency one obtained gmc fact justified simulation results section 33 moreover assess performance heuristics implemented scheme gopt determine optimal general join sequence multijoin query sopt enumerate possible candidate sequences implementation gopt employ technique branch bound prune search using gopt obtain optimal general join sequence query figure 2a r shown figure 3d requiring cost 1301357 fact rather close obtained gmc gmr clearly optimal scheme though leading optimal solution se quence incur excessive computational overhead undesirable applications might outweigh improvement could heuristic schemes seen following heuristic schemes gmc gmr despite simplicity perform significantly better sgd sopt result join sequences whose execution costs reasonably close optimal one 33 simulation results join sequence heuristics simulations performed evaluate heuristic schemes query plan generation simulation program coded c input queries generated follows number relations query predetermined occurrence edge two relations query graph determined according given probability denoted prob without loss generality queries connected query graphs deemed valid used study determine structure query also cardinalities relations attributes involved referenced prior work workload characterization 53 workload obtained canadian insurance company make simulation feasibly conducted scaled average number tuples relation one million two thousand cardinalities attributes also scaled accordingly join selectivities could still reflect reality based cardinalities relations attributes randomly generated uniform distribution within reasonable ranges number relations query denoted n chosen 4 6 8 10 respectively value n 300 queries randomly generated query five scheduling schemes ie sgd sopt gmc gmr gopt performed determine join sequences execute query two relations join predicates joined together cartesian product performed simulation found relative performance schemes sensitive density query graph ie number edges graph 5 average execution cost join sequences obtained 5 note absolute performance scheduling schemes highly dependent uopn query complexity relation sgd sopt gmc gmr gopt table 3 average execution cost join sequences obtained scheme scheme prob032 shown table 3 also divide average execution costs first four schemes gopt comparison purpose show results associated table 3 figure 4 table 3 figure 4 seen except gopt join sequence efficiency join sequences obtained gmr best among obtained four remaining schemes order gmc sopt sgd join sequence efficiencies sequences resulted gmc gmr quite close optimal one significantly better sgd sopt especially number relations increases sizes queries simulated run times sgd gmc gmr rs6000 environment close one another whereas sopt gopt larger three orders magnitude due exponential complexity 4 processor allocation executing join pointed section 1 minimize execution time multijoin query necessary address following three issues operational point selection execution dependency system fragmentation note execution time required join operation within multiprocessor system depends number processors allocated perform join relationship modeled operational curve 6 evidenced prior results intraoperator parallelism 32 51 basically increasing number processors reduce execution time join saturation point reached point adding processors execute join contrary increase execution time mainly due combining effects limited parallelism exploitable excessive communication coordination overhead many processors example operational curve phenomenon shown solid curve figure 5 dotted curve xy30 given reference curve operational point chosen curve depending design objective generally point discussions issue found 33 41 6 note every join operational curve n4 n6 n8 n1026n number relations involved minimal cost required 107 107 108 106176 126 111282 figure 4 performance results different join sequence heuristics minimizes execution time join referred minimum time point denoted one optimizes execution efficiency ie minimizes product number processors execution time referred best efficiency point denoted p b formally execution efficiency allocating k processors execute join defined exe time one proc k exe time k proc represent efficiency allocation example operational curve figure 5 improve processor allocation efficiency utilize information provided operational curve operational point selection also required comply execution dependency avoid system fragmentation much possible minimize execution time query consequently propose evaluate following several heuristics determine number processors allocated execution join heuristics proposed divided two categories 1 bottom approach presented section 41 determines join sequence processor allocation time ie processors allotted bushy tree built 2 top approach presented section 42 determines processor allocation based given bushy tree effectiveness heuristics evaluated simulation section 43 number processors execution time figure 5 example operational curve join multiprocessor system 41 bottom approach processor allocation introduce four heuristics bottom approach determine processor allocation sequential execution se heuristic use processors system execute join query sequen tially seen interoperator parallelism absent heuristic used join sequence key factor performance case b fixed cluster size heuristic allocate fixed number processors execution join avoid system fragmentation clearly taking total number processors cluster size special case equivalent heuristic se note using heuristics system fragmentation avoided since fixed number processors always released together later use moreover heuristic se execution dependency inherently observed since join operations executed sequentially however two heuristics may suffer poor operational point selection information provided cardinality 100 85 93 106 102 90 101 94 cardinalities relations attribute b c e f g h j k cardinality 9 8 7 9 9 b cardinalities attributes table 4 profile query figure 6 operational curve utilized determine operational point join c minimum time point mt heuristic based minimum time point operational curve ie number processors used execute corresponding join operation p note even though operational point obtains minimum execution time join may minimize execution time multijoin query whole due effect execution dependency system fragmentation timeefficiency point te recall best efficiency point operational point processors efficiently used execute join however seen figure 5 scheme based best efficiency point might suffer execution dependency since join operating best efficiency point might take long execution time complete due small number processors used execute operation thus causing long waiting time subsequent joins hand scheme based mt may use processors efficiently since may require many processors reach minimum time point clearly number processors associated operational point strike compromise execution time processor efficiency within region p b p view shall use combination minimum time point best efficiency point termed timeefficiency point heuristic study ie number processors kp 1gammakp b used execute join operation 0k1 note heuristics processor allocation combined schemes scheduling join sequences developed section 3 form final scheduler handles scheduling processor allocation multijoin query multiprocessor system use join sequence heuristic say gmr determine next join considered employ f rrr r jr g figure query show processor allocation appropriate processor allocation heuristic determine number processors allocated execution join operations processor allocation deallocation outlined follows processor allocation heuristic denoted h p se fs mt described h p j number processors allocated execute join j heuristic h p processor allocation p number processors available initialized total numbers processors 1 use join sequence heuristic determine next join operation j h p jp execution dependency observed ie two input relations j available join exists go processor deallocation step 2 allocate h p j processors execute join j ppgammah p j step 3 update profile marking j ongoing join step 4 determine completion time j record completion time list ongoing joins step 5 go step 1 processor deallocation 1 completion time list determine next completion ongoing join say j step 2 update profile reflect j completed pph p j step 3 executable join updated query profile go processor allocation step 4 go step 1 seen using procedures execution tree built bottom demonstrate processor allocation deallocation shall show operations using heuristics se te operations fs follow similarly consider query figure 6 profile table 4 light results parallelizing sort join phases 29 51 operational curve join modeled hyperbolic function n p number processors employed parameters b c determined path length system processing joining tuples 28 32 51 parameter determined interprocessor communication protocol also observed 32 sortmerge join runs sorting usually memory intensive view fact amount memory available proportion number processors involved join minimal number processors required execution according sizes operands p b operational curve formulated thus determined study ignore operational area number processors less p b consider operational region p b p efficient execution without loss generality gmr used determine next join operation executed 7 heuristics se multiprocessor system 32 nodes abc1 d20 execution sequence shown table 5a column cumulative execution cost r used section 42 implement top approaches bushy tree corresponding processor allocation se shown figure 7a execution scenarios using timeefficiency point shown table 5b timeefficiency point used determined 03p b 07pm 8 bushy tree corresponding processor allocation te shown figure 7b note though scheme gmr used determine next join performed cases resulting join sequences different due different processor allocation scenarios seen bushy tree figure 7b different one figure 7a 42 top approach processor allocation seen execution tree built bottom following two constraints followed 1 execution dependency observed ie operands join selected 7 corresponding simulation results using gmc provide additional information thus omitted paper 8 different values k evaluated choice k03 made reasonably good performance join sequence proc starting time end time resulting r r r 4 r 5 r r r r r se join sequence proc starting time end time resulting r r r r 6 r 8 r 4 r 5 r r r b te join sequence proc starting time end time resulting r r r 4 r 5 r r r r r c st se join sequence proc starting time end time resulting r r r r 6 r 8 r 4 r 5 r r r st table 5 execution sequence different heuristic ser 3 r 6 r 8 rr 7 rr 5 r b ter 7 rr 3 rr 5 rrr 20rrrrrrrrrrrrrr figure 7 bottom processor allocation performed next depend resulting relation ongoing join 2 processor requirement satisfied according processor allocation heuristic employed ie number processors required join larger number processors available seen table 5a 5b two constraints lengthen execution time query degrade performance scheduler since first constraint causes long waiting time operands second result existence idle processors view one naturally wants achieve degree execution synchronization meaning processors allocated joins way two input relations join made available approximately time also idleness processors avoided result propose top approach processor allocation uses concept synchronous execution time alleviate two constraints improve query execution time describe processor allocation using synchronous execution time consider bushy tree figure 7a example recall every internal node bushy tree corresponds join operation determine number processors allocated join manner top clearly processors allocated join associated root bushy tree since last join performed processors allocated join root partitioned two clusters assigned execute joins associated two child nodes root bushy tree way two joins completed approximately time step partitioning processors root applied internal nodes tree top manner internal node join assigned number processors formally define cumulative execution costs internal node sum execution costs joins subtree internal node also define cumulative execution cost leaf node original relation zero let r relation associated internal node bushy tree r x r relations corresponding two child nodes cumulative execution cost node r denoted wr determined r note cumulative execution cost node determined bushy tree built bottom cumulative execution costs internal nodes bushy trees figures 7a 7b found tables 5a 5b respectively important see achieve synchronous execution time partitioning processors node two clusters child nodes one take account cumulative execution costs two child nodes rather execution costs two joins associated two child nodes let r relation associated internal node bushy tree r x r relations corresponding two child nodes wr x denote number processors allocated perform join generating r pr pr x pr determined respectively r x r r e p r r x since wr 0 r original relation know one child node corresponds join leaf node former inherits processors note number processors allocated internal node join bushy tree say r processors exceeds required minimum time point shall employ p processors perform join whereas using r processors subsequent partitioning subtree internal node also number processors passed internal node lower level tree partitioned efficient execution joins sequential execution joins child nodes employed better performance clearly many different bushy execution trees query seen problem determining optimal bushy tree minimize execution time concept synchronous execution time exponential complexity efficient solution apply concept synchronous execution time bushy trees obtained heuristics introduced section 41 pointed different bottom processor allocation heuristics used may result different bushy trees even join sequence heuristic applied important see although execution time sequence table 5a se larger table 5b te join sequence efficiency bushy tree figure 7a fact better tree figure 7b shown cumulative execution costs tables 5a 5b note constraints execution dependency get introduced bushy tree built heuristic te well fs mt constraints absent heuristic se employed form bushy tree explains tree figure 7a different figure 7b thus bushy tree se fact superior heuristics former better join sequence efficiency owing full exploitation join sequence heuristics therefore shall apply concept synchronous execution time bushy tree built se denoted st se comparison purpose also investigate use synchronous execution time bushy tree built te denoted st execution scenario using heuristic st se shown table 5c corresponding bushy tree processor allocation shown figure 8a spite fact bushy tree figure 8a figure 7a resulting execution times differ due difference processor allocation seen st se processors allocated execution join way two joins generating two operands later join completed approximately time thus alleviating execution dependency moreover since processors allocated node bushy tree partitioned allocation child nodes system fragmentation eased explains st se outperforms se despite identical bushy trees join sequence efficiency execution scenario using heuristic st execution time shown table 5d bushy tree processor allocation st shown figure 8b bushy tree one figure 7b differs latter processor allocation important see despite outperforms se st se performs better st fact best one among processor allocation heuristics evaluated section 43 43 simulation results processor allocation query generation scheme employed section 33 used produce input queries simulation subsection section 33 300 queries given number relations involved randomly generated occurrence edge query graph also determined given probability prob query six scheduling schemes according heuristics se fs mt te st se st respectively performed determine number processors join execute query section 33 simulation results also indicate heuristics sensitive different values prob thus shall show results prob030 following multiprocessor 48 nodes average execution times obtained ar 3 r 6 r 8 rrr 5 r rr 5 rrr st b str 4 rrrrrrrrrrrrrrr figure 8 top processor allocation synchronous execution time heuristic queries 10 15 20 25 relations shown table 6a seen heuristic se ie one using intraoperator parallelism performs well number relations 10 performs worse number relations increases agrees intuition since number relations increases opportunity exploit interoperator parallelism increases constraint imposed execution dependency becomes relatively less severe also heuristic fs general outperformed others due mainly execution dependency poor operational points selection among heuristics bottom approaches shortest execution time usually achieved heuristic te especially number n large explained reason mentioned ie execution dependency eased number relations large thus performs best best usage processors also 300 randomly generated queries average execution times obtained six heuristics query 15 relations shown table 6b number processors system varied 16 64 seen number processors increases heuristic se suffers inefficient use processors thus outperformed heuristics mt te st se st wide margin also observed heuristic uses processors efficiently achieve nearly minimum execution time performs well number processors large clearly processors system parallelism exploited heuristic te however mt performs better pn64 relation se fs mt n15 90411 208287 76599 71354 59902 62845 number processors 48 proc se fs mt pn48 90411 208287 76959 71354 59902 62845 b number relations 15 table average execution time heuristic explained fact supply processors sufficient achieving minimum time point mt becomes better heuristic using processors efficiently te number processors small utilizing intraoperator parallelism ie se suffice provide reasonably good performance hand large multiprocessor system one resort interoperator parallelism fully exploit resources system note however without using synchronous execution time te though good operational point selection join cannot improve query response time global sense due nature bottom approach thus outperformed st se st fact strongly justifies necessity taking execution dependency system fragmentation consideration interoperator parallelism exploited mentioned earlier although se outperformed due poor operational point selection st se remedies defect properly reallocating processors using concept synchronous execution time st se thus outperform st te worth mentioning sequential join sequences one shown figure 3a benefit concept synchronous execution time since case joins executed sequentially interoperator parallelism exploitable fact together fact sequential join sequences usually suffer poor join sequence efficiency accounts importance exploring general join sequences note similar heuristics section 3 heuristics investigated straightforward require little implementation overhead results showed join sequence efficiency general dominating factor query execution time whereas processor allocation efficiency becomes significant number processors query complexity increase suggests efficient solution one attempt optimize join sequence efficiency building good bushy tree first improve processor allocation efficiency appropriately allocating processors execution join fact heuristic st se constructed 5 conclusion paper dealt two major issues exploit interoperator parallelism within multijoin query join sequence scheduling ii processor allocation first issue explored general join sequence exploit parallelism achievable multiprocessor system heuristics gmc gmr derived evaluated simulation heuristics proposed despite simplicity shown lead general join sequences whose join sequence efficiencies close optimal one gopt significantly better achievable optimal sequential join sequence opt particularly number relations query large moreover explored issue processor allocation addition operational point selection needed intraoperator parallelism identified investigated two factors execution dependency system fragmentation shown important exploiting interoperator parallelism several processor allocation heuristics categorized bottom top approaches proposed evaluated simulation form final scheduler perform multijoin query combined results join sequence scheduling processor allocation among schemes evaluated twostep approach st se 1 first applies join sequence heuristic build bushy tree minimize total amount work required single processor system 2 light concept synchronous execution time allocates processors internal nodes bushy tree top manner shown best solution minimize query execution time r parallel database systems overview db2 parallel edition database operations cubeconnected multiprocessor system parallel database system shared store performance comparison two architectures fast transaction processing prototyping bubba development cross8 hc16186 data base computers parallel features nonstop sql applying segmented rightdeep trees pipelining multiple hash joins combining join semijoin operations distributed query processing scheduling processor allocation parallel execution multijoin queries informix parallel data query practical skew handling parallel joins multiprocessor hashbased join algorithms parallel database systems future high performance database systems query optimization parallel execution effect join operations relation sizes dataflow query processing using multiprocessor hashpartitioned algorithms sequential sampling procedures query size estimation exploiting interoperator parallelism xprs parallel execution multiple pipelined hash joins considering data skew factor multiway join query optimization parallel execution system issues parallel sorting database systems percentile finding algorithm multiple sorted runs query optimization database systems architecture performance relational algebra machine grace effectiveness parallel joins effectiveness optimization search strategies parallel execution spaces oracle parallel rdbms massively parallel systems optimal processor allocation support pipelined hash joins exploiting database parallelism messagepassing multiprocessor optimization multiway join queries parallel execution join processing relational databases measuring complexity join enumeration query opti mization parallelism relational data base systems architectural issues design approaches kendall square query decomposer design evaluation parallel pipelined join algorithms performance evaluation four parallel join algorithms sharednothing multiprocessor environment tradeoffs processing complex join queries via hashing multiprocessor database machines access path selection relational database management system multiple query optimization design xprs parallel sort merge join algorithm managing data skew hierarchical approach parallel multiquery scheduling workload characterization relational database environments parallel query processing parallel query processing dbs3 tr ctr anindya datta debra vandermeer krithi ramamritham parallel star join efficient query processing data warehouses olap ieee transactions knowledge data engineering v14 n6 p12991316 november 2002 mingsyan chen huii hsiao philip yu applying hash filters improving execution multijoin queries vldb journal international journal large data bases v6 n2 p121131 may 1997 wenchih peng mingsyan chen query processing mobile computing environment exploiting features asymmetry ieee transactions knowledge data engineering v17 n7 p982996 july 2005 shortening matching time ops5 production systems ieee transactions software engineering v30 n7 p448457 july 2004 changhung lee mingsyan chen processing distributed mobile queries interleaved remote mobile joins ieee transactions computers v51 n10 p11821195 october 2002 julian r ullmann partition search nonbinary constraint satisfaction information sciences international journal v177 n18 p36393678 september 2007
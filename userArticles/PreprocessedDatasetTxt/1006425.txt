exact algorithms finding minimum transversals rank3 hypergraphs present two algorithms problem finding minimum transversal hypergraph rank 3 also known 3hitting set problem problem natural extension vertex cover problem ordinary graphs first algorithm runs time o16538n hypergraph n vertices needs polynomial space second algorithm uses exponential space runs time o16316n b introduction hypergraphs generalization graphs edges called hyperedges may consist 1 2 vertices hypergraph rank k largest hyperedge contains k vertices transversal also known hitting set vertex cover subset v vertices includes least one vertex every hyperedge minimum transversal problem finding transversal minimum cardinality hypergraph npcomplete general case hypergraphs maximum rank k 1 6 article consider problem hypergraph rank 3 finding transversal minimum cardinality equivalent finding independent set maximum cardinality transversals much widely studied hypergraphs independent sets finding hypergraph transversals applications many areas example artificial intelligence database theory 4 particular situation finding small transversal large rank3 hypergraph encountered computational biology computing evolutionary phylogenies 3 close connection computing set minimal transversals rh hypergraph h data mining problem research partially supported cugs national graduate school computer science sweden finding maximally specific sentences interesting database 8 furthermore minimum transversal problem natural generalization vertex cover problem ordinary graphs algorithm first exact algorithm aware solves problem time provably lower o2 n algorithms related problems could used solve minimum transver sal provide guarantee particular niedermeier rossmanith 13 constructed algorithm parameterized version problem one tries find transversal smaller given parameter k runs time o2270 k n take closer look applicability previous algorithms section 3 related results beyond ones mentioned section 3 approximation algorithm minimum transversal 10 5 deals transversal hypergraph problem general form main part paper present two algorithms minimum transversal one using polynomial space runs o16538 n one uses exponential space runs o16316 n time achieve bounds two things first use parameterized algorithm case previously mentioned algorithm niedermeier rossmanith 13 important subcase algorithm low value parameter proven possible second use method analysis takes number edges cardinality 2 consideration without making analysis overly complicated tricks may useful construction algorithms well article structured follows section 2 contains various definitions minor results needed algorithm section 3 deals topic previous algorithms problem section 4 contains algorithms analyses finally section 5 contains conclusions 2 preliminaries 21 basic definitions hypergraph generalization graph edges e arbitrary sets called hyperedges vertices h sometimes h given tuple v e v vertices e hyperedges purposes definition simpler nh number vertices jhj number edges h usually use n let hypergraph implied rank hypergraph defined runiform hypergraph call edge cardinality k kedge edge cardinality 1 called loop degree vertex dx number edges e x 2 e write hypergraph consideration clear context define k x k x h number kedges e x 2 e hypergraph simple edges minh hypergraph edges eg words hypergraph minimal hyperedges h obviously simple n complete runiform hypergraph n vertices edges combinations r vertices 22 transversals independent sets transversal h transversal transversal 0 h exists 0 ae equivalent transversal ordinary graphs vertex cover independent set h e 6 edges complement independent set transversal maximal minimal set minimal transversals h called transversal hypergraph rh hypergraph proofs statements see 1 h size smallest transversal h defined transversal hypergraph problem problem generating rh given hypergraph h naturally know rh solve minimum transversal problem searching rh smallest transversal ojt rhj time however jt rhj may exponential potentially large o2 n 23 turan numbers turan number n p r minimum jhj runiform hypergraphs h theorem 1 h 3uniform hypergraph l 6k1gamma proof given 1 r p n always true hypergraph de caen 2 shown r set integer 2n q 2 words jhj 1gammaq qn integer h possible definition turan number k solving q get one positive solution using solution get 6k note condition qn integer equivalent condition fkdeltan integer fk function positive values k continous monotonously increasing assumes values 0 1 exclusively therefore fk exists k 0 k fk 0 theorem makes trivial statement since true every 3uniform hypergraph h 3 algorithms section take look algorithms related problems could applied minimum transversal problem 31 parameterized 3hitting set 3hitting set equivalent minimum transversal problem 3 uniform hypergraphs nice algorithm parameterized version problem one seeks transversal jt j k given parameter k presented niedermeier rossmanith 13 algorithm runs time o2270 k n easily modified return minimum hitting set parameterized nature algorithm slower k large faster k low general case k may large hypergraph k 3 achieves running time o2270 n jhj limited theorem 1 guarantees better limits h thus better running time algorithm use algorithm take care otherwise difficult case details found section 4 32 transversal hypergraph applicable algorithms found solve transversal hypergraph problem defined section 22 algorithms include classic algorithm berge 1 improvement kavvadias stavropoulos 9 seems behave well experiments theoretical results exist algorithms theoretical interest eiter gottlob 4 mishra pitt 12 algorithms either proven upper bound running time best known upper bound o2 n mainly due fact algorithms designed properties low total running time mind eg low predictable delay output transversals another reason maximum size jt rhj h rank3 hypergraph unknown may high o2 n note also except algorithm kavvadias stavropoulos algorithms usually require exponential amount memory 4 algorithms section present algorithm minimum transversal problem first present basic algorithm mintrh needs polynomial space analysis show modified use exponential space lower running time algorithm vertex x hypergraph fe 2 hypergraph hg intuitively hypergraph remains covered x included transversal remaining hypergraph x included transversal sometimes say mean x included transversal vice versa vertex x dominated another vertex x every edge e 2 h note loop x dominated vertex observation useful analyzing algorithm 41 polynomial space algorithm algorithm mintrh basically binary tree search uses algorithm niedermeier rossmanith 13 base case presented list cases figure 1 first applicable case used algorithm returns smallest transversal note two different uses min mina b sets b returns set lowest car dinality minh hypergraph h hypergraph minimization operation defined section 21 algorithm mintrh input hypergraph h output smallest transversal h h empty return 1 h simple return mintrminh 2 exists loop fxg 2 h return fxg 3 vertex x dominated vertex return 4 let x vertex maximum dx among vertices maximum 5 exists least one 2edge h pick vertex x maximum 2 x 2edge fx yg return 6 maximum degree vertex h 4 use nieder meier rossmaniths algorithm 7 finally pick vertex x maximum dx return fig 1 polynomial space algorithm minimum transversal algorithm uses three reductions listed cases 13 order manner vertex chosen branching designed maximize creation loops 2edges number 2edges important feature analysis algorithm given next section prove correctness algorithm case case correctness cases 0 1 apparent section 2 case 2 note unless edge fxg cannot covered correctness case 3 follows following observation x dominated every edge covered covered 1 means exists minimum transversal exists another minimum transversal 0 x 62 0 case 6 refer niedermeier rossmaniths paper 13 every remaining case tries vertex v clearly exhaustive search last case catches remaining situations finally note since assignments done one vertex time since case 2 takes care loops empty edge never occur h 42 analysis algorithm section perform analysis algorithm show running time o16538 n analysis method kullmann 11 used consider branching tree algorithm implicitly constructs applied problem instance let every edge tree labelled real positive number representing reduction complexity occurs along edge node v tree branches labelled 1 branching tuple v associated branching number positive solution branching number denoted consider reduc tions meaning cases require one branch examined thus implemented without actual recursion occur locally within node tree node branching tree least two children algorithm cases 13 reductions hypergraph none cases 13 apply said maximally reduced hypergraph associated node v branching tree maximally reduced hypergraph dealt node analysis use realvalued function f h derive labels edges branching tree specifically label edge linking node v associated hypergraph h child w v associated hypergraph h 0 f exact definition f h given moment need know f h 0 f h labels branching tree guaranteed positive conditions 0 f h nh every label branching tree positive running time algorithm opolyn delta highest branching number tree polyn polynomial n proof discussion method found 11 f h use function takes nh number 2edges h henceforth named k consideration specifically f realvalued function words vales psik use finegrained measure complexity usual n six subdivisions one motivation using particular f h worstcase running time algorithm modelled using twovariable recursion values n settle pattern similar c ngammapsik function psik constant c another motivation seems natural n variables 2edges slightly difficult n variables one 2edge turn difficult two 2edges matter many 2edges always possible removed single assignment might lead maximally reduced hypergraph 2edges important note however correctness bounds given section rely upon either optimality similarities f h n realworld worstcase running times psik obeying given rules get worstcase branching number c running time mintrh oc n use nonoptimal psik constant c higher necessary ease presentation values psik given table 1 technically numerical optimization required find values available beforehand simplifies proof makes easier verify claims process found explained proof note similarities differences approach kullmann 11 might order since problems solve related detailed comparison course given without thorough review paper problem solving expressed roughly account 2edges according nonlinear function complexity analysis local analysis recursion performed kullmann accounts short clauses corresponding 2edges linearly instead uses complicated nonlocal analysis get good upper bound kullmanns method might provide tighter bound exchange proof bound complex lengthy main part section theorem 2 give proof time complexity mintrh first give small lemma concerning time complexity niedermeier rossmaniths algorithm lemma 1 niedermeier rossmaniths algorithm runs o16484 n time 3uniform hypergraph h maximum degree 4 less proof since maximum degree h 4 jhj n3 setting theorem 1 section 23 gives us h d060962ne ceiling function ignored sufficiently large n parameter niedermeier rossmaniths algorithm running time o2270 060962n theorem 2 mintr runs o16538 n time proof let k number 2edges h give branching numbers various cases algorithm using measure f values psik given cases 03 case 0 use recursion cases 13 reductions previously mentioned value f h decreased applicable reductions applied situation might temporarily increase f h 2edges removed case 1 occur h contains least one loop case reduce nh afterwards resulting reduction f h least case 4 case need examine detail n k change branch branching assume 3 branch examined let n 0 k 0 number variables 2edges remaining respectively reductions applied assume dominated vertices occur would lead easier branchings two branches hx 1 branch q 2edges removed loops new 2edges created hx 0 branch p 3edges turned 2edges q 2edges turned loops since h minimal p 2edges new ie occur h unique disjoint loops k 0 p also guarantees every loop fvg 2 thus maximum number 2edges removed cases 1 2 q delta q total n worst case particular q always case minimum k 0 k formula branching number branching number cases case 4 subcase 2 k formula branching number branching number cases case 4 subcase 2 resulting branchings divided 3 cases first branch one worst case branching case every value k achieved k 0 minimal branching using values table 1 find branchings branching number 16538 instance worstcase branching number note k 6 branching number 1 table 2 contains formulas calculating branching numbers cases along actual branching numbers second one worst case minimal k 0 value k given table 3 formulas calculating branching numbers actual branching numbers cases k 6 dominated worst case since parts tuple increase increasing k finally q 3 worst case value k branching formulas branching numbers values q k branching number branching number cases case 4 subcase 2 x 3 6 listen table 4 2 x 6 k 6 brings worse cases since case 5 case two subcases 2 proven branching number less 14143 note vertex v 2 v 0 otherwise domination case 4 would apply 2 assume edges containing x fx yg fx zg know 2 dominated z x z taken care reductions 0 loop fxg removed dz 1 cases least 3 variables removed branching number overestimated 3 gamma otherwise 2 branches variables x 2edge fx yg removed exactly one new 2edge created thus k unchanged branching number case case running time o16484 n case 7 since dx 5 worst branching case 16538 final case algorithm proof completed finding values psik case analysis algorithm first performed precise values psik known found numerical optimization explain optimization performed branching b set values psik calculate value branching number b given formula given branching b vector corresponding branching number enumerate branchings occuring case analysis let x vector x containing values psik running time mintrh ocx n want find x minimizes cx given conditions psik course branchings b found case 5 algorithm value b x good enough regardless x branchings included optimization note particular algorithm analyzing section b x continous long conditions x hold cx continous sufficient condition standard algorithms achieve least local optimum 43 exponential space modification using idea robson 14 lower time bound allow algorithm use exponential space idea remember result recursive algorithm subsets v 0 ae v jv 0 j ff delta jv j ff store quickly accessible data structure like balanced tree solutions calculated 14 robson ordinary graphs exactly one subgraph v 0 ae v hypergraps however several different hypergraphs using vertices v 0 may reached course algorithm start hypergraph h vertices v edge fx reach hypergraph h 0 vertices either assignment assignment made possibility fy zg 62 h 0 one way handle take care 2edges loops separately remember results 3uniform hypergraphs suppose hypergraph h 0 vertices edges h 0 h come setting vertex therefore smaller 3 edges cardinality 3 h 0 exactly edges cardinality 3 h use vertices v 0 exactly one 3uniform hypergraph every v 0 ae v unfortunately method trivially extended algorithm niedermeier rossmanith useful way running time algorithm depends value parameter k size vales psi 0 k graph consequently algorithm potentially takes o16484 n running time regardless caching want find better bound running time cannot use algorithm version algorithm net result using algorithm instead using caching trick stated running time o16316 n let mintrnonrh mintrh subcase calling niedermeier rossmaniths algorithm removed algorithm still correct modification final case remains catchall case first give bound running time mintrnonrh proceed give details modification use exponential space lemma 2 mintrnonrh takes o16737 n time hypergraph n vertices proof case analysis performed theorem 2 valid modified algorithm well final case give brief version proof values new psik called given table 5 cases 03 still valid affected change psik psi 0 k case 4 case analysis still valid need repeat branchings get new branching numbers tables 68 give branching formulas new values branching numbers case case 5 case analysis still valid branching number still smaller 14143 reasons old case 6 removed final case new worst case 1 1 psi 0 possible values psi 0 k course derived using method psik simpler way look upon robsons idea imagine algo k formula branching number branching number cases case 4 subcase 2 using psi 0 k k formula branching number branching number cases case 4 subcase 2 using psi 0 k branching number branching number cases case 4 subcase 2 x 3 using psi 0 k algorithm mintrexph input hypergraph h output smallest transversal h possibly taken lookup tree h empty return 1 loop fxg 2 h return fxg 2 vertex x lies one 2edge return 3 2edges exist vertex lies one pick edge fx yg return 4 solution previously calculated return 5 otherwise pick 3edge fx remember result fig 2 helper function mintr n ffn 0 rithm first fills tree subsets v 0 jv starts working h halting recursion whenever reached hypergraph precalculated solution tree filled time polynomial n times size certain 3uniform h 0 vertices pick edge fx branches h 0 note assignment made x second third branches first third branches etc branching equivalent looking tree way polynomial local work needed every v 0 ae v tree rest algorithm let h 0 n 0 vertices hypergraph given initial call let mintr 0 h mintrnonrh modified call mintrexph given figure 2 whenever uses two different types branchings one hand branches 1 hand standard branching branches 0 correctness former branchings follows definition transversal correctness latter branchings obvious theorem 3 mintr 0 h uses time space o16316 n hypergraph h vertices v jv proof analysis view algorithm split one treefilling part one search part filling tree uses time space opolyn delta ffn one entry every v ffn different know max 0kffn ffn delta number entries tree ffn ffn already noted tree filled polynomial local work entry get bound form n need asymptotics ffn use stirlings approximation see 7 2n e ignoring details polynomial factors ffn e e e polyn deltaff ff polyn part grows polynomially asymptotic bound time space needed part algorithm search part algorithm divided time spent mintr 0 time spent mintrexp time spent mintr 0 o16737 1gammaffn whole search tree mintrnonr algorithm viewed one search tree depth 1 gamma ffn search tree depth ffn attached leaf size lower search trees o16737 ffn since total time mintrnonr algorithm o16737 n see upper search tree o16737 1gammaffn leaves time spent mintrexp o14656 ffn mintrexp used ffn vertices remain algorithm case 1 reduction case 4 takes polynomial time case 2 branching tuple 1 better case 1 applied edges fx yg fx zg get loops fyg fzg branching number 14656 case 3 finally leads total work o14143 n 0 reached n 0 remaining vertices reach case 3 small edges created case 3 used case 4 met number 2edges b reach o2 b leaves polynomial work leaf since 2edges pairwise disjoint b n 0 2 time needed ffn worst case mintrexp case 2 combining two times o16737 1gammaffn calls mintr exp spends o14656 ffn time search tree total time o16737 1gammaffn 14656 ffn searching part algorithm two expressions balance total running time mintr 0 h sum ff first part increases growing ff second part decreases sum course dominated biggest term want find point balance solveff ff get 019228 parameter running time memory usage whole algorithm o16316 n 5 conclusions constructed two algorithms minimum transversal prob lem one needs polynomial space runs o16538 n time one needs space time o16316 n best knowledge first exact algorithms problem running time o2 n better r north holland extensions theorem moon moser complete subgraphs parameterized complexity framework systematically confronting computational intractabil ity identifying minimal transversals hypergraph related problems complexity dualization monotone disjunctive normal forms computers intractability guide theory npcompleteness concrete mathematics foundation computer science data mining evaluation algorithm transversal hypergraph problem approximating coloring maximum independent sets 3uniform hypergraphs new methods 3sat decision worstcase analysis generating maximal independent sets boundeddegree hypergraphs efficient fixed parameter algorithm 3hitting set algorithms maximum independent sets tr identifying minimal transversals hypergraph related problems complexity dualization monotone disjunctive normal forms data mining hypergraph transversals machine learning extended abstract generating maximal independent sets boundeddegree hypergraphs new methods 3sat decision worstcase analysis approximating coloring maximum independent sets 3uniform hypergraphs concrete mathematics computers intractability evaluation algorithm transversal hypergraph problem efficient fixedparameter algorithm 3hitting set ctr peter damaschke parameterized enumeration transversals imperfect phylogeny reconstruction theoretical computer science v351 n3 p337350 28 february 2006
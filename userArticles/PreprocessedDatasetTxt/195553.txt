reducing branch costs via branch alignment several researchers proposed algorithms basic block reordering call branch alignment algorithms primary emphasis algorithms improving instruction cache locality studies concerned branch prediction reported small minimal improvements wideissue architectures become increasingly popular importance reducing branch costs increase branch alignment one mechanism effectively reduce costsin paper propose improved branch alignment algorithm takes consideration architectural cost model branch prediction architecture performing basic block reordering show branch alignment algorithms improve broad range static dynamic branch prediction architectures also show program performance improved approximately 5 even using recently proposed highly accurate branch prediction architectures programs compiled existing compiler transformed via binary transformations implementing algorithms alpha axp 21604 16 reduction total execution time achieved b introduction conventional processor architectures particularly modern superscalar designs extremely sensitive control flow changes changes control flow conditional unconditional branches direct indirect function calls returns detected instructions decoded keep pipeline fully utilized processors typically fetch address following appear 6th international conference architectural support programming languages operating systems asplosvi san jose california october 1994 recent address decoded instruction breaks control flow previously fetched instruction used new instruction must fetched introducing pipeline bubble unused pipeline step called instruction misfetch penalty final destination conditional branches indirect function calls returns typically available latter stage pipeline point branch completely eval uated processor may elect fetch decode instructions assumption eventual branch target accurately predicted processor mispredicts branch destination instructions fetched incorrect instruction stream must discarded leading several pipeline bubbles causing mispredict penalty practice pipeline bubbles due mispredicted breaks control flow degrade programs performance misfetch penalty example combined branch mispredict penalty digital alpha axp 21064 processor ten instructions comparison axp 21064 would lose two instructions instruction misfetches almost modern architectures use form branch pre diction reducing number misfetch misprediction penalties increasingly important wideissue architec tures paper examine algorithms reorder structure program improve accuracy branch fetch prediction architectures code transformations reduce number mispredicted branches number misfetched instructions essentially method restructure control flow graph fallthrough branches occur fre quently use profile information direct transformation architectural cost model decide transformation warranted transformations include rearranging placement basic blocks changing sense conditional operations moving unconditional branches frequently executed path occasionally inserting unconditional branches show static dynamic branch prediction mechanisms examine benefit transformations static branch architectures benefiting dynamic implemented branch alignment binary transformation algorithms dec alpha axp 21064 measured total execution time improvements 16 considerable work profiledriven program opti mization section weconsider relevant work onoptimizations instruction caches branch mechanisms optimization memory hierarchies due expense memory early computers much early work focused reducing paging virtual memory systems several researchers explored ways group related subroutines basic blocks onto virtual memory pages 1 8 11 13 10 researchers extended work lower levels memory hierarchy optimizing performance instruction caches mcfarling 15 described algorithm reduce instruction cache conflicts particular class programs hwu chang 18 describe general effective technique using compile time analysis impacti compiler system using profilebased transformations impacti compiler inlines subroutinesand performs trace anal ysis subroutine instructions packed using frequently executed traces moving infrequently executed traces end function following global analysis arranges functions reduce interfunction cache conflicts similar transformations applied pettis hansen 21 programs hp parisc optimizations control flow mcfarling hennessy 17 described number methods reduce branch misprediction instruction fetch penalties including profiledriven static branch prediction delay slots aform branch alignment variant branch alignment considered ifthenelse constructs later bray flynn 4 extended work mcfarling et al examining various branch target buffer btb architectures yet also examined ifthenelse constructs yeh et al 26 commented trace scheduling taken branches could reduced 62 executed conditional branches 50 executed conditional branches earlier study hwu chang 18 showed 58 fallthrough rate branch alignment papers mcfarling hen nessy bray flynn pettis hansen report change percentage taken branches branch alignment reordering algorithm proposed hwu et al general mcfarlings brays hwu chang examined basic blocks rearranging achieve better branch alignment able handle branches form ifthenelse structure work pettis hansen 21 describes greedy algorithm branch alignment similar hwu changs since look basic blocks pettis hansen greedy algorithm general hwu chang algorithm performs better terms reducing cost branches paper describe algorithm extension pettis hansen algorithm compare results greedy algorithm also improve upon analysis effectiveness branch alignment mcfarling bray flynn hwu chang pettis hansen describe efficiently apply branch alignment various static dynamic prediction architectures measure effectiveness branch alignment architectures technique similar methods mcfarling bray flynn hwu chang pettis hansen however inline functions perform global analysis duplicate code perform analysis using object code postprocessor rather compiler simplifies analysis avoids recompiling full program simple transformations also allows us apply branch alignment full program including portions normally compiled user program libraries process many programs generated number different compilers postprocessor tool branch alignment would normally one several optimizations applied program 3 branch prediction architectures branch architectures donot include abtb incur misfetch penalty branch decoded architectures use branch delay slots mechanisms 5 7 17 avoid penalty paper assume fallthrough instruction fetched branch decoded except branch target buffer architecture thus taken branches always incur misfetch penalty modeled three static branch prediction architectures two dynamic prediction architectures static branch prediction architectures fallthrough model assumes fallthrough execution path always executed btfnt backwardtaken forward taken assumesback ward branches always taken forward branches taken branch model fairly common variants implemented hp parisc alpha axp21064 likely model assumes encoded information branch instruction indicates whether branch likely taken taken branch model used several architectures including tera 2 likelyunlikely flag set either using compiletime estimates 3 profile information 9 use profile information since much accurate simple gather appropriate tools 23 program transformation help branch prediction architectures reduce misfetch misprediction delays fallthrough architecture fallthrough path executed frequently reduce misfetch improve prediction btfnt architecture useful fallthrough common path thats possible costeffective branch target placed conditional branch backwards branch predicted since branch mispredict penalty larger misfetch penalty may better correctly predict backwardsbranch even results misfetch likely model compiler specify likely branch come therefore code transformations eliminate mis fetch penalties making fallthrough frequently executed path expect opportunities optimization fallthrough method btfnt model taken branches mispredicted fallthrough method likewise would expect optimization opportunities btfnt model likely model since improve misfetch rate transforming programs using likely model figure 1 shows code transformations help static original code b transformed code figure 1 benefits code transformation elim lowering espresso darkened edges fallthrough dotted edges taken nodes represent basic blocks prediction model figure 1 shows portion control flow graph routine elim lowering espresso bench mark nodes labeled numbers number parenthesis indicates number instructions basic block edges labeled frequency execution edge labeled 16 executed 16 edge transitions subroutine unlabeled edges executed less 1 time fallthrough edges darkened taken edges dotted original code figure 1a likely architecture correctly predict likely targets misfetch penalties edges comparison fallthrough architecture mispredict edges since taken branches btfnt architecture also mispredict edges correctly predict edge since target branch instruction resulting backwards branch transformed code figure 1b efficient layout terms branch costs static prediction architectures since node 25 fallthrough node 31 architectures correctly predict edge penalty since 31 laid 25 btfnt accurately predict edge misfetch penalty also since node 29 laid 27 branch accurately predicted transformed program gives optimal layout btfnt since prediction likely2041441146 figure 2 routine input hidden alvinn architecture also good layout fallthrough ar chitecture though still suffers mispredicting edges predict less likely executed edge notice transformed code two taken edges coming node 28 since one edges fallthrough need add unconditional branch fallthrough turn jump correct destination node transformed code figure 1b gives efficient transformation static architectures general single branch alignment transformation always give optimal alignment different architectures code transformations reduce branch penalties consider underlying branch model performing branch alignment later examine transformation algorithms model underlying branch architecture show perform better algorithms many optimizations unrolling loops investigate example traced alvinn pro gram neural net simulator found 46 time spent routine input hidden another 46 spent hidden input figure 2 shows control flow graph input hidden nearly 100 branches sub routine 46 branches alvinn arise single branch basic block 4 unrolled loop duplicating 11instruction basic block 4 could reduce misfetch penalty architectures improve branch prediction fallthrough architecture normally loop unrolling complex transformation also attempts reduce total number executed branches within unrolled code feel simply duplicating basic block 4 inverting aligning branch condition added conditional branches example would offer performance improvement even optimizations offered loop unrolling ignored dynamic branch prediction methods static prediction mechanisms particularly profilebased methods accurately predict 7090 conditional branches many current computer architectures use dynamicpredictionsuch branch target buffers btb pattern history tables pht accurately predict 9095 branches originally btbs used mechanism branch pre diction effectively predicting prior behavior branch even small btbs found effective 4 17 20 22 26 intel pentium example current architecture using btbs 256entry btb organized 64 line fourway associative cache branches taken entered btb branch address appears btb stored address used fetch future instructions otherwise fallthrough address used btb entry pentium also uses twobit saturating counter predict direction conditional branch 14 conditional branches predicted using much simpler mechanisms methods nothing misfetch penal ties pattern history table pht eliminates site target addresses table table predicts direction conditional branches designs use branch site address index table prediction bits recently pan et al 19 yeh patt 27 investigated branchcorrelation twolevel branch prediction mechanisms although number variants mechanisms generally combine history several recent branches predict outcome branch simplest example degeneratemethod pan et al using 4096 entry table processor maintains 12bit shift register global history register records outcome previous branches previous 12 branches executed sequence three taken branches six nontaken branches three taken branches tttnnnnnnttt register might store value 111000000111 2 3591 value used index 4096entry pattern history table providing contextual information particular patterns branches simulated two phts direct mapped pht degenerate twolevel correlation pht using variant mcfarling 16 found accurate method performs exclusiveor branch address global history register uses index pht phts simulated contained saturating updown counters total 1kbytes storage also simulated two btb configurations modeled 64entry 2way associative btb 256entry 4way btb latter configuration used intel pentium btbs simulated store taken branches btb predict fallthrough btb miss btb entry contains 2bit saturating updown counter used predict destination conditional branches btb simulations hold entries conditional branches unconditional branches indirect jumps procedure calls returns 5 26 4 branch alignment algorithms implemented branch alignment algorithm suggested pettis hansen 21 implement algorithms mcfarling hennessy bray flynn examine ifthenelse constructs limits effective unconditional branch 2 instruction correctly predicted fallthrough 1 instruction correctly predicted taken 2 instruction mispredicted table 1 cost cycles different branches ness since many transformations applied loops example algorithms would perform transformations shown figure 1 results perform branch alignment procedure program mainly concerned reducing branch cost although instruction cache performance may also improved represent procedure directed control flow graph containing set basic blocks represented nodes edges nodes trace program execution recording number times edge traversed call execution weight edge e node n transforming program look nodes degree one two unconditional branch basic block single outgoing edge taken edge conditional basic block two edges taken fallthrough edges fall basic block outgoing fallthrough edge edges given weight zero considered applying branch alignment thus ignore indirect branches procedure returns subroutine calls section discuss three branch alignment algorithms greedy pettis hansen 21 proposed two heuristics align branches describe bottomup greedy algorithm since better performance greedy algorithm directed towards btfnt architecture consider implications different branch architectures terminology 21 chain contiguous sequence basic blocks threaded head tail pointers first basic block chain null head pointer last basic block chain null tail pointer algorithm aligns procedure turn edge source destination largest weight selected algorithm attempts position node fallthrough node already fallthrough basic block already head two basic blocks combined chain otherwise blocks cannot linked basic blocks part existing chains two chains merged basic blocks linked repeated edges examined chains longer merged pettis hansen implemented technique hp parisc architecture architecture uses btfnt conditional branch prediction model edges procedure examined precedence relation defined chains determine ordering chains would achieve best prediction using btfnt model chains positioned using precedence relation inserting unconditional branches needed cost greedy algorithm consider underlining architecture constructing chains include underlining architecture costs algorithms order reduce cost branches beyond greedy algorithm architecture assumesspecific costs different branches shown table 1 cost transformation algorithm tries minimize cost branches procedure using simple heuristics hoping local minimization result global performance improvement greedy algorithm cost algorithm starts edge highest weight pick edge determine fallthrough locally benefit program using cost model trying link examine predecessors see cost effective connect another node algorithm considers basic blocks one two exit edges consider two possible alignments singleexit nodes examine cost aligning edge fall thereby avoiding unconditional branch adding unconditional branch example singleexit node could either include chain insert jump end allowing different chains conditional branches examine three possible alignments assume another edge 2 consider including 2 edge current chain adding jump end making jump fallthrough latter transformation may useful cost effective 2 fallthroughs chains certain cases aligning either edge conditional branch canimprove performanceon fallthroughandbtfnt archi tectures example consider loop consisting single basic block shown figure 2 using fallthrough model original loop node 4 incurs five cycle penalty one cycle branch instruction four cycles misprediction penalty using costmodel costeffective invert sense conditional ending block follow block inserted jump instruction combination takes three cycles correctly predicted conditional branch unconditional branch single misfetch penalty loop structured way illustrated point using single block loop greedy algorithm would restructure loops occur frequently try15 simulation study showed cost heuristic gave sizable improvements fallthrough architecture modest improvements btfnt negligible improvements likely briefly considered using cost model assess cost every possible basic block alignment using exhaustive search selecting minimal cost ordering practice sounds expensive common case procedures contain 515 basic blocks however programs procedures containing hundreds blocks making exhaustive search impossible procedures example gcc program contains procedure yyparse containing 712 basic blocks however many edges never executed large procedures basic blocks contribute execution time devised heuristic balanced time performance procedurewe select 15 frequently executededges attempt possible alignments nodes select cda9000a original code b aligned figure 3 example illustrating try15 reduces branch costs darkened edges fallthrough dotted edges taken nodes represent basic blocks next 15 edges allows us try possible combinations group 15 nodes possibilities try node similar described cost algorithm singleexit nodes unconditional fall basic blocks two possibilities make outgoing edge either fall taken edge nodes twoexit edges condi tional branches try aligning separately two outgoing edgesas fallthrough try neither outgoing edges fallthrough call try15 method heuristic took time greedy cost heuristics produced better results still ran minutes considering 10 nodes time gave slightly worse results try15 programs took less minute run still resulted better performance greedy algorithm improve performance algorithm examined edges executedmore eliminated half edges consideration program profiles used combined program one could reduce execution time try15 algorithm examining conditional branches account 99 executed branches branch alignment algorithms aligning loops difficult one case heuristics perform better greedy algorithm figure 3a shows fragment code loop greedy algorithm would modify code assuming chooses align edge whereas try15 algorithm transforms code shown figure 3b note transformed code unconditional branch c removed using cost model table 1 likely btfnt architecture execution cost original code edgeweightsshown 900089998999 21 cycles cost transformed version 8999 9000 cycles reduces branch execution cost 33 ideally want likely path loop single chain greedy cost algorithms examine enough loop minimize cost one main reasons try15 heuristic able produce better results algorithms try15 heuristic try combinations find correct place break loop 5 experimental methodology constructed two tools study branch alignment initially simulated several different branch architectures using trace driven simulation later implemented different branch alignment algorithms using om 24 25 system linktime code trans formation simulations provide detailed insight branch alignment useful different branch architectures implementation illustrates techniques practical value simulation study instrumented programs spec92 benchmark suite programs including objectoriented programs written c used atom 23 instrument programs due structure atom need record traces could trace longrunning programs programs compiled dec 3000400 using alpha processor using either dec c compiler dec c compiler systems running standard osf1 v13 operating systems programs compiled standard optimization constructed several simulators analyze program simulator run collect information branches targets second time use profile information prior run spec92 programs used largest input distributed spec92 suite table 2 shows basic statistics programs instru mented first columns lists number instructions traced second column gives percentage instructions cause break control flow columns labeled q50 q90 q99 q100 show number branch instruction sites contribute 50 90 99 100 executed conditional branches program next column static shows total number conditional branch sites program thus doduc three branch instructions constitute 50 executed branches taken column shows percentage conditional branches taken execution last five columns provide details five types breaks control flow encountered tracing conditional branches cbr indirect jumps ij unconditional branches br procedure calls call procedure returns ret note dynamic dispatch calls implemented indirect jumps c therefore included indirect jump metric programs include cfront version 301 att c language preprocessor written c groff version ditroff text formatter written c idl c parser corba interface description language db version deltablue constraint solution system written c formating system selected programs found spec92 suite typify behavior seen large programs c programs 6 alternate programs used sizable inputs hoped would exercise large part program example e x program formated 45page document 6 results results rearrange basic blocks within proce dure perform procedure splitting procedure rearranging since branch alignment method adds removes instructions program clear cut performance metric compare performance different alignments simple metrics prediction accuracy useful one method may removed added unconditional branches achieve particular branch alignment define branch execution penalty bep execution penalty associated misfetched mispredicted branches simulations assumed misfetched branch causes one cycle misfetch penalty mispredicted branch causes four cycle mispredict penalty static branch pht architec tures unconditional branches correctly predicted taken conditional branches direct procedure calls cause misfetch penalties whereas mispredicted conditional branches mispredicted returns indirect jumps cause mispredict penalties since btb architecture tries predict types branches taken branches pro cedure calls unconditional jumps taken conditional branches found btb necessarily cause misfetch penalties static dynamic architecture simulations simulated 32entry return stack 12 accurate predicting destination return instructions order evaluate performance different alignments architectures add bep number instructions executed aligned program divide number instructions executed original program essentially defines cycles per instruction relative original program also assumes instruction takes one cycle example original program issues 1000 instructions encounters 347 cycles branch penalties would cpi 1347 modified program issues 978 instructions assuming branches avoided incurred 347 cycles branch penalties would relative cpi 978 3471000 1325 cycles call relative cpi since dividing cost aligned program number instructions original program table 3 shows relative cpi program using various alignments three static branch architectures table also shows percent executed conditional branches fallthrough alignment performed varying architectures percent fallthrough branches change pettis algorithm varying branch architec tures whereas fallthrough percentage try15 algorithm changes architecture since cost model algorithm different architecture table 4 shows relative cpi pht btb architectures arithmetic averages shown group programs specfp92 specint92 orig column architecture shows performance instrumented traced original program likely architecture used profiles used create branch alignments order predict likely branch direction given branch site architecture use input align program measure improvement alignment branch alignment heuristics use architectural cost model usually perform better simpler greedy algorithm insns conditional branches percentage breaks tracing program traced breaks q50 q90 q99 q100 static taken cbr ij br call ret doduc 1149864756 853 3 175 296 1447 7073 4868 8131 001 497 686 686 hydro2d 5682546752 628 14 74 spice su2cor 4776762363 436 8 26 compress 92629658 1391 4 12 espresso 513008174 1711 44 163 470 1737 4568 6190 9325 020 188 229 239 gcc 143737915 1597 245 1612 3724 7640 16294 5942 7885 286 575 604 649 li 1355059387 1767 sc 1450134411 2093 14 94 336 1471 4478 6688 8596 098 262 518 526 cfront 19001390 1608 112 946 3055 5783 15509 5318 7345 217 640 872 926 groff 41522284 1610 86 372 1021 2511 7434 5417 6612 480 780 877 1251 table 2 measured attributes traced programs particularly notable fallthrough architecture fallthrough architecture longer realistic architecture consider used combination btbs fallthrough predicted btb miss improved performance occurs try15 heuristic align either outgoing edges conditional branches instead unconditional branches added one conditional branch edges take advantage fallthrough prediction cost model fact try15 heuristic converts 99 seen table 3 conditional branches programs fallthrough fallthrough model adding unconditional jump works especially well single basic block loops end conditional branch described earlier alvinn many fortran programs btfnt architecture sees reasonable improvement branch alignment btfnt architecture difficult create chains btfnt architecture forming chains known taken branch located final procedure chains formed laid destination taken branch could placed current node affecting final branch prediction costs small benefit likely architecture occurs eliminate misfetch penalty many branches remove unconditional branches likely execution path eliminating instruction misfetches increasingly important superscalar architectures become common fourissue superscalar architecture could encounter branch every two three cycles benefit architectures frequent fallthrough branches however relative cpi metric shown reflects improvement single issue architecture cost model used static architectures different dynamic architectures examining costs aligning conditional branch static architecture costs aligning conditional branch clear cut meaning one targets conditional branch predicted must always mispredicted dynamic architectures case order compensate increased accuracy predicted conditional branches cost model pht architectures assume conditional branches mispredicted 10 time similarly btb architectures also assume conditional branches mispredicted 10 time addition assume btb architectures 10 miss rate means taken unconditional conditional branches cause misfetch penalty 10 time seen table 4 branch alignment offers improvement pht architectures little improvement btb architectures except small btbs likely architecture major improvement performance pht architecture comes moving unconditional branches frequently executed path reducing misfetch penalty occurs taken conditional branches original program performance btb architecture already efficient stores predicts indirect jumps procedure calls unconditional conditional branches small btb architecture benefit branch alignment larger btb since taken branches stored btb therefore removing unconditional branches making branches fallthrough cause aligned program use less entries btb important observation branch alignment reduces difference performancebetween various branch architectures example aligned fallthroughandbtfnt architectures almost identical performance slightly slower likely pht architectures btb architecture relative cycles per instruction fallthrough conditional branches fallthrough btfnt likely fallthrough btfnt likely program orig greedy try15 orig greedy try15 orig greedy try15 orig greedy try15 try15 try15 alvinn 135 134 117 109 109 109 109 109 109 223 376 9957 371 375 doduc 115 109 105 109 104 104 105 104 103 5132 6890 9508 6877 9224 hydro2d 118 110 106 110 110 104 106 104 104 2666 5768 9544 5343 5345 ora 113 102 102 112 102 105 105 102 102 4676 9467 9496 9036 9050 spice 134 129 125 115 114 113 112 111 111 2837 3837 9231 3742 3774 su2cor 111 107 105 105 104 104 104 104 103 2693 5227 8982 3812 3812 tomcatv 113 108 104 108 102 102 103 102 102 072 4371 9938 4371 4371 compress 135 114 112 126 117 110 116 112 110 3175 8173 8414 6872 6872 li 127 112 111 126 114 113 115 110 110 5270 8303 8563 8303 8311 sc 151 127 118 136 117 116 120 114 114 3312 6637 9091 6566 6572 cfront 125 112 110 123 110 110 113 109 109 4682 8105 8964 8052 8120 groff 131 111 110 126 117 109 114 109 108 4586 8420 9406 8216 8453 idl 131 114 113 130 113 113 119 113 113 5330 9037 9611 8996 9000 tex 120 110 108 117 109 109 110 107 107 4253 7323 8743 7067 7143 avg 128 114 112 125 113 112 115 111 111 4633 8056 9149 7936 8030 table 3 relative cycles per instruction static prediction architectures corresponding fallthrough branches direct mapped pht 4096 correlation pht 64entry 2way btb 256entry 4way btb program orig greedy try15 orig greedy try15 orig greedy try15 orig greedy try15 alvinn 109 109 109 109 109 109 101 100 100 100 100 100 doduc 106 104 104 106 103 104 103 102 102 102 101 101 hydro2d 105 104 104 105 104 104 101 102 101 101 102 101 spice 112 111 112 111 110 111 104 104 107 104 104 107 su2cor 105 104 104 105 104 104 102 102 101 102 102 101 compress 115 112 110 115 111 109 108 108 106 106 108 106 espresso 117 115 115 114 112 112 111 110 110 107 109 109 gcc 117 112 112 117 111 111 118 110 110 112 108 108 li 115 111 110 112 108 107 113 107 107 107 106 105 sc 117 111 111 116 110 110 108 104 104 104 103 103 cfront 114 109 109 114 109 109 119 109 109 113 107 107 groff 114 109 108 113 108 107 113 107 105 106 105 103 idl 119 113 112 118 112 112 111 102 102 103 101 101 tex 110 107 107 109 106 106 108 105 104 105 104 104 avg 115 111 111 114 110 110 112 105 105 106 104 104 table 4 relative cycles per instruction dynamic prediction architectures alvinn ear compress eqntott espresso gcc li sc060810relative execution time original pettis hansen figure 4 total execution time improvement dec 3000600 alpha axp spec92 c programs best overall performance comparing static btfnt architecture performance 4096entry correlated pht alignment pht architecture performs 7 better btfnt architecture alignment performs 2 better btfnt architecture taking averaged cpi simulated programs lastly note significant difference different program classes specint92 programs see benefit branch alignment specfp92 programs reason seen table 2 specfp92 programs 65 instructions executed cause break control flow whereas specint92 programs 16 instructions cause break control 61 performance comparison implemented greedy try15 alignment algo rithms figure 4 indicates improvement total execution time spec92c programs dec 3000600 alpha axp 21064 processor running osf2 v20 program show execution time original program compiled native compiler transformed program using pettis hanson greedy algorithm transformed program using try15 algorithm scaled execution time program time original program programs compiled previously described linked used om link resulting object files standard libraries using omfull described 25 therefore original program execution times shown figure 4 use standard om link time optimizations modified om produce desired branch alignments used link programs alpha axp 21064 dual issue architecture uses combination dynamic static branch prediction instruction onchip cache single bit indicating previous branch direction instruction cache line flushed bits initialized bit instruction sign displacement located thus performance expected architecture cross direct mapped pht table btfnt architecture surprisingly floating point programs alvinn ear see benefit branch alignment agrees simulation results believe benefit could gained single loop basic blocks shown figure 2 duplicated gcc eqntott sc programs benefit branch alignment difficult understand actual performance improvement branch alignment comes tools allow us instrument measure transformed programs trace simulations completely model alpha axp architecture simulations described previous section two different chain layout algorithms used greedy try15 alignments one algorithm laid chains procedure starting highest executed chain continuing lowest executed chain algorithm laid chains using btfnt model described 21 implemented chain layouts om found algorithms laid chains highest executed lowest executed performed slightly better one laid chains using btfnt model believe performance comes fact laying chains highest lowest executed satisfies many branch priorities btfnt model time allowing better cache locality therefore results shown figure 4 uses greedy alignment used simulations except btfnt simulation highest lowest chain ordering om also implemented btfnt pht btb alignments try15 used simulations found alignment performed slightly better pht alignment better btfnt alignment recall creating pht alignment taken conditional branches unconditional branches one cycle misfetch penalty associated cost model contrast btb cost model assumes 10 btb miss rate means assumes one cycle misfetch penalty occurs 10 taken branches alpha axp 21604 architecture misfetch penalties squashed pipeline currently waiting stalls fore cost model would actually fit alpha axp 21604 architecture would assume taken branches squashed rufely 30 time results figure 4 uses alignment used btb simulations shown table 4 conclusions simulated number branch prediction architectures showed branch alignment useful architecture simulation results assumed single issue architecture wide issue architectures become popular branch alignment algorithms larger impact performance programs alignment algorithms implemented saw 16 improvement execution time dual issue alpha axp 21604 architecture total reduction program execution time results combination reduction misfetch misprediction penalties instruction cache miss rates number instructions issued described improvedalignment algorithm also showed branchesdetermine branch behavior manycommon benchmark programs technique addresses broader class program structures 15 4 anddoes require recompilation needed hwu chang18 pettis hansen 21 haveshownhow simple object code transformation taking minutes run even large programs improve programs performance branch alignment benefit programs integer programs reasonable improvement seen various branch prediction architectures acknowledgments wed like thank alan eustace amitabh srivastava developing atom especially amitabh srivastava developing om wed also like thank keith farkas dennis lee anonymous reviewers useful comments work funded part nsf grant asc9217394 arpa fellowship decwrl summer internship work part continued effort make languages c suitable scientific computing r performance enhancement paging systems program analysis trans formation tera computer system branch prediction free strategies branch target buffers 21st annual annual international symposium computer architecture quantifying behavioral differences c c branch folding crisp microprocessor reducing branch delay zero improving locality critical working sets predicting conditional branch directions previous runs program program restructuring virtual memory branch history table prediction moving target branches due subroutine returns optimal sequential partitions graphs branch prediction strategies branch target buffer design program optimization instruction caches combining branch predictors reducing cost branches hwu pohua p improvingthe accuracyof dynamic branch target buffer design optimization profile guided code positioning study system building customized program analysis tools practical system intermodule code optimizations linktime comprehensive instruction fetch mechanism processor supporting speculative execution comparisonof dynamic branchpredic tors use two levels branch history tr reducing cost branches branch folding crisp microprocessor reducing branch delay zero compiletime program restructuring multiprogrammed virtual memory systems program optimization instruction caches achieving high instruction cache performance optimizing compiler profile guided code positioning branch history table prediction moving target branches due subroutine returns strategies branch target buffers improving accuracy dynamic branch prediction using branch correlation predicting conditional branch directions previous runs program comprehensive instruction fetch mechanism processor supporting speculative execution branch prediction free comparison dynamic branch predictors use two levels branch history linktime optimization address calculation 64bit architecture atom fast accurate instruction fetch branch prediction tera computer system optimal sequential partitions graphs improving locality critical working sets branch target buffer design optimization study branch prediction strategies ctr chunling hu john mccabe daniel jimnez ulrich kremer camino compiler infrastructure acm sigarch computer architecture news v33 n5 december 2005 steven wallace nader bagherzadeh modeled measured instruction fetching performance superscalar microprocessors ieee transactions parallel distributed systems v9 n6 p570578 june 1998 nicolas gloy michael smith cliff young performance issues correlated branch prediction schemes proceedings 28th annual international symposium microarchitecture p314 november 29december 01 1995 ann arbor michigan united states icheng k chen john coffey trevor n mudge analysis branch prediction via data compression acm sigplan notices v31 n9 p128137 sept 1996 young david johnson michael smith david r karger nearoptimal intraprocedural branch alignment acm sigplan notices v32 n5 p183193 may 1997 robert cohn p geoffrey lowney hot cold optimization large windowsnt applications proceedings 29th annual acmieee international symposium microarchitecture p8089 december 0204 1996 paris france brad calder dirk grunwald joel emer system level perspective branch architecture performance proceedings 28th annual international symposium microarchitecture p199206 november 29december 01 1995 ann arbor michigan united states gadi haber moshe klausner vadim eisenberg bilha mendelson maxim gurevich optimization opportunities created global data reordering proceedings international symposium code generation optimization feedbackdirected runtime optimization march 2326 2003 san francisco california anton ertl david gregg optimizing indirect branch prediction accuracy virtual machine interpreters acm sigplan notices v38 n5 may brad calder dirk grunwald amitabh srivastava predictability branches libraries proceedings 28th annual international symposium microarchitecture p2434 november 29december 01 1995 ann arbor michigan united states alex ramirez oliverio j santana josep l larribapey mateo valero fetching instruction streams proceedings 35th annual acmieee international symposium microarchitecture november 1822 2002 istanbul turkey minghui yang gangryung uh david b whalley improving performance branch reordering acm sigplan notices v33 n5 p130141 may 1998 alex ramirez josep l larribapey mateo valero software trace cache ieee transactions computers v54 n1 p2235 january 2005 daniel jimnez code placement improving dynamic branch prediction accuracy acm sigplan notices v40 n6 june 2005 minghui yang gangryung uh david b whalley efficient effective branch reordering using profile data acm transactions programming languages systems toplas v24 n6 p667697 november 2002 amir h hashemi david r kaeli brad calder efficient procedure mapping using cache line coloring acm sigplan notices v32 n5 p171182 may 1997 bernard goossens david defour instruction register file microarchitecture future generation computer systems v21 n5 p767773 may 2005 paramjit oberoi gurindar sohi parallelism frontend acm sigarch computer architecture news v31 n2 may nikolas gloy michael smith procedure placement using temporalordering information acm transactions programming languages systems toplas v21 n5 p9771027 sept 1999 glenn reinman brad calder todd austin optimizations enabled decoupled frontend architecture ieee transactions computers v50 n4 p338355 april 2001 matthew arnold david grove collecting exploiting highaccuracy call graph profiles virtual machines proceedings international symposium code generation optimization p5162 march 2023 2005 wankang zhao david whalley christopher healy frank mueller improving wcet applying wc codepositioning optimization acm transactions architecture code optimization taco v2 n4 p335365 december 2005 ann gordonross frank vahid nikil dutt first look interplay code reordering configurable caches proceedings 15th acm great lakes symposium vlsi april 1719 2005 chicago illinois usa brad calder dirk grunwald donald lindsay james martin michael mozer benjamin zorn corpusbased static branch prediction acm sigplan notices v30 n6 p7992 june 1995 glenn reinman todd austin brad calder scalable frontend architecture fast instruction delivery acm sigarch computer architecture news v27 n2 p234245 may 1999 mikko h lipasti william j schmidt steven r kunkel robert r roediger spaid software prefetching pointer callintensive environments proceedings 28th annual international symposium microarchitecture p231236 november 29december 01 1995 ann arbor michigan united states brad calder dirk grunwald michael jones donald lindsay james martin michael mozer benjamin zorn evidencebased static branch prediction using machine learning acm transactions programming languages systems toplas v19 n1 p188222 jan 1997 sangwook p kim gary tyson analyzing working set characteristics branch execution proceedings 31st annual acmieee international symposium microarchitecture p4958 november 1998 dallas texas united states young michael smith static correlated branch prediction acm transactions programming languages systems toplas v21 n5 p10281075 sept 1999 pierre michaud andr seznec stphan jourdan exploration instruction fetch requirement outoforder superscalar processors international journal parallel programming v29 n1 p3558 february 2001
loops almost linear time loop identification essential step performing various loop optimizations transformations classical algorithm identifying loops tarjans intervalfinding algorithm restricted reducible graphs recently serveral people proposed extensions tarjans algortihm deal irreducible graphs havlak presents one extension constructs loopnesting forest arbitrary flow graph show running time algorithm quadratic worstcase almost linear claimed show modify algorithm make run almost linear time next consider quadratic algorithm presented sreedhar et al constructs loopnesting forest different one constructed havlak algorithm show algorithm adapted run almost linear time finally consider algorithm due steensgaard constructs yet antoher loopnesting forest show algorithm made efficient borrowing ideas algorithms discussed earlier b introduction loop identification interesting control flow analysis problem several applications classical algorithm identifying loops tarjans interval finding algorithm tarjan 1974 restricted reducible graphs cently several people proposed extensions tarjans algorithm deal irreducible graphs paper study improve three recently proposed algorithms identifying loops irreducible graph first algorithm study due havlak 1997 show running time algorithm quadratic worstcase almostlinear claimed show modify algorithm make run almost authors address g ramalingam ibm tj watson research center po box 704 yorktown heights ny 10598 usa email ramawatsonibmcom permission make digitalhard copy part material without fee granted provided copies made distributed profit commercial advantage acm copyrightserver notice title publication date appear notice given copying permission association computing machinery inc acm copy otherwise republish post servers redistribute lists requires prior specific permission andor fee c g ramalingam linear time next consider quadratic algorithm presented sreedhar et al 1996 constructs loop nesting forest different one constructed havlak algorithm show algorithm adapted run almost linear time final section present yet another loop nesting forest defined steensgaard 1993 discuss aspects sreedhar et al algorithm combined steensgaards algorithm improve efficiency steensgaards algorithm 2 terminology notation flowgraph connected directed graph v e startend consisting set vertices v set edges e distinguished start end vertices assume without loss generality start predecessors denote number vertices given graph n number edges given graph assume reader familiar depth first search hopcroft tarjan 1973 abbreviated dfs depth first search trees see cormen et al 1990 example edge x graph said dfs tree edge x parent dfs tree dfs forward edge x ancestor parent dfs tree dfs backedge x descendant dfs tree dfs cross edge otherwise omit prefix dfs confusion likely straightforward augment dfs compute information help answer ancestor relation queries form u ancestor v dfs tree constant time see havlak 1997 example refer order vertices visited dfs dfs order also assume reader familiar concepts reducible irreducible flowgraphs see aho et al 1986 discussion concepts denote inverse ackermann function ffi j inverse ackermann function slow growing function may considered constant practical purposes see cormen et al 1990 discussion function appear single wellaccepted definition loop certain irreducible flowgraphs three algorithms considered paper identify different set loops suitability algorithms depends intended application however following facts hold true three algorithms loop corresponds set vertices flowgraph l x l two loops identified one algorithms either l x l mutually disjoint one completely contained hence nesting containment relation loops represented forest refer loop nesting forest identified corresponding algorithm vertex belonging loop said entry vertex loop predecessor outside loop given flowgraph algorithms described paper conceptually modify flowgraph execution proceeds thus refer flowgraph worth remembering dont mean fixed input flowgraph flowgraph constantly changes course execution changes identifying loops almost linear time delta 3 flowgraph however explicitly represented instead unionfind data structure used implicitly represent changes flowgraph 3 tarjans algorithm reducible graphs begin brief description tarjans loop nesting forest algorithm construct consider reducible graph every vertex w target backedge identifies loop lw w header let bw set backedgeg loop lw consists w vertices graph reach vertex bw without going w two loops l x l either l x l must disjoint one must completely contained hence nesting containment relation loops represented forest yields loop nesting forest provides definition tarjans loop nesting forest reducible graphs let us see forest constructed efficiently tarjans algorithm performs bottom traversal depthfirst search tree identifying inner nested loops first identifies loop algorithm col lapses single vertex x set vertices collapsing x mean replacing set vertices x single representative vertex r x graph vertex successor predecessor r x collapsed graph iff successor predecessor vertex x original graph vertex w visited traversal determined loop header incoming backedges explained let bw set fzjz w backedgeg children w 1 loop nesting forest identified performing backward traversal collapsed graph identifying vertices reach vertex bw without going w children w identified w children merged collapsed together single vertex identifies newly constructed loop lw traversal continues next vertex implementation collapsing vertices achieved using classical unionfind data structure see tarjan 1983 cormen et al 1990 thus outermost loops identified far maintained set find operation vertex x returns header outermost loop containing x vertex x loop set vertices collapsed performing union operation vertices set complete description algorithm pseudocode appears figure 1 let us analyze complexity algorithm procedure findloop invoked exactly every vertex hence line 8 executed every vertex lines 1016 executed every vertex innermost loop containing identified result total cost executing lines 8 1016 perform one find operation per edge original graph similarly lines 34 executed every vertex z costs 1 union operation whole algorithm performs n union operations find operations n denotes number vertices graph denotes number edges graph hence whole algorithm runs strictly speaking mean children node representing loop lw however simplify matters somewhat using header vertex w represent loop lw loop nesting forest since vertex header one loop g ramalingam 1 procedure collapseloopbody loopheader 2 every z 2 loopbody 3 loopparentz loopheader 4 lpunionz loopheader use loopheader representative merged set 5 end 6 procedure findlooppotentialheader potentialheader backedge worklist empty 10 remove arbitrary element worklist add loopbody 12 every predecessor z z backedge 13 lpfindz 62 loopbody fpotentialheaderg worklist 14 add lpfindz worklist 15 end 16 end 17 end 18 loopbody empty 19 collapse loopbody potentialheader procedure tarjansalgorithm g 22 every vertex x g loopparentx null lpaddx end 23 every vertex x g reversedfsorder findloopx end fig 1 tarjans algorithm constructing loop nesting forest reducible graph lp partition vertices graph function lpaddz initially places z equivalence class function lpunionu v merges us vs classes one using v representative element merged class function lpfindz returns representative element zs equivalence class time omnffmnn unionfind implemented using standard path compression unionbyrank techniques tarjan 1983 cormen et al 1990 4 havlaks algorithm havlak 1997 recently presented extension tarjans algorithm handles irreducible graphs well show algorithm potentially quadratic even though havlak describes algorithm almostlinear precisely show algorithm worstcase may take n 2 time even graphs number edges havlaks extension tarjans algorithm modifies loop body identification step follows given vertex potentialheader children potentialheader loop nesting forest identified performing backward traversal collapsed graph traversal restricted set descendants potentialheader dfs tree particular lines 1315 tarjans algorithm figure modified lines executed z descendant potentialheader dfs tree z descendant potentialheader dfs tree edge z ignored replaced edge z potentialheader collapsed flowgraph note reducible graph z identifying loops almost linear time delta 5 1 2h e end k fig 2 counterexample illustrating havlaks algorithm may perform quadratic number unionfind operations solid lines indicate dfs tree edges dashed lines indicate remaining graph edges guaranteed descendant potentialheader dfs tree last step described precisely source problem possible single edge z processed multiple times time edge header loop containing example shown figure note vertices h k h 1 targets backedges hence identified loop headers order loop bodies also constructed order edge k h k processed replaced successively edges k h every k similarly every edge processed times thus algorithm end performing operations example example presents lower bound complexity havlaks al gorithm also upper bound havlaks algorithm particular modified loop lines 1215 perform n find operations since lines 1016 may performed every vertex whole algorithm performs union operations 2 find operations implies upper bound running time algorithm since ffn 2 n o1 see tarjan 1983 upper bound simplifies 2 6 delta g ramalingam 0 z 1 j k fig 3 modifying havlaks algorithm run almost linear time 0 edge flowgraph 1 delta delta delta k shown bold vertices ancestors 0 dfs tree identified loop headers havlaks algorithm z least common ancestor 0 dfs tree j proper descendant z descendant j1 havlaks algorithm edge 0 used constructing bodies loops headers 1 j used construction loop body j1 5 almost linear time version havlaks algorithm describe modification havlaks algorithm run almost linear time given vertex 0 control flow graph consider 0 ancestors havlaks loop nesting forest see figure 3 particular every 0 let i1 denote header innermost loop containing havlaks loop nesting forest thus 1 2 delta delta delta sequence loops containing 0 innermost outermost identified headers note i1 must ancestor tree consider edge 0 consider largest j descendant j dfs tree words descendant j1 j dfs tree consider havlaks algorithm processes edge 0 every body loop header constructed edge considered since source edge descendant edge replaced edge finally body loop header j1 constructed edge j appear proper edge vertex added loop body would desirable replace edge 0 edge j one step instead j steps turns let z denote least common ancestor 0 dfs tree note z must lie j j1 dfs tree consider moment havlaks algorithm visits z bottom traversal dfs tree point loops headers 1 j identified loop header j1 yet identifying loops almost linear time delta 7 1 procedure markirreducibleloopsz 3 6 null 5 mark u irreducibleloopheader 8 end procedure processcrossfwdedgesx 10 every edge z crossfwdedgesx 11 add edge findy findz graph 13 end 14 procedure modifedhavlakalgorithm g 15 every vertex x g 16 loopparentx null crossfwdedgesx fg 18 end 19 every forward edge cross edge x g 20 remove x g add crossfwdedgesleastcommonancestoryx 21 end 22 every vertex x g reversedfsorder 23 processcrossfwdedgesx 24 findloopx procedure findloop figure 1 25 end fig 4 modified version havlaks algorithm rlh second unionfind data structure used map loop headers header innermost reducible loop containing constructed find operation 0 return j stage suggests following algorithm initial pass remove every cross edge forward edge x graph attach list associated least common ancestor x almostlinear time see tarjan 1979 cormen et al 1990 problem 223 run havlaks algorithm modified follows whenever main bottomup traversal visits vertex w processes list crossforward edges associated first pass adds edge f indy f indx graph immaterial whether add edge f indx edge f indy f indx graph modified algorithm appears figure 4 note modification implies use procedure findloop tarjans algorithm unchanged modified algorithm runs almost linear time constructs loops loop nesting forest havlaks algorithm however quite complete yet addition constructing loop nesting forest havlaks algorithm also marks loops reducible irreducible straightforward distinguish reducible loops irreducible loops modified algorithm described show extra piece information computed desired consider example figure 3 presence edge 0 means g ramalingam loops headers 1 j irreducible hence algorithm replaces edge 0 edge f indy j explained need mark loop headers 1 j irreducible procedure markirre ducibleloops figure 4 walking loopnesting tree containing 0 naively explained algorithm end quadratic avoid quadratic behavior using standard path compression technique particular consider lines 56 mark vertex u irreducible loop header traverses parent let us say step scans looptree edge utilize second unionfind datastructure scan every looptree edge particular union operation line 7 ensures tree edge never scanned since find operation line 4 skips past previously scanned edges safe since reason mark vertex irreducible already marked resulting algorithm runs almost linear time 6 sreedhargaolee algorithm sreedhar et al 1996 present different algorithm constructing loop nesting forest algorithm utilizes dj graph essentially combines control flow graph dominator tree one structure however simplify discussion algorithm using control flow graph dominator tree instead dj graph let levelu denote depth node u root dominator tree root level 0 let v denote set vertices level ie set vertices u maximum level dominator tree sreedhar et al algorithm processes vertices dominator tree bottom particular level l p 1 processed follows first step identifies reducible loops level l vertices level l scanned vertex n one incoming backedges whose source dominated n identified header reducible loop body reducible loop identified tarjans algorithm traversing graph backwards sources backedges identifying vertices reach backedges without going n reducible loop collapsed single vertex tarjans algorithm vertex n level l one incoming backedges whose source dominated n n one entries irreducible loop vertices level l processed identify reducible loops construct irreducible loops level l vertex n level l one incoming backedges whose source dominated n requires processing subgraph collapsed flowgraph consisting vertices level greater equal current level l set vertices identify strongly connected components sccs nontrivial strongly connected component graph irreducible loop level l collapsed single vertex nontrivial scc mean scc consisting one vertex establish property loops identified algorithm useful subsequently identifying loops almost linear time delta 9 lemma 1 vertex entry vertex one irreducible loop proof note two irreducible loops identified level l mutually disjoint hence two loops cannot common entry vertex let l irreducible loop identified level l show entry vertex l must also vertex level l immediately implies irreducible loops belonging different levels cannot share common entry vertex either lemma follows let f denote subgraph dominator tree consisting vertices level greater equal l thus f forest consisting subtrees dominator tree first note loop l must consist vertices least two different trees f loop consisting vertices one tree must reducible loop level l loop level greater l let u v vertices belonging different trees f let w root tree containing v path flowgraph u v must pass w otherwise w would dominator v hence loop l contains vertex v must also contain root tree f contains v let v vertex loop l let w root tree containing v assume v 6 w predecessor x v flowgraph must also tree rooted w straightforward property dominator tree follows x must also loop l since path x vertex loop namely v path vertex loop namely w x establishes vertex loop l predecessor outside l must root tree f roots trees f precisely vertices level l result follows sreedhar et al show algorithm described runs time omffm n km k number levels strongly connected component algorithm invoked worst case k resulting quadratic algorithm example figure 5 illustrates source quadratic behavior algorithm repeated application scc algorithm consider processing done level example level contains irreducible loop consisting vertices b c e constructing irreducible loop requires identifying sccs graph consisting vertices 1 k b c e vertices notice vertices 1 k f 1 f k visited belong nontrivial scc similarly apply scc algorithm level lower level may end visiting vertices 1 k f 1 f k worst case may end visiting vertices times resulting quadratic complexity show careful implementation scc identification phase ensure algorithm runs almost linear time observe vertices b c e collapsed single vertex say l representing irreducible loop vertices never visited true edges k b may visited later however edges actually represent edges collapsed graph cost visiting edges attributed cost visiting vertex l g ramalingam k k f ff 1 c e level i1 x level fig 5 example illustrating source quadratic behavior sreedhar et al algo rithm solid edges belong control flow graph dominator tree dashed edges control flow graph edges dominator tree goal perform irreducible loop construction level vertex x level j visited x belongs irreducible loop level follows consider strongly connected component consider vertex u component visited first depth first search clearly vertices component descendants vertex dfs tree thus start set incoming backedges u traverse graph backwards restricting traversal vertices descendants u dfs tree identify vertices belonging us strongly connected component without visiting vertices us scc process similar one used havlaks algorithm tarjansalgorithm identify loop body corresponding potential header vertex however note apply process start vertex first one scc visited dfs identify complete scc thus havlaks tarjans algorithm visit potential header vertices reverse dfs order want visit vertices order instead perform irreducible loop construction level l visiting set vertices level l dfs order visited vertex u belongs irreducible loop level l already constructed skip vertex continue next vertex otherwise incoming backedge belongs irreducible loop body loop identified traversing backwards sources backedges restricting traversal descendants u dfs tree modified algorithm appears figure 6 words explanation tarjans algorithm havlaks algorithm identify one loop per header vertex allowed us represent loop header vertex loop nesting forest however sreedhargaolee algorithm may identify two loops per header vertex reducible loop irreducible loop consequently use header vertex represent loop loop nesting forest instead identifying loops almost linear time delta 11 1 procedure findloopheader worklist worklist empty 3 create new vertex looprep predecessors header 5 worklist empty 6 remove arbitrary element worklist add loopbody 8 processedy true 9 every predecessor z 10 lpfindz descendant header dfs tree looprep graph 12 elsif lpfindz 62 loopbody worklist 13 add lpfindz worklist 15 end 16 end 17 collapse loopbodylooprep 18 end 19 procedure modifiedsreedhargaoleealgorithm g 20 every vertex x g 22 end 23 1 24 every x 2 leveli x backedge x dominates 26 27 end 28 every x 2 leveli dfsorder 29 processedx x backedge x dominates 33 end 34 end fig 6 modified version sreedhargaolee algorithm use new representative vertex algorithm explicitly identify loops consisting single vertex modified desired note construct level list vertices level dfs order easily enough initialize lists empty visit vertices dfs order appending visited vertex end list corresponding level let us analyze complexity algorithm observe lines 615 get executed every vertex lines perform indegreey find operations however lines executed vertices exist original graph also vertices created line 3 vertices created line 3 representatives loops collapsed graph hence complexity algorithm depends number g ramalingam end fig 7 example illustrating sreedhar et al algorithm identify loops identified steensgaard algorithm representatives created indegrees created vertices fall two categories reducible loop representatives irreducible loop representatives every vertex h original graph header one reducible loop results creation one reducible loop representative r h whose indegree bounded indegree h every irreducible loop two entry vertices vertices original graph indegree representative irreducible loop bounded sum indegrees entry vertices vertex original entry vertex one irreducible loop hence sum indegrees irreducible loop representatives bounded number edges original graph result whole algorithm performs union operations om find operations resulting complexity omffm n 7 steensgaards loop nesting forest section consider yet another loop nesting forest defined steensgaard 1993 outline steensgaards algorithm constructing forest also serves constructive definition structure steensgaard identifies loops graph top fashion identifying outer loops first nontrivial strongly connected components given graph constitute outermost loops vertex loop said generalized entry node loop predecessor outside strongly connected component edge vertex inside loop one generalized entry nodes said generalized backedge inner loopscontained given loop determined identifying strongly connected components subgraph induced given loop generalized backedges eliminated iterative process yields loop nesting forest let us briefly consider differences forest created steensgaards algorithm forest created sreedhargaolee algorithm one differ ence explained sreedhar et al 1996 sreedhargaolee algorithm identifying loops almost linear time delta 13 may identify reducible loops steensgaards algorithm extra step sreedhargaolee algorithm construct reducible loops eliminated difference disappears however also possible sreedhargaolee algorithm identify fewer loops steensgaards algorithm problem possible sreedhargaolee forest one irreducible loop nested inside another irreducible loop entry vertices level dominator tree example shown figure 7 illustrates example steensgaard algorithm identifies outer loop consisting vertices u v w x inner loop consisting vertices w x contrast sreedhargaolee algorithm identifies one loop consisting u v w x show steensgaards loop nesting forest constructed efficiently borrowing ideas described section 6 sreedhar et al 1996 simply modify irreducible loop construction phase algorithm described section 6 follows instead stopping identifying strongly connected components use steensgaardlike algorithm iteratively find loops nested inside irreducible loop words instead applying strongly connected components algorithm subgraph vertices level greater equal current level apply steensgaards algorithm subgraph symmetrically also possible modify steensgaards algorithm replacing use strongly connected components algorithm algorithm presented section 6 resulting algorithm asymptotic worstcase complexity steens gaards original algorithm quadratic size graph however practice potentially efficient steensgaards original algorithm since number iterations steensgaards algorithm performs within single irreducible loop identified sreedhar et al algorithm likely much smaller number iterations would perform whole graph 8 conclusion paper examined three algorithms identifying loops irreducible flowgraphs shown algorithms made efficient three algorithms construct potentially different loop nesting forests question arises relative advantages different algorithms havlaks approach disadvantage set loops found loop nesting forest constructed dependent depthfirst spanning tree dependent ordering outgoing edges every vertex particular represented single irreducible loop k entry vertices sreedhar gaolee forest may represented k irreducible loops nested within arbitrary order havlaks forest hence believe sreedhar gaolee loop nesting forest natural havlaks loop nesting forest however modified version havlaks algorithm simpler implement modified version sreedhargaolee algorithm since require construction dominator tree would worthwhile exercise adapt havlaks algorithm directly construct sreedhargaolee loop nesting forest think done formally established yet hand sreedhargaolee loop nesting forest steensgaards 14 delta g ramalingam loop nesting forest somewhat incomparable explained section 7 ideas behind approaches combined construct loop nesting forest refined either one resulting algorithm expensive almost linear time variation presented constructing sreedhar gaolee forest whether refined forest worth increased algorithm complexity depends intended application acknowledgements thank john field v sreedhar anonymous referees helpful comments r introduction algorithms nesting reducible irreducible loops efficient algorithms graph manipulation loops using dj graphs sequentializing program dependence graphs irreducible programs testing flow graph reducibility applications path compression balanced trees data structures network algorithms revised september tr data structures network algorithms compilers principles techniques tools introduction algorithms loops using dj graphs nesting reducible irreducible loops applications path compression balanced trees algorithm 447 efficient algorithms graph manipulation ctr fang liu jacob j flomenberg devaka v yasaratne sule ozev hierarchical variance analysis analog circuits based graph modelling correlation loop tracing proceedings conference design automation test europe p126131 march 0711 2005 g ramalingam loops dominators dominance frontier acm sigplan notices v35 n5 p233241 may 2000 dominance analysis irreducible cfgs reduction acm sigplan notices v40 n4 april 2005 loops dominators dominance frontiers acm transactions programming languages systems toplas v24 n5 p455490 september 2002 sebastian unger frank mueller handling irreducible loops optimized node splitting versus djgraphs acm transactions programming languages systems toplas v24 n4 p299333 july 2002 gregor snelting torsten robschink jens krinke efficient path conditions dependence graphs software safety analysis acm transactions software engineering methodology tosem v15 n4 p410457 october 2006
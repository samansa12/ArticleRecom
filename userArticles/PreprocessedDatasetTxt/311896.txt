staggered consistent checkpointing abstracta consistent checkpointing algorithm saves consistent view distributed applications state stable storage traditional consistent checkpointing algorithms require different processes save state time causes contention stable storage potentially resulting large overheads staggering checkpoints taken various processes reduce checkpoint overhead paper presents simple approach arbitrarily stagger checkpoints approach requires processes take consistent logical checkpoints compared consistent physical checkpoints enforced existing algorithms experimental results ncube2 presented b introduction applications executed large number processors either distributed environment multicomputers ncube subject processor failures consistent checkpointing commonly used technique prevent complete loss computation upon failure 1 2 4 5 8 11 13 17 consistent checkpointing algorithm saves consistent view distributed applications state stable storage often disk used stable storage loss computation upon failure bounded taking consistent checkpoints adequate frequency traditional consistent checkpointing algorithms require different application processes save state time causes contention stable storage multiple processors share stable storage potentially resulting significant performance degradation clearly processor access separate stable stor age contention occur 1 however many installations multicomputers distributed systems require multiple processors share stable storage staggering checkpoints taken various processes reduce overhead consistent checkpointing reducing stable storage contention observed plank 13 plank proposed techniques staggering checkpoints 13 however techniques result limited staggering processes checkpoints staggered moreover previous algorithms much control checkpoints stag gered ideally one would like able stagger checkpoints manner appropriate given system systems processors able make inmemory copy entire process state checkpoint staggering trivial case checkpoints first taken memory written stable storage one time paper considers systems feasible make inmemory copy entire process state situation may occur either memory size small ii memory may shared processes multiple applications making inmemory copy process one application may cause processes applications swapped degrading performance paper presents simple approach arbitrarily stagger checkpoints different stable storages accessed network network contention become bottleneck approach requires processes take consistent logical checkpoints compared consistent physical checkpoints enforced existing algorithms staggering elaborated later physical checkpoint copy process state logical checkpoint obtained saving sufficient information eg messages recover process state objective paper show checkpoints staggered controlled manner independent applications communication patterns present different variations algorithm illustrate approach interest practice experimental results one version algorithm ncube2 multicomputer presented paper organized follows section 2 discusses related work section 3 discusses notion logical checkpoint section 4 presents consistent checkpointing algorithms proposed chandy lamport 2 plank 13 section 5 presents proposed algorithm section 6 presents experimental results variations proposed scheme discussed section 7 section 8 summarizes paper related work plank 13 first observe stable storage contention problem consistent checkpointing suggested checkpoint staggering solution degree staggering planks algorithm based chandylamport algorithm 2 limited checkpoints many processes staggered contrast algorithm allows arbitrary controlled staggering checkpoints plank 13 also presents another approach staggering checkpoints applicable wormhole routed networks algorithm also permit arbitrarycontrolled staggering fowler zwaenepoel 6 present algorithm determining causal breakpoints purpose debugging part breakpoint algorithm establish consistent recovery lines using algorithm similar approach considered modification algorithm 6 facilitate checkpoint staggering algorithm 6 designed debugging purposes various possibilities checkpoint staggering different approaches establishing checkpoints considered long et al 11 discuss evolutionary checkpointing approach similar logical checkpointing algorithm staggers checkpoints scheme 11 allow staggering 11 also assumes synchronized communication upper bound communication delays assumptions made proposed scheme wang et al 18 introduced term logical checkpoint present algorithm determine recovery line consisting consistent logical checkpoints failure occurs recovery line used recover failure goal determine latest consistent recovery line using information saved stable storage message logging independent checkpointing schemes 8 also effectively determine recovery line consisting consistent logical checkpoints failure occurs schemes failurefree operation process allowed independently take checkpoints log messages hand scheme coordinates logical checkpoints failure occurs logical checkpoints used recover future failure one consequence approach scheme log messages messages make logical checkpoints consistent logged staggering checkpoints taken various processes tends increase elapsed time sometimes called checkpoint latency 15 checkpointing algorithm progress previous work 15 shows large increase checkpoint latency acceptable accompanied even small decrease checkpoint overhead therefore techniques staggering interest even though may result greater checkpoint latency 3 logical checkpoint process said deterministic state depends initial state messages delivered 8 14 deterministic process take two types checkpoints physical checkpoint logical checkpoint process said taken physical checkpoint time 1 process state time 1 available stable storage process said taken logical checkpoint time 1 adequate information saved stable storage allow process state time 1 recovered physical checkpoint trivially logical checkpoint however converse true physical checkpoint taken two different ways one possibility save entire process state stable storage second possibility take incremental checkpoint 12 difference current state state previous physical checkpoint needs saved return incremental physical checkpoint logical checkpoint m3 process figure 1 physical checkpoint logical checkpoint checkpointing soon summarize three approaches taking logical checkpoint time 1 although three approaches equivalent approach may attractive applications approaches approaches feasible systems approach 1 one approach establishing logical checkpoint time 1 take physical checkpoint time log stable storage messages delivered process time 0 approach essentially identical presented wang et al 18 figure 1 presents example wherein process p takes physical checkpoint time 0 messages m1 m2 m3 delivered process p time 1 establish logical checkpoint process p time 1 messages m1 m2 m3 logged stable storage summarize approach physical checkpoint logical checkpoint approach 2 essential purpose behind saving messages able recreate state time 1 may also achieved taking physical checkpoint time 0 taking incremental checkpoint time 1 incremental checkpoint taken saving stable storage changes made process state time 0 summarize approach physical checkpoint incremental checkpoint logical checkpoint noted earlier physical checkpoint may taken using incremental checkpointing method therefore possible completely eliminate physical checkpoint however necessarily desirable figure 2 illustrates assume physical checkpoint p2 time 0 taken incremental change state previous physical checkpoint p1 also logical checkpoint time 1 taken incremental change state time 0 time interval p1 p2 figure 2 incremental checkpointing approach 2 logical checkpointing much larger time interval therefore size incremental state saved establish physical checkpoint p2 likely much larger saved establish logical checkpoint 1 algorithm staggers physical checkpoints whereas logical checkpoints contend stable storage consider situation physical checkpoint p2 taken case incremental state saved 1 consist modifications made state time checkpoint p1 taken therefore size incremental state least large saved establish p2 apparent later would defeat staggering algorithm introducing significant stable storage contention taking logical checkpoints therefore often desirable take physical checkpoint first possibly incremental checkpoint followed incremental logical checkpoint evolutionary checkpointing scheme long et al 11 also takes incremental checkpoints similar procedure approach 3 two approaches take physical checkpoint prior desired logical checkpoint followed logging additional information either messages incremental state change third approach converse two approaches physical checkpoint taken time 2 addition enough information saved undo effect messages received time 1 2 relevant message whose effect must undone antimessage saved stable storage notion antimessage similar used time warp mechanism 7 undo records 3 database systems antimessage corresponding message used undo state change caused message figure 3 illustrate approach logical checkpoint process p established time 1 process p delivers messages m4 m5 time 1 2 physical checkpoint taken time 2 antimessages corresponding messages m4 m5 logged stable storage antimessages named m4 m5 respectively antimessage message application time process m4 m5 stable storage state s1 notation figure 3 antimessage log logical checkpoint m4 m5 state s1 state s1 process figure 4 recovering logical checkpoint using antimessages recover state say s1 process p time 1 process initialized physical checkpoint taken time 2 antimessages m5 m4 sent process order antimessages delivered reverse order messages delivered shown figure 4 final state process p identical state logical checkpoint time 1 summarize approach antimessage log logical checkpoint antimessages possibly formed application may consist copy old process state modified message similar copyonwrite 10 4 chandylamport algorithm 2 chandy lamport 2 presented algorithm taking consistent checkpoint distributed system assume processes communicate using first infirstout unidirectional communication channels bidirectional channel modeled two unidirectional channels simplicity assume communication graph fully connected 2 algorithm presented next essentially identical 2 note chandylamport algorithm applicable strongly connected graph algorithm also generalized strongly connected graphs chandylamport 2 13 assumes certain process named p 0 designated checkpoint coordinator algorithm coordinator process p 0 initiates consistent checkpointing algorithm sending marker messages channel incident directed away p 0 immediately takes checkpoint physical checkpoint process say q receiving marker message along channel c takes following steps q taken checkpoint begin sends marker channel incident directed away q q takes checkpoint q records state channel c empty else q records state channel c sequence messages received along c q taken checkpoint q received marker along c 41 planks staggering scheme plank 13 suggested processes send markers taking checkpoints rather taking checkpoint unlike algorithm simple modification introduces staggering checkpoints however checkpoints staggered experiments use chandylamport algorithm incorporates planks modification rest paper modified algorithm referred chandy lamportplank algorithm clp brevity observations plank 13 observed staggering scheme works better original nonstaggered algorithm degree synchronization communication amongst processes relatively small ii message volume relatively small message volume amount information communicated messages figure 5 horizontal axis indicates degree synchronization application vertical axis indicates message volume shown figure synchronization frequent andor message volume large better avoid staggering checkpoints 13 extrapolating planks results follows region given staggering algorithm works best shrinks degree staggering greater staggering beneficial applications less synchronization small message volume paper alter conclusions work provides user ability choose degree staggering approach achieve completely controlled staggering checkpoints unlike plank 13 staggering works best staggering works best large message volume small message volume synchronization frequent synchronization infrequent less staggering works best figure 5 checkpoint staggering performance qualitative observations 5 staggered consistent checkpointing extent checkpoint staggering using clp algorithm dependent applications communication pattern also algorithm implemented eg whether markers sent asynchronously hand proposed algorithm stagger checkpoints manner desired many variations possible depending checkpoints desired staggered 16 illustration assume objective stagger checkpoints ie two checkpoints overlap time later illustrate situation overlap checkpointing desired proposed algorithm named stagger summarized follows staggered physical checkpoints consistent logical checkpoints staggered consistent checkpoints proposed algorithm coordinates logical checkpoints rather physical check points section assume first approach described section 3 taking logical checkpoints used thus logical checkpoint taken logging messages delivered process since recent physical checkpoint purpose discussion assume checkpoint coordinator named processes named p 1 p ngamma1 n number processes present proposed algorithm consisting two phases followed illustration presently assume processors share single stable storage section 7 considers situation multiple stable storages available algorithm stagger 1 physical checkpointing phase checkpoint coordinator p 0 takes physical checkpoint sends take checkpoint message process p 1 process p receives take checkpoint message takes physical checkpoint sends take checkpoint message process p j mod n process p 0 receives take checkpoint message process p initiates second phase algorithm named consistent logical checkpointing phase process takes physical checkpoint continues execution message delivered process taking physical checkpoint completion next phase logged stable storage procedure ensures physical checkpoints taken processes staggered one process takes physical checkpoint time physical checkpoints taken processes necessarily consistent 2 consistent logical checkpointing phase phase similar chandy lamport algorithm difference chandylamport algorithm phase original chandylamport algorithm requires process take checkpoint processes take logical checkpoint physical checkpoint chandylamport algorithm logical checkpoint taken ensuring messages delivered since physical checkpoint taken previous phase logged stable storage exact algorithm phase provided initiation coordinator p 0 initiates phase receipt take checkpoint message process p sends marker message channel incident directed away p 0 also p 0 takes logical checkpoint ensuring messages delivered since physical checkpoint logged number messages logged somewhat reduced discussed later process say q receiving marker message along channel c takes following steps q taken logical checkpoint begin sends marker channel incident directed away q q takes logical checkpoint ensuring messages delivered channel qs recent physical checkpoint logged else q ensures messages received channel c since recent logical checkpoint logged messages received channel c marker received channel logged similar chandylamport algorithm messages sent process logical checkpoint received receivers logical checkpoint logged part channel state note message logged establish logical checkpoint may logged time instant received time logical checkpoint established implementation due insufficient memory ncube2 messages logged immediately receipt algorithm establishes consistent recovery line consisting one logical checkpoint per process algorithm reduces contention stable storage completely staggering physical checkpoints however contention introduced second phase algorithm processes log messages 3 scheme perform well message volume relatively small compared checkpoint sizes figure 6 illustrates algorithm assuming system consists three processes process acts coordinator initiates physical checkpointing phase taking physical checkpoint sending take checkpoint message p 1 processes p 0 take staggered checkpoints first phase process p 0 receives take checkpoint message process p 2 initiates consistent logical checkpointing phase process p 0 3 contention potentially reduced taking logical checkpoint sending markers consistent logical checkpointing phase physical checkpoint logical checkpoint application message takecheckpoint message marker messages notation m6 m3 physical checkpointing phase consistent logical checkpointing phase process process consistent recovery line process figure example sends marker messages p 1 takes logical checkpoint logging messages m0 m2 stable storage process p 1 receives marker message process sends markers p 0 takes logical checkpoint logging message m1 stable storage similarly process p 2 takes logical checkpoint logging message m3 stable storage messages m4 m5 also logged second phase represent channel state message m6 logged proof correctness correctness follows directly proof correctness chandylamport algorithm 2 recovery failure process rolls back recent physical checkpoint reexecutes using logged messages restore process state logical checkpoint belongs recent consistent recovery line note stagger algorithm designed assuming desirable stagger checkpoints pattern staggering desirable algorithm easily modified achieve pattern section 7 illustrates example 6 performance evaluation implemented proposed algorithm stagger chandylamportplank clp algorithm ncube2 multicomputer single disk stable storage noted performance scheme closely dependent underlying hardware software implementation scheme nature application program clearly single scheme perform well applications objective demonstrate proposed scheme perform well certain circumstances implementation clp stagger markers sent process 0 sent asynchronously using interrupts signals sufficient care taken ensure markers appear firstinfirstout fifo order respect messages even though markers sent asynchronously markers sent processes sent without using interrupts markers sent asynchronously checkpointing algorithm may make progress cases synchronization communication infrequent staggering beneficial circumstances necessary ensure algorithm progresses without explicit communication application processes therefore process sends asynchronous markers return issue using asynchronous markers later section 7 first application used evaluation stagger synthetic program named syncloop similar program used plank 13 pseudocode program presented using clike syntax syncloopiter size char statesize initialize state repeat iter times perform floatingpoint multiplications synchronize processes process state size checkpoint size controlled size parameter size chosen experiments checkpoint size process syncloop approximately 21 mbyte process repeats loop performs computation amount computation controlled parameter loop repeated iter times synchronization achieved means alltoall message exchange choosing large value degree synchronization program minimized small hand implies processes synchronize frequently figure 7 presents experimental results stagger clp schemes synchronization interval figure time two consecutive synchronizations synchronization interval approximately equal time required perform computation ie multiplications iteration loop synchronization interval horizontal axis figure 7 determined dividing iter execution time syncloop without taking checkpoints checkpoint overhead obtained execution time consistent checkpoints gamma execution time without checkpoints measurements five checkpoints per execution program instance syncloop application executed five times checkpoint overhead averaged five executions figure 7 presents overhead measurements experiments cube dimension curve labeled figure experiments ndimensional cube consisting 2 n processors labels h figure 7 used match curves corresponding legend top right corner figure figure 7 observe fixed dimension synchronization interval becomes smaller checkpoint overhead grows schemes small synchronization intervals stagger scheme perform much better chandylamportplank scheme however synchronization interval large proposed scheme achieves significant improvements 1 dimension processors two schemes achieve essentially identical performance observe figure 7 given instance application dimension increased overhead stagger well clp increases however increase overhead clp much greater stagger checkpoint overhead second synchronization interval second syncloop clp d4 b stagger d4 c clp d3 b c stagger d3 f stagger d2 figure 7 checkpoint overhead syncloop labels h used match curves corresponding legend top right corner figure measurements presented imply parallel application large granularity thus requiring infrequent communication synchronization proposed stagger algorithm perform well example application coarsegrain parallelism figure 8 presents measurements simulation program sim simulation program sim evaluates expected execution time task using rollback recovery state size process sim approximately 34 kbyte simulation program completely parallelized processes synchronize beginning completion simulation synchronization pattern represents best possible scenario staggered checkpointing seen figure 8 checkpoint overhead stagger remains constant independent dimension synchronization infrequent hand overhead clp increases dimension1357 checkpoint overhead second dimension stagger figure 8 measurements sim application fair note stagger always outperform clp noted figure 5 algorithm staggers tends perform poorly degree synchronization andor message volume large illustrate figure 9a presents measurements program named fft15 repeatedly evaluates fast fourier transform 2 15 data points frequent interaction processes checkpoint size process approximately 185 mbyte application overhead stagger larger clp performance stagger improved reducing amount information logged using optimization similar 6 unlike original stagger algorithm necessary log messages data content sent process checkpoint overhead second dimension using stagger algorithm20601001 2 3 4 checkpoint overhead second dimension modified stagger b using modified stagger algorithm figure 9 measurements fft15 application taking physical checkpoint message sufficient log order information ie send receive sequence numbers sender receiver identifiers recovery message always reproduced sender process therefore logging order information sufficient figure 9b plots overhead stagger algorithm modified implement optimization overhead modified algorithm lower original stagger algorithm see figure 9a however overhead still much better clp fft15 application performs frequent communication hard achieve overhead better clp 7 variations theme process clustering exploit multiple stable storages algorithm stagger presented assumes processes share single stable storage however systems processes may share multiple stable storages instance number processes may 16 number stable storages may 4 systems modify proposed stagger algorithm make use stable storages minimizing contention stable storage achieve partition processes clusters number clusters identical number stable storages cluster associated unique stable storage processes within cluster access associated stable storage 9 algorithm stagger modified use multiple stable storages differs original stagger algorithm first phase ie staggered checkpointing phase illustrate modified staggered checkpointing phase example consider system consisting 6 processes 2 stable storages processes named denotes cluster number j denotes process number within cluster 2 stable storages available processes divided 2 clusters containing 3 processes process p i0 cluster identified checkpoint coordinator cluster process p 00 also identified global checkpoint coordinator figure 10 depicts first phase modified algorithm process p00 process p01 process p02 process p10 process p11 process p12 message denotes takecheckpoint consistent logical checkpointing phase shown staggered physical checkpointing phase figure 10 process clustering utilize multiple stable storages global checkpoint coordinator p 00 initiates phase 1 algorithm ie staggered physical checkpointing phase sending take checkpoint messages checkpoint coordinators clusters process p 00 takes physical checkpoint sends take checkpoint message process p 01 process p ij ij 6 00 receives take checkpoint message takes physical checkpoint sends take checkpoint message process p km global coordinator p 00 receives one take checkpoint message process cluster initiates consistent logical checkpointing phase phase identical second phase original stagger algorithm essentially procedure guarantees one process accesses stable storage time first phase stable storages used saving physical checkpoints b approach taking logical checkpoint discussion far assumed logical checkpoint taken taking physical checkpoint logging subsequently received messages proposed algorithm easily modified allow process use three approaches presented earlier section establishing logical checkpoint fact different processes may simultaneously use different approaches establishing logical checkpoint c asynchronous markers arrival asynchronous marker informed destination process means signal spite asynchronous nature marker appear appropriate position fifo channel sent call marker sent interrupt synchronous marker lack better terminology asynchronous marker processed soon arrives synchronous marker may processed long time particularly destination process need messages corresponding channel markers sent asynchronously affect performance stagger clp algorithms noted previously implementation markers sent process asynchronous markers synchronous plank 13 address distinction asynchronous synchronous markers one variation make clp imitate stagger particularly applications infrequent synchronization communication follows clp algorithm ensure marker sent process process j asynchronous modulo number processes thus process take checkpoint algorithm make progress even processes communicating also process sends one asynchronous marker algorithm would tend reduce contention stable storage infrequent synchronization communication rule tend stagger checkpoints different processes ie algorithm becomes similar stagger variation could also used reduce stable storage contention consistent logical checkpointing phase stagger algorithm summary paper presents algorithm taking consistent logical checkpoints proposed algorithm ensure physical checkpoints taken various processes staggered minimize contention accessing stable storage experimental results ncube2 suggest proposed scheme improve performance compared existing staggering technique particularly processes synchronize infrequently message sizes large paper also suggests variations proposed scheme including approach staggering checkpoints multiple stable storages available acknowledgements thank referees conference version paper james plank yimin wang comments earlier draft paper fft program used experiments written akhilesh kumar vidya iyer wrote parts checkpointing layer used experiments research supported part national science foundation grant mip9502563 texas advanced technology program grant 009741052c r performance consistent checkpointing distributed shared memory systems distributed snapshots determining global states distributed systems introduction database systems performance consistent checkpointing manetho transparent rollbackrecovery low overhead limited rollback fast output commit causal distributed breakpoints virtual time distributed system fault tolerance using message logging check pointing evaluation consistent logical checkpointing lowlatency concurrent checkpointing parallel programs evolutionary approach concurrent checkpointing libckpt transparent checkpointing unix efficient checkpointing mimd architectures optimistic recovery asynchronous approach faulttolerance distributed systems checkpoint letency staggered checkpointing lazy checkpoint coordination bounding rollback propagation progressive retry software error recovery distributed systems tr ctr guohong cao mukesh singhal checkpointing mutable checkpoints theoretical computer science v290 n2 p11271148 2 january partha sarathi mandal krishnendu mukhopadhyaya concurrent checkpoint initiation recovery algorithms asynchronous ring networks journal parallel distributed computing v64 n5 p649661 may 2004 partha sarathi mandal krishnendu mukhopadhyaya selfstabilizing algorithm checkpointing distributed system journal parallel distributed computing v67 n7 p816829 july 2007 guohong cao mukesh singhal mutable checkpoints new checkpointing approach mobile computing systems ieee transactions parallel distributed systems v12 n2 p157172 february 2001
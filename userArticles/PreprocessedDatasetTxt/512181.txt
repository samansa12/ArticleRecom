improving minmax aggregation spatial objects examine problem computing minmax aggregates collection spatial objects spatial object associated weight value example average temperature rainfall area covered object given query rectangle minmax problem computes minimummaximum weight among objects intersecting query rectangle traditionally queries performed range search queries assuming objects indexed spatial access method minmax computed objects retrieved requires effort proportional number objects intersecting query interval may large better approach maintain aggregate information among index nodes spatial access method various index paths eliminated range search paper propose four optimizations improve performance minmax queries experiments show proposed optimizations offer drastic performance improvement previous approaches moreover byproduct work present optimized version msbtree index proposed minmax computation 1dimensional interval objects b introduction computing aggregates objects nonzero extents received lot attention recently yw01 zmt01 pkz01 ztg01 formally general boxaggregation problem dened given n weighted rectangular objects query rectangle r ddimensional space nd aggregate weight objects intersect r paper examine problem computing min max aggregates boxmax spatial objects object represented minimum bounding rectangle mbr associated weight value want aggregate rectangle also called box thus name boxaggregation since computing min symmetric following discussion focus max aggregation moreover assume objects indexed spatial access method sam like rtree variants computer science department university california riverside ca 92521 donghuicsucredu computer science department university california riverside ca 92521 tsotrascsucredu work ben supported nsf grants iis9907477 eia9983445 department defense gut84 bks90 srf87 boxmax problem many reallife applications example consider database keeps track rainfall geographic areas area represented 2dimensional rectangle query nd max precipitation los angeles district database may also keep track time intervals rainfall case store 3dimensional rectangles one dimension representing rainfall duration boxmax query nd max precipitation los angeles district interval 19992000 three approaches towards solving boxaggregation queries straightforward approach simply perform range search sam indexes objects compute aggregation objects retrieved readily available solution requires eort proportional number objects intersect query rectangle large performance improved sam maintains additional aggregate information jl98 lm01 pkz01 example aggregation rtree artree pkz01 rtree stores aggregate value subtree index record pointing subtree traversing index aggregation information eliminates various search paths thus improving query performance third approach uses specialized aggregate index built explicitly computing aggregate question yw01 zmt01 ztg01 index maintains aggregate incrementally additional index usually rather compact since index actual data practice much smaller representative set provides best query performance main contributions paper propose four optimizations improving minmax aggregation one optimizations kmax attempts eliminate paths index traversal aggregate computed used either sam indexes objects specialized aggregate index optimizations union boxelimination areareduction eliminate resize object mbrs aect minmax computation thus apply specialized minmax aggregate indices present specialized aggregate index minmax rtree mrtree uses four optimizations present experimental comparison among plain rtree ar tree artree kmax optimization mrtree experiments show drastic improvements proposed optimizations used byproduct research discuss specialized aggregate index msb tree yw00 optimized applying boxelimination optimization msbtree eciently solves minmax problem special case onedimensional interval objects original version needs frequently reconstructed rest paper organized follows section 2 discusses related previous work section 3 identies special characteristics boxmax problem presents optimization tech niques section 4 summarizes mrtree section 5 presents results experimental comparisons section 6 applies one proposed optimization technique msbtree finally section 7 provides conclusions problems research related work two variations boxaggregation problem depending whether objects zero extent point objects aggregation point objects special case orthogonal range searching received vast attention past 20 years eld computational geometry details refer surveys meh84 ps85 mat94 ae98 solutions utilize variation rangetree ben80 following multidimensional divide andconquer technique database eld jl98 proposed r tree stores aggregated results index aok99 proposed selectively traverse multidimensional index problem selectivity estimation corresponding count aggregate lm01 proposed multiresolution aggregate tree mratree augments index records rtree aggregate information points records subtree mratree also uses selective traversal provide estimate aggregation result result progressively rened jl99 proposes performance model estimate performance index structures without aggregated data special case point aggregation problem work data cube aggregation olap applications data cube gbl96 thought multidimensional array rkr97 proposed cubetree storage abstraction cube realized using packed rtrees eciently support cube groupby aggregations ham97 addressed boxmax boxsum sum count avg queries data cubes solution boxmax query based storing precomputed max values balanced hierarchical structure solution improved ham97b solution boxsum query based precomputing prex sum aggregate range covering smallest cell array solution improved gae99 ci99 gae00 specically gae00 proposed dynamic data cube best update cost recently ccl01 proposes dynamic update cube improves update cost olog k u k u number changed array cells aggregations objects nonzero extents yw01 presented sbtree solved boxsum query special case onedimensional time intervals sbtree extended multiversion sbtree mvsbtree zmt01 eciently support temporal boxsum aggregation queries keyrange predicates ztg01 addressed boxsum aggregation spatiotemporal objects furthermore yw00 presented msbtree boxmax query onedimensional interval objects artree pkz01 originally proposed index spatial dimension spatial data warehouse environment used solve boxsum boxmax queries spatial data nonzero extent artree rtree stores index record aggregate value objects subtree since artree built support boxsum boxmax queries fully optimized towards boxmax queries artree used starting point optimizations included experimentation comparison purposes also related as90 answers window queries top pyramid data structure aggregations used existencenonexistence image features visibility terrain data last spatialtemporal data warehouse environment pkz01b proposed aggregate rbtree arbtree uses rtree index spatial dimension record r rtree pointer btree keeps historical data r 3 proposed optimizations paper focus discussion max aggregate discussion min aggregates symmetric omitted goal solve boxmax problem set objects box value given query box q want nd maximum value objects intersecting q assume objects indexed treelike structure eg rtree objects stored leaf nodes mbr internal node contains mbrs children using index boxmax query answered performing range search section propose four optimizations improve performance rst introduce notations indexleaf record entry internalleaf node tree given leaf record r let rbox rvalue denote mbr value record respectively given index record r let rbox denote mbr rvalue denote maximum value records subtreer rchild denote child page pointed r 31 kmax optimization artree rtree index record stores maximum value leaf records subtree query box contains mbr index record value stored record contributes query answer examination subtree omitted however note higher levels artree index records large mbrs boxmax query likely stop higher levels artree kmax optimization extension keeps constant number leaf objects along index record even query box contain mbr index record examination subtree may omitted kmax optimization along index record r store k objects small constant subtreer largest values among objects subtree examining record r boxmax query query box intersects k maxvalue objects r examination subtreer omitted clearly kmax optimization allows paths omitted index traversal however benet kmax query performance provided free overall space increased since node stores information well update time eort needed maintain k objects hence practice constant k kept small experiments found large improvement query time even small pointed next three optimizations apply index explicitly maintained minmax aggregation avoid confusion call explicit index minmax index since minmax problem incrementally maintainable tuples deleted database yw01 following discussion assumes appendonly database ie spatial objects inserted database never deleted spatial object mbr obox value ovalue inserted database obox accompanied ovalue inserted leaf record minmax index well however describe insertions may applied minmax index may cause existing mbrs deleted altered minmax index use r tree implement minmax index result applying four optimizations mrtree 32 boxelimination optimization consider two leaf records need maintain minmax index since contribute max query thus say becomes obsolete due boxelimination optimization insertion object leaf index record r found obox contains rbox ovalue rvalue remove r minmax index r index record remove subtreer well optimization reduce size minmax index since subtrees may removed insertion tradeo time update minmax index overall space occupied index newly inserted object may make obsolete one existing records dierent paths root leaves minmax index made compact obsolete records subtrees removed however may result expensive update processing update kept fast choose remove obsolete records met along insertion path single path since use r tree implement minmax index complexity insertion algorithm remains olog n n number mbrs minmax index practice much smaller total number spatial objects collection another choice choose c paths remove obsolete records met along paths c constant space occupied obsolete subtrees reused 33 union optimization boxelimination optimization focuses making obsolete existing records index union optimization focuses making obsolete objects inserted minmax tree first note mbr object inserted minmax index existing leaf object index whose mbr contains larger value insertion safely ignored purposes minmax computation fully implement test paths may contain object checked worst may check leaf objects minmax tree better heuristic use k maxvalue mbrs new object contained k maxvalue mbrs found along index nodes insertion path smaller value need perform insertion moreover observe even mbr object inserted fully contained existing leaf object still might safely ignore case new objects mbr contained union mbrs several existing objects illustrated gure 1 shadowed box represents new object inserted two rectangles represent two objects already minmax index since new object contained union two existing objects smaller value insertion safely ignored7 figure 1 new object becomes obsolete union two existing objects implement technique index record r minmax index stores 1 union denoted runion mbrs leaf objects subtreer 2 minimum value denoted rlow objects subtreer overall optimization described union optimization insertion object indexleaf record r found obox covered runionrbox ovalue rlowrvalue insertion ignored moreover check whether maxvalue object stored r covers obox value smaller ovalue also makes remaining question optimization store union leaf objects index record worst union may need space proportional number leaf objects create given index record limited space store approximate union particular store good approximation represented boxes mbrs small constant important approximation aect query time correctness query result approximate union covers area covered actual union may erroneously make obsolete new object approximate union completely covered actual union formally state problem follows denition 1 given constant set n boxes covered tunion dened set boxes 1 maximal ie exist another set boxes fa 0 satisfying rst condition covers larger space nd exact answer exhaustive search algorithm twodimensional case takes 8t time clearly unacceptable need nd ecient algorithm compute good approximation covered tunion order boxmax query give correct result require approximate covered tunion completely covered original n boxes hereby propose log n algorithm algorithm coveredunionboxes src1n number n given set n boxes src return approximate covered tunion src note algorithm uses small constants c max try 1 seeds c boxes src whose areas largest 2 initialize set destination boxes dest empty 3 every dimension 4 project src boxes dimension sort projected end points array projd 12n 5 endfor 6 1 7 pick box b seeds largest area covered union boxes dest 8 loop max try times 9 dimension 11 tryextend b false 12 endfor 13 b cannot enlarged extending direction break 14 else b extended box largest area 15 endloop 16 add b set 17 endfor 18 return dest algorithm tryextendbox b dimension boolean positive given box b dimension boolean variable positive denoting whether b extended positive negative direction along dimension try extend b return 1 positive true try extend positive direction 2 find smallest number w projd larger projection b dimension 3 try extend b w dimension shrink dimensions needed make sure b covered union src boxes extension successful area b grows 4 else 5 try extend negative direction similar omit 6 endif 7 return b idea algorithm coveredunion pick boxes original n boxes try expand one much possible choose th box 1 choose one largest area covered 1 boxes computed far expand chosen box try expand along directions parallel axes trivial analysis shows complexity algorithm log n following discussion term union means approximate covered tunion 34 areareduction optimization last optimization propose dynamically reduces box area object inserted areareduction optimization insertion object index record r found runion intersects obox rlow ovalue reduce size obox subtracting area covered runion inserting lower levels insertion reaches leaf object intersects new object equal larger value area new object reduced accordingly box new object similarly reduced maxvalue object stored index record r exists whose box intersects obox whose value smaller ovalue optimization reduces mbr object reduced part covered existing records tree larger equal values hence correctness minmax aggregates aected one benet optimization overlapping among sibling records tree reduced figure 2 shows example two large boxes represent two index records r 1 r 2 assume r 1 union equal mbr r 1 combination lightshadowed dark shadowed boxes represents object inserted value 8 object recursively inserted subtreer 2 without applying areareduction optimization r 2 box would need expanded fully contain new object hand apply optimization lightshadowed area subtracted thus insert subtreer 2 much smaller box darkshadowed area fully contained r 2 box thus expansion r 2 neededr2 min7 figure 2 areareduction optimization helps reduce overlaps another benet areareduction optimization help make new records obsolete example consider gure 2 possible lower level subtreer 2 darkshadowed area found obsolete since lightshadowed area already made obsolete r 1 due optimization theres need insert record note result box areas subtracted may set boxes rather single box object inserted may fragmented several smaller boxes optimization one choice handle follow r tree srf87 approach ie insert every small box separate copy choice increases space overhead another choice maintain list small boxes execution insertion algorithm go tree small boxes may become smaller obsolete eventually leaf level mbr smaller boxes inserted note mbr large original box inserted many cases much smaller 4 minmax r tree mrtree dynamic diskbased heightbalanced tree structure two types pages leaf pages index pages pages size since mrtree based r tree page except root records least records leaf record form hbox v 1 v 1 value record index record form lowi box child usual meanings list b k maxvalue leaf objects subtree index record sorted decreasing order value b stands mbr v value leaf object th largest value union stores boxes approximate tunion leaf mbrs low minimum value leaf objects subtree algorithm boxmaxpage n box b value v given tree node n query box b running value v algorithm returns boxmax query result subtree rooted n 1 every record r n rbox intersects b 2 rv1 v 3 n leaf 4 5 else exists 1 k rb intersects b 6 let smallest one satisfying condition 7 rv v set 8 else 9 v boxmaxpagerchild b v 10 endif 11 endif 12 endfor 13 return v boxmax straightforward recursive algorithm nd boxmax box b call boxmaxroot page b 1 main dierence algorithm range query algorithm rtree steps 57 corresponds kmax optimization index record r algorithm checks k maxvalue objects stored r intersects b need examine subtreer algorithm inserttree box b value v given tree index box b value v algorithm inserts object b v 1 2 n root page 3 n leaf 4 every record r n rbox intersects b 5 rbox contained b rv1 v 6 remove subtreer 7 else 8 every rv v 9 modify box subtracting rb 10 endfor 11 rlow v modify every box subtracting runion 12 endif 13 endfor 14 n zero record goto step 19 15 empty goto step 20 17 endwhile 18 optimizations leaf page similar steps 4 13 omit 19 empty insert hmbrs vi n 20 n root 21 n ows 22 splitn 23 else n ows 24 remove n reinsert records n tree n level 25 endif 26 adjust entry parentn pointing n 27 set n parentn 28 endwhile 29 n ows 30 split old root create new root 31 else n one record n leaf 32 remove n set n child new root 33 endif generally insertion algorithm follows single path root leaf reorganizations may follow path back root optimizations applied going tree steps 5 6 correspond boxelimination optimization removes subtree newly inserted object larger value spatially contains subtree steps 8 11 correspond areareduction optimization tries reduce size box inserted step 14 deals rare case subtrees index page n become obsolete due insertion object may occur n root page since otherwise index record pointing n parent page would obsolete n chance examined case algorithm results tree single page single record step 15 means object inserted obsolete recursive insertion lower levels needed step 16 chooses child page recursively insert use algorithm rtree choosechild procedure discussed detail steps 20 28 path pages examined backwards way split owed page reinsert entries owed page identical approaches rtree plus maintenance additional information kept along index record steps 29 33 handle owunder ow root page consequence tree height may increasedecrease performance compare performance proposed mrtree plain r tree artree artree kmax optimization denoted artree kmax algorithms implemented c using gnu compilers programs run sun enterprise 250 server machine two 300mhz ultrasparcii processors using solaris 28 page size 4kb space limitations report performance mrtree number maxvalue objects kept index record number boxes used represent union similarly ar kmax uses 3 index utilizes lru buer path buer buers recently accessed path total memory buer used program 256 pages present results two datasets containing 5 million square objects randomly selected twodimensional space space dimensions 1 1 million rst data set used test performance presence small objects size object randomly chosen 10 1000 second data set contains medium sized objects size object randomly chosen 10 10000 r ar kar mr2575125query rectangle area query time sec index sizes b query performance figure 3 comparing performance small object dataset figure 3 compares performance small object dataset gure use r ar kar mr represent rtree artree artree kmax proposed mrtree respectively mrtree uses 25 less space gure 3a methods obsolete records removed index artree kmax occupies space since compared rtree artree stores information index record evaluate query performance query rectangle area varies 00001 50 whole space query rectangle size randomly generated 100 square queries measured total running time running time obtained multiplying number ios average disk page read access time 10ms adding measured cpu time cpu time measured adding time spent user system mode returned getrusage system call figure 3b shows average time per query various query sizes methods comparable small query rectangles since objects satisfy query anyways mrtree clearly best query rectangle size increases note query time scale logarithmic actual dierence query speeds drastic example query size 1 mrtree 20 times faster artree reason large query rectangles minmax query chances stop higher levels mrtree particular artree decide omit examining subtree query rectangle contains box whole subtree hand mrtree search may omit traversing subtree even query rectangle partly intersects usefulness kmax optimization seen comparing ar tree kmax plain artree mrtree performs better artree kmax two reasons first due additional optimizations mrtree stores fewer objects second objects mrtree smaller area area reduction optimization thus achieve better clustering r ar kar mr2575125query rectangle area query time sec index sizes b query performance figure 4 comparing performance medium objects mediumsize objects performance improvement mrtree structures even better gure 4 reason larger objects chances contain objects thus make obsolete result mrtree becomes compact trend continued datasets larger objects results shown brevity also compared index generation time small objects gure 5a mrtree needs cpu time generate 25 times little less io time expected although mrtree occupies less space generation needs cpu time maintain extra information stored index records medium objects gure 5b mrtree takes r ar kar mr2575125io cpu creation time kilo sec r ar kar mr2575125 io cpu creation time kilo sec small objects b medium objects figure 5 comparing index creation time cpu time less io time compared structures since much smaller 6 optimize msbtree rst review msbtree proposed yw00 answer boxmax query 1 dimensional interval data show use one proposed optimization techniques improve 61 msbtree msbtree tree structure record r tree node interval ri value rv intervals records tree node intersect union interval index record points node object inserted also interval oi value ov index record r extra value ru explained shortly focus discussion max aggregate initially one node leaf node insert object leaf node l every record r l ri intersects oi examined ov rv insertion eect otherwise oi contains ri set otherwise split r two three records one corresponding intersection ri oi others corresponding rest ri leaf node l ows split two pages records evenly distributed two pages based interval positions perform boxmax query leaf page easy locate records intersecting query interval return maximum value records besides interval value v pointer child child page index record also value u meanings u v index record r follows subtreer standalone tree rv would lower bound boxmax query ru would upper bound since query subtreer may standalone tree need maintain running value corresponds boxmax get far examining path root page pointed r nal query result larger value running value boxmax query result subtreer thus perform boxmax query interval qi index page running value current check records r intersects qi ru current nothing done otherwise qi contains ri set current ru otherwise set current query result subtreer discuss insert object index page every record r ri intersects oi examined first ru ov need set keep ru upper bound next check ov rv ov rv nothing needs done otherwise oi contains ri simply set otherwise recursively insert note given level l msbtree given interval two records level l intersect insertion algorithm query algorithm examine two paths tree thus complexities olog b b page capacity number records number leaf records since insertion splits two leaf records number updates ever performed much smaller n observe consider insertion object whole space ov larger existing value tree obviously insertion although n arbitrarily large compact tree one leaf record ie msbtree called compact number leaf records minimum msbtree update algorithm ensure compactness tree since ideal maintain small yw00 proposes periodically reconstruct msbtree reconstruct whole tree browsed depthrst manner report every interval together aggregation value interval intervals thus reported continuous one another adjacent intervals value merged intervals inserted second initially empty msbtree eventually replaces original tree 62 optimize msbtree reconstruction phase msbtree oline ie new insertion made discuss apply boxelimination optimization proposed section 3 msbtree get relatively much smaller tree remains online idea whenever u v values index record r becomes equal insertion process remove whole subtreer implement modied insertion algorithm insert object index page add following steps original insertion algorithm record r oi contains ri ru ov remove subtreer mark r obsolete ie points obsolete page combine adjacent obsolete records propagate obsolete records leaf pages remains discuss propagate obsolete index record r leaf level r record page merge page sibling page otherwise exists sibling record obsolete without lose generality suppose si right ri merge r extending si contain ri also rst record every node leftmost path starting schild needs extended well lets analyze complexity modied algorithm level tree algorithm examines two pages page ob obsolete records records need follow single path page containing record leaf thus worst case update complexity ob log b number leaf records note discussion count cost free space occupied subtrees pointed obsolete records fact since subtrees needed update query performed later garbage collection performed background process compared original msbtree update algorithm modied update algorithm little expensive worst case however happen often since time modied algorithm spends time update tree shrinked major benet optimized algorithm original one optimized one results much smaller tree without periodic reconstruction example consider previous example insert object oi whole space ov larger every existing record original algorithm simply updates u v values rootlevel records thus number leaf records change hand optimized algorithm immediately decides whole tree obsolete thus results compact tree tree one leaf record conclusions examined problem computing minmax aggregation queries spatial objects nonzero extents proposed four optimization techniques improving query performance introduced mrtree new index explicitly designed maintenance minmax aggregates mrtree combines proposed optimizations experimental comparison showed approach provides drastic improvement especially query sizes increase product showed one optimizations applied existing aggregation index msbtree acknowledgements would like thank gunopulos many helpful discussions also thank papadias providing us valuable input related work including finally grateful b seeger r tree code r computational geometry introduction tr computational geometry introduction rtree efficient robust access method points rectangles geometric range searching range queries olap data cubes cubetree efficient processing window queries pyramid data structure multidimensional divideandconquer efficient computation temporal aggregates range predicates progressive approximate aggregate queries multiresolution tree structure rtrees dynamic data cube data cube incremental computation maintenance temporal aggregates hierarchical prefix cubes rangesum queries rtree dynamic update cube rangesum queries efficient olap operations spatial data warehouses rtree pisa avoid building databladesr know value everything cost nothing relative prefix sums ctr jie zhang michael gertz demet aksoy spatiotemporal aggregates raster image data proceedings 12th annual acm international workshop geographic information systems november 1213 2004 washington dc usa zhang j tsotras optimizing spatial minmax aggregations vldb journal international journal large data bases v14 n2 p170181 april 2005 ines fernando vega lopez richard snodgrass bongki moon spatiotemporal aggregate computation survey ieee transactions knowledge data engineering v17 n2 p271286 february 2005
local encoding transformations optimizing obddrepresentations finite state machines ordered binary decision diagrams stateoftheart representation switching functions order keep sizes obdds tractable heuristics dynamic reordering algorithms applied optimize underlying variable order finite state machines represented obdds state encoding used additional optimization parameter paper analyze local encoding transformations applied dynamically first investigate potential reencoding techniques propose use xortransformation show transformation suitable among set encoding transformations presented theoretical framework establishes new optimization technique obdds b introduction ordered binary decision diagrams obdds introduced bryant bry86 provide efficient graphbased data structure switching functions main optimization parameter obdds underlying variable order order find good order two techniques applied far use heuristics try exploit structure circuit representation see eg mwbs88 dynamic reordering techniques rud93 unfortunately many applications particular field sequential analysis two optimization techniques obdds reach limits hence one essential problem logic synthesis verification find new techniques minimize obdds applications obdds used represent finite state machines obddsize depend variable order also state encoding fixed state encoding many finite state machines whose obddrepresentations large wrt variable orders atb94 therefore relationship obddsize state encoding becomes increasing interest see eg qcc importance relationship underlined recent ideas apply heuristic state reencoding techniques speed verification process similarstructured finite state machines qcc underlying general problem efforts following given obdds nextstate output functions finite state machine one interested inputoutput behavior machine far internal state encoding exploited minimize obddsizes approach targets applying local encoding trans formations ie transformations involve limited number encoding bits proceedings fmcad96 lncs supported dfggraduiertenkolleg mathematische optimierung transformations interpreted reencoding symbolic states aim minimize obddsizes iterated application local transformations advantage approach costs applying transformations still manageable paper structured follows begin recalling important definitions point principle potential state reencodings wrt obddsizes section 4 analyze advantages local encoding transformations section 5 propose application xortransformation show transformation promising among set encoding transformations end paper describe implementation transformation give first experimental results illustrate positive impact presented ideas preliminaries 21 finite state machines finite state machine q set states input alphabet output alphabet output function q 0 set initial states usual components state machine assumed binary encoded let p number input bits n number state bits number output bits particular function ib n theta ib p ib n function ib n theta ib p ib q 0 subset ib n 22 binary decision diagrams ordered binary decision diagrams obdds bry86 rooted directed acyclic graphs representing switching functions obdd two sink nodes labeled 1 0 internal node labeled input variable x two outgoing edges labeled 1 0 diagrams 1edge indicated solid line 0edge dotted line linear variable order placed input variables variable occurrences obddpath consistent order obdd computes switching function f ib n ib natural manner assignment input variables x defines unique path graph root sink label sink defines value function input obdd called reduced contain vertex v 0edge 1edge v leads node contain distinct vertices v v 0 subgraphs rooted v v 0 isomorphic wellknown reduced obdds unique representation switching functions f respect given variable order bry86 size obdd number nodes several functions represented multirooted graph called shared obdd following nextstate output functions represented shared obdd 23 transition relation finite state machine characteristic function transition relation defined 1in hence function computes value 1 triple x state machine state x input e enters state variables x called currentstate variables variables called nextstate variables 3 motivation potential reencoding order demonstrate much size obddrepresentation depends choice state encoding let us consider autonomous counter finite state machine simple structure example 1 autonomous counter see example gdn92 2 n states q autonomous ie inputindependent finite state machine ffiq figure 1 autonomous counter ae oe ae oe ae oe ae oe ae oe transitions inputoutput following theorem shows almost encodings autonomous counter lead exponentialsize obdds even optimal variable order theorem 1 let en denote number nbit encodings autonomous counter 2 n states lead shared obdd size 2 n n wrt optimal variable order let denote number possible counter encodings ratio enan converges zero n tends infinity proof theorem found appendix based ideas ll92 classical counting results shannon sha49 analogous result established characteristic function transition relation obddsize definition 2 encoding transformation shortly called reencoding bijective transforms given state encoding new encoding example see figure 2 state encoded bitstring c 2 ib n new encoding aec figure 2 encoding transformation aec original new state encoding encoding q3 10 10 10 new 11 modification internal state encoding modify inputoutput behavior state machine machine new encoding denoted encoded nextstate function output function set initial states computed follows transition relation reencoded machine 0 obtained transition relation follows lemma 3 let x characteristic function transition relation characteristic function 0 x transition relation 0 ae therefore obtained x substitutions proof lemma consequence following equivalences ae example 1 ctd large potential reencoding techniques demonstrated example autonomous counter exists encoding transition relation autonomous counter 2 n states n encoding bits 5n gamma 1 nodes tm96 even variable order fixed x hence given encoding finite state machine exists reencoding leads obdds linear size according theorem 1 encodings lead obdds exponential size gain original obdd obdd suitable reencoding exponential cases aim find suited reencoding leads small obddsizes previous section shown reencodings may large impact obddsize possible obdd becomes much smaller case badly chosen reencoding obdd could even become much larger situation comparable problem finding good variable order obdd changing variable order obdd graph may become much smaller best case much larger worst case sensitivity main reason hard find good reencoding good variable order effective construction good variable orders turned efficient strategies based local exchanges variables presently best strategies finding good variable orders dynamically based sifting algorithm rudell rud93 ps95 main principle algorithm based subroutine finds optimum position one variable variables remain fixed subroutine repeated variable two main reasons strategy works efficiently bounded size alteration one variable x moved another position obdd size obdd cannot change arbitrarily much particular cannot explode blw95 shown following theorem theorem 4 let p obdd variable x moved later position variable order size resulting obdd p 0 satisfies variable x moved earlier position variable order size resulting obdd p 0 even satisfies relation practical studies shown cases resulting sizes even far worstcase estimations hence application mentioned subroutine keeps size obdd manageable however bounded size alteration subroutine mean optimization potential limited iteration subroutine allows minimize obdds effectively continuity procedure moving variable x different position order works continuously process variables original new position x involved nodes labeled remaining variables remain untouched particular time complexity operation small x moved adjacent position increases number variables original new position x variable order case reencoding situation analogous seems hard find right global reencoding whereas promising combine iterate operations restricted local effect approach construct local reencodings ae ib n ib n keep bits fixed ie ae vary small number bits particular vary 2 bits speak twobit reencodings case follows worstcase bounds synthesis substitution obdds obdds remain polynomial example 2 exchange variables reencoding ae follows following definition shows case j case j defined obviously exchange variables reencoding effect nextstate functions exchanging state variables x x j variable order 2 n possible encoding transformations n generated iterated application transformation type inverse mapping ae gamma1 equation 1 affect size resulting obdds mapping causes renaming two functions note transformation exchanges encodings two fixed states may seen local operation although transformation seems simple 5 xortransformation propose xortransformations transformation local reencoding operates two bits definition 5 xortransformation ae ij 1 short example see figure 3 figure 3 xortransformation q 1 7 q 1 phi q 2 original new encoding encoding q1 q2 q new indeed xortransformations provide solid basis design effective reencodings due following facts 1 number possible reencodings generated iterated application xor transformations much larger number possible variable orders thus xortransformations considerably enlarge optimization space hand number reencodings much smaller number reencodings makes possible keep search space manageable 2 size influence transformation bounded reasonable way like case local changes variable order 3 precise analysis even shows xortransformation contains asymmetry movement one variable variable order namely bounds effect transformation x 7 x phi x j depends position x x j variable order 4 xortransformation fact new possible reencoding two variables 5 xortransformation implemented efficiently like exchange two variables order following subsection prove statements 51 enumeration results following combinatorial statements characterize size optimization space provided use xortransformations lemma 6 1 let tn number possible encoding transformations generated iterated application xortransformations holds 2 quotient tn number possible encoding transformations converges zero n tends infinity 3 let vn 2n denote number possible variable orders transition relation autonomous finite state machine n state bits fraction vntn converges zero n tends infinity statement 3 says case autonomous state machines much encoding transformations generated xortransformations variable orders transition relation relation also holds number input bits fixed number state bits becomes large proof 1 obviously xortransformation regular linear variable transformation field zz 2 moreover xortransformations provide generating system regular linear variable transformations therefore state encodings obtained iterated xortransformations 11correspondence regular n theta nmatrices zz 2 number matrices computed follows first row vector b 1 chosen arbitrarily zz n ith row vector b 2 n chosen arbitrarily 2 possibilities vector b proves claimed number 2 statement follows relation 3 holds 1in particular number possible encoding transformations generated iterated application xortransformations smaller 2 exactly number n theta nmatrices zz 2 follows previous proof exchanges two state variables simulated iterated application xortransformations 52 bounded size alteration let ae xortransformation q 7 q phi q j inverse transformation defined ie effect aeffiae gamma1 delta equation 1 split two parts 1 substitute currentstate variable x x phi x j 2 replace function ffi matter two steps executed first lemma 7 let p obdds n obdds application xortransformation q 7 q phi q j following holds upper bound immediately follows facts substitution obdd p 2 one variable obdd p 1 leads obdd size osizep 1 operation p 1 phi p 2 leads obdd size osizep 1 lower bounds suffices observe case transition relation currentstate variables nextstate variables substituted leads result p p 0 original reencoded obdd transition relation respectively 53 stronger bounds refined analysis xortransformation use following theorem sw93 particular refine analysis substitution variable x obdd theorem 8 reduced obdd representing f variable order x contains many x nodes different functions f ae depending essentially x ie f otherwise 2 let k number nodes labeled x k obdd p k number nodes labeled x k obdd p 0 result transformation theorem 9 size obdd wrt variable order x application substitution x 7 x phi x j bounded proof theorem found appendix applies ideas blw95 local changes variable order analyzed corollary 10 let p obdd p 0 resulting obdd substitution x 7 analogy behavior xortransformation local changes variable order recommends use xortransformations optimization obdd sizes xortransformation x 7 x phi x j visualized shown figure 4 let b two subobdds whose roots children consider path x j x path contains 0edge x j subgraph rooted x remains unchanged instead path contains 1edge x j 0 1successor x node exchanged modification prevent subgraph isomorphisms new subobdds rooted x k node figure 4 mutation x 7 x phi x j x path along 0edge x j remains unchanged b path along 1edge x j 54 general twobit reencodings effect twobit reencoding split twoparts substitute two variables x x j functions replace two functions functions variable substitution impact functions depend essentially x x j whereas function replacement affects functions ffi next table shows reencodings induced bijective obtained combination maximal one xor transformation exchange variable transformation identity hence beside exchange variable transformation merely xortransformations needed produce twobit reencodings write twobit reencoding induced f ae f 22 substitution x 7 x affect size obdd x phi x 24 transformations effect wrt obddsize combination exchange variables transformation xortransformation identity operation moreover 24 transformations combination two basis transformations suffices implementation aspects section describe implement xorsubstitution x 7 x phi x j efficiently starting point consideration local changes variable order order modify variable order obdds iterate exchanging variables adjacent levels since exchange adjacent variables local operation consisting relinking nodes two levels done efficiently shown figure 5 order move variable x behind arbitrary variable x j order exchanges adjacent variables iterated figure 5 exchanging two neighboring variables level exchange case xoroperation adjacent variables x x j proceed analogous level exchange figure 6 shows case x j direct successor x order case x direct successor x j order works analogously x x j adjacent would course helpful could simulate substitution sequence like x 7 x phi x straightforward idea work would require operations intermediate steps influence two adjacent levels figure performing x 7 x phi x j two neighboring variables x x j r h g method works slightly expensive exchange two nonadjacent variables following first shift variable x new position order adjacent x j perform xoroperation shift variable x back old position technique retains locality operation nodes label x k influenced whose position order x x j 6 fsmdescriptions profit xorreencodings principle applicability xortransformation restricted use obdds underlying data structure also applied data structures boolean functions however strong relationship xortransformation local changes variable order like case obdds always transfer representations demonstrate effect ofdds ordered functional decision diagrams ofdds ksr92 modification obdds seem compact arithmetic functions node v label x obdd represents shannon decomposition whereas node v label x ofdd represents reedmuller decomposition decompositions functions g h independent x functions represented subgraphs rooted two successor nodes v shown blw95 local changes variable order effect ofdds like obdds particular exchange two variables x x j order affects nodes obdd resp ofdd labeled variable whose position order x x j observations justify notions local changes proof theorem 9 follows xortransformation obdds also pleasant local property however spite fact reedmuller decomposition seems operate well xortransformations substitution local property like case obdds figure 7 ofdd x1 prove statement consider ofdd figure 7 represents function functions independent x function f 0 hence must exist node ofdd f 0 representing function h phi r phi h r arbitrary functions substitution operation x 7 x phi x j local property however phioperation polynomial operation ofdds result substitution remains polynomial tight relationship reencoding techniques specific obddvariants following general setting concept domain transformations proposed manipulation switching functions bms95 fkb95 corresponding variants obdds called tbdds following show encoding transformations also interpreted tbddtransformations ib switching function let ib n ib n bijective mapping tbddrepresentation f obddrepresentation f ffi ffi denotes composition functions turns every reencoding function ae defines transformation within tbdd concept however obdds nextstate functions reencoded machine reencoding function ae isomorphic aetbdds obdds reencoded machine transformation ae gamma1 also involved see equation 1 section 3 7 experimental results section present first experimental results extended optimization techniques obdds built routines top obddpackage long used iscas89 benchmark circuits s1423 s5378 s9234 large number state bits also formed set examples rs95 optimization run consists three phases first applied rudells sifting algorithm rud93 finding good variable order minimization based xortransformations performed finally sifting applied reestablish suitable variable order table shows obtained shared obddsizes nextstate functions comparison sizes obtained without minimization xortransformations without circuit state bits xor xor minimization based xortransformation works follows preprocessing step compute promising pairs j xortransformation heuristic criteria considering pair j promising 1 nextstate functions nearly equal support 2 variables x x j appear nearly functions long improvements possible best xortransformation among pairs applied order avoid expensive computations step variable substitution x 7 x phi x j yields good intermediate result must admitted experiments running times significantly higher running times pure sifting due nonoptimal implementation xortransformation due large number performed xortransformations however think intensive studies different strategies analogous intensive finally quite successful studies variable order able improve results far hence think experimental results underline optimization potential xortransformation efficient implementation xortransformation construction effective minimization strategies progress 8 conclusion future work proposed analyzed new reencoding techniques minimizing obdds particular proposed xortransformation shown transformation fact new transformation two state variables transformation certain cases significantly enrich set basic operations optimization obdds future propose study heuristics choosing right transformation pairs efficient combinations variable reordering techniques new proposed trans formations furthermore dynamic application new reencoding technique traversal finite state machine seems promising helps reduce obddsizes set reached states also reduce efforts image computations 9 acknowledgements wish thank stefan krischer jan romann anna slobodova fabio somenzi interesting discussions many valuable comments r bdd variable ordering interacting finite state machines simulated annealing improve variable orderings obdds bdd minimization truth table permutations sequential logic testing verifi cation multilevel logic synthesis based functional decision diagrams obddrepresentation general boolean functions logic verification using binary decision diagrams logic synthesis environment variables neighborhood incremental fsm reencoding simplifying verification symbolic traversal dynamic variable ordering ordered binary decision diagrams synthesis twoterminal switching circuits state encodings obddsizes tr graphbased algorithms boolean function manipulation sequential logic testing verification obddrepresentation general boolean functions bdd variable ordering interacting finite state machines efficient obddbased boolean manipulation cad beyond current limits variables neighborhood dynamic variable ordering ordered binary decision diagrams linear sifting decision diagrams algorithms data structures vlsi design influence state encoding obddrepresentations finite state machines ctr carla piazza alberto policriti ackermann encoding bisimulations obdds theory practice logic programming v4 n56 p695718 september 2004
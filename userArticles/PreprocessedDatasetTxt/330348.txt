modules via concept analysis abstractwe describe general technique identifying modules legacy code method based concept analysisa branch lattice theory used identify similarities among set objects based attributes discuss concept analysis identify potential modules using positive negative information present algorithmic framework construct lattice concepts program concept represents potential module define notion concept partition present algorithm discovering concept partitions given concept lattice prove algorithm correct b introduction many existing software systems developed using programming languages paradigms incorporate objectoriented features design principles systems often monolithic style makes maintenance enhancement arduous task software engineers job would less difficult tools could transform code make explicit use modules functionally equivalent objectoriented code make use modules classes given tool partially automate transformation legacy systems could modernized making easier maintain modularization programs offers added benefit increased opportunity code reuse major difficulty software modularization accurate identification potential modules classes paper describes technique known concept analysis help automate modularization main contributions paper ffl show apply concept analysis modularization problem ffl previous work modularization problem made use positive information modules identified based properties function f uses variable x f argument type sometimes case module identified values types depend upon example function f uses fields struct queue fields struct stack concept analysis allows positive negative information incorporated modularization criterion see section 32 ffl unlike several previously proposed techniques conceptanalysis approach offers ability stay within system opposed applying ad hoc methods first suggested modularization judged inadequate proposed modularization fine scale user move partition lattice see section 4 proposed modularization coarse user add additional attributes identify concepts see section 3 ffl implemented prototype tool uses concept analysis propose modularizations c programs implementation tested several small mediumsized examples largest example consists 28000 lines source code see section 5 example consider c implementation stacks queues shown figure 1 queues represented two stacks one front one back information shifted front stack back stack back stack empty queue functions make use stack fields indirectly calling stack functions although stack queue functions written interleaved order would like able tease two components apart make separate classes one client c code given figure 2 paper discusses technique modules case c classes identified code delineate explicitly resulting information supplied suitable transformation tool maps c code c code aforementioned example although modularization algorithms able identify decomposition 2 14 unable handle variant example stack queue tightly intertwined see section 32 section 32 show concept analysis able group code latter example separate queue stack modules section 2 introduces contexts concept analysis algorithm building concept lattices contexts section 3 discusses process identifying modules c programs based concept analysis section 4 defines notion concept partition presents algorithm finding partitions concept lattice section 5 discusses implementation results section 6 concerns related work define struct stack f int base int sp int size struct queue f struct stack front struct stack back struct stack initstackint sz f struct stack struct stackmallocsizeofstruct stack return g struct queue initq f struct queue struct queuemallocsizeofstruct queue return q g int isemptystackstruct stack f return ssp sbase g int isemptyqstruct queue q f return isemptystackqfront isemptystackqback g void pushstruct stack int overflow check void enqstruct queue q int f pushqfront g int popstruct stack f isemptystacks return 1 return ssp g int deqstruct queue q f isemptyqq return 1 isemptystackqback pushqback popqfront return popqback g figure 1 c code implement queue using two stacks define class stack f private int base int public stackint new int isempty f return sp base g int pop f isempty return 1 return sp void pushint f overflow check class queue f private stack front back public new stackqueue size back new stackqueue size g int isempty f return frontisempty backisempty g int deq f isempty return 1 backisempty return backpop void enqint f frontpushi g figure 2 queue stack classes c concept analysis provides way identify sensible groupings objects common attributes illustrate concept analysis consider example crude classification group mammals cats chimpanzees dogs dolphins humans whales suppose consider five tributes fourlegged haircovered intelligent marine thumbed table 1 shows animals considered attributes attributes fourlegged haircovered intelligent marine thumbed cats chimpanzees objects dogs dolphins humans whales table 1 crude characterization mammals order understand basics concept analysis definitions required follow presentation 11 context triple finite sets objects attributes respectively r binary relation mammal example objects different kinds mammals attributes characteristics fourlegged haircovered etc binary relation r given table 1 example tuple whales marine r cats intelligent mappings attributes x common objects form galois connection mappings satisfy mappings antimonotone extensive mammal example oefcats fhaircoveredg concept pair sets set objects extent set attributes intent concept maximal collection objects sharing common attributes example fcats dogsg ffourlegged haircoveredg concept whereas fcats chimpanzeesg fhaircoveredg concept concept x 0 subconcept concept x 1 equivalently 1 instance fdolphins whalesg fintelligent marineg subconcept fchimpanzees dolphins humans whalesg fintelligentg subconcept relation forms complete partial order concept lattice set concepts concept lattice mammal example shown figure 3 top fcats chimpanzees dogs dolphins humans whalesg fchimpanzees dolphins humans whalesg fintelligentg fcats chimpanzees dogsg fhaircoveredg fchimpanzees humansg fintelligent thumbedg fdolphins whalesg fintelligent marineg fcats dogsg fhaircovered fourleggedg bot ffourlegged haircovered intelligent marine thumbedg figure 3 concept lattice accompanying key mammal example fundamental theorem concept lattices 12 relates subconcepts superconcepts follows g i2i oe i2i i2i significance theorem least common superconcept set concepts computed intersecting intents taking union extents finding common objects set common attributes resulting union example application fundamental theorem follows computation corresponds fact c 1 c lattice shown figure 3 several algorithms computing concept lattice given context 11 describe simple bottomup algorithm important fact concepts contexts used algorithm given set objects x smallest concept extent containing x oex oex thus bottom element concept lattice oe oe concept consisting objects attributes often empty set example initial step algorithm compute bottom concept lattice next step compute atomic concepts smallest concepts extent containing objects treated singleton set atomic concepts correspond nodes concept lattice reachable bottom node one step computation atomic concepts mammal example shown algorithm closes set atomic concepts join initially worklist formed containing pairs atomic concepts c c 6 c 0 c 0 6 c worklist empty remove element worklist c 0 using fundamental theorem concept analysis c 00 concept yet discovered add pairs concepts c c 6 c 00 c 00 6 c worklist process repeated worklist empty iterative step conceptbuilding algorithm illustrated 3 using concept analysis identify potential modules main idea paper apply concept analysis problem identifying potential modules within monolithic code outline process follows 1 build context objects functions defined input program attributes properties functions attributes could several properties relating functions data structures attributes discussed detail 2 construct concept lattice context described section 2 3 partitions collections concepts whose extents partition set ob jects concept partition corresponds possible modularization input program concept partitions discussed section 4 31 applying concept analysis stack queue example consider stack queue example introduction section demonstrate concept analysis used identify module partition indicated c code figure page 4 first define context let objects 0 attributes ff 0 ff correspond functions properties functions indicated tables return type struct stack return type struct initq argument type struct stack argument type struct queue uses fields struct stack uses fields struct queue context relation stack queue example next step build concept lattice context described section 2 concept lattice stack queue example together key identifying latticenode labels corresponding concepts shown bot fff 0 g empty concept one advantages using concept analysis multiple possibilities modularization offered addition relationships among concepts concept lattice also offers insight structure within proposed modules example atomic level initialization functions concepts c 0 c 2 distinct concepts functions concepts c 1 c 3 former two concepts correspond constructors latter two member functions concept corresponds stack module c 5 corresponds queue module subconcept relationships indicate stack concept consists constructor concept memberfunction concept 32 adding complementary attributes untangle code stack queue example considered thus far demonstrated full power concept analysis brings modularization problem relatively straightforward separate code shown figure 1 two modules techniques described 2 14 also create grouping essence concept analysis described emulates techniques shows concept analysis encompasses previously defined methods modularization show concept analysis offers possibility go beyond previously defined methods offers ability tease apart code sense tangled illustrate mean tangled code consider slightly modified stack queue example suppose functions isemptyq enq written modify stack fields directly see figure 4 rather calling isemptystack push may efficient makes code difficult maintain simple changes stack implementation may require changes queue code furthermore complicates process identifying separate modules apply concept analysis using set attributes attribute ff 4 uses fields struct stack applies isemptyq enq table 2 shows context relation tangled stack queue code original sets objects attributes resulting concept lattice shown figure 5 observe concept c 5 still identified queue module none concepts coincide stack module particular even though extent c 0 finitstackg extent c 2 fisemptystack push popg concept stack concept c 7 consists initstack isemptystack isemptyq push enq pop mixes stack operations queue operations int isemptyqstruct queue q f return qfrontsp qfrontbase qbacksp qbackbase void enqstruct queue q int f figure 4 queue stack example revisited tangled c code table 2 context relation tangled stack queue example top f 0 c 7 g queue concept c 6 bot fff figure 5 concept lattice corresponding key tangled stack queue example using attributes listed page 8 problem attributes listed page 8 reflect positive information distinguishing characteristic stack operations depend fields struct stack fields struct queue untangle components need augment set attributes negative information case complement uses fields struct queue ie use fields struct queue revised set attributes corresponding context relation shown return type struct stack return type struct initq argument type struct stack ff 3 argument type struct queue uses fields struct stack uses fields struct queue ff 6 use fields struct queue ff 6 resulting concept lattice corresponding key top f 0 c 7 g queue concept stack concept c 6 g initstack bot fff 0 g empty concept concept lattice contains concepts concept lattice figure 5 well additional concept c 4 corresponds stack module modularization identifies isemptyq enq part queue module separate stack module even though two operations make direct use stack fields raises issues subsequent ctoc codetransformation phase although one might able devise transformations remove dependences queue operations private members stack class eg introducing appropriate calls member functions stack class straightforward ctoc transformation would simply use c friend mechanism shown figure 6 33 choices attributes concept maximal collection objects common properties cohesive module collection functions perhaps along data structure common properties therefore employing concept analysis modularization problem reasonable objects define class queue class stack f friend class queue private int base int public stackint new int isempty f return sp base g int pop f isempty return 1 return sp void pushint f overflow check class queue f private stack front back public new stackqueue size back new stackqueue size g int return frontsp frontbase backsp backbase void enqint f int deq f isempty return 1 backisempty return backpop figure queue stack classes c friends correspond functions however flexibility comes attributes wide variety attributes might choose effort identify concepts modules program examples used attributes reflect way struct data types used instances may useful use attributes capture properties possibilities attributes include following ffl variableusage information related functions sometimes identified use common global variables attribute capturing information might form uses global variable x ffl dataflow slicing information useful identifying modules attributes capturing information might form may use value flows statement part slice respect statement ffl information obtained type inferencing type inference used uncover distinctions seemingly identical types 10 9 example f function declared type int theta int bool type inference might discover f general type form ff theta fi bool reveals type f first argument distinct type second argument even though declared type attributes might form argument type ff rather simply argument type int would prevent functions grouped together merely superficial similarities declared types arguments ffl disjunctions attributes user may aware certain properties input program perhaps similarity two data structures disjunctive attributes allow user specify properties form 1 2 example uses fields stack uses fields queue attributes could used together one context highlights one advantages conceptanalysis approach modularization represents single algorithm modularization rather provides framework obtaining collection different modularization algorithms 4 concept module partitions thus far discussed concept lattice built program way concepts represent potential modules however overlaps concepts every group concepts represents potential modularization feasible modularizations partitions collections modules disjoint include functions input code limit number choices software engineer would presented helpful identify partitions formalize notion concept partition present algorithm identify partitions concept lattice 41 concept partitions given context ar concept partition set concepts whose extents form partition partition extents concepts cover object set ie pairwise disjoint x terms modularizing program concept partition corresponds collection modules every function program associated exactly one module simple example consider concept lattice shown page 11 concept partitions context listed ftopg atomic partition p 2 p 3 combinations atomic concepts larger concepts p 4 consists one stack module one queue module p 5 trivial partition functions placed one module looking concept partitions software engineer eliminate nonsensical possibilities preceding example c 7 appear partition module ie nonoverlapping concept would deq belong atomic partition concept lattice concept partition consisting exactly atomic concepts recall atomic concepts concepts smallest extent containing objects treated singleton set instance see atomic concepts mammal example page 7 concept lattice need atomic partition example lattice figure 3 page atomic partition atomic concepts c 0 c 3 however c 1 c 3 overlap object chimpanzees extent concepts atomic partition concept lattice often good starting point choosing modularization program order develop tools work concept partitions useful able guarantee existence atomic partitions achieved augmenting context negative information similar section 32 given context ar complement attribute 2 attribute rg attribute exactly objects property example attribute table page 11 ff 5 ff 6 complements given context complemented extension c context c ag r rg complemented extension context original context attribute set augmented addition complement every original attribute straightforward see every context complemented extension concept lattice complemented extension atomic partition using fact present algorithm find partitions concept lattice 42 finding partitions concept lattice given concept lattice define following relations elements set immediate suprema concept x denoted supsx set lattice elements x elements z x z set ancestors x denoted ancsx set lattice elements x 6 x 1 sups atomic partition 4 w 6 remove p w 6 c 2 p c 0 2 supsc disjoint 14 endif 15 endif 16 endfor 17 endfor 18 endwhile figure 7 algorithm find partitions concept lattice algorithm builds collection partitions concept lattice let p collection partitions forming let w worklist partitions begin atomic partition set immediate suprema bottom element concept lattice p w initialized singleton set containing atomic partition algorithm works considering partitions worklist w w empty partition removed w new partitions formed possible selecting concept partition choosing supremum concept adding partition removing overlapping concepts algorithm given figure 7 worst case number partitions exponential number concepts case case number partitions large possible adapt algorithm work interactively new partition discovered algorithm would pause user consider partition fine scale user would allow algorithm iterate find coarsergrained partitions 5 implementation results implemented prototype tool employs concept analysis propose modularizations c programs written standard ml new jersey version 10924 runs sun solaris 251 prototype takes c program input default object set set functions defined input program default attribute set consists one attribute form uses fields struct userdefined struct type equivalent typedef input program user option include attributes form parameter return type type context formed formed fully complemented form userdefined struct type attributes formdoes use fields struct parameter return type type included attribute set context context fed concept analyzer builds concepts bottom described section 2 user view concept lattice feed lattice parti tioner computes depending users choice possible partitions one partition time examples paper analyzed implementation preliminary results larger examples appear promising particular used prototype tool spec 95 benchmark go many faces go program consists roughly 28000 lines c code 372 functions 8 userdefined data types concept lattice fully complemented context associated functions data types consists thirtyfour concepts constructed seconds user time sparcstation 10 64mb ram partitioner identified possible partitions lattice roughly amount time 51 case study chullc chullc program taken computationalgeometry library computes convex hull set vertices plane program consists roughly one thousand lines c code twentysix functions three userdefined struct data types tvertex tedge tface representing vertices edges faces respectively context fed concept analyzer consisted twentysix functions object set six attributes uses fields tvertex use fields tvertex etc binary relation indicating whether function f uses fields one struct types concept analyzer built twentyeight concepts corresponding lattice roughly one second user time lattice appears figure 8 partitioner computed 153 possible partitions concept lattice roughly two seconds figure 8 concept lattice derived chullc atomic partition groups functions eight concepts listed table 3 partition indicates code cleanly break three modules eg one struct type however assuming goal transform chullc equivalent c program eight concepts suggest possible modularization based three types concepts 2 3 4 would correspond three classes vertex edge face respectively concept 1 would correspond driver module functions concepts 5 8 would form four friend modules functions would declared friend appropriate classes concept number userdefined struct types functions makevertex readvertices collinear constructhull printvertices 3 tedge makeedge 4 tface cleanfaces makeface 5 tvertex tedge cleanvertices printedges 6 tvertex tface volume6 volumed convexity printfaces 7 tedge tface makeccw cleanedges consistency 8 tvertex tedge tface print tetrahedron addone makestructs checks table 3 atomic partition concept lattice derived chullc 6 related work although growing body literature concerning module abstractdatatype recovery nonmodular code eg 13 6 unaware previous work problem involving use concept analysis modularization reflects design decision inherently subjective unlikely modularization process ever fully automated given user interaction required conceptanalysis approach offers certain advantages previously proposed techniques namely ability stay within system opposed applying ad hoc methods user judges modularization system suggests unsatisfactory proposed modularization fine scale user move partition lattice see section 4 proposed modularization coarse user add additional attributes generate concepts see section 3 furthermore concept analysis really provides family modularization algorithms rather offering one fixed technique different attributes chosen different conditions work closely related liu wilde 8 makes use table much like objectattribute relation context however whereas work uses concept analysis analyze tables liu wilde propose less powerful analysis also propose user intervene ad hoc adjustments results modularization unsatisfactory explained conceptanalysis approach naturally generate variety possible decompositions ie different collections concepts partition set objects conceptanalysis approach general canfora et al 2 identifies abstract data types analyzing graph links functions argument types return types information captured using context objects functions attributes possible argument return types example attributes attribute table page 8 adding attributes indicate whether fields compound data types used function done example used paper conceptanalysis becomes powerful tool identifying potential modules technique described 2 work described 3 4 expands abstractdatatype identification technique described 2 call dominance information used introduce hierarchical nesting structure modules may possible combine techniques 3 4 conceptanalysis approach present paper conceptanalysis approach also general technique used obad tool 14 designed identify abstract data types c programs obad analyzes graph consists nodes representing functions struct types edges representing use internal fields struct type function recovers similar information concept analysis attributes exactly indicating use fields struct types example ff 5 table 31 page 8 however obad stumble tangled code like example discussed section 32 additional discriminatory power conceptanalysis approach due fact able exploit positive negative information contrast approach identifying objects described 1 technique aimed analyzing relationships among functions types identify classes 1 aim identify objects link functions specific variables similar effect achieved via concept analysis introducing one attribute actual parameter certain amount work involving use cluster analysis identify potential modules eg 5 1 7 work implicitly explicitly involves identification potential modules determining similarity measure among pairs functions currently investigating link concept analysis cluster analysis concept analysis previously applied softwareengineering tool albeit problem much different modularization norarecs tool uses concept analysis identify conflicts softwareconfiguration information 11 acknowledgements work supported part national science foundation grant ccr9625667 defense advanced research projects agency arpa order 8856 monitored office naval research contract n0001492j1937 comments manuvir das work reported paper greatly appreciated r greedy approach object identification imperative code experiments identifying reusable abstract data types program code program comprehension identification abstract data types system structure analysis clustering data bindings evaluating process clusters support automatic program understanding objects conventional procedural language example data design recovery practical program understanding type inference program generalization software reuse c c reengineering configurations based mathematical concept analysis restructuring lattice theory approach based hierarchies concepts second working conference reverse engineering recovering abstract data types object instances conventional procedural language tr ctr peter wendorff formal approach assessment improvement terminological models used information systems engineering acm sigsoft software engineering notes v26 n5 sept 2001 fuhgwo chen tingwei hou instructioncoated translation approach restructure directly threaded interpreters low cohesion acm sigplan notices v41 n8 august 2006 kamran sartipi kostas kontogiannis userassisted approach component clustering journal software maintenance research practice v15 n4 p265295 july andrew sutton jonathan maletic recovering uml class models c detailed explanation information software technology v49 n3 p212229 march 2007 di penta neteler g antoniol e merlo languageindependent software renovation framework journal systems software v77 n3 p225240 september 2005 andreas christl rainer koschke margaretanne storey automated clustering support reflexion method information software technology v49 n3 p255274 march 2007 rainer koschke gerardo canfora jrg czeranski revisiting ic approach component recovery science computer programming v60 n2 p171188 april 2006 gerardo canforaharman massimiliano di penta new frontiers reverse engineering 2007 future software engineering p326341 may 2325 2007